<?xml version="1.0" encoding="iso-8859-15"?>
<!--
     The FreeBSD Italian Documentation Project

     $FreeBSD$
     Original revision: 1.152
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="basics">
  <info><title>Basi di Unix</title>
    <authorgroup>
      <author><personname><firstname>Chris</firstname><surname>Shumway</surname></personname><contrib>Riscritto da </contrib></author>
    </authorgroup>
  </info>

  

  <sect1 xml:id="basics-synopsis">
    <title>Sinossi</title>

    <para>Il seguente capitolo tratta i comandi e le
      funzionalità di base del sistema operativo
      FreeBSD.  Molto di questo materiale è
      valido anche per altri sistemi operativi &unix;-like.
      Sentiti libero di leggere velocemente questo capitolo se hai
      familiarità con questo materiale.  Se sei un utente
      alle prime armi di FreeBSD, allora dovrai di
      sicuro leggere questo capitolo attentamente.</para>

    <para>Dopo aver letto questo capitolo, saprai:</para>

    <itemizedlist>
      <listitem>
        <para>Come usare le <quote>console virtuali</quote> di FreeBSD.</para>
      </listitem>

      <listitem>
        <para>Come funzionano i permessi dei file &unix; oltre ad una
          spiegazione dei flag sotto &os;.</para>
      </listitem>

      <listitem>
        <para>La struttura di default del file system di &os;.</para>
      </listitem>

      <listitem>
        <para>L'organizzazione del disco di &os;.</para>
      </listitem>

      <listitem>
        <para>Come montare e smontare i file system.</para>
      </listitem>

      <listitem>
        <para>Cosa sono i processi, i demoni e i segnali.</para>
      </listitem>

      <listitem>
        <para>Cos'è una shell, e come cambiare il proprio ambiente di
          login di default.</para>
      </listitem>

      <listitem>
        <para>I principi di base sull'uso degli editor testuali.</para>
      </listitem>

      <listitem>
        <para>Cosa sono i dispositivi e i nodi dei dispositivi.</para>
      </listitem>

      <listitem>
        <para>Quali formati dei binari sono usati in &os;.</para>
      </listitem>

      <listitem>
        <para>Come leggere le pagine man per ottenere maggiori
          informazioni.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="consoles">
    <title>Console Virtuali e Terminali</title>

    <indexterm><primary>console virtuali</primary></indexterm>
    <indexterm><primary>terminali</primary></indexterm>

    <para>FreeBSD può essere usato in vari modi.  Uno di questi
      è quello di digitare i comandi tramite un terminale
      testuale.  Quando si utilizza FreeBSD in questo modo si ha
      velocemente nelle proprie mani molta della flessibilità
      e della potenza di un sistema operativo &unix;.
      Questa sezione descrive cosa sono i <quote>terminali</quote> e le
      <quote>console</quote>, e come si possono utilizzare in FreeBSD.</para>

    <sect2 xml:id="consoles-intro">
      <title>La console</title>

      <indexterm><primary>console</primary></indexterm>

      <para>Se non hai configurato FreeBSD in modo tale da avviare in
        modo automatico l'ambiente grafico durante l'avvio, il
        sistema ti fornirà un prompt di login dopo la fase di
        avvio, esattamente dopo che gli script di avvio sono stati
        eseguiti.  Dovresti vedere qualcosa simile a questo:</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:</screen>

      <para>I messaggi potrebbero essere leggermente diversi sul tuo
        sistema, tuttavia dovresti vedere qualcosa di analogo.  In
        questo momento ci interessano le ultime due righe.  Analizziamo
        la penultima riga:</para>

      <programlisting>FreeBSD/i386 (pc3.example.org) (ttyv0)</programlisting>

      <para>Questa riga contiene alcune informazioni sul sistema che hai
        appena avviato.  Sei di fronte a una console
        <quote>FreeBSD</quote>, che sta girando su un processore Intel
        o su un processore compatibile con l'architettura x86<footnote>
          <para>Questo è il significato di <literal>i386</literal>.
            Nota che anche se non stai eseguendo FreeBSD su una CPU della serie
            386 di Intel, questo messaggio resta <literal>i386</literal>.  Non
            si riferisce al tipo del tuo processore, ma bensì
            all'<quote>architettura</quote> del processore.</para></footnote>.
        Il nome di questa macchina (tutte le macchine &unix; hanno un nome)
        è <systemitem>pc3.example.org</systemitem>, e in questo momento sei di
        fronte alla sua console di sistema&mdash;il terminale
        <filename>ttyv0</filename>.</para>

      <para>Infine, l'ultima riga è sempre:</para>

      <programlisting>login:</programlisting>

      <para>Qui devi digitare il tuo <quote>username</quote> per
        loggarti in FreeBSD.  La prossima sezione descrive come
        fare ad effettuare il login su FreeBSD.</para>
    </sect2>

    <sect2 xml:id="consoles-login">
      <title>Loggarsi in FreeBSD</title>

      <para>FreeBSD è un sistema multi-utente e multi-processo.
        Questa è la descrizione formale che viene usualmente
        attribuita a un sistema che può essere usato da diverse
        persone, le quali eseguono contemporaneamente molti programmi
        su una singola macchina.</para>

      <para>Ogni sistema multi-utente necessita di qualche metodo che
        distingua un <quote>utente</quote> in modo univoco.  In
        FreeBSD (e in tutti i sistemi operativi &unix;-like), questo
        viene realizzato richiedendo che ogni utente debba
        <quote>loggarsi</quote> nel sistema prima che possa
        eseguire qualche programma.  Ogni utente ha un nome univoco (lo
        <quote>username</quote>), uno personale e una chiave segreta
        (la <quote>password</quote>).  FreeBSD richiede entrambe
        queste due cose prima di dare la possibilità ad un
        utente di eseguire qualche programma.</para>

      <indexterm><primary>script di avvio</primary></indexterm>

      <para>Appena dopo la fase di avvio di FreeBSD e quando gli script
        di avvio sono stati eseguiti<footnote>
          <para>Gli script di avvio sono programmi che vengono eseguiti in
            modo automatico durante la fase di avvio di FreeBSD.  Il
            loro compito principale è quello di impostare l'ambiente
            che potrà essere utilizzato da qualsiasi altro programma che
            venga eseguito, ed avviare i servizi che hai configurato in
            modo tale da essere eseguiti in background per realizzare
            cose utili.</para>
        </footnote>, ti viene presentato un prompt dove inserire un valido
        username:</para>

      <screen>login:</screen>

      <para>Giusto per questo esempio, assumiamo che il tuo username
        sia <systemitem class="username">john</systemitem>.  Al prompt digita
        <literal>john</literal> e premi <keycap>Invio</keycap>.  Ti
        verrà presentato un prompt dove inserire la
        <quote>password</quote>:</para>

      <screen>login: <userinput>john</userinput>
Password:</screen>

      <para>Digita la password di <systemitem class="username">john</systemitem>, e
        premi <keycap>Invio</keycap>.  La password
        <emphasis>non viene visualizzata!</emphasis>  Non ti devi
        preoccupare di questo per ora.  È sufficiente sapere
        che è una questione di
        sicurezza.</para>

      <para>Se hai digitato la tua password in modo corretto,
        dovresti essere loggato in FreeBSD e sei quindi pronto per
        provare tutti i comandi disponibili.</para>

      <para>Dovresti inoltre vedere il messaggio del giorno
        (<acronym>MOTD</acronym>) seguito da un prompt dei comandi (un
        carattere <literal>#</literal>, <literal>$</literal>, o
        <literal>%</literal>).  Ciò
        indica che sei a tutti gli effetti loggato su FreeBSD.</para>
    </sect2>

    <sect2 xml:id="consoles-virtual">
      <title>Console Multiple</title>

      <para>Eseguire comandi &unix; in una sola console va bene,
        tuttavia FreeBSD può eseguire più programmi alla
        volta.  Avere una sola console dove poter digitare i comandi
        può essere un pò uno spreco quando un sistema
        operativo come FreeBSD è in grado di eseguire dozzine di
        programmi contemporaneamente.  È
        in questo caso che le <quote>console virtuali</quote> possono essere
        molto utili.</para>

      <para>FreeBSD può essere configurato in modo tale da poter
        utilizzare differenti console virtuali.  Puoi passare da una console
        virtuale ad un'altra digitando un paio di tasti sulla tastiera.  Ogni
        console ha il proprio canale di output indipendente, e FreeBSD si
        occupa di redirigere correttamente l'input della tastiera e l'output del
        monitor quando passi da una console virtuale in un'altra.</para>

      <para>In FreeBSD alcune combinazioni speciali di tasti sono state
        riservate per il passaggio tra le console<footnote>
          <para>Una descrizione abbastanza tecnica ed accurata di tutti i
            dettagli della console di FreeBSD e dei driver della tastiera
            può essere trovata nelle pagine man di &man.syscons.4;,
            &man.atkbd.4;, &man.vidcontrol.1; e &man.kbdcontrol.1;.  Qui non
            approfondiremo i dettagli, ma il lettore interessato può
            sempre consultare le pagine man per una spiegazione dettagliata
            e completa su come funzionano queste cose.</para>
        </footnote>.  Puoi usare
        <keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
        <keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo>, fino a
        <keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo> per
        cambiare console su FreeBSD.</para>

      <para>Quando passi da una console ad un'altra, FreeBSD si preoccupa di
        salvare e ripristinare l'output a video.  Il risultato è
        l'<quote>illusione</quote> di avere più schermi e più
        tastiere <quote>virtuali</quote> che puoi utilizzare per dare in pasto a
        FreeBSD dei comandi.  I programmi che lanci su una console virtuale
        rimarranno in esecuzione anche quando la console non è visibile.
        L'esecuzione di questi programmi continua quando passi in un'altra
        console virtuale.</para>
    </sect2>

    <sect2 xml:id="consoles-ttys">
      <title>Il File <filename>/etc/ttys</filename></title>

      <para>La configurazione di default di FreeBSD prevede l'avvio del sistema
        con otto console virtuali.  Comunque questo non è un settaggio
        obbligatorio, e puoi facilmente personalizzare la tua installazione in
        modo tale da avviare il sistema con qualche console virtuale in
        più o in meno.  Il numero e i settaggi delle console virtuali sono
        configurati nel file <filename>/etc/ttys</filename>.</para>

      <para>Puoi usare il file <filename>/etc/ttys</filename> per configurare
        le console virtuali di FreeBSD.  In questo file ogni riga non commentata
        (le righe che non iniziano con il carattere <literal>#</literal>)
        contiene i settaggi di un singolo terminale o di una singola console.
        La versione di default di questo file contenuta in FreeBSD
        configura nove console virtuali, ed abilita otto di queste.  Sono
        le righe che iniziano con <literal>ttyv</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Terminali virtuali
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>Per una descrizione più dettagliata su ogni colonna di questo
        file e per tutte le opzioni che puoi utilizzare per settare le console
        virtuali, consulta la pagina man &man.ttys.5;.</para>
    </sect2>

    <sect2 xml:id="consoles-singleuser">
      <title>Console in Modalità Single User</title>

      <para>Una descrizione dettagliata del significato della
        <quote>modalità single user</quote> può essere trovata
        nella <xref linkend="boot-singleuser"/>.  È bene notare che
        c'è un'unica console quando avvii FreeBSD in modalità
        single user.  Le console virtuali non sono disponibili.  Anche i
        settaggi della console in modalità single user possono essere
        trovati nel file <filename>/etc/ttys</filename>.  Guarda la riga che
        inizia con <literal>console</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
# Se la console è definita "insecure", allora il processo init richiederà la password di root
# quando entrerai in modalità single-user.
console none                            unknown off secure</programlisting>

      <note>
        <para>Come riportato nel commento sopra la riga
          <literal>console</literal>, puoi modificare questa riga cambiando
          <literal>secure</literal> in <literal>insecure</literal>.  Se lo fai,
          quando FreeBSD viene avviato in modalità single user,
          verrà chiesta la password di <systemitem class="username">root</systemitem>.</para>

        <para><emphasis>Pensaci comunque due volte a settare il parametro
          <literal>insecure</literal></emphasis>.  Se non ricordi più
          la password di <systemitem class="username">root</systemitem>, riuscire ad avviare il
          sistema in modalità single user sarà molto complesso.
          È ancora possibile, ma potrebbe essere molto difficile per chi
          non conosce molto bene il meccanismo di avvio di FreeBSD e i relativi
          programmi.</para>
      </note>
    </sect2>

    <sect2 xml:id="consoles-vidcontrol">
      <title>Modifica delle Modalità Video della Console</title>

      <para>La modalità video di default della console di FreeBSD
        può essere impostata a 1024x768, 1280x1024, o ad un altra
        risoluzione supportata dalla tua scheda grafica e dal tuo monitor.
        Per usare una modalità video differente, devi prima
        ricompilare il tuo kernel aggiungendo due opzioni:</para>

      <programlisting>options VESA
options SC_PIXEL_MODE</programlisting>

      <para>Quando il kernel è stato ricompilato con queste due opzioni,
        puoi determinare quali modalità video sono supportate
        dal tuo hardware usando l'utility &man.vidcontrol.1;.
        Per ottenere una lista delle modalità video supportate,
        digita il seguente comando:</para>

      <screen>&prompt.root; <userinput>vidcontrol -i mode</userinput></screen>

      <para>L'output di questo comando è una lista delle
        modalità video che sono supportate dal tuo hardware.
        Puoi usare una nuova modalità video indicandola a
        &man.vidcontrol.1; in una console <systemitem class="username">root</systemitem>:</para>

      <screen>&prompt.root; <userinput>vidcontrol MODE_279</userinput></screen>

      <para>Se la nuova modalità è soddisfacente, può
        essere impostata in modo permanente ad ogni avvio nel file
        <filename>/etc/rc.conf</filename>:</para>

      <programlisting>allscreens_flags="MODE_279"</programlisting>
    </sect2>
  </sect1>

  <sect1 xml:id="permissions">
    <title>I Permessi</title>

    <indexterm><primary>UNIX</primary></indexterm>

    <para>FreeBSD, essendo un discendente diretto dello &unix; BSD, si basa su
      molti concetti chiave di &unix;.  Il primo e il più affermato
      è che FreeBSD è un sistema operativo multi-utente.
      Il sistema può gestire diversi utenti che lavorano
      contemporaneamente su operazioni indipendenti.  Il sistema è
      responsabile della gestione e della suddivisione appropriata delle
      richieste di utilizzo dei dispositivi hardware, delle periferiche, della
      memoria, e del tempo di CPU in modo equo per ogni utente.</para>

    <para>Poichè il sistema è in grado di supportare più
      utenti, tutto ciò che il sistema gestisce possiede un insieme di
      permessi che determinano chi può leggere, scrivere, ed eseguire la
      risorsa.  Questi permessi sono memorizzati mediante tre ottetti
      suddivisi in tre parti, una per il proprietario del file, una per il
      gruppo al quale il file appartiene, e una per tutti gli altri.  Questa
      rappresentazione numerica funziona in questo modo:</para>

    <indexterm><primary>permessi</primary></indexterm>
    <indexterm><primary>permessi dei file</primary></indexterm>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="3">
        <thead>
          <row>
            <entry>Valore</entry>

            <entry>Permessi</entry>

            <entry>Listato nella Directory</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>0</entry>

            <entry>Lettura no, scrittura no, esecuzione no</entry>

            <entry><literal>---</literal></entry>
          </row>

          <row>
            <entry>1</entry>

            <entry>Lettura no, scrittura no, esecuzione</entry>

            <entry><literal>--x</literal></entry>
          </row>

          <row>
            <entry>2</entry>

            <entry>Lettura no, scrittura, esecuzione no</entry>

            <entry><literal>-w-</literal></entry>
          </row>

          <row>
            <entry>3</entry>

            <entry>Lettura no, scrittura, esecuzione</entry>

            <entry><literal>-wx</literal></entry>
          </row>

          <row>
            <entry>4</entry>

            <entry>Lettura, scrittura no, esecuzione no</entry>

            <entry><literal>r--</literal></entry>
          </row>

          <row>
            <entry>5</entry>

            <entry>Lettura, scrittura no, esecuzione</entry>

            <entry><literal>r-x</literal></entry>
          </row>

          <row>
            <entry>6</entry>

            <entry>Lettura, scrittura, esecuzione no</entry>

            <entry><literal>rw-</literal></entry>
          </row>

          <row>
            <entry>7</entry>

            <entry>Lettura, scrittura, esecuzione</entry>

            <entry><literal>rwx</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary><command>ls</command></primary></indexterm>
    <indexterm><primary>directory</primary></indexterm>

    <para>Puoi usare l'opzione <option>-l</option> del comando &man.ls.1; per
      visualizzare un lungo listato della directory che include una colonna
      contenente le informazioni sui permessi del file per il proprietario, per
      il gruppo, e per gli altri.  Per esempio, digitando <command>ls
        -l</command> in una arbitraria directory:</para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...</screen>

    <para>Ecco come è suddivisa la prima colonna dell'output del comando
      <command>ls -l</command>:</para>

    <screen>-rw-r--r--</screen>

    <para>Il primo carattere (partendo da sinistra) indica se il file in
      questione è un file regolare, una directory, un file speciale per
      dispositivi a caratteri, una socket, o un file speciale per altri
      dispositivi.  Nel nostro caso, il <literal>-</literal> indica un
      file regolare.  I tre caratteri successivi, che in questo esempio sono
      <literal>rw-</literal>, indicano i permessi per il proprietario del file.
      Seguono altri tre caratteri, <literal>r--</literal>, che indicano i
      permessi del gruppo al quale il file appartiene.  Gli ultimi tre
      caratteri, <literal>r--</literal>, indicano i permessi per il resto del
      mondo.  Un trattino significa che il permesso non viene concesso.
      Nel caso di questo file, i permessi sono settati affinchè il
      proprietario possa leggere e scrivere il file, il gruppo possa leggere
      il file, e il resto del mondo possa solamente leggere il file.  In accordo
      con la precedente tabella, i permessi per questo file sono
      <literal>644</literal>, dove ogni cifra rappresenta una delle tre parti
      che costituiscono i permessi del file.</para>

    <para>D'accordo, ma in che modo il sistema controlla i permessi sui dispositivi?
      FreeBSD tratta molti dispositivi hardware esattamente come un file che i
      programmi possono aprire, leggere, e scrivere dei dati proprio come
      avviene con gli altri file.  Questi file speciali per i dispositivi sono
      memorizzati nella directory <filename>/dev</filename>.</para>

    <para>Anche le directory sono trattate come file.  Queste hanno permessi di
      lettura, scrittura e di esecuzione.  Il bit riferito al permesso di
      esecuzione per una directory ha un significato leggermente differente
      rispetto a quello dei file.  Quando una directory ha il permesso di
      esecuzione abilitato, significa che si ha accesso alla directory, ossia
      è possibile eseguire il comando <quote>cd</quote> (cambio di
      directory) per entrarci.  Inoltre questo significa che all'interno della
      directory è possibile accedere ai file dei quali si conosce il nome
      (naturalmente a condizione dei permessi degli stessi file).</para>

    <para>In particolare, per visualizzare il contenuto di una directory, deve
      essere abilitato il permesso di lettura sulla stessa, mentre per
      eliminare un file di cui si conosce il nome, è necessario che la
      directory contenente il file abbia i permessi di scrittura
      <emphasis>e</emphasis> di esecuzione abilitati.</para>

    <para>Ci sono altri bit per permessi particolari, ma sono in genere usati
      in circostanze speciali come il permesso di setuid per i binari e
      quello di sticky per le directory.  Se vuoi avere più informazioni
      sui permessi dei file e su come settarli, guarda la pagina man di
      &man.chmod.1;.</para>

    <sect2>
      <info><title>Permessi Simbolici</title>
        <authorgroup>
          <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Contributo di </contrib></author>
        </authorgroup>
      </info>

      

      <indexterm>
        <primary>permessi</primary><secondary>simbolici</secondary>
      </indexterm>

      <para>I permessi simbolici, qualche volta chiamati espressioni simboliche,
        usano caratteri al posto dei numeri ottali per assegnare i permessi a
        file o directory.  Le espressioni simboliche usano la sintassi (chi)
        (azione) (permessi), con i seguenti valori:</para>

      <informaltable frame="none" pgwide="1">
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Opzione</entry>

              <entry>Lettera</entry>

              <entry>Cosa rappresenta/Cosa fa</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>(chi)</entry>

              <entry>u</entry>

              <entry>Utente</entry>
            </row>

            <row>
              <entry>(chi)</entry>

              <entry>g</entry>

              <entry>Gruppo di appartenenza</entry>
            </row>

            <row>
              <entry>(chi)</entry>

              <entry>o</entry>

              <entry>Altri</entry>
            </row>

            <row>
              <entry>(chi)</entry>

              <entry>a</entry>

              <entry>Tutti (tutto il <quote>mondo</quote>)</entry>
            </row>

            <row>
              <entry>(azione)</entry>

              <entry>+</entry>

              <entry>Aggiunge i permessi</entry>
            </row>

            <row>
              <entry>(azione)</entry>

              <entry>-</entry>

              <entry>Rimuove i permessi</entry>
            </row>

            <row>
              <entry>(azione)</entry>

              <entry>=</entry>

              <entry>Setta esplicitamente i permessi</entry>
            </row>

            <row>
              <entry>(permessi)</entry>

              <entry>r</entry>

              <entry>Lettura</entry>
            </row>

            <row>
              <entry>(permessi)</entry>

              <entry>w</entry>

              <entry>Scrittura</entry>
            </row>

            <row>
              <entry>(permessi)</entry>

              <entry>x</entry>

              <entry>Esecuzione</entry>
            </row>

            <row>
              <entry>(permessi)</entry>

              <entry>t</entry>

              <entry>Bit sticky</entry>
            </row>

            <row>
              <entry>(permessi)</entry>

              <entry>s</entry>

              <entry>Setta UID o GID</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Questi valori sono usati con il comando &man.chmod.1;
        come esposto in precedenza, ma con le lettere.  Per esempio, puoi usare
        il seguente comando per impedire agli altri utenti l'accesso a
        <replaceable>FILE</replaceable>:</para>

      <screen>&prompt.user; <userinput>chmod go= FILE</userinput></screen>

      <para>Se si ha la necessità di realizzare più di una
        modifica ai settaggi di un file si può usare una lista di
        settaggi separati da virgola.  Per esempio il seguente comando
        rimuoverà il permesso di scrittura su
        <replaceable>FILE</replaceable> al gruppo di appartenenza del file e al
        resto del <quote>mondo</quote>, e inoltre aggiungerà
        il permesso di esecuzione per tutti:</para>

      <screen>&prompt.user; <userinput>chmod go-w,a+x FILE</userinput></screen>
    </sect2>

    <sect2>
      <info><title>Flag dei File in &os;</title>
        <authorgroup>
          <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Contributo di </contrib></author>
        </authorgroup>
      </info>

      

      <para>Oltre ai permessi dei file discussi in precedenza, &os;
        supporta l'uso dei <quote>flag dei file</quote>.  Queste flag
        aggiungono un ulteriore livello di sicurezza e di controllo sui
        file, ma non per le directory.</para>

      <para>Queste flag dei file aggiungono un ulteriore livello di
        controllo sui file, assicurando in alcuni casi che persino
        <systemitem class="username">root</systemitem> non possa rimuovere o alterare file.</para>

      <para>Le flag dei file sono alterate usando l'utility &man.chflags.1;,
        tramite una semplice sintassi.  Per esempio, per abilitare la flag
        di sistema di non-cancellabilità sul file
        <filename>file1</filename>, si può usare il comando
        seguente:</para>

      <screen>&prompt.root; <userinput>chflags sunlink file1</userinput></screen>

      <para>E per disabilitare la stessa flag, si può usare
        semplicemente il comando precedente con <quote>no</quote> davanti a
        <option>sunlink</option>.  Ecco come:</para>

      <screen>&prompt.root; <userinput>chflags nosunlink file1</userinput></screen>

      <para>Per vedere le flag del file di esempio, usa il comando
        &man.ls.1; con le flag <option>-lo</option>:</para>

      <screen>&prompt.root; <userinput>ls -lo file1</userinput></screen>

      <para>L'output dovrebbe assomigliare al seguente:</para>

      <programlisting>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1</programlisting>

      <para>Diverse flag possono essere aggiunte o rimosse sui file solo
        tramite l'utente <systemitem class="username">root</systemitem>.  Negli altri casi, il
        proprietario dei file può settare queste flag.  Si raccomanda
        di leggere le pagine man &man.chflags.1; e &man.chflags.2; per
        maggiori informazioni.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="dirstructure">
    <title>Struttura delle Directory</title>

    <indexterm><primary>gerarchia delle directory</primary></indexterm>

    <para>La gerarchia delle directory di FreeBSD è fondamentale per
      ottenere una comprensione globale del sistema.  Il concetto più
      importante da cogliere al volo è quello relativo alla directory
      root, <quote>/</quote>.  Questa directory è la prima ad essere
      montata all'avvio e contiene gli elementi fondamentali del sistema
      necessari per predisporre il sistema operativo al funzionamento
      multi-utente.  Inoltre la directory root contiene i punti di mount per
      gli altri file system che sono montati durante la transizione per
      il funzionamento multi-utente.</para>

    <para>Un punto di mount è una directory dove dei file system
      aggiuntivi possono essere innestati sul file system padre
      (in genere il file system root).
      Questo è ulteriormente descritto nella <xref linkend="disk-organization"/>.  Alcuni punti di
      mount standard sono <filename>/usr</filename>, <filename>/var</filename>,
      <filename>/tmp</filename>, <filename>/mnt</filename>, e
      <filename>/cdrom</filename>.  Queste
      directory compaiono in genere negli elementi del file
      <filename>/etc/fstab</filename>.  Il file <filename>/etc/fstab</filename>
      è una tabella di file system e punti di mount che viene consultata
      dal sistema.  Molti dei file system riferiti nel file
      <filename>/etc/fstab</filename> sono montati in modo automatico all'avvio
      tramite lo script &man.rc.8; a meno che essi sia stati dichiarati con
      l'opzione <option>noauto</option>.  Maggiori dettagli possono essere
      trovati nella <xref linkend="disks-fstab"/>.</para>

    <para>Una descrizione completa della gerarchia del file system è
      disponibile nella pagina man &man.hier.7;.  Per ora, è
      sufficiente una breve panoramica generale delle directory più
      comuni.</para>

    <para>
      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Directory</entry>

              <entry>Descrizione</entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><filename>/</filename></entry>

              <entry>Directory root del file system.</entry>
            </row>

            <row>
              <entry><filename>/bin/</filename></entry>

              <entry>Utilità fondamentali per l'utente sia in ambiente
                mono-utente sia in ambiente multi-utente.</entry>
            </row>

            <row>
              <entry><filename>/boot/</filename></entry>

              <entry>Programmi e file di configurazione utilizzati durante la
                fase di avvio del sistema operativo.</entry>
            </row>

            <row>
              <entry><filename>/boot/defaults/</filename></entry>

              <entry>File di configurazione di avvio di default; consultare
                &man.loader.conf.5;.</entry>
            </row>

            <row>
              <entry><filename>/dev/</filename></entry>

              <entry>Nodi di dispositivo; consultare &man.intro.4;.</entry>
            </row>

            <row>
              <entry><filename>/etc/</filename></entry>

              <entry>Script e file di configurazione del sistema.</entry>
            </row>

            <row>
              <entry><filename>/etc/defaults/</filename></entry>

              <entry>File di configurazione di default del sistema; consultare
                &man.rc.8;.</entry>
            </row>

            <row>
              <entry><filename>/etc/mail/</filename></entry>

              <entry>File di configurazione per gli MTA (Mail Transfer Agent,
                agente di trasferimento della posta elettronica) come
                &man.sendmail.8;.</entry>
            </row>

            <row>
              <entry><filename>/etc/namedb/</filename></entry>

              <entry>File di configurazione di <command>named</command>;
                consultare &man.named.8;.</entry>
            </row>

            <row>
              <entry><filename>/etc/periodic/</filename></entry>

              <entry>Script che sono eseguiti giornalmente, settimanalmente, e
                mensilmente tramite &man.cron.8;; consultare
                &man.periodic.8;.</entry>
            </row>

            <row>
              <entry><filename>/etc/ppp/</filename></entry>

              <entry>File di configurazione di <command>ppp</command>;
                consultare &man.ppp.8;.</entry>
            </row>

            <row>
              <entry><filename>/mnt/</filename></entry>

              <entry>Directory vuota usata comunemente dagli amministratori di
                sistema come punto di mount temporaneo.</entry>
            </row>

            <row>
              <entry><filename>/proc/</filename></entry>

              <entry>File system dedicato ai processi; consultare
                &man.procfs.5;, &man.mount.procfs.8;.</entry>
            </row>

            <row>
              <entry><filename>/rescue/</filename></entry>

              <entry>Programmi linkati staticamente per situazioni di emergenza;
                consultare &man.rescue.8;.</entry>
            </row>

            <row>
              <entry><filename>/root/</filename></entry>

              <entry>Directory home per l'account
                <systemitem class="username">root</systemitem>.</entry>
            </row>

            <row>
              <entry><filename>/sbin/</filename></entry>

              <entry>Programmi di sistema e utilità di amministrazione
                fondamentali sia in ambiente mono-utente sia in ambiente
                multi-utente.</entry>
            </row>

            <row>
              <entry><filename>/tmp/</filename></entry>

              <entry>File temporanei.  Il contenuto di
                <filename>/tmp</filename> di solito NON
                è preservato dopo un riavvio del sistema.  Spesso
                un file system basato sulla memoria viene montato in
                <filename>/tmp</filename>.
                Questo può essere automatizzato usando le variabili
                relative a tmpmfs di &man.rc.conf.5; (o con un entry in
                <filename>/etc/fstab</filename>; consultare
                &man.mdmfs.8;).</entry>
            </row>

            <row>
              <entry><filename>/usr/</filename></entry>

              <entry>La maggior parte delle applicazioni e delle utilità
                dell'utente.</entry>
            </row>

            <row>
              <entry><filename>/usr/bin/</filename></entry>

              <entry>Utilità, strumenti di programmazione, e
                applicazioni comuni.</entry>
            </row>

            <row>
              <entry><filename>/usr/include/</filename></entry>

              <entry>File include standard del C.</entry>
            </row>

            <row>
              <entry><filename>/usr/lib/</filename></entry>

              <entry>Archivio di librerie.</entry>
            </row>

            <row>
              <entry><filename>/usr/libdata/</filename></entry>

              <entry>Archivio di dati per utilità varie.</entry>
            </row>

            <row>
              <entry><filename>/usr/libexec/</filename></entry>

              <entry>Demoni di sistema &amp; utilità di
                sistema (eseguiti da altri programmi).</entry>
            </row>

            <row>
              <entry><filename>/usr/local/</filename></entry>

              <entry>Eseguibili locali, librerie locali, ecc.  Usata anche
                come destinazione di default per la struttura dei port di
                FreeBSD.  All'interno di <filename>/usr/local</filename>, viene
                usato lo stesso schema generale descritto in &man.hier.7; per la
                directory <filename>/usr</filename>.  Le eccezioni sono la
                directory man, che è posta direttamente sotto
                <filename>/usr/local</filename> piuttosto che sotto
                <filename>/usr/local/share</filename>, e la documentazione dei
                port che è in
                <filename>share/doc/port</filename>.
              </entry>
            </row>

            <row>
              <entry><filename>/usr/obj/</filename></entry>

              <entry>Albero degli elementi dipendenti dal tipo di architettura
                dell'elaboratore prodotto dalla costruzione dell'albero
                <filename>/usr/src</filename>.</entry>
            </row>

            <row>
              <entry><filename>/usr/ports</filename></entry>

              <entry>Collezione dei port di FreeBSD (opzionale).</entry>
            </row>

            <row>
              <entry><filename>/usr/sbin/</filename></entry>

              <entry>Demoni di sistema &amp; utilità di
                sistema (eseguiti dagli utenti).</entry>
            </row>

            <row>
              <entry><filename>/usr/share/</filename></entry>

              <entry>File indipendenti dal tipo di architettura
                dell'elaboratore.</entry>
            </row>

            <row>
              <entry><filename>/usr/src/</filename></entry>

              <entry>File sorgenti di BSD e/o sorgenti proprietari.</entry>
            </row>

            <row>
              <entry><filename>/usr/X11R6/</filename></entry>

              <entry>Eseguibili, librerie, ecc. riguardanti la distribuzione
                X11R6 (opzionale).</entry>
            </row>

            <row>
              <entry><filename>/var/</filename></entry>

              <entry>File log di vario genere, file temporanei, file transitori,
                e file di spool.  Qualche volta un file system basato sulla
                memoria è montato in
                <filename>/var</filename>.
                Questo può essere automatizzato usando le variabili
                relative a varmfs di &man.rc.conf.5; (o con un entry in
                <filename>/etc/fstab</filename>; consultare
                &man.mdmfs.8;).</entry>
            </row>

            <row>
              <entry><filename>/var/log/</filename></entry>

              <entry>File di log del sistema di vario genere.</entry>
            </row>

            <row>
              <entry><filename>/var/mail/</filename></entry>

              <entry>File delle caselle di posta degli utenti.</entry>
            </row>

            <row>
              <entry><filename>/var/spool/</filename></entry>

              <entry>Directory di spool per stampanti e per la posta elettronica
                del sistema.</entry>
            </row>

            <row>
              <entry><filename>/var/tmp/</filename></entry>

              <entry>File temporanei.
                I file sono di solito preservati dopo un riavvio del sistema,
                a meno che <filename>/var</filename>
                sia un file system basato sulla memoria.</entry>
            </row>

            <row>
              <entry><filename>/var/yp</filename></entry>

              <entry>Mappe NIS.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </para>
  </sect1>

  <sect1 xml:id="disk-organization">
    <title>Organizzazione del Disco</title>

    <para>La più piccola unità di organizzazione che FreeBSD usa
      per ricercare file è il nome del file.  I nomi dei file sono
      case-sensitive, ciò significa che <filename>readme.txt</filename>
      e <filename>README.TXT</filename> sono due file distinti.  FreeBSD non usa
      l'estensione (es. <filename>.txt</filename>) di un file per determinare
      se il file è un programma, un documento, o qualche altra forma di
      dati.</para>

    <para>I file sono memorizzati in directory.  Una directory può
      contenere centinaia di file o non contenerne affatto.  Inoltre una
      directory può contenere altre directory, consentendo di costruire
      una gerarchia di directory all'interno di un'altra.  Tutto questo rende
      più facile l'organizzazione dei tuoi dati.</para>

    <para>Ci si riferisce a file e directory attraverso il nome del file o della
      directory, seguito da uno slash in avanti, <literal>/</literal>,
      a sua volta seguito da altri nomi di directory necessari.  Se
      hai una directory di nome <filename>foo</filename>, la quale contiene la
      directory <filename>bar</filename>, che a sua volta contiene il file
      <filename>readme.txt</filename>, allora il nome completo, chiamato anche
      il <firstterm>percorso</firstterm> del file è
      <filename>foo/bar/readme.txt</filename>.</para>

    <para>Le directory e i file sono memorizzati in un file system.  Ogni
      file system contiene esattamente una directory al livello più alto,
      chiamata la <firstterm>directory root</firstterm> di quel file system.
      Questa directory root può contenere altre directory.</para>

    <para>Fin qui è probabilmente tutto simile ad altri sistemi
      operativi che hai usato.  Tuttavia ci sono alcune differenze;  per
      esempio, &ms-dos; usa il carattere <literal>\</literal> per separare i
      nomi di file e directory, mentre &macos; usa <literal>:</literal>.</para>

    <para>FreeBSD non usa lettere di dispositivi, o altri nomi di dispositivi
      nel path.  In FreeBSD non dovrai mai scrivere
      <filename>c:/foo/bar/readme.txt</filename>.</para>

    <para>Piuttosto, un file system è designato come il
      <firstterm>file system root</firstterm>.  La directory root del
      file system root è riferita con <literal>/</literal>.  Ogni altro
      file system è <firstterm>montato</firstterm> sotto il file system
      root.  Non importa quanti dischi hai sul tuo sistema FreeBSD, ogni
      directory è come se fosse parte dello stesso disco.</para>

    <para>Supponiamo che tu abbia tre file system, chiamati
      <literal>A</literal>, <literal>B</literal>, e <literal>C</literal>.
      Ogni file system ha una directory root, la quale contiene altre due
      directory, chiamate <literal>A1</literal>, <literal>A2</literal> (e
      nello stesso modo <literal>B1</literal>, <literal>B2</literal> e
      <literal>C1</literal>, <literal>C2</literal>).</para>

    <para>Sia <literal>A</literal> il file system root.  Se usi il comando
      <command>ls</command> per visualizzare il contenuto di questa directory
      dovresti vedere due sottodirectory, <literal>A1</literal> e
      <literal>A2</literal>.  L'albero delle directory assomiglia a
      questo:</para>

    <mediaobject>
      <imageobject>
        <imagedata fileref="install/example-dir1"/>
      </imageobject>

      <textobject>
        <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
      </textobject>
    </mediaobject>

    <para>Un file system deve essere montato su una directory di un altro
      file system.  Supponiamo ora che tu monti il file system
      <literal>B</literal> sulla directory <literal>A1</literal>.  La directory
      root di <literal>B</literal> rimpiazza <literal>A1</literal>, e di
      conseguenza appariranno le directory di <literal>B</literal>:</para>

    <mediaobject>
      <imageobject>
        <imagedata fileref="install/example-dir2"/>
      </imageobject>

      <textobject>
        <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
      </textobject>
    </mediaobject>

    <para>I file contenuti nelle directory <literal>B1</literal> o
      <literal>B2</literal> possono essere raggiunti con il path
      <filename>/A1/B1</filename> o <filename>/A1/B2</filename>.  I file che
      erano in <filename>/A1</filename> sono stati temporaneamente nascosti.
      Questi riappariranno quando <literal>B</literal> sarà
      <firstterm>smontato</firstterm> da A.</para>

    <para>Se <literal>B</literal> è stato montato su
      <literal>A2</literal> allora il diagramma assomiglierà a
      questo:</para>

    <mediaobject>
      <imageobject>
        <imagedata fileref="install/example-dir3"/>
      </imageobject>

      <textobject>
        <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
      </textobject>
    </mediaobject>

    <para>e i percorsi saranno rispettivamente <filename>/A2/B1</filename> e
      <filename>/A2/B2</filename>.</para>

    <para>I file system possono essere montati in cima ad altri file system.
      Continuando con l'ultimo esempio, il file system <literal>C</literal>
      può essere montato in cima alla directory <literal>B1</literal>
      nel file system <literal>B</literal>, arrivando a questa
      sistemazione:</para>

    <mediaobject>
      <imageobject>
        <imagedata fileref="install/example-dir4"/>
      </imageobject>

      <textobject>
        <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
      </textobject>
    </mediaobject>

    <para>Oppure <literal>C</literal> potrebbe essere montato direttamente sul
      file system <literal>A</literal>, sotto la directory
      <literal>A1</literal>:</para>

    <mediaobject>
      <imageobject>
        <imagedata fileref="install/example-dir5"/>
      </imageobject>

      <textobject>
        <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
      </textobject>
    </mediaobject>

    <para>Se hai familiarità con &ms-dos;, questo è simile, ma
      non identico, al comando <command>join</command>.</para>

    <para>Di solito non ti devi occupare direttamente di questi aspetti.
      Tipicamente quando installi FreeBSD crei i file system e decidi dove
      montarli, e da quel momento non avrai più la necessità di
      modificarli a meno che installi un nuovo disco.</para>

    <para>È possibile avere un unico file system root, senza avere la
      necessità di crearne altri.  Esistono alcuni svantaggi
      utilizzando questo approccio, e un solo vantaggio.</para>

    <itemizedlist>
      <title>Benefici con File system Multipli</title>

      <listitem>
        <para>Filesystem diversi possono avere <firstterm>opzioni di
            mount</firstterm> diverse.  Per esempio, in un'attenta progettazione,
          il file system root potrebbe essere montato in modalità di sola
          lettura, rendendo impossibile la cancellazione accidentale o la modifica
          di un file critico.  Inoltre, separando i file system scrivibili
          dall'utente, come <filename>/home</filename>, da altri file system
          permette di montare i primi con l'opzione <firstterm>nosuid</firstterm>;
          questa opzione non permette il settaggio dei bit
          <firstterm>suid</firstterm>/<firstterm>guid</firstterm> sui file
          eseguibili memorizzati sul file system che ha tale opzione di mount
          attivata, migliorando l'aspetto sicurezza.</para>
      </listitem>

      <listitem>
        <para>FreeBSD ottimizza in modo automatico la disposizione dei file sul
          file system, a seconda di come è usato il file system.  Quindi
          un file system che contiene molti file piccoli che sono scritti di
          frequente avrà un'ottimizzazione diversa rispetto ad un altro
          file system che contiene pochi file di grandi dimensioni.  Utilizzando
          un solo grande file system questa ottimizzazione viene a
          mancare.</para>
      </listitem>

      <listitem>
        <para>I file system di FreeBSD reagiscono bene ad una violenta perdita di
          energia elettrica.  Tuttavia, una perdita di energia in un punto
          critico potrebbe sempre danneggiare la struttura del file system.
          Splittando i tuoi dati su file system multipli sarà più
          probabile che il sistema riparta, dandoti la possibilità di
          ripristinare un precedente backup se necessario.</para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <title>Benefici di un File system Singolo</title>

      <listitem>
        <para>I file system sono a dimensione fissa.  Se crei un solo file system
          quando installi FreeBSD e gli assegni una data dimensione, in futuro
          potresti scoprire che necessiti di creare una partizione più
          grande.  Questo non è facilmente realizzabile se non
          effettuando un backup dei dati, ricreando il file system con la nuova
          dimensione, e quindi ripristinando il backup di dati.</para>

        <important>
          <para>FreeBSD ha il comando &man.growfs.8;,
            con il quale è possibile incrementare la dimensione del
            file system al volo, rimuovendo questa limitazione.</para>
        </important>
      </listitem>
    </itemizedlist>

    <para>I file system sono contenuti all'interno di partizioni.  Qui il
      significato del termine partizione si discosta dall'uso comune di questo
      termine (partizioni &ms-dos;, per esempio), a causa dell'eredità
      &unix; di &os;.  Ogni partizione è identificata da una lettera
      partendo dalla <literal>a</literal> fino alla <literal>h</literal>.  Ogni
      partizione può contenere solo un file system, il che significa che i
      file system sono spesso identificati sia dal loro punto di mount nella
      gerarchia del file system, sia dalla lettera della partizione nella quale
      sono contenuti.</para>

    <para>Inoltre FreeBSD usa parte del disco per lo <firstterm>spazio di
        swap</firstterm>.  Lo spazio di swap fornisce a FreeBSD la
      funzionalità di <firstterm>memoria virtuale</firstterm>.  Questo
      permette al tuo computer di comportarsi come se avesse più memoria
      di quella che ha realmente.  Quando FreeBSD esaurisce la memoria muove
      alcuni dati presenti in memoria che non sono utilizzati in quel momento
      nello spazio di swap, e li riporta in memoria (spostando nello spazio di
      swap qualche altro dato) non appena necessari.</para>

    <para>Alcune partizioni hanno certe convenzioni a loro associate.</para>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
        <colspec colwidth="1*"/>

        <colspec colwidth="5*"/>

        <thead>
          <row>
            <entry>Partizione</entry>

            <entry>Convenzione</entry>
          </row>
        </thead>

        <tbody valign="top">
          <row>
            <entry><literal>a</literal></entry>

            <entry>In genere contiene il file system root</entry>
          </row>

          <row>
            <entry><literal>b</literal></entry>

            <entry>In genere contiene lo spazio di swap</entry>
          </row>

          <row>
            <entry><literal>c</literal></entry>

            <entry>Di solito rappresenta l'intera dimensione della slice.
              Questo permette a utility che necessitano di lavorare sull'intera
              slice (per esempio, uno scanner di blocchi difettosi) di lavorare
              sulla partizione <literal>c</literal>.  Di norma non dovresti
              creare un file system su questa partizione.</entry>
          </row>

          <row>
            <entry><literal>d</literal></entry>

            <entry>La partizione <literal>d</literal> era utilizzata in passato
              con un significato speciale, caduto ormai in disuso e ora
              può essere utilizzata come una partizione normale.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>Ogni partizione contenente un file system è memorizzata in
      ciò che FreeBSD chiama <firstterm>slice</firstterm>.  Slice
      è un termine di FreeBSD per identificare ciò che comunemente
      viene chiamato partizione, e di nuovo, questo è dovuto dal
      background &unix; di FreeBSD.  Le slice sono numerate, partendo da 1 e
      arrivando fino a 4.</para>

    <indexterm><primary>slice</primary></indexterm>

    <indexterm><primary>partizioni</primary></indexterm>

    <indexterm><primary>pericolosamente dedicate</primary></indexterm>

    <para>I numeri di slice seguono il nome del dispositivo, preceduti da una
      <literal>s</literal>, e partendo da 1.  Quindi
      <quote>da0<emphasis>s1</emphasis></quote> è la prima slice sul
      primo disco SCSI.  Ci possono essere solo quattro slice fisiche su un
      disco, ma puoi avere slice logiche all'interno di slice fisiche di un
      appropriato tipo.  Queste slice estese sono numerate a partire da 5,
      quindi <quote>ad0<emphasis>s5</emphasis></quote> è la prima
      slice estesa sul primo disco IDE.  Questi stratagemmi sono usati per i
      file system che si aspettano di occupare una slice.</para>

    <para>Le slice, i dispositivi fisici <quote>pericolosamente
        dedicati</quote>, e altri dispositivi contengono
      <firstterm>partizioni</firstterm>, le quali sono rappresentate tramite
      lettere dalla <literal>a</literal> fino alla <literal>h</literal>.  Queste
      lettere seguono il nome del dispositivo, quindi
      <quote>da0<emphasis>a</emphasis></quote> è la partizione a
      sul primo dispositivo da, il quale è <quote>pericolosamente
        dedicato</quote>.  <quote>ad1s3<emphasis>e</emphasis></quote> è
      la quinta partizione nel terza slice del secondo disco IDE.</para>

    <para>In fine, ogni disco sul sistema è identificato.  Un nome di un
      disco incomincia con un codice che indica il tipo di disco, seguito da un
      numero, che indica quale disco esso sia.  A differenza delle slice,
      i numeri riferiti al disco incominciano da 0.  Puoi vedere dei codici
      generici in <xref linkend="basics-dev-codes"/>.</para>

    <para>Quando fai riferimento a una partizione di FreeBSD devi specificare
      anche il nome della slice e del disco che contengono la partizione, e
      quando fai riferimento a una slice dovresti specificare anche il nome del
      disco.  Per riferirti ad una partizione specifica quindi il nome del disco,
      il carattere <literal>s</literal>, il numero di slice, e infine la lettera
      della partizione.  Alcuni esempi sono mostrati nell'<xref linkend="basics-disk-slice-part"/>.</para>

    <para>L'<xref linkend="basics-concept-disk-model"/> mostra un modello
      concettuale di struttura di un disco che dovrebbe aiutare a chiarire le
      cose.</para>

    <para>Per installare FreeBSD devi prima configurare le slice del disco,
      creare le partizioni all'interno della slice che vuoi usare per FreeBSD,
      e quindi creare un file system (o spazio di swap) in ogni partizione, e
      decidere dove il file system deve essere montato.</para>

    <table frame="none" pgwide="1" xml:id="basics-dev-codes">
      <title>Codici dei Dispositivi Disco</title>

      <tgroup cols="2">
        <colspec colwidth="1*"/>

        <colspec colwidth="5*"/>

        <thead>
          <row>
            <entry>Codice</entry>

            <entry>Significato</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><filename>ad</filename></entry>

            <entry>disco ATAPI (IDE)</entry>
          </row>

          <row>
            <entry><filename>da</filename></entry>

            <entry>disco ad accesso diretto SCSI</entry>
          </row>

          <row>
            <entry><filename>acd</filename></entry>

            <entry>CDROM ATAPI (IDE)</entry>
          </row>

          <row>
            <entry><filename>cd</filename></entry>

            <entry>CDROM SCSI</entry>
          </row>

          <row>
            <entry><filename>fd</filename></entry>

            <entry>Disco floppy</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <example xml:id="basics-disk-slice-part">
      <title>Esempi di Nomi di Dischi, di Slice, e di Partizioni</title>

      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
          <colspec colwidth="1*"/>

          <colspec colwidth="5*"/>

          <thead>
            <row>
              <entry>Nome</entry>

              <entry>Significato</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>ad0s1a</literal></entry>

              <entry>La prima partizione (<literal>a</literal>) sulla prima
                slice (<literal>s1</literal>) sul primo disco IDE
                (<literal>ad0</literal>).</entry>
            </row>

            <row>
              <entry><literal>da1s2e</literal></entry>

              <entry>La quinta partizione (<literal>e</literal>) sulla seconda
                slice (<literal>s2</literal>) sul secondo disco SCSI
                (<literal>da1</literal>).</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </example>

    <example xml:id="basics-concept-disk-model">
      <title>Modello Concettuale di un Disco</title>

      <para>Questo diagramma mostra come FreeBSD vede il primo disco IDE
        attaccato al sistema.  Si assuma che il disco sia di 4&nbsp;GB, e che
        contenga due slice da 2&nbsp;GB (equivalenti come significato a due
        partizioni &ms-dos;).  La prima slice contiene un disco &ms-dos;,
        <filename>C:</filename>, e la seconda slice contiene
        un'installazione di FreeBSD.  In questo esempio l'installazione di
        FreeBSD ha tre partizioni dati più una di swap.</para>

      <para>Le tre partizioni conterranno ognuna un file system.  La partizione
        <literal>a</literal> sarà usata per il file system root,
        la <literal>e</literal> per la gerarchia di directory
        <filename>/var</filename>, e la partizione <literal>f</literal> per
        la gerarchia di directory <filename>/usr</filename>.</para>

      <mediaobject>
        <imageobject>
          <imagedata fileref="install/disk-layout"/>
        </imageobject>

        <textobject>
          <literallayout class="monospaced">.-----------------.  --.
|                 |    |
|  DOS / Windows  |    |
:                 :     &gt;  Prima slice, ad0s1
:                 :    |
|                 |    |
:=================:  ==:                               --.
|                 |    |  Partizione a, montata come /   |
|                 |     &gt; riferita come ad0s2a           |
|                 |    |                                 |
:-----------------:  ==:                                 |
|                 |    |  Partizione b, usata come swap  |
|                 |     &gt; riferita come ad0s2b           |
|                 |    |                                 |
:-----------------:  ==:                                 |  Partizione c, senza
|                 |    |  Partizione e, usata come /var   &gt; file system, tutta
|                 |     &gt; riferita come ad0s2e           |  la slice di FreeBSD,
|                 |    |                                 |  ad0s2c
:-----------------:  ==:                                 |
|                 |    |                                 |
:                 :    |  Partizione f, usata come /usr  |
:                 :     &gt; riferita come ad0s2f           |
:                 :    |                                 |
|                 |    |                                 |
|                 |  --'                                 |
`-----------------'                                    --'</literallayout>
        </textobject>
      </mediaobject>
    </example>
  </sect1>

  <sect1 xml:id="mount-unmount">
    <title>Montaggio e Smontaggio dei File system</title>

    <para>Il file system è raffigurato in maniera ottimale da un albero,
      radicato, per così dire, in <filename>/</filename>.  Le directory
      <filename>/dev</filename>, <filename>/usr</filename>, e le altre
      directory che stanno all'interno della directory root sono i rami, i quali
      possono essere a loro volta ramificati, come in
      <filename>/usr/local</filename>, e così via.</para>

    <indexterm><primary>file system root</primary></indexterm>

    <para>Esistono varie ragioni per mantenere alcune di queste directory su
      file system separati.  La directory <filename>/var</filename> contiene
      le directory <filename>log/</filename>, <filename>spool/</filename>,
      e vari tipi di file temporanei, e come tale, può riempirsi.
      Riempire il file system root non è una buona idea, quindi scindere
      la directory <filename>/var</filename> da <filename>/</filename> è
      spesso vantaggioso.</para>

    <para>Un'altra motivazione per mantenere certi alberi di directory su altri
      file system è quando questi alberi sono alloggiati su dischi fisici
      separati, o sono dischi virtuali separati, come avviene per i mount del
      <link linkend="network-nfs">Network File System</link>, o dei dispositivi
      CDROM.</para>

    <sect2 xml:id="disks-fstab">
      <title>Il File <filename>fstab</filename></title>

      <indexterm>
        <primary>file system</primary>
        <secondary>montati con fstab</secondary>
      </indexterm>

      <para>Durante la <link linkend="boot">fase di avvio</link>, i file system
        elencati nel file <filename>/etc/fstab</filename> sono montati
        in modo automatico (a meno che siano specificati con l'opzione
        <option>noauto</option>).</para>

      <para>Il file <filename>/etc/fstab</filename> contiene una serie di righe
        il cui formato è il seguente:</para>

      <programlisting><replaceable>device</replaceable>       <replaceable>/mount-point</replaceable> <replaceable>fstype</replaceable>     <replaceable>options</replaceable>      <replaceable>dumpfreq</replaceable>     <replaceable>passno</replaceable></programlisting>

      <variablelist>
        <varlistentry>
          <term><literal>device</literal></term>

          <listitem>
            <para>Il nome del dispositivo (che deve esistere), come spiegato
              nella <xref linkend="disks-naming"/>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>mount-point</literal></term>

          <listitem>
            <para>La directory (che deve esistere), sulla quale montare il file
              system.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>fstype</literal></term>

          <listitem>
            <para>Il tipo di file system da passare a &man.mount.8;.  Il file
              system di default di FreeBSD è
              <literal>ufs</literal>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>options</literal></term>

          <listitem>
            <para><option>rw</option> per file system leggibili-scrivibili,
              oppure <option>ro</option> per file system solamente leggibili,
              seguite da altre opzioni che potrebbero essere necessarie.
              Un'opzione comune è <option>noauto</option> per i file
              system che normalmente non sono montati durante la sequenza di
              avvio.  Altre opzioni sono elencate nella pagina man di
              &man.mount.8;.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>dumpfreq</literal></term>

          <listitem>
            <para>Viene usato da &man.dump.8; per determinare quali file system
              richiedono un dump.  Se non si specifica nulla, viene assunto il
              valore zero.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>passno</literal></term>

          <listitem>
            <para>Determina l'ordine secondo il quale i file system vengono
              controllati.  I file system che devono saltare il controllo devono
              avere i loro <literal>passno</literal> settati a zero.  Il file
              system root (che deve essere controllato prima di qualsiasi altra
              cosa) deve avere il suo <literal>passno</literal> settato a uno,
              e i <literal>passno</literal> degli altri file system devono
              essere settati a valori maggiori di uno.  Se più di un
              file system ha lo stesso <literal>passno</literal> allora
              &man.fsck.8; tenterà di controllare i file system in
              parallelo.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Per maggiori informazioni sul formato del file
        <filename>/etc/fstab</filename> e sulle opzioni che esso contiene
        consulta la pagina man &man.fstab.5;.</para>
    </sect2>

    <sect2 xml:id="disks-mount">
      <title>Il Comando <command>mount</command></title>

      <indexterm>
        <primary>file system</primary>
        <secondary>montaggio</secondary>
      </indexterm>

      <para>Il comando &man.mount.8; è ciò che in definitiva viene
        usato per montare i file system.</para>

      <para>La sua forma di utilizzo elementare è:</para>

      <informalexample>
        <screen>&prompt.root; <userinput>mount device mountpoint</userinput></screen>
      </informalexample>

      <para>Esistono molte opzioni, come spiegato nella pagina man di
        &man.mount.8;, ma le più comuni sono:</para>

      <variablelist>
        <title>Opzioni di Mount</title>

        <varlistentry>
          <term><option>-a</option></term>

          <listitem>
            <para>Monta tutti i file system elencati nel file
              <filename>/etc/fstab</filename>.  Le eccezioni sono quei file
              system specificati come <quote>noauto</quote>, quelli esclusi
              dalla flag <option>-t</option>, o quei file system che sono
              già montati.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-d</option></term>

          <listitem>
            <para>Fà tutto ad eccezione della attuale system call di
              mount.  Questa opzione risulta utile in congiunzione con la flag
              <option>-v</option> per determinare quello che &man.mount.8; sta
              effettivamente tentando di fare.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-f</option></term>

          <listitem>
            <para>Forza il mount di un file system non correttamente smontato
              (pericoloso), o forza
              la revoca di accesso in scrittura quando si declassa lo stato
              di mount di un file system da lettura-scrittura a lettura
              solamente.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-r</option></term>

          <listitem>
            <para>Monta il file system in sola lettura.  Questo è
              identico ad usare l'argomento <option>ro</option>
              (<option>rdonly</option> per versioni di &os; dopo la 5.2) con
              l'opzione <option>-o</option>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-t</option> <replaceable>fstype</replaceable></term>

          <listitem>
            <para>Monta il dato file system secondo il tipo di file system
              specificato, oppure, se affiancato dall'opzione
              <option>-a</option>, monta solamente i file system di un dato
              tipo.</para>

            <para><quote>ufs</quote> è il tipo di file system di
              default.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-u</option></term>

          <listitem>
            <para>Aggiorna le opzioni di mount sul file system.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-v</option></term>

          <listitem>
            <para>Modalità verbosa.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-w</option></term>

          <listitem>
            <para>Monta il file system in lettura-scrittura.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>L'opzione <option>-o</option> accetta una lista di argomenti
        separati da una virgola, inclusi i seguenti:</para>

      <variablelist>
        <varlistentry>
          <term>noexec</term>

          <listitem>
            <para>Non permette l'esecuzione di binari su questo file system.
              Questa è un'altra utile opzione di sicurezza.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>nosuid</term>

          <listitem>
            <para>Non permette l'interpretazione delle flag setuid o setgid sul
              file system.  Anche questa è un'utile opzione di
              sicurezza.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <sect2 xml:id="disks-umount">
      <title>Il Comando <command>umount</command></title>

      <indexterm>
        <primary>file system</primary>
        <secondary>smontaggio</secondary>
      </indexterm>

      <para>Il comando &man.umount.8; accetta, come unico parametro, un punto di
        mount, un nome di dispositivo, l'opzione <option>-a</option> o l'opzione
        <option>-A</option>.</para>

      <para>Tutte queste modalità accettano l'opzione <option>-f</option>
        per forzare la smontatura, e l'opzione <option>-v</option> per la
        modalità verbosa.  Sei avvisato che l'opzione <option>-f</option>
        non è in generale un buona idea.  Smontare in modo forzato i
        file system può mandare in crash il computer o danneggiare i dati
        sul file system.</para>

      <para>Le opzioni <option>-a</option> e <option>-A</option> sono usate per
        smontare tutti i file system, con la possibilità di specificare
        i tipi di file system elencandoli dopo la flag <option>-t</option>.
        Tuttavia, l'opzione <option>-A</option> non tenta di smontare il file
        system root.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="basics-processes">
    <title>I Processi</title>

    <para>FreeBSD è un sistema operativo multi-tasking.  Con questa
      capacità il sistema è come se potesse eseguire più di
      un programma alla volta.  Ogni programma in esecuzione in un dato istante
      è chiamato <firstterm>processo</firstterm>.  Ogni volta che esegui
      un comando fai partire almeno un nuovo processo, e ci sono molti processi
      di sistema che sono sempre in esecuzione, che permettono il corretto
      funzionamento del sistema.</para>

    <para>Ogni processo è identificato in modo univoco da un numero
      chiamato <firstterm>process ID</firstterm>, o <firstterm>PID</firstterm>,
      e, come avviene per i file, ogni processo ha un proprietario e un gruppo.
      Le informazioni sul proprietario e sul gruppo sono usate per determinare,
      tramite il meccanismo dei permessi dei file discusso precedentemente,
      quali file e quali dispositivi il processo può aprire.  Inoltre
      molti processi hanno un processo padre.  Tale processo è il
      processo che li ha generati.  Per esempio, se stai digitando dei comandi
      in shell allora la shell è un processo, così come lo sono i
      comandi che esegui. Ogni processo che esegui in questo modo avrà
      come suo processo padre la tua shell.  L'eccezione a questo meccanismo
      è un processo speciale chiamato &man.init.8;.  Il processo
      <command>init</command> è sempre il primo processo, quindi il suo
      PID è sempre 1.  <command>init</command> viene avviato in modo
      automatico dal kernel quando si avvia FreeBSD.</para>

    <para>Due comandi sono particolarmente utili per monitorare i processi sul
      sistema, &man.ps.1; e &man.top.1;.  Il comando <command>ps</command>
      è usato per mostrare una lista statica dei processi che sono in
      esecuzione in quel momento, e può mostrare i loro PID, quanta
      memoria stanno usando, la linea di comando che li ha avviati, e altro
      ancora.  Il comando <command>top</command> visualizza tutti i processi in
      esecuzione, e aggiorna queste informazioni ogni qualche secondo, in modo
      che puoi vedere interattivamente cosa sta facendo il tuo computer.</para>

    <para>Di default, <command>ps</command> mostra solo i tuoi comandi che sono
      in quel momento in esecuzione.  Per esempio:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Come puoi vedere in questo esempio, l'output di &man.ps.1; è
      organizzato in molte colonne.  La colonna <literal>PID</literal> si
      riferisce al process ID discusso poco fà.  I PID sono assegnati
      partendo dal numero 1, andando fino al 99999,  e ricominciando dall'inizio
      una volta esauriti (se disponibili).  La colonna <literal>TT</literal>
      mostra su quale tty il programma è in esecuzione, e può
      essere benissimo ignorata per il momento.  La colonna
      <literal>STAT</literal> mostra lo stato del programma, e di nuovo,
      può essere benissimo ignorata.  La colonna <literal>TIME</literal>
      indica per quanto tempo il programma è stato in esecuzione sulla
      CPU&mdash;di solito non indica il tempo trascorso da quando hai avviato
      il programma, poichè la maggior parte dei programmi trascorrono
      molto tempo in attesa per faccende che accadono prima che questi possano
      trascorrere del tempo in CPU.  Infine, la colonna
      <literal>COMMAND</literal> indica la riga di comando che è stata
      utilizzata per eseguire il programma.</para>

    <para>Il comando &man.ps.1; supporta varie opzioni per cambiare le
      informazioni da visualizzare.  Uno dei gruppi di opzioni più utili
      è <literal>auxww</literal>.  L'opzione <option>a</option> mostra le
      informazioni riguardo a tutti i processi in esecuzione, non solo quelli
      che ti appartengono.  L'opzione <option>u</option> mostra il nome utente
      del proprietario del processo, come pure la memoria utilizzata dal
      processo.  L'opzione <option>x</option> mostra le informazioni riguardo ai
      processi demoni, e l'opzione <option>ww</option> indica a &man.ps.1; di
      visualizzare la linea di comando completa che ha avviato il processo,
      piuttosto che troncarla quando è troppo lunga per essere adattata
      sullo schermo.</para>

    <para>L'output di &man.top.1; è simile.  Un esempio di esecuzione
      assomiglia a questo:</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>L'output è diviso in due sezioni.  La parte superiore (le prime
      cinque linee) mostra il PID dell'ultimo processo eseguito, il carico medio
      del sistema (che è un indice di quanto il sistema sia impegnato), il
      tempo di vita del sistema (il tempo passato dall'ultimo reboot) e l'ora
      corrente.  I restanti numeri nella parte superiore riportano quanti
      processi sono in esecuzione (47 in questo caso), quanta memoria di sistema
      e quanta memoria di swap è stata utilizzata, e quanto tempo il
      sistema sta trascorrendo nei vari stati di CPU.</para>

    <para>Sotto ci sono una serie di colonne che contengono simili informazioni
      a quelle contenute nell'output di &man.ps.1;.  Come prima puoi vedere il
      PID, il nome utente, quanto tempo di CPU è stato utilizzato, e il
      comando che era stato eseguito.  Inoltre il comando &man.top.1; di default
      ti mostra quanta memoria è stata concessa al processo.  Questa
      informazione è suddivisa in due colonne, una per la dimensione
      totale, e l'altra per la dimensione attuale&mdash;la dimensione totale
      è la quantità di memoria che l'applicazione ha richiesto, e
      la dimensione attuale è la quantità di memoria che sta
      utilizzando in quel momento.  In questo esempio puoi vedere che
      <application>Netscape</application> ha richiesto quasi 30&nbsp;MB di RAM,
      ma al momento ne sta usando solo 9&nbsp;MB.</para>

    <para>Il comando &man.top.1; aggiorna in modo automatico queste informazioni
      ogni due secondi; questo lasso temporale può essere modificato con
      l'opzione <option>s</option>.</para>
  </sect1>

  <sect1 xml:id="basics-daemons">
    <title>I Demoni, i Segnali, e come Uccidere i Processi</title>

    <para>Quando esegui un editor risulta semplice averne il controllo, dirgli
      di caricare file, e così via.  Tutto questo può essere fatto
      poichè l'editor fornisce delle agevolazioni in questo senso, e
      anche perchè l'editor è collegato a un
      <firstterm>terminale</firstterm>.  Alcuni programmi non sono stati
      progettati per essere eseguiti con un continuo input dell'utente, e
      perciò questi programmi si disconnettono dal terminale alla prima
      occasione.  Per esempio, un server web trascorre tutto il giorno
      rispondendo a richieste web, e normalmente non necessita di alcun input
      da parte tua.  I programmi che trasportano la posta elettronica da un sito
      a un altro sito sono un altro esempio di questa classe di
      applicazioni.</para>

    <para>Chiamiamo questi programmi <firstterm>demoni</firstterm>.  I demoni
      erano dei personaggi della mitologia greca: nè buoni nè
      cattivi, erano piccoli spiriti custodi che, nel complesso,
      risultavano essere utili per l'umanità, molto similmente i server
      web e quelli di posta elettronica di oggi fanno cose utili.  Ecco il
      motivo per cui la mascotte di BSD è stata per molto tempo, e lo
      è ancora, l'allegro demone con le scarpe da tennis e con il
      forcone.</para>

    <para>Esiste la convenzione di chiamare i programmi che normalmente sono
      eseguiti come demoni con una <quote>d</quote> finale.
      <application>BIND</application> sta per Berkeley Internet Name Domain,
      ma il nome effettivo del programma che viene eseguito è
      <command>named</command>; il nome del programma
      <application>Apache</application>, un server web, è
      <command>httpd</command>; il demone dello spool di stampa è
      <command>lpd</command> e così via.  Questa è una
      convenzione, non è una regola ferrea; per esempio, il principale
      demone di posta elettronica per l'applicazione
      <application>Sendmail</application> è chiamato
      <command>sendmail</command>, e non <command>maild</command>, come potresti
      aspettarti.</para>

    <para>A volte puoi aver bisogno di comunicare con un processo demone.
      Un modo per farlo è di mandare a esso (o ad altri processi
      in esecuzione), un <firstterm>segnale</firstterm>.
      Esistono svariati segnali che puoi inviare&mdash;alcuni di
      questi hanno un significato specifico, altri sono interpretabili
      dall'applicazione, e la documentazione dell'applicazione ti dirà
      come l'applicazione stessa interpreta i segnali.  Puoi mandare un segnale
      solo ai processi che ti appartengono.  Se mandi un segnale a un processo
      che non ti appartiene con il comando &man.kill.1; o &man.kill.2;, il
      permesso ti sarà negato.  L'eccezione a questa regola riguarda
      l'utente <systemitem class="username">root</systemitem>, che può mandare segnali a
      processi di chiunque.</para>

    <para>Inoltre in alcune circostanze FreeBSD invia segnali alle
      applicazioni.  Se un'applicazione è stata scritta malamente, e
      tenta di accedere alla memoria che non gli compete, FreeBSD manda al
      processo il segnale di <firstterm>Violazione della
        Segmentazione</firstterm> (<literal>SIGSEGV</literal>).  Se
      un'applicazione ha utilizzato la system call &man.alarm.3; in modo tale
      da essere avvisata dopo un certo periodo di tempo trascorso allora
      FreeBSD invierà a questa applicazione il segnale di Allarme
      (<literal>SIGALRM</literal>), e così via.</para>

    <para>Per fermare un processo possono essere utilizzati due segnali,
      <literal>SIGTERM</literal> e <literal>SIGKILL</literal>.
      <literal>SIGTERM</literal> è il modo cortese di terminare un
      processo; il processo può <emphasis>catturare</emphasis> il
      segnale, capire che vuoi abbatterlo, chiudere i file di log che potrebbe
      avere aperto, e in genere terminare qualunque cosa che stava facendo prima
      dell'interruzione.  Nei casi in cui un processo sia coinvolto in qualche
      compito che non può essere interrotto allora questo processo
      può persino ignorare <literal>SIGTERM</literal>.</para>

    <para>Il segnale <literal>SIGKILL</literal> non può essere ignorato
      da un processo.  Questo è il segnale che dice <quote>Non mi
      interessa cosa stai facendo, fermati subito</quote>.  Se mandi il segnale
      <literal>SIGKILL</literal> a un processo allora FreeBSD fermerà
      subito il processo<footnote>
        <para>Non è del tutto vero&mdash;ci sono alcune cose che non
          possono essere interrotte.  Per esempio, se il processo sta tentando
          di leggere un file situato su un altro computer in rete, e questo
          computer non è disponibile per qualche ragione (è stato
          spento, o la rete ha qualche problema), allora il processo è
          detto <quote>non interrompibile</quote>.  Il processo finirà
          in time out, generalmente dopo due minuti.  Non appena avviene il
          time out il processo potrà essere terminato.</para>
      </footnote>.
    </para>

    <para>Altri segnali che potresti aver bisogno di usare sono
      <literal>SIGHUP</literal>, <literal>SIGUSR1</literal>, e
      <literal>SIGUSR2</literal>.  Questi sono segnali a scopo generico, e
      differenti applicazioni possono fare cose diverse quando catturano questi
      segnali.</para>

    <para>Supponiamo che hai cambiato il file di configurazione del tuo server
      web&mdash;hai bisogno di dire al server web di rileggere la sua
      configurazione.  Potresti fermare e riavviare <command>httpd</command>, ma
      questo porterebbe a un breve periodo di interruzione del tuo server
      web, che potrebbe non essere gradito.  Molti demoni sono stati scritti per
      rispondere al segnale <literal>SIGHUP</literal> tramite la rilettura
      dei loro file di configurazione.  In questo modo invece di terminare e
      riavviare <command>httpd</command> potresti inviare il segnale
      <literal>SIGHUP</literal>.  Poichè non esiste un modo standard di
      trattare questi segnali, differenti demoni potrebbero avere un
      comportamento diverso, quindi assicurati di leggere la documentazione per
      il demone in questione.</para>

    <para>I segnali sono inviati utilizzando il comando &man.kill.1;, come
      mostra questo esempio.</para>

    <procedure>
      <title>Inviare un Segnale a un Processo</title>

      <para>Questo esempio mostra come inviare un segnale a &man.inetd.8;.  Il
        file di configurazione di <command>inetd</command> è
        <filename>/etc/inetd.conf</filename>, e <command>inetd</command> rilegge
        questo file di configurazione quando riceve il segnale
        <literal>SIGHUP</literal>.</para>

      <step>
        <para>Cerca il process ID del processo a cui vuoi mandare il segnale.
          Puoi utilizzare &man.ps.1; e &man.grep.1; per farlo.  Il comando
          &man.grep.1; viene utilizzato per perlustrare attraverso l'output,
          cercando la stringa da te specificata.  Questo comando viene eseguito
          in modalità utente, e &man.inetd.8; viene eseguito in
          modalità <systemitem class="username">root</systemitem>, quindi le opzioni da dare
          a &man.ps.1; sono <option>ax</option>.</para>

        <screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

        <para>Come puoi vedere il PID di &man.inetd.8; è 198.  In alcuni
          casi potrebbe apparire nel risultato anche il comando
          <literal>grep inetd</literal>.  Questo dipende dal modo utilizzato
          da &man.ps.1; nell'elencare la lista dei processi in
          esecuzione.</para>
      </step>

      <step>
        <para>Usa il comando &man.kill.1; per inviare il segnale.  Poichè
          &man.inetd.8; viene eseguito in modalità
          <systemitem class="username">root</systemitem> prima devi usare il comando &man.su.1; per
          diventare <systemitem class="username">root</systemitem>.</para>

        <screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

        <para>Come avviene per la maggior parte dei comandi &unix;, il comando
          &man.kill.1; non stampa il risultato dell'operazione se questa ha
          avuto successo.  Se mandi un segnale a un processo del quale non sei
          il proprietario allora vedrai il messaggio <errorname>kill:
            <replaceable>PID</replaceable>: Operation not permitted</errorname>.
          Se sbagli il PID invierai il segnale al processo sbagliato, il che
          potrebbe essere dannoso, o, se hai fortuna, manderai il segnale
          a un PID che in quel momento non è in uso, e in questo caso
          vedrai il messaggio <errorname>kill: <replaceable>PID</replaceable>:
            No such process</errorname>.</para>

        <note>
          <title>Perchè Usare <command>/bin/kill</command>?</title>

          <para>Molte shell forniscono il comando <command>kill</command> come
            comando built-in; ossia, la shell invia il segnale in modo
            diretto, senza dover eseguire <filename>/bin/kill</filename>.  Tutto
            ciò può essere molto utile, ma le diverse shell hanno
            una sintassi diversa per specificare il nome del segnale da inviare.
            Invece di cercare di imparare tutte queste sintassi, può
            essere più semplice usare direttamente il comando
            <command>/bin/kill ...</command>.</para>
        </note>
      </step>
    </procedure>

    <para>L'invio di altri segnali è analogo, basta sostituire
      all'occorrenza <literal>TERM</literal> o <literal>KILL</literal> nella
      linea di comando.</para>

    <important>
      <para>Terminare processi in modo random su un sistema può essere
        una cattiva idea.  In particolare, il processo &man.init.8;, con process
        ID 1, è un caso molto speciale.  Eseguire <command>/bin/kill -s
          KILL 1</command> è un modo veloce per arrestare il tuo sistema.
        Controlla <emphasis>sempre</emphasis> due volte gli argomenti quando
        esegui &man.kill.1; <emphasis>prima</emphasis> di premere
        <keycap>Invio</keycap>.</para>
    </important>
  </sect1>

  <sect1 xml:id="shells">
    <title>Le Shell</title>

    <indexterm><primary>shell</primary></indexterm>
    <indexterm><primary>riga di comando</primary></indexterm>

    <para>In FreeBSD, la maggior parte del lavoro di tutti i giorni viene svolto
      tramite un'interfaccia a riga di comando chiamata shell.  Uno dei compiti
      principali di una shell è quello di prendere in input dei comandi
      ed eseguirli.  Inoltre molte shell hanno delle funzioni built-in
      (incorporate) utili nei lavori ordinari come la gestione dei file, la
      sostituzione dei nomi dei file, la modifica della riga di comando, la
      creazione di macro di comandi, e la gestione delle variabili d'ambiente.
      FreeBSD si propone con una serie di shell, come la Shell Bourne,
      <command>sh</command>, e la versione successiva della C-shell,
      <command>tcsh</command>.  Molte altre shell sono disponibili nella FreeBSD
      Ports Collection, come le shell <command>zsh</command> e
      <command>bash</command>.</para>

    <para>Quale shell devi usare?  È veramente una questione di gusti.
      Se sei un programmatore di C potresti sentirti a tuo agio con una shell
      C-like come la <command>tcsh</command>.  Se vieni da Linux o non sei
      pratico dell'interfaccia a riga di comando di &unix; potresti provare la
      <command>bash</command>.  Il fatto è che ogni shell ha delle
      caratteristiche che possono o meno combaciare con il tuo ambiente di
      lavoro preferito, e quindi devi scegliere tu stesso quale shell
      utilizzare.</para>

    <para>Una caratteristica comune in una shell è il completamento dei
      nomi dei file.  Dopo aver digitato alcuni dei primi caratteri di un
      comando o di un nome di file, la shell di solito può completare
      in modo automatico il resto del comando o del nome del file tramite la
      pressione del tasto <keycap>Tab</keycap> sulla tastiera.  Ecco un esempio.
      Supponiamo che hai due file chiamati <filename>foobar</filename> e
      <filename>foo.bar</filename>.  Vuoi cancellare
      <filename>foo.bar</filename>.  Quello che dovresti digitare sulla tastiera
      è:
      <command>rm
        fo[Tab].[Tab]</command>.</para>

    <para>La shell dovrebbe visualizzare <command>rm
      foo[BEEP].bar</command>.</para>

    <para>Il [BEEP] è la campanella della console, che mi segnala che la
      shell è incapace di completare interamente il nome del file
      poichè esiste più di una sola corrispondenza.  Sia
      <filename>foobar</filename> che <filename>foo.bar</filename> iniziano con
      <literal>fo</literal>, tuttavia la shell è riuscita a completarlo
      in <literal>foo</literal>.  A questo punto premendo <literal>.</literal>,
      e poi di nuovo <keycap>Tab</keycap>, la shell sarà in grado di
      completare da sola il resto del nome del file.</para>

    <indexterm><primary>variabili d'ambiente</primary></indexterm>

    <para>Un altro aspetto di una shell è l'uso delle variabili
      d'ambiente.  Le variabili d'ambiente sono una coppia di valori mutevoli
      memorizzati nello spazio dell'ambiente della shell.  Questo spazio
      può essere letto dai programmi invocati dalla shell, e di
      conseguenza questo spazio può contenere le configurazioni di molti
      programmi.  Qui sotto c'è una lista delle variabili d'ambiente
      più comuni con il loro rispettivo significato:</para>

    <indexterm><primary>variabili d'ambiente</primary></indexterm>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
        <thead>
          <row>
            <entry>Variabile</entry>

            <entry>Descrizione</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><envar>USER</envar></entry>

            <entry>Il nome dell'utente attualmente loggato.</entry>
          </row>

          <row>
            <entry><envar>PATH</envar></entry>

            <entry>Lista di directory separate da due punti utilizzate per
              la ricerca dei binari.</entry>
          </row>

          <row>
            <entry><envar>DISPLAY</envar></entry>

            <entry>Nome di rete del display X11 a cui connettersi, se
              disponibile.</entry>
          </row>

          <row>
            <entry><envar>SHELL</envar></entry>

            <entry>La shell corrente.</entry>
          </row>

          <row>
            <entry><envar>TERM</envar></entry>

            <entry>Il nome del tipo di terminale dell'utente.  Usato per determinare
              le capacità del terminale.</entry>
          </row>

          <row>
            <entry><envar>TERMCAP</envar></entry>

            <entry>Serie di elementi di codici di escape del terminale
              utilizzati per realizzare svariate funzioni del terminale.</entry>
          </row>

          <row>
            <entry><envar>OSTYPE</envar></entry>

            <entry>Il tipo di sistema operativo. FreeBSD, ad esempio.</entry>
          </row>

          <row>
            <entry><envar>MACHTYPE</envar></entry>

            <entry>L'architettura della CPU su cui il sistema gira.</entry>
          </row>

          <row>
            <entry><envar>EDITOR</envar></entry>

            <entry>L'editor di testo preferito dall'utente.</entry>
          </row>

          <row>
            <entry><envar>PAGER</envar></entry>

            <entry>L'impaginatore di testo preferito dall'utente.</entry>
          </row>

          <row>
            <entry><envar>MANPATH</envar></entry>

            <entry>Lista di directory separate da due punti utilizzate nella
              ricerca delle pagine man.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>shell Bourne</primary></indexterm>

    <para>Il modo di settare una variabile d'ambiente varia leggermente a
      seconda della shell utilizzata.  Per esempio, nelle shell C-Style come
      <command>tcsh</command> e <command>csh</command>, puoi usare
      <command>setenv</command> per settare le variabili d'ambiente.  Sotto le
      shell Bourne come <command>sh</command> e <command>bash</command>, puoi
      usare <command>export</command> per settare le tue variabili d'ambiente
      correnti.  Per esempio, per settare o modificare la variabile d'ambiente
      <envar>EDITOR</envar> a <filename>/usr/local/bin/emacs</filename>, sotto
      <command>csh</command> o <command>tcsh</command> si può utilizzare
      il comando:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Sotto le shell Bourne:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>Con la maggior parte delle shell puoi inoltre creare un'espansione
      di una variabile d'ambiente mettendo sulla riga di comando il simbolo
      <literal>$</literal> davanti al nome della variabile stessa.  Per esempio,
      <command>echo $TERM</command> visualizzerà ciò che
      corrisponde a <envar>$TERM</envar>, poichè la shell espande
      <envar>$TERM</envar> e passa il risultato a
      <command>echo</command>.</para>

    <para>Le shell trattano molti caratteri speciali, chiamati meta-caratteri
      come rappresentazioni speciali di dati.  Il più comune di questi
      è il simbolo <literal>*</literal>, che rappresenta diverse
      istanze di caratteri in un nome di file.  Questi meta-caratteri possono
      essere usati per la sostituzione dei nomi di file.  Per esempio, digitando
      <command>echo *</command> è quasi come aver digitato
      <command>ls</command> poichè la shell prende tutti i file che
      corrispondono a <literal>*</literal> e li mette sulla riga di comando
      con <command>echo</command> che quindi li visualizza.</para>

    <para>Per impedire alla shell di interpretare questi caratteri speciali,
      questi possono essere messi in escape mettendo subito prima di essi un
      backslash (<literal>\</literal>).  <command>echo $TERM</command>
      visualizza il tipo del tuo terminale. <command>echo \$TERM</command>
      visualizza <envar>$TERM</envar> così com'è.</para>

    <sect2 xml:id="changing-shells">
      <title>Cambiare la Propria Shell</title>

      <para>Il modo più semplice per cambiare la propria shell è
        quello di usare il comando <command>chsh</command>.  Eseguendo
        <command>chsh</command> verrà invocato l'editor definito nella
        tua variabile d'ambiente <envar>EDITOR</envar>; nel caso in cui questa
        non sia stata settata, verrà invocato <command>vi</command>.
        Modifica la riga <quote>Shell:</quote> in base alle tue esigenze.</para>

      <para>Puoi anche eseguire <command>chsh</command> con l'opzione
        <option>-s</option>; in questo modo verrà settata la shell in
        modo diretto, senza che sia necessario invocare l'editor.  Per
        esempio, se vuoi cambiare la tua shell in <command>bash</command>,
        potresti digitare il seguente comando:</para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <note>
        <para>La shell che desideri utilizzare <emphasis>deve</emphasis> essere
          presente nel file <filename>/etc/shells</filename>.  Se hai installato
          una shell dalla <link linkend="ports">collezione dei port</link>,
          allora la nuova shell dovrebbe essere già stata inserita nel
          suddetto file in modo automatico.  Se installi una shell manualmente,
          questo lavoro lo devi fare tu.</para>

      <para>Per esempio, se installi <command>bash</command> a mano e la
        metti sotto <filename>/usr/local/bin</filename>, dovresti fare
        questo:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Dopo averlo fatto riavvia <command>chsh</command>.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 xml:id="editors">
    <title>Editor di Testo</title>

    <indexterm><primary>editor di testo</primary></indexterm>
    <indexterm><primary>editor</primary></indexterm>

    <para>La maggior parte del lavoro di configurazione in FreeBSD viene fatto
      tramite la modifica di file di testo.  Perciò, è una buona
      idea familiarizzare con un editor di testo.  FreeBSD si presenta con
      alcuni editor come parte base del sistema, e molti altri sono disponibili
      nella collezione dei port.</para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>
    <indexterm>
      <primary>editor</primary>
      <secondary><command>ee</command></secondary>
    </indexterm>

    <para>L'editor più semplice e più facile da imparare si chiama
      <application>ee</application>, che sta per easy editor.  Per avviare
      <application>ee</application>, puoi digitare sulla riga di comando
      <command>ee filename</command> dove <literal>filename</literal> è
      il nome del file che deve essere modificato.  Per esempio, per modificare
      <filename>/etc/rc.conf</filename>, devi digitare <command>ee
        /etc/rc.conf</command>.  Una volta all'interno di <command>ee</command>,
      tutti i comandi per azionare le funzioni dell'editor sono elencati nella
      parte superiore del video.  Il carattere <literal>^</literal> è il
      tasto <keycap>Ctrl</keycap> della tastiera, quindi <literal>^e</literal>
      si riferisce alla combinazione di tasti <keycombo action="simul">
        <keycap>Ctrl</keycap>
        <keycap>e</keycap>
      </keycombo>.  Per uscire da <application>ee</application>, premi il tasto
      <keycap>Esc</keycap>, quindi conferma l'uscita dall'editor.  Se il file
      ha subito delle modifiche ti verrà chiesto se le vuoi
      salvare.</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>editor</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>editor</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>

    <para>FreeBSD ha come parte base del sistema anche editor di testo
      più potenti come <application>vi</application>, mentre altri
      editor, come <application>Emacs</application> e
      <application>vim</application>, sono inclusi nella
      FreeBSD Ports Collection (<package>editors/emacs</package> e <package>editors/vim</package>).  Questi editor offrono molte
      più funzionalità e molta più potenza a costo di essere
      un poco più complicati da imparare ad utilizzare.  Comunque se
      intendi utilizzare in modo intensivo un editor, imparando ad utilizzare un
      editor potente come <application>vim</application> o
      <application>Emacs</application>
      risparmierai a lungo andare un sacco di tempo.</para>
  </sect1>

  <sect1 xml:id="basics-devices">
    <title>Dispositivi e Nodi di Dispositivo</title>

    <para>Il termine dispositivo viene usato prevalentemente per specificare le
      unità hardware all'interno di un sistema, come i dischi, le
      stampanti, le schede grafiche, e le tastiere.  Durante la fase di avvio di
      FreeBSD, la maggior parte delle cose che vengono visualizzate da FreeBSD
      riguardano i dispositivi che sono stati rilevati.  Puoi riesaminare
      questi messaggi di avvio guardando il file
      <filename>/var/run/dmesg.boot</filename>.</para>

    <para>Per esempio, <filename>acd0</filename> è il primo drive
      CDROM IDE, mentre <filename>kbd0</filename> rappresenta la
      tastiera.</para>

    <para>In un sistema operativo &unix; la maggior parte di questi dispositivi
      sono accessibili tramite dei file speciali chiamati nodi di dispositivo,
      i quali sono posti nella directory <filename>/dev</filename>.</para>

    <sect2>
      <title>Creare i Nodi di Dispositivo</title>

      <para>Quando aggiungi un nuovo dispositivo al tuo sistema, o ricompili il
        kernel per supportare dispositivi aggiuntivi, devono essere
        creati nuovi nodi di dispositivo.</para>

      <sect3>
        <title><literal>DEVFS</literal> (DEVice File System)</title>

        <para>Il file system device, o <literal>DEVFS</literal>, fornisce la
          disponibilità dello spazio dei nomi dei dispositivi del kernel
          allo spazio dei nomi globale del file system.  Invece di dover creare
          o modificare i nodi di dispositivo, <literal>DEVFS</literal> mantiene
          in modo automatico questo particolare file system.</para>

        <para>Guarda la pagina man di &man.devfs.5; per maggiori
          informazioni.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="binary-formats">
    <title>Formati dei Binari</title>

    <para>Per comprendere il motivo per cui FreeBSD usa il formato &man.elf.5;,
      devi prima conoscere un pò i tre attuali formati eseguibili
      <quote>dominanti</quote> per &unix;:</para>

    <itemizedlist>
      <listitem>
        <para>&man.a.out.5;</para>

        <para>Il più vecchio e <quote>classico</quote> formato oggetto
          di &unix;.  Usa un'intestazione corta e compatta con un numero magico
          all'inizio che è spesso usato per caratterizzare il formato
          (vedere &man.a.out.5; per maggiori dettagli).  Contiene tre segmenti
          caricabili: .text, .data, e .bss più una tabella di simboli e
          una di stringhe.</para>
      </listitem>

      <listitem>
        <para><acronym>COFF</acronym></para>

        <para>Il formato oggetto di SVR3.  Poichè l'intestazione include
          una porzione di tabella, puoi avere molto di più delle sole
          sezioni .text, .data, e .bss.</para>
      </listitem>

      <listitem>
        <para>&man.elf.5;</para>

        <para>Il successore di <acronym>COFF</acronym>, caratterizzato da
          sezioni multiple e da possibili valori a 32-bit o 64-bit.  Uno dei
          maggiori svantaggi: <acronym>ELF</acronym> fu progettato con
          l'assunzione che ci doveva essere solo un ABI per ogni tipo di
          architettura dei sistemi.  Tale assunzione è in realtà
          piuttosto sbagliata, e non è vera nemmeno nel mondo commerciale
          di SYSV (che ha almeno tre ABI: SVR4, Solaris, SCO).</para>

        <para>FreeBSD tenta di aggirare questo problema fornendo un
          utility per <emphasis>marchiare</emphasis> un eseguibile
          <acronym>ELF</acronym> con informazioni sull'ABI per il quale è
          stato costruito.  Guarda la pagina man &man.brandelf.1; per maggiori
          informazioni.</para>
      </listitem>
    </itemizedlist>

    <para>FreeBSD proviene dalla scuola <quote>classica</quote> e ha usato il
      formato &man.a.out.5;, una tecnologia sperimentata ed utilizzata
      attraverso molte generazioni delle release BSD, fino agli inizi del ramo
      3.X.  Sebbene fino ad allora era possibile costruire ed eseguire su
      un sistema FreeBSD binari (e kernel) del formato <acronym>ELF</acronym>,
      inizialmente FreeBSD si oppose al <quote>salto</quote> di cambiamento al
      formato <acronym>ELF</acronym> come formato di default.  Per quale motivo?
      Dunque, quando la scuola Linux fece il suo doloroso passaggio a
      <acronym>ELF</acronym>, questo non era sufficiente per abbandonare
      il formato eseguibile <filename>a.out</filename> a causa del loro
      rigido meccanismo a salto-di-tabella basato sulla libreria condivisa, il
      quale rendeva la costruzione di librerie condivise un compito molto
      difficile tanto per i venditori che per gli sviluppatori.  Tuttavia,
      quando gli strumenti di <acronym>ELF</acronym> furono in grado di offrire
      una soluzione al problema della libreria condivisa e quando furono visti
      come <quote>la strada imminente</quote>, il costo della migrazione
      fu accettato poichè necessario e avvenne così la
      transizione.  Il meccanismo di libreria condivisa di FreeBSD è
      basato sullo stile più restrittivo del meccanismo di libreria
      condivisa degli &sunos; di Sun, e come tale, è molto facile da
      utilizzare.</para>

    <para>Quindi, perchè ci sono così tanti formati
      differenti?</para>

    <para>In passato l'hardware era semplice.  Questo hardware semplice
      sosteneva un sistema semplice e piccolo.  Il formato
      <filename>a.out</filename> era del tutto adatto per rappresentare i binari
      su questo semplice sistema (un PDP-11).  Nonostante le persone fecero il
      port di &unix; da questo semplice sistema, esse mantennero il formato
      <filename>a.out</filename> poichè era sufficiente per un primo port
      di &unix; verso architetture come Motorola 68k, VAXen, ecc.</para>

    <para>All'epoca alcuni ingegneri hardware di spicco stabilirono che se tale
      formato poteva forzare il software a fare alcuni trucchi sporchi, allora
      esso sarebbe stato in grado di abbattere alcune barriere di progettazione
      e permettere al core della CPU di andare più veloce.  Benchè
      il formato <filename>a.out</filename> fu progettato per lavorare
      con questo nuovo tipo di hardware (conosciuto ai giorni d'oggi come
      <acronym>RISC</acronym>), esso fu appena sufficiente per questo
      hardware, quindi furono sviluppati altri formati per ottenere delle
      prestazioni da questo hardware migliori di quelle che il limitato e
      semplice formato <filename>a.out</filename> era in grado di offrire.
      Furono inventati formati come il <acronym>COFF</acronym>,
      l'<acronym>ECOFF</acronym>, e alcuni altri e furono esaminate le loro
      limitazioni prima che fu prodotto l'<acronym>ELF</acronym>.</para>

    <para>Per di più, le dimensioni dei programmi stavano diventando
      enormi e i dischi (e la memoria fisica) erano ancora relativamente
      piccoli, e quindi il concetto di libreria condivisa prese piede.
      Inoltre il sistema di VM (Memoria Virtuale) divenne più
      sofisticato.  Benchè ognuno di questi miglioramenti fu fatto
      utilizzando il formato <filename>a.out</filename>, la sua utilità
      si distese sempre più con ogni nuova caratteristica.  In aggiunta,
      la gente voleva caricare alcune cose in modo dinamico al tempo di
      esecuzione, o anche scartare parte dei loro programmi dopo l'esecuzione
      del codice iniziale al fine di salvare memoria e spazio di swap.
      I linguaggi divennero più sofisticati e le persone desideravano che
      il codice venisse chiamato dopo il main in modo automatico.  Furono
      apportati molte migliorie al formato <filename>a.out</filename> per
      permettere tutte queste cose, e sostanzialmente tutto funzionò per
      un dato periodo.  Col passare del tempo, il formato
      <filename>a.out</filename> non fu più in grado di gestire
      tutti questi problemi senza apportare dei miglioramenti al codice con
      un conseguente aumento della complessità.  Benchè il formato
      <acronym>ELF</acronym> risolveva molti di questi problemi, era doloroso
      migrare da un sistema che tutto sommato funzionava.  Quindi il formato
      <acronym>ELF</acronym> attese fino a quando fu meno doloroso
      rimanere con il formato <filename>a.out</filename> piuttosto che migrare
      al formato <acronym>ELF</acronym>.</para>

    <para>Tuttavia, il tempo passò, e gli strumenti di costruzione che
      FreeBSD derivò dai loro strumenti di costruzione (in particolare
      l'assemblatore ed il loader) evolsero in due tronconi paralleli.
      L'albero di FreeBSD aggiunse le librerie condivise e sistemò alcuni
      bug.  Il popolo di GNU che in origine aveva scritto questi programmi
      li riscrisse e aggiunse un semplice supporto per la costruzione di
      compilatori cross, la possibilità di produrre formati diversi a
      piacimento, e così via.  Da quando molte persone vollero costruire
      compilatori cross per FreeBSD, questi furono delusi poichè i vecchi
      sorgenti che FreeBSD aveva per <application>as</application> e
      <application>ld</application> non erano pronti per questo lavoro.
      La nuova serie di strumenti di GNU (<application>binutils</application>)
      supportavano la compilazione cross, <acronym>ELF</acronym>, le librerie
      condivise, le estensioni C++, ecc.  Inoltre molti venditori stanno
      rilasciando binari <acronym>ELF</acronym>, ed è una buona cosa
      per FreeBSD eseguirli.</para>

    <para>Il formato <acronym>ELF</acronym> è più espressivo di
      quello <filename>a.out</filename> e permette una maggiore
      estensibilità nel sistema base.  Gli strumenti di
      <acronym>ELF</acronym> sono meglio mantenuti, e offrono un supporto alla
      compilazione cross, che sta a cuore a molte persone.
      <acronym>ELF</acronym> può essere un pò meno veloce di
      <filename>a.out</filename>, ma tentare di misurarne le prestazioni non
      è molto semplice.  Ci sono anche numerosi dettagli che sono diversi
      tra i due formati nel modo in cui essi mappano le pagine, gestiscono il
      codice iniziale, ecc.  Questi dettagli non sono molto importanti, ma tra i
      due esistono delle differenze.  Nel tempo il supporto per il formato
      <filename>a.out</filename> verrà rimosso dal kernel
      <filename>GENERIC</filename>, e alla fine sarà rimosso
      completamente dal kernel non appena non ci sarà più la
      necessità di eseguire programmi con il formato
      <filename>a.out</filename>.</para>
  </sect1>

  <sect1 xml:id="basics-more-information">
    <title>Per Maggiori Informazioni</title>

    <sect2 xml:id="basics-man">
      <title>Le Pagine Man</title>

      <indexterm><primary>pagine man</primary></indexterm>

      <para>La documentazione più esauriente su FreeBSD è
        costituita dalle pagine man.  Quasi tutti i programmi sul sistema hanno
        un piccolo manuale di riferimento che spiega il funzionamento di base e
        i vari argomenti del programma stesso.  Questi manuali possono essere
        visualizzati con il comando <command>man</command>.  L'uso del comando
        <command>man</command> è semplice:</para>

      <screen>&prompt.user; <userinput>man comando</userinput></screen>

      <para><literal>comando</literal> è il nome del comando di cui
        desideri maggiori informazioni.  Per esempio, per sapere di più
        circa il comando <command>ls</command> digita:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>Il manuale in linea è diviso in sezione numerate:</para>

      <orderedlist>
        <listitem>
          <para>Comandi utente.</para>
        </listitem>

        <listitem>
          <para>System call e codici di errore.</para>
        </listitem>

        <listitem>
          <para>Funzioni della libreria C.</para>
        </listitem>

        <listitem>
          <para>Driver dei dispositivi.</para>
        </listitem>

        <listitem>
          <para>Formati di file.</para>
        </listitem>

        <listitem>
          <para>Giochi e altri passatempo.</para>
        </listitem>

        <listitem>
          <para>Informazioni varie.</para>
        </listitem>

        <listitem>
          <para>Comandi di mantenimento e di funzionamento del sistema.</para>
        </listitem>

        <listitem>
          <para>Sviluppo del kernel.</para>
        </listitem>
      </orderedlist>

      <para>In qualche caso, lo stesso soggetto può apparire in
        più di una sezione del manuale in linea.  Per esempio, esiste
        un comando utente <command>chmod</command> e una system call
        <function>chmod()</function>.  In questo caso, puoi dire al comando
        <command>man</command> quale vuoi specificando la sezione:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>In questo caso verrà visualizzata la pagina man del comando
        utente <command>chmod</command>.  I riferimenti di una sezione
        particolare del manuale in linea sono tradizionalmente posti tra
        parentesi all'interno della documentazione, quindi &man.chmod.1; fa
        riferimento al comando utente <command>chmod</command> e &man.chmod.2;
        fa riferimento alla system call.</para>

      <para>Tutto questo va bene se conosci il nome del comando e desideri
        semplicemente sapere come usarlo, ma cosa succede se non ricordi il nome
        del comando?  Puoi usare <command>man</command> con l'opzione
        <option>-k</option> per ricercare tramite parole chiavi nelle
        descrizioni dei comandi:</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>Con questo comando ti verrà presentata una lista di comandi
        che hanno la parola chiave <quote>mail</quote> nella loro descrizione.
        Di fatto questo meccanismo funziona proprio come il comando
        <command>apropos</command>.</para>

      <para>Stai dando un'occhiata a tutti quei comandi fantastici che si
        trovano in <filename>/usr/bin</filename> ma non hai la più
        pallida idea di cosa fanno la maggior parte di essi?  Semplicemente
        digita:</para>

      <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

      <para>oppure</para>

      <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

      <para>che è la stessa cosa.</para>
    </sect2>

    <sect2 xml:id="basics-info">
      <title>I File Info di GNU</title>

      <indexterm><primary>Free Software Foundation</primary></indexterm>

      <para>FreeBSD include molte applicazioni e utility prodotti dalla Free
        Software Foundation (FSF).  Oltre alle pagine man, questi programmi
        hanno dei più ampi documenti in ipertesto chiamati file
        <literal>info</literal> che possono essere visualizzati con il comando
        <command>info</command>, o se hai installato
        <application>emacs</application>, con la modalità info di
        <application>emacs</application>.</para>

      <para>Per usare il comando &man.info.1;, digita semplicemente:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>Per una breve introduzione, digita <literal>h</literal>.  Per un
        rapido riferimento dei comandi, digita <literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>
