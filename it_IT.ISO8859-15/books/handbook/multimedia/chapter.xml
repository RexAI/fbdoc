<?xml version="1.0" encoding="iso-8859-15"?>
<!--
     The FreeBSD Italian Documentation Project

     $FreeBSD$
     Original revision: 1.128
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="multimedia">
  <info><title>Multimedia</title>
    <authorgroup>
      <author><personname><firstname>Ross</firstname><surname>Lippert</surname></personname><contrib>Scritto da </contrib></author>
    </authorgroup>
  </info>

  

  <sect1 xml:id="multimedia-synopsis">
    <title>Sinossi</title>

    <para>FreeBSD supporta una grande varietà di schede audio,
      permettendoti di apprezzare un output di alta fedeltà dal tuo
      computer.  Questo include l'abilità di registrare e riprodurre
      suoni nei formati MPEG Audio Layer 3 (MP3), WAV, ed Ogg Vorbis così
      come in molti altri formati.  La FreeBSD Ports Collection contiene inoltre
      applicazioni che ti permettono di modificare l'audio registrato,
      aggiungere effetti sonori, e controllare i dispositivi MIDI
      collegati.</para>

    <para>Con un po' di sperimentazione, &os;
      può supportare la riproduzione di file video e DVD.  Il numero di
      applicazioni per codificare, convertire, e riprodurre i vari formati
      video è più limitato del numero delle applicazioni audio.
      Per esempio nel momento in cui sto scrivendo, non esiste nella FreeBSD
      Ports Collection una buona applicazione per ricodificare che
      potrebbe essere usata per la conversione tra diversi formati, come
      c'è con <package>audio/sox</package>.  Tuttavia,
      il panorama software in quest'area sta rapidamente cambiando.</para>

    <para>Questo capitolo descriverà i passi necessari per configurare la
      tua scheda audio.  La configurazione e l'installazione di X11
      (<xref linkend="x11"/>) si sono già prese cura dei problemi
      hardware della tua scheda video, sebbene ci possano essere delle
      ottimizzazioni da applicare per una migliore riproduzione.</para>

    <para>Dopo aver letto questo capitolo, saprai:</para>

    <itemizedlist>
      <listitem>
        <para>Come configurare il sistema in modo che la scheda audio venga
          riconosciuta.</para>
      </listitem>

      <listitem>
        <para>Metodi per verificare che la tua scheda funzioni.</para>
      </listitem>

      <listitem>
        <para>Come risolvere i problemi di configurazione audio.</para>
      </listitem>

      <listitem>
        <para>Come riprodurre e codificare file MP3.</para>
      </listitem>

      <listitem>
        <para>Come sono supportate le applicazioni video dal server X.</para>
      </listitem>

      <listitem>
        <para>Alcuni port per riprodurre/codificare filmati che danno buoni
          risultati.</para>
      </listitem>

      <listitem>
        <para>Come riprodurre i DVD e i file <filename>.mpg</filename> e
          <filename>.avi</filename>.</para>
      </listitem>

      <listitem>
        <para>Come estrarre i contenuti da CD e DVD su file.</para>
      </listitem>

      <listitem>
        <para>Come configurare una scheda TV.</para>
      </listitem>

      <listitem>
        <para>Come configurare uno scanner di immagini.</para>
      </listitem>
    </itemizedlist>

    <para>Prima di leggere questo capitolo, dovresti:</para>

    <itemizedlist>
      <listitem>
        <para>Sapere come configurare e installare un nuovo
          kernel (<xref linkend="kernelconfig"/>).</para>
      </listitem>
    </itemizedlist>

    <warning>
      <para>Provare a montare CD audio con il comando
        &man.mount.8; produrrà un errore, come minimo, o un
        <emphasis>kernel panic</emphasis>, alla peggio.  Questi formati hanno
        codifiche particolari che differiscono dal comune file system
        ISO.</para>
    </warning>
  </sect1>

  <sect1 xml:id="sound-setup">
    <info><title>Configurazione della Scheda Audio</title>
      <authorgroup>
        <author><personname><firstname>Moses</firstname><surname>Moore</surname></personname><contrib>Contributo di </contrib></author>
      </authorgroup>

      <authorgroup>
        <author><personname><firstname>Marc</firstname><surname>Forvieille</surname></personname><contrib>Arricchito per &os;&nbsp;5.X da </contrib></author>
      </authorgroup>
    </info>

    

    <sect2 xml:id="sound-device">
      <title>Configurare il Sistema</title>

      <indexterm><primary>PCI</primary></indexterm>
      <indexterm><primary>ISA</primary></indexterm>
      <indexterm><primary>schede audio</primary></indexterm>

      <para>Prima di iniziare, dovresti conoscere il modello della scheda che
        possiedi, il chip che utilizza, e se è una scheda PCI o ISA.
        FreeBSD supporta diverse schede PCI e ISA.  Verifica la lista dei
        dispositivi audio supportati nell' <link xlink:href="&rel.current.hardware;">Hardware Notes</link> per vedere se
        la tua scheda è supportata.  Inoltre tale documento ti
        indicherà quale driver supporta la tua scheda.</para>

      <indexterm>
        <primary>kernel</primary>
        <secondary>configurazione</secondary>
      </indexterm>

      <para>Per usare il tuo dispositivo audio, dovrai caricare i driver
        corretti.  Il caricamento del driver del dispositivo può essere
        fatto in due modi.  Il metodo più semplice consiste semplicemente
        nel caricare un modulo nel kernel per la tua scheda audio con
        &man.kldload.8; che può essere fatto sia da linea di
        comando:</para>

      <screen>&prompt.root; <userinput>kldload snd_emu10k1</userinput></screen>

      <para>sia aggiungendo la riga appropriata al file
        <filename>/boot/defaults/loader.conf</filename> come questa:</para>

      <programlisting>snd_emu10k1_load="YES"</programlisting>

      <para>Questi esempi sono per la scheda audio Creative &soundblaster;
        Live!.  Altri moduli sonori disponibili sono elencati in
        <filename>/boot/loader.conf</filename>.  Se hai dei dubbi su quale
        driver usare, potresti provare a caricare il modulo
        <filename>snd_driver</filename>:</para>

      <screen>&prompt.root; <userinput>kldload snd_driver</userinput></screen>

      <para>Questo è un metadriver che carica i driver dei dispositivi
        audio più comuni in un solo colpo.  Ciò permette di
        trovare velocemente il driver corretto.  È anche possibile
        caricare tutti i driver audio attraverso il file
        <filename>/boot/loader.conf</filename>.</para>

      <para>Se desideri scoprire il driver selezionato per la tua scheda audio
        dopo aver caricato il metadriver <filename>snd_driver</filename>,
        puoi verificare il file <filename>/dev/sndstat</filename> con il
        comando <command>cat /dev/sndstat</command>.</para>

      <para>Un altro metodo è quello di compilare staticamente il
        supporto per la tua scheda audio nel kernel.  La sezione seguente
        fornisce le informazioni di cui hai bisogno per aggiungere il supporto
        al tuo hardware in questo metodo.  Per informazioni aggiuntive su
        come ricompilare il kernel, guarda il <xref linkend="kernelconfig"/>.</para>

      <sect3>
        <title>Configurare un Kernel Custom con il Supporto Audio</title>

        <para>La prima cosa da fare è aggiungere al kernel il driver
          di framework audio &man.sound.4;; per fare ciò devi aggiungere
          la seguente riga al tuo file di configurazione del kernel:</para>

        <programlisting>device sound</programlisting>

        <para>Poi, devi aggiungere il supporto per la tua scheda audio.
          Di conseguenza, devi conoscere quale driver
          supporta la scheda.  Controlla la lista dei dispositivi
          audio supportati nell'<link xlink:href="&rel.current.hardware;">Hardware Notes</link>, per
          determinare il driver corretto per la tua scheda sonora.  Per
          esempio, la scheda &soundblaster; Live! della  Creative è
          supportata dal driver &man.snd.emu10k1.4;.  Per aggiungere il
          supporto per questa scheda, usiamo la seguente riga:</para>

        <programlisting>device snd_emu10k1</programlisting>

        <para>Per conoscere la corretta sintassi da usare assicurati di
          leggere la pagina man del driver.  La sintassi corretta per la
          configurazione del kernel di ogni driver audio supportato può
          essere trovata nel file
          <filename>/usr/src/sys/conf/NOTES</filename>.</para>

        <para>Schede ISA non-PnP possono obbligarti a fornire al kernel
          informazioni su alcuni settaggi della scheda audio (IRQ, porta di I/O,
          etc), tipico di tutte le scheda ISA non-PnP.  Questo può
          essere realizzato attraverso il file
          <filename>/boot/device.hints</filename>.  All'avvio del sistema,
          il &man.loader.8; leggerà questo file e passerà
          i settaggi al kernel.  Per esempio, una vecchia scheda audio
          &soundblaster; 16 ISA non-PnP della Creative userà il driver
          &man.snd.sbc.4; in congiunzione con  <literal>snd_sb16</literal>.
          Per questa scheda le seguenti linee devono essere aggiunte al file
          di configurazione del kernel:</para>

        <programlisting>device snd_sbc
device snd_sb16</programlisting>

        <para>e queste nel <filename>/boot/device.hints</filename>:</para>

        <programlisting>hint.sbc.0.at="isa"
hint.sbc.0.port="0x220"
hint.sbc.0.irq="5"
hint.sbc.0.drq="1"
hint.sbc.0.flags="0x15"</programlisting>

        <para>In questo caso, la scheda usa la porta di I/O
          <literal>0x220</literal> e l'IRQ <literal>5</literal>.</para>

        <para>La sintassi usata nel file <filename>/boot/device.hints</filename>
          è spiegata nella pagina man di &man.sound.4; e nella pagina man
          del driver in questione.</para>

        <para>Il settaggi qui sopra sono quelli di default.  In alcuni casi,
          potresti avere la necesità di modificare l'IRQ o altri
          parametri per far funzionare la tua scheda audio.  Guarda la pagina
          man di &man.snd.sbc.4; per maggiori dettagli su questo driver.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="sound-testing">
      <title>Collaudo della Scheda Audio</title>

      <para>Dopo aver riavviato con il nuovo kernel, o dopo aver caricato il
        modulo richiesto, la scheda audio dovrebbe apparire nel tuo buffer
        dei messaggi (&man.dmesg.8;) in modo simile a quanto segue:</para>

      <screen>pcm0: &lt;Intel ICH3 (82801CA)&gt; port 0xdc80-0xdcbf,0xd800-0xd8ff irq 5 at device 31.5 on pci0
pcm0: [GIANT-LOCKED]
pcm0: &lt;Cirrus Logic CS4205 AC97 Codec&gt;</screen>

      <para>Lo stato della scheda audio può essere verificato leggendo
        il file <filename>/dev/sndstat</filename>:</para>

      <screen>&prompt.root; <userinput>cat /dev/sndstat</userinput>
FreeBSD Audio Driver (newpcm)
Installed devices:
pcm0: &lt;Intel ICH3 (82801CA)&gt; at io 0xd800, 0xdc80 irq 5 bufsz 16384
kld snd_ich (1p/2r/0v channels duplex default)</screen>

      <para>L'output del tuo sistema potrebbe essere diverso.  Se nessun
        dispositivo <filename>pcm</filename> viene visualizzato, rivedi
        ciò che è stato fatto di recente.  Ricontrolla ancora
        una volta il tuo file di configurazione del kernel e assicurati di
        aver scelto il driver corretto.  Alcuni problemi comuni sono elencati
        nella <xref linkend="troubleshooting"/>.</para>

      <para>Se tutto va bene, ora dovresti avere una scheda audio funzionante.
        Se i pin di audio-out del tuo drive CD-ROM o DVD-ROM sono collegati
        correttamente alla scheda audio, puoi inserire un CD nel drive e
        riprodurlo con &man.cdcontrol.1;:</para>

      <screen>&prompt.user; <userinput>cdcontrol -f /dev/acd0 play 1</userinput></screen>

      <para>Varie applicazioni, come <package>audio/workman</package> possono offrire una migliore
        interfaccia.  Potresti voler installare una applicazione come
        <package>audio/mpg123</package> per ascoltare i file
        audio MP3.</para>

      <para>Un altro modo veloce per controllare se la scheda trasmette
        dati al nodo <filename>/dev/dsp</filename> è questo:</para>

      <screen>&prompt.user; <userinput>cat filename &gt; /dev/dsp</userinput></screen>

      <para>dove <replaceable>filename</replaceable> può essere
        qualsiasi file.  Questo comando dovrebbe produrre del rumore, confermando
        che la scheda sonora sta lavorando.</para>

      <para>I livelli del mixer della scheda possono essere modificati
        attraverso il comando &man.mixer.8;.  Maggiori dettagli possono essere
        trovati nella pagina man &man.mixer.8;.</para>

      <sect3 xml:id="troubleshooting">
        <title>Problemi Comuni</title>

        <indexterm><primary>dispositivi</primary></indexterm>
        <indexterm><primary>porta di I/O</primary></indexterm>
        <indexterm><primary>IRQ</primary></indexterm>
        <indexterm><primary>DSP</primary></indexterm>

        <informaltable frame="none" pgwide="1">
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Errore</entry>

                <entry>Soluzione</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><errorname>sb_dspwr(XX) timed out</errorname></entry>

                <entry><para>Non è stata impostata correttamente la porta
                    di I/O.</para></entry>
              </row>

              <row>
                <entry><errorname>bad irq XX</errorname></entry>

                <entry><para>È stato configurato erroneamente l'IRQ.
                    Assicurati che l'IRQ impostato e quello della scheda siano
                    gli stessi.</para></entry>
              </row>

              <row>
                <entry><errorname>xxx: gus pcm not attached, out of
                    memory</errorname></entry>

                <entry><para>Non c'è abbastanza memoria disponibile per
                    usare il dispositivo.</para></entry>
              </row>

              <row>
                <entry><errorname>xxx: can't open /dev/dsp!</errorname></entry>

                <entry><para>Controlla con <command>fstat | grep dsp</command>
                    se un'altra applicazione sta usando il dispositivo.
                    <application>Esound</application> e il supporto audio di
                    <application>KDE</application> sono famosi per creare
                    problemi.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </sect3>
    </sect2>

    <sect2 xml:id="sound-multiple-sources">
      <info><title>Utilizzo di Sorgenti Audio Multiple</title>
        <authorgroup>
          <author><personname><firstname>Munish</firstname><surname>Chopra</surname></personname><contrib>Contributo di </contrib></author>
        </authorgroup>
      </info>

      

      <para>È spesso desiderabile avere più sorgenti di audio che
        siano in grado di suonare contemporaneamente, per esempio quando
        <application>esound</application> o <application>artsd</application> non
        supportano la condivisione del dispositivo audio con una certa
        applicazione.</para>

      <para>FreeBSD ti permette di fare questo attraverso i <emphasis>Virtual
          Sound Channels</emphasis>, che possono essere abilitati con
        &man.sysctl.8;.  I canali virtuali permettono di multiplexare i canali
        di riproduzione della tua scheda audio mixando l'audio nel
        kernel.</para>

      <para>Per impostare il numero dei canali virtuali, ci sono due variabili
        sysctl che, se sei l'utente <systemitem class="username">root</systemitem>, possono essere
        impostate così:</para>

      <screen>&prompt.root; <userinput>sysctl hw.snd.pcm0.vchans=4</userinput>
&prompt.root; <userinput>sysctl hw.snd.maxautovchans=4</userinput></screen>

      <para>L'esempio qui sopra alloca quattro canali virtuali, che è un
        numero adatto all'uso di ogni giorno.
        <varname>hw.snd.pcm0.vchans</varname> è il numero dei canali
        virtuali che ha <filename>pcm0</filename>, ed è configurabile
        una volta che il dispositivo è collegato.
        <literal>hw.snd.maxautovchans</literal> è il numero dei canali
        virtuali che vengono dati a un nuovo dispositivo audio quando viene
        collegato tramite &man.kldload.8;.  Visto che il modulo
        <filename>pcm</filename> può essere caricato
        indipendentemente dai driver dell'hardware,
        <varname>hw.snd.maxautovchans</varname> può contenere tanti
        canali virtuali quanti ne verranno allocati successivamente ad ogni
        dispositivo collegato.</para>

      <note>
        <para>Non puoi cambiare il numero di canali virtuali per un
          dispositivo mentre questo è in uso.  Chiudi tutti
          i programmi che stanno usando quel dispositivo, come player
          di musica o demoni del suono.</para>
      </note>

      <para>Se non stai usando &man.devfs.5;, dovrai indirizzare la tua
        applicazione su
        <filename>/dev/dsp0</filename>.<replaceable>x</replaceable>, dove
        <replaceable>x</replaceable> va da 0 a 3 se
        <varname>hw.snd.pcm.0.vchans</varname> è impostato a 4 come nel
        precedente esempio.  Su un sistema che usa &man.devfs.5;, questo
        verrà fatto automaticamente in modo trasparente per
        un programma che richiede <filename>/dev/dsp0</filename>.</para>
    </sect2>

    <sect2>
      <info><title>Settare i Valori di Default per i Canali del Mixer</title>
        <authorgroup>
          <author><personname><firstname>Josef</firstname><surname>El-Rayes</surname></personname><contrib>Contributo di </contrib></author>
        </authorgroup>
      </info>

      

      <para>I valori di default per i diversi canali del mixer sono rigidamente
        codificati nel codice sorgente del driver &man.pcm.4;.  Ci sono svariate
        applicazioni e demoni che ti permettono di settare i valori del mixer
        memorizzandoli per le successive invocazioni, ma questa non
        è una soluzione pulita.  È possibile settare valori di
        default del mixer a livello del driver &mdash;  questo
        è realizzabile definendo i valori desiderati nel file
        <filename>/boot/device.hints</filename>, per esempio:</para>

      <programlisting>hint.pcm.0.vol="50"</programlisting>

      <para>Questo imposterà il canale volume a un valore di default
        di 50 non appena il modulo &man.pcm.4; sarà caricato.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="sound-mp3">
    <info><title>Audio MP3</title>
      <authorgroup>
        <author><personname><firstname>Chern</firstname><surname>Lee</surname></personname><contrib>Contributo di </contrib></author>
      </authorgroup>
    </info>

    

    <para>Il formato MP3 (Audio MPEG Livello 3) raggiunge una qualità
      audio vicina a quella dei CD, non lasciandoti motivi per non utilizzarlo
      sulla tua workstation FreeBSD.</para>

    <sect2 xml:id="mp3-players">
      <title>Lettori MP3</title>

      <para>Da tempo, il più famoso lettore MP3 per X11 è
        <application>XMMS</application> (X Multimedia System).  Le skin per
        <application>Winamp</application> possono essere usate con
        <application>XMMS</application> visto che la GUI è praticamente
        identica a quella di <application>Winamp</application> della Nullsoft.
        <application>XMMS</application> ha inoltre supporto nativo ai
        plug-in.</para>

      <para><application>XMMS</application> può essere installato dal
        port o dal package <package>multimedia/xmms</package>.</para>

      <para>L'interfaccia di <application>XMMS</application> è intuitiva,
        comprende una lista di brani da eseguire, un equalizzatore grafico, ed
        altro.  Coloro che sono familiari con <application>Winamp</application>
        troveranno <application>XMMS</application> semplice da usare.</para>

      <para>Il port <package>audio/mpg123</package> è
        un lettore MP3 alternativo, da riga di comando.</para>

      <para><application>mpg123</application> può essere eseguito
        specificando il dispositivo audio e il nome del file MP3 sulla riga di
        comando, come mostrato qui sotto:</para>

      <screen>&prompt.root; <userinput>mpg123 -a /dev/dsp1.0 Foobar-GreatestHits.mp3</userinput>
High Performance MPEG 1.0/2.0/2.5 Audio Player for Layer 1, 2 and 3.
Version 0.59r (1999/Jun/15). Written and copyrights by Michael Hipp.
Uses code from various people. See 'README' for more!
THIS SOFTWARE COMES WITH ABSOLUTELY NO WARRANTY! USE AT YOUR OWN RISK!





Playing MPEG stream from Foobar-GreatestHits.mp3 ...
MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo</screen>

      <para><literal>/dev/dsp1.0</literal> deve essere sostituito con il
        dispositivo <filename>dsp</filename> presente sul tuo
        sistema.</para>
    </sect2>

    <sect2 xml:id="rip-cd">
      <title>Estrazione delle Tracce Audio dei CD</title>

      <para>Prima di codificare un CD o una traccia di CD in MP3, i dati audio
        sul CD devono essere estratti sul disco fisso.  Questo avviene copiando
        direttamente i dati CDDA (CD Digital Audio) in file WAV.</para>

      <para>Il tool <command>cdda2wav</command>, che fa parte della suite
        <package>sysutils/cdrtools</package>, viene usato per
        estrarre le informazioni audio dai CD e i dati associati.</para>

      <para>Mentre il CD audio è nel lettore, può essere eseguito
        il seguente comando (come <systemitem class="username">root</systemitem>) per estrarre un
        intero CD in singoli (per traccia) file WAV:</para>

      <screen>&prompt.root; <userinput>cdda2wav -D 0,1,0 -B</userinput></screen>

      <para><application>cdda2wav</application> supporta anche i lettori CDROM
        ATAPI (IDE).  Per estrarre da un lettore IDE, specifica il nome del
        dispositivo al posto nel numero dell'unità SCSI.  Ad esempio, per
        estrarre la traccia 7 dal lettore IDE:</para>

      <screen>&prompt.root; <userinput>cdda2wav -D /dev/acd0 -t 7</userinput></screen>

      <para>Il <option>-D <replaceable>0,1,0</replaceable></option>
        indica il dispositivo SCSI <filename>0,1,0</filename>, che
        corrisponde all'output di <command>cdrecord -scanbus</command>.</para>

      <para>Per estrarre tracce singole, usa l'opzione <option>-t</option> come
        mostrato:</para>

      <screen>&prompt.root; <userinput>cdda2wav -D 0,1,0 -t 7</userinput></screen>

      <para>Questo esempio estrae la settima traccia del CD audio.  Per estrarre
        una serie di tracce, per esempio dalla traccia uno alla sette, specifica
        un intervallo:</para>

      <screen>&prompt.root; <userinput>cdda2wav -D 0,1,0 -t 1+7</userinput></screen>

      <para>L'utility &man.dd.1; può anche essere usata per estrarre le
        tracce audio dai drive ATAPI, leggi <xref linkend="duplicating-audiocds"/> per maggiori informazioni su questa
        possibilità.</para>
    </sect2>

    <sect2 xml:id="mp3-encoding">
      <title>Codifica in MP3</title>

      <para>Al giorno d'oggi, il programma di codifica in mp3 da scegliere
        è <application>lame</application>.
        <application>Lame</application> può essere trovato in <package>audio/lame</package> nell'albero dei port.</para>

      <para>Usando i file WAV estratti, il seguente comando convertirà
        <filename>audio01.wav</filename> in
        <filename>audio01.mp3</filename>:</para>

      <screen>&prompt.root; <userinput>lame -h -b 128 \
--tt "Titolo" \
--ta "Artista" \
--tl "Album" \
--ty "2002" \
--tc "Estratto e codificato da Blah" \
--tg "Genere" \
audio01.wav audio01.mp3</userinput></screen>

      <para>128&nbsp;kbits sembra essere il bitrate standard in uso per gli MP3.
        Molti preferiscono la qualità maggiore dei 160, o 192.
        Più alto è il bitrate, più spazio consumerà
        l'MP3 risultante--ma la qualità sarà maggiore.  L'opzione
        <option>-h</option> attiva il modo <quote>qualità migliore ma un
        po' più lento"</quote>.  Le opzioni che iniziano con
        <option>--t</option> indicano i tag ID3, che solitamente contengono le
        informazioni sulla canzone, da inserire all'interno del file MP3.
        Ulteriori opzioni di codifica possono essere trovate consultando la
        pagina man di lame.</para>
    </sect2>

    <sect2 xml:id="mp3-decoding">
      <title>Decodifica da MP3</title>

      <para>Per masterizzare un CD audio partendo dagli MP3, questi ultimi
        devono essere convertiti in un formato WAV non compresso.  Sia
        <application>XMMS</application> che <application>mpg123</application>
        supportano l'output di un MP3 in un formato non compresso.</para>

      <para>Scrittura su Disco con <application>XMMS</application>:</para>

      <procedure>
        <step>
          <para>Avvia <application>XMMS</application>.</para>
        </step>

        <step>
          <para>Clicca con il tasto destro sulla finestra per far comparire il
            menu di <application>XMMS</application>.</para>
        </step>

        <step>
          <para>Seleziona <literal>Preference</literal> sotto
            <literal>Options</literal>.</para>
        </step>

        <step>
          <para>Cambia l'Output Plugin in <quote>Disk Writer
              Plugin</quote>.</para>
        </step>

        <step>
          <para>Premi <literal>Configure</literal>.</para>
        </step>

        <step>
          <para>Inserisci (o scegli browse) la directory in cui salvare i file
            decompressi.</para>
        </step>

        <step>
          <para>Carica il file MP3 in <application>XMMS</application> come al
            solito, con il volume al 100% e le impostazioni dell'equalizzatore
            disattivate.</para>
        </step>

        <step>
          <para>Premi <literal>Play</literal> &mdash;
            <application>XMMS</application> apparirà come se stesse
            riproducendo l'MP3, ma non si sentirà nessuna musica.  Sta
            riproducendo la musica su un file.</para>
        </step>

        <step>
          <para>Assicurati di reimpostare l'Output Plugin di default come prima
            per ascoltare nuovamente gli MP3.</para>
        </step>
      </procedure>

      <para>Scrittura su stdout con <application>mpg123</application>:</para>

      <procedure>
        <step>
          <para>Esegui <command>mpg123 -s audio01.mp3
            &gt; audio01.pcm</command></para>
        </step>
      </procedure>

      <para><application>XMMS</application> scrive un file nel formato WAV,
        mentre <application>mpg123</application> converte l'MP3 direttamente in
        dati audio PCM.  Entrambi questi formati possono essere usati con
        <application>cdrecord</application> per creare CD audio.
        Devi utilizzare PCM con &man.burncd.8;.  Se usi file WAV, noterai un
        breve ticchettio all'inizio di ogni traccia, questo suono è
        l'intestazione del file WAV.  Puoi semplicemente rimuovere
        l'intestazione del file WAV con l'utility <application>SoX</application>
        (può essere installata dal port o dal package <package>audio/sox</package>):</para>

      <screen>&prompt.user; <userinput>sox -t wav -r 44100 -s -w -c 2 track.wav track.raw</userinput></screen>

      <para>Leggi <xref linkend="creating-cds"/> per ulteriori informazioni su
        come usare un masterizzatore con FreeBSD.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="video-playback">
    <info><title>Riproduzione Video</title>
      <authorgroup>
        <author><personname><firstname>Ross</firstname><surname>Lippert</surname></personname><contrib>Contributo di </contrib></author>
      </authorgroup>
    </info>

    

    <para>La riproduzione video è un'area applicativa molto recente e
      in rapido sviluppo.  Sii paziente.  Non tutto funzionerà
      così facilmente come è stato per l'audio.</para>

    <para>Prima di iniziare, dovresti conoscere il modello della scheda video
      che possiedi e il chip che usa.  Sebbene
      <application>&xorg;</application> e <application>&xfree86;</application>
      supportino una vasta varietà di schede video, poche offrono buone
      prestazioni in riproduzione.  Per ottenere una lista di estensioni
      supportate dall'X server con la tua scheda usa il comando
      &man.xdpyinfo.1; mentre X11 sta girando.</para>

    <para>È una buona idea avere un piccolo file MPEG che possa essere
      trattato come un file di test per la valutazione di vari riproduttori e
      opzioni.  Visto che alcuni riproduttori di DVD cercheranno di default i
      DVD in <filename>/dev/dvd</filename>, o hanno questo nome di dispositivo
      codificato permanentemente al loro interno, potresti trovare utile creare
      dei link simbolici al dispositivo corretto:</para>

    <screen>&prompt.root; <userinput>ln -sf /dev/acd0 /dev/dvd</userinput>
&prompt.root; <userinput>ln -sf /dev/acd0 /dev/rdvd</userinput></screen>

    <para>Nota che, data la natura del &man.devfs.5;, i collegamenti creati a
      mano come questi non rimarranno se riavvii il sistema.  Per creare i
      collegamenti simbolici automaticamente quando avvii il sistema, aggiungi
      le seguenti righe in <filename>/etc/devfs.conf</filename>:</para>

    <screen>&prompt.root; <userinput>ln -sf /dev/acd0c /dev/dvd</userinput>
&prompt.root; <userinput>ln -sf /dev/acd0c /dev/rdvd</userinput></screen>

    <para>In aggiunta, la decrittazione dei DVD, che richiede l'invocazione
      di speciali funzioni dei DVD-ROM, richiede il permesso in scrittura sui
      dispositivi DVD.</para>

    <para>Per migliorare l'interfaccia della memoria condivisa di X11, è
      consigliabile incrementare i valori di alcune variabili
      &man.sysctl.8;:</para>

    <programlisting>kern.ipc.shmmax=67108864
kern.ipc.shmall=32768</programlisting>

    <sect2 xml:id="video-interface">
      <title>Determinazione delle Capacità Video</title>

      <indexterm><primary>XVideo</primary></indexterm>
      <indexterm><primary>SDL</primary></indexterm>
      <indexterm><primary>DGA</primary></indexterm>

      <para>Ci sono molti modi possibili per visualizzare immagini e filmati con
        X11.  Quello che funzionerà meglio in pratica dipende in gran
        parte dal tuo hardware.  Ogni metodo descritto qui sotto avrà una
        qualità variabile su hardware differente.  In secondo luogo, il
        rendering video in X11 è un argomento che sta ricevendo un sacco
        di attenzione ultimamente, e con ogni nuova versione di
        <application>&xorg;</application>, o di
        <application>&xfree86;</application> ci possono essere notevoli
        miglioramenti.</para>

      <para>Una lista di interfacce video comuni:</para>

      <orderedlist>
        <listitem>
          <para>X11: normale output di X11 che usa la memoria condivisa.</para>
        </listitem>

        <listitem>
          <para>XVideo: un'estensione all'interfaccia X11 che supporta grafica
            e filmati in ogni oggetto X11 disegnabile.</para>
        </listitem>

        <listitem>
          <para>SDL: Simple Directmedia Layer.</para>
        </listitem>

        <listitem>
          <para>DGA: Direct Graphics Access.</para>
        </listitem>

        <listitem>
          <para>SVGAlib: interfaccia di basso livello per la grafica da
            console.</para>
        </listitem>
      </orderedlist>

      <sect3 xml:id="video-interface-xvideo">
        <title>XVideo</title>

        <para><application>&xorg;</application> e <application>&xfree86;
            4.X</application> hanno un'estensione chiamata
          <emphasis>XVideo</emphasis> (aka Xvideo, aka Xv, aka xv) che permette
          di visualizzare grafica e filmati direttamente negli oggetti
          disegnabili attraverso una speciale accelerazione.
          Questa estensione fornisce una riproduzione di ottima qualità
          anche su macchine poco potenti.</para>

        <para>Per controllare se l'estensione sta girando, usa
          <command>xvinfo</command>:</para>

        <screen>&prompt.user; <userinput>xvinfo</userinput></screen>

        <para>XVideo è supportato dalla tua scheda se il risultato
          è simile a:</para>

        <screen>X-Video Extension version 2.2
screen #0
  Adaptor #0: "Savage Streams Engine"
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
      "XV_COLORKEY" (range 0 to 16777215)
              client settable attribute
              client gettable attribute (current value is 2110)
      "XV_BRIGHTNESS" (range -128 to 127)
              client settable attribute
              client gettable attribute (current value is 0)
      "XV_CONTRAST" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_SATURATION" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_HUE" (range -180 to 180)
              client settable attribute
              client gettable attribute (current value is 0)
    maximum XvImage size: 1024 x 1024
    Number of image formats: 7
      id: 0x32595559 (YUY2)
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        type: YUV (packed)
      id: 0x32315659 (YV12)
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x30323449 (I420)
        guid: 49343230-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x36315652 (RV16)
        guid: 52563135-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x3e0, 0x7c00
      id: 0x35315652 (RV15)
        guid: 52563136-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x7e0, 0xf800
      id: 0x31313259 (Y211)
        guid: 59323131-0000-0010-8000-00aa00389b71
        bits per pixel: 6
        number of planes: 3
        type: YUV (packed)
      id: 0x0
        guid: 00000000-0000-0000-0000-000000000000
        bits per pixel: 0
        number of planes: 0
        type: RGB (packed)
        depth: 1
        red, green, blue masks: 0x0, 0x0, 0x0</screen>

        <para>Inoltre tieni presente che i formati elencati (YUV2, YUV12, ecc)
          non sono presenti in tutte le implementazioni di XVideo e la loro
          assenza può ostacolare alcuni programmi.</para>

        <para>Se il risultato è:</para>

        <screen>X-Video Extension version 2.2
screen #0
no adaptors present</screen>

        <para>Allora XVideo probabilmente non è supportato per la tua
          scheda.</para>

        <para>Se XVideo non è supportato per la tua scheda, questo vuol
          dire solamente che sarà più difficile soddisfare le
          richieste computazionali per il rendering video.  A seconda della tua
          scheda video e del tuo processore, comunque, potresti essere ancora in
          grado di avere un'esperienza soddisfacente.  Dovrai probabilmente
          dare un occhio ai modi per migliorare le prestazioni nella lettura
          avanzata <xref linkend="video-further-reading"/>.</para>
      </sect3>

      <sect3 xml:id="video-interface-SDL">
        <title>Simple Directmedia Layer</title>

        <para>Il Simple Directmedia Layer, SDL, vuole essere un'interfaccia di
          portabilità tra &microsoft; Windows, BeOS, e &unix;, che possa
          permettere di sviluppare applicazioni multi-piattaforma che facciano
          buon uso di suoni e grafica.  L'interfaccia SDL fornisce una
          astrazione di basso livello all'hardware che può a volte
          essere più efficiente dell'interfaccia X11.</para>

        <para>L'SDL può essere trovata in <package>devel/sdl12</package>.</para>
      </sect3>

      <sect3 xml:id="video-interface-DGA">
        <title>Direct Graphics Access</title>

        <para>Direct Graphics Access è un'estensione di X11
          che permette a un programma di evitare il server X ed alterare
          direttamente il buffer video.  Siccome si basa su una mappatura
          di memoria a basso livello per effettuare questa condivisione,
          i programmi che la usano devono essere avviati da
          <systemitem class="username">root</systemitem>.</para>

        <para>L'estensione DGA può essere testata con &man.dga.1;.
          Quando <command>dga</command> è in esecuzione, cambia i colori
          del display ogni volta che viene premuto un tasto.  Per uscire, premi
          <keycap>q</keycap>.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="video-ports">
      <title>Port e Package che Riguardano il Video</title>

      <indexterm><primary>port video</primary></indexterm>
      <indexterm><primary>package video</primary></indexterm>

      <para>In questa sezione si discuterà del software disponibile
        nella FreeBSD Port Collection che possono essere usati per
        la riproduzione video.  La sezione software sulla riproduzione video
        è in continuo sviluppo, per cui le caratteristiche delle varie
        applicazioni sono destinate a differire dalla descrizione che
        segue.</para>

      <para>In primo luogo, è importante sapere che molte delle
        applicazioni video che girano su FreeBSD sono stati sviluppate come
        applicazioni Linux.  Molte di queste applicazioni sono ancora in fase
        beta.  Alcuni dei problemi che puoi incontrare con i package video su
        FreeBSD comprendono:</para>

      <orderedlist>
        <listitem>
          <para>Un'applicazione non riesce a riprodurre un file generato
            da un'altra applicazione.</para>
        </listitem>

        <listitem>
          <para>Un'applicazione non riesce a riprodurre un file che lei
            stessa ha prodotto.</para>
        </listitem>

        <listitem>
          <para>Lo stesso applicativo posto su due computer diversi,
            ricompilato su ognuno dei due computer, riproduce lo stesso
            file in modo diverso.</para>
        </listitem>

        <listitem>
          <para>Da un filtro apparentemente banale quale il ridimensionamento
            di un'immagine si ottenga un pessimo risultato derivato da una
            routine di ridimensionamento bacata.</para>
        </listitem>

        <listitem>
          <para>Un'applicazione che genera frequentemente file
            <quote>core</quote>.</para>
        </listitem>

        <listitem>
          <para>La documentazione non viene installata con il port e può
            essere trovata sul web o nella directory <filename>work</filename> del port.</para>
        </listitem>
      </orderedlist>

      <para>Molte di queste applicazioni possono anche esibire
        <quote>Linuxismi</quote>. Ovvero, ci possono essere problemi risultanti
        dal modo in cui le librerie standard sono state implementate nelle
        distribuzioni Linux, o alcune modifiche al
        kernel di Linux che sono state apportate dagli autori delle
        applicazioni.  Questi problemi possono non essere stati
        notati e aggirati dal mantainer del port, e possono
        portare comunque a problemi come questi:</para>

      <orderedlist>
        <listitem>
          <para>L'uso di <filename>/proc/cpuinfo</filename> per riconoscere
            le caratteristiche del processore.</para>
        </listitem>

        <listitem>
          <para>Un uso errato dei thread che può portare un programma
            a bloccare la propria esecuzione piuttosto che terminare
            correttamente.</para>
        </listitem>

        <listitem>
          <para>Software non ancora presente nella collezione dei port di
            FreeBSD che è comunemente usato unitamente
            all'applicazione.</para>
        </listitem>
      </orderedlist>

      <para>A questo punto, gli sviluppatori di queste applicazioni sono stati
        collaborativi con i maintainer dei port al fine di minimizzare la
        ricerca di soluzioni necessarie al processo di porting.</para>

      <sect3 xml:id="video-mplayer">
        <title>MPlayer</title>

        <para><application>MPlayer</application> è stata sviluppata di
          recente ed è un player in rapida evoluzione.  Gli obbiettivi
          degli sviluppatori di <application>MPlayer</application> sono la
          velocità e la flessibilità su Linux e le altre famiglie
          di &unix;.  Il progetto è partito non appena il fondatore del
          gruppo si stancò delle prestazioni degli altri riproduttori.
          C'è chi dice che l'interfaccia grafica sia stata sacrificata
          per un design essenziale.  Tuttavia, una volta che si sono imparate
          perfettamente le opzioni da riga di comando e le scorciatoie,
          funziona decisamente bene.</para>

        <sect4 xml:id="video-mplayer-building">
          <title>Compilazione di MPlayer</title>

          <indexterm>
            <primary>MPlayer</primary>
            <secondary>compilazione</secondary>
          </indexterm>

          <para><application>MPlayer</application> è reperibile
            sotto <package>multimedia/mplayer</package>.
            <application>MPlayer</application>
            effettua una serie di controlli sull'hardware durante il
            processo di compilazione, che ha come risultato un binario
            che non potrà essere considerato portabile da una
            piattaforma ad un'altra.  Questo è il motivo per cui
            risulta importante compilarlo usando il port piuttosto che
            il pacchetto contenente il binario.
            Inoltre, ulteriori opzioni possono essere specificate nella riga di
            comando di <command>make</command>, come descritto nel
            <filename>Makefile</filename> e all'inizio della
            compilazione.</para>

          <screen>&prompt.root; <userinput>cd /usr/ports/multimedia/mplayer</userinput>
&prompt.root; <userinput>make</userinput>
N - O - T - E
Take a careful look into the Makefile in order
to learn how to tune mplayer towards you personal preferences!
for example,
make WITH_GTK1
builds MPlayer with GTK1-GUI support.
if you want to use the GUI, you can either install
/usr/ports/multimedia/mplayer-skins
or download official skin collections from
http://www.mplayerhq.hu/homepage/dload.html</screen>

          <para>Le opzioni di default del port dovrebbero essere sufficienti
            per la maggior parte degli utenti.  Tuttavia, se hai bisogno del
            codec XviD, devi specificare l'opzione <varname>WITH_XVID</varname>
            nella riga di comando.  Inoltre puoi definire il dispositivo
            DVD di default con l'opzione <varname>WITH_DVD_DEVICE</varname>,
            altrimenti sarà utilizzato di default
            <filename>/dev/acd0</filename>.</para>

          <para>Al momento, il port <application>MPlayer</application>
            creerà la sua documentazione in HTML e due eseguibili
            <command>mplayer</command>, e <command>mencoder</command>,
            che è uno strumento per la ri-codifica video.</para>

          <para>La documentazione HTML di <application>MPlayer</application>
            è molto istruttiva.
            Qualora il lettore trovasse le informazioni sull'hardware e le
            interfacce video in questo capitolo scarne, la documentazione di
            <application>MPlayer</application> risulta essere un ottimo
            supplemento.
            Se si stanno cercando informazioni riguardo il supporto video sotto
            &unix;, sarebbe utile trovare il tempo di leggere in modo preciso
            la documentazione di <application>MPlayer</application>.</para>
        </sect4>

        <sect4 xml:id="video-mplayer-using">
          <title>Utilizzo di MPlayer</title>

          <indexterm>
            <primary>MPlayer</primary>
            <secondary>utilizzo</secondary>
          </indexterm>

          <para>Ogni utente che voglia usare <application>MPlayer</application>
            deve creare la directory <filename>.mplayer</filename> sotto
            la propria home.  Per creare questa directory necessaria, puoi
            digitare il seguente comando:</para>

          <screen>&prompt.user; <userinput>cd /usr/ports/multimedia/mplayer</userinput>
&prompt.user; <userinput>make install-user</userinput></screen>

          <para>Le opzioni del comando <command>mplayer</command> sono elencate
            nella pagina del manuale.  Per qualunque altro dettaglio consulta
            la documentazione HTML.  In questa sezione, descriveremo solamente
            alcuni degli usi più comuni.</para>

          <para>Per riprodurre un file, ad esempio
            <filename>testfile.avi</filename>, usando
            una delle varie interfacce video usa l'opzione
            <option>-vo</option>:</para>

          <screen>&prompt.user; <userinput>mplayer -vo xv testfile.avi</userinput></screen>

          <screen>&prompt.user; <userinput>mplayer -vo sdl testfile.avi</userinput></screen>

          <screen>&prompt.user; <userinput>mplayer -vo x11 testfile.avi</userinput></screen>

          <screen>&prompt.root; <userinput>mplayer -vo dga testfile.avi</userinput></screen>

          <screen>&prompt.root; <userinput>mplayer -vo 'sdl:dga' testfile.avi</userinput></screen>

          <para>È utile provare tutte queste opzioni, considerando che le
            prestazioni dipendono da svariati fattori e variano in modo
            considerevole a seconda dell'hardware.</para>

          <para>Per riprodurre un DVD, sostituisci
            <filename>testfile.avi</filename> con l'opzione
            <option>dvd://<replaceable>N</replaceable> -dvd-device
              <replaceable>DISPOSITIVO</replaceable></option> dove
            <replaceable>N</replaceable> corrisponde al numero del titolo da
            riprodurre
            e <filename>DISPOSITIVO</filename> al
            dispositivo che identifica il DVD-ROM.  Per esempio, per riprodurre
            il terzo titolo da <filename>/dev/dvd</filename>:</para>

          <screen>&prompt.root; <userinput>mplayer -vo xv dvd://3 -dvd-device /dev/dvd</userinput></screen>

          <note>
            <para>Il dispositivo DVD di default può essere definito
              durante la compilazione del port
              <application>MPlayer</application> tramite l'opzione
              <varname>WITH_DVD_DEVICE</varname>.  Di default, questo
              dispositivo è <filename>/dev/acd0</filename>.  Maggiori
              dettagli posso essere trovati nel <filename>Makefile</filename>
              del port.</para>
          </note>

          <para>Per interrompere, mettere in pausa, andare avanti e così
            via, leggi l'elenco delle associazioni dei tasti, che
            vengono elencati eseguendo <command>mplayer -h</command> o
            consulta la pagina man.</para>

          <para>Ulteriori opzioni utili per la riproduzione sono:
            <option>-fs -zoom</option> che abilita la modalità schermo
            intero e <option>-framedrop</option> che aiuta le
            prestazioni.</para>

          <para>Perchè la riga di comando di mplayer non diventi
            eccessivamente lunga, l'utente può creare il file
            <filename>.mplayer/config</filename> ed impostare lì i
            valori predefiniti:</para>

          <programlisting>vo=xv
fs=yes
zoom=yes</programlisting>

          <para>In ultimo, è possibile usare <command>mplayer</command>
            per estrarre una traccia DVD in un file <filename>.vob</filename>.
            Per estrarre la seconda traccia dal DVD, digita questo:</para>

          <screen>&prompt.root; <userinput>mplayer -dumpstream -dumpfile out.vob dvd://2 -dvd-device /dev/dvd</userinput></screen>

          <para>Il file ottenuto, <filename>out.vob</filename>, sarà
            in formato MPEG e potrà manipolato da un'altro programma
            descritto in questa sezione.</para>
        </sect4>

        <sect4 xml:id="video-mencoder">
          <title>mencoder</title>

          <indexterm><primary>mencoder</primary></indexterm>

          <para>Prima di usare <command>mencoder</command> è una buona
            idea familiarizzare con le opzioni contenute nella
            documentazione HTML.  Esiste anche una pagina man, ma non
            è utile senza la documentazione HTML.  Esiste un numero
            considerevole di modi per migliorare la qualità, un
            bitrate più basso, cambiare codifica ed alcuni di
            questi trucchi può fare la differenza tra prestazioni
            più o meno accettabili.  Di seguito un paio di esempi per
            cominciare.  Prima di tutto, una semplice copia:</para>

          <screen>&prompt.user; <userinput>mencoder input.avi -oac copy -ovc copy -o output.avi</userinput></screen>

          <para>Combinazioni errate di opzioni da riga di comando possono
            portare a file di output irriproducibili perfino con
            <command>mplayer</command>.
            Di conseguenza, se si vuole semplicemente estrarre una traccia,
            usare l'opzione <option>-dumpfile</option> eseguendo
            in <command>mplayer</command>.</para>

          <para>Per convertire il file <filename>input.avi</filename>
            in formato MPEG4 con l'audio codificato in MPEG3 (è
            necessario <package>audio/lame</package>):</para>

          <screen>&prompt.user; <userinput>mencoder input.avi -oac mp3lame -lameopts br=192 \
  -ovc lavc -lavcopts vcodec=mpeg4:vhq -o output.avi</userinput></screen>

          <para>Questo comando ha creato un file riproducibile con
            <command>mplayer</command> e <command>xine</command>.</para>

          <para>Il parametro <filename>input.avi</filename> può
            essere sostituito con <option>dvd://1 -dvd-device /dev/dvd</option>
            ed eseguire il comando come <systemitem class="username">root</systemitem> per
            ricodificare il capitolo DVD direttamente.  Poichè
            si sarà certamente poco soddisfatti del risultato la prima
            volta, è consigliato eseguire il dump del capitolo
            e lavorare direttamente sul file.</para>
        </sect4>
      </sect3>

      <sect3 xml:id="video-xine">
        <title>Il Riproduttore Video xine</title>

        <para>Il riproduttore video <application>xine</application> è un
          progetto dagli ampi obiettivi e non solo l'essere una soluzione
          unica per la riproduzione, ma anche una libreria di base
          riutilizzabile ed un eseguibile modulare che possa essere
          esteso con i plugin.  È disponibile sia come pacchetto che
          come port, sotto <package>multimedia/xine</package>.</para>

        <para><application>xine</application>
          è ancora un pò rozzo, ma è chiaramente un buon
          inizio.
          In pratica, <application>xine</application> necessita sia di una
          CPU veloce che di una scheda video veloce o il supporto per
          l'estensione XVideo.  L'interfaccia grafica è utilizzabile,
          ma ancora mal disegnata.</para>

        <para>Allo stato attuale, non ci sono moduli distribuiti con
          <application>xine</application> che possano riprodurre DVD
          codificati in CSS.  Esistono distribuzioni di terze parti che
          hanno moduli di questo genere già compilati, ma nessuno
          di questi esiste nella FreeBSD Ports Collection.</para>

        <para>Comparato con <application>MPlayer</application>,
          <application>xine</application> offre maggiori caratteristiche
          all'utente ma, allo stesso tempo, non rende disponibile
          all'utente un controllo più accurato.  Il riproduttore video
          <application>xine</application> funziona molto meglio sulle interfacce
          XVideo.</para>

        <para>Di default, <application>xine</application> si avvierà con
          un'interfaccia grafica.  Si possono quindi usare i menu per aprire
          per aprire un file specifico:</para>

        <screen>&prompt.user; <userinput>xine</userinput></screen>

        <para>Alternativamente, può essere invocato per aprire
          direttamente un file senza l'interfaccia grafica, con il
          comando:</para>

        <screen>&prompt.user; <userinput>xine -g -p mymovie.avi</userinput></screen>
      </sect3>

      <sect3 xml:id="video-ports-transcode">
        <title>Le Utility transcode</title>

        <para>Il software <application>transcode</application> non è un
          riproduttore, piuttosto un insieme di strumenti per ricodificare file
          audio e video.  Con
          <application>transcode</application>, si ha la possibilità di
          unire file video, riparare file corrotti ed utilizzare strumenti
          da riga di comando con interfaccie che utilizzano i flussi
          <filename>stdin/stdout</filename>.</para>

        <para>Durante la compilazione del port
          <package>multimedia/transcode</package> possono
          essere specificate diverse opzioni, noi ti consigliamo il
          comando seguente per compilare
          <application>transcode</application>:</para>

        <screen>&prompt.root; <userinput>make WITH_OPTIMIZED_CFLAGS=yes WITH_LIBA52=yes WITH_LAME=yes WITH_OGG=yes \
WITH_MJPEG=yes -DWITH_XVID=yes</userinput></screen>

        <para>I settaggi proposti dovrebbero essere sufficienti
          per la maggior parte degli utenti.</para>

        <para>Per illustrare le capacità di
          <command>transcode</command>, viene dato un esempio
          che mostra come convertire un file DivX in un file
          PAL MPEG-1 (PAL VCD):</para>

        <screen>&prompt.user; <userinput>transcode -i input.avi -V --export_prof vcd-pal -o output_vcd</userinput>
&prompt.user; <userinput>mplex -f 1 -o output_vcd.mpg output_vcd.m1v output_vcd.mpa</userinput></screen>

        <para>Il file MPEG risultante,
          <filename>output_vcd.mpg</filename>, è pronto per essere
          letto con <application>MPlayer</application>.  Puoi perfino
          masterizzare il file su un CD-R per creare un Video CD, e in
          questo caso necessiti di installare ed usare i programmi
          <package>multimedia/vcdimager</package> e
          <package>sysutils/cdrdao</package>.</para>

        <para>Esiste una pagina man per <command>transcode</command>, ma
          dovresti anche consultare il <link xlink:href="http://www.transcoding.org/cgi-bin/transcode">wiki
            di transcode</link> per ulteriori informazioni
          ed esempi.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="video-further-reading">
      <title>Ulteriori Letture</title>

      <para>I vari package di applicazioni video per FreeBSD si stanno
        evolvendo rapidamente.  È abbastanza possibile che in un futuro
        vicino molti dei problemi discussi qui saranno risolti.  Nel frattempo,
        chiunque voglia ottenere il massimo dalle
        capacità A/V di FreeBSD, dovrà unire alla meglio la
        conoscenza che deriva dalle svariate FAQ e guide con l'uso di queste
        poche applicazioni.  Questa sezione esiste per fornire al lettore
        indicazioni a queste informazioni aggiuntive.</para>

      <para>La <link xlink:href="http://www.mplayerhq.hu/DOCS/">Documentazione
          di MPlayer</link> è molto istruttiva sul piano tecnico.
        Questa documentazione, probabilmente, dovrà essere consultata
        da chiunque voglia ottenere un alto grado di conoscenza del video
        sotto &unix;.  La mailing list di <application>MPlayer</application>
        risulta abbastanza ostile a chiunque non si sia preoccupato di
        leggere la documentazione, se si ha intenzione di segnalar loro un
        bug, RTFM.</para>

      <para>L'<link xlink:href="http://dvd.sourceforge.net/xine-howto/en_GB/html/howto.html">HOWTO
          di xine</link> contiene un capitolo su come aumentare le prestazioni
        che è comune a tutti i riproduttori.</para>

      <para>In ultimo, ci sono alcuni applicativi promettenti che il
        lettore può provare:</para>

      <itemizedlist>
        <listitem>
          <para><link xlink:href="http://avifile.sourceforge.net/">Avifile</link> che
            è anche un port <package>multimedia/avifile</package>.</para>
        </listitem>

        <listitem>
          <para><link xlink:href="http://www.dtek.chalmers.se/groups/dvd/">Ogle</link>
            che è anche un port <package>multimedia/ogle</package>.</para>
        </listitem>

        <listitem>
          <para><link xlink:href="http://xtheater.sourceforge.net/">Xtheater</link></para>
        </listitem>

        <listitem>
          <para><package>multimedia/dvdauthor</package>, un package open
            source per la creazione di DVD.</para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 xml:id="tvcard">
    <info><title>Configurazione delle Schede TV</title>
      <authorgroup>
        <author><personname><firstname>Josef</firstname><surname>El-Rayes</surname></personname><contrib>Contributo originale di </contrib></author>
      </authorgroup>

      <authorgroup>
        <author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Ampliato e adattato da </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>schede TV</primary></indexterm>

    <sect2>
      <title>Introduzione</title>

      <para>Le schede TV permettono di visualizzare la TV via onde radio o via
        cavo sul tuo computer.  La maggior parte di queste accettano in input
        video composito tramite connettori RCA o S-video e alcune di queste
        schede hanno un sintonizzatore radio FM.</para>

      <para>&os; fornisce supporto per le schede TV su bus PCI che usano un
        chip di acquisizione video Brooktree Bt848/849/878/879 o Conexant
        CN-878/Fusion 878a tramite il driver &man.bktr.4;. Devi anche
        assicurarti che la scheda abbia un sintonizzatore supportato, consulta
        la pagina man di &man.bktr.4; per una lista dei sintonizzatori
        supportati.</para>
    </sect2>

    <sect2>
      <title>Aggiunta del Driver</title>

      <para>Per usare la scheda, devi caricare il driver &man.bktr.4;, e questo
        può essere fatto aggiungendo la seguente riga al file
        <filename>/boot/loader.conf</filename> in questo modo:</para>

      <programlisting>bktr_load="YES"</programlisting>

      <para>Alternativamente, puoi compilare staticamente il supporto per la
        scheda TV nel tuo kernel, in questo caso aggiungi le seguenti righe
        alla configurazione del tuo kernel:</para>

      <programlisting>device    bktr
device iicbus
device iicbb
device smbus</programlisting>

      <para>Questi driver aggiuntivi sono necessari poiché le
        componenti della scheda sono interconnesse tramite un bus I2C.
        Quindi compila ed installa un nuovo kernel.</para>

      <para>Una volta che hai aggiunto il supporto al tuo sistema, devi
        riavviare la macchina.  Durante il processo di avvio, la tua scheda TV
        dovrebbe apparire, come in questo esempio:</para>

      <programlisting>bktr0: &lt;BrookTree 848A&gt; mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: &lt;I2C bit-banging driver&gt; on bti2c0
iicbus0: &lt;Philips I2C bus&gt; on iicbb0 master-only
iicbus1: &lt;Philips I2C bus&gt; on iicbb0 master-only
smbus0: &lt;System Management Bus&gt; on bti2c0
bktr0: Pinnacle/Miro TV, Philips SECAM tuner.</programlisting>

      <para>Ovviamente questi messaggi possono differire a seconda
        dell'hardware.  Tuttavia dovresti controllare se il sintonizzatore
        viene rilevato correttamente; è sempre possibile modificare
        alcuni dei parametri rilevati tramite le MIB di &man.sysctl.8; e le
        opzioni nel file di configurazione del kernel.  Ad esempio, se vuoi
        imporre che il sintonizzatore sia un Philips SECAM, dovresti aggiungere
        la riga seguente al file di configurazione del kernel:</para>

      <programlisting>options OVERRIDE_TUNER=6</programlisting>

      <para>o puoi usare direttamente &man.sysctl.8;:</para>

      <screen>&prompt.root; <userinput>sysctl hw.bt848.tuner=6</userinput></screen>

      <para>Guarda la pagina man di &man.bktr.4; e il file
        <filename>/usr/src/sys/conf/NOTES</filename> per maggiori dettagli
        sulle opzioni disponibili.</para>
    </sect2>

    <sect2>
      <title>Applicazioni Utili</title>

      <para>Per usare la tua scheda TV devi installare una delle seguenti
        applicazioni:</para>

      <itemizedlist>
        <listitem>
          <para><package>multimedia/fxtv</package>
            fornisce capacità di TV-in-una-finestra e acquisizione di
            immagini/audio/video.</para>
        </listitem>

        <listitem>
          <para><package>multimedia/xawtv</package>
            è anch'esso un'applicazione TV, con le stesse caratteristiche
            di <application>fxtv</application>.</para>
        </listitem>

        <listitem>
          <para><package>misc/alevt</package> decodifica e
            visualizza Videotext/Teletext.</para>
        </listitem>

        <listitem>
          <para><package>audio/xmradio</package>,
            un'applicazione per usare il sintonizzatore radio FM che hanno
            alcune schede TV.</para>
        </listitem>

        <listitem>
          <para><package>audio/wmtune</package>,
            un'applicazione desktop maneggevole per i sintonizzatori
            radio.</para>
        </listitem>
      </itemizedlist>

      <para>Altre applicazioni sono disponibili nella &os; Ports
        Collection.</para>
    </sect2>

    <sect2>
      <title>Risoluzione dei Problemi</title>

      <para>Se incontri qualche problema con la tua scheda TV, dovresti
        verificare dapprima se il chip di acquisizione video e il
        sintonizzatore sono realmente supportati dal driver &man.bktr.4; e se
        hai usato le corrette opzioni di configurazione.  Per maggiore supporto
        e varie domande sulla tua scheda video potresti voler leggere ed
        usare gli archivi della mailing list &a.multimedia.name;.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="scanners">
    <info><title>Scanner di immagini</title>
      <authorgroup>
        <author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Scritto da </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>scanner di immagini</primary></indexterm>

    <sect2>
      <title>Introduzione</title>

      <para>In &os;, l'accesso agli scanner è fornito
        dalle <acronym role="Interfaccia di Programmazione           dell'Applicazione">API</acronym> di <application>SANE</application>
        (Scanner Access Now Easy) disponibili nella collezione dei port di &os;.
        <application>SANE</application> usa anche alcuni driver dei dispositivi
        di &os; per accedere all'hardware dello scanner.</para>

      <para>&os; supporta sia scanner SCSI che USB.  Verifica che
        il tuo scanner sia supportato da <application>SANE</application>
        prima di effettuare ogni configurazione.
        <application>SANE</application> ha una lista di <link xlink:href="http://www.sane-project.org/sane-supported-devices.html">dispositivi
        supportati</link>, che può fornire informazioni riguardo il
        supporto per uno scanner ed il suo stato.  La pagina man
        &man.uscanner.4; fornisce una lista di scanner USB supportati.</para>
    </sect2>

    <sect2>
      <title>Configurazione del Kernel</title>

      <para>Come già menzionato, sono supportati sia scanner USB che
        SCSI.  A seconda dell'interfaccia del tuo scanner, sono richiesti
        diversi driver dei dispositivi.</para>

      <sect3 xml:id="scanners-kernel-usb">
        <title>Interfaccia USB</title>

        <para>Il kernel <filename>GENERIC</filename> di default include i
          driver dei dispositivi necessari per il funzionamento degli scanner
          USB.  In caso tu voglia usare un kernel custom, accertati che le linee
          seguenti siano presenti nel tuo file di configurazione del
          kernel:</para>

        <programlisting>device usb
device uhci
device ohci
device uscanner</programlisting>

        <para>A seconda del tipo di chipset USB sulla tua scheda madre,
          hai bisogno solo di una fra le opzioni <literal>device uhci</literal>
          e <literal>device ohci</literal>, comunque avere entrambe le linee nel
          proprio file di configurazione del kernel non crea problemi.</para>

        <para>Se non intendi ricompilare un kernel custom ed il tuo
          kernel non è il <filename>GENERIC</filename>, puoi
          direttamente caricare il modulo del driver del dispositivo di
          &man.uscanner.4; con il comando &man.kldload.8;:</para>

        <screen>&prompt.root; <userinput>kldload uscanner</userinput></screen>

        <para>Per caricare il modulo ad ogni avvio di sistema, aggiungi la
          seguente linea al file <filename>/boot/loader.conf</filename>:</para>

        <programlisting>uscanner_load="YES"</programlisting>

        <para>Dopo aver riavviato con il kernel corretto, o dopo aver caricato
          il modulo necessario, attacca il tuo scanner USB.  Nel buffer dei
          messaggi di sistema (&man.dmesg.8;) dovrebbe apparire una riga che
          mostra il riconoscimento dello scanner:</para>

        <screen>uscanner0: EPSON EPSON Scanner, rev 1.10/3.02, addr 2</screen>

        <para>Questo mostra che il nostro scanner usa il nodo del dispositivo
          <filename>/dev/uscanner0</filename>.</para>
      </sect3>

      <sect3>
        <title>Interfaccia SCSI</title>

        <para>Se il tuo scanner possiede un'interfaccia SCSI, è
          importante sapere quale controller SCSI usi.  A seconda del chipset
          SCSI usato, dovrai modificare il tuo file di configurazione
          del kernel.  Il kernel <filename>GENERIC</filename> supporta
          i più comuni controller SCSI.  Accertati di leggere il file di
          <filename>NOTES</filename> e aggiungi la linea corretta al tuo file di
          configurazione del kernel.  Oltre al driver dell'interfaccia SCSI,
          devi avere le seguenti linee nel tuo file di configurazione
          del kernel:</para>

        <programlisting>device scbus
device pass</programlisting>

        <para>Una volta che il kernel è stato correttamente compilato
          ed installato, dovresti vedere i dispositivi nel buffer dei
          messaggi di sistema, al momento del boot:</para>

        <screen>pass2 at aic0 bus 0 target 2 lun 0
pass2: &lt;AGFA SNAPSCAN 600 1.10&gt; Fixed Scanner SCSI-2 device
pass2: 3.300MB/s transfers</screen>

        <para>Se il tuo scanner non era acceso al momento dell'avvio, è
          ancora possibile forzare manualmente il riconoscimento attraverso uno
          scan del bus SCSI con il comando &man.camcontrol.8;:</para>

        <screen>&prompt.root; <userinput>camcontrol rescan all</userinput>
Re-scan of bus 0 was successful
Re-scan of bus 1 was successful
Re-scan of bus 2 was successful
Re-scan of bus 3 was successful</screen>

        <para>A questo punto lo scanner apparirà nella lista
          dei device SCSI:</para>

        <screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 5 lun 0 (pass0,da0)
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 6 lun 0 (pass1,da1)
&lt;AGFA SNAPSCAN 600 1.10&gt;           at scbus1 target 2 lun 0 (pass3)
&lt;PHILIPS CDD3610 CD-R/RW 1.00&gt;     at scbus2 target 0 lun 0 (pass2,cd0)</screen>

        <para>Ulteriori dettagli sui dispositivi SCSI sono
          disponibili nelle pagine man &man.scsi.4; e &man.camcontrol.8;.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Configurazione di SANE</title>

      <para>Il sistema <application>SANE</application> è
        diviso in due parti: il backend (<package>graphics/sane-backends</package>) ed il frontend
        (<package>graphics/sane-frontends</package>).
        La parte backend fornisce accesso allo scanner.  La lista dei
        <link xlink:href="http://www.sane-project.org/sane-supported-devices.html">dispositivi
          supportati</link> da <application>SANE</application> specifica quale
        backend supporta il tuo scanner di immagini.  È necessario
        determinare il corretto backend per il tuo scanner se intendi usare il
        tuo dispositivo.  La parte frontend fornisce l'interfaccia grafica
        allo scanning (<application>xscanimage</application>).</para>

      <para>La prima cosa da fare è installare il port o il pacchetto
        <package>graphics/sane-backends</package>.
        Quindi, usa il comando <command>sane-find-scanner</command>
        per verificare il riconoscimento dello scanner da parte
        del sistema <application>SANE</application>:</para>

      <screen>&prompt.root; <userinput>sane-find-scanner -q</userinput>
found SCSI scanner "AGFA SNAPSCAN 600 1.10" at /dev/pass3</screen>

      <para>L'output mostrerà il tipo di interfaccia dello
        scanner ed il nodo del dispositivo usato per connettere lo scanner
        al sistema.  La marca ed il nome del modello potrebbero
        non comparire, non è importante.</para>

      <note>
        <para>Alcuni scanner USB richiedono il caricamento di un firmware,
          ciò è spiegato nella pagina man del backend.  È
          utile anche leggere le pagine man di &man.sane-find-scanner.1; e di
          &man.sane.7;.</para>
      </note>

      <para>Adesso dobbiamo verificare se lo scanner sarà identificato
        da un frontend di scanning.  Di default, il backend di
        <application>SANE</application> fornisce un programma da linea di
        comando chiamato &man.scanimage.1;.  Questo comando ti permette di
        elencare i dispositivi ed effettuare un'acquisizione di immagini da
        linea di comando.  L'opzione <option>-L</option> è usata per
        ottenere una lista di scanner:</para>

      <screen>&prompt.root; <userinput>scanimage -L</userinput>
device `snapscan:/dev/pass3' is a AGFA SNAPSCAN 600 flatbed scanner</screen>

      <para>Nessun output o un messaggio che dice che nessuno scanner
        è stato identificato indica che &man.scanimage.1; non è
        in grado di identificare lo scanner.  Se ciò succede, dovrai
        editare il file di configurazione del backend ed indicare il driver
        del dispositivo usato dallo scanner.  La directory <filename>/usr/local/etc/sane.d/</filename> contiene tutti i
        file di configurazione del backend.  Questo problema di identificazione
        avviene con alcuni scanner USB.</para>

      <para>Ad esempio, usando <xref linkend="scanners-kernel-usb"/>,
        <command>sane-find-scanner</command> su uno scanner USB otteniamo
        la seguente informazione:</para>

      <screen>&prompt.root; <userinput>sane-find-scanner -q</userinput>
found USB scanner (UNKNOWN vendor and product) at device
/dev/uscanner0</screen>

      <para>Lo scanner è stato riconosciuto correttamente, usa
        l'interfaccia USB ed è attaccato al nodo del dispositivo
        <filename>/dev/uscanner0</filename>.  Ora possiamo testare
        se lo scanner è correttamente identificato:</para>

      <screen>&prompt.root; <userinput>scanimage -L</userinput>

Nessun scanner è stato identificato. Se ti aspettavi qualcosa di diverso,
verifica che lo scanner sia collegato, accendilo e avvia il tool di
riconoscimento degli scanner di sane (se adatto). Per cortesia leggi la
documentazione fornita con questo software (README, FAQ, pagine man).</screen>

      <para>Dato che lo scanner non è stato identificato, dovremo editare
        il file <filename>/usr/local/etc/sane.d/epson.conf</filename>.
        Il modello di scanner usato è l'&epson.perfection; 1650,
        così sappiamo che userà il backend
        <literal>epson</literal>.  Accertati di leggere i commenti di aiuto nei
        file di configurazione del backend.  Le modifiche alle linee sono
        abbastanza semplici: commenta tutte le linee che hanno un'interfaccia
        non adatta al tuo scanner (nel nostro caso, commenteremo tutte le linee
        che iniziano con la parola <literal>scsi</literal> dato che il nostro
        scanner usa l'interfaccia USB), quindi aggiungi alla fine del
        file una linea che specifica l'interfaccia ed il nodo di dispositivo
        usato.  In questo caso, aggiungiamo la seguente linea:</para>

      <programlisting>usb /dev/uscanner0</programlisting>

      <para>Sei invitato a leggere i commenti presenti nel file di
        configurazione del backend così come le pagine man del backend
        per più dettagli e per la corretta sintassi da usare.  Ora
        possiamo verificare se lo scanner è identificato:</para>

      <screen>&prompt.root; <userinput>scanimage -L</userinput>
device `epson:/dev/uscanner0' is a Epson GT-8200 flatbed scanner</screen>

      <para>Il nostro scanner USB è stato riconosciuto.
        Non è importante se la marca ed il modello non coincidono
        con il proprio scanner.
        Il punto principale a cui prestare attenzione è il campo
        <literal>`epson:/dev/uscanner0'</literal>, che ci dà il
        corretto nome del backend ed il corretto nodo del dispositvo.</para>

      <para>Una volta che il comando <command>scanimage -L</command>
        è in grado di vedere lo scanner, la configurazione
        è completa.  Il dispositivo ora è in grado di
        scannerizzare.</para>

      <para>Mentre &man.scanimage.1; ci permette di effettuare
        l'acquisizione di un'immagine dalla linea di comando, è
        preferibile usare un'interfaccia grafica per effettuare
        scansioni di immagini.  <application>SANE</application>
        offre una semplice ma efficace interfaccia grafica:
        <application>xscanimage</application> (<package>graphics/sane-frontends</package>).</para>

      <para><application>Xsane</application> (<package>graphics/xsane</package>) è un altro comune
        frontend grafico di scanning.  Questo frontend offre caratteristiche
        avanzate come varie tecniche di scanning (fotocopia, fax, etc.),
        correzione del colore, scans multipli, etc.  Entrambe queste
        applicazioni sono fruibili come plugin di
        <application>GIMP</application>.</para>
    </sect2>

    <sect2>
      <title>Permettere ad Altri Utenti l'Accesso allo Scanner</title>

      <para>Tutte le operazioni precedenti sono state compiute
        con privilegi di <systemitem class="username">root</systemitem>.  Tuttavia potresti aver
        bisogno che altri utenti abbiano accesso allo scanner.  L'utente
        necessiterà permessi di lettura e scrittura sul nodo di
        dispositivo usato dallo scanner.  Per esempio, il nostro scanner USB
        usa il nodo di dispositivo <filename>/dev/uscanner0</filename> che
        appartiene al gruppo <systemitem class="groupname">operator</systemitem>.  Aggiungendo
        l'utente <systemitem class="username">joe</systemitem> al gruppo
        <systemitem class="groupname">operator</systemitem> gli permetterà di usare lo
        scanner:</para>

      <screen>&prompt.root; <userinput>pw groupmod operator -m joe</userinput></screen>

      <para>Per maggiori informazioni consulta la pagina man di &man.pw.8;.
        Inoltre devi settare corretamente i permessi di scrittura (0660 o 0664)
        per il nodo del dispositivo <filename>/dev/uscanner0</filename>; di
        default il gruppo <systemitem class="groupname">operator</systemitem> può solo
        leggere questo nodo di dispositivo.  Tale operazione può essere
        realizzata aggiungendo la seguente riga al file
        <filename>/etc/devfs.rules</filename>:</para>

      <programlisting>[system=5]
add path uscanner0 mode 660</programlisting>

      <para>Quindi aggiungi la seguente riga al file
        <filename>/etc/rc.conf</filename> e riavvia la macchina:</para>

      <programlisting>devfs_system_ruleset="system"</programlisting>

      <para>Ulteriori informazioni riguardo queste righe possono essere trovate
        nella pagina man di &man.devfs.8;.</para>

      <note>
        <para>Chiaramente, per ragioni di sicurezza, dovresti pensarci due
          volte prima di aggiungere un utente a qualsiasi gruppo, specialmente
          al gruppo <systemitem class="groupname">operator</systemitem>.</para>
      </note>
    </sect2>
  </sect1>
</chapter>
