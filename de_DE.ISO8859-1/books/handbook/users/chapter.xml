<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/users/chapter.xml,v 1.47 2012/04/30 16:19:09 bcr Exp $
     basiert auf: 1.63
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="users">
  <info><title>Benutzer und grundlegende Account-Verwaltung</title>
    <authorgroup>
      <author><personname><firstname>Neil</firstname><surname>Blakey-Milner</surname></personname><contrib>Beigetragen von </contrib></author>
    </authorgroup>
    
    <authorgroup>
      <author><personname><firstname>Robert</firstname><surname>Drehmel</surname></personname><contrib>Übersetzt von </contrib></author>
    </authorgroup>
    
  </info>

  

  <sect1 xml:id="users-synopsis">
    <title>Übersicht</title>

    <para>Einen FreeBSD-Computer können mehrere Benutzer zur selben
      Zeit benutzen, allerdings kann immer nur einer vor der Konsole sitzen
      <footnote>
	<para>Außer Sie verwenden, wie in <xref linkend="serialcomms"/> besprochen,  zusätzliche Terminals</para>
      </footnote>, über das Netzwerk können beliebig viele
      Benutzer angemeldet sein.  Jeder Benutzer muss einen Account
      haben, um das System benutzen zu können.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</para>

    <itemizedlist>
      <listitem>
	<para>die verschiedenen Account-Typen von FreeBSD kennen,</para>
      </listitem>

      <listitem>
	<para>wissen, wie Accounts angelegt werden,</para>
      </listitem>

      <listitem>
	<para>wissen, wie Sie Accounts löschen,</para>
      </listitem>

      <listitem>
	<para>wie Sie Attribute eines Accounts, wie den Loginnamen oder
	  die Login-Shell ändern,</para>
      </listitem>

      <listitem>
	<para>wissen, wie Sie Limits für einen Account setzen, um
	  beispielsweise Ressourcen, wie Speicher oder CPU-Zeit,
	  einzuschränken,</para>
      </listitem>

      <listitem>
	<para>wie Sie mit Gruppen die Verwaltung der Accounts
	  vereinfachen.</para>
      </listitem>
    </itemizedlist>

    <para>Vor dem Lesen dieses Kapitels sollten Sie</para>

    <itemizedlist>
      <listitem>
	<para>die Grundlagen von &unix; und FreeBSD (<xref linkend="basics"/>)
	  verstanden haben.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="users-introduction">
    <title>Einführung</title>

    <para>Jeder Zugriff auf das System geschieht über Accounts und alle
      Prozesse werden von Benutzern gestartet, also sind Benutzer- und
      Account-Verwaltung von wesentlicher Bedeutung in FreeBSD-Systemen.</para>

    <para>Mit jedem Account eines FreeBSD-Systems sind bestimmte Informationen
      verknüpft, die diesen Account identifizieren.</para>

    <variablelist>
      <varlistentry>
	<term>Loginnamen</term>

	<listitem>
	  <para>Den Loginnamen geben Sie bei der Anmeldung ein, wenn Sie
	    dazu mit <prompt>login:</prompt> aufgefordert werden.
	    Loginnamen müssen auf dem System eindeutig sein, das
	    heißt auf einem System kann es nicht zwei Accounts mit
	    demselben Loginnamen geben.  In &man.passwd.5; wird
	    beschrieben, wie ein gültiger Loginname gebildet wird.
	    Normalerweise sollten Sie Namen verwenden, die aus
	    Kleinbuchstaben bestehen und bis zu acht Zeichen lang sind.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Passwort</term>

	<listitem>
	  <para>Mit jedem Account ist ein Passwort verknüpft.  Wenn
	    das Passwort leer ist, wird es bei der Anmeldung nicht
	    abgefragt.  Das ist allerdings nicht zu empfehlen, daher sollte
	    jeder Account ein Passwort besitzen.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>User ID (UID)</term>

	<listitem>
	  <para>Die UID ist üblicherweise eine Zahl zwischen
	    0 und 65535<footnote xml:id="users-largeuidgid">
	      <para>Für UIDs und GIDs können Zahlen bis
		einschließlich 4294967295 verwendet werden.
		Allerdings können solche IDs erhebliche
		Probleme mit Anwendungen verursachen, die
		Annahmen über den Wertebereich der IDs
		treffen.</para>
	    </footnote>, die einen
	    Account eindeutig identifiziert.  Intern verwendet FreeBSD nur
	    die UID, Loginnamen werden zuerst in eine UID umgewandelt,
	    mit der das System dann weiter arbeitet.  Das bedeutet, dass
	    Sie Accounts mit unterschiedlichen Loginnamen aber gleicher
	    UID einrichten können.  Vom Standpunkt des Systems handelt
	    es sich dabei um denselben Account.  In der Praxis werden Sie
	    diese Eigenschaft des Systems wahrscheinlich nicht
	    benutzen.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Group ID (GID)</term>

	<listitem>
	  <para>Die GID ist üblicherweise eine Zahl zwischen 0 und
	    65536<footnoteref linkend="users-largeuidgid"/>, die eine Gruppe
	    eindeutig identifiziert.  Mit Gruppen kann der Zugriff auf
	    Ressourcen über die GID anstelle der UID geregelt werden.
	    Einige Konfigurationsdateien werden durch diesen Mechanismus
	    deutlich kleiner.  Ein Account kann mehreren Gruppen
	    zugehören.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Login-Klasse</term>

	<listitem>
	  <para>Login-Klassen erweitern das Gruppenkonzept.  Sie
	    erhöhen die Flexibilität des Systems in der Handhabung
	    der verschiedenen Accounts.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Gültigkeit von Passwörtern</term>

	<listitem>
	  <para>Ein regelmäßiges Ändern des Passworts wird in
	    der Voreinstellung von FreeBSD nicht erzwungen.  Sie
	    können allerdings einen Passwortwechsel nach einer
	    gewissen Zeit auf Basis einzelner Accounts erzwingen.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Verfallszeit eines Accounts</term>

	<listitem>
	  <para>In der Voreinstellung verfallen unter FreeBSD keine
	    Accounts.  Wenn Sie Accounts einrichten, die nur für eine
	    bestimmte Zeit gültig sein sollen, beispielsweise Accounts
	    für Teilnehmer eines Praktikums, können Sie angeben,
	    wie lange der Account gültig sein soll.  Nachdem die
	    angegebene Zeitspanne verstrichen ist, kann dieser Account
	    nicht mehr zum Anmelden verwendet werden, obwohl alle
	    Verzeichnisse und Dateien, die diesem Account gehören,
	    noch vorhanden sind.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>vollständiger Benutzername</term>

	<listitem>
	  <para>FreeBSD identifiziert einen Account eindeutig über
	    den Loginnamen, der aber keine Ähnlichkeit mit dem
	    richtigen Namen des Benutzers haben muss.  Der
	    vollständige Benutzername kann daher beim Einrichten eines
	    Accounts angegeben werden.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Heimatverzeichnis</term>

	<listitem>
	  <para>Das Heimatverzeichnis gibt den vollständigen Pfad zu
	    dem Verzeichnis an, in dem sich der Benutzer nach erfolgreicher
	    Anmeldung befindet.  Es ist üblich, alle
	    Heimatverzeichnisse unter
	    <filename>/home/Loginname</filename>
	    oder
	    <filename>/usr/home/Loginname</filename>
	    anzulegen.  Im Heimatverzeichnis oder in dort angelegten
	    Verzeichnissen werden die Dateien eines Benutzers
	    gespeichert.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Login-Shell</term>

	<listitem>
	  <para>Grundsätzlich ist die Schnittstelle zum System eine
	    Shell, von denen es viele unterschiedliche gibt.  Die
	    bevorzugte Shell eines Benutzers kann seinem Account zugeordnet
	    werden.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Es gibt drei Haupttypen von Accounts: Der
      <link linkend="users-superuser">Superuser</link>,
      <link linkend="users-system">Systembenutzer</link> und
      <link linkend="users-user">Benutzer-Accounts</link>.  Der
      Superuser-Account, normalerweise <systemitem class="username">root</systemitem> genannt, wird
      benutzt, um das System ohne Beschränkungen auf Privilegien zu
      verwalten.  Systembenutzer starten Dienste.  Abschließend werden
      Benutzer-Accounts von echten Menschen genutzt, die sich einloggen, Mails
      lesen und so weiter.</para>
  </sect1>

  <sect1 xml:id="users-superuser">
    <title>Der Superuser-Account</title>

    <indexterm>
      <primary>Accounts</primary>
      <secondary>Superuser (root)</secondary>
    </indexterm>

    <para>Der Superuser-Account, normalerweise <systemitem class="username">root</systemitem>
      genannt, ist vorkonfiguriert und erleichtert die Systemverwaltung, sollte
      aber nicht für alltägliche Aufgaben wie das Verschicken und
      Empfangen von Mails, Entdecken des Systems oder Programmierung benutzt
      werden.</para>

    <para>Das ist so, da der Superuser im Gegensatz zu normalen
      Benutzer-Accounts ohne Beschränkungen operiert und falsche
      Anwendung des Superuser-Accounts in spektakulären Katastrophen
      resultieren kann.  Benutzer-Accounts sind nicht in der Lage, das System
      versehentlich zu zerstören, deswegen ist es generell am besten
      normale Benutzer-Accounts zu verwenden, solange man nicht
      hauptsächlich die extra Privilegien benötigt.</para>

    <para>Kommandos, die Sie als Superuser eingeben, sollten Sie immer
      doppelt und dreifach überprüfen, da ein
      zusätzliches Leerzeichen oder ein fehlender Buchstabe irreparablen
      Datenverlust bedeuten kann.</para>

    <para>Das erste, das Sie tun sollten, nachdem Sie dieses Kapitel gelesen
      haben, ist einen unprivilegierten Benutzer für Ihre eigene normale
      Benutzung zu erstellen, wenn Sie das nicht bereits getan haben.  Das
      trifft immer zu, egal ob Sie ein Mehrbenutzersystem oder ein System
      laufen haben, welches Sie alleine benutzen.  Später in diesem
      Kapitel besprechen wir, wie man zusätzliche Accounts erstellt und
      wie man zwischen dem normalen Benutzer und dem Superuser wechselt.</para>
  </sect1>

  <sect1 xml:id="users-system">
    <title>System-Accounts</title>

    <indexterm>
      <primary>Accounts</primary>
      <secondary>System-Accounts</secondary>
    </indexterm>

    <para>Systembenutzer starten Dienste wie DNS, Mail-Server, Web-Server und so
      weiter.  Der Grund dafür ist die Sicherheit; wenn die Programme
      von dem Superuser gestartet werden, können Sie ohne
      Einschränkungen handeln.</para>

    <indexterm>
      <primary>Accounts</primary>
      <secondary><systemitem class="username">daemon</systemitem></secondary>
    </indexterm>
    <indexterm>
      <primary>Accounts</primary>
      <secondary><systemitem class="username">operator</systemitem></secondary>
    </indexterm>
    <para>Beispiele von Systembenutzern sind <systemitem class="username">daemon</systemitem>,
      <systemitem class="username">operator</systemitem>, <systemitem class="username">bind</systemitem> (für den
      Domain Name Service) und <systemitem class="username">news</systemitem> und
      <systemitem class="username">www</systemitem>.</para>

    <indexterm>
      <primary>Accounts</primary>
      <secondary><systemitem class="username">nobody</systemitem></secondary>
    </indexterm>
    <para><systemitem class="username">nobody</systemitem> ist der generische unprivilegierte
      Systembenutzer.  Bedenken Sie aber, dass je mehr Dienste
      <systemitem class="username">nobody</systemitem> benutzen, desto mehr Dateien und Prozesse
      diesem Benutzer gehören und dieser Benutzer damit umso
      privilegierter wird.</para>
  </sect1>

  <sect1 xml:id="users-user">
    <title>Benutzer-Accounts</title>

    <indexterm>
      <primary>Accounts</primary>
      <secondary>Benutzer-Accounts</secondary>
    </indexterm>

    <para>Benutzer-Accounts sind das primäre Mittel des Zugriffs für
      Menschen auf das System und isolieren Benutzer und Umgebung,
      schützen die Benutzer davor, das System oder Daten anderer Benutzer
      zu beschädigen und erlauben Benutzern ihre Umgebung selbst
      einzurichten, ohne das sich dies auf andere auswirkt.</para>

    <para>Jede Person, die auf Ihr System zugreift, sollte ihren eigenen
      Account besitzen.  Das erlaubt Ihnen herauszufinden, wer was macht
      und hält Leute davon ab, die Einstellungen der anderen zu
      verändern oder Mails zu lesen, die nicht für sie bestimmt
      waren.</para>

    <para>Jeder Benutzer kann sich eine eigene Umgebung mit alternativen
      Shells, Editoren, Tastaturbelegungen und Sprachen einrichten.</para>
  </sect1>

  <sect1 xml:id="users-modifying">
    <title>Accounts verändern</title>

    <indexterm>
      <primary>Accounts</primary>
      <secondary>verändern</secondary>
    </indexterm>

    <para>Unter &unix; gibt es verschiedene Kommandos, um Accounts zu
      verändern.  Die gebräuchlichsten Kommandos sind unten,
      gefolgt von einer detaillierten Beschreibung, zusammengefasst.</para>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Kommando</entry>
	    <entry>Zusammenfassung</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>&man.adduser.8;</entry>
	    <entry>Das empfohlene Werkzeug, um neue Accounts zu
	      erstellen.</entry>
	  </row>
	  <row>
	    <entry>&man.rmuser.8;</entry>
	    <entry>Das empfohlene Werkzeug, um Accounts zu
	      löschen.</entry>
	  </row>
	  <row>
	    <entry>&man.chpass.1;</entry>
	    <entry>Ein flexibles Werkzeug, um Informationen in der
	      Account-Datenbank zu verändern.</entry>
	  </row>
	  <row>
	    <entry>&man.passwd.1;</entry>
	    <entry>Ein einfaches Werkzeug, um Passwörter von Accounts
	      zu ändern.</entry>
	  </row>
	  <row>
	    <entry>&man.pw.8;</entry>
	    <entry>Ein mächtiges und flexibles Werkzeug um alle
	      Informationen über Accounts zu ändern.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <sect2 xml:id="users-adduser">
      <title><command>adduser</command></title>

      <indexterm>
	<primary>Accounts</primary>
	<secondary>erstellen</secondary>
      </indexterm>
      <indexterm>
	<primary><command>adduser</command></primary>
      </indexterm>
      <indexterm>
	<primary><filename>/usr/share/skel</filename></primary>
      </indexterm>
      <para>&man.adduser.8; ist ein einfaches Programm
        um neue Benutzer hinzuzufügen.  Es erstellt
	<filename>passwd</filename> und <filename>group</filename>
	Einträge für den
        Benutzer, genauso wie ein home Verzeichnis, kopiert ein paar
        vorgegebene Dotfiles aus <filename>/usr/share/skel</filename> und kann
        optional dem Benutzer eine ,,Willkommen``-Nachricht zuschicken.</para>

      <example>
	<title>Einen Benutzer unter &os; anlegen</title>

	<screen>&prompt.root; <userinput>adduser</userinput>
Username: <userinput>jru</userinput>
Full name: <userinput>J. Random User</userinput>
Uid (Leave empty for default):
Login group [jru]:
Login group is jru. Invite jru into other groups? []: <userinput>wheel</userinput>
Login class [default]:
Shell (sh csh tcsh zsh nologin) [sh]: <userinput>zsh</userinput>
Home directory [/home/jru]:
Home directory permissions (Leave empty for default):
Use password-based authentication? [yes]:
Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]:
Enter password:
Enter password again:
Lock out the account after creation? [no]:
Username   : jru
Password   : ****
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? (yes/no): <userinput>yes</userinput>
adduser: INFO: Successfully added (jru) to the user database.
Add another user? (yes/no): <userinput>no</userinput>
Goodbye!
&prompt.root;</screen>
      </example>

      <note>
        <para>Wenn Sie das Passwort eingeben, werden weder Passwort noch
          Sternchen angezeigt.  Passen Sie auf, dass Sie das Passwort
          korrekt eingeben.</para>
      </note>
    </sect2>

    <sect2 xml:id="users-rmuser">
      <title><command>rmuser</command></title>

      <indexterm><primary><command>rmuser</command></primary></indexterm>
      <indexterm>
	<primary>Accounts</primary>
	<secondary>löschen</secondary>
      </indexterm>

      <para>Benutzen Sie &man.rmuser.8;, um einen Account
        vollständig aus dem System zu entfernen.
	&man.rmuser.8; führt die folgenden Schritte
	durch:</para>

      <procedure>
        <step>
          <para>Entfernt den &man.crontab.1; Eintrag des Benutzers
	    (wenn dieser existiert).</para>
        </step>
        <step>
          <para>Entfernt alle &man.at.1; jobs, die dem Benutzer gehören.
          </para>
        </step>
        <step>
          <para>Schließt alle Prozesse des Benutzers.</para>
        </step>
        <step>
          <para>Entfernt den Benutzer aus der lokalen Passwort-Datei des
            Systems.</para>
        </step>
        <step>
          <para>Entfernt das Heimatverzeichnis des Benutzers (falls es dem
            Benutzer gehört).</para>
        </step>
        <step>
          <para>Entfernt eingegangene E-Mails des Benutzers
            aus <filename>/var/mail</filename>.</para>
        </step>
        <step>
          <para>Entfernt alle Dateien des Benutzers aus temporären
            Dateispeicherbereichen wie <filename>/tmp</filename>.</para>
        </step>
        <step>
          <para>Entfernt den Loginnamen von allen Gruppen, zu denen er
            gehört, aus <filename>/etc/group</filename>.</para>

            <note>
              <para>Wenn eine Gruppe leer wird und der Gruppenname mit dem
                Loginnamen identisch ist, wird die Gruppe entfernt; das
                ergänzt sich mit den einzelnen Benutzer-Gruppen, die von
                &man.adduser.8; für jeden neuen Benutzer erstellt werden.
              </para>
            </note>
        </step>
      </procedure>

      <para>Der Superuser-Account kann nicht mit &man.rmuser.8; entfernt
        werden, da dies in den meisten Fällen das System unbrauchbar
	macht.</para>

      <para>Als Vorgabe wird ein interaktiver Modus benutzt, der
        sicherzustellen versucht, dass Sie wissen, was Sie tun.</para>

      <example>
        <title>Interaktives Löschen von Account mit
	  <command>rmuser</command></title>

        <screen>&prompt.root; <userinput>rmuser jru</userinput>
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? <userinput>y</userinput>
Remove user's home directory (/home/jru)? <userinput>y</userinput>
Updating password file, updating databases, done.
Updating group file: trusted (removing group jru -- personal group is empty) done.
Removing user's incoming mail file /var/mail/jru: done.
Removing files belonging to jru from /tmp: done.
Removing files belonging to jru from /var/tmp: done.
Removing files belonging to jru from /var/tmp/vi.recover: done.
&prompt.root;</screen>
      </example>
    </sect2>

    <sect2 xml:id="users-chpass">
      <title><command>chpass</command></title>

      <indexterm><primary><command>chpass</command></primary></indexterm>
      <para>&man.chpass.1; ändert Informationen der
        Benutzerdatenbank wie Passwörter, Shells und persönliche
        Informationen.</para>

      <para>Nur Systemadministratoren, mit Superuser-Rechten, können die
        Informationen und Passwörter der anderen Benutzer mit
        &man.chpass.1; verändern.</para>

      <para>Werden keine Optionen neben dem optionalen Loginnamen
        angegeben, zeigt &man.chpass.1; einen Editor
        mit Account-Informationen an und aktualisiert die
	Account-Datenbank, wenn dieser verlassen wird.</para>

      <note>
        <para>Unter &os; wird nach dem Verlassen des Editors
          nach dem Passwort gefragt, es sei denn, man ist als Superuser
          angemeldet.</para>
      </note>

      <example>
        <title>Interaktives <command>chpass</command> des Superusers</title>

        <screen>#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <para>Der normale Benutzer kann nur einen kleinen Teil dieser
        Informationen verändern und natürlich nur die Daten des
	eigenen Accounts.</para>

      <example>
        <title>Interaktives <command>chpass</command> eines normalen
	  Benutzers</title>

        <screen>#Changing user database information for jru.
Shell: /usr/local/bin/tcsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <note>
        <para>&man.chfn.1; und &man.chsh.1; sind
          nur Verweise auf &man.chpass.1; genauso wie
          &man.ypchpass.1;, &man.ypchfn.1; und
          &man.ypchsh.1;.  NIS wird automatisch unterstützt,
          deswegen ist es nicht notwendig das <literal>yp</literal> vor dem
          Kommando einzugeben.  NIS wird später
	  in <xref linkend="network-servers"/> besprochen.</para>
      </note>
    </sect2>
    <sect2 xml:id="users-passwd">
      <title><application>passwd</application></title>

      <indexterm><primary><command>passwd</command></primary></indexterm>
      <indexterm>
	<primary>Accounts</primary>
	<secondary>Passwort wechseln</secondary>
      </indexterm>
      <para>&man.passwd.1; ist der übliche Weg, Ihr
        eigenes Passwort als Benutzer zu ändern oder das Passwort eines
        anderen Benutzers als Superuser.</para>

      <note>
	<para>Um unberechtigte Änderungen zu verhindern,
	  muss bei einem Passwortwechsel zuerst das ursprüngliche
	  Passwort eingegeben werden.</para>
      </note>

      <example>
        <title>Wechseln des Passworts</title>

        <screen>&prompt.user; <userinput>passwd</userinput>
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done

&prompt.root; <userinput>passwd jru</userinput>
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <example>
	<title>Als Superuser das Passwort eines anderen Accounts
	  verändern</title>

	<screen>&prompt.root; <userinput>passwd jru</userinput>
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <note>
        <para>Wie bei &man.chpass.1; ist &man.yppasswd.1;
	  nur ein Verweis auf &man.passwd.1;.  NIS wird von
	  jedem dieser Kommandos unterstützt.</para>
      </note>
    </sect2>

    <sect2 xml:id="users-pw">
      <title><command>pw</command></title>
      <indexterm><primary><command>pw</command></primary></indexterm>

      <para>&man.pw.8; ist ein Kommandozeilenprogramm, mit
        dem man Accounts und Gruppen erstellen, entfernen, verändern
	und anzeigen kann.  Dieses Kommando dient als Schnittstelle zu den
        Benutzer- und Gruppendateien des Systems.  &man.pw.8;
	besitzt eine Reihe mächtiger Kommandozeilenschalter, die es
	für die Benutzung in Shell-Skripten geeignet machen, doch
	finden neue Benutzer die Bedienung des Kommandos komplizierter, als
	die der anderen hier vorgestellten Kommandos.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="users-limiting">
    <title>Benutzer einschränken</title>

    <indexterm><primary>Benutzer einschränken</primary></indexterm>
    <indexterm>
      <primary>Accounts</primary>
      <secondary>einschränken</secondary>
    </indexterm>
    <para>Wenn ein System von mehreren Benutzern verwendet wird, ist es
      vielleicht notwendig, den Gebrauch des Systems zu beschränken.
      FreeBSD bietet dem Systemadministrator mehrere Möglichkeiten
      die System-Ressourcen, die ein einzelner Benutzer verwenden kann,
      einzuschränken.  Diese Limitierungen sind in zwei Kategorien
      eingeteilt: Festplattenkontingente und andere
      Ressourcenbeschränkungen.</para>

    <indexterm><primary>Quotas</primary></indexterm>
    <indexterm>
      <primary>Benutzer einschränken</primary>
      <secondary>Quotas</secondary>
    </indexterm>
    <indexterm><primary>Festplatten Quotas</primary></indexterm>
    <para>Festplatten-Kontingente schränken den Plattenplatz, der
      einem Benutzer zur Verfügung steht, ein.  Sie bieten zudem,
      ohne aufwändige Berechnung, einen schnellen Überblick
      über den verbrauchten Plattenplatz.
      Kontingente werden in <xref linkend="quotas"/> diskutiert.</para>

    <indexterm>
      <primary><filename>/etc/login.conf</filename></primary>
    </indexterm>
    <para>Die Login-Klassen werden in <filename>/etc/login.conf</filename>
      definiert.  Auf die präzisen Semantiken gehen wir hier nicht
      weiter ein, sie können jedoch in &man.login.conf.5;
      nachgelesen werden.  Es ist ausreichend zu sagen, dass jeder
      Benutzer einer Login-Klasse zugewiesen wird (standardmäßig
      <literal>default</literal>) und dass jede Login-Klasse mit einem Satz
      von Login-Fähigkeiten verbunden ist.  Eine Login-Fähigkeit
      ist ein <literal>Name=Wert
      </literal> Paar, in dem <replaceable>Name</replaceable>
      die Fähigkeit bezeichnet und <replaceable>Wert</replaceable>
      ein willkürlicher Text ist, der je nach <replaceable>Name
      </replaceable> entsprechend verarbeitet wird.  Login-Klassen und
      -Fähigkeiten zu definieren, ist fast schon selbsterklärend
      und wird auch in &man.login.conf.5; beschrieben.</para>

    <note>
      <para>Das System verwendet die Datei
	<filename>/etc/login.conf</filename> normalerweise nicht direkt,
	sondern nur über die Datenbank
	<filename>/etc/login.conf.db</filename>, da diese eine
	schnellere Abfrage erlaubt.  Der nachstehende Befehl erzeugt die
	Datenbank <filename>/etc/login.conf.db</filename> aus der Datei
	<filename>/etc/login.conf</filename>:</para>

      <screen>&prompt.root; <userinput>cap_mkdb /etc/login.conf</userinput></screen>
    </note>

    <para>Ressourcenbeschränkungen unterscheiden sich von normalen
      Login-Fähigkeiten zweifach.  Erstens gibt es für jede
      Beschränkung ein aktuelles und ein maximales Limit.  Das
      aktuelle Limit kann vom Benutzer oder einer Anwendung beliebig
      bis zum maximalen Limit verändert werden.  Letzteres kann
      der Benutzer nur heruntersetzen.  Zweitens gelten die meisten
      Ressourcenbeschränkungen für jeden vom Benutzer
      gestarteten Prozess, nicht für den Benutzer selbst.
      Beachten Sie jedoch, dass diese Unterschiede durch das spezifische
      Einlesen der Limits und nicht durch das System der
      Login-Fähigkeiten entstehen (das heißt,
      Ressourcenbeschränkungen sind <emphasis>keine</emphasis>
      Login-Fähigkeiten).</para>

    <para>Hier befinden sich die am häufigsten benutzten
      Ressourcenbeschränkungen (der Rest kann zusammen mit den
      anderen Login-Fähigkeiten in &man.login.conf.5; gefunden
      werden):</para>

    <variablelist>
      <varlistentry>
	<term><literal>coredumpsize</literal></term>

	<listitem>
	  <indexterm><primary>coredumpsize</primary></indexterm>
	  <indexterm>
	    <primary>Benutzer einschränken</primary>
	    <secondary>coredumpsize</secondary>
	  </indexterm>
          <para>Das Limit der Größe einer core-Datei, die
	    von einem Programm generiert wird, unterliegt aus
	    offensichtlichen Gründen anderen Limits der
	    Festplattenbenutzung (zum Beispiel <literal>filesize</literal>
	    oder Festplattenkontingenten).  Es wird aber trotzdem
	    oft als weniger harte Methode zur Kontrolle des
	    Festplattenplatz-Verbrauchs verwendet: Da Benutzer die
	    core-Dateien nicht selbst erstellen, und sie oft nicht
	    löschen, kann sie diese Option davor retten, dass
	    ihnen kein Festplattenspeicher mehr zur Verfügung
	    steht, sollte ein großes Programm, wie
	    <application>emacs</application>, abstürzen.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>cputime</literal></term>

	<listitem>
	  <indexterm><primary>cputime</primary></indexterm>
	  <indexterm>
	    <primary>Benutzer einschränken</primary>
	    <secondary>cputime</secondary>
	  </indexterm>
	  <para>Die maximale Rechenzeit, die ein Prozess eines Benutzers
	    verbrauchen darf.  Überschreitet der Prozess diesen Wert,
	    wird er vom Kernel beendet.</para>

	    <note>
	      <para>Die Rechen<emphasis>zeit</emphasis> wird limitiert,
		nicht die prozentuale Prozessorenbenutzung, wie es in
		einigen Feldern in &man.top.1; und &man.ps.1; dargestellt
		wird.  Letzteres war zu der Zeit, als dies hier geschrieben
		wurde nicht möglich und würde eher nutzlos sein:
		Ein Compiler &ndash; ein wahrscheinlich legitimer
		Vorgang &ndash; kann leicht fast 100% des Prozessors in
		Anspruch nehmen.</para>
	    </note>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>filesize</literal></term>

	<listitem>
	  <indexterm><primary>filesize</primary></indexterm>
	  <indexterm>
	    <primary>Benutzer einschränken</primary>
	    <secondary>filesize</secondary>
	  </indexterm>
	  <para>Hiermit lässt sich die maximale Größe einer Datei
	    bestimmen, die der Benutzer besitzen darf.  Im Gegensatz zu
            <link linkend="quotas">Festplattenkontingenten</link> ist diese
	    Beschränkung nur für jede einzelne Datei gültig
	    und nicht für den Platz, den alle Dateien eines Benutzers
	    verwenden.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>maxproc</literal></term>

	<listitem>
	  <indexterm><primary>maxproc</primary></indexterm>
	  <indexterm>
	    <primary>Benutzer einschränken</primary>
	    <secondary>maxproc</secondary>
	  </indexterm>
	  <para>Das ist die maximale Anzahl von Prozessen, die ein
	    Benutzer starten darf, und beinhaltet sowohl Vordergrund-
	    als auch Hintergrundprozesse.  Natürlich darf dieser
	    Wert nicht höher sein als das System-Limit, das in
	    <varname>kern.maxproc</varname> angegeben ist.  Vergessen
	    Sie auch nicht, dass ein zu kleiner Wert den Benutzer in
	    seiner Produktivität einschränken könnte;
	    es ist oft nützlich, mehrfach eingeloggt zu sein, oder
	    <foreignphrase>Pipelines</foreignphrase>
	      <footnote>
		<para><foreignphrase>Pipeline</foreignphrase> =
		  <emphasis>Leitung</emphasis>.
		  Mit <foreignphrase>Pipes</foreignphrase> sind Verbindungen
		  zwischen zwei Sockets in meistens zwei verschiedenen
		  Prozessen gemeint.</para>
	      </footnote>
	    zu verwenden.  Ein paar Aufgaben, wie die Kompilierung eines
	    großen Programms, starten mehrere Prozesse (zum Beispiel
	    &man.make.1;, &man.cc.1; und andere).</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>memorylocked</literal></term>

	<listitem>
	  <indexterm><primary>memorylocked</primary></indexterm>
	  <indexterm>
	    <primary>Benutzer einschränken</primary>
	    <secondary>memorylocked</secondary>
	  </indexterm>
	  <para>Dieses Limit gibt an, wie viel virtueller Speicher von einem
	    Prozess maximal im Arbeitsspeicher festgesetzt werden kann.
	    (siehe auch &man.mlock.2;).  Ein paar systemkritische Programme,
	    wie &man.amd.8;, verhindern damit einen Systemzusammenbruch, der
	    auftreten könnte, wenn sie aus dem Speicher genommen werden.
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>memoryuse</literal></term>

	<listitem>
	  <indexterm><primary>memoryuse</primary></indexterm>
	  <indexterm>
	    <primary>Benutzer einschränken</primary>
	    <secondary>memoryuse</secondary>
	  </indexterm>
	  <para>Bezeichnet den maximalen Speicher, den ein Prozess benutzen
	    darf und beinhaltet sowohl Arbeitsspeicher-, als auch Swap-
	    Benutzung.  Es ist kein allübergreifendes Limit für
	    den Speicherverbrauch, aber ein guter Anfang.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>openfiles</literal></term>

	<listitem>
	  <indexterm><primary>openfiles</primary></indexterm>
	  <indexterm>
	    <primary>Benutzer einschränken</primary>
	    <secondary>openfiles</secondary>
	  </indexterm>
	  <para>Mit diesem Limit lässt sich die maximale Anzahl
	    der von einem Prozess des Benutzers geöffneten Dateien
	    festlegen.  In FreeBSD werden Dateien auch verwendet, um Sockets
	    und <foreignphrase>IPC</foreignphrase>-Kanäle
	    <footnote>
	      <para><foreignphrase>IPC</foreignphrase> steht für
		<foreignphrase>Interprocess Communication</foreignphrase>.
		</para>
	    </footnote>
	    darzustellen.  Setzen Sie es deshalb nicht zu niedrig.  Das
	    System-Limit ist im <varname>kern.maxfiles</varname>
	    &man.sysctl.8; definiert.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>sbsize</literal></term>

	<listitem>
	  <indexterm><primary>sbsize</primary></indexterm>
	  <indexterm>
	    <primary>Benutzer einschränken</primary>
	    <secondary>sbsize</secondary>
	  </indexterm>
	  <para>Dieses Limit beschränkt den Netzwerk-Speicher, und damit
	    die mbufs, die ein Benutzer verbrauchen darf.  Es stammt aus einer
	    Antwort auf einen DoS-Angriff, bei dem viele Netzwerk-Sockets
	    geöffnet wurden, kann aber generell dazu benutzt werden
	    Netzwerk-Verbindungen zu beschränken.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>stacksize</literal></term>

	<listitem>
	  <para>Das ist die maximale Größe, auf die der Stack
	    eines Prozesses heranwachsen darf.  Das allein ist natürlich
	    nicht genug, um den Speicher zu beschränken, den ein Programm
	    verwenden darf.  Es sollte deshalb in Verbindung mit anderen
	    Limits gesetzt werden.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Beim Setzen von Ressourcenbeschränkungen sind noch andere
      Dinge zu beachten.  Nachfolgend ein paar generelle Tipps, Empfehlungen
      und verschiedene Kommentare.</para>

    <itemizedlist>
      <listitem>
	<para>Von <filename>/etc/rc</filename> beim Hochfahren des Systems
	  gestartete Prozesse werden der <literal>daemon</literal>
	  Login-Klasse zugewiesen.</para>
      </listitem>

      <listitem>
	<para>Obwohl das mitgelieferte <filename>/etc/login.conf</filename>
	  eine Quelle von vernünftigen Limits darstellt, können nur
	  Sie, der Administrator, wissen, was für Ihr System angebracht
	  ist.  Ein Limit zu hoch anzusetzen könnte Ihr System für
	  Missbrauch öffnen, und ein zu niedriges Limit der
	  Produktivität einen Riegel vorschieben.</para>
      </listitem>

      <listitem>
	<para>Benutzer des X-Window Systems (X11) sollten wahrscheinlich
	  mehr Ressourcen zugeteilt bekommen als andere Benutzer.  X11
	  beansprucht selbst schon eine Menge Ressourcen, verleitet die
	  Benutzer aber auch, mehrere Programme gleichzeitig laufen zu
	  lassen.</para>
      </listitem>

      <listitem>
	<para>Bedenken Sie, dass viele Limits für einzelne Prozesse
	  gelten und nicht für den Benutzer selbst.  Setzt man
	  zum Beispiel <varname>openfiles</varname> auf 50, kann jeder
	  Prozess des Benutzers bis zu 50 Dateien öffnen.  Dadurch
	  ist die maximale Anzahl von Dateien, die von einem Benutzer
	  geöffnet werden können, <literal>openfiles</literal>
	  mal <literal>maxproc</literal>.  Das gilt auch für den
	  Speicherverbrauch.</para>
      </listitem>
    </itemizedlist>

    <para>Weitere Informationen über
      Ressourcenbeschränkungen, Login-Klassen und -Fähigkeiten
      enthalten die Hilfeseiten
      &man.cap.mkdb.1;, &man.getrlimit.2; und &man.login.conf.5;.</para>
  </sect1>

  <sect1 xml:id="users-groups">
    <title>Gruppen</title>

    <indexterm><primary>Gruppen</primary></indexterm>
    <indexterm>
      <primary><filename>/etc/groups</filename></primary>
    </indexterm>
    <indexterm>
      <primary>Accounts</primary>
      <secondary>Gruppen</secondary>
    </indexterm>
    <para>Eine Gruppe ist einfach eine Zusammenfassung von Accounts.
      Gruppen werden durch den Gruppennamen und die GID (group ID)
      identifiziert.  Der Kernel von FreeBSD (und den meisten anderen &unix;
      Systemen) entscheidet anhand der UID und der Gruppenmitgliedschaft
      eines Prozesses, ob er dem Prozess etwas erlaubt oder nicht.  Im
      Unterschied zur UID kann ein Prozess zu einer Reihe von Gruppen
      gehören.  Wenn jemand von der GID eines
      Benutzers oder Prozesses spricht, meint er damit meistens die erste
      Gruppe der Gruppenliste.</para>

    <para>Die Zuordnung von Gruppennamen zur GID steht in
      <filename>/etc/group</filename>, einer Textdatei mit vier durch
      Doppelpunkte getrennten Feldern.  Im ersten Feld steht der
      Gruppenname, das zweite enthält ein verschlüsseltes
      Passwort, das dritte gibt die GID an und das vierte besteht aus einer
      Komma separierten Liste der Mitglieder der Gruppe.  Diese Datei kann
      einfach editiert werden (natürlich nur, wenn Sie dabei keine
      Syntaxfehler machen).  Eine ausführliche Beschreibung der Syntax
      dieser Datei finden Sie in &man.group.5;.</para>

    <para>Wenn Sie <filename>/etc/group</filename> nicht händisch
      editieren möchten, können Sie &man.pw.8; zum Editieren
      benutzen.  Das folgende Beispiel zeigt das Hinzufügen einer
      Gruppe mit dem Namen <systemitem class="groupname">teamtwo</systemitem>:</para>

    <example>
      <title>Setzen der Mitgliederliste einer Gruppe mit &man.pw.8;</title>

      <screen>&prompt.root; <userinput>pw groupadd teamtwo</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:</screen>
    </example>

    <para>Die Zahl <literal>1100</literal> ist die GID der Gruppe
      <systemitem class="groupname">teamtwo</systemitem>.  Momentan hat
      <systemitem class="groupname">teamtwo</systemitem> noch keine Mitglieder und ist daher
      ziemlich nutzlos.  Um das zu ändern, nehmen wir nun
      <systemitem class="username">jru</systemitem> in <systemitem class="groupname">teamtwo</systemitem>
      auf.</para>

    <example>
      <title>Ein Gruppenmitglied mit <command>pw</command>
	hinzufügen</title>

      <screen>&prompt.root; <userinput>pw groupmod teamtwo -M jru</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:jru</screen>
    </example>

    <para>Als Argument von <option>-M</option> geben Sie eine Komma
      separierte Liste von Mitgliedern an, die in die Gruppe aufgenommen
      werden sollen.  Aus den vorherigen Abschnitten ist bekannt, dass die
      Passwort-Datei ebenfalls eine Gruppe für jeden Benutzer
      enthält.  Das System teilt dem Benutzer automatisch eine Gruppe
      zu, die aber vom <option>groupshow</option> Kommando von &man.pw.8;
      nicht angezeigt wird.  Diese Information wird allerdings von
      &man.id.1; und ähnlichen Werkzeugen angezeigt.  Das heißt,
      dass &man.pw.8; nur <filename>/etc/group</filename> manipuliert,
      es wird nicht versuchen, zusätzliche Informationen aus
      <filename>/etc/passwd</filename> zu lesen.</para>

    <example>
      <title>Hinzufügen eines neuen Gruppenmitglieds mittels
      &man.pw.8;</title>

      <screen>&prompt.root; <userinput>pw groupmod teamtwo -m db</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:jru,db</screen>
    </example>

    <para>Die Argumente zur Option <option>-m</option> ist eine durch Komma
      getrennte Liste von Benutzern, die der Gruppe hinzugefügt werden
      sollen.  Anders als im vorherigen Beispiel werden diese Benutzer in die
      Gruppe aufgenommen und ersetzen nicht die Liste der bereits bestehenden
      Benutzer in der Gruppe.</para>

    <example>
      <title>Mit <command>id</command> die Gruppenzugehörigkeit
	bestimmen</title>

      <screen>&prompt.user; <userinput>id jru</userinput>
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)</screen>
    </example>

    <para>Wie Sie sehen, ist <systemitem class="username">jru</systemitem> Mitglied von
      <systemitem class="groupname">jru</systemitem> und <systemitem class="groupname">teamtwo</systemitem>.</para>

    <para>Weitere Informationen entnehmen Sie bitte &man.pw.8;.</para>
  </sect1>
</chapter>
