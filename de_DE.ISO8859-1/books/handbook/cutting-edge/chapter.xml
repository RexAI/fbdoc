<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde$
     basiert auf: r38826
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="updating-upgrading">
  <info><title>&os; aktualisieren</title>
    <authorgroup>
      <author><personname><firstname>Jim</firstname><surname>Mock</surname></personname><contrib>Umstrukturiert und aktualisiert von </contrib></author>
      <!-- Mar 2000 -->
    </authorgroup>

    <authorgroup>
      <author><personname><firstname>Jordan</firstname><surname>Hubbard</surname></personname><contrib>Im Original von </contrib></author>
      <author><personname><firstname>Poul-Henning</firstname><surname>Kamp</surname></personname></author>
      <author><personname><firstname>John</firstname><surname>Polstra</surname></personname></author>
      <author><personname><firstname>Nik</firstname><surname>Clayton</surname></personname></author>
    </authorgroup>

    
    <authorgroup>
      <author><personname><firstname>Martin</firstname><surname>Heinen</surname></personname><contrib>Übersetzt von </contrib></author>
    </authorgroup>
  </info>

  

  <sect1 xml:id="updating-upgrading-synopsis">
    <title>Übersicht</title>

    <para>&os; wird zwischen einzelnen Releases ständig weiter
      entwickelt.  Manche Leute bevorzugen die offiziellen Release-Versionen,
      während andere wiederum lieber auf dem aktuellen Stand der
      Entwicklung bleiben möchten.  Wie dem auch sei, sogar offizielle
      Release-Versionen werden oft mit Sicherheitsaktualisierungen und
      anderen kritischen Fehlerbereinigungen versorgt.  Unabhängig von
      der eingesetzten Version bringt &os; alle nötigen Werkzeuge mit,
      um ihr System aktuell zu halten und es innerhalb verschiedener
      Versionen zu aktualisieren.  Dieses Kapitel hilft Ihnen bei der
      Entscheidung, ob Sie mit dem Entwicklungssystem Schritt halten oder
      ein Release verwenden wollen.  Die zugrundeliegenden Werkzeuge um
      Ihr System aktuell zu halten werden ebenfalls vorgestellt.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</para>

    <itemizedlist>
      <listitem>
	<para>wissen, welche Werkzeuge verwendet werden können, um das
	  System und die Port-Sammlung zu aktualisieren.</para>
      </listitem>

      <listitem>
	<para>wissen, wie Sie Ihr System mit
          <application>freebsd-update</application>,
          <application>CVSup</application>,
          <application>CVS</application> oder
          <application>CTM</application>
          aktualisieren.</para>
      </listitem>

      <listitem>
	<para>wissen, wie man das aktuell installierte System mit einer
	  ursprünglichen Version vergleicht.</para>
      </listitem>

      <listitem>
	<para>wissen, wie Sie ihre Dokumentation mit
	  <application>CVSup</application> oder Dokumentations-Ports
          <!-- oder <application>Docsnap</application> -->
	  aktuell halten können.</para>
      </listitem>

      <listitem>
	<para>den Unterschied zwischen den beiden Entwicklungszweigen
	  &os.stable; und &os.current; kennen.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie das komplette Basissystem mit <command>make
	  buildworld</command> neu bauen und installieren.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>

    <itemizedlist>
      <listitem>
	<para>Ihr Netzwerk richtig konfiguriert haben
	  (<xref linkend="advanced-networking"/>) und</para>
      </listitem>

      <listitem>
	<para>wissen, wie Sie Software Dritter installieren
	  (<xref linkend="ports"/>).</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Im gesamten Kapitel wird der Befehl <command>cvsup</command>
        verwendet, um die &os; Quellen zu beziehen und zu aktualisieren.  Um es
        zu verwenden, benötigen Sie einen Port oder ein Paket wie
        <package>net/cvsup</package> (falls Sie den
        graphischen <command>cvsup</command>-Client nicht benötigen,
        können Sie auch nur den Port
        <filename>net/cvsup-without-gui</filename> installieren).
	Alternativ können Sie auch &man.csup.1; verwenden, das bereits
	Teil des Basissystems ist.</para>
    </note>
  </sect1>

  <sect1 xml:id="updating-upgrading-freebsdupdate">
    <info><title>&os;-Update</title>
      <authorgroup>
        <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Geschrieben von </contrib></author>
      </authorgroup>

      <authorgroup>
        <author><personname><firstname>Colin</firstname><surname>Percival</surname></personname><contrib>Basierend auf bereitgestellten Mitschriften von </contrib></author>
      </authorgroup>

      <authorgroup>
        <author><personname><firstname>Benedict</firstname><surname>Reuschling</surname></personname><contrib>Übersetzt von </contrib></author>
      </authorgroup>
    </info>
    

    <indexterm><primary>Updating and Upgrading</primary></indexterm>
    <indexterm>
      <primary>freebsd-update</primary>
      <see>updating-upgrading</see>
    </indexterm>

    <para>Das Einspielen von Sicherheitsaktualisierungen ist ein wichtiger
      Bestandteil bei der Wartung von Computersoftware, besonders wenn es um
      das Betriebssystem geht.  Für lange Zeit war dieser Prozess unter
      &os; nicht einfach.  Fehlerbehebungen mussten auf den Quellcode
      angewendet werden, danach wurde der Code zu neuen Binärdateien
      übersetzt und schliesslich mussten diese Dateien neu installiert
      werden.</para>

    <para>Das ist seit längerem nicht mehr der Fall, da &os; jetzt ein
       Werkzeug namens <command>freebsd-update</command> enthält.  Dieses
       Werkzeug bringt zwei getrennte Funktionen mit sich.   Die erste Funktion
       ermöglicht die Anwendung von Sicherheitsaktualisierungen im
       Binärformat auf das &os; Basissystem, ohne dieses neu zu
       übersetzen und zu installieren.  Die zweite Funktion
       unterstützt Aktualisierungen zwischen Haupt- und
       Unterversionen.</para>

    <note>
      <para>Binäre Aktualisierungen sind für alle Architekturen und
        Releases verfügbar, die aktuell vom &os; Security Team betreut
        werden.  Vor
        der Aktualisierung auf eine neue Release-Version sollten die aktuellen
        Ankündigungen zu dem Release gelesen werden, da diese wichtige
        Informationen zu der gewünschten Version enthalten.  Diese
        Ankündigungen finden Sie unter dem folgenden Link: <uri xlink:href="http://www.FreeBSD.org/releases/">http://www.FreeBSD.org/releases/</uri>.</para>
    </note>

    <para>Wenn eine <command>crontab</command> existiert, welche die
      Eigenschaften von <command>freebsd-update</command> verwendet, muss diese
      deaktiviert werden, bevor die folgende Aktion gestartet wird.</para>

    <sect2 xml:id="freebsdupdate-config-file">
      <title>Die Konfigurationsdatei</title>

      <para>Manche Anwender möchten sicherlich Einstellungen in der
        Standard-Konfigurationsdatei unter
        <filename>/etc/freebsd-update.conf</filename> vornehmen, um
        bessere Kontrolle über den
        gesamten Prozess zu besitzen.  Die Optionen sind sehr gut dokumentiert,
        jedoch benötigen die folgenden ein paar zusätzliche
        Erklärungen:</para>

      <programlisting># Components of the base system which should be kept updated.
Components src world kernel</programlisting>

      <para>Dieser Parameter kontrolliert, welche Teile von &os; auf dem
        aktuellen Stand gehalten werden sollen.  Die Voreinstellung ist es, den
        Quellcode zu aktualisieren, das gesamte Basissystem sowie den Kernel.
        Die Komponenten sind die gleichen wie während der Installation,
        also würde beispielsweise das hinzufügen von
        <literal>world/games</literal> an dieser Stelle es erlauben,
        Aktualisierungen für Spiele anzuwenden.
        Die Verwendung von <literal>src/bin</literal> erlaubt es, den
        Quellcode in <filename>src/bin</filename> aktuell zu
        halten.</para>

      <para>Die beste Einstellung ist, diese Option so zu belassen, da eine
        Änderung es bedingt, dass man als Benutzer jede Komponente
        auflisten muss, die aktualisiert werden soll.  Dies könnte
        katastrophale Folgen nach sich ziehen, da der Quellcode und die
        Binärdateien dadurch nicht mehr synchron wären.</para>

      <programlisting># Paths which start with anything matching an entry in an IgnorePaths
# statement will be ignored.
IgnorePaths</programlisting>

      <para>Fügen Sie Pfade wie <filename>/bin</filename> oder <filename>/sbin</filename> hinzu, um diese speziellen
        Verzeichnisse während des Aktualisierungsprozesses unberührt
        zu lassen.  Diese Option kann verwendet werden, um zu verhindern, dass
        <command>freebsd-update</command> lokale Änderungen
        überschreibt.</para>

      <programlisting># Paths which start with anything matching an entry in an UpdateIfUnmodified
# statement will only be updated if the contents of the file have not been
# modified by the user (unless changes are merged; see below).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</programlisting>

      <para>Aktualisieren Sie Konfigurationsdateien in den angegebenen
        Verzeichnissen nur, wenn diese nicht geändert wurden.  Jegliche
        Änderung, die der Benutzer daran vorgenommen hat, wird die
        automatische Aktualisierung dieser Dateien ungültig machen.
        Es gibt eine weitere Option <literal>KeepModifiedMetadata</literal>,
        die <command>freebsd-update</command> instruiert, die Änderungen
        während der Zusammenführung zu speichern.</para>

      <programlisting># When upgrading to a new &os; release, files which match MergeChanges
# will have any local changes merged into the version from the new release.
MergeChanges /etc/ /var/named/etc/</programlisting>

      <para>Eine Liste von Verzeichnissen mit Konfigurationsdateien, in denen
        <command>freebsd-update</command> Zusammenführungen versuchen
        soll.  Dieser Verschmelzungsprozess von Dateien ist eine Serie von
        &man.diff.1;-Korrekturen, ähnlich wie &man.mergemaster.8; mit
        weniger Optionen. Die Änderungen werden entweder akzeptiert,
        öffnen einen Editor oder <command>freebsd-update</command> bricht
        ab.  Wenn Sie im Zweifel sind, sichern Sie das <filename>/etc</filename> Verzeichnis und akzeptieren einfach
        die Änderungen. Lesen Sie <xref linkend="mergemaster"/>, um
        Informationen über das <command>mergemaster</command>-Kommando
        zu erhalten.</para>

      <programlisting># Directory in which to store downloaded updates and temporary
# files used by &os; Update.
# WorkDir /var/db/freebsd-update</programlisting>

      <para>In diesem Verzeichnis werden alle Korrekturen und temporären
        Dateien abgelegt.  Für Fälle in denen der Anwender eine
        Versionsaktualisierung vornimmt, sollte diesem Verzeichnis mindestens
        ein Gigabyte Festplattenspeicher zur Verfügung stehen.</para>

      <programlisting># When upgrading between releases, should the list of Components be
# read strictly (StrictComponents yes) or merely as a list of components
# which *might* be installed of which &os; Update should figure out
# which actually are installed and upgrade those (StrictComponents no)?
# StrictComponents no</programlisting>

      <para>Wenn dies auf <literal>yes</literal> gesetzt ist, wird
        <command>freebsd-update</command> annehmen, dass die
        <literal>Components</literal>-Liste vollständig ist und nicht
        versuchen, Änderungen ausserhalb dieser Liste zu tätigen.
        Tatsächlich wird <command>freebsd-update</command> versuchen, jede
        Datei zu aktualisieren, die zu der <literal>Components</literal>-Liste
        gehört.</para>
    </sect2>

    <sect2 xml:id="freebsdupdate-security-patches">
      <title>Sicherheitsaktualisierungen</title>

      <para>Sicherheitsaktualisierungen sind auf einer entfernten Maschine
        abgelegt und können durch das folgende Kommando heruntergeladen
        und installiert werden:</para>

      <screen>&prompt.root; <userinput>freebsd-update fetch</userinput>
&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Wenn irgendeine Änderung auf den Kernel angewendet wurde
        benötigt das System einen Neustart.  Wenn alles gut verlaufen ist,
        sollte das System aktualisiert sein und
        <command>freebsd-update</command> kann als nächtlicher
        &man.cron.8;-Job ablaufen.  Ein Eintrag in der Datei
        <filename>/etc/crontab</filename> ist für diese Aufgabe
        ausreichend:</para>

      <programlisting>@daily                                  root    freebsd-update cron</programlisting>

      <para>Dieser Eintrag besagt, dass einmal am Tag
        <command>freebsd-update</command> ausgeführt wird.  Auf diese
        Weise kann <command>freebsd-update</command> nur durch die Verwendung
        des <option>cron</option>-Arguments prüfen, ob Aktualisierungen
        vorliegen.  Wenn Korrekturen existieren, werden diese automatisch auf
        die lokale Festplatte heruntergeladen, aber nicht eingespielt.  Der
        <systemitem class="username">root</systemitem>-Benutzer bekommt eine Nachricht, damit dieser
        die Korrekturen manuell installiert.</para>

      <para>Sollte irgendetwas schief gelaufen sein, kann
        <command>freebsd-update</command> den letzten Satz von Änderungen
        mit dem folgenden Befehl zurückrollen:</para>

      <screen>&prompt.root; <userinput>freebsd-update rollback</userinput></screen>

      <para>Sobald dieser Vorgang abgeschlossen ist, sollte das System neu
        gestartet werden, wenn der Kernel oder ein beliebiges Kernelmodul
        geändert wurde.  Dies ermöglicht es &os;, die neuen
        Binärdateien in den Hauptspeicher zu laden.</para>

      <para>Das <command>freebsd-update</command>-Werkzeug kann nur den
        <filename>GENERIC</filename>-Kernel automatisch aktualisieren.  Wenn
        ein selbstkonfigurierter Kernel verwendet wird, muss dieser neu
        erstellt und installiert werden, nachdem
        <command>freebsd-update</command> den Rest der Aktualisierungen
        durchgeführt hat.  Allerdings wird
        <command>freebsd-update</command> den
        <filename>GENERIC</filename>-Kernel in <filename>/boot/GENERIC</filename> erkennen und aktualisieren
        (falls dieser existiert), sogar dann, wenn dies nicht der
        aktuell verwendete Kernel des Systems ist.</para>

      <note>
        <para>Es ist eine gute Idee, immer eine Kopie des
          <filename>GENERIC</filename>-Kernels in <filename>/boot/GENERIC</filename> aufzubewahren.  Das wird
          bei der Diagnose von verschiedenen Problemen eine grosse Hilfe sein,
          sowie bei der Durchführung von Versionsaktualisierungen mit
          <command>freebsd-update</command>, wie in <xref linkend="freebsdupdate-upgrade"/> beschrieben ist.</para>
      </note>

      <para>Solange die Standardkonfiguration in
        <filename>/etc/freebsd-update.conf</filename> nicht geändert
        wurde, wird <command>freebsd-update</command> die aktualisierten
        Quellcodedateien des Kernels zusammen mit dem Rest der Neuerungen
        installieren.  Die erneute Übersetzung und Installation ihres
        neuen, selbstkonfigurierten Kernels kann dann auf die übliche
        Art und Weise durchgeführt werden.</para>

      <note>
        <para>Die Aktualisierungen, die über
          <command>freebsd-update</command> verteilt werden, betreffen nicht
          immer den Kernel.  Es ist nicht notwendig, den selbstkonfigurierten
          Kernel neu zu erstellen, wenn die Kernelquellen nicht durch die
          Ausführung von <command>freebsd-update install</command>
          geändert wurden.  Allerdings wird
          <command>freebsd-update</command> auf alle Fälle die Datei
          <filename>/usr/src/sys/conf/newvers.sh</filename> aktualisieren.
          Der aktuelle Patch-Level (angegeben durch die
          <literal>-p</literal>-Nummer, die von dem Kommando <command>uname
          -r</command> ausgegeben wird) wird aus dieser Datei ausgelesen.
          Die Neuinstallation des selbstkonfigurierten Kernels, selbst wenn
          sich daran nichts geändert hat, erlaubt es &man.uname.1;, den
          aktuellen Patch-Level des Systems korrekt wiederzugeben.  Dies ist
          besonders hilfreich, wenn mehrere Systeme gewartet werden, da es
          eine schnelle Einschätzung der installierten Aktualisierungen in
          jedem einzelnen System ermöglicht.</para>
      </note>
    </sect2>

    <sect2 xml:id="freebsdupdate-upgrade">
      <title>Aktualisierungen an Haupt- und Unterversionen</title>

      <para>Dieser Prozess entfernt alte Objekt-Dateien und Bibliotheken, was
        dazu führt, dass die meisten Anwendungen von Drittherstellern
        nicht mehr funktionieren.  Es wird empfohlen, dass alle installierten
        Ports entweder entfernt und neu installiert oder zu einem späteren
        Zeitpunkt mittels <package>ports-mgmt/portupgrade</package> aktualisiert werden.
        Die meisten Anwender werden wahrscheinlich einen Testlauf mittels des
        folgenden Kommandos durchführen wollen:</para>

      <screen>&prompt.root; <userinput>portupgrade -af</userinput></screen>

      <para>Dies sorgt dafür, dass alles korrekt neu installiert wird.
        Beachten Sie, dass das Setzen der
        <varname>BATCH</varname>-Umgebungsvariable auf <literal>yes</literal>
        während dieses Prozesses auf jede Eingabe mit
        <literal>ja</literal> antwortet, was es nicht mehr notwendig macht,
        manuell eingreifen zu müssen.</para>

      <para>Wenn ein selbstkonfigurierter Kernel verwendet wird, ist der
        Aktualisierungsprozess ein kleines bisschen aufwändiger.  Eine
        Kopie des <filename>GENERIC</filename>-Kernels wir benötigt und
        sollte in <filename>/boot/GENERIC</filename> abgelegt
        sein.  Wenn der <filename>GENERIC</filename>-Kernel nicht bereits im
        System vorhanden ist, kann dieser über eine der folgenden Methoden
        bezogen werden:</para>

      <itemizedlist>
        <listitem>
          <para>Wenn ein eigener Kernel genau einmal gebaut wurde, ist der
            Kernel im Verzeichnis <filename>/boot/kernel.old</filename> in Wirklichkeit der
            <filename>GENERIC</filename>-Kernel.  Benennen Sie einfach dieses
            Verzeichnis in <filename>/boot/GENERIC</filename> um.</para>
        </listitem>

        <listitem>
          <para>Angenommen, direkter Zugriff auf die Maschine ist möglich,
            so kann eine Kopie des <filename>GENERIC</filename>-Kernels von den
            CD-ROM-Medien installiert werden.  Legen Sie die Installations-CD
            ein und benutzen Sie die folgenden Befehle:</para>

          <screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>cd /cdrom/X.Y-RELEASE/kernels</userinput>
&prompt.root; <userinput>./install.sh GENERIC</userinput></screen>

         <para>Ersetzen Sie <filename>X.Y-RELEASE</filename>
           mit der richtigen Version der Veröffentlichung, die Sie
           verwenden.  Der <filename>GENERIC</filename>-Kernel wird
           standardmässig in <filename>/boot/GENERIC</filename> installiert.</para>
        </listitem>

        <listitem>
          <para>Falls alle obigen Schritte fehlschlagen, kann der
            <filename>GENERIC</filename>-Kernel folgendermassen aus den Quellen
            neu gebaut und installiert werden:</para>

          <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>env DESTDIR=/boot/GENERIC make kernel</userinput>
&prompt.root; <userinput>mv /boot/GENERIC/boot/kernel/* /boot/GENERIC</userinput>
&prompt.root; <userinput>rm -rf /boot/GENERIC/boot</userinput></screen>

          <para>Damit dieser Kernel als <filename>GENERIC</filename>-Kernel von
            <command>freebsd-update</command> erkannt wird, darf die
            <filename>GENERIC</filename>-Konfigurationsdatei in keiner Weise
            geändert worden sein.  Es wird ebenfalls empfohlen, dass
            dieser ohne irgendwelche speziellen Optionen erstellt wird
            (bevorzugt mit einer leeren
            <filename>/etc/make.conf</filename>).</para>
        </listitem>
      </itemizedlist>

      <para>Der Neustart in den <filename>GENERIC</filename>-Kernel ist zu
        diesem Zeitpunkt nicht notwendig.</para>

      <para>Aktualisierungen an Haupt- und Unterversionen können
        durchgeführt werden, wenn man <command>freebsd-update</command>
        eine Release-Version als Ziel übergibt.  Beispielsweise wird das
        folgende Kommando das System auf &os;&nbsp;8.1 aktualisieren:</para>

      <screen>&prompt.root; <userinput>freebsd-update -r 8.1-RELEASE upgrade</userinput></screen>

      <para>Nachdem das Kommando empfangen wurde, überprüft
        <command>freebsd-update</command> die Konfigurationsdatei und das
        aktuelle System, um die nötigen Informationen für die
        Systemaktualisierung zu sammeln.  Eine Bildschirmausgabe wird anzeigen,
        welche Komponenten erkannt und welche nicht erkannt wurden.
        Zum Beispiel:</para>

      <screen>Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature for 8.0-RELEASE from update1.FreeBSD.org... done.
Fetching metadata index... done.
Inspecting system... done.

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD do not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable (y/n)? y</screen>

      <para>An diesem Punkt wird <command>freebsd-update</command> versuchen,
        alle notwendigen Dateien für die Aktualisierung herunter zu laden.
        In manchen Fällen wird der Benutzer mit Fragen konfrontiert, um
        festzustellen, was installiert werden soll oder auf welche Art und
        Weise fortgesetzt werden soll.</para>

      <para>Wenn ein selbstkonfigurierter Kernel benutzt wird, produziert der
        vorherige Schritt eine Warnung ähnlich zu der folgenden:</para>

      <screen>WARNING: This system is running a "<replaceable>MYKERNEL</replaceable>" kernel, which is not a
kernel configuration distributed as part of FreeBSD 8.0-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running "/usr/sbin/freebsd-update install"</screen>

      <para>Diese Warnung kann an dieser Stelle problemlos ignoriert
        werden.  Der aktualisierte <filename>GENERIC</filename>-Kernel wird als
        ein Zwischenschritt im Aktualisierungsprozess verwendet.</para>

      <para>Nachdem alle Korrekturen auf das lokale System heruntergeladen
        wurden, werden diese nun eingespielt.  Dieser Prozess kann eine gewisse
        Zeit in Anspruch nehmen, abhängig von der Geschwindigkeit und
        Auslastung der Maschine.  Konfigurationsdateien werden ebenfalls
        zusammengefügt - dieser Teil der Prozedur benötigt einige
        Benutzereingaben, da eine Datei möglicherweise von Hand
        zusammengefasst werden muss oder ein Editor erscheint auf dem
        Bildschirm zum manuellen bearbeiten.  Die Ergebnisse von jeder
        erfolgreichen Zusammenfassung werden dem Benutzer angezeigt,
        während der Prozess weiterläuft.  Eine fehlgeschlagene oder
        ignorierte Zusammenfassung wird den Prozess sofort beenden.  Benutzer
        sollten eine Sicherung von <filename>/etc</filename>
        anlegen und wichtige Dateien später manuell vereinen,
        beispielsweise <filename>master.passwd</filename> oder
        <filename>group</filename>.</para>

      <note>
        <para>Das System ist noch nicht verändert worden, alle Korrekturen
          und Vereinigungen sind in einem anderen Verzeichnis vorgenommen
          worden.  Wenn alle Korrekturen erfolgreich eingespielt, alle
          Konfigurationsdateien zusammengefügt wurden und es den Anschein
          hat, dass der Prozess problemlos verlaufen wird, müssen die
          Änderungen vom Anwender noch angewendet werden.</para>
      </note>

      <para>Sobald dieser Prozess abgeschlossen ist, können die
        Aktualisierungen über das folgende Kommando auf die Platte
        geschrieben werden:</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Der Kernel und die Module werden zuerst aktualisiert.  Zu diesem
        Zeitpunkt muss die Maschine neu gestartet werden.  Wenn das System
        einen selbstkonfigurierten Kernel verwendet, benutzen Sie das
        &man.nextboot.8;-Kommando, um den Kernel für den nächsten
        Neustart auf <filename>/boot/GENERIC</filename> zu
        setzen (welcher aktualisiert wurde):</para>

      <screen>&prompt.root; <userinput>nextboot -k GENERIC</userinput></screen>

      <warning>
        <para>Bevor mit dem <filename>GENERIC</filename>-Kernel das System neu
          gestartet wird, vergewissern Sie sich, dass alle notwendigen Treiber
          für ihr System enthalten sind, um korrekt zu starten (und
          schliessen Sie ihn ans Netzwerk an, falls auf die Maschine, die
          aktualisiert wird, von der Ferne aus zugegriffen wird).  Achten Sie
          besonders darauf, dass wenn der vorherige selbstkonfigurierte Kernel
          Funktionalität beinhaltet, die von Kernelmodulen zur
          Verfügung gestellt wurde, dass diese temporär in den
          <filename>GENERIC</filename>-Kernel über die Datei
          <filename>/boot/loader.conf</filename> übernommen werden.
          Sie sollten ebenfalls nicht benötigte Dienste, eingehängte
          Platten, verbundene Netzlaufwerke, usw. deaktivieren, bis der
          Aktualisierungsprozess abgeschlossen ist.</para>
      </warning>

      <para>Die Maschine sollte nun mit dem aktualisierten Kernel neu
        gestartet werden:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <para>Sobald das System wieder hochgefahren wurde, muss
        <command>freebsd-update</command> erneut gestartet werden.  Der Zustand
        des Prozesses wurde zuvor gesichert und deshalb wird
        <command>freebsd-update</command> nicht von vorne beginnen, jedoch alle
        alten Shared-Libraries und Objektdateien löschen.  Um zu diesem
        Zustand zu gelangen, setzen Sie das folgende Kommando ab:</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <note>
        <para>Abhängig davon, ob irgendwelche Bibliotheksversionen
          erhöht wurden, kann es sein, dass nur zwei Installationsphasen
          anstatt drei durchlaufen werden.</para>
      </note>

      <para>Nun muss alle Drittanbieter-Software neu erstellt und neu
        installiert werden.  Dies ist notwendig, da die installierte Software
        möglicherweise Abhängigkeiten zu Bibliotheken enthält,
        die während der Aktualisierung entfernt wurden.  Der <package>ports-mgmt/portupgrade</package>-Befehl kann verwendet
        werden, um diesen Vorgang zu automatisieren.  Die folgenden Kommandos
        können verwendet werden, um diesen Prozess zu starten:</para>

      <screen>&prompt.root; <userinput>portupgrade -f ruby</userinput>
&prompt.root; <userinput>rm /var/db/pkg/pkgdb.db</userinput>
&prompt.root; <userinput>portupgrade -f ruby18-bdb</userinput>
&prompt.root; <userinput>rm /var/db/pkg/pkgdb.db /usr/ports/INDEX-*.db</userinput>
&prompt.root; <userinput>portupgrade -af</userinput></screen>

      <para>Sobald dies abgeschlossen ist, beenden Sie den
        Aktualisierungsprozess mit einem letzten Aufruf von
        <command>freebsd-update</command>.  Geben Sie den folgenden Befehl ein,
        um alle losen Enden des Aktualisierungsprozesses miteinander zu
        verknüpfen:</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Wenn der <filename>GENERIC</filename>-Kernel temporär
        Verwendung fand, ist dies der richtige Zeitpunkt, einen neuen,
        selbstkonfigurierten Kernel zu bauen und über die übliche
        Methode zu installieren.</para>

      <para>Booten Sie anschliessend die Maschine in die neue &os;-Version.
        Der Prozess ist damit abgeschlossen.</para>
    </sect2>

    <sect2 xml:id="freebsdupdate-system-comparison">
      <title>Vergleich des Systemzustands</title>

      <para>Das <command>freebsd-update</command>-Werkzeug kann verwendet
        werden, um den Zustand der installierten &os;-Version gegenüber
        einer bekannten und funktionierenden Kopie zu vergleichen.  Diese
        Option vergleicht die aktuelle Version von Systemwerkzeugen,
        Bibliotheken und Konfigurationsdateien.  Um diesen Vergleich zu
        starten, geben Sie den folgenden Befehl ein:</para>

      <screen>&prompt.root; <userinput>freebsd-update IDS &gt;&gt; outfile.ids</userinput></screen>

      <warning>
        <para>Obwohl der Befehlsname <acronym>IDS</acronym> lautet, sollte er
          in keiner Weise als Ersatz für ein Intrusion Detection System
          wie <package>security/snort</package> angesehen
          werden.  Da <command>freebsd-update</command> seine Daten auf Platte
          ablegt, ist die Möglichkeit von Verfälschungen
          offensichtlich.  Obwohl diese Möglichkeit durch die Verwendung
          von <varname>kern.securelevel</varname> oder die Ablage von
          <command>freebsd-update</command> auf einem Nur-Lese Dateisystem,
          wenn es gerade nicht gebraucht wird, eingedämmt werden kann,
          besteht eine bessere Lösung darin, das System gegen ein
          gesichertes Medium, wie eine <acronym>DVD</acronym> oder einen
          externen, separat aufbewahrten
          <acronym>USB</acronym>-Plattenspeicher, zu vergleichen.</para>
      </warning>

      <para>Das System wird jetzt untersucht und eine Liste von Dateien
        ausgegeben, zusammen mit deren &man.sha256.1;-Hashwerten, sowohl der
        von der Release-Version bekannte Wert als auch der des aktuell
        installierten Systems.  Das ist der Grund dafür, warum die Ausgabe
        an die Datei <filename>outfile.ids</filename> geschickt wurde.  Es
        scrollt zu schnell vorbei, um diese mit den Augen zu vergleichen und
        bald wird auch der Konsolenpuffer damit überfüllt.</para>

      <para>Diese Zeilen sind dazu noch extrem lang, aber das Ausgabeformat
        kann sehr einfach verarbeitet werden. Um beispielsweise eine Liste von
        allen Dateien zu erhalten, die sich vom aktuellen Release
        unterscheiden, geben Sie das folgende Kommando ein:</para>

      <screen>&prompt.root; <userinput>cat outfile.ids | awk '{ print $1 }' | more</userinput>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</screen>

      <para>Diese Ausgabe wurde abgeschnitten, es existieren noch viel mehr
        Dateien dazu.  Manche dieser Dateien besitzen ganz
        selbstverständliche Veränderungen,
        <filename>/etc/passwd</filename> wurde beispielsweise geändert,
        um Benutzer zum System hinzuzufügen.  In manchen Fällen kann
        es anderen Dateien wie Kernelmodule geben, welche sich geändert
        haben, weil <command>freebsd-update</command> diese aktualisiert hat.
        Um bestimmte Dateien oder Verzeichnisse auszuschliessen, hängen
        Sie diese an die <literal>IDSIgnorePaths</literal>-Option in
        <filename>/etc/freebsd-update.conf</filename> an.</para>

      <para>Diese Vorgehensweise kann als Teil einer ausgeklügelten
        Aktualisierungsmethode benutzt werden, unabhängig von der zuvor
        angesprochenen Variante.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="updating-upgrading-portsnap">
    <info><title>Portsnap: Ein Werkzeug zur Aktualisierung der Ports-Sammlung</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Geschrieben von </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Colin</firstname><surname>Percival</surname></personname><contrib>Basierend auf bereitgestellten Mitschriften von </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Benedict</firstname><surname>Reuschling</surname></personname><contrib>Übersetzt von </contrib></author>
      </authorgroup>
    </info>
    

    <indexterm><primary>Updating and Upgrading</primary></indexterm>
    <indexterm>
      <primary>Portsnap</primary>
      <see>Updating and Upgrading</see>
    </indexterm>

    <para>Das Basissystem von &os; enthält auch ein Programm zum
      Aktualisieren der Ports-Sammlung: das &man.portsnap.8; Werkzeug.  Wenn
      es ausgeführt wird, verbindet es sich mit einem entfernten Rechner,
      überprüft den Sicherungsschlüssel und lädt eine neue
      Kopie der Ports-Sammlung herunter.  Der Schlüssel wird dazu
      verwendet, um die Integrität aller heruntergeladenen Dateien zu
      prüfen und um sicherzustellen, dass diese unterwegs nicht
      verändert wurden.  Um die aktuellsten Dateien der Ports-Sammlung
      herunter zu laden, geben Sie das folgende Kommando ein:</para>

    <screen>&prompt.root; <userinput>portsnap fetch</userinput>
Looking up portsnap.FreeBSD.org mirrors... 3 mirrors found.
Fetching snapshot tag from portsnap1.FreeBSD.org... done.
Fetching snapshot metadata... done.
Updating from Wed Aug  6 18:00:22 EDT 2008 to Sat Aug 30 20:24:11 EDT 2008.
Fetching 3 metadata patches.. done.
Applying metadata patches... done.
Fetching 3 metadata files... done.
Fetching 90 patches.....10....20....30....40....50....60....70....80....90. done.
Applying patches... done.
Fetching 133 new ports or files... done.</screen>

    <para>Dieses Beispiel zeigt, dass &man.portsnap.8; mehrere Korrekturen
      für die aktuellen Ports-Daten gefunden und verifiziert hat.  Es
      zeigt auch, dass das Programm zuvor schon einmal gestartet wurde.
      Wäre es das erste Mal, würde nur die Ports-Sammlung
      heruntergeladen werden.</para>

    <para>Wenn &man.portsnap.8; erfolgreich die
      <command>fetch</command>-Operation abgeschlossen hat, befinden sich die
      Ports-Sammlung und die dazugehörigen Korrekturen auf dem lokalen
      System, welches die Überprüfung bestanden hat.  Wenn Sie
      <command>portsnap</command> das erste Mal ausgeführt haben,
      müssen Sie den Befehl <literal>portsnap extract</literal>
      verwenden, um die Ports-Sammlung zu installieren:</para>

    <screen>&prompt.root; <userinput>portsnap extract</userinput>
/usr/ports/.cvsignore
/usr/ports/CHANGES
/usr/ports/COPYRIGHT
/usr/ports/GIDs
/usr/ports/KNOBS
/usr/ports/LEGAL
/usr/ports/MOVED
/usr/ports/Makefile
/usr/ports/Mk/bsd.apache.mk
/usr/ports/Mk/bsd.autotools.mk
/usr/ports/Mk/bsd.cmake.mk
<replaceable>...</replaceable></screen>

    <para>Um Ihre bereits installierte Ports-Sammlung zu aktualisieren,
      verwenden Sie hingegen den Parameter <literal>update</literal>:</para>

    <screen>&prompt.root; <userinput>portsnap update</userinput></screen>

    <para>Der Prozess ist jetzt abgeschlossen und Anwendungen können
      mittels der aktuellen Ports-Sammlung installiert oder aktualisiert
      werden.</para>

    <para>Die Operationen <literal>fetch</literal> und
      <literal>extract</literal> oder <literal>update</literal> können
      auch nacheinander ausgeführt werden, wie im folgenden Beispiel
      gezeigt:</para>

    <screen>&prompt.root; <userinput>portsnap fetch update</userinput></screen>

    <para>Dieser Befehl lädt die aktuelle Version der Ports-Sammlung
      herunter und aktualisiert anschließend Ihre lokale Version
      im Verzeichnis <filename>/usr/ports</filename>.</para>
  </sect1>

  <sect1 xml:id="updating-upgrading-documentation">
    <info><title>Aktualisieren der Dokumentationssammlung</title>
      <authorgroup>
	<author><personname><firstname>Benedict</firstname><surname>Reuschling</surname></personname><contrib>Übersetzt von </contrib></author>
      </authorgroup>
    </info>
    

    <indexterm><primary>Updating and Upgrading</primary></indexterm>

    <indexterm>
      <primary>Documentation</primary>
      <see>Updating and Upgrading</see>
    </indexterm>

    <para>Neben dem Basissystem und der Ports-Sammlung ist die Dokumentation
      ein wichtiger Bestandteil des &os; Betriebssystems.  Obwohl eine aktuelle
      Version der &os; Dokumentation jederzeit auf der <link xlink:href="http://www.freebsd.org/doc/">&os; Webseite</link> verfügbar
      ist, verfügen manche Benutzer nur über eine langsame oder
      überhaupt keine Netzwerkverbindung. Glücklicherweise gibt es
      mehrere Möglichkeiten, die Dokumentation, welche mit jeder Version
      ausgeliefert wird, zu aktualisieren, indem eine lokale Kopie der
      aktuellen &os;-Dokumentationssammlung verwendet wird.</para>

    <sect2 xml:id="csup-doc">
      <title>Verwenden von CVSup um die Dokumentation zu aktualisieren</title>

      <para>Die Quellen und die installierte Kopie der &os; Dokumentation
        kann mittels <application>CVSup</application> aktualisiert werden,
        indem ein ähnlicher Mechanismus angewendet wird, wie derjenige
        für die Betriebssystemquellen (vergleichen Sie mit <xref linkend="makeworld"/>).  Dieser Abschnitt beschreibt:</para>

      <itemizedlist>
	<listitem>
	  <para>Wie die Dokumentations-Werkzeugsammlung installiert wird,
	    welche die Werkzeuge enthält, die nötig sind, um die
	    &os; Dokumentation aus den Quellen neu zu erstellen.</para>
	</listitem>

	<listitem>
	  <para>Wie man eine Kopie der Dokumentationsquellen nach <filename>/usr/doc</filename> herunterlädt, unter
	    Verwendung von <application>CVSup</application>.</para>
	</listitem>

	<listitem>
	  <para>Wie man die &os; Dokumentation aus den Quellen baut und unter
	    <filename>/usr/share/doc</filename>
	    installiert.</para>
	</listitem>

	<listitem>
	  <para>Manche der Optionen zum Erstellen, die vom System zum Bauen der
	    Dokumentation unterstützt werden, z.B. die Optionen welche nur
	    ein paar der unterschiedlichen Sprachübersetzungen der
	    Dokumentation erstellen oder die Optionen, die ein bestimmtes
	    Ausgabeformat auswählen.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2 xml:id="installing-documentation-toolchain">
      <title>CVSup und die Werkzeugsammlung der Dokumentation
        installieren</title>

      <para>Die &os; Dokumentation aus dem Quellen zu erstellen benötigt
        eine ziemlich grosse Anzahl an Werkzeugen.  Diese Werkzeuge sind nicht
        Teil des &os; Basissystems, da sie eine grosse Menge an Plattenplatz
        verbrauchen und nicht von allen &os;-Anwendern benötigt werden.
        Sie sind nur für diejenigen Benutzer notwendig, die aktiv an neuer
        Dokumentation fü &os; schreiben oder häufig ihre
        Dokumentation aus den Quellen bauen lassen.</para>

      <para>Alle benötigten Werkzeuge sind als Teil der Ports-Sammlung
        verfügbar.  Der Port <package>textproc/docproj</package> dient als Masterport, der
        vom &os; Documentation Project entwickelt wurde, um die initiale
        Installation und zukünftige Aktualisierungen dieser Werkzeuge zu
        vereinfachen.</para>

      <note>
	<para>Wenn Sie die Dokumentation nicht als &postscript; oder PDF
	  benötigen, können Sie alternativ die Installation des
	  <package>textproc/docproj-nojadetex</package>-Ports
	  in Erwägung ziehen.  Diese Version der
	  Dokumentations-Werkzeugsammlung enthält alles ausser das
	  <application>teTeX</application>-Textsatzsystem.
	  <application>teTeX</application> ist eine sehr grosse Sammlung an
	  Werkzeugen, deshalb ist es vernünftig, deren Installation
	  auszulassen, wenn die Ausgabe von PDF nicht unbedingt gebraucht
	  wird.</para>
      </note>

      <para>Für weitere Informationen über das Installieren und
        Verwenden von <application>CVSup</application>, lesen Sie <link linkend="cvsup">CVSup verwenden</link>.</para>
    </sect2>

    <sect2 xml:id="updating-documentation-sources">
      <title>Die Dokumentationsquellen aktualisieren</title>

      <para>Das Programm <application>CVSup</application> kann eine saubere
        Kopie der Dokumentationsquellen holen, indem es die Datei
        <filename>/usr/share/examples/cvsup/doc-supfile</filename> als
        Konfigurationsvorlage verwendet.  Der Standard-Host zum Aktualisieren
        ist auf einen Platzhalterwert im <filename>doc-supfile</filename>
        gesetzt, aber &man.cvsup.1; akzeptiert auch einen Hostnamen über
        die Kommandozeile. Somit können die Dokumentationsquellen von
        einem der <application>CVSup</application>-Server geholt werden, indem
        man eingibt:</para>

      <screen>&prompt.root; <userinput>cvsup -h cvsup.FreeBSD.org -g -L 2 /usr/share/examples/cvsup/doc-supfile</userinput></screen>

      <para>Ändern Sie <replaceable>cvsup.FreeBSD.org</replaceable> auf
        den Ihnen am nächsten gelegenen
        <application>CVSup</application>-Server.  Eine vollständige Liste
        von Spiegelservern finden Sie unter <xref linkend="cvsup-mirrors"/>.</para>

      <para>Es dauert eine Weile, wenn die Dokumentationsquellen das allererste
        Mal heruntergeladen werden. Lassen Sie es laufen, bis es fertig
        ist.</para>

      <para>Zukünftige Aktualisierungen der Dokumentationsquellen
        können Sie über den gleichen Befehl bekommen.  Das Programm
        <application>CVSup</application> lädt und kopiert nur diejenigen
        Aktualisierungen herunter, die seit seinem letzten Aufruf hinzugekommen
        sind.  Deshalb sollte jeder weitere Aufruf von
        <application>CVSup</application> nach dem Ersten wesentlich schneller
        abgeschlossen sein.</para>

      <para>Nachdem die Quellen einmal ausgecheckt wurden, besteht ein anderer
        Weg, die Dokumentation zu aktualisieren, darin, das
        <filename>Makefile</filename> im Verzeichnis <filename>/usr/doc</filename> anzupassen.  Durch setzen von
        <varname>SUP_UPDATE</varname>, <varname>SUPHOST</varname> und
        <varname>DOCSUPFILE</varname> in der Datei
        <filename>/etc/make.conf</filename> ist es jetzt möglich,
        folgendes zu tun:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make update</userinput></screen>

      <para>Ein typischer Satz dieser &man.make.1;-Optionen für
        <filename>/etc/make.conf</filename> ist:</para>

      <programlisting>SUP_UPDATE= yes
SUPHOST?= cvsup.freebsd.org
DOCSUPFILE?= /usr/share/examples/cvsup/doc-supfile</programlisting>

      <note>
	<para>Das Setzen des Werts von <varname>SUPHOST</varname> und
	  <varname>DOCSUPFILE</varname> auf <literal>?=</literal> erlaubt es,
	  diese in der Kommandozeile von make zu überschreiben.  Diese
	  Methode wird empfohlen, um Optionen zu <filename>make.conf</filename>
	  hinzuzufügen, um zu verhindern, dass man die Datei jedes Mal
	  bearbeiten muss, um einen anderen Wert für die Option
	  auszuprobieren.</para>
      </note>
    </sect2>

    <sect2 xml:id="updating-documentation-options">
      <title>Einstellbare Optionen der Dokumentationsquellen</title>

      <para>Das System zum aktualisieren und erstellen der &os;-Dokumentation
        unterstützt ein paar Optionen, welche den Prozess der
        Aktualisierung von Teilen der Dokumentation oder einer bestimmten
        Übersetzung erleichtert.  Diese Optionen lassen sich entweder
        systemweit in der Datei <filename>/etc/make.conf</filename> setzen,
        oder als Kommandozeilenoptionen, die dem &man.make.1;-Werkzeug
        übergeben werden.</para>

      <para>Die folgenden Optionen sind ein paar davon:</para>

      <variablelist>
	<varlistentry>
	  <term><varname>DOC_LANG</varname></term>

	  <listitem>
	    <para>Eine Liste von Sprachen und Kodierungen, die gebaut und
	      installiert werden sollen, z.B.
	      <literal>en_US.ISO8859-1</literal>, um nur die englische
	      Dokumentation zu erhalten.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>FORMATS</varname></term>

	  <listitem>
	    <para>Ein einzelnes Format oder eine Liste von Ausgabeformaten, das
	      gebaut werden soll. Momentan werden <literal>html</literal>,
	      <literal>html-split</literal>, <literal>txt</literal>,
	      <literal>ps</literal>, <literal>pdf</literal>,
	      und <literal>rtf</literal> unterstützt.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>SUPHOST</varname></term>

	  <listitem>
	    <para>Der Hostname des <application>CVSup</application>-Servers,
	      der verwendet werden soll, um Aktualisierungen zu holen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>DOCDIR</varname></term>

	  <listitem>
	    <para>Wohin die Dokumentation installiert werden soll.  Der
	      Standardpfad ist <filename>/usr/share/doc</filename>.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Für weitere make-Variablen, die als systemweite Optionen
        in &os; unterstützt werden, lesen Sie &man.make.conf.5;.</para>

      <para>Für weitere make-Variablen, die vom System zum Erstellen der
        &os;-Dokumentation unterstützt werden, lesen Sie die <link xlink:href="&url.doc.langbase;/books/fdp-primer">Fibel für neue
        Mitarbeiter des &os;-Dokumentationsprojekts</link>.</para>
    </sect2>

    <sect2 xml:id="updating-installed-documentation">
      <title>Die &os;-Dokumentation aus den Quellen installieren</title>

      <para>Wenn ein aktueller Schnappschuss der Dokumentationsquellen nach
        <filename>/usr/doc</filename> heruntergeladen wurde,
        ist alles bereit für eine Aktualisierung der bestehenden
        Dokumentation.</para>

      <para>Eine komplette Aktualisierung aller Sprachoptionen, definiert durch
        die <varname>DOC_LANG</varname> Makefile-Option, kann durch folgende
        Eingabe erreicht werden:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>Wenn <filename>make.conf</filename> mit den richtigen Optionen
        <varname>DOCSUPFILE</varname>, <varname>SUPHOST</varname> und
        <varname>SUP_UPDATE</varname> eingerichtet wurde, kann der
        Installationsschritt mit einer Aktualisierung der Dokumentationsquellen
        kombiniert werden, indem man eingibt:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make update install clean</userinput></screen>

      <para>Wenn nur eine Aktualisierung einer bestimmten Sprache
        gewünscht wird, kann &man.make.1; in einem sprachspezifischen
        Unterverzeichnis von <filename>/usr/doc</filename>
        aufgerufen werden, z.B.:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc/en_US.ISO8859-1</userinput>
&prompt.root; <userinput>make update install clean</userinput></screen>

      <para>Die zu installierenden Ausgabeformate können durch das Setzen
        der make-Variablen <varname>FORMATS</varname> angegeben werden,
        z.B.:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make FORMATS='html html-split' install clean</userinput></screen>
    </sect2>

    <sect2 xml:id="doc-ports">
      <info><title>Verwendung von Dokumentations-Ports</title>
	<authorgroup>
	  <author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Basierend auf der Arbeit von </contrib></author>
	</authorgroup>
      </info>

      

      <indexterm><primary>Updating and Upgrading</primary></indexterm>

      <indexterm>
	<primary>documentation package</primary>
	<see>Updating and Upgrading</see>
      </indexterm>

      <para>Im vorherigen Abschnitt wurde eine Methode gezeigt, wie die
        &os;-Dokumentation aus den Quellen gebaut werden kann.  Allerdings sind
        quellbasierte Aktualisierungen möglicherweise nicht für alle
        &os;-Systeme geeignet oder praktikabel. Das Erstellen der
        Dokumentationsquellen benötigt eine grosse Anzahl an Werkzeugen,
        Programmen und Hilfsmitteln, die <emphasis>documentation
        toolchain</emphasis>, ein gewisser Grad an Vertrautheit mit
        <application>CVS</application> und ausgecheckte Quellen von einem
        Repository, sowie ein paar manuelle Schritte, um diese ausgecheckten
        Quellen zu bauen.  In diesem Abschnitt wird eine alternative Art und
        Weise vorgestellt, wie man die installierte Kopie der
        &os;-Dokumentation aktualisieren kann.  Diese Methode verwendet die
        Ports-Sammlung und erlaubt es:</para>

      <itemizedlist>
	<listitem>
	  <para>vorgefertigte Schnappschüsse der Dokumentation herunter zu
	    laden und zu installieren, ohne vorher irgendetwas lokal zu
	    erstellen (dadurch ist es nicht mehr notwendig, den kompletten
	    Werkzeugkasten der Dokumentation zu installieren).</para>
	</listitem>

	<listitem>
	  <para>die Dokumentationsquellen herunterzuladen und durch das
	    Ports-System erstellen zu lassen (was die Schritte zum Auschecken
	    und Erstellen etwas erleichtert).</para>
	</listitem>
      </itemizedlist>

      <para>Diese beiden Methoden der Aktualisierung der &os;-Dokumentation
        werden durch eine Menge von <emphasis>Dokumentations-Ports</emphasis>
        unterstützt, die von &a.doceng; monatlich aktualisiert wird.
        Diese sind in der Ports-Sammlung unter der virtuellen Kategorie, <link xlink:href="http://www.freshports.org/docs/">docs</link> genannt,
        gelistet.</para>

      <sect3 xml:id="doc-ports-install-make">
	<title>Erstellen und Installieren von Dokumentations-Ports</title>

	<para>Die Dokumentations-Ports nutzen das Ports-System, um das
	  Erstellen von Dokumentation wesentlich einfacher zu machen.  Es
	  automatisiert den Prozess des Auscheckens der Dokumentationsquellen,
	  aufrufen von &man.make.1; mit den passenden Umgebungsvariablen und
	  Kommandozeilenoptionen und macht die Installation und Deinstallation
	  von Dokumentation so einfach wie die Installation von jedem anderen
	  Port oder Paket.</para>

	<note>
	  <para>Als zusätzliche Eigenschaft zeichnen sie eine
	    Abhängigkeit zum
	    <emphasis>Dokumentations-Werkzeugsatz</emphasis> auf, wenn die
	    Dokumentations-Ports lokal erstellt werden, weshalb dieser auch
	    automatisch mitinstalliert wird.</para>
	</note>

	<para>Die Dokumentations-Ports sind wie folgt organisiert:</para>

	<itemizedlist>
	  <listitem>
	    <para>Es existiert ein <quote>Master-Port</quote>, <package>misc/freebsd-doc-en</package>, in dem alle
	      Dateien zu den Dokumentations-Ports abgelegt sind.  Es dient als
	      Basis für alle Dokumentations-Ports.  Als Voreinstellung
	      wird nur die englische Dokumentation gebaut.</para>
	  </listitem>

	  <listitem>
	    <para>Es gibt einen <quote>Alles-in-Einem-Port</quote>, <package>misc/freebsd-doc-all</package>, welcher die
	      komplette Dokumentation in allen verfügbaren Sprachen
	      erstellt und installiert.</para>
	  </listitem>

	  <listitem>
	    <para>Schliesslich gibt es noch einen sogenannten <quote>slave
	      port</quote> für jede Übersetzung, z.B.: <package>misc/freebsd-doc-hu</package> für
	      Dokumentation in ungarischer Sprache.  All diese benötigen
	      den Master-Port und installieren die übersetzte
	      Dokumentation in der entsprechenden Sprache.</para>
	  </listitem>
	</itemizedlist>

	<para>Um einen Dokumentations-Port aus den Quellen zu installieren,
	  geben Sie das folgende Kommando (als <systemitem class="username">root</systemitem>)
	  ein:</para>

	<screen>&prompt.root; <userinput>cd /usr/ports/misc/freebsd-doc-en</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

	<para>Auf diese Weise wird die englische Dokumentation gebaut und als
	  getrenntes <acronym>HTML</acronym>-Format im Verzeichnis <filename>/usr/local/share/doc/freebsd</filename> installiert
	  (genau wie unter <uri xlink:href="http://www.FreeBSD.org">http://www.FreeBSD.org</uri> zu
	  finden).</para>

	<sect4 xml:id="doc-ports-options">
	  <title>Gebräuchliche Schalter und Optionen</title>

	  <para>Es gibt viele Optionen, um das Standarderhalten der
	    Dokumentations-Ports zu verändern.  Im Folgenden sind nur ein
	    paar davon aufgeführt:</para>

	  <variablelist>
	    <varlistentry>
	      <term><varname>WITH_HTML</varname></term>

	      <listitem>
		<para>Erlaubt das Erstellen im HTML-Format: eine einzige
		  HTML-Datei pro Dokument.  Die formatierte Dokumentation wird
		  als Datei mit dem Namen <filename>article.html</filename>
		  gespeichert, oder, je nachdem, als
		  <filename>book.html</filename>, zuzuüglich der
		  Bilder.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><varname>WITH_PDF</varname></term>

	      <listitem>
		<para>Erlaubt das Erstellen von &adobe; Portable Document
		  Format, für die Verwendung mit &adobe; &acrobat.reader;,
		  <application>Ghostscript</application> oder anderen
		  PDF-Betrachtern.  Die formatierte Dokumentation wird als Datei
		  mit dem Namen <filename>article.pdf</filename> oder, soweit
		  angemessen, als <filename>book.pdf</filename>
		  gespeichert.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><varname>DOCBASE</varname></term>

	      <listitem>
		<para>Wohin die Dokumentation installiert werden soll.  Der
		  Standardpfad ist <filename>/usr/local/share/doc/freebsd</filename>.</para>

		<note>
		  <para>Beachten Sie, dass sich der Standardpfad von dem
		    Verzeichnis unterscheidet, das von der
		    <application>CVSup</application>-Methode verwendet wird.
		    Das liegt daran, dass ein Port installiert wird und diese
		    üblicherweise im Verzeichnis <filename>/usr/local</filename> abgelegt werden.
		    Durch setzen der <varname>PREFIX</varname>-Variablen kann
		    dieses Verhalten geändert werden.</para>
		</note>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Es folgt ein kurzes Beispiel, wie die Variablen verwendet
	    werden, um die oben erwähnte ungarische Dokumentation als
	    Portable Document Format zu installieren:</para>

	  <screen>&prompt.root; cd /usr/ports/misc/freebsd-doc-hu
&prompt.root; make -DWITH_PDF DOCBASE=share/doc/freebsd/hu install clean</screen>
	</sect4>
      </sect3>

      <sect3 xml:id="doc-ports-install-package">
	<title>Verwendung von Dokumentations-Paketen</title>

	<para>Das Erstellen der Dokumentations-Ports aus den Quellen, wie im
	  vorherigen Abschnitt beschrieben, benötigt die lokale
	  Installation der Dokumentations-Werkzeugsammlung und ein wenig
	  Festplattenspeicher für das Bauen der Ports.  Sollten die
	  Ressourcen zum Bauen der Dokumentations-Werkzeugsammlung nicht zur
	  Verfügung stehen, oder weil das erstellen zuviel Plattenplatz
	  benötigen würde, ist es trotzdem möglich, bereits
	  zuvor gebaute Schnappschüsse der Dokumentations-Ports zu
	  installieren.</para>

	<para>&a.doceng; erstellt monatliche Schnappschüsse der
	  Dokumentations-Pakete von &os;.  Diese Binärpakete können
	  mit jedem der mitgelieferten Paketwerkzeuge installiert werden,
	  beispielsweise &man.pkg.add.1;, &man.pkg.delete.1; und so
	  weiter.</para>

	<note>
	  <para>Wenn Binärpakete zu Einsatz kommen, wird die
            &os;-Dokumentation in <emphasis>allen</emphasis> verfügbaren
            Formaten in der gegebenen Sprache installiert.</para>
	</note>

	<para>Zum Beispiel installiert das folgende Kommando das aktuelle,
	  vorgefertigte Paket der ungarischen Dokumentation:</para>

	<screen>&prompt.root; <userinput>pkg_add -r hu-freebsd-doc</userinput></screen>

	<note>
	  <para>Pakete haben das folgende Namensformat, welches sich von dem
	    Namen des dazugehörigen Ports unterscheidet:
	    <literal>lang-freebsd-doc</literal>.
	    <replaceable>lang</replaceable> entspricht hier der Kurzform des
	    Sprachcodes, z.B. <literal>hu</literal> für Ungarisch, oder
	    <literal>zh_cn</literal> für vereinfachtes Chinesisch.</para>
	</note>
      </sect3>

      <sect3 xml:id="doc-ports-update">
	<title>Dokumentations-Ports aktualisieren</title>

	<para>Um einen zuvor installierten Dokumentations-Port zu aktualisieren,
	  kann jedes Werkzeug, das auch zum Aktualisieren von Ports verwendet
	  wird, eingesetzt werden.  Beispielsweise aktualisiert das folgende
	  Kommando die installierte ungarische Dokumentation mittels des
	  Programms <package>ports-mgmt/portupgrade</package> indem nur Pakete
	  verwendet werden sollen:</para>

	<screen>&prompt.root; <userinput>portupgrade -PP hu-freebsd-doc</userinput></screen>
      </sect3>
    </sect2>

<!-- FIXME: Waiting for a working docsnap server...

    <sect2 id="docsnap">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Pav</firstname>
	    <surname>Lucistnik</surname>
	    <contrib>Based on information provided by </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Using Docsnap</title>

      <indexterm><primary>Updating and Upgrading</primary></indexterm>

      <indexterm>
	<primary>Docsnap</primary>
	<see>Updating and Upgrading</see>
      </indexterm>

      <para><application>Docsnap</application> is an &man.rsync.1;
	repository for updating installed &os; Documentation in a
	relatively easy and fast way.  A
	<quote><application>Docsnap</application> server</quote> tracks
	the documentation sources, and builds them in HTML format every
	hour.  The <filename role="package">textproc/docproj</filename>
	is unneeded with <application>Docsnap</application> as only
	patches to the built documentation exist.</para>

      <para>The only requirement for using this technique is
	the <filename role="package">net/rsync</filename> port or
	package.  To add it, use the following command:</para>

      <screen>&prompt.root; <userinput>pkg_add -r rsync</userinput></screen>

      <note>
	<para><application>Docsnap</application> has been originally
	  developed for updating documentation installed
	  to <filename class="directory">/usr/share/doc</filename>, but
	  the following examples could be adapted for other directories
	  as well.  For user directories, it does not require
	  <username>root</username> privileges.</para>
      </note>

      <para>To update the documentation set, issue the following
	command:</para>

      <screen>&prompt.root; <userinput>rsync -rltvz <replaceable>docsnap.sk.FreeBSD.org</replaceable>::docsnap <replaceable>/usr/share/doc</replaceable></userinput></screen>

      <note>
	<para>There is only one <application>Docsnap</application>
	  server at the moment;
	  the <hostid>docsnap.sk.FreeBSD.org</hostid> shown
	  above.</para>
      </note>

      <para>Do not use the <option>&dash;&dash;delete</option> flag here as there
	are some items installed
	into <filename class="directory">/usr/share/doc</filename>
	during <command>make installworld</command>, which would
	accidentally be removed.  To clean up, use this command
	instead:</para>

      <screen>&prompt.root; <userinput>rsync -rltvz &dash;&dash;delete <replaceable>docsnap.sk.FreeBSD.org</replaceable>::docsnap/??_??\.\* <replaceable>/usr/share/doc</replaceable></userinput></screen>

      <para>If a subset of documentation needs to be updated, for
	example, the English documentation only, the following command
	should be used:</para>

      <screen>&prompt.root; <userinput>rsync -rltvz <replaceable>docsnap.sk.FreeBSD.org</replaceable>::docsnap/en_US.ISO8859-1 <replaceable>/usr/share/doc</replaceable></userinput></screen>
    </sect2>
-->
  </sect1>

  <sect1 xml:id="current-stable">
    <title>Einem Entwicklungszweig folgen</title>
    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>FreeBSD besitzt zwei Entwicklungszweige: &os.current; und
      &os.stable;.  Dieser Abschnitt beschreibt beide Zweige und
      erläutert, wie Sie Ihr System auf dem aktuellen Stand
      eines Zweiges halten.  Zuerst wird &os.current; vorgestellt, dann
      &os.stable;.</para>

    <sect2 xml:id="current">
      <title>&os.current;</title>

      <para>Beachten Sie im Folgenden, dass &os.current; die Spitze
        der Entwicklung von &os; ist.  Benutzer von &os.current; sollten
	über sehr gute technische Fähigkeiten verfügen und
	in der Lage sein, schwierige Probleme alleine zu lösen.  Wenn
	&os; neu für Sie ist, überlegen Sie sich genau, ob Sie
	&os.current; benutzen wollen.</para>

      <sect3>
	<title>Was ist &os.current;?</title>
	<indexterm><primary>Snapshot</primary></indexterm>

	<para>&os.current; besteht aus den neuesten Quellen des
	  FreeBSD-Systems.  Es enthält Sachen, an denen gerade
	  gearbeitet wird, experimentelle Änderungen und
	  Übergangsmechanismen, die im nächsten offiziellen
	  Release der Software enthalten sein können oder nicht.
	  Obwohl &os.current; täglich von vielen Entwicklern gebaut
	  wird, gibt es Zeiträume, in denen sich das System nicht
	  bauen lässt.  Diese Probleme werden so schnell wie
	  möglich gelöst, aber ob Sie mit &os.current;
	  Schiffbruch erleiden oder die gewünschten Verbesserungen
	  erhalten, kann von dem Zeitpunkt abhängen, an dem Sie sich
	  den Quelltext besorgt haben!</para>
      </sect3>

      <sect3>
	<title>Wer braucht &os.current;?</title>

	<para>&os.current; wird hauptsächlich für 3
	  Interessengruppen zur Verfügung gestellt:</para>

	<orderedlist>
	  <listitem>
	    <para>Entwickler, die an einem Teil des Quellbaums arbeiten und
	      daher über die aktuellen Quellen verfügen
	      müssen.</para>
	  </listitem>

	  <listitem>
	    <para>Tester, die bereit sind, Zeit in das Lösen von
	      Problemen zu investieren und sicherstellen, dass
	      &os.current; so stabil wie möglich bleibt.  Weiterhin
	      Leute, die Vorschläge zu Änderungen oder der
	      generellen Entwicklung von &os; machen und Patches
	      bereitstellen, um diese Vorschläge zu realisieren.</para>
	  </listitem>

	  <listitem>
	    <para>Für Leute, die die Entwicklung im Auge behalten
	      wollen, oder die Quellen zu Referenzzwecken (zum Beispiel
	      darin lesen, aber nicht verwenden) benutzen wollen.  Auch diese
	      Gruppe macht Vorschläge oder steuert Quellcode
	      bei.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Was &os.current; <emphasis>nicht</emphasis> ist!</title>

	<orderedlist>
	  <listitem>
	    <para>Der schnellste Weg, neue Sachen vor dem offiziellen
	      Release auszuprobieren.  Bedenken Sie, dass der erste,
	      der die neuen Sachen ausprobiert, auch der erste ist, der die
	      neuen Fehler findet.</para>
	  </listitem>

	  <listitem>
	    <para>Ein schneller Weg, um an Fehlerbehebungen (engl.
	      <foreignphrase>bug fixes</foreignphrase>) zu kommen.  Jede
	      Version von &os.current; führt mit gleicher
	      Wahrscheinlichkeit neue Fehler ein, mit der sie alte
	      behebt.</para>
	  </listitem>

	  <listitem>
	    <para>In irgendeiner Form <quote>offiziell
	        unterstützt</quote>.  Wir tun unser Bestes, um Leuten
	      aus den drei <quote>legitimen</quote> Benutzergruppen von
	      &os.current; zu helfen, aber wir <emphasis>haben einfach nicht
	      die Zeit</emphasis>, technische Unterstützung zu
	      erbringen.  Das kommt nicht daher, dass wir kleinliche,
	      gemeine Leute sind, die anderen nicht helfen wollen (wenn
	      wir das wären, würden wir &os; nicht machen), wir
	      können einfach nicht jeden Tag Hunderte Nachrichten
	      beantworten <emphasis>und</emphasis> an &os; arbeiten!  Vor
	      die Wahl gestellt, &os; zu verbessern oder jede Menge Fragen
	      zu experimentellem Code zu beantworten, haben sich die
	      Entwickler für ersteres entschieden.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Benutzen von &os.current;</title>

	<orderedlist>
	  <listitem>
	    <para>Es ist <emphasis>essentiell</emphasis>, die Mailinglisten
	      &a.current.name; und &a.svn-src-head.name;<indexterm><primary>-CURRENT</primary><secondary>benutzen</secondary></indexterm> zu lesen.  Wenn Sie
	      <emphasis>&a.current.name;</emphasis> nicht lesen, verpassen Sie
	      die Kommentare anderer über den momentanen Zustand des
	      Systems und rennen demzufolge in viele bekannte Probleme, die
	      schon gelöst sind.  Noch kritischer ist, dass Sie wichtige
	      Bekanntmachungen verpassen, die erhebliche Auswirkungen
	      auf die Stabilität Ihres Systems haben können.</para>

	    <para>In der &a.svn-src-head.name; Mailingliste sehen Sie zu jeder
	      Änderung das Commit-Log, das Informationen zu
	      möglichen Seiteneffekten enthält.</para>

	    <para>Um diese Listen zu abonnieren (oder zu lesen)
	      besuchen Sie bitte die Seite &a.mailman.lists.link;.
	      Weitere Informationen erhalten Sie, wenn Sie dort
	      auf die gewünschte Liste klicken.  Wenn Sie daran
	      interessiert sind, die Änderungen am gesamten Quellbaum
	      mit zu verfolgen, schlagen wir vor, die Liste
	      &a.svn-src-all.name; zu abonnieren.</para>
	  </listitem>

	  <listitem>
	    <para>Beschaffen Sie sich die Quellen von einem
	      <link linkend="mirrors">&os;-Spiegel</link>.  Sie haben
	      dazu zwei Möglichkeiten:</para>

	    <orderedlist>
	      <listitem>
		<para>Benutzen Sie das Programm
		  <link linkend="cvsup">cvsup</link><indexterm><primary><command>cvsup</command></primary></indexterm>
		  mit der Datei <filename>standard-supfile</filename>
		  aus dem Verzeichnis
		  <filename>/usr/share/examples/cvsup</filename>.
		  Dies ist die empfohlene Methode, da Sie die ganzen
		  Quellen nur einmal herunterladen und danach nur noch
		  Änderungen beziehen.  Viele lassen
		  <command>cvsup</command> aus <command>cron</command>
		  heraus laufen, um ihre Quellen automatisch auf Stand
		  zu bringen.  Sie müssen die obige Sup-Datei
		  anpassen und <link linkend="cvsup">cvsup</link><indexterm><primary>-CURRENT</primary><secondary>mit <application>CVSup</application> synchronisieren</secondary></indexterm>
		  in Ihrer Umgebung konfigurieren.</para>

		<note>
		  <para>Die <filename>standard-supfile</filename>-Beispieldatei
		    ist dafür vorgesehen, einen bestimmten
		    Sicherheitszweig zu verfolgen und nicht &os.current;.  Sie
		    müssen diese Datei bearbeiten und die folgende
		    Zeile:</para>

		  <programlisting>*default release=cvs tag=RELENG_<replaceable>X</replaceable>_<replaceable>Y</replaceable></programlisting>

                  <para>durch diese ersetzen:</para>

                  <programlisting>*default release=cvs tag=.</programlisting>

                  <para>Lesen Sie den Abschnitt über <link linkend="cvs-tags">CVS Tags</link> im Handbuch, um eine
                    genaue Beschreibung von verwendbaren Tags zu
                    erhalten.</para>
		</note>
	      </listitem>

	      <listitem>
		<para><application>CTM</application><indexterm><primary>-CURRENT</primary><secondary>mit CTM synchronisieren</secondary></indexterm>
		  kommt in Frage, wenn Sie
		  über eine schlechte Internet-Anbindung (hoher Preis
		  oder nur E-Mail Zugriff) verfügen.  Der Umgang mit
		  <application>CTM</application> ist allerdings recht
		  mühsam und Sie können beschädigte Dateien
		  erhalten.  Daher wird es selten benutzt, was wiederum
		  dazu führt, dass es über längere Zeit
		  nicht funktioniert.  Wir empfehlen jedem mit einem
		  9600&nbsp;bps oder schnellerem Modem,
		  <application>CVSup</application>
		  zu benutzen.</para>
	      </listitem>
	    </orderedlist>
	  </listitem>

	  <listitem>
	    <para>Wenn Sie die Quellen einsetzen und nicht nur darin
	      lesen wollen, besorgen Sie sich bitte die
	      <emphasis>kompletten</emphasis> Quellen von &os.current; und
	      nicht nur ausgesuchte Teile.  Der Grund hierfür ist,
	      dass die verschiedenen Teile der Quellen voneinander
	      abhängen.  Es ist ziemlich sicher, dass Sie in
	      Schwierigkeiten geraten, wenn Sie versuchen, nur einen Teil
	      der Quellen zu übersetzen.</para>

	    <para>Sehen Sie sich das <filename>Makefile</filename> in
	      <filename>/usr/src</filename> genau an, bevor Sie
	      &os.current; übersetzen<indexterm><primary>-CURRENT</primary><secondary>übersetzen</secondary></indexterm>.  Wenn Sie
	      &os; das erste Mal aktualisieren, sollten Sie sowohl
	      <link linkend="makeworld">einen Kernel als auch das
		System neu installieren</link>.
	      Lesen Sie bitte die Mailingliste &a.current;
	      und <filename>/usr/src/UPDATING</filename>, um über
	      Änderungen im Installationsverfahren, die manchmal
	      vor der Einführung eines neuen Releases notwendig sind,
	      informiert zu sein.</para>
	  </listitem>

	  <listitem>
	    <para>Seien Sie aktiv!  Wenn Sie &os.current; laufen lassen,
	      wollen wir wissen, was Sie darüber denken, besonders
	      wenn Sie Verbesserungsvorschläge oder Fehlerbehebungen
	      haben.  Verbesserungsvorschläge, die Code enthalten,
	      werden übrigens begeistert entgegengenommen.</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>

    <sect2 xml:id="stable">
      <title>&os.stable;</title>

      <sect3>
	<title>Was ist &os.stable;?</title>
	<indexterm><primary>-STABLE</primary></indexterm>

	<para>&os.stable; ist der Entwicklungszweig, auf dem Releases
	  erstellt werden.  Dieser Zweig ändert sich langsamer als
	  &os.current; und alle Änderungen hier sollten zuvor in
	  &os.current; ausgetestet sein.  Beachten Sie, dass dies
	  <emphasis>immer noch</emphasis> ein Entwicklungszweig ist und
	  daher zu jedem Zeitpunkt die Quellen von &os.stable; verwendbar
	  sein können oder nicht.  &os.stable; ist Teil des
	  Entwicklungsprozesses und nicht für Endanwender
	  gedacht.</para>
      </sect3>

      <sect3>
	<title>Wer braucht &os.stable;?</title>

	<para>Wenn Sie den FreeBSD-Entwicklungsprozess, besonders im
	  Hinblick auf das nächste Release, verfolgen oder
	  dazu beitragen wollen, sollten Sie erwägen, &os.stable; zu
	  benutzen.</para>

	<para>Auch wenn sicherheitsrelevante Fehlerbehebungen in den
	  &os.stable; Zweig einfließen, müssen Sie deswegen
	  noch lange nicht &os.stable; verfolgen.  Jeder der FreeBSD
	  Sicherheitshinweise beschreibt für jedes betroffene Release,
	  <footnote><para>Das stimmt nicht ganz.  Obwohl wir alte FreeBSD
	    Releases für einige Jahre unterstützen, können
	    wir sie nicht ewig unterstützen.  Eine vollständige
	    Beschreibung der Sicherheitspolitik für alte FreeBSD
	    Releases entnehmen Sie bitte <link xlink:href="&url.base;/security/">http://www.FreeBSD.org/security/</link>.</para>
	  </footnote>
	  wie sie einen sicherheitsrelevanten Fehler beheben.
	  Wenn Sie den Entwicklungszweig aus Sicherheitsgründen
	  verfolgen wollen, bedenken Sie, dass Sie neben
	  Fehlerbehebungen auch eine Vielzahl unerwünschter
	  Änderungen erhalten werden.</para>

	<para>Obwohl wir versuchen sicherzustellen, dass der
	  &os.stable; Zweig sich jederzeit übersetzen lässt
	  und läuft, können wir dafür keine Garantie
	  übernehmen.  Auch wenn Neuentwicklungen in &os.current;
	  stattfinden, ist es jedoch so, dass mehr Leute
	  &os.stable; benutzen als &os.current; und es daher unvermeidlich
	  ist, dass Fehler und Grenzfälle erst in &os.stable;
	  auffallen.</para>

	<para>Aus diesen Gründen empfehlen wir Ihnen
	  <emphasis>nicht</emphasis>, blindlings &os.stable; zu benutzen.
	  Es ist wichtig, dass Sie &os.stable; zuerst sorgfältig
	  in einer Testumgebung austesten, bevor Sie Ihre Produktion
	  auf &os.stable; migrieren.</para>

	<para>Wenn Sie dies nicht leisten können, empfehlen wir Ihnen,
	  das aktuelle FreeBSD-Release zu verwenden.  Benutzen Sie dann den
	  binären Update-Mechanismus, um auf neue Releases
	  zu migrieren.</para>
      </sect3>

      <sect3>
	<title>Benutzen von &os.stable;</title>

	<orderedlist>
	  <listitem>
	    <para>Lesen Sie Mailingliste &a.stable.name;, damit Sie über
	      Abhängigkeiten beim Bau von &os.stable;<indexterm><primary>-STABLE</primary><secondary>benutzen</secondary></indexterm> und Sachen, die
	      besondere Aufmerksamkeit erfordern, informiert sind.
	      Umstrittene Fehlerbehebungen oder Änderungen werden von
	      den Entwicklern auf dieser Liste bekannt gegeben.  Dies
	      erlaubt es den Benutzern, Einwände gegen die
	      vorgeschlagenen Änderungen vorzubringen.</para>

	    <para>Abonnieren Sie die passende
	      <application>SVN</application>-Liste für den jeweiligen
	      Branch, den Sie verfolgen.  Wenn Sie beispielsweise den Zweig
	      7-STABLE verfolgen, lesen Sie die &a.svn-src-stable-7.name;.
	      Dort sehen Sie zu jeder Änderung das Commit-Log, das
	      Informationen zu möglichen Seiteneffekten
	      enthält.</para>

	    <para>Um diese Listen oder andere Listen zu abonnieren
	      besuchen Sie bitte die Seite &a.mailman.lists.link;.
	      Weitere Informationen erhalten Sie, wenn Sie dort
	      auf die gewünschte Liste klicken.  Wenn Sie daran
	      interessiert sind, Änderungen am gesamten Quellbaum zu
	      verfolgen, dann empfehlen wir, dass Sie &a.svn-src-all.name;
	      abonnieren.</para>
	  </listitem>

	  <listitem>
	    <para>Wenn Sie ein neues System installieren und dazu einen
	      der monatlich aus &os.stable; erzeugten Snapshots verwenden
	      wollen, sollten Sie zuerst die <link xlink:href="&url.base;/../snapshots/">Snapshot Website</link> auf
	      aktuelle Informationen überprüfen.  Alternativ
	      können Sie auch das neueste &os.stable;-Release von
	      den <link linkend="mirrors">Spiegeln</link> beziehen
	      und Ihr System nach den folgenden Anweisungen
	      aktualisieren.</para>

	    <para>Wenn Sie schon ein älteres Release von &os;
	      und das System mit dem Quellcode aktualisieren wollen,
	      benutzen Sie einen der <link linkend="mirrors">&os;-Spiegel</link>.  Sie haben
	      dazu zwei Möglichkeiten:</para>

	    <orderedlist>
	      <listitem>
		<para>Benutzen Sie das Programm
		  <link linkend="cvsup">cvsup</link><indexterm><primary><command>cvsup</command></primary></indexterm>
		  mit der Datei <filename>stable-supfile</filename><indexterm><primary>-STABLE</primary><secondary>mit <application>CVSup</application> synchronisieren</secondary></indexterm>
		  aus dem Verzeichnis
		  <filename>/usr/share/examples/cvsup</filename>.
		  Dies ist die empfohlene Methode, da Sie die ganzen
		  Quellen nur einmal herunterladen und danach nur noch
		  Änderungen beziehen.  Viele lassen
		  <command>cvsup</command> aus <command>cron</command>
		  heraus laufen, um ihre Quellen automatisch auf Stand
		  zu bringen.  Sie müssen das oben erwähnte
		  <filename>supfile</filename> anpassen und <link linkend="cvsup">cvsup</link> konfigurieren.</para>
	      </listitem>

	      <listitem>
		<para>Benutzen Sie <application>
		    CTM</application><indexterm><primary>-STABLE</primary><secondary>mit CTM synchronisieren</secondary></indexterm>.  Wenn Sie über
		  keine schnelle und billige Internet-Anbindung
		  verfügen, sollten Sie diese Methode in Betracht
		  ziehen.</para>
	      </listitem>
	   </orderedlist>
	 </listitem>

	  <listitem>
	    <para>Benutzen Sie <command>cvsup</command> oder
	      <command>ftp</command>, wenn Sie schnellen Zugriff auf die
	      Quellen brauchen und die Bandbreite keine Rolle spielt,
	      andernfalls benutzen Sie
	      <application>CTM</application>.</para>
	  </listitem>

	  <listitem>
	    <para>Bevor Sie &os.stable; übersetzen<indexterm><primary>-STABLE</primary><secondary>übersetzen</secondary></indexterm>, sollten Sie sich
	      das <filename>Makefile</filename> in
	      <filename>/usr/src</filename> genau anschauen.  Wenn Sie
	      &os; das erste Mal aktualisieren, sollten Sie sowohl
	      <link linkend="makeworld">einen Kernel als auch das
		System neu installieren</link>.
	      Lesen Sie bitte die Mailingliste &a.stable;
	      und <filename>/usr/src/UPDATING</filename>, um über
	      Änderungen im Installationsverfahren, die manchmal
	      vor der Einführung eines neuen Releases notwendig sind,
	      informiert zu sein.</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="synching">
    <title>Synchronisation der Quellen</title>

    <para>Sie können eine Internet-Verbindung (oder E-Mail) dazu
      nutzen, Teile von &os;, wie die Quellen zu einzelnen Projekten, oder
      das Gesamtsystem, aktuell zu halten.  Dazu bieten wir die Dienste
      <link linkend="anoncvs">AnonymousCVS</link>,
      <link linkend="cvsup">CVSup</link> und
      <link linkend="ctm">CTM</link> an.</para>

    <warning>
      <para>Obwohl es möglich ist, nur Teile des Quellbaums zu
        aktualisieren, ist die einzige unterstütze Migrationsprozedur,
	den kompletten Quellbaum zu aktualisieren und alles, das
	heißt das Userland (z.B. alle Programme in
	<filename>/bin</filename> und <filename>/sbin</filename>) und die
	Kernelquellen, neu zu übersetzen.  Wenn Sie nur einen Teil der
	Quellen, zum Beispiel nur den Kernel oder nur die Programme aus dem
	Userland, aktualisieren, werden Sie oft Probleme haben, die von
	Übersetzungsfehlern über Kernel-Panics bis hin zu
	Beschädigungen Ihrer Daten reichen können.</para>
    </warning>

    <indexterm>
      <primary>CVS</primary>
      <secondary>anonymous</secondary>
    </indexterm>

    <para><application>Anonymous CVS</application> und
      <application>CVSup</application> benutzen die
      <foreignphrase>Pull</foreignphrase>-Methode
      <footnote>
	<para>Von engl. <foreignphrase>to pull</foreignphrase> =
	  <emphasis>ziehen</emphasis>.  Der Client holt sich bei dieser
	  Methode die Dateien ab.</para>
      </footnote>, um die Quellen zu aktualisieren.  Im Fall von
      <application>CVSup</application> ruft der Benutzer oder ein
      <command>cron</command>-Skript <command>cvsup</command> auf, das
      wiederum mit einem <command>cvsupd</command> Server interagiert, um
      Ihre Quellen zu aktualisieren.  Mit beiden Methoden erhalten Sie
      aktuelle Updates zu einem genau von Ihnen bestimmten Zeitpunkt.  Sie
      können die Prozedur auf bestimmte Dateien oder Verzeichnisse
      einschränken, so dass Sie nur die Updates bekommen, die
      für Sie von Interesse sind.  Die Updates werden zur Laufzeit,
      abhängig von den Sachen, die Sie schon haben und den Sachen, die
      Sie haben wollen, auf dem Server generiert.  <application>Anonymous
        CVS</application> ist eine Erweiterung von
      <application>CVS</application>, die es Ihnen erlaubt, Änderungen
      direkt aus einem entfernten CVS-Repository zu ziehen.
      <application>Anonymous CVS</application> ist leichter zu handhaben
      als <application>CVSup</application>, doch ist letzteres sehr viel
      effizienter.</para>

    <indexterm>
      <primary><application>CTM</application></primary>
    </indexterm>
    <para>Im Gegensatz dazu vergleicht <application>CTM</application> Ihre
      Quellen nicht mit denen auf einem Server.  Stattdessen läuft auf
      dem Server ein Skript, das Änderungen an Dateien gegenüber
      seinem vorigen Lauf bemerkt, die Änderungen komprimiert, mit
      einer Sequenznummer versieht und für das Verschicken per E-Mail
      kodiert (es werden nur druckbare ASCII-Zeichen verwendet).  Wenn Sie
      diese <quote>CTM-Deltas</quote> erhalten haben, können Sie sie
      mit &man.ctm.rmail.1; benutzen, welches die Deltas dekodiert,
      verifiziert und dann die Änderungen an Ihren Quellen vornimmt.
      Dieses Verfahren ist viel effizienter als
      <application>CVSup</application> und erzeugt auch weniger Last auf
      unseren Servern, da es die
      <foreignphrase>Push</foreignphrase>-Methode
      <footnote>
	<para>Von engl. <foreignphrase>to push</foreignphrase> =
	  <emphasis>schieben</emphasis>.  Der Server schickt dem Client die
	  Dateien.</para>
      </footnote> verwendet.</para>

    <para>Es gibt natürlich noch weitere Unterschiede, die Sie
      beachten sollten.  Wenn Sie unabsichtlich Teile Ihres Archivs
      löschen, wird das von <application>CVSup</application>
      wie <application>Anonymous CVS</application> erkannt
      und repariert.  Wenn sich fehlerhafte Dateien in Ihrem Quellbaum
      befinden, löschen Sie diese einfach und synchronisieren erneut.
      <application>CTM</application> leistet das nicht,
      wenn Sie Teile des Quellbaums gelöscht haben und keine Sicherung
      besitzen, müssen Sie von neuem, das heißt vom letzten
      <quote>Basis-Delta</quote>, starten und die Änderungen wieder
      mit <application>CTM</application> nachziehen.</para>
  </sect1>

  <sect1 xml:id="makeworld">
    <title>Das komplette Basissystem neu bauen</title>

    <indexterm>
      <primary>Bau des Basissystems</primary>
    </indexterm>

    <para>Wenn Sie Ihren lokalen Quellbaum mit einer bestimmten FreeBSD
      Version (&os.stable;, &os.current;, usw.) synchronisiert haben,
      können Sie diesen benutzen, um das System neu zu
      bauen.</para>

    <warning>
      <title>Erstellen Sie eine Sicherungskopie!</title>

      <para>Es kann nicht oft genug betont werden, wie wichtig es ist, Ihr
        System zu sichern, <emphasis>bevor</emphasis> Sie die nachfolgenden
	Schritte ausführen.  Obwohl der Neubau des Systems eine
	einfache Aufgabe ist, wenn Sie sich an die folgende Anleitung
	halten, kann es dennoch vorkommen, dass Sie einen Fehler machen,
	oder dass Ihr System nicht mehr bootet, weil andere Entwickler
	Fehler in den Quellbaum eingeführt haben.</para>

      <para>Stellen Sie sicher, dass Sie eine Sicherung erstellt haben
        und über eine Fixit-Floppy oder eine startfähige CD
	verfügen.  Wahrscheinlich werden Sie die Startmedien
	nicht benötigen, aber gehen Sie auf Nummer sicher!</para>
    </warning>

    <warning>
      <title>Abonnieren Sie die richtige Mailingliste</title>

      <indexterm><primary>Mailingliste</primary></indexterm>
      <para>Die &os.stable; und &os.current; Zweige befinden sich in
        <emphasis>ständiger Entwicklung</emphasis>.  Die Leute, die zu
	&os; beitragen, sind Menschen und ab und zu machen sie
	Fehler.</para>

      <para>Manchmal sind diese Fehler harmlos und lassen Ihr System eine
        Warnung ausgeben.  Die Fehler können allerdings auch
	katastrophal sein und dazu führen, dass Sie Ihr System
	nicht mehr booten können, Dateisysteme beschädigt
	werden oder Schlimmeres passiert.</para>

      <para>Wenn solche Probleme auftauchen, wird ein
	<quote>heads up</quote> an die passende Mailingliste geschickt, welches
	das Problem erklärt und die betroffenen Systeme benennt.  Eine
	<quote>all clear</quote> Meldung wird versendet, wenn das
	Problem gelöst ist.</para>

      <para>Wenn Sie &os.stable; oder &os.current; benutzen und nicht die
        Mailinglisten &a.stable; beziehungsweise &a.current; lesen, bringen
	Sie sich nur unnötig in Schwierigkeiten.</para>
    </warning>

    <warning>
      <title>Finger weg von <command>make world</command></title>

      <para>Ältere Dokumentationen empfehlen, das Kommando
	<command>make world</command> für den Neubau.
	Das Kommando überspringt wichtige Schritte.  Setzen
	Sie es nur ein, wenn Sie wissen was Sie tun.  In fast
	allen Fällen ist <command>make world</command>
	falsch, benutzen Sie stattdessen die nachstehende
	Anleitung.</para>
    </warning>

    <sect2 xml:id="canonical-build">
      <title>Richtig aktualisieren</title>

      <para>Um Ihr System zu aktualisieren, sollten Sie zuerst
	<filename>/usr/src/UPDATING</filename> lesen, und
	eventuelle, für Ihre Quellcodeversion nötigen
	Aufgaben erledigen, bevor Sie das System bauen.  Danach
	aktualisieren Sie Ihr System mit den folgenden
	Schritten.</para>

      <para>Bei den hier dargestellten Aktualisierungsschritten wird davon
        ausgegangen, dass Sie momentan eine alte &os;-Version verwenden, die
        aus einem alten Compiler, Kernel, sowie einem alten Basissystem und
        veralteten Konfigurationsdateien besteht.  Mit
        <quote>Basissystem</quote> sind hier die zentralen Binärdateien,
        Bibliotheken und Entwicklerdateien gemeint.  Der Compiler ist Teil
        des <quote>Basissystems</quote>, beinhaltet aber ein paar
        Besonderheiten.</para>

      <para>Es wird ausserdem davon ausgegangen, dass Sie bereits die Quellen
        für ein neues System bezogen haben.  Falls die Quellen in dem
        vorliegenden System zu alt sind, lesen Sie <xref linkend="synching"/>,
        um detaillierte Hilfe über die Aktualisierung der Quellen zu
        erhalten.</para>

      <para>Die Aktualisierung des Systems aus den Quellen ist ein wenig
        ausgetüftelter als es zunächst den Anschein hat. Die
        Entwickler von &os; haben es über die Jahre für Nötig
        befunden, den vorgeschlagenen Ablauf ziemlich stark zu
        verändern, da neue Arten von unvermeidlichen Abhängigkeiten
        mit der Zeit ans Licht kamen.  Der übrige Teil dieses Abschnitts
        beschreibt die Überlegungen hinter der aktuell empfohlenen
        Aktualisierungsreihenfolge.</para>

      <para>Jede erfolgreiche Aktualisierung muss sich mit den folgenden
        Sachverhalten auseinandersetzen:</para>

      <itemizedlist>
        <listitem>
          <para>Der alte Compiler ist möglicherweise nicht in der Lage,
            den neuen Kernel zu übersetzen (alte Compiler besitzen
            manchmal Fehler).  Deshalb sollte der neue Kernel mit dem neuen
            Compiler übersetzt werden.  Ganz besonders muss darauf
            geachtet werden, dass der neue Compiler vor dem neuen Kernel
            gebaut wird.  Das bedeutet nicht unbedingt, dass der neue
            Compiler auch <emphasis>installiert</emphasis> werden muss, bevor
            der neue Kernel gebaut wird.</para>
        </listitem>

        <listitem>
          <para>Das neue Basissystem benötigt eventuell neue
            Eigenschaften des Kernels. Also muss der neue Kernel installiert
            sein, bevor das neue Basissystem installiert wird.</para>
        </listitem>
      </itemizedlist>

      <para>Diese ersten beiden Sachverhalte sind die Grundlage für die
        zentrale Sequenz von <buildtarget>buildworld</buildtarget>,
        <buildtarget>buildkernel</buildtarget>,
        <buildtarget>installkernel</buildtarget> und
        <buildtarget>installworld</buildtarget>, die in den folgenden
        Abschnitten beschrieben wird.  Dies ist keine vollständige Liste
        all der Gründe, warum Sie den aktuell empfohlenen Prozess der
        Aktualisierung bevorzugen sollten.  Ein paar der weniger
        naheliegenden Gründe sind im folgenden aufgezählt:</para>

     <itemizedlist>
       <listitem>
         <para>Das alte Basissystem wird möglicherweise nicht korrekt
           mit dem neuen Kernel funktionieren, weshalb Sie das neue
           Basissystem sofort nach der Installation des neuen Kernels
           installieren müssen.</para>
       </listitem>

       <listitem>
  	 <para>Manche Änderungen an der Konfiguration müssen
  	   erledigt worden sein, bevor das neue Basissystem installiert wird,
  	   jedoch können andere die Funktionalität des alten
  	   Basissystems beeinträchtigen.  Aus diesem Grund sind zwei
  	   verschiedene Schritte notwendig, um eine Aktualisierung der
  	   Konfiguration durchzuführen.</para>
       </listitem>

       <listitem>
         <para>Der Aktualisierungsprozess ersetzt zum Grossteil Dateien oder
           fügt neue hinzu, bestehende Dateien werden nicht
           gelöscht.  In wenigen Ausnahmefällen kann dies Probleme
           verursachen.  Aus diesem Grund wird der Aktualisierungsprozess
           manchmal bestimmte Dateien zum manuellen Löschen vorschlagen.
           Dies wird eventuell in der Zukunft automatisch
           durchgeführt.</para>
       </listitem>
     </itemizedlist>

     <para>Diese Bedenken haben zu der folgenden Reihenfolge geführt.
       Beachten Sie, dass der genaue Ablauf für bestimmte
       Aktualisierungen zusätzliche Schritte nach sich zieht, jedoch
       sollte der Kernprozess davon nicht beeinträchtigt werden:</para>

     <orderedlist>
       <listitem>
         <para><command>make
           buildworld</command></para>

         <para>Dieser Schritt übersetzt zuerst den neuen Compiler und
           ein paar damit zusammenhängende Werkzeuge und verwendet dann
           den neuen Compiler, um den Rest des Basissystems zu erstellen.
           Das Ergebnis landet dann in <filename>/usr/obj</filename>.</para>
       </listitem>

       <listitem>
         <para><command>make
           buildkernel</command></para>

         <para>Statt dem alten Ansatz, &man.config.8; und
           &man.make.1; zu verwenden, nutzt dieser den
           <emphasis>neuen</emphasis> Compiler, der in <filename>/usr/obj</filename> abgelegt ist.
           Das schützt Sie vor falschen
           Compiler-Kernel-Kombinationen.</para>
       </listitem>

       <listitem>
         <para><command>make
           installkernel</command></para>

         <para>Platziert den neuen Kernel und Kernelmodule auf der Platte,
           was es erlaubt, mit dem frisch aktualisierten Kernel zu
           starten.</para>
       </listitem>

       <listitem>
         <para>Starten Sie das System neu in den Single-User-Modus.</para>

         <para>Der Single-User-Modus minimiert Probleme mit der
           Aktualisierung von Programmen, die bereits gestartet sind.  Ebenso
           minimiert es Probleme, die mit der Verwendung des alten
           Basissystems und des neuen Kernels zu tun haben
           könnten.</para>
       </listitem>

       <listitem>
         <para><command>mergemaster -p</command></para>

         <para>Dieser Schritt aktualisiert ein paar initiale
           Konfigurationsdateien als Vorbereitung für das neue
           Basissystem.  Beispielsweise fügt es neue Benutzergruppen
           zum System oder neue Benutzernamen in die Passwortdatenbank hinzu.
           Dies wird oftmals benötigt, wenn neue Gruppen oder bestimmte
           Systembenutzerkonten seit der letzten Aktualisierung hinzu gekommen
           sind, so dass der <buildtarget>installworld</buildtarget>-Schritt
           in der Lage ist, auf dem neu installierten System die Benutzer
           oder Systemgruppennamen ohne Probleme zu verwenden.</para>
       </listitem>

       <listitem>
         <para><command>make
           installworld</command></para>

         <para>Kopiert das Basissystem aus <filename>/usr/obj</filename>.  Sie haben jetzt den
           neuen Kernel und das neue Basissystem auf der Festplatte.</para>
       </listitem>

       <listitem>
         <para><command>mergemaster</command></para>

         <para>Sie können nun die verbleibenden Konfigurationsdateien
           aktualisieren, da Sie nun das neue Basissystem auf der Platte
           haben.</para>
       </listitem>

       <listitem>
         <para>Starten Sie das System neu.</para>

         <para>Ein kompletter Systemneustart ist notwendig, um den neuen
           Kernel und das neue Basissystem mit den neuen
           Konfigurationsdateien zu laden.</para>
       </listitem>
      </orderedlist>

      <para>Beachten Sie, dass wenn Sie von einem Release des gleichen
        &os;-Zweigs auf ein aktuelleres Release des gleichen Zweigs, z.B.
        von 7.0 auf 7.1, aktualisieren, dann ist diese Vorgehensweise nicht
        unbedingt notwendig, da Sie nur sehr unwahrscheinlich in
        ungünstige Kombinationen zwischen Compiler, Kernel, Basissystem
        und den Konfigurationsdateien geraten werden.  Die ältere
        Vorgehensweise von <command>make
        world</command>, gefolgt von der Erstellung
        und Installation des neuen Kernels funktioniert möglicherweise
        gut genug, um kleinere Aktualisierungen vorzunehmen.</para>

      <para>Wenn Sie allerdings zwischen Hauptversionen aktualisieren wollen
        und befolgen diese Schritte nicht, sollten Sie sich auf Probleme
        gefasst machen.</para>

      <para>Es ist auch wichtig zu wissen, dass viele Aktualisierungen, z.B.
        von 4.<replaceable>X</replaceable> auf 5.0, viele spezielle und
        zusätzliche Schritte benötigt, wie beispielsweise das
        umbennen oder löschen von speziellen Dateien vor installworld.
        Lesen Sie die Datei <filename>/usr/src/UPDATING</filename>
        gründlich, besonders am Ende, wo die aktuell vorgeschlagene
        Aktualisierungssequenz explizit aufgelistet ist.</para>

      <para>Diese Prozedur hat sich mit der Zeit weiterentwickelt, da die
        Entwickler es für unmöglich erachtet haben, bestimmte
        Arten von Kombinationsproblemen vollständig auszuschliessen.
        Hoffentlich wird die aktuelle Aktualisierungsprozedur für lange
        Zeit stabil bleiben.</para>

      <para>Als Zusammenfassung ist hier nochmal die aktuell vorgeschlagene
        Vorgehensweise für die Aktualisierung von &os; aus den Quellen
        aufgelistet:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput>
&prompt.root; <userinput>make installkernel</userinput>
&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <note>
	<para>Es gibt einige, sehr seltene Situationen, in denen Sie
	  <command>mergemaster -p</command> zusätzlich
	  ausführen müssen, bevor Sie das System mit
	  <buildtarget>buildworld</buildtarget> bauen.  Diese Situationen
	  werden in <filename>UPDATING</filename> beschrieben.  Solche
	  Situationen treten aber in der Regel nur dann auf, wenn Sie
	  Ihr &os;-System um eine oder mehrere Hauptversionen
	  aktualisieren.</para>
      </note>

      <para>Nachdem <buildtarget>installkernel</buildtarget> erfolgreich
	abgeschlossen wurde, starten Sie das System im Single-User-Modus
	(etwa durch die Eingabe von <command>boot -s</command> am
	Loaderprompt).  Danach führen Sie die folgenden Anweisungen
	aus:</para>

      <screen>&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>adjkerntz -i</userinput>
&prompt.root; <userinput>mergemaster -p</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput>
&prompt.root; <userinput>mergemaster</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <warning>
	<title>Lesen Sie bitte weiter</title>

	<para>Die obige Vorschrift ist nur eine
	  Gedächtnisstütze.  Um die einzelnen
	  Schritte zu verstehen, lesen Sie bitte die
	  folgenden Abschnitte, insbesondere wenn Sie
	  einen angepassten Kernel erstellen.</para>
      </warning>
    </sect2>

    <sect2 xml:id="src-updating">
      <title>Lesen Sie <filename>/usr/src/UPDATING</filename></title>

      <para>Bevor Sie etwas anderes tun, lesen Sie bitte
        <filename>/usr/src/UPDATING</filename> (oder die entsprechende
	Datei, wenn Sie den Quellcode woanders installiert haben).  Die
	Datei enthält wichtige Informationen zu Problemen, auf die Sie
	stoßen könnten oder gibt die Reihenfolge vor, in der Sie
	bestimmte Kommandos laufen lassen müssen.  Die Anweisungen in
	<filename>UPDATING</filename> sind aktueller als die in diesem
	Handbuch.  Im Zweifelsfall folgen Sie bitte den Anweisungen aus
	<filename>UPDATING</filename>.</para>

      <important>
	<para>Das Lesen von <filename>UPDATING</filename> ersetzt nicht das
	  Abonnieren der richtigen Mailingliste.  Die beiden Voraussetzungen
	  ergänzen sich, es reicht nicht aus, nur eine zu
	  erfüllen.</para>
      </important>
    </sect2>

    <sect2 xml:id="make-conf">
      <title>Überprüfen Sie
	<filename>/etc/make.conf</filename></title>
      <indexterm>
        <primary><filename>make.conf</filename></primary>
      </indexterm>

      <para>Überprüfen Sie die Dateien
	<filename>/usr/share/examples/etc/make.conf</filename>
	und <filename>/etc/make.conf</filename>.  Die erste enthält
	Vorgabewerte, von denen die meisten auskommentiert sind.  Um diese
	während des Neubaus des Systems zu nutzen, tragen Sie die
	Werte in <filename>/etc/make.conf</filename> ein.  Beachten Sie,
	dass alles, was Sie in <filename>/etc/make.conf</filename>
	eintragen, bei jedem Aufruf von <command>make</command> angezogen
	wird.  Es ist also klug, hier etwas Sinnvolles einzutragen.</para>

      <para>Typischerweise wollen Sie die Zeilen, die
        <varname>CFLAGS</varname> und <varname>NO_PROFILE</varname>
	enthalten, aus
	<filename>/usr/share/examples/etc/make.conf</filename>
	nach <filename>/etc/make.conf</filename> übertragen und dort
	aktivieren.</para>

      <para>Sehen Sie sich auch die anderen Definitionen, wie
        <varname>COPTFLAGS</varname> oder <varname>NOPORTDOCS</varname> an
	und entscheiden Sie, ob Sie diese aktivieren wollen.</para>
    </sect2>

    <sect2 xml:id="updating-etc">
      <title>Aktualisieren Sie die Dateien in <filename>/etc</filename></title>

      <para>Das Verzeichnis <filename>/etc</filename> enthält den
        Großteil der Konfigurationsdateien des Systems und Skripten,
	die beim Start des Systems ausgeführt werden.  Einige dieser
	Skripten ändern sich bei einer Migration auf eine neue
	FreeBSD-Version.</para>

      <para>Einige der Konfigurationsdateien, besonders
        <filename>/etc/group</filename>, werden für den Normalbetrieb
	des Systems gebraucht.</para>

      <para>Es gab Fälle, in denen das Kommando
        <command>make installworld</command> auf bestimmte
	Accounts oder Gruppen angewiesen war, die aber während
	der Aktualisierung fehlten.  Demzufolge kam es zu Problemen
	bei der Aktualisierung.  In einigen Fällen prüft
	<command>make buildworld</command> ob die Accounts oder
	Gruppen vorhanden sind.</para>

      <para>Ein Beispiel dafür trat beim Anlegen des Benutzers
	<systemitem class="username">smmsp</systemitem> auf.  Die Installationsprozedur
	schlug an der Stelle fehl, an der &man.mtree.8;
	versuchte, <filename>/var/spool/clientmqueue</filename>
	anzulegen.</para>

      <para>Um dieses Problem zu umgehen,rufen Sie &man.mergemaster.8;
	prä-buildworld-Modus auf, der mit <option>-p</option> aktiviert
	wird.  In diesem Modus werden nur Dateien verglichen, die für
	den Erfolg von <buildtarget>buildworld</buildtarget> oder
	<buildtarget>installworld</buildtarget> essentiell sind.</para>

      <tip>
	<para>Wenn Sie besonders paranoid sind, sollten Sie Ihr System nach
	  Dateien absuchen, die der Gruppe, die Sie umbenennen oder
	  löschen, gehören:</para>

	<screen>&prompt.root; <userinput>find / -group GID -print</userinput></screen>

	<para>Das obige Kommando zeigt alle Dateien an, die der Gruppe
	  <replaceable>GID</replaceable> (dies kann entweder ein
	  Gruppenname oder eine numerische ID sein) gehören.</para>
      </tip>
    </sect2>

    <sect2 xml:id="makeworld-singleuser">
      <title>Wechseln Sie in den Single-User-Modus</title>
      <indexterm><primary>Single-User-Modus</primary></indexterm>

      <para>Sie können das System im Single-User-Modus
        übersetzen.  Abgesehen davon, dass dies etwas schneller
	ist, werden bei der Installation des Systems viele wichtige Dateien,
	wie die Standard-Systemprogramme, die Bibliotheken und
	Include-Dateien, verändert.  Sie bringen sich in
	Schwierigkeiten, wenn Sie diese Dateien auf einem laufenden System
	verändern, besonders dann, wenn zu dieser Zeit Benutzer auf
	dem System aktiv sind.</para>

      <indexterm><primary>Mehrbenutzermodus</primary></indexterm>
      <para>Eine andere Methode übersetzt das System im
        Mehrbenutzermodus und wechselt für die Installation in den
	Single-User-Modus.  Wenn Sie diese Methode benutzen wollen, warten
	Sie mit den folgenden Schritten, bis der Bau des Systems fertig
	ist und Sie mit <buildtarget>installkernel</buildtarget> oder
	<buildtarget>installworld</buildtarget> installieren wollen.</para>

      <para>Als Superuser können Sie mit dem folgenden Kommando ein
        laufendes System in den Single-User-Modus bringen:</para>

      <screen>&prompt.root; <userinput>shutdown now</userinput></screen>

      <para>Alternativ können Sie das System mit der Option
        <quote>single user</quote> in den Single-User-Modus booten.
	Danach geben Sie die folgenden Befehle ein:</para>

      <screen>&prompt.root; <userinput>fsck -p</userinput>
&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

      <para>Die Kommandos überprüfen die Dateisysteme,
        hängen <filename>/</filename> wieder beschreibbar ein,
	hängen dann alle anderen UFS Dateisysteme aus
	<filename>/etc/fstab</filename> ein und aktivieren den
	Swap-Bereich.</para>

        <note>
	  <para>Zeigt Ihre CMOS-Uhr die lokale Zeit und nicht GMT an, dies
	    erkennen Sie daran, dass &man.date.1; die
	    falsche Zeit und eine falsche Zeitzone anzeigt, setzen Sie das
	    folgende Kommando ab:</para>
<screen>&prompt.root; <userinput>adjkerntz -i</userinput></screen>

	  <para>Dies stellt sicher, dass Ihre Zeitzone richtig
	    eingestellt ist.  Ohne dieses Kommando werden Sie
	    vielleicht später Probleme bekommen.</para>
        </note>

    </sect2>

    <sect2 xml:id="cleaning-usr-obj">
      <title>Entfernen Sie <filename>/usr/obj</filename></title>

      <para>Die neu gebauten Teile des Systems werden in der Voreinstellung
        unter <filename>/usr/obj</filename> gespeichert.  Die Verzeichnisse
	dort spiegeln die Struktur unter
	<filename>/usr/src</filename>.</para>

      <para>Sie können den <command>make buildworld</command> Prozess
        beschleunigen, indem Sie dieses Verzeichnis entfernen.  Dies
	erspart Ihnen zudem einigen Ärger aufgrund von
	Abhängigkeiten.</para>

      <para>Einige Dateien unter <filename>/usr/obj</filename> sind
        vielleicht durch die <option>immutable</option>-Option
	(siehe &man.chflags.1;) schreibgeschützt, die vor dem
	Löschen entfernt werden muss.</para>

      <screen>&prompt.root; <userinput>cd /usr/obj</userinput>
&prompt.root; <userinput>chflags -R noschg *</userinput>
&prompt.root; <userinput>rm -rf *</userinput></screen>
    </sect2>

    <sect2 xml:id="updating-upgrading-compilebase">
      <title>Übersetzen der Quellen des Basissystems</title>

      <sect3>
	<title>Sichern der Ausgaben</title>

	<para>Für den Fall, dass etwas schief geht, sollten Sie
	  die Ausgaben von &man.make.1; in einer Datei sichern, damit Sie
	  eine Kopie der Fehlermeldung besitzen.  Das mag Ihnen nicht
	  helfen, den Fehler zu finden, kann aber anderen helfen, wenn Sie
	  Ihr Problem in einer der &os;-Mailinglisten schildern.</para>

	<para>Dazu können Sie einfach das Kommando &man.script.1;
	  benutzen, dem Sie beim Aufruf als Parameter den Dateinamen
	  für die Ausgaben mitgeben.  Setzen Sie das Kommando
	  unmittelbar vor dem Neubau ab und geben Sie
	  <userinput>exit</userinput> ein, wenn der Bau abgeschlossen
	  ist:</para>

	<screen>&prompt.root; <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out
&prompt.root; <userinput>make TARGET</userinput>
<emphasis>&hellip; Ausgaben des Kommandos &hellip;</emphasis>
&prompt.root; <userinput>exit</userinput>
Script done, &hellip;</screen>

	<para>Sichern Sie die Ausgaben nicht in <filename>/tmp</filename>,
	  da dieses Verzeichnis beim nächsten Boot aufgeräumt
	  werden kann.  Ein geeigneteres Verzeichnis ist
	  <filename>/var/tmp</filename>, wie im vorigen Beispiel gezeigt,
	  oder das Heimatverzeichnis von <systemitem class="username">root</systemitem>.</para>
      </sect3>

      <sect3 xml:id="make-buildworld">
	<title>Übersetzen des Basissystems</title>

	<para>Wechseln Sie in das Verzeichnis, in dem die Quellen liegen
	  (in der Voreinstellung ist das
	  <filename>/usr/src</filename>):</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>

	<indexterm><primary><command>make</command></primary></indexterm>

	<para>Zum Neubau der Welt benutzen Sie &man.make.1;.  Dieses
	  Kommando liest ein <filename>Makefile</filename>, das Anweisungen
	  enthält, wie die Programme, aus denen &os; besteht, zu bauen
	  sind und in welcher Reihenfolge diese zu bauen sind.</para>

	<para>Ein typischer Aufruf von <command>make</command> sieht wie
	  folgt aus:</para>

	<screen>&prompt.root; <userinput>make -x -DVARIABLE target</userinput></screen>

	<para>In diesem Beispiel ist
	  <option>-<replaceable>x</replaceable></option> eine Option, die
	  Sie an &man.make.1; weitergeben wollen.  Eine Liste gültiger
	  Optionen finden Sie in der &man.make.1; Manualpage.</para>

	<para>Das Verhalten eines <filename>Makefile</filename>s wird von
	  Variablen bestimmt.  Mit
	  <option>-D<replaceable>VARIABLE</replaceable></option> setzen Sie
	  eine Variable.  Diese Variablen sind dieselben, die auch in
	  <filename>/etc/make.conf</filename> gesetzt werden, dies ist nur
	  ein alternativer Weg, Variablen zu setzen.</para>

	<para>Um zu verhindern, dass die <quote>profiled</quote>
	  Bibliotheken gebaut werden, rufen Sie <command>make</command> wie
	  folgt auf:</para>
	<screen>&prompt.root; <userinput>make -DNO_PROFILE target</userinput></screen>

	<para>Dieser Aufruf entspricht dem folgenden Eintrag in
	  <filename>/etc/make.conf</filename>:</para>

	<programlisting>NO_PROFILE=    true     #    Avoid compiling profiled libraries</programlisting>

	<para>Jedes <filename>Makefile</filename> definiert einige
	  <quote>Ziele</quote>, die festlegen, was genau zu tun ist.  Mit
	  <replaceable>target</replaceable> wählen Sie eins dieser
	  Ziele aus.</para>

	<para>Einige Ziele im <filename>Makefile</filename> sind nicht
	  für den Endanwender gedacht, sondern unterteilen den
	  Bauprozess in eine Reihe von Einzelschritten.</para>

	<para>Im Regelfall müssen Sie &man.make.1; keine Parameter
	  mitgeben, so dass Ihre Kommandozeile wie folgt aussehen
	  wird:</para>

	<screen>&prompt.root; <userinput>make target</userinput></screen>

	<para><replaceable>target</replaceable> steht dabei für
	  die verschiedenen Ziele.  Das erste Ziel sollte immer
	  <varname>buildworld</varname> sein.</para>

	<para>Mit <buildtarget>buildworld</buildtarget> wird ein kompletter
	  Baum unterhalb von <filename>/usr/obj</filename> gebaut, der mit
	  <buildtarget>installworld</buildtarget>, einem weiteren Ziel, auf
	  dem System installiert werden kann.</para>

	<para>Über separate Optionen zu verfügen, ist aus
	  mehreren Gründen nützlich.  Erstens
	  können Sie das System auf einem laufenden System bauen, da die
	  Bauprozedur abgekapselt vom Rest des Systems ist.  Das System
	  lässt sich im Mehrbenutzermodus ohne negative
	  Seiteneffekte bauen.  Die Installation mit
	  <buildtarget>installworld</buildtarget> sollte aber immer noch im
	  Single-User-Modus erfolgen.</para>

	<para>Zweitens können Sie NFS benutzen, um mehrere Maschinen
	  in Ihrem Netzwerk zu aktualisieren.  Wenn Sie die Maschinen
	  <systemitem>A</systemitem>, <systemitem>B</systemitem> und <systemitem>C</systemitem>
	  aktualisieren wollen, lassen sie <command>make
	    buildworld</command> und <command>make installworld</command> auf
	  <systemitem>A</systemitem> laufen.  Auf den Maschinen <systemitem>B</systemitem>
	  und <systemitem>C</systemitem> können Sie die
	  Verzeichnisse <filename>/usr/src</filename> und
	  <filename>/usr/obj</filename> von <systemitem>A</systemitem> einhängen
	  und brauchen dort nur noch <command>make installworld</command>
	  auszuführen, um die Bauresultate zu installieren.</para>

	<para>Obwohl das Ziel <buildtarget>world</buildtarget> noch
	  existiert, sollten Sie es wirklich nicht mehr benutzen.</para>

	<para>Um das System zu bauen, setzen Sie das folgende Kommando
	  ab:</para>

	<screen>&prompt.root; <userinput>make buildworld</userinput></screen>

	<para>Mit <option>-j</option> können Sie
	  <command>make</command> anweisen, mehrere Prozesse zu starten.
	  Besonders effektiv ist das auf Mehrprozessor-Systemen.  Da aber
	  der Übersetzungsprozess hauptsächlich von IO statt
	  der CPU bestimmt wird, ist diese Option auch auf
	  Einprozessor-Systemen nützlich.</para>

	<para>Auf einem typischen Einprozessor-System können Sie den
	  folgenden Befehl absetzen:</para>

	<screen>&prompt.root; <userinput>make -j4 buildworld</userinput></screen>

	<para>&man.make.1; wird dann bis zu vier Prozesse gleichzeitig
	  laufen lassen.  Erfahrungsberichte aus den Mailinglisten zeigen,
	  dass dieser Aufruf typischerweise den besten
	  Geschwindigkeitsgewinn bringt.</para>

	<para>Wenn Sie ein Mehrprozessor-System besitzen und SMP in Ihrem
	  Kernel konfiguriert ist, probieren Sie Werte zwischen 6 und 10
	  aus.</para>
      </sect3>

      <sect3>
	<title>Laufzeiten</title>
	<indexterm>
	  <primary>Bau des Basissystems</primary>
	  <secondary>Laufzeiten</secondary>
	</indexterm>

	<para>Die Laufzeit eines Baus wird von vielen Faktoren
	  beeinflusst, ein aktuelles System benötigt aber etwa
	  zwei Stunden um &os.stable; zu bauen.  Der Bau von
	  &os.current; dauert etwas länger.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="new-kernel">
      <title>Übersetzen und Installation des Kernels</title>
      <indexterm>
        <primary>Kernel</primary>
	<secondary>Übersetzen</secondary>
      </indexterm>

      <para>Um das Beste aus Ihrem System zu holen, sollten Sie einen neuen
	Kernel kompilieren.  Praktisch gesehen ist das sogar notwendig, da
	sich einige Datenstrukturen geändert haben und Programme wie
	&man.ps.1; oder &man.top.1; nur mit einem Kernel zusammen arbeiten,
	der auch zu dem entsprechenden Quellcode passt.</para>

      <para>Am einfachsten und sichersten bauen Sie dazu den
        <filename>GENERIC</filename> Kernel.  Obwohl der
        <filename>GENERIC</filename> Kernel vielleicht nicht alle
        Ihre Geräte unterstützt, sollte er alles enthalten,
        um das System in den Single-User-Modus zu booten.  Dies ist auch
        ein guter Test, um zu sehen, dass das System
        ordnungsgemäß funktioniert.  Nachdem Sie mit
        <filename>GENERIC</filename> gebootet und sichergestellt haben,
        dass Ihr System funktioniert, können Sie einen neuen
        Kernel mit Ihrer Konfigurationsdatei bauen.</para>

      <para>In aktuellen &os;-Versionen müssen Sie das
	<link linkend="make-buildworld">Basissystem neu bauen</link>,
	bevor Sie einen neuen Kernel erstellen.</para>

      <note>
	<para>Wenn Sie einen angepassten Kernel erstellen wollen und
	  bereits über eine Konfigurationsdatei verfügen,
	  geben Sie diese, wie im folgenden Beispiel gezeigt, auf der
	  Kommandozeile an:</para>

        <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildkernel KERNCONF=MYKERNEL</userinput>
&prompt.root; <userinput>make installkernel KERNCONF=MYKERNEL</userinput></screen>

      </note>

      <para>Wenn <varname>kern.securelevel</varname> einen Wert
	größer als <literal>1</literal> besitzt
	<emphasis>und</emphasis> der Kernel mit <literal>noschg</literal>
	oder ähnlichen Optionen geschützt ist, müssen Sie
	<buildtarget>installkernel</buildtarget> im Einbenutzermodus
	ausführen.  Wenn das nicht der Fall ist, sollten die beiden
	Kommandos problemlos im Mehrbenutzermodus laufen.  Weitere
	Informationen über <varname>kern.securelevel</varname> finden
	Sie in &man.init.8; und &man.chflags.1; erläutert Optionen, die
	Sie auf Dateien setzen können.</para>
    </sect2>

    <sect2 xml:id="new-kernel-singleuser">
      <title>Booten Sie in den Single-User-Modus</title>
      <indexterm><primary>Single-User-Modus</primary></indexterm>

      <para>Um zu prüfen, ob der neue Kernel funktioniert, sollten Sie
        in den Single-User-Modus booten.  Folgen Sie dazu der Anleitung aus
	<xref linkend="makeworld-singleuser"/>.</para>
    </sect2>

    <sect2 xml:id="make-installworld">
      <title>Installation des Systems</title>

      <para>Nun können Sie das neue System mit
	<buildtarget>installworld</buildtarget> installieren.
	Rufen Sie dazu das folgende Kommando auf:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput></screen>

      <note>
	<para>Wenn Sie mit dem <command>make buildworld</command> Kommando
	  Variablen verwendet haben, müssen Sie dieselben Variablen
	  auch bei dem <command>make installworld</command> Kommando
	  angeben.  Auf die anderen Optionen trifft das nur bedingt zu:
	  <option>-j</option> darf mit <buildtarget>installworld</buildtarget>
	  nicht benutzt werden.</para>

	<para>Sie haben zum Bauen die folgende Kommandozeile
	  verwendet:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE buildworld</userinput></screen>

	<para>Bei der Installation setzen Sie dann das folgende Kommando
	  ab:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE installworld</userinput></screen>

	<para>Würden Sie die Variable bei der Installation weglassen,
	  so würde das System versuchen, die <quote>profiled</quote>
	  Bibliotheken, die aber gar nicht gebaut wurden, zu
	  installieren.</para>
      </note>
    </sect2>

    <sect2 xml:id="post-installworld-updates">
      <title>Aktualisieren der von <command>make installworld</command>
        ausgelassenen Dateien</title>

      <para>Neue oder geänderte Konfigurationsdateien aus einigen
        Verzeichnissen, besonders <filename>/etc</filename>,
	<filename>/var</filename> und <filename>/usr</filename> werden bei
	der Installationsprozedur nicht berücksichtigt.</para>

      <para>Sie können diese Dateien mit &man.mergemaster.8;
        aktualisieren.  Alternativ können Sie das auch manuell
	durchführen, obwohl wir diesen Weg nicht empfehlen.  Egal
	welchen Weg Sie beschreiten, sichern Sie vorher den Inhalt von
	<filename>/etc</filename> für den Fall, dass etwas schief
	geht.</para>

      <sect3 xml:id="mergemaster">
        <info><title><command>mergemaster</command></title>
	  <authorgroup>
	    <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
	  </authorgroup>
        </info>
	
        <indexterm><primary><command>mergemaster</command></primary></indexterm>

	<para>Das Bourne-Shell Skript &man.mergemaster.8; hilft Ihnen dabei,
	  die Unterschiede zwischen den Konfigurationsdateien in
	  <filename>/etc</filename> und denen im Quellbaum unter
	  <filename>/usr/src/etc</filename> zu finden.
	  <command>mergemaster</command> ist der empfohlene Weg, Ihre
	  Systemkonfiguration mit dem Quellbaum abzugleichen.</para>

	<para>Rufen Sie <command>mergemaster</command> einfach auf und
	  schauen Sie zu.  Ausgehend von <filename>/</filename> wird
	  <command>mergemaster</command> einen virtuellen Root-Baum
	  aufbauen und darin die neuen Konfigurationsdateien ablegen.
	  Diese Dateien werden dann mit den auf Ihrem System installierten
	  verglichen.  Unterschiede zwischen den Dateien werden im
	  &man.diff.1;-Format dargestellt.  Neue oder geänderte Zeilen
	  werden mit <option>+</option> gekennzeichnet.  Zeilen die
	  gelöscht oder ersetzt werden, sind mit einem
	  <option>-</option> gekennzeichnet.  Das Anzeigeformat wird in
	  &man.diff.1; genauer erklärt.</para>

	<para>&man.mergemaster.8; zeigt Ihnen jede geänderte Datei an
	  und Sie haben die Wahl, die neue Datei (in
	  <command>mergemaster</command> wird sie temporäre Datei
	  genannt) zu löschen, sie unverändert zu installieren,
	  den Inhalt der neuen Datei mit dem Inhalt der alten Datei
	  abzugleichen, oder die &man.diff.1; Ausgabe noch einmal zu
	  sehen.  Sie können die aktuelle Datei auch
	  überspringen, sie wird dann noch einmal angezeigt, nachdem
	  alle anderen Dateien abgearbeitet wurden.  Sie erhalten Hilfe,
	  wenn Sie bei der Eingabeaufforderung von
	  <command>mergemaster</command> ein <keycap>?</keycap>
	  eingeben.</para>

	<para>Wenn Sie die temporäre Datei löschen, geht
	  <command>mergemaster</command> davon aus, dass Sie Ihre
	  aktuelle Datei behalten möchten.  Wählen Sie die Option
	  bitte nur dann, wenn Sie keinen Grund sehen, die aktuelle Datei
	  zu ändern.</para>

	<para>Wenn Sie die temporäre Datei installieren, wird Ihre
	  aktuelle Datei mit der neuen Datei überschrieben.  Sie
	  sollten alle unveränderten Konfigurationsdateien auf diese
	  Weise aktualisieren.</para>

	<para>Wenn Sie sich entschließen den Inhalt beider Dateien
	  abzugleichen, wird ein Texteditor aufgerufen, indem Sie beide
	  Dateien nebeneinander betrachten können.  Mit der Taste
	  <keycap>l</keycap> übernehmen Sie die aktuelle Zeile der
	  links dargestellten Datei, mit der Taste <keycap>r</keycap>
	  übernehmen Sie die Zeile der rechts dargestellten Datei.
	  Das Ergebnis ist eine Datei, die aus Teilen der beiden
	  ursprünglichen Dateien besteht und installiert werden kann.
	  Dieses Verfahren wird gewöhnlich bei veränderten
	  Dateien genutzt.</para>

	<para>Haben Sie sich entschieden die Differenzen noch einmal
	  anzuzeigen, zeigt Ihnen &man.mergemaster.8; dieselbe Ausgabe, die
	  Sie gesehen haben, bevor die Eingabeaufforderung ausgegeben
	  wurde.</para>

	<para>Wenn &man.mergemaster.8; alle Systemdateien abgearbeitet hat,
	  werden weitere Optionen abgefragt.  Sie werden unter
	  Umständen gefragt, ob Sie die Passwort-Datei neu bauen
	  lassen wollen.  Am Ende haben Sie die Möglichkeit, den Rest
	  der temporären Dateien zu löschen.</para>
      </sect3>

      <sect3>
	<title>Manueller Abgleich der Konfigurationsdateien</title>

	<para>Wenn Sie den Abgleich lieber selbst ausführen wollen,
	  beachten Sie bitte, dass Sie nicht einfach die Dateien aus
	  <filename>/usr/src/etc</filename> nach <filename>/etc</filename>
	  kopieren können.  Einige dieser Dateien müssen zuerst
	  <emphasis>installiert</emphasis> werden, bevor sie benutzt werden
	  können.  Das liegt daran, dass
	  <filename>/usr/src/etc</filename> keine exakte Kopie von
	  <filename>/etc</filename> ist.  Zudem gibt es Dateien, die sich
	  in <filename>/etc</filename> befinden aber nicht in
	  <filename>/usr/src/etc</filename>.</para>

	<para>Wenn Sie, wie empfohlen, <command>mergemaster</command>
	  benutzen, können Sie direkt in den nächsten
	  <link linkend="updating-upgrading-rebooting">Abschnitt</link>
	  wechseln.</para>

	<para>Am einfachsten ist es, wenn Sie die neuen Dateien in ein
	  temporäres Verzeichnis installieren und sie nacheinander auf
	  Differenzen zu den bestehenden Dateien durchsehen.</para>

	<warning>
	  <title>Sichern Sie die Inhalte von <filename>/etc</filename></title>

	  <para>Obwohl bei dieser Prozedur keine Dateien in
	    <filename>/etc</filename> automatisch verändert werden,
	    sollten Sie dessen Inhalt an einen sicheren Ort
	    kopieren:</para>

	    <screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

	    <para>Mit <option>-R</option> wird rekursiv kopiert und
	      <option>-p</option> erhält die Attribute der kopierten
	      Dateien, wie Zugriffszeiten und Eigentümer.</para>
	</warning>

	<para>Sie müssen die neuen Dateien in einem temporären
	  Verzeichnis installieren.  <filename>/var/tmp/root</filename> ist
	  eine gute Wahl für das temporäre Verzeichnis, in dem
	  auch noch einige Unterverzeichnisse angelegt werden
	  müssen.</para>

        <screen>&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>

	<para>Die obigen Kommandos bauen die nötige
	  Verzeichnisstruktur auf und installieren die neuen Dateien in
	  diese Struktur.  Unterhalb von <filename>/var/tmp/root</filename>
	  wurden einige leere Verzeichnisse angelegt, die Sie am besten wie
	  folgt entfernen:</para>

        <screen>&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d . -type d | xargs rmdir 2&gt;/dev/null</userinput></screen>

	<para>Im obigen Beispiel wurde die Fehlerausgabe nach
	  <filename>/dev/null</filename> umgeleitet, um die Warnungen
	  über nicht leere Verzeichnisse zu unterdrücken.</para>

	<para><filename>/var/tmp/root</filename> enthält nun alle
	  Dateien, die unterhalb von <filename>/</filename> installiert
	  werden müssen.  Sie müssen nun jede dieser Dateien mit
	  den schon existierenden Dateien vergleichen.</para>

	<para>Einige der installierten Dateien unter
	  <filename>/var/tmp/root</filename> beginnen mit einem
	  <quote>.</quote>.
	  Als dieses Kapitel verfasst wurde, waren das nur die
	  Startdateien für die Shells in
	  <filename>/var/tmp/root/</filename> und
	  <filename>/var/tmp/root/root/</filename>.  Abhängig davon,
	  wann Sie dieses Handbuch lesen, können mehr Dateien dieser
	  Art existieren.  Verwenden Sie <command>ls -a</command> um
	  sicherzustellen, dass Sie alle derartigen Dateien
	  finden.</para>

	<para>Benutzen Sie &man.diff.1; um Unterschiede zwischen zwei
	  Dateien festzustellen:</para>

        <screen>&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>

	<para>Das obige Kommando zeigt Ihnen die Unterschiede zwischen der
	  installierten Version von <filename>/etc/shells</filename> und
	  der neuen Version in <filename>/var/tmp/root/etc/shells</filename>.
	  Entscheiden Sie anhand der Unterschiede, ob
	  Sie beide Dateien abgleichen oder die neue Version über die
	  alte kopieren wollen.</para>

	<tip>
	  <title>Versehen Sie das temporäre Verzeichnis mit einem
	    Zeitstempel</title>

	  <para>Wenn Sie das System oft neu bauen, müssen Sie
	    <filename>/etc</filename> genauso oft aktualisieren.  Dies kann
	    mit der Zeit sehr lästig werden.</para>

	  <para>Sie können das Verfahren beschleunigen, wenn Sie sich
	    eine Kopie der Dateien behalten, die Sie zuletzt nach
	    <filename>/etc</filename> installiert haben.  Das folgende
	    Verfahren zeigt Ihnen, wie das geht.</para>

	  <procedure>
	    <step>
	      <para>Folgen Sie der normalen Prozedur um das System zu
	        bauen.  Wenn Sie <filename>/etc</filename> und die anderen
		Verzeichnisse aktualisieren wollen, geben Sie dem
		temporären Verzeichnis einen Namen, der das aktuelle
		Datum enthält.  Wenn Sie dies zum Beispiel am
		14.&nbsp;Februar 1998 durchführten, hätten Sie die
		folgenden Kommandos abgesetzt:</para>

	      <screen>&prompt.root; <userinput>mkdir /var/tmp/root-19980214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-19980214 \
    distrib-dirs distribution</userinput></screen>
	    </step>

	    <step>
	      <para>Gleichen Sie die Änderungen entsprechend der
		Anleitung von oben ab.</para>

	      <para>Wenn Sie fertig sind, entfernen Sie das Verzeichnis
		<filename>/var/tmp/root-19980214</filename>
		<emphasis>nicht</emphasis>.</para>
	    </step>

	    <step>
	      <para>Wenn Sie nun neue Quellen heruntergeladen und gebaut
	        haben, folgen Sie bitte Schritt 1.  Wenn Sie zwischen den
		Updates eine Woche gewartet haben, haben Sie nun ein
		Verzeichnis mit dem Namen
		<filename>/var/tmp/root-19980221</filename>.</para>
	    </step>

	    <step>
	      <para>Sie können nun die Unterschiede, die sich in einer
		Woche ergeben haben, sehen, indem Sie &man.diff.1; rekursiv
		anwenden:</para>

	      <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-19980214 root-19980221</userinput></screen>

	      <para>Üblicherweise sind die Differenzen, die Sie jetzt
	        sehen, kleiner als die Differenzen zwischen
		<filename>/var/tmp/root-19980221/etc</filename> und
		<filename>/etc</filename>.  Da die angezeigten Differenzen
		kleiner sind, ist es jetzt einfacher den Abgleich der
		Dateien durchzuführen.</para>
	    </step>

	    <step>
	      <para>Sie können nun das älteste der beiden
	        <filename>/var/tmp/root-*</filename> Verzeichnisse
	        entfernen:</para>

	      <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-19980214</userinput></screen>
	    </step>

	    <step>
	      <para>Wiederholen Sie diesen Prozess jedes Mal wenn Sie
		Dateien in <filename>/etc</filename> abgleichen
		müssen.</para>
	    </step>
	  </procedure>

	  <para>Mit &man.date.1; können Sie den Verzeichnisnamen
	    automatisch erzeugen:</para>

	  <screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
	</tip>
      </sect3>
    </sect2>

    <sect2 xml:id="updating-upgrading-rebooting">
      <title>Das System neu starten</title>

      <para>Sie sind nun am Ende der Prozedur angelangt.  Nachdem Sie sich
        davon überzeugt haben, dass Ihr System funktioniert,
        starten Sie Ihr System mit &man.shutdown.8; neu:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>
    </sect2>

    <sect2>
      <title>Ende</title>

      <para>Herzlichen Glückwunsch!  Sie haben gerade erfolgreich Ihr
        &os; System aktualisiert.</para>

      <para>Es ist übrigens leicht einen Teil des Systems
        wiederherzustellen, für den Fall, dass Ihnen ein kleiner
	Fehler unterlaufen ist.  Wenn Sie beispielsweise während des
	Updates oder Abgleichs <filename>/etc/magic</filename> aus Versehen
	gelöscht haben, wird &man.file.1; nicht mehr funktionieren.
	In diesem Fall können Sie das Problem mit dem folgenden
	Kommando beheben:</para>

	<screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2 xml:id="updating-questions">
      <title>Fragen</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>Muss ich wirklich immer alles neu bauen, wenn sich
	      etwas geändert hat?</para>
	  </question>

	  <answer>
	    <para>Darauf gibt es keine einfache Antwort.  Was zu tun ist,
	      hängt von den Änderungen ab.  Es lohnt
	      wahrscheinlich nicht, alles neu zu bauen, wenn sich bei einem
	      <application>CVSup</application>-Lauf nur die folgenden
	      Dateien geändert haben:</para>

	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

	    <para>In diesem Fall können Sie in die entsprechenden
	      Unterverzeichnisse wechseln und dort <command>make all
	      install</command> ausführen.  Wenn sich allerdings etwas
	      Wichtiges, wie <filename>src/lib/libc/stdlib</filename>,
	      geändert hat, sollten Sie die Welt oder
	      mindestens die statisch gelinkten Teile des Systems (sowie
	      Ihre statisch gelinkten Ergänzungen) neu bauen.</para>

	    <para>Letztendlich ist das Ihre Entscheidung.  Sie sind
	      vielleicht damit zufrieden, das System alle zwei Wochen neu
	      zu bauen und in der Zwischenzeit die anfallenden
	      Änderungen zu sammeln.  Wenn Sie sich zutrauen, alle
	      Abhängigkeiten zu erkennen, bauen Sie vielleicht auch
	      nur die geänderten Sachen neu.</para>

	    <para>Das hängt natürlich auch noch davon ab, wie oft
	      Sie ein Update durchführen wollen und ob Sie &os.stable;
	      oder &os.current; benutzen.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Der Bau bricht mit vielen
	      <errorname>Signal 11</errorname>-Fehlern<indexterm>
	      <primary>Signal 11</primary></indexterm> (oder anderen
	      Signalnummern) ab.  Was ist da passiert?</para>
	  </question>

	  <answer>
	    <para>Normalerweise zeigen diese Meldungen Hardwarefehler an.
	      Ein Neubau der Welt ist ein guter Belastungstest für
	      Ihre Hardware und zeigt oft Probleme mit dem Speicher auf.
	      Dies äußert sich darin, dass der Compiler
	      mit dem Erhalt von seltsamen Signalen abbricht.</para>

	    <para>Es liegt garantiert ein Hardwarefehler vor, wenn ein
	      neuer Übersetzungslauf an einer anderen Stelle
	      abbricht.</para>

	    <para>In diesem Fall können Sie nur einzelne Komponenten
	      Ihres Systems tauschen, um zu bestimmen, welche Komponente den
	      Fehler verursacht.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Kann ich <filename>/usr/obj</filename> löschen, wenn
	      ich fertig bin?</para>
	  </question>

	  <answer>
	    <para>Kurze Antwort: Ja.</para>

	    <para>In <filename>/usr/obj</filename> werden alle Dateien
	      abgelegt, die während der Übersetzungsphase erstellt
	      wurden.  Dieses Verzeichnis wird in einem der ersten Schritte
	      der Bauprozedur entfernt.  Es macht daher
	      wenig Sinn, dieses Verzeichnis zu behalten und Sie setzen
	      eine Menge Plattenplatz, momentan ungefähr 2&nbsp;GB,
	      frei, wenn Sie es löschen.</para>

	    <para>Wenn Sie allerdings genau wissen, was Sie tun, können
	      Sie diesen Schritt bei <command>make buildworld</command>
	      auslassen.  Nachfolgende Bauprozeduren werden dadurch erheblich
	      schneller, da die meisten Quelldateien nicht mehr neu
	      übersetzt werden.  Dafür können aber subtile
	      Abhängigkeitsprobleme entstehen, die dazu führen,
	      dass der Bau auf merkwürdige Weise abbrechen kann.
	      Dies führt häufig zu unnötigen Diskussionen auf
	      den &os; Mailinglisten, wenn sich jemand über einen
	      kaputten Bau beschwert, aber nicht sieht, dass er
	      Probleme hat, weil er eine Abkürzung genommen hat.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Kann ein abgebrochener Bau weitergeführt
	      werden?</para>
	  </question>

	  <answer>
	    <para>Das hängt davon ab, wieweit der Bauprozess
	      fortgeschritten ist.</para>

	    <para><emphasis>Üblicherweise</emphasis> werden
	      essentielle Werkzeuge, wie &man.gcc.1; und &man.make.1;,
	      und die Systembibliotheken während des Bauprozesses
	      neu erstellt (dies ist aber keine allgemein gültige
	      Regel).  Die neu erstellen Werkzeuge und Bibliotheken werden
	      dann benutzt, um sich selbst noch einmal zu bauen, und wieder
	      installiert.  Anschließend wird das Gesamtsystem mit
	      den neu erstellten Systemdateien gebaut.</para>

	    <para>Wenn Sie sich im letzten Schritt befinden und Sie wissen,
	      dass Sie dort sind, weil Sie durch die Ausgaben, die Sie
	      ja sichern, der Bauprozedur gesehen haben, können Sie
	      mit ziemlicher Sicherheit den Bau weiterführen:</para>

	    <screen><emphasis>&hellip; Fehler beheben &hellip;</emphasis>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNO_CLEAN all</userinput></screen>

	    <para>Diese Variablen verhindern,
	      dass <command>make buildworld</command> die vorher erstellten
	      Dateien löscht.</para>

	    <para>Das Sie sich im letzten Schritt der Bauprozedur
	      befinden, erkennen Sie daran, dass Sie in der Ausgabe die
	      folgenden Zeilen finden:</para>

	      <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

	    <para>Wenn Sie diese Meldung nicht finden, oder sich nicht sicher
	      sind, dann ist es besser, noch einmal ganz von Vorne
	      anzufangen.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Wie kann ich den Bauprozess beschleunigen?</para>
          </question>

          <answer>
	    <itemizedlist>
	      <listitem>
		<para>Bauen Sie im Single-User-Modus.</para>
	      </listitem>

	      <listitem>
		<para>Legen Sie <filename>/usr/src</filename> und
		  <filename>/usr/obj</filename> in getrennte Dateisysteme auf
		  unterschiedliche Festplatten.  Benutzen Sie nach
		  Möglichkeit auch getrennte Platten-Controller.</para>
	      </listitem>

	      <listitem>
		<para>Noch besser ist es, diese Dateisysteme auf mehrere
		  Festplatten mit &man.ccd.4; zu verteilen.</para>
	      </listitem>

	      <listitem>
		<para>Bauen Sie die <quote>profiled</quote>-Bibliotheken,
		  die Sie wahrscheinlich sowieso nicht brauchen, nicht.
		  <filename>/etc/make.conf</filename> sollte dazu
		  <literal>NO_PROFILE=true</literal> enthalten.</para>
	      </listitem>

	      <listitem>
		<para>Setzen Sie die <varname>CFLAGS</varname> in
		  <filename>/etc/make.conf</filename> auf <option>-O
		    -pipe</option>.  Die Optimierungsstufe
		  <option>-O2</option> ist deutlich langsamer und die
		  Performance-Unterschiede zwischen <option>-O</option> und
		  <option>-O2</option> sind vernachlässigbar klein.
		  <option>-pipe</option> veranlasst den Compiler Pipes
		  anstelle von Dateien für die Kommunikation zu
		  benutzen.  Dies spart einige Plattenzugriffe, geht aber
		  auf Kosten des Speichers.</para>
	      </listitem>

	      <listitem>
		<para>Benutzen Sie
		  <option>-j<replaceable>n</replaceable></option>, um
		  mehrere Prozesse parallel laufen zu lassen.
		  Normalerweise beschleunigt dies den Bauprozess
		  unabhängig davon, ob Sie ein Einprozessor- oder
		  Mehrprozessorsystem einsetzen.</para>
	      </listitem>

	      <listitem>
		<para>Sie können das Dateisystem
		  <filename>/usr/src</filename> mit der Option
		  <option>noatime</option> einhängen.  Dies
		  verhindert, dass die Zugriffszeiten der Dateien
		  aktualisiert werden (eine Information, die Sie vielleicht
		  gar nicht brauchen).</para>

		<screen>&prompt.root; <userinput>mount -u -o noatime /usr/src</userinput></screen>

		<warning>
		  <para>Das Beispiel geht davon aus, dass sich
		    <filename>/usr/src</filename> auf einem separaten
		    Dateisystem befindet.  Wenn das nicht der Fall ist,
		    weil das Verzeichnis beispielsweise Teil des
		    <filename>/usr</filename> Dateisystems ist,
		    müssen Sie anstelle von
		    <filename>/usr/src</filename> den Mountpoint des
		    Dateisystems angeben.</para>
		</warning>
	      </listitem>

	      <listitem>
		<para>Das Dateisystem, in dem sich
		  <filename>/usr/obj</filename> befindet, kann mit der
		  Option <option>async</option> eingehangen werden.  Dies
		  bewirkt, dass Schreibzugriffe auf die Platte
		  asynchron stattfinden, das heißt ein Schreibzugriff
		  ist sofort beendet, die Daten werden allerdings erst einige
		  Sekunden später geschrieben.  Dadurch können
		  Schreibzugriffe zusammengefasst werden, was einen
		  erheblichen Geschwindigkeitszuwachs mit sich bringen
		  kann.</para>

		<warning>
		  <para>Beachten Sie, dass dies Ihr Dateisystem
		    anfälliger für Fehler macht.  Im Fall eines
		    Stromausfalls besteht eine erhöhte
		    Wahrscheinlichkeit, dass das Dateisystem beim
		    Start der Maschine zerstört ist.</para>

		  <para>Wenn sich <filename>/usr/obj</filename> auf einem
		    extra Dateisystem befindet, ist das kein Problem.  Wenn
		    sich allerdings auf diesem Dateisystem noch andere
		    wertvolle Daten befinden, stellen Sie sicher, dass
		    Sie aktuelle Sicherungen besitzen.</para>
		</warning>

		<screen>&prompt.root; <userinput>mount -u -o async /usr/obj</userinput></screen>

		<warning>
		  <para>Ersetzen Sie <filename>/usr/obj</filename> durch
		    den Mountpoint des entsprechenden Dateisystems, wenn es
		    sich nicht auf einem eigenen Dateisystem
		    befindet.</para>
		</warning>
	      </listitem>
	    </itemizedlist>
	  </answer>
	</qandaentry>

        <qandaentry>
          <question>
	    <para>Was mache ich, wenn etwas nicht funktioniert?</para>
          </question>

          <answer>
	    <para>Stellen Sie sicher, dass sich in Ihrer Umgebung
	      keine Reste eines vorherigen Baus befinden.  Das geht ganz
	      einfach:</para>

            <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root; <userinput>rm -rf /usr/obj/usr</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

	    <para>Ja, <command>make cleandir</command> muss wirklich
	      zweimal aufgerufen werden.</para>

	    <para>Nachdem Sie aufgeräumt haben, starten Sie den
	      Bauprozess wieder mit <command>make
	        buildworld</command>.</para>

	    <para>Wenn Sie immer noch Probleme haben, schicken Sie die
	      Fehlermeldungen und die Ausgabe von <command>uname
	        -a</command> an die Mailingliste &a.de.questions;.  Bereiten
	      Sie sich darauf vor, weitere Fragen zu Ihrer Umgebung zu
	      beantworten.</para>
          </answer>
        </qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 xml:id="make-delete-old">
    <info><title>Veraltete Dateien, Verzeichnisse und Bibliotheken
      löschen</title>
      <authorgroup>
	<author><personname><firstname>Anton</firstname><surname>Shterenlikht</surname></personname><contrib>Basiert auf Notizen von </contrib></author>
      </authorgroup>
    </info>

    
    <indexterm>
      <primary>Veraltete Dateien, Verzeichnisse und Bibliotheken
	löschen</primary>
    </indexterm>

    <para>Aufgrund der ständigen Weiterentwicklung von &os; kann es
      dazu kommen, dass Dateien (und deren Inhalte) obsolet werden, weil
      deren Funktionalität entweder in anderen Dateien implementiert
      wurde, sich die Versionsnummer der Bibliothek geändert hat
      oder deren Funktion nicht mehr benötigt wird.  Dies kann
      sowohl Dateien und Verzeichnis, aber auch Bibliotheken betreffen.
      Diese veralteten Dateien sollten daher entfernt werden, bevor Sie
      Ihr System aktualisieren.  Der Vorteil für den Benutzer ist
      darin zu sehen, dass dessen System (sowie dessen Backup) von
      nicht mehr benötigten Dateien gereinigt wird.  Falls die
      obsolete Bibliothek Sicherheits- oder Stabilitätsprobleme
      aufweist, sollte das System ebenfalls aktualisiert werden, um
      Ihr System sicher zu halten und/oder durch die fehlerhafte
      Bibliothek verursachte Systemabstürze zu vermeiden.  Veraltete
      Dateien, Verzeichnisse und Bibliotheken sind in der Datei
      <filename>/usr/src/ObsoleteFiles.inc</filename> aufgelistet.  Die
      folgenden Anweisungen sollen Ihnen dabei helfen, diese Dateien
      während der Systemaktualisierung zu entfernen.</para>

    <para>Im Folgenden wird angenommen, dass Sie den Anweisungen von
      <xref linkend="canonical-build"/> folgen.  Nachdem Sie
      <command>make installworld</command>
      sowie <command>mergemaster</command> erfolgreich ausgeführt
      haben, sollten Sie Ihr System auf veraltete Dateien und
      Bibliotheken hin überprüfen:</para>

    <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make check-old</userinput></screen>

    <para>Werden dabei veraltete Dateien gefunden, können diese
      im nächsten Schritt entfernt werden:</para>

    <screen>&prompt.root; <userinput>make delete-old</userinput></screen>

    <tip>
      <para>Weitere interessante Targets finden sich in der Datei
	<filename>/usr/src/Makefile</filename>.</para>
    </tip>

    <para>Bei jeder Datei wird nachgefragt, ob Sie diese wirklich
      löschen wollen.  Es ist aber auch möglich, alle
      Dateien automatisch löschen zu lassen.  Dies erreichen Sie,
      indem Sie die Umgebungsvariable
      <varname>BATCH_DELETE_OLD_FILES</varname> entsprechend
      setzen:</para>

    <screen>&prompt.root; <userinput>make -DBATCH_DELETE_OLD_FILES delete-old</userinput></screen>

    <para>Alternativ können Sie auch den folgenden Befehl
      einsetzen (und jeweils die Antwort <command>yes</command>
      an die einzelnen Abfragen weiterreichen):</para>

    <screen>&prompt.root; <userinput>yes | make delete-old</userinput></screen>

    <warning>
      <title>Warnung</title>
	<para>Das Löschen veralteter Dateien kann dazu führen,
	  dass Programme, die auf diese Dateien angewiesen sind, nicht mehr
	  funktionieren.  Dies gilt insbesondere für veraltete
	  Bibliotheken.  In den meisten Fällen ist es dann notwendig,
	  Programme, Ports und Bibliotheken, welche die veraltete
	  Bibliothek verwenden, neu zu bauen, bevor Sie den Befehl
	  <command>make
	  delete-old-libs</command>
	  ausführen.</para>
    </warning>

    <para>Die Ports-Sammlung enthält Werkzeuge, die Ihnen beim
      Prüfen von Bibliothek-Abhängigkeiten helfen können:
      <package>sysutils/libchk</package>
      sowie <package>sysutils/bsdadminscripts</package>.</para>

    <para>Veraltete Bibliotheken können zu Konflikten mit neueren
      Bibliotheken führen und beispielsweise folgende
      Meldungen verursachen:</para>

    <screen>/usr/bin/ld: warning: libz.so.4, needed by /usr/local/lib/libtiff.so, may conflict with libz.so.5
/usr/bin/ld: warning: librpcsvc.so.4, needed by /usr/local/lib/libXext.so, may conflict with librpcsvc.so.5</screen>

    <para>Um diese Probleme zu lösen, müssen Sie zuerst
      herausfinden, welcher Port die Bibliothek installiert hat:</para>

    <screen>&prompt.root; <userinput>pkg_info -W  /usr/local/lib/libtiff.so</userinput>
/usr/local/lib/libtiff.so was installed by package tiff-3.9.4
&prompt.root; <userinput>pkg_info -W /usr/local/lib/libXext.so</userinput>
/usr/local/lib/libXext.so was installed by package libXext-1.1.1,1</screen>

    <para>Danach deinstallieren Sie den Port und bauen ihn neu, um ihn
      danach erneut zu installieren.  Dieser Vorgang kann durch den
      Einsatz der Werkzeuge <package>ports-mgmt/portmaster</package> oder <package>ports-mgmt/portupgrade</package> automatisiert
      werden.  Nachdem Sie alle Ports erfolgreich neu gebaut haben
      (und Sie daher keine veralteten Bibliotheken mehr verwenden)
      können Sie die veralteten Bibliotheken endgültig
      entfernen:</para>

    <screen>&prompt.root; <userinput>make delete-old-libs</userinput></screen>
  </sect1>

  <sect1 xml:id="small-lan">
    <info><title>Installation mehrerer Maschinen</title>
      <authorgroup>
	<author><personname><firstname>Mike</firstname><surname>Meyer</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
    </info>
    

    <para>Wenn Sie mehrere Maschinen besitzen, die Sie alle auf dem
      gleichen Stand halten wollen, ist es eine Verschwendung von
      Ressourcen, die Quellen auf jeder Maschine vorzuhalten und zu
      übersetzen.  Die Lösung dazu ist, eine Maschine den
      Großteil der Arbeit durchführen zu lassen und den anderen
      Maschinen das Ergebnis mit NFS zur Verfügung zu stellen.  Dieser
      Abschnitt zeigt Ihnen wie das geht.</para>

    <sect2 xml:id="small-lan-preliminaries">
      <title>Voraussetzungen</title>

      <para>Stellen Sie zuerst eine Liste der Maschinen zusammen, die auf
        demselben Stand sein sollen.  Wir nennen diese Maschinen die
	<emphasis>Baugruppe</emphasis>.  Jede dieser Maschinen kann mit
	einem eigenen Kernel laufen, doch sind die Programme des Userlands
	auf allen Maschinen gleich.  Wählen Sie aus der Baugruppe eine
	Maschine aus, auf der der Bau durchgeführt wird, den
	<emphasis>Bau-Master</emphasis>.  Dies sollte eine Maschine sein,
	die über die nötigen Ressourcen für
	<command>make buildworld</command> und
	<command>make installworld</command> verfügt.
	Sie brauchen auch eine
	<emphasis>Testmaschine</emphasis>, auf der Sie die Updates testen,
	bevor Sie sie in Produktion installieren.  Dies sollte eine
	Maschine, eventuell der Bau-Master, sein, die über einen
	längeren Zeitraum nicht zur Verfügung stehen kann.</para>

      <para>Alle Maschinen der Baugruppe müssen
        <filename>/usr/obj</filename> und <filename>/usr/src</filename> von
	derselben Maschine an gleichem Ort einhängen.  Idealerweise
	befinden sich die beiden Verzeichnisse auf dem Bau-Master auf
	verschiedenen Festplatten, sie können allerdings auch auf dem
	Bau-Master über NFS zur Verfügung gestellt werden.  Wenn
	Sie mehrere Baugruppen haben, sollte sich
	<filename>/usr/src</filename> auf einem Bau-Master befinden und
	über NFS für den Rest der Maschinen zur Verfügung
	gestellt werden.</para>

      <para>Stellen Sie sicher, dass
        <filename>/etc/make.conf</filename> und
        <filename>/etc/src.conf</filename> auf allen Maschinen einer
	Baugruppe mit der Datei des Bau-Masters übereinstimmt.  Der
	Bau-Master muss jeden Teil des Systems bauen, den irgendeine
	Maschine der Baugruppe benötigt.  Auf dem Bau-Master
	müssen in <filename>/etc/make.conf</filename> alle zu bauenden
	Kernel mit der Variablen <varname>KERNCONF</varname> bekannt gegeben
	werden.  Geben Sie dabei den Kernel des Bau-Masters zuerst an.
	Für jeden zu bauenden Kernel muss auf dem Bau-Master die
	entsprechende Konfigurationsdatei unter
	<filename>/usr/src/sys/arch/conf</filename>
	abgelegt werden.</para>
    </sect2>

    <sect2 xml:id="small-lan-base-system">
      <title>Installation des Basissystems</title>

      <para>Nach diesen Vorbereitungen können Sie mit dem Bau
        beginnen.  Bauen Sie auf dem Bau-Master, wie in <xref linkend="make-buildworld"/> beschrieben, den Kernel und die Welt,
	installieren Sie aber nichts.  Wechseln Sie auf die Testmaschine
	und installieren Sie den gerade gebauten Kernel.  Wenn diese
	Maschine <filename>/usr/src</filename> und
	<filename>/usr/obj</filename> über NFS bekommt, müssen
	Sie das Netzwerk im Single-User-Modus aktivieren und die beiden
	Dateisysteme einhängen.  Am einfachsten ist dies, wenn Sie
	auf der Testmaschine ausgehend vom Mehrbenutzermodus mit
	<command>shutdown now</command> in den Single-User-Modus wechseln.
	Sie können dann mit der normalen Prozedur den neuen Kernel
	und das System installieren und anschließend
	<command>mergemaster</command> laufen lassen.  Wenn Sie damit
	fertig sind, können Sie die Maschine wieder in den
	Mehrbenutzermodus booten.</para>

      <para>Nachdem Sie sichergestellt haben, dass die Testmaschine
        einwandfrei funktioniert, wiederholen Sie diese Prozedur für
	jede Maschine in der Baugruppe.</para>
    </sect2>

    <sect2 xml:id="small-lan-ports">
      <title>Die Ports-Sammlung</title>

      <para>Dasselbe Verfahren können Sie auch für die
        Ports-Sammlung anwenden.  Zuerst müssen alle Maschinen einer
	Baugruppe <filename>/usr/ports</filename> von derselben Maschine
	über NFS zur Verfügung gestellt bekommen.  Setzen Sie
	dann ein Verzeichnis für die Quellen auf, das sich alle
	Maschinen teilen.  Dieses Verzeichnis können Sie in
	<filename>/etc/make.conf</filename> mit der Variablen
	<varname>DISTDIR</varname> angeben.  Das Verzeichnis sollte
	für den Benutzer beschreibbar sein, auf den der Benutzer
	<systemitem class="username">root</systemitem> vom NFS Subsystem abgebildet wird.  Jede
	Maschine sollte noch <varname>WRKDIRPREFIX</varname> auf ein
	lokales Bauverzeichnis setzen.  Wenn Sie vorhaben, Pakete zu bauen
	und zu verteilen, sollten Sie <varname>PACKAGES</varname> auf ein
	Verzeichnis mit den gleichen Eigenschaften wie
	<varname>DISTDIR</varname> setzen.</para>
    </sect2>
  </sect1>
</chapter>
