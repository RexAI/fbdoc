<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/kernelconfig/chapter.xml,v 1.117 2012/04/30 17:31:07 bcr Exp $
     basiert auf: 1.205
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="kernelconfig">
  <info><title>Konfiguration des &os;-Kernels</title>
    <authorgroup>
      <author><personname><firstname>Jim</firstname><surname>Mock</surname></personname><contrib>Erweitert und neu strukturiert von </contrib></author>
    </authorgroup>
    <authorgroup>
      <author><personname><firstname>Jake</firstname><surname>Hamby</surname></personname><contrib>Ursprünglich veröffentlicht von </contrib></author>
    </authorgroup>
    <authorgroup>
      <author><personname><firstname>Robert</firstname><surname>Altschaffel</surname></personname><contrib>Übersetzt von </contrib></author>
    </authorgroup>
  </info>

  

  <sect1 xml:id="kernelconfig-synopsis">
    <title>Übersicht</title>

    <indexterm>
      <primary>Kernel</primary>
      <secondary>Erstellen eines angepassten Kernels</secondary>
    </indexterm>

    <para>Der Kernel ist das Herz des &os; Betriebssystems.  Er ist
      verantwortlich für die Speicherverwaltung, das Durchsetzen
      von Sicherheitsdirektiven, Netzwerkfähigkeit, Festplattenzugriffen
      und vieles mehr.  Obwohl &os; es immer mehr ermöglicht, dynamisch
      konfiguriert zu werden, ist es ab und an notwendig, den Kernel
      neu zu konfigurieren und zu kompilieren.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie Folgendes
      wissen:</para>

    <itemizedlist>
      <listitem>
        <para>Wieso Sie Ihren Kernel neu konfigurieren sollten.</para>
      </listitem>

      <listitem>
        <para>Wie Sie eine Kernelkonfigurationsdatei erstellen oder
	  verändern.</para>
      </listitem>

      <listitem>
        <para>Wie Sie mit der Konfigurationsdatei einen neuen Kernel
	  kompilieren.</para>
      </listitem>

      <listitem>
        <para>Wie Sie den neuen Kernel installieren.</para>
      </listitem>

      <listitem>
        <para>Was zu tun ist, falls etwas schiefgeht.</para>
      </listitem>
    </itemizedlist>

    <para>Alle Kommandos, aus den Beispielen dieses Kapitels,
      müssen mit <systemitem class="username">root</systemitem>-Rechten
      ausgeführt werden.</para>
  </sect1>

  <sect1 xml:id="kernelconfig-custom-kernel">
    <title>Wieso einen eigenen Kernel bauen?</title>

    <para>Traditionell besaß &os; einen monolithischen Kernel.  Das
      bedeutet, dass der Kernel ein einziges großes Programm war,
      das eine bestimmte Auswahl an Hardware unterstützte.
      Also musste man immer, wenn man das Kernelverhalten verändern
      wollte, zum Beispiel wenn man neue Hardware hinzufügen wollte,
      einen neuen Kernel kompilieren, installieren und das System neu
      starten.</para>

    <para>Heutzutage vertritt &os; immer mehr die Idee eines modularen
      Kernels, bei dem bestimmte Funktionen, je nach Bedarf, als Module
      geladen werden können.  Ein bekanntes Beispiel dafür sind
      die Module für die PCMCIA-Karten in Laptops, die zum Starten
      nicht zwingend benötigt und erst bei Bedarf geladen
      werden.</para>

    <para>Trotzdem ist es noch immer nötig, einige statische
      Kernelkonfigurationen durchzuführen.  In einigen Fällen
      ist die Funktion zu systemnah, um durch ein Modul zu realisiert werden.
      In anderen Fällen hat eventuell noch niemand ein ladbares
      Kernelmodul für diese Funktion geschrieben.</para>

    <para>Das Erstellen eines angepaßten Kernels ist eines der
      wichtigsten Rituale für erfahrene BSD-Benutzer.  Obwohl dieser
      Prozess recht viel Zeit in Anspruch nimmt,
      bringt er doch viele Vorteile für Ihr &os; System.  Der
      <filename>GENERIC</filename>-Kernel muss eine Vielzahl
      unterschiedlicher Hardware unterstützen, im Gegensatz dazu
      unterstützt ein angepasster Kernel nur
      <emphasis>Ihre</emphasis> Hardware.  Dies hat einige Vorteile:</para>

    <itemizedlist>
      <listitem>
        <para>Schnellerer Bootvorgang.  Da der Kernel nur
	  nach der Hardware des Systems sucht, kann sich
	  die Zeit für einen Systemstart erheblich
	  verkürzen.</para>
      </listitem>

      <listitem>
        <para>Geringerer Speicherbedarf.  Ein eigener Kernel
	  benötigt in der Regel weniger Speicher als ein
	  <filename>GENERIC</filename>-Kernel durch das Entfernen von
	  Funktionen und Gerätetreibern. Das ist vorteilhaft, denn der
	  Kernel verweilt immer im RAM und verhindert dadurch, dass dieser
	  Speicher von Anwendungen genutzt wird.  Insbesondere
	  profitieren Systeme mit wenig RAM davon.</para>
      </listitem>

      <listitem>
        <para>Zusätzliche Hardwareunterstützung.  Ein
	  angepasster Kernel kann Unterstützung für
	  Geräte wie Soundkarten bieten, die im
	  <filename>GENERIC</filename>-Kernel nicht enthalten
	  sind.</para>
      </listitem>
    </itemizedlist>
  </sect1>

 <sect1 xml:id="kernelconfig-devices">
    <info><title>Informationen über die vorhandene Hardware
      beschaffen</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Geschrieben von </contrib></author>
      </authorgroup>
    </info>

    

    <para>Bevor Sie mit der Kernelkonfiguration beginnen, sollten
      Sie wissen, über welche Hardware Ihr System verfügt.
      Verwenden Sie derzeit noch ein anderes Betriebssystem, ist
      es meist sehr einfach, eine Liste der installierten Hardware
      zu erzeugen.  Verwenden Sie beispielsweise &microsoft.windows;,
      können Sie dafür den
      <application>Gerätemanager</application> verwenden, den
      Sie in der <quote>Systemsteuerung</quote> finden.</para>

    <note>
      <para>Einige Versionen von &microsoft.windows; verfügen
	über ein <application>System</application>-Icon auf
	dem Desktop, über das Sie den
	<application>Gerätemanager</application> direkt aufrufen
	können.</para>
    </note>

    <para>Haben Sie außer &os; kein weiteres Betriebssystem,
      müssen Sie diese Informationen manuell zusammentragen.
      Eine Möglichkeit, an Informationen über die
      vorhandene Hardware zu gelangen, ist der Einsatz von &man.dmesg.8;
      in Kombination mit &man.man.1;.  Die meisten &os;-Gerätetreiber
      haben eine eigene Manualpage, die Informationen über die
      unterstützte Hardware enthält.  Während des
      Systemstarts werden Informationen über die vorhandene
      Hardware ausgegeben.  Die folgenden Zeilen zeigen beispielsweise
      an, dass der <filename>psm</filename>-Treiber eine
      angeschlossene Maus gefunden hat:</para>

    <programlisting>psm0: &lt;PS/2 Mouse&gt; irq 12 on atkbdc0
psm0: [GIANT-LOCKED]
psm0: [ITHREAD]
psm0: model Generic PS/2 mouse, device ID 0</programlisting>

    <para>Dieser Treiber muss in Ihrer Kernelkonfigurationsdatei
      vorhanden sein oder durch das Werkzeug &man.loader.conf.5;
      geladen werden.</para>

    <para>Manchmal zeigt <command>dmesg</command> während des
      Systemstarts nur Systemmeldungen, aber keine Informationen
      zur gefundenen Hardware an.  In diesem Fall können Sie
      diese Informationen durch das Studium der Datei
      <filename>/var/run/dmesg.boot</filename>
      herausfinden.</para>

    <para>Eine weitere Möglichkeit bietet das Werkzeug
      &man.pciconf.8;, das ausführliche Informationen
      bereitstellt.  Dazu ein Beispiel:</para>

    <programlisting>ath0@pci0:3:0:0:        class=0x020000 card=0x058a1014 chip=0x1014168c rev=0x01 hdr=0x00
    vendor     = 'Atheros Communications Inc.'
    device     = 'AR5212 Atheros AR5212 802.11abg wireless'
    class      = network
    subclass   = ethernet</programlisting>

    <para>Diese Zeilen, die Sie durch den Aufruf des Befehls
      <command>pciconf -lv</command> erhalten, zeigen,
      dass der Treiber <filename>ath</filename> eine drahtlose
      Ethernetkarte gefunden hat.  Durch Eingabe des Befehls
      <command>man ath</command> öffnet
      sich die Manualpage &man.ath.4;.</para>

    <para>Rufen Sie &man.man.1; mit der Option <option>-k</option>
      auf, können Sie die Datenbank der Manualpages auch
      durchsuchen.  Für das angegebene Beispiel würde
      dieser Befehl beispielsweise so aussehen:</para>

    <screen>&prompt.root; man -k <replaceable>Atheros</replaceable></screen>

    <para>Dadurch erhalten Sie eine Liste aller Manualpages, die das
      angegebene Suchkriterium enthalten:</para>

    <programlisting>ath(4)                   - Atheros IEEE 802.11 wireless network driver
ath_hal(4)               - Atheros Hardware Access Layer (HAL)</programlisting>

    <para>Mit diesen Informationen ausgestattet, sollte der Bau eines
      angepassten Kernel keine allzugroßen Probleme mehr
      bereiten.</para>
  </sect1>

  <sect1 xml:id="kernelconfig-modules">
    <title>Kerneltreiber, Subsysteme und Module</title>

    <indexterm>
      <primary>Kernel</primary>
      <secondary>Treiber / Module / Subsysteme</secondary>
    </indexterm>

    <para>Bevor Sie einen angepassten Kernel erstellen, überlegen Sie sich
      bitte, warum Sie dies tun wollen.  Wenn Sie lediglich eine bestimmte
      Hardwareunterstützung benötigen, existiert diese vielleicht
      schon als Kernelmodul.</para>

    <para>Kernelmodule existieren im Verzeichnis <filename>/boot/kernel</filename> und können dynamisch in
      den laufenden Kernel über &man.kldload.8; geladen werden.  Die
      meisten, wenn nicht sogar alle, Kerneltreiber besitzen ein spezifisches
      Modul und eine Manualpage.  Beispielsweise erwähnte der letzte
      Abschnitt den drahtlosen Ethernettreiber <filename>ath</filename>.
      Dieses Gerät hat die folgende Information in seiner
      Manualpage:</para>

    <programlisting>Alternatively, to load the driver as a module at boot time, place the
following line in &man.loader.conf.5;:

    if_ath_load="YES"</programlisting>

    <para>Wie dort angegeben, wird das Modul durch die Zeile
      <literal>if_ath_load="YES"</literal> in der Datei
      <filename>/boot/loader.conf</filename> dynamisch beim Systemstart
      geladen.</para>

    <para>Allerdings gibt es in manchen Fällen kein dazugehöriges
      Modul.  Das gilt insbesondere für bestimmte Teilsysteme und sehr
      wichtige Treiber.  Beispielsweise ist das
      Fast File System (<acronym>FFS</acronym>) eine notwendige Kerneloption,
      genauso wie die Netzwerkunterstützung (INET).  Die einzige
      Möglichkeit, herauszufinden, ob ein Treiber benötigt ist,
      ist die Überprüfung des jeweiligen Moduls.</para>

    <warning>
      <para>Es ist erstaunlich einfach, einen defekten Kernel zu erhalten
        (beispielsweise durch das Entfernen der eingebauten
        Unterstützung für ein Gerät oder einer Kerneloption).
        Wenn beispielsweise der &man.ata.4;-Treiber aus der
        Kernelkonfigurationsdatei entfernt wird, kann ein
        System, das den <acronym>ATA</acronym>-Festplattentreiber
        benötigt, nicht mehr starten, ohne dass Sie das entsprechende
        Kernelmodul durch einen Eintrag in <filename>loader.conf</filename>
        aufnehmen.  Wenn Sie nicht sicher sind, wie Sie vorgehen sollen,
        überprüfen Sie zuerst das Modul.  Im Zweifelsfall belassen
        Sie die Unterstützung für ein bestimmtes Gerät
        besser im Kernel.</para>
    </warning>
  </sect1>

  <sect1 xml:id="kernelconfig-building">
    <title>Erstellen und Installation eines angepassten
      Kernels</title>

    <note>
      <para>Sie benötigen den kompletten Quellcodebaum, um den
	Kernel zu bauen.</para>
    </note>

    <indexterm>
      <primary>Kernel</primary>
      <secondary>Erstellen und Installation</secondary>
    </indexterm>

    <para>Zuerst erläutern wir die Verzeichnisstruktur, in der der
      Kernel gebaut wird.  Die im Folgenden genannten Verzeichnisse sind
      relativ zum Verzeichnis
      <filename>/usr/src/sys</filename>
      angegeben, das Sie auch über den Pfad
      <filename>/sys</filename> erreichen können.  Es existieren
      mehrere Unterverzeichnisse, die bestimmte Teile des Kernels
      darstellen, aber die für uns wichtigsten sind
      <filename>arch/conf</filename>, in dem
      Sie die Konfigurationsdatei für den angepassten Kernel
      erstellen werden, und <filename>compile</filename>, in dem der Kernel
      gebaut wird.  <replaceable>arch</replaceable> kann entweder
      <filename>i386</filename>,
      <filename>amd64</filename>, <filename>ia64</filename>,
      <filename>powerpc</filename>, <filename>sparc64</filename> oder
      <filename>pc98</filename> (eine in Japan beliebte Architektur) sein.
      Alles in diesen Verzeichnissen ist nur für die jeweilige
      Architektur relevant.  Der Rest des Codes ist
      maschinenunabhängig und für alle
      Plattformen, auf die &os; portiert werden kann, gleich.
      Beachten Sie die Verzeichnisstruktur, die jedem unterstützten
      Gerät, jedem Dateisystem und jeder Option ein eigenes
      Verzeichnis zuordnet.</para>

    <para>Die Beispiele in diesem Kapitel verwenden ein
      i386-System.  Wenn Sie ein anderes System benutzen,
      passen Sie bitte die Pfade entsprechend der Architektur
      des Systems an.</para>

    <note>
      <para>Falls Sie kein <filename>/usr/src/</filename>-Verzeichnis
	vorfinden (oder dieses leer ist), so sind die Quellen nicht
	installiert.  Der einfachste Weg, dies nachzuholen, ist
	<command>sysinstall</command> als <systemitem class="username">root</systemitem>
        auszuführen.  Dort wählen Sie
	<guimenuitem>Configure</guimenuitem>, dann
	<guimenuitem>Distributions</guimenuitem>, dann
	<guimenuitem>src</guimenuitem>, und schließlich
	<guimenuitem>All</guimenuitem>.  Falls nicht vorhanden, sollten
	Sie auch noch einen symbolischen Link auf
	<filename>/usr/src/sys/</filename> anlegen:</para>

      <screen>&prompt.root; <userinput>ln -s /usr/src/sys /sys</userinput></screen>
    </note>

    <para>Als nächstes wechseln sie in das Verzeichnis
      <filename>arch/conf</filename>
      und kopieren die Konfigurationsdatei
      <filename>GENERIC</filename> in eine Datei, die den
      Namen Ihres Kernels trägt.  Zum Beispiel:</para>

    <screen>&prompt.root; <userinput>cd /usr/src/sys/i386/conf</userinput>
&prompt.root; <userinput>cp GENERIC MYKERNEL</userinput></screen>

    <para>Traditionell ist der Name des Kernels immer in Großbuchstaben.
      Wenn Sie mehrere &os; mit unterschiedlicher Hardware warten, ist
      es nützlich, wenn Sie Konfigurationsdatei nach dem Hostnamen der
      Maschinen benennen.  Im Beispiel verwenden wir den Namen
      <filename>MYKERNEL</filename>.</para>

    <tip>
      <para>Es ist nicht zu empfehlen die Konfigurationsdatei direkt
        unterhalb von <filename>/usr/src</filename> abzuspeichern.
	Wenn Sie Probleme haben, könnten Sie der Versuchung
	erliegen, <filename>/usr/src</filename>
	einfach zu löschen und wieder von vorne anzufangen.
	Wenn Sie so vorgehen, werden Sie kurz darauf merken,
	dass Sie soeben Ihre Kernelkonfigurationsdatei
	gelöscht haben.</para>

      <para>Editieren Sie immer eine Kopie von <filename>GENERIC</filename>.
	Änderungen an <filename>GENERIC</filename> können
	verloren gehen, wenn der
	<link linkend="updating-upgrading">Quellbaum aktualisiert</link>
	wird.</para>

      <para>Sie sollten die Konfigurationsdatei an anderer Stelle
	aufheben und im Verzeichnis
	<filename>i386</filename>
	einen Link auf die Datei erstellen.</para>

      <para>Beispiel:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/sys/i386/conf</userinput>
&prompt.root; <userinput>mkdir /root/kernels</userinput>
&prompt.root; <userinput>cp GENERIC /root/kernels/MYKERNEL</userinput>
&prompt.root; <userinput>ln -s /root/kernels/MYKERNEL</userinput></screen>
    </tip>

    <para>Jetzt editieren Sie
      <filename>MYKERNEL</filename> mit einem
      Texteditor Ihres Vertrauens.  Wenn Sie gerade neu anfangen, ist Ihnen
      vielleicht nur der <application>vi</application> Editor bekannt,
      der allerdings zu komplex ist, um hier erklärt zu werden.
      Er wird aber in vielen Büchern aus der <link linkend="bibliography">
	Bibliographie</link> gut erklärt.  &os; bietet aber auch
      einen leichter zu benutzenden Editor, den <application>ee</application>
      an, den Sie, wenn Sie Anfänger sind, benutzen sollten.  Sie
      können die Kommentare am Anfang der Konfigurationsdatei
      ändern, um die Änderungen gegenüber
      <filename>GENERIC</filename> zu dokumentieren.</para>

    <indexterm><primary>SunOS</primary></indexterm>

    <para>Falls Sie schon einmal einen Kernel unter &sunos; oder einem
      anderen BSD kompiliert haben, werden Sie diese Konfigurationsdatei
      bereits kennen.  Wenn Sie mit einem anderen Betriebssystem wie DOS
      vertraut sind, könnte die <filename>GENERIC</filename>
      Konfigurationsdatei Sie verschrecken.  In diesen Fall sollten Sie
      den Beschreibungen im Abschnitt über die
      <link linkend="kernelconfig-config">Konfigurationsdatei</link>
      langsam und vorsichtig folgen.</para>

    <note>
      <para>Wenn Sie die <link linkend="updating-upgrading">&os; Quellen
          synchronisieren</link>, sollten Sie immer, bevor Sie etwas
	verändern, <filename>/usr/src/UPDATING</filename>
	durchlesen.  Diese Datei enthält alle wichtigen Informationen,
	die Sie beim Aktualisieren beachten müssen.
        Da <filename>/usr/src/UPDATING</filename> immer zu Ihrer Version
	der &os; Quellen passt, sind die Informationen dort genauer,
	als in diesem Handbuch.</para>
    </note>

    <para>Nun müssen Sie die Kernelquellen kompilieren.</para>

    <procedure>
      <title>Den Kernel bauen</title>

      <note>
	<para>Sie benötigen den kompletten Quellcodebaum, um den
	  Kernel zu bauen.</para>
      </note>

      <step>
	<para>Wechseln Sie in das Verzeichnis <filename>/usr/src</filename>:</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>
      </step>

      <step>
	<para>Kompilieren Sie den neuen Kernel:</para>

	<screen>&prompt.root; <userinput>make buildkernel KERNCONF=MYKERNEL</userinput></screen>
      </step>

      <step>
	<para>Installieren Sie den neuen Kernel:</para>

	<screen>&prompt.root; <userinput>make installkernel KERNCONF=MYKERNEL</userinput></screen>
      </step>
    </procedure>

    <tip>
      <para>In der Voreinstellung werden beim Bau eines angepassten
	Kernels stets <emphasis>alle</emphasis> Kernelmodule neu gebaut.
	Wollen Sie Ihren Kernel schneller bauen oder nur bestimmte
	Module bauen, sollten Sie <filename>/etc/make.conf</filename>
	anpassen, bevor Sie Ihren Kernel bauen:</para>

      <programlisting>MODULES_OVERRIDE = linux acpi sound/sound sound/driver/ds1 ntfs</programlisting>

      <para>Wenn Sie diese Variable setzen, werden ausschließlich
	die hier angegebenen Module gebaut (und keine anderen).</para>

      <programlisting>WITHOUT_MODULES = linux acpi sound ntfs</programlisting>

      <para>Durch das Setzen dieser Variable werden werden alle
	Module auf oberster Ebene bis auf die angegebenen gebaut.  Weitere
	Variablen, die beim Bau eines Kernels von Interesse sein könnten,
	finden Sie in &man.make.conf.5;.</para>
    </tip>

    <indexterm>
      <primary>
	<filename>/boot/kernel.old</filename>
      </primary>
    </indexterm>

    <para>Der neue Kernel wird im Verzeichnis
      <filename>/boot/kernel</filename>, genauer
      unter <filename>/boot/kernel/kernel</filename> abgelegt,
      während der alte Kernel nach
      <filename>/boot/kernel.old/kernel</filename> verschoben wird.
      Um den neuen Kernel zu benutzen, sollten Sie Ihren Rechner
      jetzt neu starten.  Falls etwas schief geht, sehen Sie
      bitte in dem Abschnitt zur <link linkend="kernelconfig-trouble">
      Fehlersuche</link> am Ende dieses Kapitels nach.  Dort sollten Sie
      auch unbedingt den Abschnitt lesen, der erklärt, was zu tun
      ist, <link linkend="kernelconfig-noboot">wenn der neue Kernel nicht
      startet</link>.</para>

    <note>
      <para>Im Verzeichnis <filename>/boot</filename> werden andere
	Dateien, die zum Systemstart benötigt werden, wie der
	Boot-Loader (&man.loader.8;) und dessen Konfiguration, abgelegt.
	Module von Fremdherstellern oder angepasste Module
	werden in <filename>/boot/kernel</filename>
	abgelegt.  Beachten Sie bitte, dass diese Module immer
	zu dem verwendeten Kernel passen müssen.  Module,
	die nicht zu dem verwendeten Kernel passen,
	gefährden die Stabilität des Systems.</para>
    </note>
  </sect1>

  <sect1 xml:id="kernelconfig-config">
    <info><title>Die Kernelkonfigurationsdatei</title>
      <authorgroup>
        <author><personname><firstname>Joel</firstname><surname>Dahl</surname></personname><contrib>Aktualisiert von </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>Kernel</primary>
      <secondary>NOTES</secondary>
    </indexterm>

    <indexterm>
      <primary>NOTES</primary>
    </indexterm>

    <indexterm>
      <primary>Kernel</primary>
      <secondary>Konfigurationsdatei</secondary>
    </indexterm>

    <para>Das Format der Konfigurationsdatei ist recht einfach.  Jede Zeile
      enthält ein Schlüsselwort und ein oder mehrere Argumente.
      Eine Zeile, die von einen <literal>#</literal> eingeleitet wird, gilt
      als Kommentar und wird ignoriert.  Die folgenden Abschnitte
      beschreiben jedes Schlüsselwort in der Reihenfolge, in der es
      in <filename>GENERIC</filename> auftaucht.
      <anchor xml:id="kernelconfig-options"/> Eine ausführliche Liste aller
      Optionen mit detaillierten Erklärungen finden Sie in der
      Konfigurationsdatei <filename>NOTES</filename>, die sich in demselben
      Verzeichnis wie die Datei <filename>GENERIC</filename> befindet.
      Von der Architektur unabhängige Optionen sind in
      der Datei <filename>/usr/src/sys/conf/NOTES</filename>
      aufgeführt.</para>

    <para>Es ist möglich, eine <literal>include</literal>-Anweisung
      in die Kernelkonfigurationsdatei aufzunehmen.
      Diese erlaubt das lokale Einfügen von anderen Konfigurationsdateien
      in die aktuelle, was es einfacher macht, kleinere Änderungen an
      einer existierenden Datei zu vollziehen.  Wenn Sie beispielsweise einen
      <filename>GENERIC</filename>-Kernel mit nur einer kleinen Anzahl von
      zusätzlichen Optionen und Treibern benötigen, brauchen Sie
      mit den folgenden Zeilen nur ein kleines Delta im Vergleich zu GENERIC
      anpassen:</para>

    <programlisting>include GENERIC
ident MYKERNEL

options         IPFIREWALL
options         DUMMYNET
options         IPFIREWALL_DEFAULT_TO_ACCEPT
options         IPDIVERT
</programlisting>

    <para>Für viele Administratoren bietet dieses Modell entscheidende
      Vorteile über das bisherige Erstellen von Konfigurationsdateien von
      Grund auf: die lokalen Konfigurationdateien enthalten auch nur die
      lokalen Unterschiede zu einem <filename>GENERIC</filename>-Kernel und
      sobald Aktulaisierungen durchgeführt werden, können neue
      Eigenschaften, die zu <filename>GENERIC</filename> hinzugefügt
      werden, auch dem lokalen Kernel angehängt werden, es sei denn, es
      wird durch <literal>nooptions</literal> oder <literal>nodevice</literal>
      verhindert.  Der übrige Teil dieses Kapitels behandelt die Inhalte
      einer typischen Konfigurationsdatei und die Rolle, die unterschiedliche
      Optionen und Geräte dabei spielen.</para>

    <note>
      <para>Um einen Kernel mit allen möglichen Optionen zu bauen
	beispielsweise für Testzwecke), führen Sie als
	<systemitem class="username">root</systemitem> die folgenden Befehle aus:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/sys/i386/conf &amp;&amp; make LINT</userinput></screen>
    </note>

    <indexterm>
      <primary>Kernel</primary>
      <secondary>Konfigurationsdatei</secondary>
    </indexterm>

    <para>Das folgende Beispiel zeigt eine <filename>GENERIC</filename>
      Konfigurationsdatei, die, wo notwendig, zusätzliche Kommentare
      enthält.  Sie sollte der Datei
      <filename>/usr/src/sys/i386/conf/GENERIC</filename>
      auf Ihrem System sehr ähnlich sein.</para>

    <indexterm>
      <primary>Kerneloptionen</primary>
      <secondary>machine</secondary>
    </indexterm>

    <programlisting>machine		i386</programlisting>

    <para>Gibt die Architektur der Maschine an und muss entweder
      <literal>amd64</literal>,
      <literal>i386</literal>, <literal>ia64</literal>,
      <literal>pc98</literal>, <literal>powerpc</literal>
      oder <literal>sparc64</literal> sein.</para>

    <indexterm>
      <primary>Kerneloptionen</primary>
      <secondary>cpu</secondary>
    </indexterm>

    <programlisting>cpu          I486_CPU
cpu          I586_CPU
cpu          I686_CPU</programlisting>

    <para>Die vorigen Zeilen geben den Typ der CPU Ihres Systems an.  Sie
      können mehrere CPU Typen angeben, wenn Sie sich zum Beispiel
      nicht sicher sind, ob Sie <literal>I586_CPU</literal> oder
      <literal>I686_CPU</literal> benutzen sollen.  Für einen
      angepassten Kernel ist es aber am besten, wenn Sie nur die CPU
      angeben, die sich in der Maschine befindet.  Der CPU-Typ wird
      in den Boot-Meldungen ausgegeben, die in der Datei
      <filename>/var/run/dmesg.boot</filename> gespeichert sind.</para>

    <indexterm>
      <primary>Kerneloptionen</primary>
      <secondary>ident</secondary>
    </indexterm>

    <programlisting>ident          GENERIC</programlisting>

    <para>Gibt den Namen Ihres Kernels an.  Hier sollten Sie den Namen
      einsetzen, den Sie Ihrer Konfigurationsdatei gegeben haben.  In
      unserem Beispiel ist das <literal>MYKERNEL</literal>.  Der Wert, den
      Sie <literal>ident</literal> zuweisen, wird beim Booten des neuen
      Kernels ausgegeben.  Wenn Sie den Kernel von Ihrem normal verwendeten
      Kernel unterscheiden wollen, weil Sie zum Beispiel einen Kernel zum
      Testen bauen, ist es nützlich, hier einen anderen Namen
      anzugeben.</para>

    <programlisting>#To statically compile in device wiring instead of /boot/device.hints
#hints          "GENERIC.hints"         # Default places to look for devices.</programlisting>

    <para>Unter &os; werden Geräte mit &man.device.hints.5;
      konfiguriert.  In der Voreinstellung überprüft
      &man.loader.8; beim Systemstart die Datei
      <filename>/boot/device.hints</filename>.  Die Option
      <literal>hints</literal> erlaubt es, die Gerätekonfiguration
      statisch in den Kernel einzubinden, sodass die Datei
      <filename>device.hints</filename> in <filename>/boot</filename>
      nicht benötigt wird.</para>

    <!-- XXX: Add a comment here that explains when compiling
	      hints into the kernel is a good idea and why. -->

    <programlisting>makeoptions     DEBUG=-g          # Build kernel with gdb(1) debug symbols</programlisting>

    <para>Der normale Bauprozess von FreeBSD erstellt nur dann einen
      Kernel, der Debugging-Informationen enthält, wenn Sie die
      Option <option>-g</option> von &man.gcc.1; aktivieren.</para>

    <programlisting>options          SCHED_ULE        # ULE scheduler</programlisting>

    <para>Der voreingestellte Scheduler von &os;.  Ändern Sie
      diesen Wert nicht!</para>

    <programlisting>options          PREEMPTION        # Enable kernel thread preemption</programlisting>

    <para>Erlaubt es Kernelthreads, vor Threads eigentlich höherer
      Prioritält ausgeführt zu werden.  Die Interaktivitält
      des Systems wird dadurch erhölt.  Interrupt-Threads werden
      dabei bevorzugt ausgeführt.</para>

    <programlisting>options          INET              # InterNETworking</programlisting>

    <para>Netzwerkunterstützung.  Auch wenn Sie nicht planen, den
      Rechner mit einem Netzwerk zu verbinden, sollten Sie diese Option
      aktiviert lassen.  Die meisten Programme sind mindestens auf die
      Loopback Unterstützung (Verbindungen mit sich selbst)
      angewiesen.  Damit ist diese Option im Endeffekt
      notwendig.</para>

    <programlisting>options          INET6             # IPv6 communications protocols</programlisting>

    <para>Aktiviert die Unterstützung für das IPv6
      Protokoll.</para>

    <programlisting>options          FFS               # Berkeley Fast Filesystem</programlisting>

    <para>Das Dateisystem für Festplatten.  Wenn Sie von einer
      Festplatte booten wollen, lassen Sie diese Option aktiviert.</para>

    <programlisting>options          SOFTUPDATES       # Enable FFS Soft Updates support</programlisting>

    <para>Mit dieser Option wird die Unterstützung für Soft
      Updates, die Schreibzugriffe beschleunigen, in den Kernel
      eingebunden.  Auch wenn die Funktion im Kernel ist, muss
      sie für einzelne Dateisysteme explizit aktiviert werden.
      Überprüfen Sie mit &man.mount.8;, ob die Dateisysteme
      Soft Updates benutzen.  Wenn die Option
      <literal>soft-updates</literal> nicht aktiviert ist, können
      Sie die Option nachträglich mit &man.tunefs.8; aktivieren.
      Für neue Dateisysteme können Sie Option beim Anlegen mit
      &man.newfs.8; aktivieren.</para>

    <programlisting>options          UFS_ACL           # Support for access control lists</programlisting>

    <para>Diese Option aktiviert die Unterstützung für
      Zugriffskontrolllisten (<acronym>ACL</acronym>).  Die
      <acronym>ACL</acronym>s hängen von
      erweiterten Attributen und <acronym>UFS2</acronym> ab,
      eine genaue Beschreibung finden
      Sie in <xref linkend="fs-acl"/>.  Die Zugriffskontrolllisten sind in
      der Voreinstellung aktiviert und sollten auch nicht deaktiviert
      werden, wenn Sie schon einmal auf einem Dateisystem verwendet wurden,
      da dies die Zugriffsrechte auf Dateien in unvorhersehbarer Art und
      Weise ändern kann.</para>

    <programlisting>options          UFS_DIRHASH       # Improve performance on big directories</programlisting>

    <para>Diese Option steigert die Geschwindigkeit von Plattenzugriffen
      auf großen Verzeichnissen.  Dadurch verbraucht das System etwas
      mehr Speicher als vorher.  Für stark beschäftigte Server
      oder Arbeitsplatzrechner sollten Sie diese Option aktiviert lassen.
      Auf kleineren Systemen, bei denen Speicher eine kostbare Ressource
      darstellt oder Systemen, auf denen die Geschwindigkeit der
      Plattenzugriffe nicht wichtig ist, wie Firewalls, können Sie
      diese Option abstellen.</para>

    <programlisting>options          MD_ROOT           # MD is a potential root device</programlisting>

    <para>Diese Option aktiviert die Unterstüztung für
      ein Root-Dateisystem auf einem speicherbasierten Laufwerk
      (RAM-Disk).</para>

    <indexterm>
      <primary>Kerneloptionen</primary>
      <secondary>NFS</secondary>
    </indexterm>

    <indexterm>
      <primary>Kerneloptionen</primary>
      <secondary>NFS_ROOT</secondary>
    </indexterm>

    <programlisting>options          NFSCLIENT         # Network Filesystem Client
options          NFSSERVER         # Network Filesystem Server
options          NFS_ROOT          # NFS usable as /, requires NFSCLIENT</programlisting>

    <para>Das Network Filesystem.  Wenn Sie keine Partitionen von einem
      &unix; File-Server über TCP/IP einhängen wollen, können
      Sie diese Zeile auskommentieren.</para>

    <indexterm>
      <primary>Kerneloptionen</primary>
      <secondary>MSDOSFS</secondary>
    </indexterm>

    <programlisting>options          MSDOSFS           # MSDOS Filesystem</programlisting>

    <para>Das &ms-dos; Dateisystem.  Sie können diese Zeile
      auskommentieren, wenn Sie nicht vorhaben, eine DOS-Partition
      beim Booten einzuhängen.  Das nötige Modul wird
      ansonsten automatisch geladen, wenn Sie das erste Mal eine
      DOS-Partition einhängen.  Außerdem können
      Sie mit den ausgezeichneten
      <package>emulators/mtools</package> aus
      der Ports-Sammlung auf DOS-Floppies zugreifen, ohne diese
      an- und abhängen zu müssen (<literal>MSDOSFS</literal>
      wird in diesem Fall nicht benötigt).</para>

    <programlisting>options          CD9660            # ISO 9660 Filesystem</programlisting>

    <para>Das ISO 9660 Dateisystem für CD-ROMs.  Sie können diese
      Zeile auskommentieren, wenn Sie kein CD-ROM-Laufwerk besitzen oder
      nur ab und an CDs einhängen.  Das Modul wird automatisch
      geladen, sobald Sie das erste Mal eine CD einhängen.  Für
      Audio-CDs benötigen Sie dieses Dateisystem nicht.</para>

    <programlisting>options          PROCFS            # Process filesystem (requires PSEUDOFS)</programlisting>

    <para>Das Prozessdateisystem.  Dies ist ein Pseudo-Dateisystem,
      das auf <filename>/proc</filename> eingehangen wird und es Programmen
      wie &man.ps.1; erlaubt, mehr Informationen über laufende Prozesse
      auszugeben.  <literal>PROCFS</literal> sollte von &os; nicht mehr
      benötigt werden, da die meisten Debug- und
      Überwachungs-Werkzeuge nicht mehr darauf angewiesen sind.
      Daher wird das Prozessdateisystem auch nicht mehr automatisch
      in das System eingebunden.</para>

    <programlisting>options          PSEUDOFS          # Pseudo-filesystem framework</programlisting>

    <para>Kernel, die <literal>PROCFS</literal> verwenden, müssen
      auch die Option <literal>PSEUDOFS</literal> verwenden.</para>

    <programlisting>options          GEOM_PART_GPT          # GUID Partition Tables.</programlisting>

    <para>Diese Option ermöglicht eine große Anzahl
      Partitionen auf einem einzelnen Laufwerk.</para>

    <programlisting>options          COMPAT_43         # Compatible with BSD 4.3 [KEEP THIS!]</programlisting>

    <para>Stellt die Kompatibilität zu 4.3BSD sicher.  Belassen Sie
      diese Option, da sich manche Programme recht sonderbar verhalten
      werden, wenn Sie diese auskommentieren.</para>

    <programlisting>options          COMPAT_FREEBSD4   # Compatible with FreeBSD4</programlisting>

    <para>Diese Option stellt sicher, dass Anwendungen, die auf
      älteren &os;
      Versionen übersetzt wurden und alte Systemaufrufe verwenden,
      noch lauffähig sind.  Wir empfehlen, diese Option auf allen
      &i386;-Systemen zu verwenden, auf denen vielleicht noch
      ältere Anwendungen laufen sollen.  Auf Plattformen, die erst ab
      &os;&nbsp;5.0 unterstützt werden (wie ia64 und &sparc;),
      wird diese Option nicht benötigt.</para>

    <programlisting>options          COMPAT_FREEBSD5   # Compatible with &os;5</programlisting>

    <para>Diese Option wird ab &os;&nbsp;6.X benötigt, um Programme,
      die unter &os;&nbsp;5.X-Versionen mit &os;&nbsp;5.X-Systemaufrufen
      kompiliert wurden, unter &os;&nbsp;6.X ausführen zu
      können.</para>

    <programlisting>options          COMPAT_FREEBSD6   # Compatible with &os;6</programlisting>

    <para>Diese Option wird ab &os;&nbsp;7.X benötigt, um Programme,
      die unter &os;&nbsp;6.X-Versionen mit &os;&nbsp;6.X-Systemaufrufen
      kompiliert wurden, unter &os;&nbsp;7.X ausführen zu
      können.</para>

    <programlisting>options          COMPAT_FREEBSD7   # Compatible with &os;7</programlisting>

    <para>Diese Option wird ab &os;&nbsp;8.X benötigt, um Programme,
      die unter &os;&nbsp;7.X-Versionen mit &os;&nbsp;7.X-Systemaufrufen
      kompiliert wurden, unter &os;&nbsp;8.X ausführen zu
      können.</para>

    <programlisting>options          SCSI_DELAY=5000  # Delay (in ms) before probing SCSI</programlisting>

    <para>Dies weist den Kernel an, 5&nbsp;Sekunden zu warten, bevor er
      anfängt nach SCSI-Geräten auf dem System zu suchen.  Wenn
      Sie nur IDE-Geräte besitzen, können Sie die Anweisung
      ignorieren.  Sie können versuchen, den Wert zu
      senken, um den Startvorgang zu beschleunigen.  Wenn
      &os; dann Schwierigkeiten hat, Ihre SCSI-Geräte zu erkennen,
      sollten Sie den Wert natürlich wieder erhöhen.</para>

    <programlisting>options          KTRACE            # ktrace(1) support</programlisting>

    <para>Dies schaltet die Kernel-Prozessverfolgung
      (engl. <foreignphrase>kernel process tracing</foreignphrase>) ein,
      die sehr nützlich bei der Fehlersuche ist.</para>

    <programlisting>options          SYSVSHM           # SYSV-style shared memory</programlisting>

    <para>Diese Option aktiviert die Unterstützung für
      System&nbsp;V Shared-Memory.  Die XSHM-Erweiterung von X
      benötigt diese Option und viele Graphik-Programme
      werden die Erweiterung automatisch benutzen und schneller
      laufen.  Wenn Sie X benutzen, sollten Sie diese Option auf
      jeden Fall aktivieren.</para>

    <programlisting>options          SYSVMSG           # SYSV-style message queues</programlisting>

    <para>Unterstützung für System&nbsp;V Messages.
      Diese Option vergrößert den Kernel nur um
      einige hundert Bytes.</para>

    <programlisting>options          SYSVSEM           # SYSV-style semaphores</programlisting>

    <para>Unterstützung für System&nbsp;V Semaphoren.
      Dies wird selten gebraucht, vergrößert aber den
      Kernel nur um einige hundert Bytes.</para>

    <note>
      <para>Die Option <option>-p</option> des Kommandos
	&man.ipcs.1; zeigt Programme an, die diese System&nbsp;V
	Erweiterungen benutzen.</para>
    </note>

    <programlisting>options 	     _KPOSIX_PRIORITY_SCHEDULING # POSIX P1003_1B real-time extensions</programlisting>

    <para>Echtzeit-Erweiterungen, die 1993 zu &posix;
      hinzugefügt wurden.  Bestimmte Programme wie
      <application>&staroffice;</application> benutzen
      diese Erweiterungen.</para>

    <programlisting>options          KBD_INSTALL_CDEV  # install a CDEV entry in /dev</programlisting>

    <para>Diese Option erstellt für die Tastatur einen
      Eintrag im Verzeichnis <filename>/dev</filename>.</para>

    <programlisting>options          ADAPTIVE_GIANT    # Giant mutex is adaptive.</programlisting>

    <para>Giant ist der Name einer Sperre (Mutex) die viele
      Kernel-Ressourcen schützt.  Heutzutage ist Giant ein
      unannehmbarer Engpass, der die Leistung eines Systems
      beeinträchtigt.  Daher wird Giant durch Sperren ersetzt,
      die einzelne Ressourcen schützen.  Die Option
      <literal>ADAPTIVE_GIANT</literal> fügt Giant zu den
      Sperren hinzu, auf die gewartet werden kann.  Ein Thread,
      der die Sperre Giant von einem anderen Thread benutzt
      vorfindet, kann nun weiterlaufen und auf die Sperre Giant
      warten.  Früher wäre der Prozess in den schlafenden
      Zustand (<foreignphrase>sleep</foreignphrase>) gewechselt
      und hätte darauf warten müssen, dass er wieder
      laufen kann.  Wenn Sie sich nicht sicher sind, belassen
      Sie diese Option.</para>

    <note>
      <para>Beachten Sie, dass ab &os; 8.0-RELEASE und neuer alle
	Mutexe in der Voreinstellung adaptiv sein werden, es sei denn,
	Sie werden durch das Setzen der Option
	<literal>NO_ADAPTIVE_MUTEXES</literal> explizit als
	nichtadaptiv deklariert.  Als Folge dessen ist Giant nun in
	in der Voreinstellung ebenfalls adaptiv, daher ist in diesen
	Versionen die Kerneloption <literal>ADAPTIVE_GIANT</literal>
	nicht mehr in der Kernelkonfigurationsdatei enthalten.</para>
    </note>

    <indexterm>
      <primary>Kerneloptionen</primary>
      <secondary>SMP</secondary>
    </indexterm>

    <programlisting>device          apic               # I/O APIC</programlisting>

    <para>Das apic-Gerält ermöglicht die Benutzung
      des I/O APIC für die Interrupt-Auslieferung.
      Das apic-Gerält kann mit Kerneln für
      Einprozessorsysteme und Mehrprozessorsysteme benutzt
      werden.  Kernel für Mehrprozessorsysteme benötigen
      diese Option zwingend.  Die Unterstützung für
      Mehrprozessorsysteme aktivieren Sie mit der Option
      <literal>options SMP</literal>.</para>

    <note>
      <para>Das apic-Gerät existiert nur unter der i386-Architektur,
	daher ist es sinnlos, diese Zeile unter einer anderen
	Architektur in Ihre Kernelkonfigurationsdatei aufzunehmen.</para>
    </note>

    <programlisting>device          eisa</programlisting>

    <para>Fügen Sie diese Zeile ein, wenn Sie ein EISA-Motherboard
      besitzen.  Dies aktiviert die Erkennung und Konfiguration von allen
      Geräten auf dem EISA Bus.</para>

    <programlisting>device          pci</programlisting>

    <para>Wenn Sie ein PCI-Motherboard besitzen, fügen Sie diese Zeile
      ein.  Dies aktiviert die Erkennung von PCI-Karten und die PCI-ISA
      bridge.</para>

    <programlisting># Floppy drives
device          fdc</programlisting>

    <para>Der Floppy-Controller.</para>

    <programlisting># ATA and ATAPI devices
device          ata</programlisting>

    <para>Dieser Treiber unterstützt alle ATA und ATAPI Geräte.
      Eine <literal>device ata</literal> Zeile reicht aus und der
      Kernel wird auf modernen Maschinen alle PCI ATA/ATAPI Geräte
      entdecken.</para>

    <programlisting>device          atadisk                 # ATA disk drives</programlisting>

    <para>Für ATA-Plattenlaufwerke brauchen Sie diese Zeile zusammen
      mit <literal>device ata</literal>.</para>

    <programlisting>device          ataraid                 # ATA RAID drives</programlisting>

    <para>Für ATA-RAID brauchen Sie diese Zeile zusammen
      mit <literal>device ata</literal>.</para>

    <programlisting><anchor xml:id="kernelconfig-atapi"/>
device          atapicd                 # ATAPI CDROM drives</programlisting>

    <para>Zusammen mit <literal>device ata</literal> wird dies für
      ATAPI CD-ROM Laufwerke benötigt.</para>

    <programlisting>device          atapifd                 # ATAPI floppy drives</programlisting>

    <para>Zusammen mit <literal>device ata</literal> wird dies für
      ATAPI Floppy Laufwerke benötigt.</para>

    <programlisting>device          atapist                 # ATAPI tape drives</programlisting>

    <para>Zusammen mit <literal>device ata</literal> wird dies für
      ATAPI Bandlaufwerke benötigt.</para>

    <programlisting>options         ATA_STATIC_ID           # Static device numbering</programlisting>

    <para>Erzwingt eine statische Gerätenummer für
      den Controller; ohne diese Option werden die Nummern
      dynamisch zugeteilt.</para>

    <programlisting># SCSI Controllers
device          ahb        # EISA AHA1742 family
device          ahc        # AHA2940 and onboard AIC7xxx devices
options         AHC_REG_PRETTY_PRINT     # Print register bitfields in debug
                                         # output.  Adds ~128k to driver.
device          ahd        # AHA39320/29320 and onboard AIC79xx devices
options         AHD_REG_PRETTY_PRINT     # Print register bitfields in debug
                                         # output.  Adds ~215k to driver.
device          amd        # AMD 53C974 (Teckram DC-390(T))
device          isp        # Qlogic family
#device         ispfw      # Firmware for QLogic HBAs- normally a module
device          mpt        # LSI-Logic MPT-Fusion
#device         ncr        # NCR/Symbios Logic
device          sym        # NCR/Symbios Logic (newer chipsets + those of `ncr'))
device          trm        # Tekram DC395U/UW/F DC315U adapters

device          adv        # Advansys SCSI adapters
device          adw        # Advansys wide SCSI adapters
device          aha        # Adaptec 154x SCSI adapters
device          aic        # Adaptec 15[012]x SCSI adapters, AIC-6[23]60.
device          bt         # Buslogic/Mylex MultiMaster SCSI adapters

device          ncv        # NCR 53C500
device          nsp        # Workbit Ninja SCSI-3
device          stg        # TMC 18C30/18C50</programlisting>

    <para>SCSI-Controller.  Kommentieren Sie alle Controller aus, die sich
      nicht in Ihrem System befinden.  Wenn Sie ein IDE-System besitzen,
      können Sie alle Einträge entfernen.  Die Zeilen mit den
      <literal>*_REG_PRETTY_PRINT</literal>-Einträgen aktivieren
      Debugging-Optionen für die jeweiligen Treiber.</para>

    <programlisting># SCSI peripherals
device          scbus      # SCSI bus (required for SCSI)
device          ch         # SCSI media changers
device          da         # Direct Access (disks)
device          sa         # Sequential Access (tape etc)
device          cd         # CD
device          pass       # Passthrough device (direct SCSI access)
device          ses        # SCSI Environmental Services (and SAF-TE)</programlisting>

    <para>SCSI Peripheriegeräte.  Kommentieren Sie wieder alle
      Geräte aus, die Sie nicht besitzen.  Besitzer von IDE-Systemen
      können alle Einträge entfernen.</para>

    <note>
      <para>Der USB-&man.umass.4;-Treiber und einige andere
	Treiber benutzen das SCSI-Subsystem obwohl sie keine
	SCSI-Geräte sind.  Belassen Sie die SCSI-Unterstützung
	im Kernel, wenn Sie solche Treiber verwenden.</para>
    </note>

    <programlisting># RAID controllers interfaced to the SCSI subsystem
device          amr        # AMI MegaRAID
device          arcmsr     # Areca SATA II RAID
device          asr        # DPT SmartRAID V, VI and Adaptec SCSI RAID
device          ciss       # Compaq Smart RAID 5*
device          dpt        # DPT Smartcache III, IV - See NOTES for options
device          hptmv      # Highpoint RocketRAID 182x
device          hptrr      # Highpoint RocketRAID 17xx, 22xx, 23xx, 25xx
device          iir        # Intel Integrated RAID
device          ips        # IBM (Adaptec) ServeRAID
device          mly        # Mylex AcceleRAID/eXtremeRAID
device          twa        # 3ware 9000 series PATA/SATA RAID

# RAID controllers
device          aac        # Adaptec FSA RAID
device          aacp       # SCSI passthrough for aac (requires CAM)
device          ida        # Compaq Smart RAID
device          mfi        # LSI MegaRAID SAS
device          mlx        # Mylex DAC960 family
device          pst        # Promise Supertrak SX6000
device          twe        # 3ware ATA RAID</programlisting>

    <para>Unterstützte RAID Controller.  Wenn Sie keinen der
      aufgeführten Controller besitzen, kommentieren Sie die
      Einträge aus oder entfernen sie.</para>

    <programlisting># atkbdc0 controls both the keyboard and the PS/2 mouse
device          atkbdc     # AT keyboard controller</programlisting>

    <para>Der Tastatur-Controller (<literal>atkbdc</literal>) ist für
      die Ein- und Ausgabe von AT-Tastaturen und PS/2 Zeigegeräten (z.B.
      einer Maus) verantwortlich.  Dieser Controller wird vom
      Tastaturtreiber (<literal>atkbd</literal>) und dem PS/2
      Gerätetreiber (<literal>psm</literal>) benötigt.</para>

    <programlisting>device          atkbd      # AT keyboard</programlisting>

    <para>Zusammen mit dem <literal>atkbdc</literal> Controller bietet der
      <literal>atkbd</literal> Treiber Zugriff auf AT-Tastaturen.</para>

    <programlisting>device          psm        # PS/2 mouse</programlisting>

    <para>Benutzen Sie dieses Gerät, wenn Sie eine Maus mit PS/2
      Anschluss besitzen.</para>

    <programlisting>device          kbdmux        # keyboard multiplexer</programlisting>

    <para>Basisunterstützung für Tastaturmultiplexer.
      Verwenden Sie nur eine einzige Tastatur, können Sie diese
      Zeile aus Ihrer Kernelkonfigurationsdatei entfernen.</para>

    <programlisting>device          vga        # VGA video card driver</programlisting>

    <para>Der Grafikkartentreiber.</para>

    <programlisting>device          splash     # Splash screen and screen saver support</programlisting>

    <para>Zeigt einen <quote>Splash Screen</quote> beim Booten.  Diese
      Zeile wird auch von den Bildschirmschonern benötigt.</para>

    <programlisting># syscons is the default console driver, resembling an SCO console
device          sc</programlisting>

    <para><literal>sc</literal> ist in der Voreinstellung der Treiber
      für die Konsole, die der SCO-Konsole ähnelt.  Da die
      meisten bildschirmorientierten Programme auf die Konsole mit Hilfe
      einer Datenbank wie <filename>termcap</filename> zugreifen, sollte es
      keine Rolle spielen, ob Sie diesen Treiber oder
      <literal>vt</literal>, den <literal>VT220</literal> kompatiblen
      Konsolentreiber einsetzen.  Wenn Sie Probleme mit
      bildschirmorientierten Anwendungen unter dieser Konsole haben, setzen
      Sie beim Anmelden die Variable <envar>TERM</envar> auf den Wert
      <literal>VT220</literal>.</para>

    <programlisting># Enable this for the pcvt (VT220 compatible) console driver
#device          vt
#options         XSERVER          # support for X server on a vt console
#options         FAT_CURSOR       # start with block cursor</programlisting>

    <para>Der VT220 kompatible Konsolentreiber ist kompatibel zu VT100/102.
      Auf einigen Laptops, die aufgrund der Hardware inkompatibel zum
      <literal>sc</literal> Treiber sind, funktioniert dieser Treiber gut.
      Beim Anmelden sollten Sie die Variable <envar>TERM</envar> auf den
      Wert <literal>vt100</literal> setzen.  Dieser Treiber kann sich als
      nützlich erweisen, wenn Sie sich über das Netzwerk auf
      vielen verschiedenen Maschinen anmelden, da dort oft Einträge in
      <filename>termcap</filename> oder <filename>terminfo</filename>
      für das <literal>sc</literal> Gerät fehlen.  Dagegen
      sollte <literal>vt100</literal> auf jeder Plattform unterstützt
      werden.</para>

    <programlisting>device          agp</programlisting>

    <para>Fügen Sie diese Zeile ein, wenn Sie eine AGP-Karte
      besitzen.  Damit werden Motherboards mit AGP und AGP GART
      unterstützt.</para>

    <indexterm>
      <primary>APM</primary>
    </indexterm>

    <programlisting># Power management support (see NOTES for more options)
#device          apm</programlisting>

    <para>Unterstützung zur Energieverwaltung.  Diese
      Option ist nützlich für Laptops, allerdings
      ist sie in <filename>GENERIC</filename> deaktiviert.</para>

    <programlisting># Add suspend/resume support for the i8254.
device           pmtimer</programlisting>

    <para>Zeitgeber für Ereignisse der Energieverwaltung
      (APM und ACPI).</para>

    <programlisting># PCCARD (PCMCIA) support
# PCMCIA and cardbus bridge support
device          cbb               # cardbus (yenta) bridge
device          pccard            # PC Card (16-bit) bus
device          cardbus           # CardBus (32-bit) bus</programlisting>

    <para>PCMCIA Unterstützung.  Wenn Sie einen Laptop benutzen,
      brauchen Sie diese Zeile.</para>

    <programlisting># Serial (COM) ports
device          sio               # 8250, 16[45]50 based serial ports</programlisting>

    <para>Die seriellen Schnittstellen, die in der &ms-dos;-
      und &windows;-Welt <filename>COM</filename>
      genannt werden.</para>

    <note>
      <para>Wenn Sie ein internes Modem, das <filename>COM4</filename>
	benutzt, besitzen und eine serielle Schnittstelle haben,
	die auf <filename>COM2</filename> liegt, müssen
	Sie den IRQ des Modems auf 2 setzen (wegen undurchsichtigen
	technischen Gründen ist IRQ2 gleich IRQ9).  Wenn Sie
	eine serielle Multiport-Karte besitzen, entnehmen Sie bitte
	die Werte, die Sie in die Datei
	<filename>/boot/device.hints</filename> einfügen
	müssen, der Hilfeseite &man.sio.4;.  Einige Graphikkarten,
	besonders die auf S3-Chips basierten, benutzen IO-Adressen
	der Form <literal>0x*2e8</literal> und manche billige
	serielle Karten dekodieren den 16-Bit IO-Adressraum
	nicht sauber.  Dies führt zu Konflikten und blockiert
	dann die <filename>COM4</filename>-Schnittstelle.</para>

      <para>Jeder seriellen Schnittstelle muss ein eigener IRQ zugewiesen
	werden (wenn Sie eine Multiport-Karte verwenden, bei der das Teilen
	von Interrupts unterstützt wird, muss das nicht der Fall
	sein), daher können in der Voreinstellung
	<filename>COM3</filename> und <filename>COM4</filename>
	nicht benutzt werden.</para>
    </note>

    <programlisting># Parallel port
device          ppc</programlisting>

    <para>Die parallele Schnittstelle auf dem ISA Bus.</para>

    <programlisting>device          ppbus      # Parallel port bus (required)</programlisting>

    <para>Unterstützung für den Bus auf der parallelen
      Schnittstelle.</para>

    <programlisting>device          lpt        # Printer</programlisting>

    <para>Unterstützung für Drucker über die parallele
      Schnittstelle.</para>

    <note>
      <para>Sie brauchen jede der drei Zeilen, um die Unterstützung
        für einen Drucker an der parallelen Schnittstelle zu
	aktivieren.</para>
    </note>

    <programlisting>device          plip       # TCP/IP over parallel</programlisting>

    <para>Der Treiber für das Netzwerkinterface über die
      parallele Schnittstelle.</para>

    <programlisting>device          ppi        # Parallel port interface device</programlisting>

    <para>Allgemeine I/O (<quote>geek port</quote>) und IEEE1284 I/O
      Unterstützung.</para>

    <programlisting>#device         vpo        # Requires scbus and da</programlisting>

    <indexterm><primary>Zip Laufwerk</primary></indexterm>

    <para>Dies aktiviert den Treiber für ein Iomega Zip Laufwerk.
      Zusätzlich benötigen Sie noch die Unterstützung
      für <literal>scbus</literal> und <literal>da</literal>.  Die
      beste Performance erzielen Sie, wenn Sie die Schnittstelle im EPP 1.9
      Modus betreiben.</para>

    <programlisting>#device         puc</programlisting>

    <para>Aktivieren Sie diesen Treiber, wenn Sie eine serielle
      oder parallele PCI-Karte besitzen, die vom Treiber
      &man.puc.4; unterstützt wird.</para>

    <programlisting># PCI Ethernet NICs.
device          de         # DEC/Intel DC21x4x (<quote>Tulip</quote>)
device          em         # Intel PRO/1000 adapter Gigabit Ethernet Card
device          ixgb       # Intel PRO/10GbE Ethernet Card
device          txp        # 3Com 3cR990 (<quote>Typhoon</quote>)
device          vx         # 3Com 3c590, 3c595 (<quote>Vortex</quote>)</programlisting>

    <para>Verschiedene Treiber für PCI-Netzwerkkarten.  Geräte,
      die sich nicht in Ihrem System befinden, können Sie entfernen oder
      auskommentieren.</para>

    <programlisting># PCI Ethernet NICs that use the common MII bus controller code.
# NOTE: Be sure to keep the 'device miibus' line in order to use these NICs!
device          miibus     # MII bus support</programlisting>

    <para>Einige PCI 10/100 Ethernet Netzwerkkarten, besonders die, die
      MII-fähige Transceiver verwenden oder Transceiver-Steuerungen
      implementieren, die ähnlich wie MII funktionieren,
      benötigen die Unterstützung für den MII-Bus.  Die
      Zeile <literal>device miibus</literal> fügt dem Kernel die
      Unterstützung für das allgemeine miibus API und allen
      PHY-Treibern hinzu.</para>

    <programlisting>device          bce        # Broadcom BCM5706/BCM5708 Gigabit Ethernet
device          bfe        # Broadcom BCM440x 10/100 Ethernet
device          bge        # Broadcom BCM570xx Gigabit Ethernet
device          dc         # DEC/Intel 21143 and various workalikes
device          fxp        # Intel EtherExpress PRO/100B (82557, 82558)
device          lge        # Level 1 LXT1001 gigabit ethernet
device          msk        # Marvell/SysKonnect Yukon II Gigabit Ethernet
device          nge        # NatSemi DP83820 gigabit ethernet
device          nve        # nVidia nForce MCP on-board Ethernet Networking
device          pcn        # AMD Am79C97x PCI 10/100 (precedence over 'lnc')
device          re         # RealTek 8139C+/8169/8169S/8110S
device          rl         # RealTek 8129/8139
device          sf         # Adaptec AIC-6915 (<quote>Starfire</quote>)
device          sis        # Silicon Integrated Systems SiS 900/SiS 7016
device          sk         # SysKonnect SK-984x &amp; SK-982x gigabit Ethernet
device          ste        # Sundance ST201 (D-Link DFE-550TX)
device          stge       # Sundance/Tamarack TC9021 gigabit Ethernet
device          ti         # Alteon Networks Tigon I/II gigabit Ethernet
device          tl         # Texas Instruments ThunderLAN
device          tx         # SMC EtherPower II (83c170 <quote>EPIC</quote>)
device          vge        # VIA VT612x gigabit ethernet
device          vr         # VIA Rhine, Rhine II
device          wb         # Winbond W89C840F
device          xl         # 3Com 3c90x (<quote>Boomerang</quote>, <quote>Cyclone</quote>)</programlisting>

    <para>Treiber, die den MII Bus Controller Code benutzen.</para>

    <programlisting># ISA Ethernet NICs.  pccard NICs included.
device          cs         # Crystal Semiconductor CS89x0 NIC
# 'device ed' requires 'device miibus'
device          ed         # NE[12]000, SMC Ultra, 3c503, DS8390 cards
device          ex         # Intel EtherExpress Pro/10 and Pro/10+
device          ep         # Etherlink III based cards
device          fe         # Fujitsu MB8696x based cards
device          ie         # EtherExpress 8/16, 3C507, StarLAN 10 etc.
device          lnc        # NE2100, NE32-VL Lance Ethernet cards
device          sn         # SMC's 9000 series of Ethernet chips
device          xe         # Xircom pccard Ethernet

# ISA devices that use the old ISA shims
#device         le</programlisting>

    <para>Treiber für ISA Ethernet Karten.  Schauen Sie in
      <filename>/usr/src/sys/i386/conf/NOTES</filename>
      nach, um zu sehen, welche Karte von welchem Treiber
      unterstützt wird.</para>

    <programlisting># Wireless NIC cards
device          wlan       # 802.11 support</programlisting>

    <para>Generische 802.11-Unterstützung.  Diese Zeile wird
      unbedingt benötigt, wenn Sie WLAN nutzen wollen.</para>

    <programlisting>device          wlan_wep        # 802.11 WEP support
device          wlan_ccmp       # 802.11 CCMP support
device          wlan_tkip       # 802.11 TKIP support</programlisting>

    <para>Krypto-Unterstützung für 802.11-Geräte.  Sie
      benötigen diese Zeilen, wenn Sie Ihr drahtloses Netzwerk
      verschlüsseln und die 802.11-Sicherheitsprotokolle
      einsetzen wollen.</para>

    <programlisting>device          an              # Aironet 4500/4800 802.11 wireless NICs
device          ath             # Atheros pci/cardbus NIC's
device          ath_hal         # Atheros HAL (Hardware Access Layer)
device          ath_rate_sample # SampleRate tx rate control for ath
device          awi        # BayStack 660 and others
device          ral        # Ralink Technology RT2500 wireless NICs.
device          wi         # WaveLAN/Intersil/Symbol 802.11 wireless NICs.
#device         wl         # Older non 802.11 Wavelan wireless NIC.</programlisting>

    <para>Treiber für drahtlose Netzwerkkarten (WLAN).</para>

    <programlisting># Pseudo devices
device   loop          # Network loopback</programlisting>

    <para>Das TCP/IP Loopback Device.  Wenn Sie eine Telnet oder FTP
      Verbindung zu <systemitem>localhost</systemitem> (alias <systemitem class="ipaddress">127.0.0.1</systemitem>) aufbauen, erstellen Sie eine
      Verbindung zu sich selbst durch dieses Device.  Die Angabe
      dieser Option ist <emphasis>verpflichtend</emphasis>.</para>

    <programlisting>device   random        # Entropy device</programlisting>

    <para>Kryptographisch sicherer Zufallszahlengenerator.</para>

    <programlisting>device   ether         # Ethernet support</programlisting>

    <para><literal>ether</literal> brauchen Sie nur, wenn Sie eine
      Ethernet-Karte besitzen.  Der Treiber unterstützt das
      Ethernet-Protokoll.</para>

    <programlisting>device   sl            # Kernel SLIP</programlisting>

    <para><literal>sl</literal> aktiviert die SLIP-Unterstützung.
      SLIP ist fast vollständig von PPP verdrängt
      worden, da letzteres leichter zu konfigurieren, besser
      geeignet für Modem zu Modem Kommunikation und
      mächtiger ist.</para>

    <programlisting>device   ppp           # Kernel PPP</programlisting>

    <para>Dies ist Kernel Unterstützung für
      PPP-Wählverbindungen.  Es existiert auch eine
      PPP-Version im Userland, die den <literal>tun</literal>
      Treiber benutzt.  Die Userland-Version ist flexibler
      und bietet mehr Option wie die Wahl auf Anforderung.</para>

    <programlisting>device   tun           # Packet tunnel.</programlisting>

    <para>Dies wird vom der Userland PPP benutzt.  Die
      <replaceable>Zahl</replaceable> hinter <literal>tun</literal> gibt
      die Anzahl der unterstützten gleichzeitigen Verbindungen an.
      Weitere Informationen erhalten Sie im Abschnitt
      <link linkend="userppp">PPP</link>
      dieses Handbuchs.</para>

    <programlisting><anchor xml:id="kernelconfig-ptys"/>
device   pty           # Pseudo-ttys (telnet etc)</programlisting>

    <para>Dies ist ein <quote>Pseudo-Terminal</quote> oder simulierter
      Login-Terminal.  Er wird von einkommenden <command>telnet</command>
      und <command>rlogin</command> Verbindungen,
      <application>xterm</application> und anderen Anwendungen wie
      <application>Emacs</application> benutzt.</para>

    <programlisting>device   md            # Memory <quote>disks</quote></programlisting>

    <para>Pseudo-Gerät für Speicher-Laufwerke.</para>

    <programlisting>device   gif           # IPv6 and IPv4 tunneling</programlisting>

    <para>Dieses Gerät tunnelt IPv6 über IPv4, IPv4 über
      IPv6, IPv4 über IPv4 oder IPv6 über IPv6.
      Das Gerät <literal>gif</literal> kann die Anzahl der
      benötigten Geräte automatisch bestimmen
      (<quote>auto-cloning</quote>).</para>

    <programlisting>device   faith         # IPv6-to-IPv4 relaying (translation)</programlisting>

    <para>Dieses Pseudo-Gerät fängt zu ihm gesendete Pakete ab
      und leitet Sie zu einem D&aelig;mon weiter, der Verkehr zwischen IPv4
      und IPv6 vermittelt.</para>

    <programlisting># The `bpf' device enables the Berkeley Packet Filter.
# Be aware of the administrative consequences of enabling this!
# Note that 'bpf' is required for DHCP.
device   bpf           # Berkeley packet filter</programlisting>

    <para>Das ist der Berkeley Paketfilter.  Dieses Pseudo-Gerät kann
      Netzwerkkarten in den <quote>promiscuous</quote> Modus setzen und
      erlaubt es damit, Pakete auf einem Broadcast Netzwerk (z.B. einem
      Ethernet) einzufangen.  Die Pakete können auf der Festplatte
      gespeichert und mit &man.tcpdump.1; untersucht werden.</para>

    <note>
      <para>Das &man.bpf.4;-Gerät wird von
        &man.dhclient.8; genutzt, um die IP-Adresse des Default-Routers
	zu bekommen.  Wenn Sie DHCP benutzen, lassen Sie diese Option bitte
	aktiviert.</para>
    </note>

    <programlisting># USB support
device          uhci          # UHCI PCI-&gt;USB interface
device          ohci          # OHCI PCI-&gt;USB interface
device          ehci          # EHCI PCI-&gt;USB interface (USB 2.0)
device          usb           # USB Bus (required)
#device         udbp          # USB Double Bulk Pipe devices
device          ugen          # Generic
device          uhid          # <quote>Human Interface Devices</quote>
device          ukbd          # Keyboard
device          ulpt          # Printer
device          umass         # Disks/Mass storage - Requires scbus and da
device          ums           # Mouse
device          ural          # Ralink Technology RT2500USB wireless NICs
device          urio          # Diamond Rio 500 MP3 player
device          uscanner      # Scanners
# USB Ethernet, requires mii
device          aue           # ADMtek USB Ethernet
device          axe           # ASIX Electronics USB Ethernet
device          cdce          # Generic USB over Ethernet
device          cue           # CATC USB Ethernet
device          kue           # Kawasaki LSI USB Ethernet
device          rue           # RealTek RTL8150 USB Ethernet</programlisting>

    <para>Unterstützung für verschiedene USB Geräte.</para>

    <programlisting># FireWire support
device          firewire      # FireWire bus code
device          sbp           # SCSI over FireWire (Requires scbus and da)
device          fwe           # Ethernet over FireWire (non-standard!)</programlisting>

    <para>Verschiedene Firewire-Geräte.</para>

    <para>Mehr Informationen und weitere von &os; unterstützte
      Geräte entnehmen Sie bitte
      <filename>/usr/src/sys/i386/conf/NOTES</filename>.</para>

    <sect2>
      <title>Hohe Speicheranforderungen (<acronym>PAE</acronym>)</title>

      <indexterm>
	<primary>Physical Address Extensions (<acronym>PAE</acronym>)</primary>
	<secondary>hohe Speicheranforderungen</secondary>
      </indexterm>

      <para>Systeme mit hohen Speicheranforderungen benötigen
	mehr Speicher als den auf 4&nbsp;Gigabyte beschränkten
	User- und Kernel-Adressraum (<acronym>KVA</acronym>).
	Mit dem &pentium;&nbsp;Pro und neueren CPUs hat
	Intel den Adressraum auf 36-Bit erweitert.</para>

      <para>Die Physical-Address-Extension (<acronym>PAE</acronym>)
	von &intel;s &pentium;&nbsp;Pro und neueren Prozessoren
	unterstützt bis zu 64&nbsp;Gigabyte Speicher.
	&os; kann diesen Speicher mit der Option <option>PAE</option>
	in der Kernelkonfiguration nutzen.  Die Option gibt es
	in allen aktuellen &os;-Versionen.  Wegen Beschräkungen der
	Intel-Speicherarchitektur wird keine Unterscheidung
	zwischen Speicher oberhalb oder unterhalb von 4&nbsp;Gigabyte
	getroffen.  Speicher über 4&nbsp;Gigabyte wird
	einfach dem zur Verfügung stehenden Speicher
	zugeschlagen.</para>
	<!-- XXX ?? Bedeutung des letzten Satzes ?? -->

      <para>Sie aktivieren <acronym>PAE</acronym> im Kernel, indem
	Sie die folgende Zeile in die Kernelkonfigurationsdatei
	einfügen:</para>

      <programlisting>options		    PAE</programlisting>

      <note>
	<para>&os; unterstützt <acronym>PAE</acronym> nur
	  auf IA-32 Prozessoren.  Die
	  <acronym>PAE</acronym>-Unterstützung wurde
	  zudem noch nicht hinreichend getestet und befindet
	  sich im Vergleich zu anderen Komponenten von &os; noch
	  im Beta-Stadium.</para>
      </note>

      <para>Die <acronym>PAE</acronym>-Unterstützung in &os;
	  ist mit den nachstehenden Einschränkungen verbunden:</para>

      <itemizedlist>
	<listitem>
	  <para>Ein Prozess kann nicht mehr als 4&nbsp;Gigabyte
	    virtuellen Speicher benutzen.</para>
	</listitem>

	<listitem>
	  <para>Gerätetreiber, die nicht die
	    &man.bus.dma.9;-Schnittstelle benutzen, führen
	    zusammen mit einem <acronym>PAE</acronym>-Kernel zu
	    Datenverlusten.  Diese Treiber sollen nicht mit
	    einem <acronym>PAE</acronym>-Kernel verwendet werden.
	    Daher gibt es unter &os; eine zusätzliche
	    <acronym>PAE</acronym>-Kernelkonfigurationsdatei,
	    die alle Treiber enthält, die mit einem
	    <acronym>PAE</acronym>-Kernel funktionieren.</para>
	</listitem>

	<listitem>
	  <para>Einige Systemvariablen werden abhängig von
	    der Speichergröße eingestellt.  In einem
	    <acronym>PAE</acronym>-System mit viel Speicher
	    können die Werte daher zu hoch eingestellt sein.
	    Ein Beispiel ist die sysctl-Variable
	    <option>kern.maxvnodes</option>, die die maximale
	    Anzahl von vnodes im Kernel bestimmt.  Solche
	    Variablen sollten auf einen angemessenen Wert
	    eingestellt werden.</para>
	</listitem>

	<listitem>
	  <para>Es kann erforderlich sein, den virtuellen Adressraum
	    des Kernels (<acronym>KVA</acronym>) zu vergrößern
	    oder, wie oben beschrieben, den Wert einer häufig
	    gebrauchten Kernelvariablen zu verringern.  Dies
	    verhindert einen Überlauf des <acronym>KVA</acronym>s.
	    Der Adressraum des Kernels kann mit der Kerneloption
	    <option>KVA_PAGES</option> vergrößert
	    werden.</para>
	</listitem>
      </itemizedlist>

      <para>Hinweise zur Leistungssteigerung und Stabilität
	entnehmen Sie bitte der Hilfeseite &man.tuning.7;.
	Die <acronym>PAE</acronym>-Unterstützung von &os;
	wird in der Hilfeseite &man.pae.4; beschrieben.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="kernelconfig-trouble">
    <title>Wenn etwas schiefgeht</title>

    <para>Es gibt vier Hauptfehlerquellen beim Erstellen eines
      angepassten Kernels:</para>

    <variablelist>
      <varlistentry>
        <term><command>config</command> verursacht Fehler:</term>

        <listitem>
          <para>Wenn &man.config.8; misslingt, liegen Fehler
	    in der Kernelkonfigurationsdatei vor.  Zum Glück
	    gibt &man.config.8; die die Zeilennummer der
	    Fehlerstelle an, sodass Sie den Fehler schnell
	    finden können.  Beispielsweise könnten
	    Sie folgende Fehlermeldung sehen:</para>

          <screen>config: line 17: syntax error</screen>

	  <para>Vergleichen Sie die angegebene Zeile mit
	    <filename>GENERIC</filename> und stellen Sie sicher,
	    dass das Schlüsselwort richtig geschrieben
	    ist.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>make</command> verursacht Fehler:</term>

        <listitem>
	  <para>Wenn <command>make</command> misslingt, liegen
	    meistens Fehler in der Konfigurationsdatei vor,
	    die aber nicht schwerwiegend genug für
	    &man.config.8; waren.  Überprüfen Sie
	    wiederum Ihre Konfiguration und wenn Sie keinen
	    Fehler entdecken können, schicken Sie eine
	    E-Mail mit Ihrer Kernelkonfiguration an die Mailingliste
	    &a.de.questions;.  Sie sollten dann schnell Hilfe erhalten.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Der Kernel bootet nicht:<anchor xml:id="kernelconfig-noboot"/></term>

        <listitem>
          <para>Wenn der Kernel nicht booten will, ist das noch
	    lange kein Grund zur Panik.  Denn &os; besitzt exzellente
	    Mechanismen zur Wiederherstellung nach dem Einsatz
	    inkompatibler Kernel.  Den Kernel, mit dem Sie booten
	    wollen, können Sie sich im &os; Boot-Loader
	    aussuchen.  Dazu wählen Sie im Bootmenü die
	    Option <quote>Escape to a loader prompt</quote>.  Danach
	    geben Sie den Befehl
	    <command>boot kernel.old</command> oder
	    den Namen eines anderen Kernels ein, der sauber bootet.  Für
	    alle Fälle sollten Sie immer einen Kernel, der garantiert
	    bootet, bereit halten.</para>

          <para>Nun können Sie die Konfiguration noch einmal
	    überprüfen und den Kernel neu kompilieren.  Dazu
	    ist <filename>/var/log/messages</filename> sehr nützlich,
	    da hier sämtliche Kernelmeldungen von jedem erfolgreichen
	    Bootvorgang gespeichert werden.  &man.dmesg.8; gibt Ihnen die
	    Kernelmeldungen vom letzten Bootvorgang aus.</para>

          <note>
	    <para>Für den Fall, dass Sie Probleme bei dem
	      Kernelbau bekommen, heben Sie sich immer einen
	      <filename>GENERIC</filename> oder einen anderen
	      Kernel, der garantiert bootet, auf.  Der Name
	      dieses Kernels sollte so gewählt sein, dass
	      er beim nächsten Bau nicht überschrieben
	      wird.  Sie können sich nicht auf
	      <filename>kernel.old</filename> verlassen, da
	      dieser Kernel durch den zuletzt installierten
	      Kernel, der vielleicht schon kaputt war, während
	      der Installation ersetzt wird.  Kopieren Sie den
	      funktionierenden Kernel so schnell wie möglich
	      in das richtige Verzeichnis
	      (<filename>/boot/kernel</filename>).
	      Ansonsten funktionieren Kommandos wie &man.ps.1;
	      nicht.  Benennen Sie dazu einfach das Verzeichnis
	      des funktionierenden Kernels um:</para>

	    <screen>&prompt.root; <userinput>mv /boot/kernel /boot/kernel.bad</userinput>
&prompt.root; <userinput>mv /boot/kernel.good /boot/kernel</userinput></screen>

	  </note>
        </listitem>
      </varlistentry>

      <varlistentry>
	<term>Der Kernel ist in Ordnung, aber <command>ps</command> geht
	  nicht mehr:</term>

        <listitem>
	  <para>Wenn Sie eine andere Version des Kernels installiert
	    haben als die, mit der Ihre Systemwerkzeuge gebaut
	    wurden (beispielsweise einen -CURRENT-Kernel auf einem
	    -RELEASE-System), werden Programme wie &man.ps.1; und
	    &man.vmstat.8; nicht mehr funktionieren.  Sie
	    sollten nun das <link linkend="makeworld">komplette
	    System neu bauen und installieren</link>.  Achten
	    Sie darauf, dass die Quellen, aus denen Sie das
	    System bauen, zum installierten Kernel passen.
	    Das ist ein Grund dafür, warum man nie einen
	    Kernel, der nicht zur Systemversion passt, benutzen
	    sollten.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </sect1>
</chapter>
