<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/disks/chapter.xml,v 1.187 2012/04/26 19:32:48 bcr Exp $
     basiert auf: 1.315
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="disks">
  <info><title>Speichermedien</title>
    <authorgroup>
      <author><personname><firstname>Bernd</firstname><surname>Warken</surname></personname><contrib>Übersetzt von </contrib></author>
      <author><personname><firstname>Martin</firstname><surname>Heinen</surname></personname></author>
    </authorgroup>
  </info>

  

  <sect1 xml:id="disks-synopsis">
    <title>Übersicht</title>

    <para>Dieses Kapitel behandelt die Benutzung von Laufwerken unter
      FreeBSD.  Laufwerke können speichergestützte Laufwerke,
      Netzwerklaufwerke oder normale SCSI/IDE-Geräte sein.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie Folgendes
      wissen:</para>

    <itemizedlist>
      <listitem>
	<para>Die Begriffe, die FreeBSD verwendet, um die
	  Organisation der Daten auf einem physikalischen Laufwerk
	  zu beschreiben (Partitionen und Slices).</para>
      </listitem>

      <listitem>
	<para>Wie Sie ein weiteres Laufwerk zu Ihrem System
	  hinzufügen.</para>
      </listitem>

      <listitem>
	<para>Wie virtuelle Dateisysteme, zum Beispiel RAM-Disks,
	  eingerichtet werden.</para>
      </listitem>

      <listitem>
	<para>Wie Sie mit Quotas die Benutzung von Laufwerken
	  einschränken können.</para>
      </listitem>

      <listitem>
	<para>Wie Sie Partitionen verschlüsseln, um Ihre Daten
	  zu schützen.</para>
      </listitem>

      <listitem>
	<para>Wie unter FreeBSD CDs und DVDs gebrannt werden.</para>
      </listitem>

      <listitem>
	<para>Sie werden die Speichermedien, die Sie für
	  Backups einsetzen können, kennen.</para></listitem>

      <listitem>
	<para>Wie Sie die unter FreeBSD erhältlichen Backup
	  Programme benutzen.</para></listitem>

      <listitem>
	<para>Wie Sie ein Backup mit Disketten erstellen.</para>
      </listitem>

      <listitem>
	<para>Was Dateisystem-Schnappschüsse sind und wie sie
	  eingesetzt werden.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen,</para>

    <itemizedlist>
      <listitem>
	<para>sollten Sie einen einen &os;-Kernel installieren
	  können (<xref linkend="kernelconfig"/>).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="disks-naming">
    <title>Gerätenamen</title>

    <para>Die folgende Tabelle zeigt die von FreeBSD unterstützten
      Speichergeräte und deren Gerätenamen.</para>

    <table xml:id="disk-naming-physical-table" frame="none">
      <title>Namenskonventionen von physikalischen Laufwerken</title>

      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Laufwerkstyp</entry>
	    <entry>Gerätename</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>IDE-Festplatten</entry>
	    <entry><literal>ad</literal></entry>
	  </row>
	  <row>
	    <entry>IDE-CD-ROM Laufwerke</entry>
	    <entry><literal>acd</literal></entry>
	  </row>
	  <row>
	    <entry>SCSI-Festplatten und USB-Speichermedien</entry>
	    <entry><literal>da</literal></entry>
	  </row>
	  <row>
	    <entry>SCSI-CD-ROM Laufwerke</entry>
	    <entry><literal>cd</literal></entry>
	  </row>
	  <row>
	    <entry>Verschiedene proprietäre CD-ROM-Laufwerke</entry>
	    <entry><literal>mcd</literal> Mitsumi CD-ROM und
	      <literal>scd</literal> Sony CD-ROM</entry>
	  </row>
	  <row>
	    <entry>Diskettenlaufwerke</entry>
	    <entry><literal>fd</literal></entry>
	  </row>
	  <row>
	    <entry>SCSI-Bandlaufwerke</entry>
	    <entry><literal>sa</literal></entry>
          </row>
	  <row>
	    <entry>IDE-Bandlaufwerke</entry>
	    <entry><literal>ast</literal></entry>
	  </row>
	  <row>
	    <entry>Flash-Laufwerke</entry>
	    <entry><literal>fla</literal> für &diskonchip;
	      Flash-Device</entry>
	  </row>
	  <row>
	    <entry>RAID-Laufwerke</entry>
	    <entry><literal>aacd</literal> für &adaptec; AdvancedRAID,
	      <literal>mlxd</literal> und <literal>mlyd</literal>
	      für &mylex;,
	      <literal>amrd</literal> für AMI &megaraid;,
	      <literal>idad</literal> für Compaq Smart RAID,
	      <literal>twed</literal> für &tm.3ware; RAID.</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>
  </sect1>

  <sect1 xml:id="disks-adding">
    <info><title>Hinzufügen von Laufwerken</title>
      <authorgroup>
	<author><personname><firstname>David</firstname><surname>O'Brian</surname></personname><contrib>Im Original von </contrib></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>Laufwerke</primary>
      <secondary>hinzufügen</secondary>
    </indexterm>

    <para>Der folgende Abschnitt beschreibt, wie Sie ein neues
      <acronym>SCSI</acronym>-Laufwerk zu einer Maschine
      hinzufügen, die momentan nur ein Laufwerk hat.  Dazu schalten
      Sie zuerst den Rechner aus und installieren das Laufwerk entsprechend
      der Anleitungen Ihres Rechners, Ihres Controllers und des
      Laufwerkherstellers.  Den genauen Ablauf können wir wegen der
      großen Abweichungen leider nicht beschreiben.</para>

    <para>Nachdem Sie das Laufwerk installiert haben, melden Sie sich als
      Benutzer <systemitem class="username">root</systemitem> an und kontrollieren Sie
      <filename>/var/run/dmesg.boot</filename>, um sicherzustellen,
      dass das neue Laufwerk gefunden wurde.  Das neue Laufwerk
      wird, um das Beispiel fortzuführen, <filename>da1</filename>
      heißen und soll unter <filename>/1</filename> eingehängt
      werden.  Fügen Sie eine IDE-Platte hinzu, wird diese den
      Namen <filename>ad1</filename> erhalten.</para>

    <indexterm><primary>Partitionen</primary></indexterm>
    <indexterm><primary>Slices</primary></indexterm>
    <indexterm>
      <primary><command>fdisk</command></primary>
    </indexterm>

    <para>Da FreeBSD auf IBM-PC kompatiblen Rechnern läuft, muss
      es die PC BIOS-Partitionen, die verschieden von den traditionellen
      BSD-Partitionen sind, berücksichtigen.  Eine PC Platte kann
      bis zu vier BIOS-Partitionen enthalten.  Wenn die Platte
      ausschließlich für FreeBSD verwendet wird, können
      Sie den <emphasis>dedicated</emphasis> Modus benutzen, ansonsten
      muss FreeBSD in eine der BIOS-Partitionen installiert werden.
      In FreeBSD heißen die PC BIOS-Partitionen
      <emphasis>Slices</emphasis>, um sie nicht mit den traditionellen
      BSD-Partitionen zu verwechseln.  Sie können auch Slices auf
      einer Platte verwenden, die ausschließlich von FreeBSD
      benutzt wird, sich aber in einem Rechner befindet, der noch ein
      anderes Betriebssystem installiert hat.  Dadurch stellen Sie sicher,
      dass Sie <command>fdisk</command> des anderen Betriebssystems noch
      benutzen können.</para>

    <para>Im Fall von Slices wird die Platte als
      <filename>/dev/da1s1e</filename> hinzugefügt.  Das heißt:
      SCSI-Platte, Einheit 1 (die zweite SCSI-Platte), Slice 1
      (PC BIOS-Partition 1) und die <filename>e</filename> BSD-Partition.
      Wird die Platte ausschließlich für FreeBSD verwendet
      (<quote>dangerously dedicated</quote>), wird sie einfach als
      <filename>/dev/da1e</filename> hinzugefügt.</para>

    <note>
      <para>Da &man.bsdlabel.8; zum Speichern von Sektoren 32-Bit
	Integer verwendet, ist das Werkzeug in den meisten Fällen
	auf 2^32-1 Sektoren pro Laufwerk oder 2&nbsp;TB
	beschränkt.  In &man.fdisk.8; darf der Startsektor
	nicht größer als 2^32-1 sein und Partitionen
	sind auf eine Länge von 2^32-1 beschränkt.
	In den meisten Fällen beschränkt dies die
	Größe einer Partition auf 2&nbsp;TB
	und die maximale Größe eines Laufwerks
	auf 4&nbsp;TB.  Das &man.sunlabel.8;-Format ist
	mit 2^32-1 Sektoren pro Partition und 8&nbsp;Partitionen
	auf 16&nbsp;TB beschränkt.  Mit größeren
	Laufwerken können &man.gpt.8;-Partitionen benutzt
	werden, um <acronym>GPT</acronym>-Partitionen zu erstellen.
	<acronym>GPT</acronym> hat den zusätzlichen Vorteil, dass es
	nicht auf 4 Slices beschränkt ist.</para>
    </note>

    <sect2>
      <title>Verwenden von &man.sysinstall.8;</title>
      <indexterm>
	<primary><application>sysinstall</application></primary>
	<secondary>hinzufügen von Laufwerken</secondary>
      </indexterm>
      <indexterm>
	<primary>su</primary>
      </indexterm>

      <procedure>
	<step>
	  <title>Das <application>sysinstall</application> Menü</title>

          <para>Um ein Laufwerk zu partitionieren und zu labeln, kann das
	    menügestützte <command>sysinstall</command>
	    benutzt werden.  Dazu melden Sie sich als <systemitem class="username">root</systemitem>
	    an oder benutzen <command>su</command>, um
	    <systemitem class="username">root</systemitem> zu werden.  Starten Sie
	    <command>sysinstall</command> und wählen das
	    <literal>Configure</literal> Menü, wählen Sie dort
	    den Punkt <literal>Fdisk</literal> aus.</para>
	</step>

      <step>
	<title>Partitionieren mit <application>fdisk</application></title>

	<para>Innerhalb von <application>fdisk</application> geben Sie
	  <keycap>A</keycap> ein, um die ganze Platte für
	  FreeBSD zu benutzen.  Beantworten Sie die Frage <quote>remain
	    cooperative with any future possible operating systems</quote> mit
	  <literal>YES</literal>.  <keycap>W</keycap> schreibt die
	  Änderung auf die Platte, danach können Sie
	  <application>fdisk</application> mit <keycap>Q</keycap>
	  verlassen.  Da Sie eine Platte zu einem schon laufenden System
	  hinzugefügt haben, beantworten Sie die Frage nach dem
	  Master Boot Record mit <literal>None</literal>.</para>
      </step>

      <step>
	<title>Disk-Label-Editor</title>
	<indexterm><primary>BSD Partitionen</primary></indexterm>

	<para>Als nächstes müssen Sie
	  <application>sysinstall</application> verlassen und es erneut
	  starten.  Folgen Sie dazu bitte den Anweisungen von oben, aber
	  wählen Sie dieses Mal die Option <literal>Label</literal>,
	  um in den <literal>Disk Label Editor</literal> zu gelangen.
	  Hier werden die traditionellen BSD-Partitionen erstellt.
	  Ein Laufwerk kann acht Partitionen, die mit den Buchstaben
	  <literal>a-h</literal> gekennzeichnet werden,
	  besitzen.  Einige Partitionen sind für spezielle Zwecke
	  reserviert.  Die <literal>a</literal> Partition ist für die
	  Root-Partition (<filename>/</filename>) reserviert.  Deshalb
	  sollte nur das Laufwerk, von dem gebootet wird, eine
	  <literal>a</literal> Partition besitzen.  Die <literal>b</literal>
	  Partition wird für Swap-Partitionen benutzt, wobei Sie
	  diese auf mehreren Platten benutzen dürfen.
	  Im <quote>dangerously dedicated</quote> Modus spricht
	  die <literal>c</literal> Partition die gesamte Platte an,
	  werden Slices verwendet, wird damit die ganze Slice angesprochen.
	  Die anderen Partitionen sind für allgemeine Zwecke
	  verwendbar.</para>

        <para>Der Label Editor von <application>sysinstall</application>
	  bevorzugt die <literal>e</literal>
	  Partition für Partitionen, die weder Root-Partitionen noch
	  Swap-Partitionen sind.  Im Label
	  Editor können Sie ein einzelnes Dateisystem
	  mit <keycap>C</keycap> erstellen.  Wählen Sie
	  <literal>FS</literal>, wenn Sie gefragt werden, ob Sie ein
	  FS (Dateisystem) oder Swap erstellen wollen, und geben Sie einen
	  Mountpoint z.B. <filename>/mnt</filename> an.  Wenn Sie nach einer
	  FreeBSD-Installation ein Dateisystem mit
	  <application>sysinstall</application> erzeugen,
	  so werden die Einträge in <filename>/etc/fstab</filename>
	  nicht erzeugt, so dass die Angabe des Mountpoints nicht
	  wichtig ist.</para>

        <para>Sie können nun das Label auf das Laufwerk schreiben und
	  das Dateisystem erstellen, indem Sie <keycap>W</keycap>
	  drücken.  Ignorieren Sie die Meldung von
	  <application>sysinstall</application>, dass die neue Partition
	  nicht angehangen werden konnte, und verlassen Sie den Label Editor
	  sowie <application>sysinstall</application>.</para>
      </step>

      <step>
	<title>Ende</title>

        <para>Im letzten Schritt fügen Sie noch in
	  <filename>/etc/fstab</filename> den Eintrag für das neue
	  Laufwerk ein.</para>
      </step>

      </procedure>
    </sect2>

    <sect2>
      <title>Die Kommandozeile</title>

      <sect3>
	<title>Anlegen von Slices</title>

        <para>Mit der folgenden Vorgehensweise wird eine Platte mit
	  anderen Betriebssystemen, die vielleicht auf Ihrem Rechner
	  installiert sind, zusammenarbeiten und nicht das
	  <command>fdisk</command> Programm anderer Betriebssysteme
	  stören.  Bitte benutzen
	  Sie den <literal>dedicated</literal> Modus nur dann, wenn
	  Sie dazu einen guten Grund haben!</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 bs=1k count=1</userinput>
&prompt.root; <userinput>fdisk -BI da1</userinput> # Initialisieren der neuen Platte
&prompt.root; <userinput>bsdlabel -B -w da1s1 auto</userinput> #Labeln.
&prompt.root; <userinput>bsdlabel -e da1s1</userinput> # Editieren des Disklabels und Hinzufügen von Partitionen
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>newfs /dev/da1s1e</userinput> # Wiederholen Sie diesen Schritt für jede Partition
&prompt.root; <userinput>mount /dev/da1s1e /1</userinput> # Anhängen der Partitionen
&prompt.root; <userinput>vi /etc/fstab</userinput> # Ändern Sie <filename>/etc/fstab</filename> entsprechend</screen>

	<para>Wenn Sie ein IDE-Laufwerk besitzen, ändern Sie
	  <filename>da</filename> in <filename>ad</filename>.</para>
      </sect3>

      <sect3>
	<title>Dedicated</title>
	<indexterm><primary>OS/2</primary></indexterm>

        <para>Wenn das neue Laufwerk nicht von anderen Betriebssystemen
	  benutzt werden soll, können Sie es im
	  <literal>dedicated</literal> Modus betreiben.  Beachten Sie bitte,
	  dass Microsoft-Betriebssysteme mit diesem Modus eventuell nicht
	  zurechtkommen, aber es entsteht kein Schaden am Laufwerk.  Im
	  Gegensatz dazu wird IBMs &os2; versuchen, jede ihm nicht bekannte
	  Partition zu reparieren.</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 bs=1k count=1</userinput>
&prompt.root; <userinput>bsdlabel -Bw da1 auto</userinput>
&prompt.root; <userinput>bsdlabel -e da1</userinput>  # Erstellen der `e' Partition
&prompt.root; <userinput>newfs /dev/da1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput> # /dev/da1e hinzufügen
&prompt.root; <userinput>mount /1</userinput></screen>

	<para>Eine alternative Methode:</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 count=2</userinput>
&prompt.root; <userinput>bsdlabel /dev/da1 | bsdlabel -BR da1 /dev/stdin</userinput>
&prompt.root; <userinput>newfs /dev/da1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput> # /dev/da1e hinzufügen
&prompt.root; <userinput>mount /1</userinput></screen>

      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="raid">
    <title>RAID</title>

    <sect2 xml:id="raid-soft">
      <title>Software-RAID</title>

      <sect3 xml:id="ccd">
        <info><title>Concatenated-Disk (CCD) konfigurieren</title>
          <authorgroup>
	    <author><personname><firstname>Christopher</firstname><surname>Shumway</surname></personname><contrib>Original von </contrib></author>
	  </authorgroup>
          <authorgroup>
	    <author><personname><firstname>Jim</firstname><surname>Brown</surname></personname><contrib>Überarbeitet von </contrib></author>
          </authorgroup>
        </info>

	
	<indexterm>
	  <primary>RAID</primary>
	  <secondary>Software</secondary>
	</indexterm>
	<indexterm>
	  <primary>RAID</primary>
	  <secondary>CCD</secondary>
	</indexterm>

        <para>Die wichtigsten Faktoren bei der Auswahl von Massenspeichern
	  sind Geschwindigkeit, Zuverlässigkeit und Preis.
	  Selten findet sich eine ausgewogene Mischung aller drei Faktoren.
	  Schnelle und zuverlässige Massenspeicher sind für
	  gewöhnlich teuer.  Um die Kosten zu senken, muss
	  entweder an der Geschwindigkeit oder an der Zuverlässigkeit
	  gespart werden.</para>

	<para>Das unten beschriebene System sollte vor allem
	  preiswert sein.  Der nächst wichtige Faktor war
	  die Geschwindigkeit gefolgt von der Zuverlässigkeit.
	  Die Geschwindigkeit war nicht so wichtig, da über
	  das Netzwerk auf das System zugegriffen wird.  Da alle
	  Daten schon auf CD-Rs gesichert sind, war die
	  Zuverlässigkeit, obwohl wichtig, ebenfalls nicht
	  von entscheidender Bedeutung.</para>

	<para>Die Bewertung der einzelnen Faktoren ist der erste
	  Schritt bei der Auswahl von Massenspeichern.  Wenn Sie
	  vor allem ein schnelles und zuverlässiges Medium
	  benötigen und der Preis nicht wichtig ist, werden
	  Sie ein anderes System als das hier beschriebene
	  zusammenstellen.</para>

        <sect4 xml:id="ccd-installhw">
          <title>Installation der Hardware</title>

	  <para>Neben der IDE-Systemplatte besteht das System
	    aus drei Western Digital IDE-Festplatten mit
	    5400&nbsp;RPM und einer Kapazität von je
	    30&nbsp;GB.  Insgesamt stehen also 90&nbsp;GB
	    Speicherplatz zur Verfügung.  Im Idealfall sollte
	    jede Festplatte an einen eigenen Controller angeschlossen
	    werden.  Um Kosten zu sparen, wurde bei diesem System
	    darauf verzichtet und an jeden IDE-Controller eine
	    Master- und eine Slave-Platte angeschlossen.</para>

          <para>Beim Reboot wurde das BIOS so konfiguriert, dass es
	    die angeschlossenen Platten automatisch erkennt und FreeBSD
	    erkannte die Platten ebenfalls:</para>

          <programlisting>ad0: 19574MB &lt;WDC WD205BA&gt; [39770/16/63] at ata0-master UDMA33
ad1: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata0-slave UDMA33
ad2: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata1-master UDMA33
ad3: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata1-slave UDMA33</programlisting>

	  <note>
	    <para>Wenn FreeBSD die Platten nicht erkennt,
	      überprüfen Sie, ob die Jumper korrekt
	      konfiguriert sind.  Die meisten IDE-Festplatten
	      verfügen über einen
	      <quote>Cable Select</quote>-Jumper.  Die Master-
	      und Slave-Platten werden mit einem anderen
	      Jumper konfiguriert.  Bestimmen Sie den richtigen
	      Jumper mithilfe der Dokumentation Ihrer
	      Festplatte.</para>
	  </note>

	  <para>Als nächstes sollten Sie überlegen,
	    auf welche Art der Speicher zur Verfügung
	    gestellt werden soll.  Schauen Sie sich dazu
	    &man.vinum.4; (<xref linkend="vinum-vinum"/>)
	    und &man.ccd.4; an.  Im hier beschriebenen
	    System wird &man.ccd.4; eingesetzt.</para>
        </sect4>

        <sect4 xml:id="ccd-setup">
          <title>Konfiguration von CCD</title>

          <para>Mit &man.ccd.4; können mehrere
	    gleiche Platten zu einem logischen Dateisystem
	    zusammengefasst werden.  Um &man.ccd.4;
	    zu benutzen, muss der Kernel mit der entsprechenden
	    Unterstützung übersetzt werden.
	    Ergänzen Sie die Kernelkonfiguration um die
	    nachstehende Zeile.  Anschließend müssen
	    Sie den Kernel neu übersetzen und installieren.</para>

	  <programlisting>pseudo-device   ccd</programlisting>

	  <para>Alternativ kann &man.ccd.4; auch als
	    Kernelmodul geladen werden.</para>

          <para>Um &man.ccd.4; zu benutzen, müssen
	    die Laufwerke zuerst mit einem Label versehen werden.
	    Die Label werden mit &man.bsdlabel.8; erstellt:</para>

          <programlisting>bsdlabel -w ad1 auto
bsdlabel -w ad2 auto
bsdlabel -w ad3 auto</programlisting>

          <para>Damit wurden die Label <filename>ad1c</filename>,
	    <filename>ad2c</filename> und <filename>ad3c</filename>
	    erstellt, die jeweils das gesamte Laufwerk umfassen.</para>

          <para>Im nächsten Schritt muss der Typ des Labels
	    geändert werden.  Die Labels können Sie
	    mit &man.bsdlabel.8; editieren:</para>

          <programlisting>bsdlabel -e ad1
bsdlabel -e ad2
bsdlabel -e ad3</programlisting>

          <para>Für jedes Label startet dies den durch
	    <envar>EDITOR</envar> gegebenen Editor, typischerweise
	    &man.vi.1;.</para>

	  <para>Ein unverändertes Label sieht zum Beispiel
	    wie folgt aus:</para>

          <programlisting>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)</programlisting>

	  <para>Erstellen Sie eine <literal>e</literal>-Partition
	    für &man.ccd.4;.  Dazu können Sie normalerweise
	    die Zeile der <literal>c</literal>-Partition kopieren,
	    allerdings muss <option>fstype</option> auf
	    <userinput>4.2BSD</userinput> gesetzt werden.
	    Das Ergebnis sollte wie folgt aussehen:</para>

          <programlisting>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)
  e: 60074784        0    4.2BSD        0     0     0   # (Cyl.    0 - 59597)</programlisting>

        </sect4>

        <sect4 xml:id="ccd-buildingfs">
          <title>Erstellen des Dateisystems</title>

	  <para>Nachdem alle Platten ein Label haben, kann das
	    &man.ccd.4;-RAID aufgebaut werden.  Dies geschieht
	    mit &man.ccdconfig.8;:</para>

	  <programlisting>ccdconfig ccd0<co xml:id="co-ccd-dev"/> 32<co xml:id="co-ccd-interleave"/> 0<co xml:id="co-ccd-flags"/> /dev/ad1e<co xml:id="co-ccd-devs"/> /dev/ad2e /dev/ad3e</programlisting>

	  <para>Die folgende Aufstellung erklärt die
	    verwendeten Kommandozeilenargumente:</para>

	  <calloutlist>
	    <callout arearefs="co-ccd-dev">
	      <para>Das erste Argument gibt das zu konfigurierende
		Gerät, hier <filename>/dev/ccd0c</filename>,
		an.  Die Angabe von <filename>/dev/</filename> ist
		dabei optional.</para>
	    </callout>

	    <callout arearefs="co-ccd-interleave">
	      <para>Der Interleave für das Dateisystem.  Der
	        Interleave definiert die Größe eines
		Streifens in Blöcken, die normal 512&nbsp;Bytes
		groß sind.  Ein Interleave von 32 ist
		demnach 16384&nbsp;Bytes groß.</para>
	    </callout>

	    <callout arearefs="co-ccd-flags">
	      <para>Weitere Argumente für &man.ccdconfig.8;.
		Wenn Sie spiegeln wollen, können Sie das
		hier angeben.  Die gezeigte Konfiguration
		verwendet keine Spiegel, sodass der Wert
		<literal>0</literal> angegeben ist.</para>
	    </callout>

	    <callout arearefs="co-ccd-devs">
	      <para>Das letzte Argument gibt die Geräte des
		Plattenverbundes an.  Benutzen Sie für jedes
		Gerät den kompletten Pfadnamen.</para>
	    </callout>
	  </calloutlist>

	  <para>Nach Abschluß von &man.ccdconfig.8; ist der
	    Plattenverbund konfiguriert und es können Dateisysteme
	    auf dem Plattenverbund angelegt werden.  Das Anlegen
	    von Dateisystemen wird in der Hilfeseite &man.newfs.8;
	    beschrieben.  Für das Beispiel genügt
	    der folgende Befehl:</para>

          <programlisting>newfs /dev/ccd0c</programlisting>
        </sect4>

        <sect4 xml:id="ccd-auto">
          <title>Automatisierung</title>

          <para>Damit &man.ccd.4; beim Start automatisch
	    aktiviert wird, ist die Datei <filename>/etc/ccd.conf</filename>
	    mit dem folgenden Kommando zu erstellen:</para>

          <programlisting>ccdconfig -g &gt; /etc/ccd.conf</programlisting>

          <para>Wenn <filename>/etc/ccd.conf</filename> existiert, wird beim
	    Reboot <command>ccdconfig -C</command> von
	    <command>/etc/rc</command> aufgerufen.  Damit wird
	    &man.ccd.4; eingerichtet und die darauf
	    befindlichen Dateisysteme können angehängt
	    werden.</para>

	  <note>
            <para>Wenn Sie in den Single-User Modus booten, müssen Sie
	      den Verbund erst konfigurieren, bevor Sie darauf befindliche
	      Dateisysteme anhängen können:</para>

            <programlisting>ccdconfig -C</programlisting>
	  </note>

          <para>In <filename>/etc/fstab</filename> ist noch ein Eintrag
	    für das auf dem Verbund befindliche Dateisystem zu
	    erstellen, damit dieses beim Start des Systems immer
	    angehängt wird:</para>

          <programlisting>/dev/ccd0c              /media       ufs     rw      2       2</programlisting>
        </sect4>
      </sect3>

      <sect3 xml:id="vinum">
	<title>Der Vinum-Volume-Manager</title>

	<indexterm>
	  <primary>RAID</primary>
	  <secondary>Software</secondary>
	</indexterm>
	<indexterm>
	  <primary>RAID</primary>
	  <secondary>Vinum</secondary>
	</indexterm>
	<para>Der Vinum Volume Manager ist ein Block-Gerätetreiber,
	  der virtuelle Platten zur Verfügung stellt.  Er trennt die
	  Verbindung zwischen der Festplatte und dem zugehörigen
	  Block-Gerät auf.  Im Gegensatz zur konventionellen
	  Aufteilung einer Platte in Slices lassen sich dadurch Daten
	  flexibler, leistungsfähiger und zuverlässiger verwalten.
	  &man.vinum.4; stellt RAID-0, RAID-1 und RAID-5 sowohl einzeln wie
	  auch in Kombination zur Verfügung.</para>

	<para>Mehr Informationen über &man.vinum.4; erhalten Sie in
	  <xref linkend="vinum-vinum"/>.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="raid-hard">
      <title>Hardware-RAID</title>

      <indexterm>
        <primary>RAID</primary>
        <secondary>Hardware</secondary>
      </indexterm>
      <para>FreeBSD unterstützt eine Reihe von
	<acronym>RAID</acronym>-Controllern.  Diese Geräte
	verwalten einen Plattenverbund; zusätzliche Software
	wird nicht benötigt.</para>

      <para>Der Controller steuert mithilfe eines
	<acronym>BIOS</acronym> auf der Karte die Plattenoperationen.
	Wie ein <acronym>RAID</acronym> System eingerichtet wird,
	sei kurz am Beispiel des Promise <acronym>IDE</acronym>
	<acronym>RAID</acronym>-Controllers gezeigt.  Nachdem
	die Karte eingebaut ist und der Rechner neu gestartet wurde,
	erscheint eine Eingabeaufforderung.  Wenn Sie den Anweisungen
	auf dem Bildschirm folgen, gelangen Sie in eine Maske, in der
	Sie mit den vorhandenen Festplatten ein
	<acronym>RAID</acronym>-System aufbauen können.
	FreeBSD behandelt das <acronym>RAID</acronym>-System wie
	eine einzelne Festplatte.</para>
    </sect2>

    <sect2>
      <title>Wiederherstellen eines ATA-RAID-1 Verbunds</title>

      <para>Mit FreeBSD können Sie eine ausgefallene Platte in
	einem RAID-Verbund während des Betriebs auswechseln,
	vorausgesetzt Sie bemerken den Ausfall vor einem Neustart.</para>

      <para>Einen Ausfall erkennen Sie, wenn in der Datei
	<filename>/var/log/messages</filename> oder in der
	Ausgabe von &man.dmesg.8; Meldungen wie die folgenden
	auftauchen:</para>

      <programlisting>ad6 on monster1 suffered a hard error.
ad6: READ command timeout tag=0 serv=0 - resetting
ad6: trying fallback to PIO mode
ata3: resetting devices .. done
ad6: hard error reading fsbn 1116119 of 0-7 (ad6 bn 1116119; cn 1107 tn 4 sn 11)\\
status=59 error=40
ar0: WARNING - mirror lost</programlisting>

      <para>Überprüfen Sie den RAID-Verbund mit
        &man.atacontrol.8;:</para>

      <screen>&prompt.root; <userinput>atacontrol list</userinput>
ATA channel 0:
	Master:      no device present
	Slave:   acd0 &lt;HL-DT-ST CD-ROM GCR-8520B/1.00&gt; ATA/ATAPI rev 0

ATA channel 1:
	Master:      no device present
	Slave:       no device present

ATA channel 2:
	Master:  ad4 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

ATA channel 3:
	Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

&prompt.root; <userinput>atacontrol status ar0</userinput>
ar0: ATA RAID1 subdisks: ad4 ad6 status: DEGRADED</screen>

      <procedure>
	<step>
	  <para>Damit Sie die Platte ausbauen können, muss zuerst
	    der ATA-Channel der ausgefallenen Platte aus dem Verbund entfernt
	    werden:</para>

	  <screen>&prompt.root; <userinput>atacontrol detach ata3</userinput></screen>
	</step>

	<step>
	  <para>Ersetzen Sie dann die Platte.</para>
	</step>

	<step>
	  <para>Nun aktivieren Sie den ATA-Channel wieder:</para>

	  <screen>&prompt.root; <userinput>atacontrol attach ata3</userinput>
Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
Slave:   no device present</screen>
	</step>

	<step>
	  <para>Nehmen Sie die neue Platte in den Verbund auf:</para>

          <screen>&prompt.root; <userinput>atacontrol addspare ar0 ad6</userinput></screen>
	</step>

	<step>
	  <para>Stellen Sie die Organisation des Verbunds wieder her:</para>

	  <screen>&prompt.root; <userinput>atacontrol rebuild ar0</userinput></screen>
	</step>

	<step>
	  <para>Sie können den Fortschritt des Prozesses durch
	    folgende Befehle kontrollieren:</para>

	  <screen>&prompt.root; <userinput>dmesg | tail -10</userinput>
[output removed]
ad6: removed from configuration
ad6: deleted from ar0 disk1
ad6: inserted into ar0 disk1 as spare

&prompt.root; <userinput>atacontrol status ar0</userinput>
ar0: ATA RAID1 subdisks: ad4 ad6 status: REBUILDING 0% completed</screen>
	</step>

	<step>
	  <para>Warten Sie bis die Wiederherstellung beendet ist.</para>
	</step>
      </procedure>
    </sect2>
  </sect1>

  <sect1 xml:id="usb-disks">
    <info><title>USB Speichermedien</title>
      <authorgroup>
	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>USB</primary>
      <secondary>Speichermedien</secondary>
    </indexterm>

    <para>Der Universal Serial Bus (USB) wird heutzutage von
      vielen externen Speichern benutzt:  Festplatten,
      USB-Thumbdrives oder CD-Brennern, die alle von
      &os; unterstützt werden.</para>

    <sect2>
      <title>USB-Konfiguration</title>

      <para>USB-Massenspeicher werden vom Treiber &man.umass.4;
	betrieben.  Wenn Sie den <filename>GENERIC</filename>-Kernel
	benutzen, brauchen Sie keine Anpassungen vorzunehmen.
	Benutzen Sie einen angepassten Kernel, müssen die
	nachstehenden Zeilen in der Kernelkonfigurationsdatei
	enthalten sein:</para>

      <programlisting>device scbus
device da
device pass
device uhci
device ohci
device ehci
device usb
device umass</programlisting>

      <para>Der Treiber &man.umass.4; greift über das
        SCSI-Subsystem auf die USB-Geräte zu.  Ihre
	USB-Geräte werden daher vom System als SCSI-Geräte
	erkannt.  Abhängig vom Chipsatz Ihrer Systemplatine
	benötigen Sie in der Kernelkonfiguration entweder
	die Option <literal>device uhci</literal> oder die
	Option <literal>device ohci</literal> für die
	Unterstützung von USB 1.1.  Die
	Kernelkonfiguration kann allerdings auch beide Optionen
	enthalten.  Unterstützung für USB 2.0 Controller
	wird durch den &man.ehci.4;-Treiber geleistet (die
	<literal>device ehci</literal> Zeile).  Vergessen Sie bitte nicht,
	einen neuen Kernel zu bauen und zu installieren, wenn Sie die
	Kernelkonfiguration verändert haben.</para>

      <note>
	<para>Wenn es sich bei Ihrem USB-Gerät um einen
	  CD-R- oder DVD-Brenner handelt, müssen Sie den
	  Treiber &man.cd.4; für SCSI-CD-ROMs in die
	  Kernelkonfiguration aufnehmen:</para>

	<programlisting>device cd</programlisting>

	<para>Da der Brenner als SCSI-Laufwerk erkannt wird,
	  sollten Sie den Treiber &man.atapicam.4; nicht
	  benutzen.</para>
      </note>
    </sect2>

    <sect2>
      <title>Die USB-Konfiguration testen</title>

      <para>Sie können das USB-Gerät nun testen.
	Schließen Sie das Gerät an und untersuchen
	Sie die Systemmeldungen (&man.dmesg.8;), Sie sehen
	Ausgaben wie die folgende:</para>

      <screen>umass0: USB Solid state disk, rev 1.10/1.00, addr 2
GEOM: create disk da0 dp=0xc2d74850
da0 at umass-sim0 bus 0 target 0 lun 0
da0: &lt;Generic Traveling Disk 1.11&gt; Removable Direct Access SCSI-2 device
da0: 1.000MB/s transfers
da0: 126MB (258048 512 byte sectors: 64H 32S/T 126C)</screen>

      <para>Die Ausgaben, wie das erkannte Gerät oder
	der Gerätename (<filename>da0</filename>)
	hängen natürlich von Ihrer Konfiguration ab.</para>

      <para>Da ein USB-Gerät als SCSI-Gerät erkannt
	wird, können Sie USB-Massenspeicher mit dem
	Befehl <command>camcontrol</command> anzeigen:</para>

      <screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;Generic Traveling Disk 1.11&gt;      at scbus0 target 0 lun 0 (da0,pass0)</screen>

      <para>Wenn auf dem Laufwerk ein Dateisystem eingerichtet
	ist, sollten Sie das Dateisystem einhängen können.
	<xref linkend="disks-adding"/> beschreibt, wie Sie
	USB-Laufwerke formatieren und Partitionen einrichten.</para>

      <warning>
        <para>Aus Sicherheitsgründen sollten Sie Benutzern, denen Sie
          nicht vertrauen, das Einhängen (z.B. durch die unten
          beschriebene Aktivierung von <literal>vfs.usermount</literal>)
          beliebiger Medien  verbieten.  Die meisten Dateisysteme in &os;
          wurden nicht entwickelt, um sich vor böswilligen Geräten
          zu schützen.</para>
      </warning>

      <para>Damit auch normale Anwender (ohne
	<systemitem class="username">root</systemitem>-Rechte) USB-Laufwerke einhängen
	können, müssen Sie Ihr System erst entsprechend
	konfigurieren.  Als erstes müssen Sie sicherstellen, dass
	diese Anwender auf die beim Einhängen eines USB-Laufwerks
	dynamisch erzeugten Gerätedateien zugreifen dürfen.
	Dazu können Sie beispielsweise mit &man.pw.8; alle
	potentiellen Benutzer dieser Gerätedateien in die Gruppe
	<systemitem class="groupname">operator</systemitem> aufnehmen.  Außerdem
	muss sichergestellt werden, dass Mitglieder der Gruppe
	<systemitem class="groupname">operator</systemitem> Schreib- und Lesezugriff
	auf diese Gerätedateien haben.  Dazu fügen Sie die
	folgenden Zeilen in die Konfigurationsdatei
	<filename>/etc/devfs.rules</filename> ein:</para>

      <programlisting>[localrules=5]
add path 'da*' mode 0660 group operator</programlisting>

      <note>
	<para>Verfügt Ihr System auch über SCSI-Laufwerke,
	  gibt es eine Besonderheit.   Haben Sie beispielsweise
	  die SCSI-Laufwerke <filename>da0</filename> bis
	  <filename>da2</filename> installiert, so sieht die
	  zweite Zeile wie folgt aus:</para>

	<programlisting>add path 'da[3-9]*' mode 0660 group operator</programlisting>

        <para>Dadurch werden die bereits vorhandenen
	  SCSI-Laufwerke nicht in die Gruppe
	  <systemitem class="groupname">operator</systemitem> aufgenommen.</para>
      </note>

      <para>Vergessen Sie nicht, die &man.devfs.rules.5;-Regeln
	in der Datei <filename>/etc/rc.conf</filename> zu
	aktivieren:</para>

      <programlisting>devfs_system_ruleset="localrules"</programlisting>

      <para>Als nächstes müssen Sie Ihre Kernelkonfiguration
	anpassen, damit auch normale Benutzer Dateisysteme mounten
	dürfen.  Dazu fügen Sie am besten folgende Zeile
	in die Konfigurationsdatei
	<filename>/etc/sysctl.conf</filename> ein:</para>

      <programlisting>vfs.usermount=1</programlisting>

      <para>Damit diese Einstellung wirksam wird, müssen Sie Ihr
	System neu starten.  Alternativ können Sie diese Variable
	auch mit &man.sysctl.8; setzen.</para>

      <para>Zuletzt müssen Sie noch ein Verzeichnis anlegen, in
	das das USB-Laufwerk eingehängt werden soll.   Dieses
	Verzeichnis muss dem Benutzer gehören, der das
	USB-Laufwerk in den Verzeichnisbaum einhängen will.
	Dazu legen Sie als <systemitem class="username">root</systemitem> ein
	Unterverzeichnis
	<filename>/mnt/username</filename>
	an (wobei Sie <replaceable>username</replaceable>
	durch den Login des jeweiligen Benutzers sowie
	<replaceable>usergroup</replaceable> durch die primäre
	Gruppe des Benutzers ersetzen):</para>

      <screen>&prompt.root; <userinput>mkdir /mnt/username</userinput>
 &prompt.root; <userinput>chown username:usergroup /mnt/username</userinput></screen>

      <para>Wenn Sie nun beispielsweise einen USB-Stick
	anschließen, wird automatisch die Gerätedatei
	<filename>/dev/da0s1</filename> erzeugt.  Da derartige
	Geräte in der Regel mit dem FAT-Dateisystem
	formatiert sind, können Sie sie beispielsweise mit
	dem folgenden Befehl in den Verzeichnisbaum
	einhängen:</para>

      <screen>&prompt.user; <userinput>mount -t msdosfs -o -m=644,-M=755 /dev/da0s1 /mnt/username</userinput></screen>

      <para>Wenn Sie das Gerät entfernen (das Dateisystem
	müssen Sie vorher abhängen),  sehen Sie
	in den Systemmeldungen Einträge wie die folgenden:</para>

      <screen>umass0: at uhub0 port 1 (addr 2) disconnected
(da0:umass-sim0:0:0:0): lost device
(da0:umass-sim0:0:0:0): removing device entry
GEOM: destroy disk da0 dp=0xc2d74850
umass0: detached</screen>
    </sect2>

    <sect2>
      <title>Weiteres zu USB</title>

      <para>Neben den Abschnitten
	<link linkend="disks-adding">Hinzufügen von Laufwerken</link>
	und <link linkend="mount-unmount">Anhängen und
	Abhängen von Dateisystemen</link> lesen Sie bitte
	die Hilfeseiten &man.umass.4;, &man.camcontrol.8; für
	&os;&nbsp;8.X oder &man.usbdevs.8; bei vorherigen Versionen.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="creating-cds">
    <info><title>CDs benutzen</title>
      <authorgroup>
	<author><personname><firstname>Mike</firstname><surname>Meyer</surname></personname><contrib>Beigesteuert von </contrib></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>CD-ROM</primary>
      <secondary>brennen</secondary>
    </indexterm>

    <sect2>
      <title>Einführung</title>

      <para>CDs besitzen einige Eigenschaften, die sie von
	konventionellen Laufwerken unterscheiden.  Zuerst konnten
	sie nicht beschrieben werden.  Sie wurden so entworfen, dass
	sie ununterbrochen, ohne Verzögerungen durch Kopfbewegungen
	zwischen den Spuren, gelesen werden können.  Sie konnten
	früher auch leichter als vergleichbar große Medien zwischen
	Systemen bewegt werden.</para>

      <para>CDs besitzen Spuren, aber damit ist der Teil Daten
	gemeint, der ununterbrochen gelesen wird, und nicht eine
	physikalische Eigenschaft der CD.  Um eine CD mit FreeBSD
	zu erstellen,  werden die Daten jeder Spur der CD in
	Dateien vorbereitet und dann die Spuren auf die CD
	geschrieben.</para>

      <indexterm><primary>ISO 9660</primary></indexterm>
      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>ISO 9660</secondary>
      </indexterm>
      <para>Das ISO 9660-Dateisystem wurde entworfen, um mit diesen
	Unterschieden umzugehen.  Leider hat es auch damals übliche
	Grenzen für Dateisysteme implementiert.  Glücklicherweise
	existiert ein Erweiterungsmechanismus, der es korrekt
	geschriebenen CDs erlaubt, diese Grenzen zu überschreiten
	und dennoch auf Systemen zu funktionieren, die diese
	Erweiterungen nicht unterstützen.</para>

      <indexterm>
	<primary><package>sysutils/cdrtools</package></primary>
      </indexterm>

      <para>Der Port <package>sysutils/cdrtools</package>
	enthält das Programm &man.mkisofs.8;, das eine Datei
	erstellt, die ein ISO 9660-Dateisystem enthält.
	Das Programm hat Optionen, um verschiedene Erweiterungen
	zu unterstützen, und wird unten beschrieben.</para>

      <indexterm>
	<primary>CD-Brenner</primary>
	<secondary>ATAPI</secondary>
      </indexterm>

      <para>Welches Tool Sie zum Brennen von CDs benutzen, hängt davon
	ab, ob Ihr CD-Brenner ein ATAPI-Gerät ist oder nicht.
	Mit ATAPI-CD-Brennern wird <command>burncd</command> benutzt,
	das Teil des Basissystems ist.
	SCSI- und USB-CD-Brenner werden mit <command>
	cdrecord</command> aus <package>sysutils/cdrtools</package> benutzt.
	Zusätzlich ist es möglich, über das Modul
	<link linkend="atapicam">ATAPI/CAM</link> SCSI-Werkzeuge wie
	<command>cdrecord</command>
	auch für ATAPI-Geräte einzusetzen.</para>

      <para>Wenn Sie eine Brennsoftware mit grafischer
	Benutzeroberfläche benötigen, sollten Sie sich
	<application>X-CD-Roast</application> oder
	<application>K3b</application> näher ansehen.  Diese
	Werkzeuge können als Paket oder aus den
	Ports (<package>sysutils/xcdroast</package>
	und <package>sysutils/k3b</package>)
	installiert werden.  Mit ATAPI-Hardware benötigt
	<application>K3b</application> das
	<link linkend="atapicam">ATAPI/CAM-Modul</link>.</para>
    </sect2>

    <sect2 xml:id="mkisofs">
      <title><application>mkisofs</application></title>

      <para>Das Programm &man.mkisofs.8; aus dem Port
	<package>sysutils/cdrtools</package>
	erstellt ein ISO 9660-Dateisystem,
	das ein Abbild eines Verzeichnisbaumes ist.
	Die einfachste Anwendung ist wie folgt:</para>

      <screen>&prompt.root; <userinput>mkisofs -o Imagedatei /path/to/tree</userinput></screen>

      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>ISO 9660</secondary>
      </indexterm>
      <para>Dieses Kommando erstellt eine <replaceable>Imagedatei</replaceable>,
        die ein ISO 9660-Dateisystem enthält, das eine Kopie des
	Baumes unter <replaceable>/path/to/tree</replaceable> ist.
	Dabei werden die Dateinamen auf Namen abgebildet, die den
	Restriktionen des ISO 9660-Dateisystems entsprechen.  Dateien
	mit Namen, die im ISO 9660-Dateisystem nicht gültig sind,
	bleiben unberücksichtigt.</para>

      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>HFS</secondary>
      </indexterm>
      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>Joliet</secondary>
      </indexterm>
      <para>Es einige Optionen, um diese Beschränkungen
	zu überwinden.  Die unter &unix; Systemen üblichen
	Rock-Ridge-Erweiterungen werden durch <option>-R</option>
	aktiviert, <option>-J</option> aktiviert die von Microsoft
	Systemen benutzten Joliet-Erweiterungen und <option>-hfs</option>
	dient dazu, um das von &macos; benutzte HFS zu erstellen.</para>

      <para>Für CDs, die nur auf FreeBSD-Systemen verwendet werden
	sollen, kann <option>-U</option> genutzt werden, um alle
	Beschränkungen für Dateinamen aufzuheben.  Zusammen
	mit <option>-R</option> wird ein Abbild des
	Dateisystems, ausgehend von dem Startpunkt im FreeBSD-Dateibaum,
	erstellt, obwohl dies den ISO 9660 Standard
	verletzen kann.</para>

      <indexterm>
	<primary>CD-ROM</primary>
	<secondary>bootbare erstellen</secondary>
      </indexterm>
      <para>Die letzte übliche Option ist <option>-b</option>.
	Sie wird benutzt, um den Ort eines Bootimages einer
	<quote>El Torito</quote> bootbaren CD anzugeben.  Das Argument
	zu dieser Option ist der Pfad zu einem Bootimage ausgehend
	von der Wurzel des Baumes, der auf die CD geschrieben werden
	soll.   In der Voreinstellung erzeugt &man.mkisofs.8; ein
	ISO-Image im <quote>Diskettenemulations</quote>-Modus.  Dabei
	muss das Image genau 1200, 1440 oder 2880&nbsp;KB groß
	sein.  Einige Bootloader, darunter der auf den FreeBSD-Disks
	verwendete, kennen keinen Emulationsmodus.  Daher sollten Sie
	in diesen Fällen die Option <option>-no-emul-boot</option>
	verwenden.  Wenn <filename>/tmp/myboot</filename> ein bootbares
	FreeBSD-System enthält, dessen Bootimage sich in
	<filename>/tmp/myboot/boot/cdboot</filename> befindet, können
	Sie ein Abbild eines ISO 9660-Dateisystems in
	<filename>/tmp/bootable.iso</filename> wie folgt
	erstellen:</para>

      <screen>&prompt.root; <userinput>mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot</userinput></screen>

      <para>Wenn Sie <filename>md</filename> in Ihrem
	Kernel konfiguriert haben, können Sie danach das Dateisystem
	einhängen:</para>

      <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /tmp/bootable.iso -u 0</userinput>
&prompt.root; <userinput>mount -t cd9660 /dev/md0 /mnt</userinput></screen>

      <para>Jetzt können Sie überprüfen, dass
	<filename>/mnt</filename> und <filename>/tmp/myboot</filename>
	identisch sind.</para>

      <para>Sie können das Verhalten von &man.mkisofs.8;
	mit einer Vielzahl von Optionen beeinflussen.  Insbesondere
	können Sie das ISO 9660-Dateisystem modifizieren und
	Joliet- oder HFS-Dateisysteme brennen.  Details dazu
	entnehmen Sie bitte der Hilfeseite &man.mkisofs.8;.</para>
    </sect2>

    <sect2 xml:id="burncd">
      <title><application>burncd</application></title>

      <indexterm>
	<primary>CD-ROM</primary>
	<secondary>brennen</secondary>
      </indexterm>
      <para>Wenn Sie einen ATAPI-CD-Brenner besitzen, können
	Sie <command>burncd</command> benutzen, um ein ISO-Image
	auf CD zu brennen.  <command>burncd</command> ist Teil
	des Basissystems und unter <filename>/usr/sbin/burncd</filename>
	installiert.  Da es nicht viele Optionen hat, ist es leicht
	zu benutzen:</para>

      <screen>&prompt.root; <userinput>burncd -f cddevice data imagefile.iso fixate</userinput></screen>

      <para>Dieses Kommando brennt eine Kopie von
	<replaceable>imagefile.iso</replaceable> auf das Gerät
	<replaceable>cddevice</replaceable>.  In der Grundeinstellung
	wird das Gerät <filename>/dev/acd0</filename> benutzt.
	&man.burncd.8; beschreibt, wie die Schreibgeschwindigkeit
	gesetzt wird, die CD ausgeworfen wird und Audiodaten
	geschrieben werden.</para>
    </sect2>

    <sect2 xml:id="cdrecord">
      <title><application>cdrecord</application></title>

      <para>Wenn Sie keinen ATAPI-CD-Brenner besitzen, benutzen Sie
	<command>cdrecord</command>, um CDs zu brennen.
	<command>cdrecord</command> ist nicht Bestandteil des Basissystems.
	Sie müssen es entweder aus den Ports in
	<package>sysutils/cdrtools</package> oder dem
	passenden Paket installieren.  Änderungen im Basissystem
	können Fehler im binären Programm verursachen und
	führen möglicherweise dazu, dass Sie einen
	<quote>Untersetzer</quote> brennen.  Sie sollten
	daher den Port aktualisieren, wenn Sie Ihr System aktualisieren
	bzw. wenn Sie
	<link linkend="stable">STABLE verfolgen</link>,
	den Port aktualisieren, wenn es eine neue Version gibt.</para>

      <para>Obwohl <command>cdrecord</command> viele Optionen besitzt,
	ist die grundlegende Anwendung einfacher als <command>burncd</command>.
	Ein ISO 9660-Image erstellen Sie mit:</para>

      <screen>&prompt.root; <userinput>cdrecord dev=device imagefile.iso</userinput></screen>

      <para>Der Knackpunkt in der Benutzung von <command>cdrecord</command>
	besteht darin, das richtige Argument zu <option>dev</option> zu
	finden.  Benutzen Sie dazu den Schalter <option>-scanbus</option>
	von <command>cdrecord</command>, der eine ähnliche Ausgabe
	wie die folgende produziert:</para>

      <indexterm>
	<primary>CD-ROM</primary>
	<secondary>brennen</secondary>
      </indexterm>
      <screen>&prompt.root; <userinput>cdrecord -scanbus</userinput>
Cdrecord 1.9 (i386-unknown-freebsd7.0) Copyright (C) 1995-2004 Jörg Schilling
Using libscg version 'schily-0.1'
scsibus0:
        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk
        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk
        0,2,0     2) *
        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk
        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM
        0,5,0     5) *
        0,6,0     6) *
        0,7,0     7) *
scsibus1:
        1,0,0   100) *
        1,1,0   101) *
        1,2,0   102) *
        1,3,0   103) *
        1,4,0   104) *
        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM
        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner
        1,7,0   107) *</screen>

      <para>Für die aufgeführten Geräte in der Liste
	wird das passende Argument zu <option>dev</option> gegeben.
        Benutzen Sie die drei durch Kommas separierten Zahlen, die zu
	Ihrem CD-Brenner angegeben sind, als Argument für
	<option>dev</option>.  Im Beispiel ist das CDRW-Gerät
	1,5,0, so dass die passende Eingabe
	<userinput>dev=1,5,0</userinput> wäre.
	Einfachere Wege das Argument anzugeben, sind in &man.cdrecord.1;
	beschrieben.  Dort sollten Sie auch nach
	Informationen über Audiospuren, das Einstellen der
	Geschwindigkeit und ähnlichem suchen.</para>
    </sect2>

    <sect2 xml:id="duplicating-audiocds">
      <title>Kopieren von Audio-CDs</title>

      <para>Um eine Kopie einer Audio-CD zu erstellen, kopieren Sie die
        Stücke der CD in einzelne Dateien und brennen diese Dateien
	dann auf eine leere CD.  Das genaue Verfahren hängt davon ab,
	ob Sie ATAPI- oder SCSI-Laufwerke verwenden.</para>

      <procedure>
	<title>SCSI-Laufwerke</title>

	<step>
	  <para>Kopieren Sie die Audiodaten mit
	    <command>cdda2wav</command>:</para>

	  <screen>&prompt.user; <userinput>cdda2wav -vall -D2,0 -B -Owav</userinput></screen>
	</step>

	<step>
	  <para>Die erzeugten <filename>.wav</filename> Dateien schreiben
	    Sie mit <command>cdrecord</command> auf eine leere CD:</para>

	  <screen>&prompt.user; <userinput>cdrecord -v dev=2,0 -dao -useinfo  *.wav</userinput></screen>

	  <para>Das Argument von <option>dev</option> gibt das verwendete
	    Gerät an, das Sie, wie in <xref linkend="cdrecord"/>
	    beschrieben, ermitteln können.</para>
	</step>
      </procedure>

      <procedure>
	<title>ATAPI-Laufwerke</title>

	<note>
	  <para>Über das Modul <link linkend="atapicam">ATAPI/CAM</link> kann
	    <command>cdda2wav</command> auch mit ATAPI-Laufwerken
	    verwendet werden.  Diese Methode ist für die meisten
	    Anwender besser geeignet als die im folgenden beschriebenen
	    Methoden (Jitter-Korrektur, Big-/Little-Endian-Probleme und
	    anderes mehr spielen hierbei eine Rolle).</para>
        </note>

	<step>
	  <para>Der ATAPI-CD-Treiber stellt die einzelnen Stücke der
	    CD über die Dateien
	    <filename>/dev/acddtnn</filename>,
	    zur Verfügung.  <replaceable>d</replaceable> bezeichnet
	    die Laufwerksnummer und <replaceable>nn</replaceable> ist die
	    Nummer des Stücks.  Die Nummer ist immer zweistellig,
	    das heißt es wird, wenn nötig, eine führende
	    Null ausgegeben.  Die Datei <filename>/dev/acd0t01</filename>
	    ist also das erste Stück des ersten CD-Laufwerks.
	    <filename>/dev/acd0t02</filename> ist das zweite Stück
	    und <filename>/dev/acd0t03</filename> das dritte.</para>

	  <para>Überprüfen Sie stets, ob die entsprechenden
	    Dateien im Verzeichnis <filename>/dev</filename> auch
	    angelegt werden.  Sind die Einträge nicht vorhanden,
	    weisen Sie Ihr System an, das Medium erneut zu testen:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/acd0 of=/dev/null count=1</userinput></screen>

	  <note>
	    <para>Unter &os;&nbsp;4.X werden diese Einträge nicht
	      mit dem Wert Null vordefiniert.  Falls die entsprechenden
	      Einträge unter <filename>/dev</filename> nicht
	      vorhanden sind, müssen Sie diese hier von
	      <command>MAKEDEV</command> anlegen lassen:</para>

	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV acd0t99</userinput></screen>

	  </note>
	</step>

	<step>
	  <para>Die einzelnen Stücke kopieren Sie mit &man.dd.1;.  Sie
	    müssen dazu eine spezielle Blockgröße
	    angeben:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/acd0t01 of=track1.cdr bs=2352</userinput>
&prompt.root; <userinput>dd if=/dev/acd0t02 of=track2.cdr bs=2352</userinput>
...</screen>
	</step>

	<step>
	  <para>Die kopierten Dateien können Sie dann mit
	    <command>burncd</command> brennen.  Auf der Kommandozeile
	    müssen Sie angeben, dass Sie Audio-Daten brennen
	    wollen und dass das Medium fixiert werden soll:</para>

	  <screen>&prompt.root; <userinput>burncd -f /dev/acd0 audio track1.cdr track2.cdr ... fixate</userinput></screen>
	</step>
      </procedure>
    </sect2>

    <sect2 xml:id="imaging-cd">
      <title>Kopieren von Daten-CDs</title>

      <para>Sie können eine Daten-CD in eine Datei kopieren, die einem
        Image entspricht, das mit &man.mkisofs.8; erstellt
	wurde.  Mit Hilfe dieses Images können Sie jede Daten-CD
	kopieren.  Das folgende Beispiel verwendet
	<filename>acd0</filename> für das CD-ROM-Gerät.  Wenn
	Sie ein anderes Laufwerk benutzen, setzen Sie bitte den richtigen
	Namen ein.</para>

      <screen>&prompt.root; <userinput>dd if=/dev/acd0 of=file.iso bs=2048</userinput></screen>

      <para>Danach haben Sie ein Image, das Sie wie oben beschrieben, auf
        eine CD brennen können.</para>
    </sect2>

    <sect2 xml:id="mounting-cd">
      <title>Einhängen von Daten-CDs</title>

      <para>Nachdem Sie eine Daten-CD gebrannt haben, wollen Sie
        wahrscheinlich auch die Daten auf der CD lesen.  Dazu müssen
	Sie die CD in den Dateibaum einhängen.  Die Voreinstellung
	für den Typ des Dateisystems von &man.mount.8; ist
	<literal>UFS</literal>.  Das System wird die Fehlermeldung
	<errorname>Incorrect super block</errorname> ausgeben, wenn Sie
	versuchen, die CD mit dem folgenden Kommando
	einzuhängen:</para>

      <screen>&prompt.root; <userinput>mount /dev/cd0 /mnt</userinput></screen>

      <para>Auf der CD befindet sich ja kein <literal>UFS</literal>
	Dateisystem, so dass der Versuch, die CD einzuhängen
	fehlschlägt.  Sie müssen &man.mount.8; sagen, dass
	es ein Dateisystem vom Typ <literal>ISO9660</literal> verwenden
	soll.  Dies erreichen Sie durch die Angabe von <option>-t
	cd9660</option> auf der Kommandozeile.  Wenn Sie also die CD-ROM
	<filename>/dev/cd0</filename> in <filename>/mnt</filename>
	einhängen wollen, führen Sie folgenden Befehl aus:</para>

          <screen>&prompt.root; <userinput>mount -t cd9660 /dev/cd0c /mnt</userinput></screen>

      <para>Abhängig vom verwendeten CD-ROM kann der Gerätename
        von dem im Beispiel (<filename>/dev/cd0</filename>)
	abweichen.  Die Angabe von <option>-t cd9660</option> führt
	&man.mount.cd9660.8; aus, so dass das Beispiel verkürzt
	werden kann:</para>

<screen>&prompt.root; <userinput>mount_cd9660 /dev/cd0 /mnt</userinput></screen>

      <para>Auf diese Weise können Sie
        Daten-CDs von jedem Hersteller verwenden.  Es kann allerdings zu
	Problemen mit CDs kommen, die verschiedene ISO9660-Erweiterungen
	benutzen.  So speichern Joliet-CDs alle Dateinamen unter Verwendung
	von zwei Byte langen Unicode-Zeichen.  Zwar unterstützt der
	&os;-Kernel derzeit noch kein Unicode, der CD9660-Treiber erlaubt
	es aber, zur Laufzeit eine Konvertierungstabelle zu laden.  Tauchen
	bei Ihnen also statt bestimmter Zeichen nur Fragezeichen auf, so
	müssen Sie über die Option <option>-C</option> den
	benötigten Zeichensatz angeben.  Weitere Informationen zu
	diesem Problem finden Sie in der Manualpage
	&man.mount.cd9660.8;.</para>

      <note>
	<para>Damit der Kernel diese Zeichenkonvertierung (festgelegt
	  durch die Option <option>-C</option>) erkennt, müssen Sie
	  das Kernelmodul <filename>cd9660_iconv.ko</filename> laden.
	  Dazu fügen Sie folgende Zeile in die Datei
	  <filename>loader.conf</filename> ein:</para>

	<programlisting>cd9660_iconv_load="YES"</programlisting>

	<para>Danach müssen Sie allerdings Ihr System neu starten.
	  Alternativ können Sie das Kernelmodul auch direkt
	  über &man.kldload.8; laden.</para>
      </note>

      <para>Manchmal werden Sie die Meldung <errorname>Device
        not configured</errorname> erhalten, wenn Sie versuchen,  eine
	CD-ROM einzuhängen.  Für gewöhnlich liegt das daran,
	dass das Laufwerk meint es sei keine CD eingelegt, oder
	dass das Laufwerk auf dem Bus nicht erkannt wird.  Es kann
	einige Sekunden dauern, bevor das Laufwerk merkt, dass eine CD
	eingelegt wurde.  Seien Sie also geduldig.</para>

      <para>Manchmal wird ein SCSI-CD-ROM nicht erkannt, weil es keine Zeit
        hatte, auf das Zurücksetzen des Busses zu antworten.  Wenn Sie
	ein SCSI-CD-ROM besitzen, sollten Sie die folgende Zeile in Ihre
	Kernelkonfiguration aufnehmen und einen neuen <link linkend="kernelconfig-building">Kernel bauen</link>:</para>

      <programlisting>options SCSI_DELAY=15000</programlisting>

      <para>Die Zeile bewirkt, dass nach dem Zurücksetzen des
        SCSI-Busses beim Booten 15&nbsp;Sekunden gewartet wird, um dem
	CD-ROM-Laufwerk genügend Zeit zu geben, darauf zu
	antworten.</para>
    </sect2>

    <sect2 xml:id="rawdata-cd">
      <title>Brennen von rohen CDs</title>

      <para>Sie können eine Datei auch direkt auf eine CD brennen,
        ohne vorher auf ihr ein ISO 9660-Dateisystem einzurichten.
	Einige Leute nutzen dies, um Datensicherungen durchzuführen.
	Diese Vorgehensweise hat den Vorteil, dass Sie schneller als
	das Brennen einer normalen CD ist.</para>

      <screen>&prompt.root; <userinput>burncd -f /dev/acd1 -s 12 data archive.tar.gz fixate</userinput></screen>

      <para>Wenn Sie die Daten von einer solchen CD wieder
        zurückbekommen wollen, müssen Sie sie direkt von dem
	rohen Gerät lesen:</para>

      <screen>&prompt.root; <userinput>tar xzvf /dev/acd1</userinput></screen>

      <para>Eine auf diese Weise gefertigte CD können Sie nicht in das
        Dateisystem einhängen.  Sie können Sie auch nicht auf
	einem anderen Betriebssystem lesen.  Wenn Sie die erstellten CDs in
	das Dateisystem einhängen oder mit anderen Betriebssystemen
	austauschen wollen, müssen Sie &man.mkisofs.8;
	wie oben beschrieben benutzen.</para>
    </sect2>

    <sect2 xml:id="atapicam">
      <info><title>Der ATAPI/CAM Treiber</title>
	<authorgroup>
	  <author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Beigetragen von </contrib></author>
	</authorgroup>
      </info>

      

      <indexterm>
	<primary>CD-Brenner</primary>
	<secondary>ATAPI/CAM Treiber</secondary>
      </indexterm>

      <para>Mit diesem Treiber kann auf ATAPI-Geräte (wie
	CD-ROM-, CD-RW- oder DVD-Laufwerke) mithilfe des
	SCSI-Subsystems zugegriffen werden.  Damit können
	Sie SCSI-Werkzeuge, wie <package>sysutils/cdrdao</package> oder &man.cdrecord.1;,
	zusammen mit einem ATAPI-Gerät benutzen.</para>

      <para>Wenn Sie den Treiber benutzen wollen, fügen Sie
	die folgende Zeile in
	<filename>/boot/loader.conf</filename> ein:</para>

      <programlisting>atapicam_load="YES"</programlisting>

      <para>Danach müssen Sie Ihr System neu starten, um
	den Treiber zu aktivieren.</para>

      <note>
	<para>Alternativ können Sie die Unterstützung
	  für &man.atapicam.4; auch in Ihren Kernel kompilieren.
	  Dazu fügen Sie die folgende Zeile in Ihre
	  Kernelkonfigurationsdatei ein:</para>

        <programlisting>device atapicam</programlisting>

        <para>Die folgenden Zeilen werden ebenfalls benötigt,
	  sollten aber schon Teil der Kernelkonfiguration sein:</para>

        <programlisting>device ata
device scbus
device cd
device pass</programlisting>
      </note>

      <para>Übersetzen und installieren Sie den neuen
	Kernel.  Der CD-Brenner sollte nun beim Neustart des Systems
	erkannt werden:</para>

      <screen>acd0: CD-RW &lt;MATSHITA CD-RW/DVD-ROM UJDA740&gt; at ata1-master PIO4
cd0 at ata1 bus 0 target 0 lun 0
cd0: &lt;MATSHITA CDRW/DVD UJDA740 1.00&gt; Removable CD-ROM SCSI-0 device
cd0: 16.000MB/s transfers
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed</screen>

      <para>Über den Gerätenamen <filename>/dev/cd0</filename>
	können Sie nun auf das Laufwerk zugreifen.  Wenn Sie
	beispielsweise eine CD-ROM in <filename>/mnt</filename>
	einhängen wollen, benutzen Sie das nachstehende
	Kommando:</para>

      <screen>&prompt.root; <userinput>mount -t cd9660 /dev/cd0 /mnt</userinput></screen>

      <para>Die SCSI-Adresse des Brenners können Sie als
	<systemitem class="username">root</systemitem> wie folgt ermitteln:</para>

      <screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;MATSHITA CDRW/DVD UJDA740 1.00&gt;   at scbus1 target 0 lun 0 (pass0,cd0)</screen>

      <para>Die SCSI-Adresse <literal>1,0,0</literal> können
	Sie mit den SCSI-Werkzeugen, zum Beispiel &man.cdrecord.1;,
	verwenden.</para>

      <para>Weitere Informationen über das ATAPI/CAM- und
        das SCSI-System erhalten Sie in den Hilfeseiten
	&man.atapicam.4; und &man.cam.4;.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="creating-dvds">
    <info><title>DVDs benutzen</title>
      <authorgroup>
	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Andy</firstname><surname>Polyakov</surname></personname><contrib>Mit Beiträgen von </contrib></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>DVD</primary>
      <secondary>brennen</secondary>
    </indexterm>

    <sect2>
      <title>Einführung</title>

      <para>Nach der CD ist die DVD die nächste Generation
	optischer Speichermedien.  Auf einer DVD können
	mehr Daten als auf einer CD gespeichert werden.
	DVDs werden heutzutage als Standardmedium für
	Videos verwendet.</para>

      <para>Für beschreibbare DVDs existieren fünf
	Medienformate:</para>

      <itemizedlist>
	<listitem>
	  <para>DVD-R:  Dies war das erste verfügbare Format.
	    Das Format wurde vom <link xlink:href="http://www.dvdforum.com/forum.shtml">DVD-Forum</link>
	    festgelegt.  Die Medien sind nur einmal beschreibbar.</para>
	</listitem>

	<listitem>
	  <para>DVD-RW:  Dies ist die wiederbeschreibbare Version
	    des DVD-R Standards.  Eine DVD-RW kann ungefähr
	    1000&nbsp;Mal beschrieben werden.</para>
	</listitem>

	<listitem>
	  <para>DVD-RAM:  Dies ist ebenfalls ein wiederbeschreibbares
	    Format, das vom DVD-Forum unterstützt wird.
	    Eine DVD-RAM verhält sich wie eine Wechselplatte.
	    Allerdings sind die Medien nicht kompatibel zu den
	    meisten DVD-ROM-Laufwerken und DVD-Video-Spielern.
	    DVD-RAM wird nur von wenigen Brennern unterstützt.
	    Wollen Sie DVD-RAM einsetzen, sollten Sie
	    <xref linkend="creating-dvd-ram"/> lesen.</para>
	</listitem>

	<listitem>
	  <para>DVD+RW:  Ist ein wiederbeschreibbares Format, das
	    von der <link xlink:href="http://www.dvdrw.com/">DVD+RW
	      Alliance</link> festgelegt wurde.  Eine DVD+RW
	    kann ungefähr 1000&nbsp;Mal beschrieben werden.</para>
	</listitem>

	<listitem>
	  <para>DVD+R:  Dieses Format ist die nur einmal beschreibbare
	    Variante des DVD+RW Formats.</para>
	</listitem>
      </itemizedlist>

      <para>Auf einer einfach beschichteten DVD können
	4.700.000.000&nbsp;Bytes gespeichert werden.  Das
	sind 4,38&nbsp;GB oder 4485&nbsp;MB (1&nbsp;Kilobyte
	sind 1024&nbsp;Bytes).</para>

      <note>
	<para>Die physischen Medien sind unabhängig von
	  der Anwendung.  Ein DVD-Video ist eine spezielle
	  Anordnung von Dateien, die auf irgendein Medium (zum Beispiel
	  DVD-R, DVD+R oder DVD-RW) geschrieben werden kann.
	  Bevor Sie ein Medium auswählen, müssen
	  Sie sicherstellen, dass der Brenner und der DVD-Spieler
	  (ein Einzelgerät oder ein DVD-ROM-Laufwerk
	  eines Rechners) mit dem Medium umgehen können.</para>
      </note>
    </sect2>

    <sect2>
      <title>Konfiguration</title>

      <para>Das Programm &man.growisofs.1; beschreibt DVDs.
	Das Kommando ist Teil der Anwendung
	<application>dvd+rw-tools</application>
	(<package>sysutils/dvd+rw-tools</package>).
	<application>dvd+rw-tools</application> kann mit allen
	DVD-Medien umgehen.</para>

      <para>Um die Geräte anzusprechen, brauchen die
	Werkzeuge das SCSI-Subsystem.  Daher muss der
	Kernel den <link linkend="atapicam">ATAPI/CAM-Treiber</link>
	zur Verfügung stellen.  Der Treiber ist mit
	USB-Brennern nutzlos; die Konfiguration von
	USB-Geräten behandelt <xref linkend="usb-disks"/>.</para>

      <para>Für ATAPI-Geräte müssen Sie ebenfalls
	DMA-Zugriffe aktivieren.  Fügen Sie dazu die nachstehende
	Zeile in die Datei <filename>/boot/loader.conf</filename>
	ein:</para>

      <programlisting>hw.ata.atapi_dma="1"</programlisting>

      <para>Bevor Sie <application>dvd+rw-tools</application>
	mit Ihrem DVD-Brenner benutzen, lesen Sie bitte die
	Hardware-Informationen auf der Seite <link xlink:href="http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html">dvd+rw-tools'
	  hardware compatibility notes</link>.</para>

      <note>
	<para>Wenn Sie eine grafische Oberfläche bevorzugen,
	  schauen Sie sich bitte den Port
	  <package>sysutils/k3b</package>
	  an.  Der Port bietet eine leicht zu bedienende
	  Schnittstelle zu &man.growisofs.1; und vielen
	  anderen Werkzeugen.</para>
      </note>
    </sect2>

    <sect2>
      <title>Daten-DVDs brennen</title>

      <para>&man.growisofs.1; erstellt mit dem Programm
	<link linkend="mkisofs">mkisofs</link> das Dateisystem
	und brennt anschließend die DVD.  Vor dem Brennen
	brauchen Sie daher kein Abbild der Daten zu erstellen.</para>

      <para>Wenn Sie von den Daten im Verzeichnis
	<filename>/path/to/data</filename> eine
	DVD+R oder eine DVD-R brennen wollen, benutzen Sie
	das nachstehende Kommando:</para>

      <screen>&prompt.root; <userinput>growisofs -dvd-compat -Z /dev/cd0 -J -R /path/to/data</userinput></screen>

      <para>Die Optionen <option>-J -R</option> werden an
	&man.mkisofs.8; durchgereicht und dienen zum Erstellen
	des Dateisystems (hier:  ein ISO-9660-Dateisystem mit
	Joliet- und Rock-Ridge-Erweiterungen).  Weiteres
	entnehmen Sie bitte der Hilfeseite &man.mkisofs.8;.</para>

      <para>Die Option <option>-Z</option> wird für die erste
	Aufnahme einer Session benötigt, egal ob Sie eine
	Multi-Session-DVD brennen oder nicht.  Für
	<replaceable>/dev/cd0</replaceable> müssen Sie
	den Gerätenamen Ihres Brenners einsetzen.  Die
	Option <option>-dvd-compat</option> schließt das
	Medium, weitere Daten können danach nicht mehr
	angehängt werden.  Durch die Angabe dieser Option
	kann das Medium von mehr DVD-ROM-Laufwerken gelesen
	werden.</para>

      <para>Sie können auch ein vorher erstelltes Abbild
	der Daten brennen.  Die nachstehende Kommandozeile
	brennt das Abbild in der Datei
	<replaceable>imagefile.iso</replaceable>:</para>

      <screen>&prompt.root; <userinput>growisofs -dvd-compat -Z /dev/cd0=imagefile.iso</userinput></screen>

      <para>Die Schreibgeschwindigkeit hängt von den
	verwendeten Medium sowie dem verwendeten Gerät ab
	und sollte automatisch gesetzt werden.  Falls Sie die
	Schreibgeschwindigkeit vorgeben möchten, verwenden
	Sie den Parameter <option>-speed=</option>.  Weiteres
	erfahren Sie in der Hilfeseite &man.growisofs.1;.</para>

      <note>
        <para>Um grössere Dateien als 4.38GB in ihre Sammlung
          aufzunehmen, ist es notwendig ein UDF/ISO-9660 Hybrid-Dateisystem
          zu erstellen.  Dieses Dateisystem muss mit zusätzlichen
          Parametern <option>-udf -iso-level 3</option> bei &man.mkisofs.8;
          und allen relevanten Programmen (z.B. &man.growisofs.1;) erzeugt
          werden.  Dies ist nur notwendig wenn Sie ein ISO-Image erstellen
          oder direkt auf eine DVD schreiben wollen.  DVDs, die in dieser
          Weise hergestellt worden sind, müssen als UDF-Dateisystem
          mit &man.mount.udf.8; eingehangen werden. Sie sind nur auf
          Betriebssystemen, die UDF unterstützen brauchbar, ansonsten
          sieht es so aus, als ob sie kaputte Dateien enthalten würden.
        </para>

        <para>Um so eine ISO Datei zu bauen, geben Sie den folgenden
          Befehl ein:</para>

<screen>&prompt.user; <userinput>mkisofs -R -J -udf -iso-level 3 -o imagefile.iso /path/to/data</userinput></screen>

 	<para>Um Daten direkt auf eine DVD zu brennen, geben Sie den
 	  folgenden Befehl ein:</para>

<screen>&prompt.root; <userinput>growisofs -dvd-compat -udf -iso-level 3 -Z /dev/cd0 -J -R /path/to/data</userinput></screen>

 	<para>Wenn Sie ein ISO-Image haben das bereits grosse Dateien
 	  enthält, sind keine weiteren zusätzlichen Optionen für
 	  &man.growisofs.1; notwendig, um das Image auf die DVD zu
 	  brennen.</para>

 	<para>Beachten Sie noch, dass Sie die aktuelle Version von
 	  <package>sysutils/cdrtools</package> haben (welche
 	  &man.mkisofs.8; enthält), da die älteren Versionen nicht
 	  den Support für grosse Dateien enthalten.  Wenn Sie Probleme
 	  haben sollten, können Sie auch das Entwicklerpaket
 	  von <package>sysutils/cdrtools-devel</package>
 	  einsetzen und lesen Sie die &man.mkisofs.8; Manualpage.</para>

      </note>

    </sect2>

    <sect2>
      <title>DVD-Videos brennen</title>

      <indexterm>
	<primary>DVD</primary>
	<secondary>DVD-Video</secondary>
      </indexterm>

      <para>Ein DVD-Video ist eine spezielle Anordnung von Dateien, die
	auf den ISO-9660 und den micro-UDF (M-UDF) Spezifikationen
	beruht.  Ein DVD-Video ist auf eine bestimmte Datei-Hierarchie
	angewiesen.  Daher müssen Sie DVDs mit speziellen
	Programmen wie <package>multimedia/dvdauthor</package>
	erstellen.</para>

      <para>Wenn Sie schon ein Abbild des Dateisystems eines
	DVD-Videos haben, brennen Sie das Abbild wie jedes
	andere auch.  Eine passende Kommandozeile finden Sie
	im vorigen Abschnitt.  Wenn Sie die DVD im Verzeichnis
	<filename>/path/to/video</filename>
	zusammengestellt haben, erstellen Sie das DVD-Video
	mit dem nachstehenden Kommando:</para>

      <screen>&prompt.root; <userinput>growisofs -Z /dev/cd0 -dvd-video /path/to/video</userinput></screen>

      <para>Die Option <option>-dvd-video</option> wird an
	&man.mkisofs.8; weitergereicht.  Dadurch erstellt
	&man.mkisofs.8; die Datei-Hierarchie für ein
	DVD-Video.  Weiterhin bewirkt die Angabe von
	<option>-dvd-video</option>, dass &man.growisofs.1;
	mit der Option <option>-dvd-compat</option> aufgerufen wird.</para>
    </sect2>

    <sect2>
      <title>DVD+RW-Medien benutzen</title>

      <indexterm>
	<primary>DVD</primary>
	<secondary>DVD+RW</secondary>
      </indexterm>

      <para>Im Gegensatz zu CD-RW-Medien müssen Sie DVD+RW-Medien
	erst formatieren, bevor Sie die Medien benutzen.
	Sie sollten &man.growisofs.1; einzetzen, da das Programm
	Medien automatisch formatiert, wenn es erforderlich
	ist.  Sie können eine DVD+RW aber auch mit dem
	Kommando <command>dvd+rw-format</command> formatieren:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format /dev/cd0</userinput></screen>

      <para>Sie müssen das Kommando nur einmal mit
	neuen Medien laufen lassen.  Anschließend
	können Sie DVD+RWs, wie in den vorigen
	Abschnitten beschrieben, brennen.</para>

      <para>Wenn Sie auf einer DVD+RW ein neues Dateisystem
	erstellen wollen, brauchen Sie die DVD+RW vorher
	nicht zu löschen.  Überschreiben Sie
	einfach das vorige Dateisystem indem Sie eine neue
	Session anlegen:</para>

      <screen>&prompt.root; <userinput>growisofs -Z /dev/cd0 -J -R /path/to/newdata</userinput></screen>

      <para>Mit dem DVD+RW-Format ist es leicht, Daten an eine
	vorherige Aufnahme anzuhängen.  Dazu wird eine neue
	Session mit der schon bestehenden zusammengeführt.
	Es wird keine Multi-Session geschrieben, sondern
	&man.growisofs.1; <emphasis>vergrößert</emphasis>
	das ISO-9660-Dateisystem auf dem Medium.</para>

      <para>Das folgende Kommando fügt weitere Daten zu
	einer vorher erstellten DVD+RW hinzu:</para>

      <screen>&prompt.root; <userinput>growisofs -M /dev/cd0 -J -R /path/to/nextdata</userinput></screen>

      <para>Wenn Sie eine DVD+RW erweitern, verwenden Sie
	dieselben &man.mkisofs.8;-Optionen wie beim Erstellen
	der DVD+RW.</para>

      <note>
	<para>Um die Kompatibilität mit DVD-ROM-Laufwerken
	  zu gewährleisten, wollen Sie vielleicht die
	  Option <option>-dvd-compat</option> einsetzen.
	  Zu einem DVD+RW-Medium können Sie mit dieser
	  Option auch weiterhin Daten hinzufügen.</para>
      </note>

      <para>Wenn Sie das Medium aus irgendwelchen Gründen
	doch löschen müssen, verwenden Sie den
	nachstehenden Befehl:</para>

      <screen>&prompt.root; <userinput>growisofs -Z /dev/cd0=/dev/zero</userinput></screen>
    </sect2>

    <sect2>
      <title>DVD-RW-Medien benutzen</title>

      <indexterm>
	<primary>DVD</primary>
	<secondary>DVD-RW</secondary>
      </indexterm>

      <para>Eine DVD-RW kann mit zwei Methoden beschrieben werden:
	<firstterm>Sequential-Recording</firstterm> oder
	<firstterm>Restricted-Overwrite</firstterm>.  Voreingestellt
	ist Sequential-Recording.</para>

      <para>Eine neue DVD-RW kann direkt beschrieben werden; sie
	muss nicht vorher formatiert werden.  Allerdings muss
	eine DVD-RW, die mit Sequential-Recording aufgenommen
	wurde, zuerst gelöscht werden, bevor eine neue Session
	aufgenommen werden kann.</para>

      <para>Der folgende Befehl löscht eine DVD-RW im
	Sequential-Recording-Modus:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format -blank=full /dev/cd0</userinput></screen>

      <note>
	<para>Das vollständige Löschen
	  (<option>-blank=full</option>) dauert mit einem
	  1x&nbsp;Medium ungefähr eine Stunde.  Wenn die
	  DVD-RW im Disk-At-Once-Modus (DAO) aufgenommen wurde,
	  kann Sie mit der Option <option>-blank</option> schneller
	  gelöscht werden.  Um eine DVD-RW im DAO-Modus zu
	  brennen, benutzen Sie das folgende Kommando:</para>

	<screen>&prompt.root; <userinput>growisofs -use-the-force-luke=dao -Z /dev/cd0=imagefile.iso</userinput></screen>

	<para>Die Option <option>-use-the-force-luke=dao</option>
	  sollte nicht erforderlich sein, da &man.growisofs.1;
	  den DAO-Modus erkennt.</para>

	<para>Der Restricted-Overwrite-Modus sollte mit jeder
	  DVD-RW verwendet werden, da er flexibler als der
	  voreingestellte Sequential-Recording-Modus ist.</para>
      </note>

      <para>Um Daten auf eine DVD-RW im Sequential-Recording-Modus
	zu schreiben, benutzen Sie dasselbe Kommando wie
	für die anderen DVD-Formate:</para>

      <screen>&prompt.root; <userinput>growisofs -Z /dev/cd0 -J -R /path/to/data</userinput></screen>

      <para>Wenn Sie weitere Daten zu einer Aufnahme hinzufügen
	wollen, benutzen Sie die Option <option>-M</option> von
	&man.growisofs.1;.  Werden die Daten im Sequential-Recording-Modus
	hinzugefügt, wird eine neue Session erstellt.
	Das Ergebnis ist ein Multi-Session-Medium.</para>

      <para>Eine DVD-RW im Restricted-Overwrite-Modus muss nicht
	gelöscht werden, um eine neue Session aufzunehmen.
	Sie können das Medium einfach mit der Option
	<option>-Z</option> überschreiben, ähnlich wie
	bei DVD+RW.  Mit der Option <option>-M</option> können
	Sie das ISO-9660-Dateisystem, wie mit einer DVD+RW,
	vergrößern.  Die DVD enthält danach eine
	Session.</para>

      <para>Benutzen sie das nachstehende Kommando, um den
	Restricted-Overwrite-Modus einzustellen:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format /dev/cd0</userinput></screen>

      <para>Das folgende Kommando stellt den Modus wieder auf
	Sequential-Recording zurück:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format -blank=full /dev/cd0</userinput></screen>
    </sect2>

    <sect2>
      <title>Multi-Session</title>

      <para>Nur wenige DVD-ROM-Laufwerke können
	Multi-Session-DVDs lesen.  Meist lesen die Spieler nur
	die erste Session.  Mehrere Sessions werden von
	DVD+R, DVD-R und DVD-RW im Sequential-Recording-Modus
	unterstützt.  Im Modus Restricted-Overwrite gibt
	es nur eine Session.</para>

      <para>Wenn das Medium noch nicht geschlossen ist, erstellt
        das nachstehende Kommando eine neue Session auf einer
	DVD+R, DVD-R oder DVD-RW im Sequential-Recording-Modus:</para>

      <screen>&prompt.root; <userinput>growisofs -M /dev/cd0 -J -R /path/to/nextdata</userinput></screen>

      <para>Wird diese Kommandozeile mit DVD+RW- oder DVD-RW-Medien
	im Restricted-Overwrite-Modus benutzt, werden die
	neuen Daten mit den Daten der bestehenden Session
	zusammengeführt.  Das Medium enthält danach
	eine Session.  Auf diesem Weg werden neue Daten zu
	einer bestehenden Session hinzugefügt.</para>

      <note>
	<para>Für den Anfang und das Ende einer Session
	  wird auf dem Medium zusätzlicher Platz verbraucht.
	  Um den Speicherplatz auf dem Medium optimal auszunutzen,
	  sollten Sie daher Sessions mit vielen Daten hinzufügen.
	  Auf ein DVD+R-Medium passen maximal 154&nbsp;Sessions,
	  2000&nbsp;Sessions auf ein DVD-R-Medium und
	  127&nbsp;Sessions auf eine DVD+R Double Layer.</para>
      </note>
    </sect2>

    <sect2>
      <title>Weiterführendes</title>

      <para>Das Kommando <command>dvd+rw-mediainfo
	/dev/cd0</command> zeigt
	Informationen über eine im Laufwerk liegende
	DVD an.</para>

      <para>Weiteres zu den <application>dvd+rw-tools</application>
	lesen Sie bitte in der Hilfeseite &man.growisofs.1;,
	auf der <link xlink:href="http://fy.chalmers.se/~appro/linux/DVD+RW/">dvd+rw-tools
	Web-Seite</link> oder in den Archiven der <link xlink:href="http://lists.debian.org/cdwrite/">cdwrite-Mailingliste</link>.</para>
    </sect2>

    <sect2 xml:id="creating-dvd-ram">
      <title>DVD-RAM</title>

      <indexterm>
	<primary>DVD</primary>
	<secondary>DVD-RAM</secondary>
      </indexterm>

      <sect3>
	<title>Konfiguration</title>

	<para>DVD-RAM-fähige Brenner werden sowohl mit SCSI-
	  als auch mit ATAPI-Schnittstelle angeboten.  Verwenden Sie
	  ein ATAPI-Gerät, müssen Sie den DMA-Modus
	  aktivieren.  Dazu fügen Sie die folgende Zeile in
	  <filename>/boot/loader.conf</filename> ein:</para>

	 <programlisting>hw.ata.atapi_dma="1"</programlisting>
      </sect3>

      <sect3>
	<title>Das Medium vorbereiten</title>

	<para>Wie weiter oben in diesem Kapitel bereits erwähnt,
	  kann man eine DVD-RAM mit einer Wechselplatte vergleichen.
	  Wie diese muss auch eine DVD-RAM vor dem ersten Einsatz
	  <quote>vorbereitet</quote> werden.  In unserem Beispiel
	  wird das gesamte Medium mit dem Standard-UFS2-Dateisystem
	  formatiert.</para>

	<para>Dazu geben Sie als <systemitem class="username">root</systemitem> bei
	  eingelegter DVD-RAM die folgenden Befehle ein:</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/acd0 bs=2k count=1</userinput>
&prompt.root; <userinput>bsdlabel -Bw acd0</userinput>
&prompt.root; <userinput>newfs /dev/acd0</userinput></screen>

	<para>Denken Sie dabei daran, dass Sie gegebenenfalls die
	  Gerätedatei (hier <filename>acd0</filename>) an
	  Ihre Konfiguration anpassen müssen.</para>
      </sect3>

      <sect3>
	<title>Das Medium einsetzen</title>

	<para>Nachdem Sie das Medium vorbereitet haben, können
	  Sie das DVD-RAM-Medium in Ihren Verzeichnisbaum
	  einhängen:</para>

	<screen>&prompt.root; <userinput>mount /dev/acd0 /mnt</userinput></screen>

	<para>Danach können Sie schreibend und lesend auf das
	  Medium zugreifen.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="floppies">
    <info><title>Disketten benutzen</title>
      <authorgroup>
	<author><personname><firstname>Julio</firstname><surname>Merino</surname></personname><contrib>Original von </contrib></author>
      </authorgroup>
      
      <authorgroup>
	<author><personname><firstname>Martin</firstname><surname>Karlsson</surname></personname><contrib>Umgeschrieben von </contrib></author>
      </authorgroup>
    </info>

    

    <para>Disketten sind nützlich, wenn kein anderes
      bewegliches Speichermedium vorhanden ist oder wenn
      nur kleine Datenmengen transferiert werden sollen.</para>

    <para>Dieser Abschnitt beschreibt die Handhabung von Disketten
      unter FreeBSD.  Hauptsächlich geht es um die
      Formatierung und Benutzung von 3,5&nbsp;Zoll Disketten,
      doch lassen sich die Konzepte leicht auf Disketten anderer
      Formate übertragen.</para>

    <sect2>
      <title>Disketten formatieren</title>

      <sect3>
        <title>Die Gerätedateien</title>

        <para>Wie auf jedes andere Gerät auch, greifen Sie
	  auf Disketten über Einträge im Verzeichnis
	  <filename>/dev</filename> zu.  Verwenden Sie dazu die
	  Einträge
	  <filename>/dev/fdN</filename>.</para>
      </sect3>

      <sect3>
	<title>Formatierung</title>

	<para>Bevor eine Diskette benutzt werden kann, muss Sie
	  (low-level) formatiert werden, was normalerweise der
	  Hersteller schon gemacht hat.  Sie können die
	  Diskette allerdings noch einmal formatieren, um das Medium zu
	  überprüfen.  Es ist möglich, die
	  Kapazität der Diskette zu verändern,
	  allerdings sind die meisten Disketten auf 1440&nbsp;kB
	  ausgelegt.</para>

	<para>Mit &man.fdformat.1; formatieren Sie eine
	  Diskette.  Das Kommando erwartet die Angabe eines
	  Gerätenamens.</para>

	<para>Achten Sie bei der Formatierung
	  auf Fehlermeldungen, die schlechte Speichermedien
	  anzeigen.</para>

	<sect4>
	  <title>Disketten formatieren</title>

	  <para>Die Disketten werden mithilfe der Gerätedatei
	    <filename>/dev/fdN</filename>
	    formatiert.  Legen Sie eine 3,5&nbsp;Zoll Diskette in
	    Ihr Laufwerk ein und führen das folgende Kommando
	    aus:</para>

	  <screen>&prompt.root; <userinput>/usr/sbin/fdformat -f 1440 /dev/fd0</userinput></screen>
	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Das Disklabel</title>

      <para>Nach dem Formatieren muss auf der Diskette ein Disklabel
        erstellt werden.  Das Disklabel wird später zerstört, ist
	aber notwendig, um die Größe und Geometrie der Diskette
	zu erkennen.</para>

      <para>Das Disklabel gilt für die ganze Diskette und enthält
	alle Informationen über die Geometrie der Diskette.  Eine
	Liste der möglichen Geometrien finden Sie in
	<filename>/etc/disktab</filename>.</para>

      <para>Erstellen Sie nun das Label mit &man.bsdlabel.8;:</para>

      <screen>&prompt.root; <userinput>/sbin/bsdlabel -B -w /dev/fd0 fd1440</userinput></screen>

    </sect2>

    <sect2>
      <title>Das Dateisystem</title>

      <para>Auf der Diskette muss nun ein Dateisystem erstellt werden
        (high-level Formatierung), damit FreeBSD von der Diskette lesen und
	auf sie schreiben kann.  Das Disklabel wird durch das Anlegen eines
	Dateisystems zerstört.  Falls Sie die Diskette später erneut
	formatieren wollen, müssen Sie dann auch ein neues Disklabel
	anlegen.</para>

      <para>Sie können entweder UFS oder FAT als Dateisystem
	verwenden.  Für Disketten ist FAT das beste Dateisystem.</para>

      <para>Das folgende Kommando legt ein Dateisystem auf der Diskette
        an:</para>

      <screen>&prompt.root; <userinput>/sbin/newfs_msdos /dev/fd0</userinput></screen>

      <para>Die Diskette kann nun benutzt werden.</para>
    </sect2>

    <sect2>
      <title>Verwenden der Diskette</title>

      <para>Zum Einhängen der Diskette in das Dateisystem
	verwenden Sie den Befehl &man.mount.msdosfs.8;.  Sie
	können auch den
	Port <package>emulators/mtools</package>
	verwenden, um mit der Diskette zu arbeiten.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="backups-tapebackups">
    <title>Bandmedien benutzen</title>

    <indexterm><primary>Bandmedien</primary></indexterm>
    <para>Die wichtigsten Bandmedien sind 4mm, 8mm, QIC,
      Mini-Cartridge und DLT.</para>

    <sect2 xml:id="backups-tapebackups-4mm">
      <title>4mm (DDS: Digital Data Storage)</title>

      <indexterm>
	<primary>Bandmedien</primary>
	<secondary>DDS (4mm) Bänder</secondary>
      </indexterm>
      <indexterm>
	<primary>Bandmedien</primary>
	<secondary>QIC Bänder</secondary>
      </indexterm>

      <para>Die 4mm-Bänder ersetzen mehr und mehr das QIC-Format als
        Backupmedium der Wahl für Workstations.  Dieser Trend nahm stark
        zu, als Conner die Firma Archive, einen führenden Hersteller von
        QIC-Laufwerken, aufkaufte und die Produktion von QIC-Laufwerken
        stoppte.  4mm-Laufwerke sind klein und ruhig, haben aber nicht den
        gleichen Ruf der Zuverlässigkeit, den die 8mm-Laufwerke
        genießen.  Die 4mm-Kassetten sind preiswerter und mit den
        Maßen 76,2&nbsp;x&nbsp;50,8&nbsp;x&nbsp;12,7&nbsp;mm
	(3&nbsp;x&nbsp;2&nbsp;x&nbsp;0,5&nbsp;Inch) kleiner als die
        8mm-Kassetten.  Sowohl die 4mm- als auch die 8mm-Magnetköpfe
        haben eine relativ kurze Lebensdauer, weil beide die gleiche
        Helical-Scan-Technik benutzen.</para>

      <para>Der Datendurchsatz dieser Laufwerke beginnt bei etwa
	150&nbsp;kByte/s, Spitzenwerte liegen bei etwa 500&nbsp;kByte/s.
        Die Datenkapazität liegt zwischen 1,3&nbsp;GB und 2&nbsp;GB.
	Die meisten Geräte haben eine Hardwarekompression eingebaut,
	die die Kapazität ungefähr verdoppelt.  Es gibt
        Multi-Drive-Einheiten für Bandbibliotheken mit bis zu 6
        Laufwerken in einem Gehäuse und automatischem Bandwechsel.  Die
        Kapazität einer solchen Bibliothek liegt bei 240&nbsp;GB.</para>

      <para>Der Standard DDS-3 unterstützt nun Bandkapazitäten bis
        zu 12&nbsp;GB (oder komprimiert 24&nbsp;GB).</para>

      <para>4mm-Laufwerke, ebenso wie 8mm-Laufwerke, verwenden Helical-Scan.
        Alle Vor- und Nachteile von Helical-Scan gelten sowohl für 4mm-
        als auch für 8mm-Laufwerke.</para>

      <para>Bänder sollten nach 2.000 Banddurchläufen oder 100
        vollen Backups ersetzt werden.</para>
    </sect2>

    <sect2 xml:id="backups-tapebackups-8mm">
      <title>8mm (Exabyte)</title>
      <indexterm>
	<primary>Bandmedien</primary>
	<secondary>Exabyte (8mm) Bänder</secondary>
      </indexterm>

      <para>8mm-Bänder sind die verbreitetsten SCSI-Bandlaufwerke; sie
        sind das geeignetste Bandformat zum Austausch von Bändern.
        Fast an jedem Standort gibt es ein 8mm-Bandlaufwerk mit 2&nbsp;GB.
        8mm-Bänder sind zuverlässig, gut zu handhaben und
	arbeiten leise.  Bandkassetten sind preiswert und klein mit
	122&nbsp;x&nbsp;84&nbsp;x&nbsp;15&nbsp;mm
        (4,8&nbsp;x&nbsp;3,3&nbsp;x&nbsp;0,6&nbsp;Inch).  Ein Nachteil
	der 8mm-Technik ist die relativ kurze Lebensdauer des
	Schreib-/Lesekopfs und der Bänder auf Grund der hohen
	Relativgeschwindigkeit des Bandes über die Köpfe
	hinweg.</para>

      <para>Der Datendurchsatz liegt ungefähr zwischen
	250&nbsp;kByte/s und 500&nbsp;kByte/s.  Die Datenkapazität
	beginnt bei 300&nbsp;MB und erreicht bis zu 7&nbsp;GB bei den
	Spitzengeräten.  Die meisten Geräte
        haben eine Hardwarekompression eingebaut, die die Kapazität
        ungefähr verdoppelt.  Diese Laufwerke sind erhältlich in
        Form von Einzelgeräten oder als Multi-Drive-Bandbibliotheken mit
        6 Laufwerken und 120 Bändern in einem Gehäuse.  Die
        Bänder werden von der Geräteeinheit automatisch gewechselt.
        Die Kapazität einer solchen Bibliothek liegt bei 840&nbsp;GB und
        mehr.</para>

      <para>Das Exabyte-Modell <quote>Mammoth</quote> unterstützt
	12&nbsp;GB auf einem Band (24&nbsp;GB mit Kompression) und kostet
	etwa doppelt so viel wie ein konventionelles Bandlaufwerk.</para>

      <para>Die Daten werden mittels Helical-Scan auf das Band
        aufgezeichnet, die Köpfe sind leicht schräg zum Medium
        angebracht (mit einem Winkel von etwa 6 Grad).  Das Band wickelt
	sich 270&nbsp;Grad um die Spule, die die Köpfe trägt.
	Die Spule dreht sich, während das Band darüber läuft.
	Das Resultat ist eine hohe Datendichte und eng gepackte Spuren,
	die von einem Rand des Bands zum gegenüberliegenden quer
	über das Band abgewinkelt verlaufen.</para>
    </sect2>

    <sect2 xml:id="backups-tapebackups-qic">
      <title>QIC</title>

      <indexterm>
	<primary>Bandmedien</primary>
	<secondary>QIC-150</secondary>
      </indexterm>

      <para>QIC-150-Bänder und -Laufwerke sind wohl der am weitesten
        verbreitete Bandtyp überhaupt.  QIC-Bandlaufwerke sind die
        preiswertesten <quote>seriösen</quote> Backupgeräte,
	die angeboten werden.  Der Nachteil dabei ist der hohe Preis
	der Bänder.  QIC-Bänder sind im Vergleich zu 8mm- oder
	4mm-Bändern bis zu fünf Mal teurer, wenn man den Preis
	auf 1&nbsp;GB Datenkapazität umrechnet.  Aber wenn Ihr Bedarf
	mit einem halben Dutzend Bänder abgedeckt werden kann,
	mag QIC die richtige Wahl sein.</para>

      <para>QIC ist der <emphasis>gängigste</emphasis>
        Bandlaufwerkstyp.  Jeder Standort hat ein QIC-Laufwerk der einen oder
        anderen Dichte.  Aber gerade das ist der Haken an der Sache, QIC
        bietet eine große Anzahl verschiedener Datendichten auf
        physikalisch ähnlichen (manchmal gleichen) Bändern.
        QIC-Laufwerke sind nicht leise.  Diese Laufwerke suchen lautstark die
        richtige Bandstelle, bevor sie mit der Datenaufzeichnung beginnen.
        Sie sind während des Lesens, Schreibens und Suchens deutlich
        hörbar.</para>

      <para>Die Abmessungen der QIC-Kassetten betragen
	152&nbsp;x&nbsp;102&nbsp;x&nbsp;17&nbsp;mm
	(6&nbsp;x&nbsp;4&nbsp;x&nbsp;0,7&nbsp;Inch).</para>

      <para>Der Datendurchsatz liegt ungefähr zwischen
	150&nbsp;kByte/s und 500&nbsp;kByte/s.  Die Datenkapazität
	reicht von 40&nbsp;MB bis zu 15&nbsp;GB.
        Hardwarekompression ist in vielen der neueren QIC-Laufwerke eingebaut.
        QIC-Laufwerke werden heute seltener eingesetzt; sie werden von den
        DAT-Laufwerken abgelöst.</para>

      <para>Die Daten werden auf dem Band in Spuren aufgezeichnet.  Die
        Spuren verlaufen entlang der Längsachse des Bandmediums von einem
        Ende zum anderen.  Die Anzahl der Spuren, und damit auch die Breite
        einer Spur, variiert mit der Kapazität des Laufwerks.  Die
        meisten, wenn nicht alle neueren Laufwerke sind
        rückwärtskompatibel, zumindest zum Lesen (aber oft auch zum
        Schreiben).  QIC hat einen guten Ruf bezüglich der
        Datensicherheit (die Mechanik ist einfacher und robuster als diejenige
        der Helical-Scan-Laufwerke).</para>

      <para>Bänder sollten nach 5,000 Backups ersetzt werden.</para>
    </sect2>

    <sect2 xml:id="backups-tapebackups-dlt">
      <title>DLT</title>
      <indexterm>
	<primary>Bandmedien</primary>
	<secondary>DLT</secondary>
      </indexterm>

      <para>DLT hat die schnellste Datentransferrate von allen hier
        aufgelisteten Gerätetypen.  Das 1/2-Inch-Band (12,7&nbsp;mm)
	befindet sich in einer Spulkassette mit den Abmessungen
	101,6&nbsp;x&nbsp;101,6&nbsp;x&nbsp;25,4&nbsp;mm
        (4&nbsp;x&nbsp;4&nbsp;x&nbsp;1&nbsp;Inch).  Die eine Seite
	der Kassette hat eine bewegliche Abdeckung.  Der Laufwerksmechanismus
	öffnet diese Abdeckung und zieht die Bandführung heraus.
	Die Bandführung trägt ein ovales Loch, die das Laufwerk
	zum <quote>Einhängen</quote> des Bandes benutzt.  Die
	Aufwickelspule befindet sich im Innern des Bandlaufwerks.  Bei allen
	anderen hier besprochenen Bandkassetten (9-Spur-Bänder
	sind die einzige Ausnahme) befinden sich sowohl die Auf- als auch
	die Abwickelspule im Inneren der Bandkassette.</para>

      <para>Der Datendurchsatz liegt bei etwa 1,5&nbsp;MBytes/s, der dreifache
        Durchsatz der 4mm-, 8mm- oder QIC-Bandlaufwerke.  Die
        Datenkapazität reicht von 10&nbsp;GB bis 20&nbsp;GB für
        Einfachlaufwerke.  Auch Mehrfachbandgeräte sind erhältlich,
        sowohl als Bandwechsler wie auch als Multi-Drive-Bandbibliotheken, die
        Platz für 5 bis 900 Bänder verteilt auf 1 bis 20 Laufwerke
        enthalten, mit einer Speicherkapazität von 50&nbsp;GB bis
	9&nbsp;TB.</para>

      <para>Mit Kompression unterstützt das Format DLT Type IV bis zu
        70&nbsp;GB Kapazität.</para>

      <para>Die Daten werden auf dem Band in Spuren aufgezeichnet, die
        parallel zur Bewegungsrichtung verlaufen (gerade so wie bei den
        QIC-Bändern).  Zwei Spuren werden dabei gleichzeitig beschrieben.
        Die Lebenszeit der Lese- und Schreibköpfe sind relativ lang; denn
        sobald das Band anhält, gibt es keine Relativbewegung mehr
        zwischen den Köpfen und dem Band.</para>
    </sect2>

    <sect2>
      <title xml:id="backups-tapebackups-ait">AIT</title>
      <indexterm>
	<primary>Bandmedien</primary>
	<secondary>AIT</secondary>
      </indexterm>

      <para>AIT ist ein neues Format von Sony, das (mit Kompression) bis zu
        50&nbsp;GB pro Band speichern kann.  Die Bänder haben einen
        Speicherchip, der einen Index mit dem Inhalt des Bandes anlegt.
        Dieser Index kann vom Bandlaufwerk zur schnellen Bestimmung der Lage
        von Dateien auf dem Band benutzt werden, während andere
        Bänder einige Minuten zur Lokalisierung benötigen.</para>

      <para>Entsprechende Software wie etwa
	<application>SAMS:Alexandria</application> können 40
	oder mehr AIT-Bandbibliotheken verarbeiten, indem sie
        direkt mit dem Speicherchip des Bandes kommunizieren, wenn der
        Bandinhalt am Bildschirm dargestellt werden soll oder bestimmt werden
        soll, welche Dateien auf welchem Band gespeichert sind, oder um das
        richtige Band zu lokalisieren, zu laden und Daten vom Band
        zurückzuspielen.  Bibliotheken dieser Art liegen in der
        Preiskategorie von $20,000, womit sie etwas aus dem Hobbymarkt
        herausfallen.</para>
    </sect2>

    <sect2>
      <title>Die erste Benutzung eines neuen Bands</title>

      <para>Der Versuch ein neues, vollkommen leeres Band ohne weiteres zu
        lesen oder zu beschreiben wird schief gehen.  Auf der Konsole werden
        dann Meldungen ähnlich wie folgt ausgegeben:</para>

      <screen>sa0(ncr1:4:0): NOT READY asc:4,1
0(ncr1:4:0): Logical unit is in process of becoming ready</screen>

      <para>Das Band enthält nämlich keinen Identifier-Block
        (Blocknummer 0).  Alle QIC-Bandlaufwerke seit der Einführung des
        QIC-525-Standards schreiben einen Identifier-Block auf das Band.  Es
        gibt zwei Lösungen:</para>

      <itemizedlist>
	<listitem>
	  <para><command>mt fsf 1</command> veranlasst das Bandlaufwerk
	    einen Identifier-Block auf das Band zu schreiben.</para>
	</listitem>

	<listitem>
	  <para>Das Band durch Drücken des Bandauswurfknopfs an der
	    Vorderseite des Bandgeräts auswerfen.</para>

	  <para>Danach das Band wieder einlegen und mit
	    <command>dump</command> Daten auf das Band
	    übertragen.</para>

	  <para>Das Kommando <command>dump</command> gibt die Meldung
	    <errorname>DUMP: End of tape detected</errorname> zurück
	    und die Konsole zeigt:
	    <errorname>HARDWARE FAILURE info:280 asc:80,96</errorname>.</para>

	  <para>Das Band zurückspulen mit dem Kommando:
	    <command>mt rewind</command>.</para>

	  <para>Nachfolgende Bandoperationen werden dann erfolgreich
	    ausgeführt.</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 xml:id="backups-floppybackups">
    <title>Was ist mit Backups auf Disketten?</title>

    <sect2 xml:id="floppies-using">
      <title>Kann ich Disketten zum Backup meiner Daten verwenden?</title>
      <indexterm><primary>Backup Disketten</primary></indexterm>
      <indexterm><primary>Disketten</primary></indexterm>

      <para>Disketten sind kein wirklich geeignetes Medium für Backups
        aus folgenden Gründen:</para>

      <itemizedlist>
        <listitem>
          <para>Disketten sind unzuverlässig, besonders
            langfristig.</para>
        </listitem>

        <listitem>
          <para>Speichern und Wiederherstellen ist sehr langsam.</para>
        </listitem>

        <listitem>
          <para>Sie haben eine sehr eingeschränkte Kapazität (Die
            Zeiten sind längst vorbei, wo eine ganze Festplatte auf ein
            Dutzend Disketten oder so gespeichert werden konnte).</para>
        </listitem>
      </itemizedlist>

      <para>Wenn jedoch keine andere Möglichkeit zum Datenbackup
        vorhanden ist, dann sind Disketten immer noch besser als gar kein
        Backup.</para>

      <para>Wenn man gezwungen ist Disketten zu verwenden, dann sollte man
        auf eine gute Qualität achten.  Disketten, die schon einige Jahre
        im Büro herumgelegen haben, sind eine schlechte Wahl.  Ideal sind
        neue Disketten von einem renommierten Hersteller.</para>
    </sect2>

    <sect2 xml:id="floppies-creating">
      <title>Wie mache ich ein Backup auf Disketten?</title>

      <para>Die beste Art eines Diskettenbackups ist der Befehl
	&man.tar.1; mit der Mehrfachband-Option <option>-M</option>,
	die es ermöglicht ein Backup über mehrere
	Disketten zu verteilen.</para>

      <para>Ein Backup aller Dateien im aktuellen Verzeichnis
        einschließlich aller Unterverzeichnisse wird durch den folgenden
        Befehl veranlasst (als <systemitem class="username">root</systemitem>):</para>

      <screen>&prompt.root; <userinput>tar Mcvf /dev/fd0 *</userinput></screen>

      <para>Wenn die erste Diskette voll ist, meldet sich &man.tar.1;
	und verlangt einen Diskettenwechsel (weil &man.tar.1;
	unabhängig vom
        Medium arbeitet, wird das nächste Band (Volume) verlangt, was in
        diesem Zusammenhang eine Diskette bedeutet), in etwa wie folgt:</para>

      <screen>Prepare volume #2 for /dev/fd0 and hit return:</screen>

      <para>Dies wird mit steigender Volumenzahl wiederholt, bis alle
        angegebenen Dateien archiviert sind.</para>
    </sect2>

    <sect2 xml:id="floppies-compress">
      <title>Können Diskettenbackups komprimiert werden?</title>
      <indexterm>
	<primary><command>tar</command></primary>
      </indexterm>
      <indexterm>
	<primary><command>gzip</command></primary>
      </indexterm>
      <indexterm><primary>Kompression</primary></indexterm>

      <para>Leider erlaubt es &man.tar.1; nicht, die Option
        <option>-z</option> für Multi-Volume-Archive zu verwenden.
        Man kann natürlich alle Dateien mit &man.gzip.1;
	komprimieren, sie mit &man.tar.1; auf die Disketten
	aufspielen, und dann die Dateien wieder &man.gunzip.1;
	dekomprimieren!</para>
    </sect2>

    <sect2 xml:id="floppies-restoring">
      <title>Wie werden Diskettenbackups wieder hergestellt?</title>

      <para>Zur Wiederherstellung des gesamten Archivs verwendet man:</para>

      <screen>&prompt.root; <userinput>tar Mxvf /dev/fd0</userinput></screen>

      <para>Eine Methode um nur bestimmte Dateien wieder her zu stellen ist
        mit der ersten Diskette den folgenden Befehl auszuführen:</para>

      <screen>&prompt.root; <userinput>tar Mxvf /dev/fd0 filename</userinput></screen>

      <para>&man.tar.1; wird dann die folgenden Disketten anfordern,
	bis die benötigte Datei gefunden ist.</para>

      <para>Wenn man die Diskette kennt, auf der sich die Datei befindet,
        kann man alternativ diese Diskette auch direkt einlegen und den
        gleichen Befehl wie oben verwenden.  Man beachte, dass, falls die
        erste Datei eine Fortsetzung einer Datei von einer
        der vorigen Disketten ist, &man.tar.1; die Warnung ausgibt,
	dass diese Datei nicht wiederhergestellt werden kann, selbst dann,
	wenn dies gar nicht verlangt wurde!</para>
    </sect2>
  </sect1>

  <sect1 xml:id="backup-strategies">
    <info><title>Backup-Strategien</title>
      <authorgroup>
	<author><personname><firstname>Lowell</firstname><surname>Gilbert</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
      
    </info>

    

    <para>Wenn Sie eine eigene Backup-Strategie planen, müssen Sie
      darauf achten, dass jedes der folgenden Probleme von Ihrer
      Strategie abgedeckt wird:</para>

    <itemizedlist>
      <listitem>
        <para>Plattendefekte.</para>
      </listitem>
      <listitem>
        <para>Versehentliches Löschen von Dateien.</para>
      </listitem>
      <listitem>
        <para>Eine nicht vorhersehbare Korrumpierung von Dateien.</para>
      </listitem>
      <listitem>
        <para>Die vollständige Zerstörung Ihres Systems, etwa
          durch ein Feuer.  Dazu gehört auch die Zerstörung
          von Backups, die am gleichen Ort aufbewahrt werden.</para>
      </listitem>
    </itemizedlist>

    <para>Es ist nicht nur möglich, dass ein System
      für jedes dieser Probleme eine eigene (oft völlig
      unterschiedliche) Strategie benötigt.  Es ist vielmehr
      unwahrscheinlich (sieht man von Systemen ab, die keine
      wichtigen Daten enthalten),  dass eine Technik alle
      Problembereiche abdecken kann.</para>

    <para>Häufig verwendeten Techniken sind unter anderen:</para>

    <itemizedlist>
      <listitem>
	<para>Die Archivierung des kompletten Systems auf externen
	  Datenträgern, die an einem gesonderten Ort aufbewahrt
	  werden.  Dieser Ansatz schützt zwar vor allen oben
	  angeführten Problemen, ist aber zeitaufwändig.
	  Auch eine Wiederherstellung des Systems ist nicht ohne
	  weiteres möglich.  Zwar können Sie Kopien Ihrer
	  Backups auch vor Ort und/oder auf online zugängigen
	  Systemen aufbewahren, was aber nichts daran ändert,
	  dass eine Wiederherstellung, insbesondere für nicht
	  privilegierte Benutzer, nach wie vor nicht ohne weiteres
	  möglich ist.</para>
      </listitem>

      <listitem>
	<para>Dateisystem-Snapshots.  Diese Technik hilft zwar nur
	  gegen das versehentliche Löschen von Dateien, in einem
	  solchen Fall ist sie aber <emphasis>äußerst</emphasis>
	  hilfreich.  Vorteile dieser Technik sind außerdem die
	  leichte und schnelle Implementierung und Handhabung.</para>
      </listitem>

      <listitem>
	<para>Das Erstellen von Kopien ganzer Dateisysteme und/oder
	  Platten (etwa durch einen periodischen &man.rsync.1;-Transfer des
	  kompletten Systems).  Diese Technik ist insbesondere in
	  Netzwerken mit besonderen Anforderungen nützlich.  Der
	  Schutz vor Plattendefekten ist allerdings schlechter als beim
	  Einsatz von <acronym>RAID</acronym>.  Die
	  Fähigkeiten zur Wiederherstellung gelöschter
	  Dateien sind mit denen von <acronym>UFS</acronym>-Snapshots
	  vergleichbar.  Ob diese Technik für Sie geeignet ist,
	  hängt also letztlich von Ihren Anforderungen ab.</para>
      </listitem>

      <listitem>
	<para><acronym>RAID</acronym>.  Minimiert oder vermeidet
	  Ausfallzeiten, die durch einen Plattendefekt verursacht werden
	  könnten.  Zwar können Plattendefekte (aufgrund
	  der höheren Anzahl verwendeter Platten) häufiger
	  auftreten, sie stellen aber dann kein so akutes Problem
	  dar.</para>
      </listitem>

      <listitem>
	<para>Das Überprüfen von Datei-Fingerprints durch
	  &man.mtree.8;.  Dabei handelt es sich zwar um keine
	  Backup-Technik im eigentlichen Sinne, Sie werden durch den
	  Einsatz dieses Werkzeugs aber informiert, dass Sie auf Ihre
	  Backups zurückgreifen müssen.  Dies ist insbesondere
	  beim Einsatz von Offline-Backups von großer Bedeutung.
	  Daher sollte diese Technik regelmäßig eingesetzt
	  werden.</para>
      </listitem>
    </itemizedlist>

    <para>Es gibt noch zahlreiche weitere Techniken, von denen aber viele
      nur Variationen der eben beschriebenen Techniken sind.  Spezielle
      Anforderungen erfordern dabei in der Regel auch spezielle
      Backup-Techniken (so erfordert das Backup einer aktiven Datenbank
      in der Regel ein auf die eingesetzte Datenbank-Software abgestimmtes
      Verfahren).  Entscheidend ist daher immer, gegen welche Gefahren
      Sie sich schützen und wie Sie diesen Schutz realisieren
      wollen.</para>
  </sect1>

  <sect1 xml:id="backup-basics">
    <title>Datensicherung</title>

    <para>Die drei wichtigsten Programme zur Sicherung von Daten sind
      &man.dump.8;, &man.tar.1; und &man.cpio.1;.</para>

    <sect2>
      <title>Sichern und Wiederherstellen</title>
      <indexterm><primary>Datensicherung</primary></indexterm>
      <indexterm><primary>Backup</primary></indexterm>
      <indexterm>
	<primary>Backup-Software</primary>
	<secondary><command>dump</command></secondary>
      </indexterm>
      <indexterm>
	<primary>Backup-Software</primary>
	<secondary><command>restore</command></secondary>
      </indexterm>
      <indexterm><primary><command>dump</command></primary></indexterm>
      <indexterm><primary><command>restore</command></primary></indexterm>

      <para><command>dump</command> und <command>restore</command> sind die
	traditionellen Backup-Programme in &unix; Systemen.  Sie betrachten das
	Laufwerk als eine Ansammlung von Blöcken, operieren also unterhalb
	des Abstraktionslevels von Dateien, Links und Verzeichnissen, die die
        Grundlage des Dateisystemkonzepts bilden.  Im Gegensatz zu anderen
        Backup-Programmen sichert <command>dump</command> ein ganzes Dateisystem
        auf einem Gerät.  Es ist nicht möglich nur einen Teil des
	Dateisystems, oder einen Verzeichnisbaum, der mehr als ein Dateisystem
	umfasst, zu sichern.  Das <command>dump</command>-Kommando schreibt
	keine Dateien oder Verzeichnisse auf das Band, sondern die Blöcke,
	aus denen Dateien und Verzeichnisse bestehen.  Wenn
	<command>restore</command> für das Extrahieren von Daten verwendet
	wird, werden temporäre Dateien standardmäßig in
	<filename>/tmp/</filename> abgelegt - wenn Sie von einer Platte mit
	einem kleinen <filename>/tmp</filename>-Verzeichnis zurücksichern,
	müssen Sie möglicherweise die Umgebungsvariable
	<envar>TMPDIR</envar> auf ein Verzeichnis mit mehr freiem Speicherplatz
	setzen, damit die Wiederherstellung gelingt.</para>

      <note><para>Wenn Sie mit <command>dump</command> das Root-Verzeichnis
	sichern, werden <filename>/home</filename>, <filename>/usr</filename>
	und viele andere Verzeichnisse nicht gesichert, da dies normalerweise
	Mountpunkte für andere Dateisysteme oder symbolische Links
	zu diesen Dateisystemen sind.</para></note>

      <para><command>dump</command> hat einige Eigenarten, die noch aus den
        frühen Tagen der Version 6 von AT&amp;T UNIX (ca. 1975)
	stammen.  Die Parameter
        sind für 9-Spur-Bänder (6250&nbsp;bpi) voreingestellt,
	nicht auf die heute üblichen Medien hoher Dichte (bis zu
	62.182&nbsp;ftpi).  Bei der Verwendung der Kapazitäten
	moderner Bandlaufwerke muss diese Voreinstellung auf der
	Kommandozeile überschrieben werden.</para>

      <indexterm><primary><filename>.rhosts</filename></primary></indexterm>
      <para><command>rdump</command> und <command>rrestore</command>
	können Daten über
        Netzwerk auf ein Band, das sich in einem Laufwerk eines anderen
        Computers befindet, überspielen.  Beide Programme benutzen die
        Funktionen &man.rcmd.3; und &man.ruserok.3; zum
	Zugriff auf das entfernte
        Bandlaufwerk.  Daher muss der Anwender, der das Backup
        durchführt, auf dem entfernten Rechner in
        <filename>.rhosts</filename> eingetragen sein.</para>

      <para>Die Argumente zu <command>rdump</command> und
	<command>rrestore</command> müssen
        zur Verwendung auf dem entfernten Computer geeignet sein.
	Wenn Sie zum Beispiel mit <command>rdump</command> von einem
	FreeBSD-Rechner aus auf ein Exabyte-Bandlaufwerk einer Sun mit
	Namen <systemitem>komodo</systemitem> zugreifen möchten, setzen Sie
	das folgende Kommando ab:</para>

      <screen>&prompt.root; <userinput>/sbin/rdump 0dsbfu 54000 13000 126 komodo:/dev/nsa8 /dev/da0a 2&gt;&amp;1</userinput></screen>

      <para>Zum Ausführen dieses Kommandos müssen Sie auf dem
	entfernten Rechner in <filename>.rhosts</filename> eingetragen
	sein.  Die r-Kommandos sind ein großes Sicherheitsrisiko,
	daher sollten Sie deren Verwendung sorgfältig
	abwägen.</para>

      <para>Es ist auch möglich, <command>dump</command> und
	<command>restore</command> über eine gesicherte Verbindung
	mit <command>ssh</command> einzusetzen:</para>

      <example>
	<title><command>dump</command> mit <application>ssh</application>
	  benutzen</title>
	<screen>&prompt.root; <userinput>/sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \
	  targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz</userinput></screen>
      </example>

      <para>Sie können ebenfalls mit der internen Methode
	von <command>dump</command> auf entfernte Rechner zugreifen,
	indem Sie die Umgebungsvariable <envar>RSH</envar>
	setzen:</para>

      <example>
	<title><command>dump</command> über <application>ssh</application>
	  mit gesetzter <envar>RSH</envar> benutzen</title>

	<screen>&prompt.root; <userinput>RSH=/usr/bin/ssh /sbin/dump -0uan -f tatargetuser@targetmachine.example.com:/dev/sa0 /usr</userinput></screen>
      </example>
    </sect2>

    <sect2>
      <title><command>tar</command></title>
      <indexterm>
	<primary>Backup-Software</primary>
	<secondary><command>tar</command></secondary>
      </indexterm>

      <para>&man.tar.1; stammt ebenfalls aus Version 6 von AT&amp;T UNIX
	(ca. 1975).  <command>tar</command> arbeitet mit dem Dateisystem,
	denn es schreibt Dateien und Verzeichnisse auf das Band.
	<command>tar</command> unterstützt zwar nicht alle Optionen,
	die bei &man.cpio.1; zur Verfügung stehen, aber dafür
	erfordert es auch nicht die ungewöhnliche Kommando-Pipeline,
	die von <command>cpio</command> verwendet wird.</para>

      <indexterm><primary><command>tar</command></primary></indexterm>

      <para>Um Daten mit <command>tar</command> auf ein an einer
	Sun-Workstation (namens <systemitem>komodo</systemitem>) angeschlossenes
	Exabyte-Bandlaufwerk zu archivieren, geben Sie Folgendes ein:</para>

      <screen>&prompt.root; <userinput>tar cf - . | rsh komodo dd of=tape-device obs=20b</userinput></screen>

      <para>Wenn Sie Bedenken bezüglich der Sicherheit beim Backup
        über das Netz haben, sollten Sie <command>ssh</command> anstatt
        <command>rsh</command> benutzen.</para>
    </sect2>

    <sect2>
      <title>Cpio</title>
      <indexterm>
	<primary>Backup-Software</primary>
	<secondary><command>cpio</command></secondary>
      </indexterm>
      <indexterm>
	<primary><command>cpio</command></primary>
      </indexterm>

      <para>&man.cpio.1; ist das ursprüngliche Programm von
	&unix; Systemen zum Dateitransfer mit magnetischen Medien.
	<command>cpio</command> hat (neben vielen anderen
	Leistungsmerkmalen) Optionen zum Byte-Swapping, zum Schreiben
        einer Anzahl verschiedener Archivformate und zum Weiterleiten von
        Daten an andere Programme über eine Pipeline.  Dieses letzte
        Leistungsmerkmal macht <command>cpio</command> zu einer
	ausgezeichneten Wahl für Installationsmedien.  Leider kann
	<command>cpio</command> keine
        Dateibäume durchlaufen, so dass eine Liste der zu bearbeitenden
        Dateien über <filename>stdin</filename> angegeben werden
        muss.</para>

      <para><command>cpio</command> unterstützt keine Backups
	über das Netzwerk.  Man kann aber eine Pipeline und
	<command>rsh</command> verwenden, um
        Daten an ein entferntes Bandlaufwerk zu senden.</para>

      <screen>&prompt.root; <userinput>for f in directory_list; do</userinput>
<userinput>find $f &gt;&gt; backup.list</userinput>
<userinput>done</userinput>
&prompt.root; <userinput>cpio -v -o --format=newc &lt; backup.list | ssh user@host "cat &gt; backup_device"</userinput></screen>

      <para>Dabei steht <replaceable>directory_list</replaceable> für
	eine Aufzählung der Verzeichnisse, die Sie sichern wollen.
	<replaceable>user</replaceable>@<replaceable>host</replaceable>
	gibt den Benutzer auf dem Zielrechner an, der die Sicherung
	laufen lässt.  Der Ort der Sicherung wird durch
	<replaceable>backup_device</replaceable> angegeben
	(z.B. <filename>/dev/nsa0</filename>).</para>
    </sect2>

    <sect2>
      <title><command>pax</command></title>
      <indexterm>
	<primary>Backup-Software</primary>
	<secondary><command>pax</command></secondary>
      </indexterm>
      <indexterm><primary><command>pax</command></primary></indexterm>
      <indexterm><primary>POSIX</primary></indexterm>
      <indexterm><primary>IEEE</primary></indexterm>

      <para>&man.pax.1; ist die Antwort von IEEE/&posix; auf
	<command>tar</command> und <command>cpio</command>.
        Über die Jahre hinweg sind die verschiedenen
        Versionen von <command>tar</command> und <command>cpio</command> leicht
	inkompatibel geworden.  Daher hat &posix;, statt eine Standardisierung
	zwischen diesen auszufechten, ein neues Archivprogramm geschaffen.
	<command>pax</command> versucht viele der unterschiedlichen
	<command>cpio</command>- und <command>tar</command>-Formate zu lesen
        und zu schreiben, außerdem einige neue, eigene Formate.  Die
        Kommandostruktur ähnelt eher <command>cpio</command> als
	<command>tar</command>.</para>
    </sect2>

    <sect2 xml:id="backups-programs-amanda">
      <title><application>Amanda</application></title>
      <indexterm>
	<primary>Backup-Software</primary>
	<secondary><application>Amanda</application></secondary>
      </indexterm>
      <indexterm>
	<primary><application>Amanda</application></primary>
      </indexterm>

      <!-- Remove link until <port> tag is available -->
      <para><application>Amanda</application>
        (Advanced Maryland Network Disk Archiver) ist ein
        Client/Server-Backupsystem, nicht nur ein einzelnes Programm.
	Ein <application>Amanda</application>-Server kann auf einem
	einzigen Bandlaufwerk Datensicherungen von jeder beliebigen
	Anzahl von Computern speichern, sofern auf diesen jeweils ein
	<application>Amanda</application>-Client läuft und sie
	über Netzwerk mit dem <application>Amanda</application>-Server
	verbunden sind.</para>

      <para>Ein häufiges Problem bei Standorten mit einer Anzahl
        großer Festplatten ist, dass das Kopieren der Daten auf
	Band langsamer vor sich geht als solche Daten anfallen.
	<application>Amanda</application> löst dieses Problem
	durch Verwendung einer <quote>Holding Disk</quote>, einer Festplatte
        zum gleichzeitigen Zwischenspeichern mehrerer Dateisysteme.</para>

      <para>Für Datensicherungen über einen längeren
	Zeitraum erzeugt <application>Amanda</application>
	<quote>Archivsets</quote> von allen Dateisystemen, die in
	<application>Amandas</application> Konfigurationsdatei genannt
	werden.  Ein Archivset ist eine Gruppe von Bändern mit
	vollen Backups und Reihen von inkrementellen (oder differentiellen)
	Backups, die jeweils nur die Unterschiede zum vorigen
        Backup enthalten.  Zur Wiederherstellung von beschädigten
        Dateisystemen benötigt man Das Letzte volle Backup und alle
        darauf folgenden inkrementellen Backups.</para>

      <para>Die Konfigurationsdatei ermöglicht die Feineinstellung
	der Backups und des Netzwerkverkehrs von
	<application>Amanda</application>.  <application>Amanda</application>
	kann zum Schreiben der Daten auf das Band jedes der oben
	beschriebenen Backuprogramme verwenden.
	<application>Amanda</application> ist nicht Teil des Basissystems,
	Sie müssen <application>Amanda</application> über
	die Ports-Sammlung oder als Paket installieren.</para>
    </sect2>

    <sect2>
      <title>Tue nichts</title>

      <para><quote>Tue nichts</quote> ist kein Computerprogramm, sondern die
        am häufigsten angewendete Backupstrategie.  Diese kostet nichts,
        man muss keinen Backup Plan befolgen, einfach nur nein sagen.  Wenn
        etwas passiert, einfach grinsen und ertragen!</para>

      <para>Wenn Ihre Zeit und Ihre Daten nicht so wichtig sind, dann ist
        die Strategie <quote>Tue nichts</quote> das geeignetste Backup-Programm
        für Ihren Computer.  Aber &unix; ist ein nützliches Werkzeug,
	Sie müssen damit rechnen, dass Sie innerhalb von sechs Monaten
	eine Sammlung von Dateien haben, die für Sie wertvoll geworden
        sind.</para>

      <para><quote>Tue nichts</quote> ist die richtige Backupmethode für
        <filename>/usr/obj</filename> und andere Verzeichnisbäume, die
        vom Computer exakt wiedererzeugt werden können.  Ein Beispiel
        sind die Dateien, die diese Handbuchseiten darstellen &ndash; sie
        wurden aus Quelldateien im Format <acronym>SGML</acronym> erzeugt.
	Es ist nicht nötig, Sicherheitskopien der Dateien in den
        sekundären Formaten wie etwa <acronym>HTML</acronym> zu
        erstellen.  Die Quelldateien in <acronym>SGML</acronym> sollten jedoch
        in die regelmäßigen Backups mit einbezogen werden.</para>
    </sect2>

    <sect2>
      <title>Welches Backup-Programm ist am Besten?</title>
      <indexterm>
	<primary>LISA</primary>
      </indexterm>

      <para><command>dump</command>, <emphasis>Punkt und Schluss.</emphasis>
	Elizabeth&nbsp;D. Zwicky hat alle hier genannten Backup-Programme
	bis zur Erschöpfung ausgetestet.  Ihre eindeutige Wahl zur
	Sicherung aller Daten mit Berücksichtigung aller Besonderheiten
	von &unix; Dateisystemen ist <command>dump</command>.</para>

      <para>Elizabeth erzeugte Dateisysteme mit einer großen Vielfalt
        ungewöhnlicher Bedingungen (und einiger gar nicht so
        ungewöhnlicher) und testete jedes Programm durch ein Backup und
        eine Wiederherstellung dieser Dateisysteme.  Unter den Besonderheiten
        waren Dateien mit Löchern, Dateien mit Löchern und einem
        Block mit Null-Zeichen, Dateien mit ausgefallenen Buchstaben im
        Dateinamen, unlesbare und nichtschreibbare Dateien,
        Gerätedateien, Dateien, deren Länge sich während des
        Backups ändert, Dateien, die während des Backups erzeugt und
        gelöscht werden, u.v.m.  Sie berichtete über ihre Ergebnisse
        in LISA V im Oktober 1991, s. <link xlink:href="http://www.coredumps.de/doc/dump/zwicky/testdump.doc.html">Torture-testing
          Backup and Archive Programs</link>.</para>
    </sect2>

    <sect2>
      <title>Die Wiederherstellung in einem Notfall</title>

      <sect3>
        <title>Vor dem Unglück</title>

        <para>Es sind nur vier Vorkehrungen zu treffen, um auf jedes
          erdenkliche Unglück vorbereitet zu sein.</para>

	<indexterm>
	  <primary><command>bsdlabel</command></primary>
	</indexterm>

        <para>Als erstes drucken Sie das bsdlabel jeder Ihrer Festplatten
          (z.B. mittels <command>bsdlabel da0 | lpr</command>), die
          Partitions- und Dateisystemtabelle jeder Festplatte (mit
          <filename>/etc/fstab</filename>) sowie alle Bootmeldungen, jeweils
          in zweifacher Ausfertigung.</para>

	<indexterm><primary>Live-CD</primary></indexterm>

        <para>Zweitens brennen Sie eine <quote>livefs</quote>-CD.  Diese
          CD-ROM enthält alle nötigen Programme, um in einen
          Reperaturmodus zu starten, aus dem heraus Sie unter anderem
          &man.dump.8;, &man.restore.8;, &man.fdisk.8;, &man.bsdlabel.8;,
          &man.newfs.8; sowie &man.mount.8; starten können.
          ISO-Abbilder für das <quote>livefs</quote>-System finden
          Sie unter <uri xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/&arch.i386;/ISO-IMAGES/&rel.current;/&os;-&rel.current;-RELEASE-&arch.i386;-livefs.iso">ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/&arch.i386;/ISO-IMAGES/&rel.current;/&os;-&rel.current;-RELEASE-&arch.i386;-livefs.iso</uri>.</para>

        <para>Drittens, machen Sie oft Backups auf Band.  Jede Änderung
          seit Ihrem letzten Backup kann unwiederbringlich verloren gehen.
          Versehen Sie die Backup-Bänder mit Schreibschutz.</para>

        <para>Viertens, testen Sie das in Schritt 2 erstellte
          <quote>livefs</quote>-System sowie die für das Backup
          notwendigen Bänder.  Dokumentieren Sie diesen Test und
          bewahren Sie diese Notizen zusammen mit der
          <quote>livefs</quote>-CD und den Bändern auf.  Wenn der
          Ernstfall eintritt, werden Sie vielleicht so genervt
          sein, dass Sie ohne Ihre Notizen vielleicht das Backup auf Ihren
          Bändern zerstören.  (Wie das geht?  Man braucht nur
          unglücklicherweise den Befehl <command>tar cvf
            /dev/sa0</command> einzugeben um ein Band zu
          überschreiben).</para>

        <para>Als zusätzliche Sicherheitsvorkehrung, kann man jeweils
          die <quote>livefs</quote>-CD und Bänder doppelt erstellen.
          Eine der Kopien sollte an einem entfernten Standort aufbewahrt
          werden.  Ein entfernter Standort ist NICHT der Keller im gleichen
          Bürogebäude.  Eine Anzahl von Firmen im World Trade Center
          musste diese Lektion auf die harte Tour lernen.  Ein entfernter
          Standort sollte von Ihrem Computer und Ihren Festplatten
          physikalisch durch eine erhebliche Entfernung getrennt sein.</para>
      </sect3>

      <sect3>
        <title>Nach dem Unglück</title>

        <para>Die Schlüsselfrage ist, ob Ihre Hardware überlebt
          hat.  Denn da Sie ja regelmäßig Backups angefertigt
          haben, brauchen Sie sich um die Software keine Sorgen zu
          machen.</para>

        <para>Falls die Hardware beschädigt wurde, ersetzen Sie zuerst
          die defekten Teile bevor Sie den Computer benutzen.</para>

        <para>Falls die Hardware funktioniert, legen Sie die
          <quote>livefs</quote>-CD in das Laufwerk ein und starten den
          Rechner, wodurch das originale Installationsprogramm von &os;
          gestartet wird.  Legen Sie zuerst Ihr Land fest.  Danach
          öffnen Sie das Menü
          <literal>Fixit -- Repair mode with CDROM/DVD/floppy or start
          a shell.</literal> und wählen den Eintrag
          <guimenuitem>CDROM/DVD -- Use the live filesystem
          CDROM/DVD</guimenuitem> aus.  <command>restore</command>
          und die anderen Programme, die Sie benötigen, befinden
          sich dann im Verzeichnis <filename>/mnt2/rescue</filename>.</para>

        <para>Stellen Sie die Dateisysteme nacheinander wieder her.</para>

	<indexterm>
	  <primary><command>mount</command></primary>
	</indexterm>
	<indexterm>
	  <primary>Root-Partition</primary>
	</indexterm>
	<indexterm>
	  <primary><command>bsdlabel</command></primary>
	</indexterm>
	<indexterm>
	  <primary><command>newfs</command></primary>
	</indexterm>

        <para>Versuchen Sie die Root-Partition Ihrer ersten Festplatte
          einzuhängen (z.B. mit <command>mount /dev/sd0a
            /mnt</command>).  Wenn das Bsdlabel beschädigt wurde,
	  benutzen Sie <command>bsdlabel</command> um die Platte
	  neu zu partitionieren und zu benennen und zwar so, dass die
	  Festplatte mit dem Label übereinstimmt, das Sie
	  ausgedruckt und aufbewahrt haben.</para>

        <para>Verwenden Sie <command>newfs</command> um neue Dateisysteme
	  auf den
          Partitionen anzulegen.  Hängen Sie nun die Root-Partition der
          Festplatte mit Schreibzugriff ein (mit <command>mount -u -o rw
            /mnt</command>).  Benutzen Sie Ihr Backup-Programm um die Daten
          für das jeweilige Dateisystem aus den Backup-Bändern
          wieder her zu stellen (z.B. durch <command>restore vrf
            /dev/sta</command>).  Hängen Sie das Dateisystem wieder aus
          (z.B. durch <command>umount /mnt</command>).  Wiederholen Sie diesen
          Ablauf für jedes betroffene Dateisystem.</para>

        <para>Sobald Ihr System wieder läuft, machen Sie gleich wieder
          ein vollständiges Backup auf neue Bänder.  Denn die
          Ursache für den Absturz oder den Datenverlust kann wieder
          zuschlagen.  Eine weitere Stunde, die Sie jetzt noch
          dranhängen, kann Ihnen später ein weiteres Missgeschick
          ersparen.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="disks-virtual">
    <info><title>Netzwerk-, speicher- und dateibasierte Dateisysteme</title>
      <authorgroup>
	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Verbessert und neu strukturiert von </contrib></author>
      </authorgroup>
    </info>
    
    <indexterm>
      <primary>Laufwerke</primary>
      <secondary>virtuelle</secondary>
    </indexterm>

    <para>Neben Laufwerken, die sich physikalisch im Rechner befinden
      wie Diskettenlaufwerke, CDs, Festplatten usw., kann FreeBSD auch
      mit anderen Laufwerken, den <firstterm>virtuellen Laufwerken</firstterm>,
      umgehen.</para>

    <indexterm><primary>NFS</primary></indexterm>
    <indexterm><primary>Coda</primary></indexterm>
    <indexterm>
      <primary>Laufwerke</primary>
      <secondary>speicherbasierte</secondary>
    </indexterm>
    <indexterm>
      <primary>Laufwerke</primary>
      <secondary>RAM-Disks</secondary>
    </indexterm>

    <para>Dazu zählen Netzwerkdateisysteme wie
      <link linkend="network-nfs">Network Filesystem</link> und Coda,
      speicher- und dateibasierte Dateisysteme.</para>

    <para>Abhängig von der verwendeten FreeBSD Version werden
      speicher- und dateibasierte Dateisysteme mit unterschiedlichen
      Werkzeugen angelegt.</para>

    <note>
      <para>Gerätedateien werden unter &os; automatisch
	von &man.devfs.5; angelegt.</para>
    </note>

    <sect2 xml:id="disks-mdconfig">
      <title>Dateibasierte Laufwerke unter FreeBSD</title>
      <indexterm>
        <primary>Laufwerke</primary>
        <secondary>dateibasierte</secondary>
      </indexterm>

      <para>Unter FreeBSD werden virtuelle Laufwerke
	(&man.md.4;) mit &man.mdconfig.8; erzeugt.  Dazu muss das Modul
	&man.md.4; geladen sein oder das entsprechende Gerät in der
	Kernelkonfiguration aktiviert sein:</para>

      <programlisting>device md</programlisting>

      <para>Mit &man.mdconfig.8; können drei verschiedene virtuelle
        Laufwerke angelegt werden: speicherbasierte Laufwerke, deren
	Speicher von &man.malloc.9; zur Verfügung gestellt wird, oder
	dateibasierte Laufwerke, deren Speicher von einer Datei oder dem
	Swap-Bereich zur Verfügung gestellt wird.  Eine mögliche
	Anwendung ist das Einhängen von Dateien, die Abbilder von
	CD-ROMs oder Disketten enthalten.</para>

      <para>Das Abbild eines Dateisystems wird wie folgt
        eingehangen:</para>

      <example>
	<title>Einhängen eines existierenden Abbildes unter
	  FreeBSD</title>

	<screen>&prompt.root; <userinput>mdconfig -a -t vnode -f diskimage -u 0</userinput>
&prompt.root; <userinput>mount /dev/md0 /mnt</userinput></screen>
      </example>

      <para>Ein neues Dateisystem-Abbild erstellen Sie mit
        &man.mdconfig.8; wie folgt:</para>

      <example>
	<title>Erstellen eines dateibasierten Laufwerks mit
	  <command>mdconfig</command></title>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=newimage bs=1k count=5k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mdconfig -a -t vnode -f newimage -u 0</userinput>
&prompt.root; <userinput>bsdlabel -w md0 auto</userinput>
&prompt.root; <userinput>newfs md0a</userinput>
/dev/md0a: 5.0MB (10224 sectors) block size 16384, fragment size 2048
        using 4 cylinder groups of 1.25MB, 80 blks, 192 inodes.
super-block backups (for fsck -b #) at:
 160, 2720, 5280, 7840
&prompt.root; <userinput>mount /dev/md0a /mnt</userinput>
&prompt.root; <userinput>df /mnt</userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0a       4710    4  4330     0%    /mnt</screen>
      </example>

      <para>Wenn Sie keine Gerätenummer mit dem Schalter
        <option>-u</option> angeben, wird von &man.md.4; automatisch eine
	ungenutzte Gerätenummer zugewiesen.  Das zugewiesene Gerät
	wird auf der Standardausgabe ausgegeben (zum Beispiel
	<filename>md4</filename>).  Weitere Informationen entnehmen Sie
	bitte der Hilfeseite &man.mdconfig.8;.</para>

      <para>Das Werkzeug &man.mdconfig.8; ist sehr nützlich, doch muss
        man viele Kommandos absetzen, um ein dateibasiertes Dateisystem zu
	erstellen.  FreeBSD enthält das Werkzeug &man.mdmfs.8;, das
	die notwendigen Schritte in einem Befehl zusammenfasst.  Es
	konfiguriert mit &man.mdconfig.8; ein &man.md.4;-Laufwerk, erstellt
	darauf mit &man.newfs.8; ein Dateisystem und hängt es
	anschließend mit &man.mount.8; ein.  Das virtuelle Laufwerk
	aus dem obigen Beispiel kann somit einfach mit den nachstehenden
	Befehlen erstellt werden:</para>

      <example>
	<title>Mit <command>mdmfs</command> ein dateibasiertes
	  Dateisystem erstellen</title>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=newimage bs=1k count=5k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mdmfs -F newimage -s 5m md0 /mnt</userinput>
&prompt.root; <userinput>df /mnt</userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0        4718    4  4338     0%    /mnt</screen>
      </example>

      <para>Wenn sie die Option <option>md</option> ohne Gerätenummer
        verwenden, wählt &man.md.4; automatisch ein ungenutztes
	Gerät aus.  Weitere Einzelheiten entnehmen Sie bitte der
	Hilfeseite &man.mdmfs.8;.</para>
    </sect2>

    <sect2 xml:id="disks-md-freebsd5">
      <title>Speicherbasierte Laufwerke unter FreeBSD</title>

      <indexterm>
	<primary>Laufwerke</primary>
	<secondary>speicherbasierte</secondary>
      </indexterm>

      <para>Verwenden Sie ein
	speicherbasiertes Dateisystem, sollten Sie die Option
	<quote>swap backing</quote> aktivieren.   Setzen Sie diese
	Option, heißt dies allerdings nicht, dass das
	speicherbasierte Laufwerk automatisch auf ihre Festplatte
	ausgelagert wird, vielmehr wird der Speicherplatz danach
	aus einem Speicherpool angefordert, der bei Bedarf auf
	die Platte ausgelagert werden kann.  Zusätzlich ist
	es möglich, &man.malloc.9;-gestützte
	speicherbasierte Laufwerke zu erstellen.  Das Anlegen solcher
	Laufwerke kann allerdings zu einer System-Panic führen,
	wenn der Kernel danach über zu wenig Speicher
	verfügt.</para>

      <example>
	<title>Erstellen eines speicherbasierten Laufwerks mit
	  <command>mdconfig</command></title>

	<screen>&prompt.root; <userinput>mdconfig -a -t swap -s 5m -u 1</userinput>
&prompt.root; <userinput>newfs -U md1</userinput>
/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048
        using 4 cylinder groups of 1.27MB, 81 blks, 192 inodes.
        with soft updates
super-block backups (for fsck -b #) at:
 160, 2752, 5344, 7936
&prompt.root; <userinput>mount /dev/md1 /mnt</userinput>
&prompt.root; <userinput>df /mnt</userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4718    4  4338     0%    /mnt</screen>
      </example>

      <example>
	<title>Erstellen eines speicherbasierten Laufwerks mit
	  <command>mdmfs</command></title>
	<screen>&prompt.root; <userinput>mdmfs -s 5m md2 /mnt</userinput>
&prompt.root; <userinput>df /mnt</userinput>

&prompt.root; <userinput>df /mnt</userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md2        4846    2  4458     0%    /mnt</screen>
      </example>
    </sect2>

    <sect2>
      <title>Virtuelle Laufwerke freigeben</title>
      <indexterm>
        <primary>Laufwerke</primary>
        <secondary>Freigabe von virtuellen Laufwerken</secondary>
      </indexterm>

      <para>Wenn ein virtuelles Laufwerk nicht mehr gebraucht wird, sollten
        Sie dem System die belegten Ressourcen zurückgeben.
	Hängen Sie dazu zuerst das Dateisystem ab und geben Sie dann
	die benutzten Ressourcen mit &man.mdconfig.8; frei.</para>

      <para>Alle von <filename>/dev/md4</filename> belegten Ressourcen
        werden mit dem nachstehenden Kommando freigegeben:</para>

      <screen>&prompt.root; <userinput>mdconfig -d -u 4</userinput></screen>

      <para>Eingerichtete &man.md.4;-Geräte werden mit dem Befehl
        <command>mdconfig -l</command> angezeigt.</para>

    </sect2>
  </sect1>

  <sect1 xml:id="snapshots">
    <info><title>Schnappschüsse von Dateisystemen</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
      
    </info>

    

    <indexterm>
      <primary>Schnappschüsse</primary>
      <secondary>von Dateisystemen</secondary>
    </indexterm>

    <para>Zusammen mit <link linkend="soft-updates">Soft Updates</link>
      bietet FreeBSD eine neue Funktion:  Schnappschüsse von
      Dateisystemen.</para>

    <para>Schnappschüsse sind Dateien, die ein Abbild eines
      Dateisystems enthalten und müssen auf dem jeweiligen
      Dateisystem erstellt werden.  Pro Dateisystem darf es maximal
      20&nbsp;Schnappschüsse, die im Superblock vermerkt werden, geben.
      Schnappschüsse bleiben erhalten, wenn das Dateisystem abgehangen,
      neu eingehangen oder das System neu gestartet wird.  Wenn Sie einen
      Schnappschuss nicht mehr benötigen, können Sie ihn
      mit &man.rm.1; löschen.  Es ist egal, in welcher Reihenfolge
      Schnappschüsse gelöscht werden.  Es kann allerdings
      vorkommen, dass nicht der gesamte Speicherplatz
      wieder freigegeben wird, da ein anderer
      Schnappschuss einen Teil der entfernten Blöcke für sich
      beanspruchen kann.</para>

    <para>Das unveränderliche <option>Snapshot</option>-Dateiflag
      wird nach der Erstellung des Snaphshots von &man.mksnap.ffs.8;
      gesetzt.  Durch die Verwendung von &man.unlink.1; ist es allerdings
      möglich, einen Schnappschuss zu löschen.</para>

    <para>Schnappschüsse werden mit &man.mount.8; erstellt.  Das
      folgende Kommando legt einen Schnappschuss von
      <filename>/var</filename> in <filename>/var/snapshot/snap</filename>
      ab:</para>

<screen>&prompt.root; <userinput>mount -u -o snapshot /var/snapshot/snap /var</userinput></screen>

    <para>Den Schnappschuss können Sie auch mit &man.mksnap.ffs.8;
      erstellen:</para>

    <screen>&prompt.root; <userinput>mksnap_ffs /var /var/snapshot/snap</userinput></screen>

    <para>Um einen Schnappschuss auf Ihrem System zu finden, verwenden
      Sie &man.find.1;:</para>

    <screen>&prompt.root; <userinput>find /var -flags snapshot</userinput></screen>

    <para>Nachdem ein Schnappschuss erstellt wurde, können Sie
      ihn für verschiedene Zwecke benutzen:</para>

    <itemizedlist>
      <listitem>
	<para>Sie können den Schnappschuss für die
	  Datensicherung benutzen und ihn auf eine CD oder ein Band
	  schreiben.</para>
      </listitem>

      <listitem>
	<para>Sie können den Schnappschuss mit &man.fsck.8;
	  manuell prüfen.  Wenn das Dateisystem zum Zeitpunkt der
	  Erstellung des Schnappschusses in Ordnung war, sollte
	  &man.fsck.8; immer erfolgreich durchlaufen.  Der
	  Hintergrund-Prozess &man.fsck.8; hat im Übrigen genau
	  diese Aufgabe.</para>
      </listitem>

      <listitem>
	<para>Sie können den Schnappschuss mit &man.dump.8;
	  sichern.  Sie erhalten dann eine konsistente Sicherung des
	  Dateisystems zu dem Zeitpunkt, der durch den Zeitstempel des
	  Schnappschusses gegeben ist.  Der Schalter <option>-L</option>
	  von &man.dump.8; erstellt für die Sicherung einen
	  Schnappschuss und entfernt diesen am Ende der Sicherung
	  wieder.</para>
      </listitem>

      <listitem>
	<para>Sie können einen Schnappschuss in den
	  Verzeichnisbaum einhängen und sich dann den Zustand des
	  Dateisystems zu dem Zeitpunkt ansehen, an dem der
	  Schnappschuss erstellt wurde.  Der folgende Befehl
	  hängt den Schnappschuss
	  <filename>/var/snapshot/snap</filename> ein:</para>

	<screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /var/snapshot/snap -u 4</userinput>
&prompt.root; <userinput>mount -r /dev/md4 /mnt</userinput></screen>

      </listitem>
    </itemizedlist>

    <para>Sie können sich nun den eingefrorenen Stand des
      <filename>/var</filename> Dateisystems unterhalb von
      <filename>/mnt</filename> ansehen.  Mit Ausnahme der früheren
      Schnappschüsse, die als leere Dateien auftauchen, wird zu
      Beginn alles so aussehen, wie zum Zeitpunkt der Erstellung des
      Schnappschusses.  Wenn Sie den Schnappschuss nicht mehr
      benötigen, können Sie ihn, wie nachfolgend gezeigt,
      abhängen:</para>

    <screen>&prompt.root; <userinput>umount /mnt</userinput>
&prompt.root; <userinput>mdconfig -d -u 4</userinput></screen>

    <para>Weitere Informationen über Soft Updates und
      Schnappschüsse von Dateisystemen sowie technische Artikel finden
      Sie auf der <link xlink:href="http://www.mckusick.com/">Webseite
        von Marshall Kirk McKusick</link>.</para>
  </sect1>

  <sect1 xml:id="quotas">
    <title>Dateisystem-Quotas</title>
    <indexterm>
      <primary>Accounting</primary>
      <secondary>Plattenplatz</secondary>
    </indexterm>
    <indexterm><primary>Disk Quotas</primary></indexterm>

    <para>Quotas sind eine optionale Funktion des Betriebssystems,
      die es Ihnen erlauben, den Plattenplatz und/oder die Anzahl
      der Dateien eines Benutzers oder der Mitglieder einer Gruppe,
      auf Dateisystemebene zu beschränken.  Oft wird dies
      auf Timesharing-Systemen (Mehrbenutzersystemen) genutzt, da
      es dort erwünscht ist, die Ressourcen, die ein Benutzer oder
      eine Gruppe von Benutzern belegen können, zu limitieren.  Das
      verhindert, dass ein Benutzer oder eine Gruppe von Benutzern
      den ganzen verfügbaren Plattenplatz belegt.</para>

    <sect2>
      <title>Konfiguration des Systems, um Quotas zu
	aktivieren</title>

      <para>Bevor Quotas benutzt werden können, müssen
	sie im Kernel konfiguriert werden, wozu die folgende Zeile
	der Kernelkonfiguration hinzugefügt wird:</para>

      <programlisting>options QUOTA</programlisting>

      <para>Im gewöhnlichen <filename>GENERIC</filename> Kernel
        sind Quotas nicht aktiviert, so dass Sie einen angepassten
	Kernel konfigurieren und bauen müssen, um Quotas zu
	benutzen.  Weitere Informationen
	finden Sie in <xref linkend="kernelconfig"/>.</para>

      <para>Durch Hinzufügen der folgenden Zeile in
        <filename>/etc/rc.conf</filename> wird das Quota-System
	in &os;&nbsp;7.X und ältere aktiviert:</para>

      <programlisting>enable_quotas="YES"</programlisting>

      <para>Seit &os;&nbsp;8.0-RELEASE und dessen Nachfolger fügen
        Sie stattdessen die folgende Zeile hinzu:</para>

      <programlisting>quota_enable="YES"</programlisting>
      <indexterm>
	<primary>Disk Quotas</primary>
	<secondary>überprüfen</secondary>
      </indexterm>

      <para>Um den Start des Quota-Systems zu beeinflussen, steht
	eine weitere Variable zur Verfügung.  Normalerweise
	wird beim Booten die Integrität der Quotas auf
	allen Dateisystemen mit &man.quotacheck.8;
	überprüft.  &man.quotacheck.8; stellt
	sicher, dass die Quota-Datenbank mit den Daten auf
	einem Dateisystem übereinstimmt.  Dies ist allerdings
	ein sehr zeitraubender Prozess, der die Zeit, die
	das System zum Booten braucht, signifikant beeinflusst.
	Eine Variable in <filename>/etc/rc.config</filename> erlaubt es Ihnen,
	diesen Schritt zu überspringen:</para>

      <programlisting>check_quotas="NO"</programlisting>

      <para>Schließlich müssen Sie noch in
	<filename>/etc/fstab</filename> die Plattenquotas auf
	Dateisystemebene aktivieren.  Dort können Sie
	für alle Dateisysteme Quotas für Benutzer, Gruppen
	oder für beide aktivieren.</para>

      <para>Um Quotas pro Benutzer für ein Dateisystem zu
        aktivieren, geben Sie für dieses Dateisystem die
	Option <option>userquota</option> im Feld Optionen von
	<filename>/etc/fstab</filename> an.  Beispiel:</para>

      <programlisting>/dev/da1s2g   /home    ufs rw,userquota 1 2</programlisting>

      <para>Um Quotas für Gruppen einzurichten, verwenden
	Sie <option>groupquota</option> anstelle von
	<option>userquota</option>.  Um Quotas für Benutzer
	und Gruppen einzurichten, ändern Sie den Eintrag
	wie folgt ab:</para>

      <programlisting>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</programlisting>

      <para>Die Quotas werden jeweils im Rootverzeichnis des Dateisystems
	unter dem Namen <filename>quota.user</filename> für
	Benutzer-Quotas und <filename>quota.group</filename> für
	Gruppen-Quotas abgelegt.  Obwohl &man.fstab.5; beschreibt,
	dass diese Dateien an anderer Stelle gespeichert werden
	können, wird das nicht empfohlen, da es den Anschein hat,
	dass die verschiedenen Quota-Utilities das nicht richtig
	unterstützen.</para>

      <para>Jetzt sollten Sie Ihr System mit dem neuen Kernel booten.
	<filename>/etc/rc</filename> wird dann automatisch die
	richtigen Kommandos aufrufen, die die Quota-Dateien für
	alle Quotas, die Sie in <filename>/etc/fstab</filename>
	definiert haben, anlegen.  Deshalb müssen vorher auch keine
	leeren Quota-Dateien angelegt werden.</para>

      <para>Normalerweise brauchen Sie die Kommandos
	&man.quotacheck.8;, &man.quotaon.8; oder
	&man.quotaoff.8; nicht händisch aufzurufen,
	obwohl Sie vielleicht die entsprechenden Seiten im
	Manual lesen sollten, um sich mit ihnen vertraut
	zu machen.</para>
    </sect2>

    <sect2>
      <title>Setzen von Quota-Limits</title>
      <indexterm>
	<primary>Disk Quotas</primary>
	<secondary>Limits</secondary>
      </indexterm>

      <para>Nachdem Sie Quotas in Ihrem System aktiviert haben, sollten
        Sie überprüfen, dass Sie auch tatsächlich
	aktiviert sind.  Führen Sie dazu einfach den folgenden
	Befehl aus:</para>

      <screen>&prompt.root; <userinput>quota -v</userinput></screen>

      <para>Für jedes Dateisystem, auf dem Quotas aktiviert sind,
	sollten Sie eine Zeile mit der Plattenauslastung und den
	aktuellen Quota-Limits sehen.</para>

      <para>Mit &man.edquota.8; können Sie nun
	Quota-Limits setzen.</para>

      <para>Sie haben mehrere Möglichkeiten, die Limits für
	den Plattenplatz, den ein Benutzer oder eine Gruppe verbrauchen
	kann, oder die Anzahl der Dateien, die angelegt werden dürfen,
	festzulegen.  Die Limits können auf dem Plattenplatz
	(Block-Quotas) oder der Anzahl der Dateien (Inode-Quotas) oder
	einer Kombination von beiden basieren.
	Jedes dieser Limits wird weiterhin in zwei Kategorien geteilt:
	Hardlimits und Softlimits.</para>

      <indexterm><primary>Hardlimit</primary></indexterm>
      <para>Ein Hardlimit kann nicht überschritten werden.
	Hat der Benutzer einmal ein Hardlimit erreicht, so kann er
	auf dem betreffenden Dateisystem keinen weiteren Platz mehr
	beanspruchen.  Hat ein Benutzer beispielsweise ein Hardlimit
	von 500 Kilobytes auf einem Dateisystem und benutzt davon
	490 Kilobyte, so kann er nur noch 10 weitere Kilobytes
	beanspruchen.  Der Versuch, weitere 11 Kilobytes zu beanspruchen,
	wird fehlschlagen.</para>

      <indexterm><primary>Softlimit</primary></indexterm>
      <para>Im Gegensatz dazu können Softlimits für eine
	befristete Zeit überschritten werden.  Diese Frist
	beträgt in der Grundeinstellung
	eine Woche.  Hat der Benutzer das Softlimit über die
	Frist hinaus überschritten, so wird das Softlimit in
	ein Hardlimit umgewandelt und der Benutzer kann
	keinen weiteren Platz mehr beanspruchen.  Wenn er einmal
	das Softlimit unterschreitet, wird die Frist wieder
	zurückgesetzt.</para>

      <para>Das folgende Beispiel zeigt die Benutzung von
	&man.edquota.8;.  Wenn &man.edquota.8; aufgerufen wird,
	wird der Editor gestartet, der durch <envar>EDITOR</envar>
	gegeben ist oder <application>vi</application> falls
	<envar>EDITOR</envar> nicht gesetzt ist.  In dem Editor
	können Sie die Limits eingeben.</para>

      <screen>&prompt.root; <userinput>edquota -u test</userinput></screen>

      <programlisting>Quotas for user test:
/usr: kbytes in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)</programlisting>

      <para>Für jedes Dateisystem, auf dem Quotas aktiv sind,
	sehen Sie zwei Zeilen, eine für die Block-Quotas und die
	andere für die Inode-Quotas.  Um ein Limit zu modifizieren,
	ändern Sie einfach den angezeigten Wert.  Um beispielsweise
	das Blocklimit dieses Benutzers von einem Softlimit von 50
	und einem Hardlimit von 75 auf ein Softlimit von 500 und
	ein Hardlimit von 600 zu erhöhen, ändern Sie
	die Zeile</para>

      <programlisting>/usr: kbytes in use: 65, limits (soft = 50, hard = 75)</programlisting>

      <para>zu:</para>

      <programlisting>/usr: kbytes in use: 65, limits (soft = 500, hard = 600)</programlisting>

      <para>Die neuen Limits sind wirksam, wenn Sie den
	Editor verlassen.</para>

      <para>Manchmal ist es erwünscht, die Limits für einen
	Bereich von UIDs zu setzen.  Dies kann mit der <option>-p</option>
	Option von &man.edquota.8; bewerkstelligt werden.
	Weisen Sie dazu die Limits einem Benutzer zu und rufen danach
	<command>edquota -p protouser startuid-enduid</command> auf.
	Besitzt beispielsweise der Benutzer <systemitem class="username">test</systemitem>
	die gewünschten Limits, können diese mit
	dem folgenden Kommando für die UIDs 10.000 bis 19.999
	dupliziert werden:</para>

      <screen>&prompt.root; <userinput>edquota -p test 10000-19999</userinput></screen>

      <para>Weitere Informationen erhalten Sie in &man.edquota.8;.</para>
    </sect2>

    <sect2>
      <title>Überprüfen von Quota-Limits und Plattennutzung</title>
      <indexterm>
	<primary>Disk Quotas</primary>
	<secondary>überprüfen</secondary>
      </indexterm>

      <para>Sie können &man.quota.1; oder
	&man.repquota.8; benutzen, um Quota-Limits
	und Plattennutzung zu überprüfen.  Um die Limits
	oder die Plattennutzung individueller Benutzer und Gruppen
	zu überprüfen, kann &man.quota.1;
	benutzt werden.  Ein Benutzer kann nur die eigenen Quotas und die
	Quotas der Gruppe, der er angehört untersuchen.  Nur der
	Superuser darf sich alle Limits ansehen.
	Mit &man.repquota.8; erhalten Sie eine Zusammenfassung
	von allen Limits und der Plattenausnutzung für alle
	Dateisysteme, auf denen Quotas aktiv sind.</para>

      <para>Das folgende Beispiel zeigt die Ausgabe von
	<command>quota -v</command> für einen Benutzer, der
	Quota-Limits auf zwei Dateisystemen besitzt:</para>

      <programlisting>Disk quotas for user test (uid 1002):
     Filesystem  usage   quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</programlisting>

      <indexterm>
	<primary>Disk Quotas</primary>
	<secondary>Frist</secondary>
      </indexterm>
      <para>Im Dateisystem <filename>/usr</filename> liegt der Benutzer
	momentan 15 Kilobytes über dem Softlimit von
	50 Kilobytes und hat noch 5 Tage seiner Frist übrig.
	Der Stern <literal>*</literal> zeigt an, dass der
	Benutzer sein Limit überschritten hat.</para>

      <para>In der Ausgabe von &man.quota.1; werden Dateisysteme,
	auf denen ein Benutzer keinen Platz verbraucht, nicht angezeigt,
	auch wenn diesem Quotas zugewiesen wurden.  Mit <option>-v</option>
	werden diese Dateisysteme, wie <filename>/usr/var</filename>
	im obigen Beispiel, angezeigt.</para>
    </sect2>

    <sect2>
      <title>Quotas über NFS</title>
      <indexterm><primary>NFS</primary></indexterm>

      <para>Quotas werden von dem Quota-Subsystem auf dem NFS Server
	erzwungen.  Der &man.rpc.rquotad.8; D&aelig;mon stellt
	&man.quota.1; die Quota Informationen auf dem NFS Client
	zur Verfügung, so dass Benutzer auf diesen
	Systemen ihre Quotas abfragen können.</para>

      <para>Aktivieren Sie <command>rpc.rquotad</command> in
	<filename>/etc/inetd.conf</filename> wie folgt:</para>

      <programlisting>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</programlisting>

      <para>Anschließend starten Sie <command>inetd</command>
	neu:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/inetd restart</userinput></screen>
    </sect2>
  </sect1>

  <sect1 xml:id="disks-encrypting">
    <info><title>Partitionen verschlüsseln</title>
      <authorgroup>
	<author><personname><firstname>Lucky</firstname><surname>Green</surname></personname><contrib>Beigetragen von </contrib><affiliation>
	    <address><email>shamrock@cypherpunks.to</email></address>
	  </affiliation></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>Partitionen</primary>
      <secondary>verschlüsseln</secondary>
    </indexterm>

    <para>FreeBSD bietet ausgezeichnete Möglichkeiten, Daten vor
      unberechtigten Zugriffen zu schützen.  Wenn das
      Betriebssystem läuft, schützen Zugriffsrechte und
      vorgeschriebene Zugriffskontrollen (MAC) (siehe <xref linkend="mac"/>)
      die Daten.  Die Zugriffskontrollen des Betriebssystems
      schützen allerdings nicht vor einem Angreifer, der
      Zugriff auf den Rechner hat.  Der Angreifer
      kann eine Festplatte einfach in ein anderes System einbauen
      und dort die Daten analysieren.</para>

    <para>Die für &os; verfügbaren kryptografischen
      Subsysteme <application>GEOM Based Disk Encryption (gbde)</application>
      und <command>geli</command> sind in der Lage, Daten auf
      Dateisystemen auch vor hoch motivierten Angreifern zu
      schützen,  die über erhebliche Mittel verfügen.
      Dieser Schutz ist unabhängig von der Art und Weise, durch
      die ein Angreifer Zugang zu einer Festplatte oder zu einem
      Rechner erlangt hat.  Im Gegensatz zu schwerfälligen
      Systemen, die einzelne Dateien verschlüsseln,
      verschlüsseln <application>gbde</application> und
      <command>geli</command> transparent ganze Dateisysteme.  Auf der
      Festplatte werden dabei keine Daten im Klartext gespeichert.</para>

    <sect2>
      <title>Plattenverschlüsselung mit
        <application>gbde</application></title>

      <procedure>
	<step>
	  <title>Wechseln sie zu <systemitem class="username">root</systemitem></title>

	  <para>Sie benötigen Superuser-Rechte, um
	    <application>gbde</application> einzurichten.</para>

	  <screen>&prompt.user; <userinput>su -</userinput>
Password:</screen>
	</step>

	<step>
	  <title>Aktivieren Sie &man.gbde.4; in
	    der Kernelkonfigurationsdatei</title>

	  <para>Fügen Sie folgende Zeile in Ihre
	    Kernelkonfigurationsdatei ein:</para>

	  <para><literal>options GEOM_BDE</literal></para>

	  <para>Übersetzen und installieren Sie den FreeBSD-Kernel
	    wie in <xref linkend="kernelconfig"/> beschrieben.</para>

	  <para>Starten sie das System neu, um den neuen Kernel
	    zu benutzen.</para>
	</step>

	<step>
	  <para>Alternativ zur Neukompilierung des Kernels können
	    Sie auch <command>kldload</command> verwenden, um das
	    Kernelmodul &man.gbde.4; zu laden:</para>

	  <screen>&prompt.root; <userinput>kldload geom_bde</userinput></screen>

	</step>
      </procedure>

    <sect3>
      <title>Einrichten eines verschlüsselten Dateisystems</title>

      <para>Das folgende Beispiel beschreibt, wie ein Dateisystem
	auf einer neuen Festplatte verschlüsselt wird.  Das
	Dateisystem wird in <filename>/private</filename> eingehangen.
	Mit <application>gbde</application> könnten auch
	<filename>/home</filename> und <filename>/var/mail</filename>
	verschlüsselt werden.  Die dazu nötigen Schritte
	können allerdings in dieser Einführung
	nicht behandelt werden.</para>

      <procedure>
	<step>
	  <title>Installieren der Festplatte</title>

	  <para>Installieren Sie die Festplatte wie in
	    <xref linkend="disks-adding"/> beschrieben.  Im Beispiel
	    verwenden wir die Partition <filename>/dev/ad4s1c</filename>.
	    Die Gerätedateien
	    <filename>/dev/ad0s1*</filename>
	    sind Standard-Partitionen des FreeBSD-Systems.</para>

	  <screen>&prompt.root; <userinput>ls /dev/ad*</userinput>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4</screen>
	</step>

	<step>
	  <title>Verzeichnis für gbde-Lock-Dateien anlegen</title>

	  <screen>&prompt.root; <userinput>mkdir /etc/gbde</userinput></screen>

	  <para>Die Lock-Dateien sind für den Zugriff von
	    <application>gbde</application> auf verschlüsselte
	    Partitionen notwendig.  Ohne die Lock-Dateien können
	    die Daten nur mit erheblichem manuellen Aufwand wieder
	    entschlüsselt werden (dies wird auch von der Software
	    nicht unterstützt).  Jede verschlüsselte
	    Partition benötigt eine gesonderte Lock-Datei.</para>
	</step>

	<step>
	  <title>Vorbereiten der gbde-Partition</title>

	  <para>Eine von <application>gbde</application> benutzte
	    Partition muss einmalig vorbereitet werden:</para>

	  <screen>&prompt.root; <userinput>gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock</userinput></screen>

	  <para>&man.gbde.8; öffnet eine Vorlage in Ihrem Editor,
	    in der Sie verschiedene Optionen einstellen können.
	    Setzen Sie <varname>sector_size</varname> auf
	    <literal>2048</literal>, wenn Sie
	    UFS1 oder UFS2 benutzen.</para>

	  <programlisting># &dollar;FreeBSD: src/sbin/gbde/template.txt,v 1.1.36.1 2009/08/03 08:13:06 kensmith Exp $
#
# Sector size is the smallest unit of data which can be read or written.
# Making it too small decreases performance and decreases available space.
# Making it too large may prevent filesystems from working.  512 is the
# minimum and always safe.  For UFS, use the fragment size
#
sector_size     =       2048
[...]</programlisting>

	  <para>&man.gbde.8; fragt dann zweimal eine Passphrase
	    zum Schutz der Daten ab.  Die Passphrase muss beides
	    Mal gleich eingegeben werden.  Die Sicherheit der
	    Daten hängt alleine von der Qualität der
	    gewählten Passphrase ab.
	    <footnote>
	      <para>Die Auswahl einer sicheren und leicht zu merkenden
	        Passphrase wird auf der Webseite <link xlink:href="http://world.std.com/~reinhold/diceware.html">Diceware
	          Passphrase</link> beschrieben.</para></footnote></para>

	  <para>Mit <command>gbde init</command> wurde im Beispiel
	    auch die Lock-Datei <filename>/etc/gbde/ad4s1c.lock</filename>
	    angelegt.  <application>gbde</application>-Lockdateien
	    müssen die Dateiendung <quote>.lock</quote> aufweisen,
	    damit sie von <filename>/etc/rc.d/gbde</filename>, dem
	    Startskript von <application>gbde</application>, erkannt
	    werden.</para>

	  <caution>
	    <para>Sichern Sie die Lock-Dateien von
	      <application>gbde</application> immer zusammen mit den
	      verschlüsselten Dateisystemen.  Ein entschlossener
	      Angreifer kann die Daten vielleicht auch ohne die
	      Lock-Datei entschlüsseln.  Ohne die Lock-Datei
	      können Sie allerdings nicht auf die
	      verschlüsselten Daten zugreifen.  Dies ist nur noch
	      mit erheblichem manuellen Aufwand möglich, der
	      weder von &man.gbde.8; noch seinem Entwickler
	      unterstützt wird.</para>
	  </caution>
	</step>

	<step>
	  <title>Einbinden der verschlüsselten Partition
	    in den Kernel</title>

	  <screen>&prompt.root; <userinput>gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock</userinput></screen>

	  <para>Das Kommando fragt die Passphrase ab, die Sie
	    beim Vorbereiten der Partition eingegeben haben.  Das
	    neue Gerät erscheint danach als
	    <filename>/dev/device_name.bde</filename> im
	    Verzeichnis <filename>/dev</filename>:</para>

	  <screen>&prompt.root; <userinput>ls /dev/ad*</userinput>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde</screen>
	</step>

	<step>
	  <title>Dateisystem auf dem verschlüsselten Gerät
	    anlegen</title>

	  <para>Wenn der Kernel die verschlüsselte Partition
	    kennt, können Sie ein Dateisystem auf ihr anlegen.
	    Benutzen Sie dazu den Befehl &man.newfs.8;.  Da ein
	    Dateisystem vom Typ UFS2 sehr viel schneller als eins
	    vom Typ UFS1 angelegt wird, empfehlen wir Ihnen, die
	    Option <option>-O2</option> zu benutzen.</para>

	  <screen>&prompt.root; <userinput>newfs -U -O2 /dev/ad4s1c.bde</userinput></screen>

	  <note>
	    <para>&man.newfs.8; muss auf einer dem Kernel bekannten
	      <application>gbde</application>-Partition (einem
	      Gerät mit dem Namen
	      <filename>*.bde</filename>
	      laufen.</para>
	  </note>
	</step>

	<step>
	  <title>Einhängen der verschlüsselten Partition</title>

	  <para>Legen Sie einen Mountpunkt für das
	    verschlüsselte Dateisystem an:</para>

	  <screen>&prompt.root; <userinput>mkdir /private</userinput></screen>

	  <para>Hängen Sie das verschlüsselte Dateisystem
	    ein:</para>

	  <screen>&prompt.root; <userinput>mount /dev/ad4s1c.bde /private</userinput></screen>
	</step>

	<step>
	  <title>Überprüfen des verschlüsselten
	    Dateisystem</title>

	  <para>Das verschlüsselte Dateisystem sollte jetzt
	    von &man.df.1; erkannt werden und benutzt werden
	    können.</para>

	  <screen>&prompt.user; <userinput>df -H</userinput>
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private</screen>
	</step>
      </procedure>
    </sect3>

    <sect3>
      <title>Einhängen eines existierenden verschlüsselten
	Dateisystems</title>

      <para>Nach jedem Neustart müssen verschlüsselte
	Dateisysteme dem Kernel wieder bekannt gemacht werden,
	auf Fehler überprüft werden und eingehangen
	werden.  Die dazu nötigen Befehle müssen als
	<systemitem class="username">root</systemitem> durchgeführt werden.</para>

      <procedure>
	<step>
	  <title>gbde-Partition im Kernel bekannt geben</title>

	  <screen>&prompt.root; <userinput>gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock</userinput></screen>

	  <para>Das Kommando fragt nach der Passphrase, die Sie
	    beim Vorbereiten der verschlüsselten
	    <application>gbde</application>-Partition festgelegt
	    haben.</para>
	</step>

	<step>
	  <title>Prüfen des Dateisystems</title>

	  <para>Das verschlüsselte Dateisystem kann noch nicht
	    automatisch über <filename>/etc/fstab</filename>
	    eingehangen werden.  Daher muss es vor dem Einhängen
	    mit &man.fsck.8; geprüft werden:</para>

	  <screen>&prompt.root; <userinput>fsck -p -t ffs /dev/ad4s1c.bde</userinput></screen>
	</step>

	<step>
	  <title>Einhängen des verschlüsselten
	    Dateisystems</title>

	  <screen>&prompt.root; <userinput>mount /dev/ad4s1c.bde /private</userinput></screen>

	  <para>Das verschlüsselte Dateisystem steht danach
	    zur Verfügung.</para>
	</step>
      </procedure>

      <sect4>
	<title>Verschlüsselte Dateisysteme automatisch
	  einhängen</title>

	<para>Mit einem Skript können verschlüsselte
	  Dateisysteme automatisch bekannt gegeben, geprüft
	  und eingehangen werden.  Wir raten Ihnen allerdings
	  aus Sicherheitsgründen davon ab.  Starten Sie das
	  Skript manuell an der Konsole oder in einer
	  &man.ssh.1;-Sitzung.</para>

	<para>Zu diesem Zweck existiert ein
	  <filename>rc.d</filename>-Skript, an das über
	  Einträge in der Datei &man.rc.conf.5;
	  Argumente übergeben werden können.  Dazu ein
	  Beispiel:</para>

	<programlisting>gbde_autoattach_all="YES"
gbde_devices="ad4s1c"
gbde_lockdir="/etc/gbde"</programlisting>

	<para>Durch diese Argumente muss beim Systemstart die
	  <application>gbde</application>-Passphrase eingegeben werden.
	  Erst nach Eingabe der korrekten Passphrase wird die
	  <application>gbde</application>-verschlüsselte
	  Partition automatisch in den Verzeichnisbaum
	  eingehängt.  Dieses Vorgehen ist insbesondere dann
	  nützlich, wenn Sie <application>gbde</application> auf
	  einem Notebook einsetzen wollen.</para>
      </sect4>
    </sect3>

    <sect3>
      <title>Kryptografische Methoden von gbde</title>

      <para>&man.gbde.8; benutzt den 128-Bit AES im CBC-Modus,
	um die Daten eines Sektors zu verschlüsseln.  Jeder
	Sektor einer Festplatte wird mit einem unterschiedlichen
	AES-Schlüssel verschlüsselt.  Mehr Informationen,
	unter anderem wie die Schlüssel für einen Sektor
	aus der gegebenen Passphrase ermittelt werden, erhalten
	Sie in &man.gbde.4;.</para>
    </sect3>

    <sect3>
      <title>Kompatibilität</title>

      <para>&man.sysinstall.8; kann nicht mit verschlüsselten
	<application>gbde</application>-Geräten umgehen.  Vor
	dem Start von &man.sysinstall.8; sind alle
	<filename>*.bde</filename>-Geräte
	zu deaktivieren, da &man.sysinstall.8; sonst bei der
	Gerätesuche abstürzt.  Das im Beispiel verwendete
	Gerät wird mit dem folgenden Befehl deaktiviert:</para>

      <screen>&prompt.root; <userinput>gbde detach /dev/ad4s1c</userinput></screen>

      <note>
	<para>Sie können <application>gbde</application>
	  nicht zusammen mit <application>vinum</application>
	  benutzen, da &man.vinum.4; das &man.geom.4;-Subsystem
	  nicht benutzt.</para>
      </note>
    </sect3>
    </sect2>

    <sect2>
      <info><title>Plattenverschlüsselung mit <command>geli</command></title>
	<authorgroup>
	  <author><personname><firstname>Daniel</firstname><surname>Gerzo</surname></personname><contrib>Beigetragen von </contrib></author>
	</authorgroup>
      </info>

      

      <para><command>geli</command> ist als alternative kryptografische
	GEOM-Klasse verfügbar und wird derzeit
	von &a.pjd; weiterentwickelt.  <command>geli</command>
	unterscheidet sich von <command>gbde</command> durch
	unterschiedliche Fähigkeiten und einen unterschiedlichen
	Ansatz für die Verschlüsselung von Festplatten.</para>

      <para>Die wichtigsten Merkmale von &man.geli.8; sind:</para>

      <itemizedlist>
	<listitem>
	  <para>Der Einsatz des &man.crypto.9;-Frameworks &ndash;
	    verfügt das System über kryptografische Hardware,
	    wird diese von <command>geli</command> automatisch
	    verwendet.</para>
	</listitem>

	<listitem>
	  <para>Die Unterstützung verschiedener kryptografischer
	    Algorithmen (derzeit AES, Blowfish, sowie 3DES).</para>
	</listitem>

	<listitem>
	  <para>Die Möglichkeit, die root-Partition zu
	    verschlüsseln.  Um auf die verschlüsselte
	    root-Partition zugreifen zu können, muss beim
	    Systemstart die Passphrase eingegeben werden.</para>
	</listitem>

	<listitem>
	  <para><command>geli</command> erlaubt den Einsatz von zwei
	    voneinander unabhängigen Schlüsseln (etwa einem
	    privaten <quote>Schlüssel</quote> und einem
	    <quote>Unternehmens-Schlüssel</quote>).</para>
	</listitem>

	<listitem>
	  <para><command>geli</command> ist durch einfache
	    Sektor-zu-Sektor-Verschlüsselung sehr schnell.</para>
	</listitem>

	<listitem>
	  <para>Die Möglichkeit, Master-Keys zu sichern und
	    wiederherzustellen.  Wenn ein Benutzer seinen Schlüssel
	    zerstört, kann er über seinen zuvor gesicherten
	    Schlüssel wieder auf seine Daten zugreifen.</para>
	</listitem>

	<listitem>
	  <para><command>geli</command> erlaubt es, Platten mit
	    einem zufälligen Einmal-Schlüssel einzusetzen,
	    was insbesondere für Swap-Partitionen und
	    temporäre Dateisysteme interessant ist.</para>
	</listitem>
      </itemizedlist>

      <para>Weitere Informationen zu den Fähigkeiten von
	<command>geli</command> finden Sie in &man.geli.8;.</para>

      <para>Die folgenden Schritte beschreiben, wie Sie
	<command>geli</command> im &os;-Kernel aktivieren und einen
	<command>geli</command>-Verschlüsselungs-Provider
	anlegen können.</para>

      <para>Da Sie Ihren Kernel anpassen müssen,
	benötigen Sie außerdem
	<systemitem class="username">root</systemitem>-Privilegien.</para>

      <procedure>
	<step>
	  <title>Aufnahme der <command>geli</command>-Unterstützung
	    in Ihre Kernelkonfigurationsdatei</title>

	  <para>Fügen Sie die folgenden Zeilen in Ihre
	    Kernelkonfigurationsdatei ein:</para>

	  <programlisting>options GEOM_ELI
device crypto</programlisting>

	  <para>Bauen und installieren Sie Ihren neuen Kernel wie in
	    <xref linkend="kernelconfig"/> beschrieben.</para>

	  <para>Alternativ können Sie aber auch das
	    <command>geli</command>-Kernelmodul beim Systemstart laden.
	    Dazu fügen Sie die folgende Zeile in
	    <filename>/boot/loader.conf</filename> ein:</para>

	  <programlisting>geom_eli_load="YES"</programlisting>

	  <para>Ab sofort wird &man.geli.8; vom Kernel
	    unterstützt.</para>
	</step>

	<step>
	  <title>Erzeugen des Master-Keys</title>

	  <para>Das folgende Beispiel beschreibt, wie Sie eine
	    Schlüsseldatei erzeugen, die als Teil des
	    Master-Keys für den Verschlüsselungs-Provider
	    verwendet wird, der unter <filename>/private</filename> in den
	    Verzeichnisbaum eingehängt (<quote>gemountet</quote>)
	    wird.  Diese Schlüsseldatei liefert zufällige
	    Daten, die für die Verschlüsselung des
	    Master-Keys benötigt werden.  Zusätzlich wird
	    der Master-Key durch eine Passphrase geschützt.  Die
	    Sektorgröße des Providers beträgt 4&nbsp;KB.
	    Außerdem wird beschrieben, wie Sie einen
	    <command>geli</command>-Provider aktivieren, ein vom ihm
	    verwaltetes Dateisystem erzeugen, es mounten, mit ihm
	    arbeiten und wie Sie es schließlich wieder unmounten
	    und den Provider deaktivieren.</para>

	  <para>Um eine bessere Leistung zu erzielen, sollten Sie eine
	    größere Sektorgröße (beispielsweise
	    4&nbsp;KB) verwenden.</para>

	  <para>Der Master-Key wird durch eine Passphrase sowie die
	    Daten der Schlüsseldatei (die von
	    <filename>/dev/random</filename> stammen) geschützt.
	    Die Sektorgröße von
	    <filename>/dev/da2.eli</filename> (das als Provider
	    bezeichnet wird) beträgt 4&nbsp;KB.</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/random of=/root/da2.key bs=64 count=1</userinput>
&prompt.root; <userinput>geli init -s 4096 -K /root/da2.key /dev/da2</userinput>
Enter new passphrase:
Reenter new passphrase:</screen>

	  <para>Es ist nicht zwingend nötig, sowohl eine Passphrase
	    als auch eine Schlüsseldatei zu verwenden.  Die
	    einzelnen Methoden können auch unabhängig
	    voneinander eingesetzt werden.</para>

	  <para>Wird für die Schlüsseldatei der Wert
	    <quote>-</quote> angegeben, wird dafür die
	    Standardeingabe verwendet.  Das folgende Beispiel zeigt,
	    dass Sie auch mehr als eine Schlüsseldatei verwenden
	    können.</para>

	  <screen>&prompt.root; <userinput>cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2</userinput></screen>
	</step>

	<step>
	  <title>Aktivieren des Providers mit dem erzeugten
	    Schlüssel</title>

	  <screen>&prompt.root; <userinput>geli attach -k /root/da2.key /dev/da2</userinput>
Enter passphrase:</screen>

	  <para>Dadurch wird die (Normaltext-)Gerätedatei
	    <filename>/dev/da2.eli</filename>
	    angelegt.</para>

	  <screen>&prompt.root; <userinput>ls /dev/da2*</userinput>
/dev/da2  /dev/da2.eli</screen>
	</step>

	<step>
	  <title>Das neue Dateisystem erzeugen</title>

	  <screen>&prompt.root; <userinput>dd if=/dev/random of=/dev/da2.eli bs=1m</userinput>
&prompt.root; <userinput>newfs /dev/da2.eli</userinput>
&prompt.root; <userinput>mount /dev/da2.eli /private</userinput></screen>

	<para>Das verschlüsselte Dateisystem wird nun von
	  &man.df.1; angezeigt und kann ab sofort eingesetzt werden.</para>

	  <screen>&prompt.root; <userinput>df -H</userinput>
Filesystem     Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a    248M    89M   139M    38%    /
/devfs         1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr
/dev/ad0s1d    989M   1.5M   909M     0%    /tmp
/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var
/dev/da2.eli   150G   4.1K   138G     0%    /private</screen>

	</step>

	<step>
	  <title>Das Dateisystem unmounten und den Provider deaktivieren</title>

	  <para>Wenn Sie nicht mehr mit dem verschlüsselten
	    Dateisystem arbeiten und die unter <filename>/private</filename> eingehängte
	    Partition daher nicht mehr benötigen,  sollten
	    Sie diese unmounten und den
	    <command>geli</command>-Verschlüsselungs-Provider
	    wieder deaktivieren.</para>

	  <screen>&prompt.root; <userinput>umount /private</userinput>
&prompt.root; <userinput>geli detach da2.eli</userinput></screen>
	</step>
      </procedure>

      <para>Weitere Informationen zum Einsatz von <command>geli</command>
        finden Sie in &man.geli.8;.</para>

      <sect3>
	<title>Der Einsatz des <filename>geli</filename>-
	  <filename>rc.d</filename>-Skripts</title>

	<para><command>geli</command> verfügt über ein
	  <filename>rc.d</filename>-Skript,
	  das den Einsatz von <command>geli</command>
	  deutlich vereinfacht.  Es folgt nun ein Beispiel, in dem
	  <command>geli</command> über die Datei
	  &man.rc.conf.5; konfiguriert wird:</para>

	<programlisting>geli_devices="da2"
geli_da2_flags="-p -k /root/da2.key"</programlisting>

	<para>Durch diese Einträge wird
	  <filename>/dev/da2</filename> als
	  <command>geli</command>-Provider festgelegt.  Der Master-Key
	  befindet sich in <filename>/root/da2.key</filename>.  Beim
	  Aktivieren des <command>geli</command>-Providers wird keine
	  Passphrase abgefragt (beachten Sie, dass dies nur dann
	  möglich ist, wenn Sie <command>geli</command> mit dem
	  Parameter <option>-P</option> initialisieren).  Wird das
	  System heruntergefahren, wird der
	  <literal>geli</literal>-Provider zuvor deaktiviert.</para>

	<para>Weitere Informationen zur Konfiguration der
	  <filename>rc.d</filename>-Skripten
	  finden Sie im Abschnitt <link linkend="configtuning-rcd">rc.d</link> des Handbuchs.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="swap-encrypting">
    <info><title>Den Auslagerungsspeicher verschlüsseln</title>
      <authorgroup>
	<author><personname><firstname>Christian</firstname><surname>Brüffer</surname></personname><contrib>Geschrieben von </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>Auslagerungsspeicher</primary>
      <secondary>verschlüsseln</secondary>
    </indexterm>

    <para>Die Verschlüsselung des Auslagerungsspeichers ist unter &os;
      einfach einzurichten.
      Je nach dem, welche &os;-Version Sie einsetzen, können
      Konfiguration und mögliche Optionen allerdings unterschiedlich
      sein.  Sie können entweder das
      &man.gbde.8;- oder das &man.geli.8;-Verschlüsselungs-Subsystem
      einsetzen.  Beide Subsysteme werden über das <link linkend="configtuning-rcd">rc.d</link>-Skript
      <filename>encswap</filename> gestartet.</para>

    <para>Der letzte Abschnitt, <link linkend="disks-encrypting">
      Partitionen verschlüsseln</link>, enthält eine kurze
      Beschreibung der verschiedenen
      Verschlüsselungs-Subsysteme.</para>

    <sect2>
      <title>Warum sollte der Auslagerungsspeicher verschlüsselt
	werden?</title>

      <para>Wie die Verschlüsselung von Plattenpartitionen dient
	auch die Verschlüsselung des Auslagerungsspeichers dem
	Schutz sensitiver Informationen.  Stellen Sie sich etwa eine
	Anwendung vor, die ein Passwort erfordert.  Solange dieses
	Passwort im Hauptspeicher verbleibt, ist alles in
	Ordnung.  Beginnt Ihr Betriebssystem allerdings, Daten auf
	die Festplatte auszulagern, um im Hauptspeicher Platz für
	andere Anwendungen zu schaffen, kann es passieren, dass Ihr
	Passwort im Klartext in den Auslagerungsspeicher
	geschrieben wird, was es einem potentiellen Angreifer leicht
	macht, Ihr Passwort herauszufinden.  Die Verschlüsselung
	Ihres Auslagerungsspeichers kann dieses Problem lösen.</para>
    </sect2>

    <sect2>
      <title>Vorbereitungen</title>

      <note>
	<para>Für die weiteren Ausführungen dieses Abschnitts
	  stellt <filename>ad0s1b</filename> die Swap-Partition
	  dar.</para>
      </note>

      <para>Noch ist Ihr Auslagerungsspeicher nicht verschlüsselt.
	Es könnte allerdings sein, dass bereits Passwörter
	oder andere sensitive Daten als Klartext im Auslagerungsspeicher
	vorhanden sind.  Daher sollten Sie den Auslagerungsspeicher
	komplett mit zufällig generierten Zeichen
	überschreiben, bevor Sie ihn verschlüsseln:</para>

      <screen>&prompt.root; <userinput>dd if=/dev/random of=/dev/ad0s1b bs=1m</userinput></screen>
    </sect2>

    <sect2>
      <title>Den Auslagerungsspeicher mit &man.gbde.8;
	verschlüsseln</title>

      <para>In der Datei <filename>/etc/fstab</filename> sollte
	das Suffix <literal>.bde</literal> an den Gerätenamen
	der Swap-Partition anhängt werden:</para>

      <programlisting># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ad0s1b.bde         none            swap    sw              0       0</programlisting>
    </sect2>

    <sect2>
      <title>Den Auslagerungsspeicher mit &man.geli.8;
	verschlüsseln</title>

      <para>Alternativ können Sie Ihren Auslagerungsspeicher auch
	mit &man.geli.8; verschlüsseln.  Die Vorgehensweise ist
	dabei ähnlich.  Allerdings hängen Sie bei der Verwendung
	von &man.geli.8; in <filename>/etc/fstab</filename> das Suffix
	<literal>.eli</literal> an den Gerätenamen der
	Swap-Partition an:</para>

      <programlisting># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ad0s1b.eli         none            swap    sw              0       0</programlisting>

      <para>In der Voreinstellung verschlüsselt &man.geli.8; den
	Auslagerungsspeicher mit dem <acronym>AES</acronym>-Algorithmus
	und einer Schlüssellänge von 128 Bit.</para>

      <para>Es ist möglich, diese Optionen durch das Setzen der
	<literal>geli_swap_flags</literal>-Option in
	<filename>/etc/rc.conf</filename> anzupassen.  Die folgende
	Zeile weist das rc.d-Skript <filename>encswap</filename> an,
	&man.geli.8;-Swap-Partitionen mit dem Blowfish-Algorithmus und
	einer Schlüssellänge von 128&nbsp;Bit zu
	verschlüsseln.  Zusätzlich wird die
	Sektorgröße auf 4&nbsp;Kilobyte gesetzt und die Option
	<quote>detach on last close</quote> aktiviert:</para>

      <programlisting>geli_swap_flags="-e blowfish -l 128 -s 4096 -d"</programlisting>

      <para>Eine Auflistung möglicher Optionen für den Befehl
	<command>onetime</command> finden Sie in der Manualpage zu
	&man.geli.8;.</para>
    </sect2>

    <sect2>
      <title>Die korrekte Funktion testen</title>

      <para>Nachdem Sie Ihr System neu gestartet haben, können Sie
	die korrekte Funktion Ihres verschlüsselten
	Auslagerungsspeichers prüfen, indem Sie sich die Ausgabe
	von <command>swapinfo</command> ansehen.</para>

      <para>Wenn Sie &man.gbde.8; einsetzen, erhalten Sie eine
	Meldung ähnlich der folgenden:</para>

      <screen>&prompt.user; <userinput>swapinfo</userinput>
Device          1K-blocks     Used    Avail Capacity
/dev/ad0s1b.bde    542720        0   542720     0%</screen>

      <para>Wenn Sie &man.geli.8; einsetzen, erhalten Sie hingegen
	eine Ausgabe ähnlich der folgenden:</para>

      <screen>&prompt.user; <userinput>swapinfo</userinput>
Device          1K-blocks     Used    Avail Capacity
/dev/ad0s1b.eli    542720        0   542720     0%</screen>
    </sect2>
  </sect1>

  <sect1 xml:id="disks-hast">
    <info><title>Highly Available Storage (HAST)</title>
      <authorgroup>
	<author><personname><firstname>Daniel</firstname><surname>Gerzo</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Freddie</firstname><surname>Cash</surname></personname><contrib>Mit Beiträgen von </contrib></author>
	<author><personname><firstname>Pawel Jakub</firstname><surname>Dawidek</surname></personname></author>
	<author><personname><firstname>Michael W.</firstname><surname>Lucas</surname></personname></author>
	<author><personname><firstname>Viktor</firstname><surname>Petersson</surname></personname></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Benedict</firstname><surname>Reuschling</surname></personname><contrib>Übersetzt von </contrib></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>HAST</primary>
      <secondary>high availability</secondary>
    </indexterm>

    <sect2>
      <title>Überblick</title>

      <para>Hochverfügbarkeit ist eine der Hauptanforderungen von
        ernsthaften Geschäftsanwendungen und hochverfügbarer Speicher
        ist eine Schlüsselkomponente in solchen Umgebungen.  Highly
        Available STorage, oder <acronym>HAST<remark role="acronym">Highly Available STorage</remark></acronym>, wurde von
        &a.pjd; als ein Framework entwickelt, welches die transparente
        Speicherung der gleichen Daten über mehrere physikalisch getrennte
        Maschinen ermöglicht, die über ein TCP/IP-Netzwerk verbunden
        sind.  <acronym>HAST</acronym> kann als ein netzbasiertes RAID1
        (Spiegel) verstanden werden und ist dem DRBD&reg;-Speichersystem der
        GNU/&linux;-Plattform ähnlich.  In Kombination mit anderen
        Hochverfügbarkeitseigenschaften von &os;
        wie <acronym>CARP</acronym>, ermöglicht es
        <acronym>HAST</acronym>, hochverfügbare Speichercluster zu bauen,
        die in der Lage sind, Hardwareausfällen zu widerstehen.</para>

      <para>Nachdem Sie diesen Abschnitt gelesen haben, werden Sie folgendes
        wissen:</para>

      <itemizedlist>
	<listitem>
	  <para>Was <acronym>HAST</acronym> ist, wie es funktioniert und
	    welche Eigenschaften es besitzt.</para>
	</listitem>
	<listitem>
	  <para>Wie man <acronym>HAST</acronym> auf &os; aufsetzt und
	    verwendet.</para>
	</listitem>
	<listitem>
	  <para>Wie man <acronym>CARP</acronym> und &man.devd.8; kombiniert, um
	    ein robustes Speichersystem zu bauen.</para>
 	</listitem>
      </itemizedlist>

      <para>Bevor Sie diesen Abschnitt lesen, sollten Sie:</para>

      <itemizedlist>
	<listitem>
	  <para>die Grundlagen von &unix; und &os; verstanden haben
	    (<xref linkend="basics"/>).</para>
	</listitem>
	<listitem>
	  <para>wissen, wie man Netzwerkschnittstellen und andere Kernsysteme
	    von &os; konfiguriert (<xref linkend="config-tuning"/>).</para>
	</listitem>
	<listitem>
	  <para>ein gutes Verständnis der &os;-Netzwerkfunktionalität
	    besitzen (<xref linkend="network-communication"/>).</para>
	</listitem>
	<listitem>
	  <para>&os;&nbsp;8.1-RELEASE oder höher einsetzen.</para>
	</listitem>
      </itemizedlist>

      <para>Das <acronym>HAST</acronym>-Projekt wurde von der &os; Foundation
        mit Unterstützung der <link xlink:href="http://www.omc.net/">OMCnet Internet Service GmbH</link> und
        <link xlink:href="http://www.transip.nl/">TransIP BV</link>
        gesponsert.</para>
    </sect2>

    <sect2>
      <title>HAST-Merkmale</title>

      <para>Die Hauptmerkmale des <acronym>HAST</acronym>-Systems sind:</para>

      <itemizedlist>
        <listitem>
	  <para>Es kann zur Maskierung von I/O-Fehlern auf lokalen Festplatten
	    eingesetzt werden.</para>
	</listitem>
	<listitem>
	  <para>Dateisystem-unabhängig, was es erlaubt, jedes von &os;
	    unterstützte Dateisystem zu verwenden.</para>
	</listitem>
	<listitem>
	  <para>Effiziente und schnelle Resynchronisation: es werden nur die
	    Blöcke synchronisiert, die während der Ausfallzeit eines
	    Knotens geändert wurden.</para>
	</listitem>
	<!--
        <listitem>
	  <para>Besitzt mehrere Synchronisationsmodi, um eine schnelle
	    Übergabe an einen anderen Knoten (sog. failover) zu
	    ermöglichen.</para>
	</listitem>
	-->
	<listitem>
	  <para>Es kann in einer bereits bestehenden Umgebung eingesetzt
	    werden, um zusätzliche Redundanz zu erreichen.</para>
	</listitem>
	<listitem>
	  <para>Zusammen mit <acronym>CARP</acronym>,
	    <application>Heartbeat</application>, oder anderen Werkzeugen, ist
	    es möglich, ein robustes und dauerhaftes Speichersystem zu
	    bauen.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>HAST im Einsatz</title>

      <para><acronym>HAST</acronym> stellt auf Block-Ebene eine synchrone
        Replikation eines beliebigen Speichermediums auf mehreren Maschinen zur
        Verfügung.  Daher werden mindestens zwei Knoten (physikalische
        Maschinen) benötigt: der <literal>primary</literal>
        (auch bekannt als <literal>master</literal>) Knoten, sowie der
        <literal>secondary</literal> (<literal>slave</literal>) Knoten.  Diese
        beiden Maschinen zusammen werden als Cluster bezeichnet.</para>

      <note>
	<para>HAST ist momentan auf insgesamt zwei Knoten im Cluster
	  beschränkt.</para>
      </note>

      <para>Da <acronym>HAST</acronym> in einer
        primär-sekundär-Konfiguration funktioniert, ist immer nur ein
        Knoten des Clusters zu jeder Zeit aktiv.  Der
        <literal>primäre</literal> Knoten, auch
        <literal>active</literal> genannt, ist derjenige, der alle I/O-Anfragen
	verarbeitet, die an die <acronym>HAST</acronym>-Schnittstelle gesendet
	werden.  Der <literal>secondary</literal>-Knoten wird automatisch vom
	<literal>primary</literal>-Knoten aus synchronisiert.</para>

      <para>Die physischen Komponenten des <acronym>HAST</acronym>-Systems
        sind:</para>

      <itemizedlist>
	<listitem>
	  <para>lokale Platte (am Primärknoten)</para>
	</listitem>
	<listitem>
	  <para>Platte am entfernten Rechner (Sekundärknoten)</para>
	</listitem>
      </itemizedlist>

      <para><acronym>HAST</acronym> arbeitet synchron auf Blockebene, was es
        für Dateisysteme und Anwendungen transparent macht.
        <acronym>HAST</acronym> stellt gewöhnliche GEOM-Provider im
        Verzeichnis <filename>/dev/hast/</filename> für
        die Verwendung durch andere Werkzeuge oder Anwendungen zur
        Verfügung, somit gibt es keinen Unterschied zwischen dem Einsatz
        von durch <acronym>HAST</acronym> bereitgestellten Geräten und
        herkömmlichen Platten, Partitionen, etc.</para>

      <para>Jede Schreib-, Lösch- oder Entleerungsoperation wird an die
        lokale und über TCP/IP zu der entfernt liegenden
        Platte gesendet.  Jede Leseoperation wird von der lokalen Platte
        durchgeführt, es sei denn, die lokale Platte ist nicht aktuell
        oder es tritt ein I/O-Fehler auf.  In solchen Fällen wird die
        Leseoperation an den Sekundärknoten geschickt.</para>

      <sect3>
	<title>Synchronisation und Replikationsmodi</title>

	<para><acronym>HAST</acronym> versucht, eine schnelle Fehlerbereinigung
	  zu gewährleisten.  Aus diesem Grund ist es sehr wichtig, die
	  Synchronisationszeit nach dem Ausfall eines Knotens zu reduzieren.
	  Um eine schnelle Synchronisation zu ermöglichen, verwaltet
	  <acronym>HAST</acronym> eine Bitmap von unsauberen Bereichen
	  auf der Platte und synchronisiert nur diese während einer
	  regulären Synchronisation (mit Ausnahme der initialen
	  Synchronisation).</para>

	<para>Es gibt viele Wege, diese Synchronisation zu behandeln.
	  <acronym>HAST</acronym> implementiert mehrere Replikationsarten, um
	  unterschiedliche Methoden der Synchronisation zu realisieren:</para>

	<itemizedlist>
	  <listitem>
	    <para><emphasis>memsync</emphasis>: meldet Schreiboperationen als
	      vollständig, wenn die lokale Schreiboperation beendet ist
	      und der entfernt liegende Knoten die Ankunft der Daten
	      bestätigt hat, jedoch bevor die Daten wirklich gespeichert
	      wurden.  Die Daten werden auf dem entfernt liegenden Knoten
	      direkt nach dem Senden der Bestätigung gespeichert.  Dieser
	      Modus ist dafür gedacht, Latenzen zu verringern und
	      zusätzlich eine gute Verlässlichkeit zu bieten.  Der
	      <emphasis>memsync</emphasis>-Replikationsmodus ist momentan noch
	      nicht implementiert.</para>
	  </listitem>
	  <listitem>
	    <para><emphasis>fullsync</emphasis>: meldet Schreiboperationen als
	      vollständig, wenn die lokale Schreiboperation beendet ist
	      und die entfernte Schreiboperation ebenfalls abgeschlossen wurde.
	      Dies ist der sicherste und zugleich der langsamste
	      Replikationsmodus.  Er stellt den momentanen Standardmodus
	      dar.</para>
	  </listitem>
	  <listitem>
	    <para><emphasis>async</emphasis>: meldet Schreiboperationen als
	      vollständig, wenn lokale Schreibvorgänge abgeschlossen
	      wurden.  Dies ist der schnellste und gefährlichste
	      Replikationsmodus.  Er sollte verwendet werden, wenn die Latenz
	      zu einem entfernten Knoten bei einer Replikation zu hoch ist
	      für andere Modi.  Der
	      <emphasis>async</emphasis>-Replikationsmodus ist zum
	      gegenwärtigen Zeitpunkt nicht implementiert.</para>
	  </listitem>
	</itemizedlist>

	<warning>
	  <para>Momentan wird nur der
	    <emphasis>fullsync</emphasis>-Replikationsmodus
	    unterstützt.</para>
	</warning>
      </sect3>
    </sect2>

    <sect2>
      <title>HAST-Konfiguration</title>

      <para><acronym>HAST</acronym> benötigt
        <literal>GEOM_GATE</literal>-Unterstützung, um korrekt zu
        funktionieren.  Der <literal>GENERIC</literal>-Kernel enthält
        jedoch <literal>GEOM_GATE</literal> <emphasis>nicht</emphasis> von
        vornherein, jedoch ist in der Standardinstallation von &os;
        <filename>geom_gate.ko</filename> als ladbares Modul vorhanden.
        Stellen Sie bei Systemen, bei denen nur das Allernötigste
        vorhanden sein soll, sicher, dass dieses Modul zur Verfügung
        steht.  Als Alternative lässt sich die
	<literal>GEOM_GATE</literal>-Unterstützung direkt in den Kernel
	statisch einbauen, indem Sie die folgende Zeile zu Ihrer
	Kernelkonfigurationsdatei hinzufügen:</para>

      <programlisting>options	GEOM_GATE</programlisting>

      <para>Das <acronym>HAST</acronym>-Framework besteht aus Sicht des
        Betriebssystems aus mehreren Bestandteilen:</para>

      <itemizedlist>
        <listitem>
	  <para>Dem &man.hastd.8;-Dienst, welcher für die
	    Datensynchronisation verantwortlich ist,</para>
	</listitem>
	<listitem>
	  <para>Dem &man.hastctl.8; Management-Werkzeug,</para>
	</listitem>
	<listitem>
	  <para>Der Konfigurationsdatei &man.hast.conf.5;.</para>
	</listitem>
      </itemizedlist>

      <para>Das folgende Beispiel beschreibt, wie man zwei Knoten als
        <literal>master</literal>-<literal>slave</literal> /
        <literal>primary</literal>-<literal>secondary</literal> mittels
        <acronym>HAST</acronym> konfiguriert, um Daten zwischen diesen beiden
        auszutauschen.  Die Knoten werden als
        <literal>hasta</literal> mit der IP-Adresse
        <replaceable>172.16.0.1</replaceable> und
        <literal>hastb</literal> mit der IP-Adresse
        <replaceable>172.16.0.2</replaceable> bezeichnet.  Beide Knoten
        besitzen eine dedizierte Festplatte
        <filename>/dev/ad6</filename> mit der
        gleichen Grösse für den <acronym>HAST</acronym>-Betrieb.
	Der <acronym>HAST</acronym>-Pool (manchmal auch Ressource
	genannt, z.B. der GEOM-Provider in <filename>/dev/hast/</filename>) wird als
	<filename>test</filename> bezeichnet.</para>

      <para>Die Konfiguration von <acronym>HAST</acronym> wird in der Datei
        <filename>/etc/hast.conf</filename> vorgenommen.  Diese Datei sollte
        auf beiden Knoten gleich sein.  Die denkbar einfachste Konfiguration
        ist folgende:</para>

      <programlisting>resource test {
	on hasta {
		local /dev/ad6
		remote 172.16.0.2
	}
	on hastb {
		local /dev/ad6
		remote 172.16.0.1
	}
}</programlisting>

      <para>Schlagen Sie in der &man.hast.conf.5;-Manualpage nach, wenn Sie an
        erweiterten Konfigurationsmöglichkeiten interessiert sind.</para>

      <tip>
	<para>Es ist ebenfalls möglich, den Hostnamen in den
	  <literal>remote</literal>-Anweisungen zu verwenden.  Stellen Sie in
	  solchen Fällen sicher, dass diese Rechner auch aufgelöst
	  werden können, also in der Datei <filename>/etc/hosts</filename>
	  aufgeführt sind, oder alternativ im lokalen
	  <acronym>DNS</acronym>.</para>
      </tip>

      <para>Da nun die Konfiguration auf beiden Rechnern vorhanden ist, sind
        Sie in der Lage, den <acronym>HAST</acronym>-Pool zu erstellen.  Lassen
        Sie die folgenden Kommandos auf beiden Knoten ablaufen, um die
        initialen Metadaten auf die lokale Platte zu schreiben und starten Sie
        anschliessend den &man.hastd.8;-Dienst:</para>

      <screen>&prompt.root; <userinput>hastctl create test</userinput>
&prompt.root; <userinput>/etc/rc.d/hastd onestart</userinput></screen>

      <note>
	<para>Es ist <emphasis>nicht</emphasis> möglich, GEOM-Provider mit
	  einem bereits bestehenden Dateisystem zu verwenden (z.B. um einen
	  bestehenden Speicher in einen von <acronym>HAST</acronym> verwalteten
	  Pool zu konvertieren), weil diese Prozedur bestimmte Metadaten auf
	  den Provider schreiben muss und dafür nicht genug freier Platz
	  zur Verfügung stehen wird.</para>
      </note>

      <para>HAST ist nicht dafür verantwortlich, die Rolle
        (<literal>primary</literal> oder <literal>secondary</literal>) für
        den jeweiligen Knoten festzulegen.  Die Rolle des Knotens muss vom
        Administrator oder einer anderen Software wie
        <application>Heartbeat</application> mittels des
        &man.hastctl.8;-Werkzeugs festgelegt werden.  Auf dem primären
        Knoten (<literal>hasta</literal>) geben Sie
        nun den folgenden Befehl ein:</para>

      <screen>&prompt.root; <userinput>hastctl role primary test</userinput></screen>

      <para>Geben Sie nun, ähnlich wie zuvor, das folgende Kommando auf
        dem sekundären Knoten
        (<literal>hastb</literal>) ein:</para>

      <screen>&prompt.root; <userinput>hastctl role secondary test</userinput></screen>

      <caution>
	<para>Es kann passieren, dass beide Knoten nicht in der Lage sind,
	  miteinander zu kommunizieren und dadurch beide als primäre
	  Knoten konfiguriert sind; die Konsequenz daraus wird als
	  <literal>split-brain</literal> bezeichnet.  Um diese Situation zu
	  bereinigen, folgen Sie den Schritten, die in <xref linkend="disks-hast-sb"/> beschrieben sind.</para>
      </caution>

      <para>Es ist möglich das Ergebnis des &man.hastctl.8;-Werkzeugs auf
        jedem Knoten zu überprüfen:</para>

      <screen>&prompt.root; <userinput>hastctl status test</userinput></screen>

      <para>Der wichtigste Teil ist die <literal>status</literal>-Textzeile der
        Ausgabe, die auf jedem Knoten <literal>complete</literal> lauten
        sollte.  Falls der Status als <literal>degraded</literal>
        zurückgemeldet wird, ist etwas schief gegangen.  Zu diesem
        Zeitpunkt hat die Synchronisation zwischen den beiden Knoten bereits
        begonnen.  Die Synchronisation ist beendet, wenn das Kommando
        <command>hastctl status</command> meldet, dass die
        <literal>dirty</literal>-Bereiche 0 Bytes betragen.</para>

      <para>Der letzte Schritt ist, ein Dateisystem auf dem
        <filename>/dev/hast/test</filename>
	GEOM-Provider anzulegen und dieses ins System einzuhängen.  Dies
	muss auf dem <literal>primary</literal>-Knoten durchgeführt werden
	(da <filename>/dev/hast/test</filename> nur
	auf dem <literal>primary</literal>-Knoten erscheint). Dies kann ein
	paar Minuten dauern, abhängig von der Grösse der
	Festplatte:</para>

      <screen>&prompt.root; <userinput>newfs -U /dev/hast/test</userinput>
&prompt.root; <userinput>mkdir /hast/test</userinput>
&prompt.root; <userinput>mount /dev/hast/test /hast/test</userinput></screen>

      <para>Sobald das <acronym>HAST</acronym>-Framework richtig konfiguriert
        wurde, besteht der letzte Schritt nun darin, sicherzustellen, dass
        <acronym>HAST</acronym> während des Systemstarts automatisch
        gestartet wird.  Die folgende Zeile sollte zur Datei
        <filename>/etc/rc.conf</filename> hinzugefügt werden:</para>

      <programlisting>hastd_enable="YES"</programlisting>

      <sect3>
	<title>Failover-Konfiguration</title>

	<para>Das Ziel dieses Beispiels ist, ein robustes Speichersystem zu
	  bauen, welches Fehlern auf einem beliebigen Knoten widerstehen kann.
	  Die Schlüsselaufgabe in diesem Szenario besteht darin, zu
	  verhindern, dass der <literal>primary</literal>-Knoten des Clusters
	  ausfällt.  Sollte es dennoch passieren, ist der
	  <literal>secondary</literal>-Knoten da, um nahtlos einzuspringen, das
	  Dateisystem zu prüfen, einzuhängen und mit der Arbeit
	  fortzufahren, ohne dass auch nur ein einzelnes Bit an Daten verloren
	  ging.</para>

	<para>Um diese Aufgabe zu bewerkstelligen, ist es nötig, eine
	  weitere Eigenschaft zu nutzen, die unter &os; verfügbar ist,
	  welche ein automatisches Failover auf der IP-Schicht ermöglicht:
	  <acronym>CARP</acronym>.  <acronym>CARP</acronym> steht für
	  Common Address Redundancy Protocol und erlaubt es mehreren Rechnern
	  im gleichen Netzsegment, die gleiche IP-Adresse zu verwenden.  Setzen
	  Sie <acronym>CARP</acronym> auf beiden Knoten des Clusters anhand der
	  Dokumentation in <xref linkend="carp"/> auf.  Nachdem dieser Schritt
	  abgeschlossen ist, sollte jeder Knoten seine eigene
	  <filename>carp0</filename>-Schnittstelle mit der geteilten
	  IP-Adresse <replaceable>172.16.0.254</replaceable> besitzen.
	  Selbstverständlich muss der primäre
	  <acronym>HAST</acronym>-Knoten des Clusters der
	  <acronym>CARP</acronym>-Masterknoten sein.</para>

	<para>Der <acronym>HAST</acronym>-Pool, welcher im vorherigen Abschnitt
	  erstellt wurde, ist nun bereit für den Export über das
	  Netzwerk auf den anderen Rechner.  Dies kann durch den Export
	  über <acronym>NFS</acronym>, <application>Samba</application>
	  etc. erreicht werden, indem die geteilte IP-Addresse
	  <replaceable>172.16.0.254</replaceable> verwendet wird.  Das einzige
	  ungelöste Problem ist der automatische Failover, sollte der
	  primäre Knoten einmal ausfallen.</para>

	<para>Falls die <acronym>CARP</acronym>-Schnittstelle aktiviert oder
	  deaktiviert wird, generiert das &os;-Betriebssystem ein
	  &man.devd.8;-Ereignis, was es ermöglicht,
	  Zustandsänderungen auf den
	  <acronym>CARP</acronym>-Schnittstellen zu überwachen.  Eine
	  Zustandsänderung auf der <acronym>CARP</acronym>-Schnittstelle
	  ist ein Indiz dafür, dass einer der Knoten gerade ausgefallen
	  oder wieder verfügbar ist.  In diesem Fall ist es möglich,
	  ein Skript zu starten, welches den Failover automatisch
	  durchführt.</para>

	<para>Um diese Zustandsänderungen auf der
	  <acronym>CARP</acronym>-Schnittstelle abzufangen, müssen die
	  folgenden Zeilen in der Datei <filename>/etc/devd.conf</filename> auf
	  jedem Knoten eingefügt werden:</para>

	<programlisting>notify 30 {
	match "system" "IFNET";
	match "subsystem" "carp0";
	match "type" "LINK_UP";
	action "/usr/local/sbin/carp-hast-switch master";
};

notify 30 {
	match "system" "IFNET";
	match "subsystem" "carp0";
	match "type" "LINK_DOWN";
	action "/usr/local/sbin/carp-hast-switch slave";
};</programlisting>

	<para>Um diese neue Konfiguration zu aktivieren, starten Sie
	  &man.devd.8; auf beiden Knoten neu, um die neue Konfiguration
	  wirksam werden zu lassen:</para>

	<screen>&prompt.root; <userinput>/etc/rc.d/devd restart</userinput></screen>

	<para>Für den Fall, dass die
	  <filename>carp0</filename>-Schnittstelle aktiviert oder
	  deaktiviert wird (sich also der Status der Schnittstelle
	  ändert), erzeugt das System eine Meldung, was es dem
	  &man.devd.8;-Subsystem ermöglicht, ein beliebiges Skript zu
	  starten, in diesem Fall also
	  <filename>/usr/local/sbin/carp-hast-switch</filename>.  Dies ist das
	  Skript, dass den automatischen Failover durchführt.  Für
	  genauere Informationen zu der obigen &man.devd.8;-Konfiguration,
	  lesen Sie die &man.devd.conf.5;-Manualpage.</para>

	<para>Ein Beispiel für ein solches Skript könnte wie folgt
	  aussehen:</para>

<programlisting>#!/bin/sh

# Original script by Freddie Cash &lt;fjwcash@gmail.com&gt;
# Modified by Michael W. Lucas &lt;mwlucas@BlackHelicopters.org&gt;
# and Viktor Petersson &lt;vpetersson@wireload.net&gt;

# The names of the HAST resources, as listed in /etc/hast.conf
resources="test"

# delay in mounting HAST resource after becoming master
# make your best guess
delay=3

# logging
log="local0.debug"
name="carp-hast"

# end of user configurable stuff

case "$1" in
	master)
		logger -p $log -t $name "Switching to primary provider for ${resources}."
		sleep ${delay}

		# Wait for any "hastd secondary" processes to stop
		for disk in ${resources}; do
			while $( pgrep -lf "hastd: ${disk} \(secondary\)" &gt; /dev/null 2&gt;&amp;1 ); do
				sleep 1
			done

			# Switch role for each disk
			hastctl role primary ${disk}
			if [ $? -ne 0 ]; then
				logger -p $log -t $name "Unable to change role to primary for resource ${disk}."
				exit 1
			fi
		done

		# Wait for the /dev/hast/* devices to appear
		for disk in ${resources}; do
			for I in $( jot 60 ); do
				[ -c "/dev/hast/${disk}" ] &amp;&amp; break
				sleep 0.5
			done

			if [ ! -c "/dev/hast/${disk}" ]; then
				logger -p $log -t $name "GEOM provider /dev/hast/${disk} did not appear."
				exit 1
			fi
		done

		logger -p $log -t $name "Role for HAST resources ${resources} switched to primary."


		logger -p $log -t $name "Mounting disks."
		for disk in ${resources}; do
			mkdir -p /hast/${disk}
			fsck -p -y -t ufs /dev/hast/${disk}
			mount /dev/hast/${disk} /hast/${disk}
		done

	;;

	slave)
		logger -p $log -t $name "Switching to secondary provider for ${resources}."

		# Switch roles for the HAST resources
		for disk in ${resources}; do
			if ! mount | grep -q "^/dev/hast/${disk} on "
			then
			else
				umount -f /hast/${disk}
			fi
			sleep $delay
			hastctl role secondary ${disk} 2&gt;&amp;1
			if [ $? -ne 0 ]; then
				logger -p $log -t $name "Unable to switch role to secondary for resource ${disk}."
				exit 1
			fi
			logger -p $log -t $name "Role switched to secondary for resource ${disk}."
		done
	;;
esac</programlisting>

	<para>Im Kern führt das Skript die folgenden Aktionen durch,
	  sobald ein Knoten zum <literal>master</literal> /
	  <literal>primary</literal> wird:</para>

	<itemizedlist>
	  <listitem>
	    <para>Es ernennt den <acronym>HAST</acronym>-Pool als den
	      primären für einen gegebenen Knoten.</para>
	  </listitem>
	  <listitem>
	    <para>Es prüft das Dateisystem, dass auf dem
	      <acronym>HAST</acronym>-Pool erstellt wurde.</para>
	  </listitem>
	  <listitem>
	    <para>Es hängt die Pools an die richtige Stelle im System
	      ein.</para>
	  </listitem>
	</itemizedlist>

	<para>Wenn ein Knoten zum <literal>backup</literal> /
	  <literal>secondary</literal> ernannt wird:</para>

	<itemizedlist>
	  <listitem>
	    <para>Hängt es den <acronym>HAST</acronym>-Pool aus dem
	      Dateisystem aus.</para>
	  </listitem>
	  <listitem>
	    <para>Degradiert es den <acronym>HAST</acronym>-Pool zum
	      sekundären.</para>
	  </listitem>
	</itemizedlist>

	<caution>
	  <para>Bitte beachten Sie, dass dieses Skript nur ein Beispiel
	    für eine mögliche Lösung darstellt.  Es behandelt
	    nicht alle möglichen Szenarien, die auftreten können und
	    sollte erweitert bzw. abgeändert werden, so dass z.B.
	    benötigte Dienste gestartet oder gestoppt werden usw.</para>
	</caution>

	<tip>
	  <para>Für dieses Beispiel wurde ein Standard-UFS Dateisystem
	    verwendet.  Um die Zeit für die Wiederherstellung zu
	    verringern, kann ein UFS mit Journal oder ein ZFS-Dateisystem
	    benutzt werden.</para>
	</tip>

	<para>Weitere detaillierte Informationen mit zusätzlichen
	  Beispielen können auf der <link xlink:href="http://wiki.FreeBSD.org/HAST">HAST Wiki</link>-Seite
	  abgerufen werden.</para>
      </sect3>
    </sect2>
    <sect2>
      <title>Fehlerbehebung</title>

      <sect3>
	<title>Allgemeine Tipps zur Fehlerbehebung</title>

	<para><acronym>HAST</acronym> sollte generell ohne Probleme
	  funktionieren. Jedoch kann es, wie bei jeder anderen Software auch,
	  zu gewissen Zeiten sein, dass sie sich nicht so verhält wie
	  angegeben.  Die Quelle dieser Probleme kann unterschiedlich sein,
	  jedoch sollte als Faustregel gewährleistet werden, dass die
	  Zeit für beide Knoten im Cluster synchron läuft.</para>

	<para>Die Anzahl an Debugging-Meldungen von &man.hastd.8; sollte
	  erhöht werden, wenn Fehler von <acronym>HAST</acronym> bereinigt
	  werden.  Dies kann durch das Starten des &man.hastd.8;-Dienstes mit
	  der Option <literal>-d</literal> erreicht werden.  Wichtig zu wissen
	  ist, dass diese Option mehrfach angegeben werden kann, um die Anzahl
	  an Meldungen weiter zu erhöhen.  Sie können viele
	  nützliche Informationen auf diese Art bekommen.  Sie sollten
	  ebenfalls die Verwendung der Option <literal>-F</literal> in
	  Erwägung ziehen, die den &man.hastd.8;-Dienst in den Vordergrund
	  bringt.</para>
     </sect3>

      <sect3 xml:id="disks-hast-sb">
	<title>Auflösung des Split-brain-Zustands</title>

	<para>Die Konsequenz aus der Situation, wenn beide Knoten des Clusters
	  nicht in der Lage sind, miteinander zu kommunizieren und dadurch
	  beide als primäre Knoten fungieren, wird als
	  <literal>split-brain</literal> bezeichnet.  Dies ist ein
	  gefährlicher Zustand, weil es beiden Knoten erlaubt ist,
	  Änderungen an den Daten vorzunehmen, die miteinander nicht in
	  Einklang gebracht werden können.  Diese Situation sollte vom
	  Systemadministrator händisch bereinigt werden.</para>

	<para>Um diese Situation zu beheben, muss der Administrator
	  entscheiden, welcher Knoten die wichtigsten Änderungen von
	  beiden besitzt (oder diese manuell miteinander vermischen) und
	  anschliessend den <acronym>HAST</acronym>-Knoten die volle
	  Synchronisation mit jenem Knoten durchführen zu lassen, welcher
	  die beschädigten Daten besitzt.  Um dies zu tun, geben Sie die
	  folgenden Befehle auf dem Knoten ein, der neu synchronisiert werden
	  soll:</para>

        <screen>&prompt.root; <userinput>hastctl role init &lt;resource&gt;</userinput>
&prompt.root; <userinput>hastctl create &lt;resource&gt;</userinput>
&prompt.root; <userinput>hastctl role secondary &lt;resource&gt;</userinput></screen>
      </sect3>
    </sect2>
  </sect1>
</chapter>
