<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/advanced-networking/chapter.xml,v 1.195 2011/02/23 12:30:43 jkois Exp $
     basiert auf: 1.436
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="advanced-networking">
  <info><title>Weiterführende Netzwerkthemen</title>
    <authorgroup>
      <author><personname><firstname>Johann</firstname><surname>Kois</surname></personname><contrib>Übersetzt von </contrib></author>
    </authorgroup>
  </info>

  

  <sect1 xml:id="advanced-networking-synopsis">

    <title>Übersicht</title>

    <para>Dieses Kapitel beschreibt verschiedene
      weiterführende Netzwerkthemen.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</para>

    <itemizedlist>
      <listitem>
	<para>Die Grundlagen von Gateways und Routen kennen.</para>
      </listitem>

      <listitem>
	<para>&bluetooth;- sowie drahtlose, der Norm &ieee;&nbsp;802.11
	  entsprechende, Geräte mit FreeBSD verwenden
	  können.</para>
      </listitem>

      <listitem>
	<para>Eine Bridge unter FreeBSD einrichten können.</para>
      </listitem>

      <listitem>
	<para>Einen plattenlosen Rechner über das Netzwerk starten
	  können.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie man NAT (Network Address Translation)
	  einrichtet.</para>
      </listitem>

      <listitem>
	<para>Zwei Computer über PLIP verbinden können.</para>
      </listitem>

      <listitem>
	<para>IPv6 auf einem FreeBSD-Rechner einrichten
	  können.</para>
      </listitem>

      <listitem>
	<para>ATM einrichten können.</para>
      </listitem>

      <listitem>
	<para>CARP, das Common Address Redundancy Protocol, unter
	  &os; einsetzen können.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>

    <itemizedlist>
      <listitem>
	<para>Die Grundlagen der <filename>/etc/rc</filename>-Skripte
	  verstanden haben.</para>
      </listitem>

      <listitem>
	<para>Mit der grundlegenden Netzwerkterminologie vertraut
	  sein.</para>
      </listitem>

      <listitem>
	<para>Einen neuen FreeBSD-Kernel konfigurieren und installieren
	  können (<xref linkend="kernelconfig"/>).</para>
      </listitem>

      <listitem>
	<para>Wissen, wie man zusätzliche Softwarepakete von
	  Drittherstellern installiert (<xref linkend="ports"/>).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="network-routing">
    <info><title>Gateways und Routen</title>
      <authorgroup>
	<author><personname><firstname>Coranth</firstname><surname>Gryphon</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>Routing</primary>
    </indexterm>
    <indexterm>
      <primary>Gateway</primary>
    </indexterm>
    <indexterm>
      <primary>Subnetz</primary>
    </indexterm>

    <para>Damit ein Rechner einen anderen über ein Netzwerk
      finden kann, muss ein Mechanismus vorhanden sein, der
      beschreibt, wie man von einem Rechner zum anderen gelangt.
      Dieser Vorgang wird als <firstterm>Routing</firstterm>
      bezeichnet.  Eine <quote>Route</quote> besteht aus einem
      definierten Adressenpaar: Einem <quote>Ziel</quote> und einem
      <quote>Gateway</quote>.  Dieses Paar zeigt an, dass Sie
      über das <emphasis>Gateway</emphasis> zum
      <emphasis>Ziel</emphasis> gelangen wollen.  Es gibt drei Arten
      von Zielen: Einzelne Rechner (Hosts), Subnetze und das
      <quote>Standard</quote>ziel.  Die <quote>Standardroute</quote>
      wird verwendet, wenn keine andere Route zutrifft.  Wir werden
      Standardrouten später etwas genauer behandeln.
      Außerdem gibt es drei Arten von Gateways: Einzelne Rechner
      (Hosts), Schnittstellen (Interfaces, auch als <quote>Links</quote>
      bezeichnet), sowie Ethernet Hardware-Adressen (MAC-Adressen).
    </para>

    <sect2>
      <title>Ein Beispiel</title>

      <para>Um die verschiedenen Aspekte des Routings zu
	veranschaulichen, verwenden wir folgende Ausgaben von
	<command>netstat</command>:</para>

      <screen>&prompt.user; <userinput>netstat -r</userinput>
Routing tables

Destination               Gateway            Flags       Refs     Use     Netif Expire

default                   outside-gw         UGSc        37       418     ppp0
localhost                 localhost          UH          0        181     lo0
test0                     0:e0:b5:36:cf:4f   UHLW        5        63288   ed0    77
10.20.30.255              link#1             UHLW        1        2421
example.com               link#1             UC          0        0
host1                     0:e0:a8:37:8:1e    UHLW        3        4601    lo0
host2                     0:e0:a8:37:8:1e    UHLW        0        5       lo0 =&gt;
host2.example.com         link#1             UC          0        0
224                       link#1             UC          0        0
</screen>

      <indexterm>
	<primary>Defaultroute</primary>
      </indexterm>

      <para>Die ersten zwei Zeilen geben die Standardroute (die wir
	im <link linkend="network-routing-default"> nächsten
	Abschnitt</link> behandeln), sowie die
	<systemitem>localhost</systemitem> Route an.</para>

      <indexterm>
	<primary>Loopback-Gerät</primary>
      </indexterm>

      <para>Das in der Routingtabelle für
	<literal>localhost</literal> festgelegte Interface
	(<literal>Netif</literal>-Spalte)
	<filename>lo0</filename>, ist auch als loopback-Gerät
	(Prüfschleife) bekannt.  Das heißt, dass der ganze
	Datenverkehr für dieses Ziel intern (innerhalb des
	Gerätes) bleibt, anstatt ihn über ein Netzwerk (LAN)
	zu versenden, da das Ziel dem Start entspricht.</para>

      <indexterm>
	<primary>Ethernet</primary>
	<secondary>MAC-Adresse</secondary>
      </indexterm>

      <para>Der nächste auffällige Punkt sind die mit
	<systemitem class="etheraddress">0:e0:</systemitem> beginnenden Adressen.  Es
	handelt sich dabei um Ethernet Hardwareadressen, die auch als
	MAC-Adressen bekannt sind.  FreeBSD identifiziert Rechner im
	lokalen Netz automatisch (im Beispiel <systemitem>test0</systemitem>)
	und fügt eine direkte Route zu diesem Rechner hinzu.  Dies
	passiert über die Ethernet-Schnittstelle
	<filename>ed0</filename>.  Außerdem existiert ein Timeout
	(in der Spalte <literal>Expire</literal>) für diese Art
	von Routen, der verwendet wird, wenn dieser Rechner in einem
	definierten Zeitraum nicht reagiert.  Wenn dies passiert, wird
	die Route zu diesem Rechner automatisch gelöscht.
	Rechner im lokalen Netz werden durch einen als RIP (Routing
	Information Protocol) bezeichneten Mechanismus identifiziert,
	der den kürzesten Weg zu den jeweiligen Rechnern
	bestimmt.</para>

      <indexterm>
	<primary>Subnetz</primary>
      </indexterm>

      <para>FreeBSD fügt außerdem Subnetzrouten für das
	lokale Subnetz hinzu (<systemitem class="ipaddress">10.20.30.255</systemitem> ist die Broadcast-Adresse
	für das Subnetz <systemitem class="ipaddress">10.20.30</systemitem>,
	<systemitem class="fqdomainname">example.com</systemitem> ist der zu
	diesem Subnetz gehörige Domainname).  Das Ziel
	<literal>link#1</literal> bezieht sich auf die erste
	Ethernet-Karte im Rechner.  Sie können auch feststellen,
	dass keine zusätzlichen Schnittstellen angegeben
	sind.</para>

      <para>Routen für Rechner im lokalen Netz und lokale
	Subnetze werden automatisch durch den
	<application>routed</application> Daemon konfiguriert.  Ist
	dieser nicht gestartet, sind nur statisch definierte
	(explizit eingegebene) Routen vorhanden.</para>

      <para>Die Zeile <literal>host1</literal> bezieht sich auf
	unseren Rechner, der durch seine Ethernetadresse bekannt ist.
	Da unser Rechner der Sender ist, verwendet FreeBSD automatisch
	das Loopback-Gerät (<filename>lo0</filename>),
	anstatt den Datenverkehr über die Ethernetschnittstelle
	zu senden.</para>

      <para>Die zwei <literal>host2</literal> Zeilen sind ein Beispiel
	dafür, was passiert, wenn wir ein &man.ifconfig.8; Alias
	verwenden (Lesen Sie dazu den Abschnitt über Ethernet,
	wenn Sie wissen wollen, warum wir das tun sollten.).  Das
	Symbol <literal>=&gt;</literal> (nach der
	<filename>lo0</filename>-Schnittstelle) sagt aus, dass wir
	nicht nur das Loopbackgerät verwenden (da sich die
	Adresse auf den lokalen Rechner bezieht), sondern dass es sich
	zusätzlich auch um ein Alias handelt.  Solche Routen sind
	nur auf Rechnern vorhanden, die den Alias bereitstellen;
	alle anderen Rechner im lokalen Netz haben für solche
	Routen nur eine einfache <literal>link#1</literal>
	Zeile.</para>

      <para>Die letzte Zeile (Zielsubnetz <literal>224</literal>)
	behandelt das Multicasting, das wir in einem anderen Abschnitt
	besprechen werden.</para>

      <para>Schließlich gibt es für Routen noch
	verschiedene Attribute, die Sie in der Spalte
	<literal>Flags</literal> finden.  Nachfolgend finden Sie eine
	kurze Übersicht von einigen dieser Flags und ihrer
	Bedeutung:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
          <colspec colwidth="1*"/>
          <colspec colwidth="4*"/>

	  <tbody>
	    <row>
	      <entry>U</entry>

	      <entry>Up: Die Route ist aktiv.</entry>
	    </row>

	    <row>
	      <entry>H</entry>

	      <entry>Host: Das Ziel der Route ist ein einzelner
		Rechner (Host).</entry>
	    </row>

	    <row>
	      <entry>G</entry>

	      <entry>Gateway: Alle Daten, die an dieses Ziel gesendet
		werden, werden von diesem System an ihr jeweiliges
		Ziel weitergeleitet.</entry>
	    </row>

	    <row>
	      <entry>S</entry>

	      <entry>Static: Diese Route wurde manuell konfiguriert,
		das heißt sie wurde <emphasis>nicht</emphasis>
		automatisch vom System erzeugt.</entry>
	    </row>

	    <row>
	      <entry>C</entry>

	      <entry>Clone: Erzeugt eine neue Route, basierend auf der
		Route für den Rechner, mit dem wir uns verbinden.
		Diese Routenart wird normalerweise für lokale
		Netzwerke verwendet.</entry>
	    </row>

	    <row>
	      <entry>W</entry>

	      <entry>WasCloned: Eine Route, die automatisch
		konfiguriert wurde.  Sie basiert auf einer lokalen
		Netzwerkroute (Clone).</entry>
	    </row>

	    <row>
	      <entry>L</entry>

	      <entry>Link: Die Route beinhaltet einen Verweis auf eine
		Ethernetkarte (MAC-Adresse).</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2 xml:id="network-routing-default">
      <title>Standardrouten</title>

      <indexterm>
	<primary>Defaultroute</primary>
      </indexterm>

      <indexterm>
	<primary>Standardroute</primary>
	<see>Defaultroute</see>
      </indexterm>

      <para>Wenn sich der lokale Rechner mit einem entfernten Rechner
	verbinden will, wird die Routingtabelle überprüft,
	um festzustellen, ob bereits ein bekannter Pfad vorhanden ist.
	Gehört dieser entfernte Rechner zu einem Subnetz, dessen
	Pfad uns bereits bekannt ist
	(<foreignphrase>Cloned route</foreignphrase>), dann versucht der
	lokale Rechner über diese Schnittstelle eine Verbindung
	herzustellen.</para>

      <para>Wenn alle bekannten Pfade nicht funktionieren, hat der
	lokale Rechner eine letzte Möglichkeit: Die
	Standardroute (Defaultroute).  Bei dieser
	Route handelt es sich um eine spezielle Gateway-Route
	(gewöhnlich die einzige im System vorhandene), die im
	Flags-Feld immer mit <literal>C</literal> gekennzeichnet ist.
	Für Rechner im lokalen Netzwerk ist dieses Gateway auf
	<emphasis>welcher Rechner auch immer eine Verbindung nach
	außen hat</emphasis> gesetzt (entweder über eine
	PPP-Verbindung, DSL, ein Kabelmodem, T1 oder eine beliebige
	andere Netzwerkverbindung).</para>

      <para>Wenn Sie die Standardroute für einen Rechner
	konfigurieren, der selbst als Gateway zur Außenwelt
	funktioniert, wird die Standardroute zum Gateway-Rechner Ihres
	Internetanbieter (ISP) gesetzt.</para>

      <para>Sehen wir uns ein Beispiel für Standardrouten an.  So
	sieht eine übliche Konfiguration aus:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="advanced-networking/net-routing"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced">
[Local2]  &lt;--ether--&gt;  [Local1]  &lt;--PPP--&gt; [ISP-Serv]  &lt;--ether--&gt;  [T1-GW]
	  </literallayout>
	</textobject>
      </mediaobject>

      <para>Die Rechner <systemitem>Local1</systemitem> und
	<systemitem>Local2</systemitem> befinden sich auf Ihrer Seite.
	<systemitem>Local1</systemitem> ist mit einem ISP über eine
	PPP-Verbindung verbunden.  Dieser PPP-Server ist über ein
	lokales Netzwerk mit einem anderen Gateway-Rechner verbunden,
	der über eine Schnittstelle die Verbindung des ISP zum
	Internet herstellt.</para>

      <para>Die Standardrouten für Ihre Maschinen lauten:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Host</entry>

	      <entry>Standard Gateway</entry>

	      <entry>Schnittstelle</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Local2</entry>

	      <entry>Local1</entry>

	      <entry>Ethernet</entry>
	    </row>

	    <row>
	      <entry>Local1</entry>

	      <entry>T1-GW</entry>

	      <entry>PPP</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Eine häufig gestellte Frage lautet: <quote>Warum (oder
	wie) sollten wir <systemitem>T1-GW</systemitem> als Standard-Gateway
	für <systemitem>Local1</systemitem> setzen, statt den (direkt
	verbundenen) ISP-Server zu verwenden?</quote>.</para>

      <para>Bedenken Sie, dass die PPP-Schnittstelle für die
	Verbindung eine Adresse des lokalen Netzes des ISP verwendet.
	Daher werden Routen für alle anderen Rechner im lokalen
	Netz des ISP automatisch erzeugt.  Daraus folgt, dass Sie
	bereits wissen, wie Sie <systemitem>T1-GW</systemitem> erreichen
	können!  Es ist also unnötig, einen Zwischenschritt
	über den ISP-Server zu machen.</para>

      <para>Es ist üblich, die Adresse <systemitem class="ipaddress">X.X.X.1</systemitem> als Gateway-Adresse für
	ihr lokales Netzwerk zu verwenden.  Für unser Beispiel
	bedeutet dies Folgendes: Wenn Ihr lokaler Klasse-C-Adressraum
	<systemitem class="ipaddress">10.20.30</systemitem> ist und Ihr ISP
	<systemitem class="ipaddress">10.9.9</systemitem> verwendet, sehen die
	Standardrouten so aus:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Rechner (Host)</entry>

	      <entry>Standardroute</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Local2 (10.20.30.2)</entry>

	      <entry>Local1 (10.20.30.1)</entry>
	    </row>

	    <row>
	      <entry>Local1 (10.20.30.1, 10.9.9.30)</entry>

	      <entry>T1-GW (10.9.9.1)</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Sie können die Standardroute ganz einfach in der Datei
	<filename>/etc/rc.conf</filename> festlegen.  In unserem
	Beispiel wurde auf dem Rechner <systemitem>Local2</systemitem>
	folgende Zeile in <filename>/etc/rc.conf</filename>
	eingefügt:</para>

      <programlisting>defaultrouter="10.20.30.1"</programlisting>

      <para>Die Standardroute kann über &man.route.8; auch direkt
	gesetzt werden:</para>

      <screen>&prompt.root; <userinput>route add default 10.20.30.1</userinput></screen>

      <para>Weitere Informationen zum Bearbeiten von
	Netzwerkroutingtabellen finden Sie in &man.route.8;.</para>
    </sect2>

    <sect2 xml:id="network-dual-homed-hosts">
      <title>Rechner mit zwei Heimatnetzen</title>
      <indexterm>
	<primary>Dual-Homed-Hosts</primary>
      </indexterm>

      <para>Es gibt noch eine Konfigurationsmöglichkeit, die wir
	besprechen sollten, und zwar Rechner, die sich in zwei
	Netzwerken befinden.  Technisch gesehen, zählt jeder als
	Gateway arbeitende Rechner zu den Rechnern mit zwei
	Heimatnetzen (im obigen Beispiel unter Verwendung einer
	PPP-Verbindung).  In der Praxis meint man damit allerdings nur
	Rechner, die sich in zwei lokalen Netzen befinden.</para>

      <para>Entweder verfügt der Rechner über zwei
	Ethernetkarten und jede dieser Karten hat eine Adresse in
	einem separaten Subnetz, oder der Rechner hat nur eine
	Ethernetkarte und verwendet &man.ifconfig.8; Aliasing.  Die
	erste Möglichkeit wird verwendet, wenn zwei physikalisch
	getrennte Ethernet-Netzwerke vorhanden sind, die zweite, wenn
	es nur ein physikalisches Ethernet-Netzwerk gibt, das aber aus
	zwei logisch getrennten Subnetzen besteht.</para>

      <para>In beiden Fällen werden Routingtabellen erstellt,
	damit jedes Subnetz weiß, dass dieser Rechner als Gateway
	zum anderen Subnetz arbeitet (<foreignphrase>inbound
	route</foreignphrase>).  Diese Konfiguration (der
	Gateway-Rechner arbeitet als Router zwischen den Subnetzen) wird
	häufig verwendet, wenn es darum geht, Paketfilterung oder
	eine Firewall (in eine oder beide Richtungen) zu implementieren.
      </para>

      <para>Soll dieser Rechner Pakete zwischen den beiden
	Schnittstellen weiterleiten, müssen Sie diese Funktion
	manuell konfigurieren und aktivieren.  Lesen Sie den
	nächsten Abschnitt, wenn Sie weitere Informationen zu
	diesem Thema benötigen.</para>
    </sect2>

    <sect2 xml:id="network-dedicated-router">
      <title>Einen Router konfigurieren</title>

      <indexterm>
	<primary>Router</primary>
      </indexterm>

      <para>Ein Netzwerkrouter ist einfach ein System, das Pakete von
	einer Schnittstelle zur anderen weiterleitet.
	Internetstandards und gute Ingenieurspraxis sorgten
	dafür, dass diese Funktion in FreeBSD in der Voreinstellung
	deaktiviert ist.  Sie können diese Funktion aktivieren,
	indem Sie in &man.rc.conf.5;  folgende Änderung
	durchführen:</para>

      <programlisting>gateway_enable="YES"          # Auf YES setzen, wenn der Rechner als Gateway arbeiten soll</programlisting>

      <para>Diese Option setzt die &man.sysctl.8;-Variable
	<varname>net.inet.ip.forwarding</varname> auf
	<literal>1</literal>.  Wenn Sie das Routing kurzzeitig
	unterbrechen wollen, können Sie die Variable auf
	<literal>0</literal> setzen.</para>

      <indexterm><primary>BGP</primary></indexterm>
      <indexterm><primary>RIP</primary></indexterm>
      <indexterm><primary>OSPF</primary></indexterm>

      <para>Ihr neuer Router benötigt nun noch Routen, um zu
	wissen, wohin er den Verkehr senden soll.  Haben Sie ein
	(sehr) einfaches Netzwerk, können Sie statische Routen
	verwenden.  FreeBSD verfügt über den Standard
	BSD-Routing-Daemon &man.routed.8;, der RIP (sowohl Version 1
	als auch Version 2) und IRDP versteht.  BGP&nbsp;v4,
	OSPF&nbsp;v2 und andere Protokolle werden von
	<package>net/zebra</package>
	unterstützt.  Es stehen auch kommerzielle Produkte
	wie <application>gated</application> zur Verfügung.</para>
    </sect2>

    <sect2 xml:id="network-static-routes">
      <info><title>Statische Routen einrichten</title>
	<authorgroup>
	  <author><personname><firstname>Al</firstname><surname>Hoang</surname></personname><contrib>Beigetragen von </contrib></author>
	</authorgroup>
      </info>

      

      <sect3>
	<title>Manuelle Konfiguration</title>

	<para>Nehmen wir an, dass wir über folgendes Netzwerk
	  verfügen:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="advanced-networking/static-routes"/>
          </imageobject>

          <textobject>
            <literallayout class="monospaced">
    INTERNET
      | (10.0.0.1/24) Default Router to Internet
      |
      |Interface xl0
      |10.0.0.10/24
   +------+
   |      | RouterA
   |      | (FreeBSD gateway)
   +------+
      | Interface xl1
      | 192.168.1.1/24
      |
  +--------------------------------+
   Internal Net 1      | 192.168.1.2/24
                       |
                   +------+
                   |      | RouterB
                   |      |
                   +------+
                       | 192.168.2.1/24
                       |
                     Internal Net 2
            </literallayout>
          </textobject>
        </mediaobject>

	<para><systemitem>RouterA</systemitem>, ein &os;-Rechner, dient als
	  Router für den Zugriff auf das Internet.  Die
	  Standardroute ist auf <systemitem class="ipaddress">10.0.0.1</systemitem>
	  gesetzt, damit ein Zugriff auf das Internet möglich wird.
	  Wir nehmen nun an, dass <systemitem>RouterB</systemitem> bereits
	  konfiguriert ist und daher weiß, wie er andere Rechner
	  erreichen kann.  Dazu wird die Standardroute von
	  <systemitem>RouterB</systemitem> auf
	  <systemitem class="ipaddress">192.168.1.1</systemitem> gesetzt, da dieser
	  Rechner als Gateway fungiert.</para>

	<para>Sieht man sich die Routingtabelle für
	  <systemitem>RouterA</systemitem> an, erhält man folgende Ausgabe:
	</para>

	<screen>&prompt.user; <userinput>netstat -nr</userinput>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0/24          link#1             UC          0        0    xl0
192.168.1/24       link#2             UC          0        0    xl1</screen>

	<para>Mit dieser Routingtabelle kann <systemitem>RouterA</systemitem>
	  unser internes Netz 2 nicht erreichen, da keine Route zum
	  Rechner <systemitem class="ipaddress">192.168.2.0/24</systemitem>
	  vorhanden ist.  Um dies zu korrigieren, kann die Route manuell
	  gesetzt werden.  Durch den folgenden Befehl wird das
	  interne Netz 2 in die Routingtabelle des Rechners
	  <systemitem>RouterA</systemitem> aufgenommen, indem
	  <systemitem class="ipaddress">192.168.1.2</systemitem> als nächster
	  Zwischenschritt verwenden wird:</para>

	<screen>&prompt.root; <userinput>route add -net 192.168.2.0/24 192.168.1.2</userinput></screen>

	<para>Ab sofort kann <systemitem>RouterA</systemitem> alle Rechner des
	  Netzwerks <systemitem class="ipaddress">192.168.2.0/24</systemitem>
	  erreichen.</para>
      </sect3>

      <sect3>
	<title>Routen dauerhaft einrichten</title>

	<para>Das obige Beispiel ist für die Konfiguration einer
	  statischen Route auf einem laufenden System geeignet.  Diese
	  Information geht jedoch verloren, wenn der &os;-Rechner neu
	  gestartet werden muss.  Um dies zu verhindern, wird diese
	  Route in <filename>/etc/rc.conf</filename> eingetragen:</para>

	<programlisting># Add Internal Net 2 as a static route
static_routes="internalnet2"
route_internalnet2="-net 192.168.2.0/24 192.168.1.2"</programlisting>

	<para>Die Variable <literal>static_routes</literal> enthält
	  eine Reihe von Strings, die durch Leerzeichen getrennt sind.
	  Jeder String bezieht sich auf den Namen einer Route.  In
	  unserem Beispiel hat <literal>static_routes</literal>
	  <replaceable>internalnet2</replaceable> als einzigen String.
	  Zusätzlich verwendet man die Konfigurationsvariable
	  <literal>route_internalnet2</literal>,
	  in der alle sonstigen an &man.route.8; zu übergebenden
	  Parameter festgelegt werden.  In obigen Beispiel hätte
	  man folgenden Befehl verwendet:</para>

	<screen>&prompt.root; <userinput>route add -net 192.168.2.0/24 192.168.1.2</userinput></screen>

	<para>Daher wird
	  <literal>"-net 192.168.2.0/24 192.168.1.2"</literal> als
	  Parameter der Variable <literal>route_</literal> angegeben.
	</para>

	<para>Wie bereits erwähnt, können bei
	  <literal>static_routes</literal> auch mehrere Strings
	  angegeben werden.  Dadurch lassen sich mehrere statische
	  Routen anlegen.  Durch folgende Zeilen werden auf einem
	  imaginären Rechner statische Routen zu den Netzwerken
	  <systemitem class="ipaddress">192.168.0.0/24</systemitem> sowie <systemitem class="ipaddress">192.168.1.0/24</systemitem> definiert:</para>

	<programlisting>static_routes="net1 net2"
route_net1="-net 192.168.0.0/24 192.168.0.1"
route_net2="-net 192.168.1.0/24 192.168.1.1"</programlisting>
      </sect3>
    </sect2>

    <sect2 xml:id="network-routing-propagation">
      <title>Verteilung von Routing-Informationen</title>
      <indexterm>
	<primary>routing propagation</primary>
      </indexterm>

      <para>Wir haben bereits darüber gesprochen, wie wir unsere
	Routen zur Außenwelt definieren, aber nicht darüber,
	wie die Außenwelt uns finden kann.</para>

      <para>Wir wissen bereits, dass Routing-Tabellen so erstellt
	werden können, dass sämtlicher Verkehr für
	einen bestimmten Adressraum (in unserem Beispiel ein
	Klasse-C-Subnetz) zu einem bestimmten Rechner in diesem
	Netzwerk gesendet wird, der die eingehenden Pakete im Subnetz
	verteilt.</para>

      <para>Wenn Sie einen Adressraum für Ihre Seite zugewiesen
	bekommen, richtet Ihr Diensteanbieter seine Routingtabellen so
	ein, dass der ganze Verkehr für Ihr Subnetz entlang Ihrer
	PPP-Verbindung zu Ihrer Seite gesendet wird.  Aber woher
	wissen die Seiten in der Außenwelt, dass sie die Daten an
	Ihren ISP senden sollen?</para>

      <para>Es gibt ein System (ähnlich dem verbreiteten DNS),
	das alle zugewiesenen Adressräume verwaltet und ihre
	Verbindung zum Internet-Backbone definiert und dokumentiert.
	Der <quote>Backbone</quote> ist das Netz aus
	Hauptverbindungen, die den Internetverkehr in der ganzen Welt
	transportieren und verteilen.  Jeder Backbone-Rechner
	verfügt über eine Kopie von Haupttabellen, die den
	Verkehr für ein bestimmtes Netzwerk hierarchisch vom
	Backbone über eine Kette von Diensteanbietern bis hin zu
	Ihrer Seite leiten.</para>

      <para>Es ist die Aufgabe Ihres Diensteanbieters, den
	Backbone-Seiten mitzuteilen, dass sie mit Ihrer Seite
	verbunden wurden.  Durch diese Mitteilung der Route ist nun
	auch der Weg zu Ihnen bekannt.  Dieser Vorgang wird als
	<emphasis>Bekanntmachung von Routen</emphasis>
	(<foreignphrase>routing propagation</foreignphrase>)
	bezeichnet.</para>
    </sect2>

    <sect2 xml:id="network-routing-troubleshooting">
      <title>Problembehebung</title>
      <indexterm>
	<primary><command>traceroute</command></primary>
      </indexterm>

      <para>Manchmal kommt es zu Problemen bei der Bekanntmachung von
	Routen, und einige Seiten sind nicht in der Lage, Sie zu
	erreichen.  Vielleicht der nützlichste Befehl, um
	festzustellen, wo das Routing nicht funktioniert, ist
	&man.traceroute.8;.  Er ist außerdem sehr nützlich,
	wenn Sie einen entfernten Rechner nicht erreichen können
	(lesen Sie dazu auch &man.ping.8;).</para>

      <para>&man.traceroute.8; wird mit dem zu erreichenden Rechner
	(Host) ausgeführt.  Angezeigt werden die Gateway-Rechner
	entlang des Verbindungspfades.  Schließlich wird der
	Zielrechner erreicht oder es kommt zu einem Verbindungsabbruch
	(beispielsweise durch Nichterreichbarkeit eines
	Gateway-Rechners).</para>

      <para>Weitere Informationen finden Sie in
	&man.traceroute.8;.</para>
    </sect2>

    <sect2 xml:id="network-routing-multicast">
      <title>Multicast-Routing</title>
      <indexterm>
	<primary>Multicast-Routing</primary>
      </indexterm>

      <indexterm>
	<primary>Kerneloptionen</primary>
	<secondary>MROUTING</secondary>
      </indexterm>

      <para>&os; unterstützt sowohl Multicast-Anwendungen als
	auch Multicast-Routing.  Multicast-Anwendungen müssen
	nicht konfiguriert werden, sie laufen einfach.
	Multicast-Routing muss in der Kernelkonfiguration aktiviert
	werden:</para>

      <programlisting>options MROUTING</programlisting>

      <para>Zusätzlich muss &man.mrouted.8;, der
	Multicast-Routing-Daemon, über die Datei
	<filename>/etc/mrouted.conf</filename> eingerichtet werden,
	um Tunnel und <acronym>DVMRP</acronym> zu aktivieren.  Weitere
	Informationen zu diesem Thema finden Sie in
	&man.mrouted.8;.</para>

      <note>
	<para>&man.mrouted.8;, der Multicast Routing Daemon,
	  verwendet das <acronym>DVMRP</acronym> Multicast Routing
	  Protocol, das inzwischen in den meisten Multicast-Installationen
	  durch &man.pim.4; ersetzt wurde.   &man.mrouted.8; sowie die
	  damit in Verbindung stehenden Werkzeuge &man.map-mbone.8; und
	  &man.mrinfo.8;können über die &os;-Ports-Sammlung
	  (genauer den Port <package>net/mrouted</package>) installiert werden.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 xml:id="network-wireless">
    <info><title>Drahtlose Netzwerke</title>
      <authorgroup>
	<author><personname><othername>Loader</othername></personname></author>

	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname></author>

	<author><personname><firstname>Murray</firstname><surname>Stokely</surname></personname></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>Netzwerke, drahtlos</primary></indexterm>
    <indexterm>
      <primary>802.11</primary>
      <see>drahtlose Netzwerke</see>
    </indexterm>

    <sect2>
      <title>Grundlagen</title>

      <para>Die meisten drahtlosen Netzwerke basieren auf dem
	Standard &ieee;&nbsp;802.11.  Sie bestehen aus Stationen, die
	in der Regel im 2,4&nbsp;GHz- oder im 5&nbsp;GHz-Band
	miteinander kommunizieren.  Es ist aber auch
	möglich, dass regional andere Frequenzen,
	beispielsweise im 2,3&nbsp;GHz- oder 4,9&nbsp;GHz-Band,
	verwendet werden.</para>

      <para>802.11-Netzwerke können auf zwei verschiedene
	Arten aufgebaut sein:  Im
	<emphasis>Infrastruktur-Modus</emphasis> agiert eine
	Station als Master, mit dem sich alle anderen Stationen
	verbinden.  Die Summe aller Stationen wird als BSS
	(Basic Service Set), die Master-Station hingegen als
	Access Point (AP) bezeichnet.  In einem BSS läuft
	jedwede Kommunikation über den Access Point.  Die
	zweite Form drahtloser Netzwerke sind die sogenannten
	<emphasis>Ad-hoc-Netzwerke</emphasis> (auch als IBSS
	bezeichnet), in denen es keinen Access Point gibt und
	in denen die Stationen direkt miteinander
	kommunizieren.</para>

      <para>Die ersten 802.11-Netzwerke arbeiteten im
	2,4&nbsp;GHz-Band und nutzten dazu Protokolle der
	&ieee;-Standards 802.11 sowie 802.11b.  Diese Standards
	legen unter anderem Betriebsfrequenzen sowie Merkmale
	des MAC-Layers (wie Frames und Transmissionsraten) fest.
	Später kam der Standard 802.11a hinzu, der im
	5&nbsp;GHz-Band, im Gegensatz zu den ersten beiden
	Standards aber mit unterschiedlichen Signalmechanismen
	und höheren Transmissionsraten arbeitet.  Der
	neueste Standard 802.11g implementiert die Signal- und
	Transmissionsmechanismen von 802.11a im 2,4&nbsp;GHz-Band,
	ist dabei aber abwärtskompatibel zu
	802.11b-Netzwerken.</para>

      <para>Unabhängig von den zugrundeliegenden
	Transportmechanismen verfügen 802.11-Netzwerke
	über diverse Sicherheitsmechanismen.  Der
	ursprüngliche 802.11-Standard definierte lediglich
	ein einfaches Sicherheitsprotokoll namens WEP.  Dieses
	Protokoll verwendet einen fixen (gemeinsam verwendeten)
	Schlüssel sowie die RC4-Kryptografie-Chiffre,
	um Daten verschlüsselt über das drahtlose
	Netzwerk zu senden.  Alle Stationen des Netzwerks
	müssen sich auf den gleichen fixen Schlüssel
	einigen, um miteinander kommunizieren zu können.  Dieses
	Schema ist sehr leicht zu knacken und wird deshalb heute
	kaum mehr eingesetzt.  Aktuelle Sicherheitsmechanismen
	bauen auf dem Standard &ieee;&nbsp;802.11i auf, der neue
	kryptografische Schlüssel (Chiffren), ein neues
	Protokoll für die Anmeldung von Stationen an einem
	Access Point, sowie Mechanismen zum Austausch von
	Schlüsseln als Vorbereitung der Kommunikation zwischen
	verschiedenen Geräten festlegt.  Kryptografische
	Schlüssel werden regelmäßig getauscht.
	Außerdem gibt es Mechanismen, um Einbruchsversuche
	zu entdecken (und Gegenmaßnahmen ergreifen zu können).
	Ein weiteres häufig verwendetes Sicherheitsprotokoll ist
	WPA.  Dabei handelt es sich um einen Vorläufer von 802.11i,
	der von einem Industriekonsortium als Zwischenlösung bis
	zur endgültigen Verabschiedung von 802.11i entwickelt
	wurde.  WPA definiert eine Untergruppe der Anforderungen des
	802.11i-Standards und ist für den Einsatz in älterer
	Hardware vorgesehen.  WPA benötigt nur den (auf dem
	ursprünglichen WEP-Code basierenden) TKIP-Chiffre.  802.11i
	erlaubt zwar auch die Verwendung von TKIP, fordert aber
	zusätzlich eine stärkere Chiffre (AES-CCM)
	für die Datenverschlüsselung.  (AES war für
	WPA nicht vorgesehen, weil man es als zu rechenintensiv
	für den Einsatz in älteren Geräten ansah.)</para>

      <para>Neben den weiter oben erwähnten Standards ist auch
	der Standard 802.11e von großer Bedeutung.  Dieser
	definiert Protokolle zur Übertragung von
	Multimedia-Anwendungen wie das Streaming von Videodateien
	oder Voice-over-IP (VoIP) in einem 802.11-Netzwerk.  Analog
	zu 802.11i verfügt auch 802.11e über eine
	vorläufige Spezifikation namens WMM (ursprünglich
	WME), die von einem Industriekonsortium als Untergruppe
	von 802.11e spezifiziert wurde, um Multimedia-Anwendungen
	bereits vor der endgültigen Verabschiedung des
	802.11e-Standards implementieren zu können.  802.11e
	sowie WME/WMM  erlauben eine Prioritätenvergabe beim
	Datentransfer im einem drahtlosen Netzwerk.  Möglich
	wird dies durch den Einsatz von Quality of Service-Protokollen
	(QoS) und erweiterten Medienzugriffsprotokollen.  Werden
	diese Protokolle korrekt implementiert, erlauben sie daher
	hohe Datenübertragungsraten und einen priorisierten
	Datenfluss.</para>

      <para>&os; unterstützt die Standards
	802.11a, 802.11b, sowie 802.11g.  Ebenfalls unterstützt
	werden WPA sowie die Sicherheitsprotokolle gemäß
	802.11i (dies sowohl für 11a, 11b als auch 11g). QoS und
	Verkehrspriorisierung, die von den WME/WMM-Protokollen
	benötigt werden, werden ebenfalls (allerdings nicht
	für alle drahtlosen Geräte) unterstützt.</para>
    </sect2>

    <sect2 xml:id="network-wireless-basic">
      <title>Basiskonfiguration</title>

      <sect3>
	<title>Kernelkonfiguration</title>

	<para>Um ein drahtloses Netzwerk zu nutzen, benötigen
	  Sie eine drahtlose Netzwerkkarte und einen Kernel, der
	  drahtlose Netzwerke unterstützt.  Der &os;-Kernel
	  unterstützt den Einsatz von Kernelmodulen.  Daher
	  müssen Sie nur die Unterstützung für die
	  von Ihnen verwendeten Geräte aktivieren.</para>

	<para>Als Erstes benötigen Sie ein drahtloses Gerät.
	  Die meisten drahtlosen Geräte verwenden Bauteile von
	  Atheros und werden deshalb vom &man.ath.4;-Treiber
	  unterstützt.  Um diesen Treiber zu verwenden,
	  nehmen Sie die folgende Zeile in die Datei
	  <filename>/boot/loader.conf</filename> auf:</para>

	<programlisting>if_ath_load="YES"</programlisting>

	<para>Der Atheros-Treiber besteht aus drei Teilen:
	  dem Treiber selbst (&man.ath.4;), dem
	  Hardware-Support-Layer für die
	  chip-spezifischen Funktionen (&man.ath.hal.4;)
	  sowie einem Algorithmus zur Auswahl der korrekten
	  Frame-Übertragungsrate (ath_rate_sample).
	  Wenn Sie die Unterstützung für diesen
	  Treiber als Kernelmodul laden, kümmert sich
	  dieses automatisch um diese Aufgaben.  Verwenden
	  Sie ein Nicht-Atheros-Gerät, so müssen
	  Sie hingegen das für dieses Gerät geeignete
	  Modul laden, beispielsweise</para>

	<programlisting>if_wi_load="YES"</programlisting>

	<para>für Geräte, die auf Bauteilen von
	  Intersil Prism basieren und daher den Treiber
	  &man.wi.4; voraussetzen.</para>

	<note>
	  <para>In den folgenden Abschnitten wird der
	    &man.ath.4;-Treiber verwendet.  Verwenden Sie ein
	    anderes Gerät, müssen Sie diesen Wert
	    daher an Ihre Konfiguration anpassen.  Eine Liste aller
	    verfügbaren Treiber und unterstützten
	    drahtlosen Geräte finden sich in den &os;
	    Hardware Notes.  Diese sind für verschiedene
	    Releases und Architekturen auf der Seite <link xlink:href="http://www.FreeBSD.org/releases/index.html">
	    Release Information</link> der &os; Homepage.  Gibt es
	    keinen nativen &os;-Treiber für Ihr drahtloses
	    Gerät, können Sie möglicherweise mit
	    <link linkend="config-network-ndis">NDIS</link> einen
	    &windows;-Treiber verwenden.</para>
	</note>

	<para>Unter &os;&nbsp;7.X benötigen Sie zusätlich
	  zum korrekten Treiber auch die Unterstützung
	  für 802.11-Netzwerke.  Für
	  den &man.ath.4;-Treiber werden dazu mindestens die
	  Module &man.wlan.4;, <literal>wlan_scan_ap</literal>
	  sowie <literal>wlan_scan_sta</literal> benötigt.
	  Das &man.wlan.4;-Kernelmodul wird automatisch mit dem
	  Treiber des drahtlosen Geräts geladen, die beiden
	  anderen Module werden jeweils durch einen Eintrag in der
	  Datei <filename>/boot/loader.conf</filename> beim Systemstart
	  geladen:</para>

	<programlisting>wlan_scan_ap_load="YES"
wlan_scan_sta_load="YES"</programlisting>

	<para>Ab &os;&nbsp;8.0 sind diese Module Teil des
	  &man.wlan.4;-Treibers und werden bei Bedarf automatisch
	  geladen.</para>

	<para>Zusätzlich
	  benötigen Sie noch Module zur Verschlüsselung
	  ihres drahtlosen Netzwerks.  Diese werden normalerweise
	  dynamisch vom &man.wlan.4;-Modul geladen.  Im folgenden
	  Beispiel erfolgt allerdings eine manuelle Konfiguration.
	  Folgende Module sind verfügbar:  &man.wlan.wep.4;,
	  &man.wlan.ccmp.4; sowie &man.wlan.tkip.4;.  Sowohl
	  &man.wlan.ccmp.4; als auch &man.wlan.tkip.4; werden nur
	  benötigt, wenn Sie WPA und/oder die Sicherheitsprotokolle
	  von 802.11i verwenden wollen.  Wollen Sie Ihr Netzwerk
	  hingegen ohne Verschlüsselung betreiben,
	  benötigen Sie nicht einmal
	  die &man.wlan.wep.4;-Unterstützung.  Um alle drei
	  Module beim Systemstart zu laden, fügen Sie folgende
	  Zeilen in die Datei <filename>/boot/loader.conf</filename>
	  ein:</para>

	<programlisting>wlan_wep_load="YES"
wlan_ccmp_load="YES"
wlan_tkip_load="YES"</programlisting>

	<para>Um diese neuen Einträge in der Datei
	  <filename>/boot/loader.conf</filename> zu aktivieren, müssen
	  Sie Ihr &os;-System neu starten.  Alternativ können Sie
	  die Kernelmodule aber auch manuell mit &man.kldload.8; laden.</para>

	<note>
	  <para>Wollen Sie keine Kernelmodule verwenden, können
	    Sie die benötigten Treiber auch in Ihren Kernel
	    kompilieren.  Daz nehmen Sie folgende Zeilen in Ihre
	    Kernelkonfigurationsdatei auf:</para>

	  <programlisting>device wlan              # 802.11 support
device wlan_wep          # 802.11 WEP support
device wlan_ccmp         # 802.11 CCMP support
device wlan_tkip         # 802.11 TKIP support
device wlan_amrr         # AMRR transmit rate control algorithm
device ath               # Atheros pci/cardbus NIC's
device ath_hal           # pci/cardbus chip support
options AH_SUPPORT_AR5416 # enable AR5416 tx/rx descriptors
device ath_rate_sample   # SampleRate tx rate control for ath</programlisting>

        <para>Verwenden Sie &os;&nbsp;7.X, müssen Sie auch die beiden
	  Module <literal>wlan_scan_ap</literal> und
	  <literal>wlan_scan_sta</literal> in den Kernel aufnehmen (unter
	  &os;&nbsp;8.X ist dies hingegen nicht mehr notwendig):</para>

	<programlisting>device wlan_scan_ap      # 802.11 AP mode scanning
device wlan_scan_sta     # 802.11 STA mode scanning</programlisting>

	  <para>Danach bauen Sie den neuen Kernel und starten Ihr
	    &os;-System neu.</para>
	</note>

	<para>Während des Systemstarts sollten nun einige
	  Informationen ähnlich den folgenden über das von
	  Ihnen verwendete drahtlose Gerät ausgegeben
	  werden:</para>

	<screen>ath0: &lt;Atheros 5212&gt; mem 0x88000000-0x8800ffff irq 11 at device 0.0 on cardbus1
ath0: [ITHREAD]
ath0: AR2413 mac 7.9 RF2413 phy 4.5</screen>
      </sect3>
    </sect2>

    <sect2>
      <title>Infrastruktur-Modus</title>

      <para>Drahtlose Netzwerke werden in der Regel im
	Infrastruktur-Modus (auch BSS-Modus genannt) betrieben.
	Dazu werden mehrere drahtlose Access Points zu einem
	gemeinsamen drahtlosen Netzwerk verbunden.  Jedes dieser
	drahtlosen Netzwerke hat einen eigenen Namen, der als
	<emphasis>SSID</emphasis> bezeichnet wird.  Alle Clients
	eines drahtlosen Netzwerks verbinden sich in diesem Modus
	mit einem Access Point.</para>

      <sect3>
	<title>&os;-Clients</title>

	<sect4>
	  <title>Einen Access Point finden</title>

	  <para>Um nach drahtlosen Netzwerken zu suchen verwenden Sie
	    <command>ifconfig</command>.  Dieser Scanvorgang kann einige
	    Zei in Anspruch nehmen, da dazu jede verfügbare
	    Frequenz auf verfügbare Access Points hin
	    überprüft werden muss.  Um die Suche zu starten,
	    müssen Sie als Super-User angemeldet sein:</para>

	  <screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0</userinput>
&prompt.root; <userinput>ifconfig wlan0 up scan</userinput>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
dlinkap         00:13:46:49:41:76   11   54M -90:96   100 EPS  WPA WME
freebsdap       00:11:95:c3:0d:ac    1   54M -83:96   100 EPS  WPA</screen>

	  <note>
	    <para>Ihre Netzwerkkarte muss in den Status
	      <option>up</option> versetzt werden, bevor Sie den ersten
	      Scanvorgang starten können.  Für spätere
	      Scans ist dies aber nicht mehr erforderlich.</para>
	  </note>

	  <note>
	    <para>Unter &os;&nbsp;7.X wird der Gerätetreiber,
	      beispielsweise
	      <filename>ath0</filename>,
	      direkt verwendet, anstatt auf das allgemeine Gerät
	      <filename>wlan0</filename>
	      zuzugreifen.  Verwenden Sie also &os;&nbsp;7.X, müssen
	      Sie die beiden Befehle im vorigen Beispiel durch den
	      folgenden Befehl ersetzen:</para>

	    <screen>&prompt.root; <userinput>ifconfig ath0 up scan</userinput></screen>

	    <para>Dies gilt auch für alle weiteren Ausführungen
	      in diesem Kapitel.  Unter &os;&nbsp;7.X müssen analog
	      alle Befehle und Konfigurationsdateien/Zeilen entsprechend
	      angepasst werden.</para>
	  </note>

	  <para>Als Ergebnis erhalten Sie eine Liste mit allen
	    gefundenen BSS/IBSS-Netzwerken.  Zusätzlich zur
	    <literal>SSID</literal> (dem Namen des Netzwerks) wird
	    auch die <literal>BSSID</literal> ausgegeben.  Dabei
	    handelt es sich um MAC-Adresse des Access Points.  Das
	    Feld <literal>CAPS</literal> gibt den Typ des Netzwerks
	    sowie die Fähigkeiten der Stationen innerhalb des
	    Netzwerks an:</para>

	  <variablelist>
	    <varlistentry>
	      <term><literal>E</literal></term>

	      <listitem>
		<para>Extended Service Set (ESS).  Zeigt an, dass die
		  Station Teil eines Infrastruktur-Netzwerks ist (und
		  nicht eines IBSS/Ad-hoc-Netzwerks).</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>I</literal></term>

	      <listitem>
		<para>IBSS/Ad-hoc-Netzwerk.  Die Station ist Teil eines
		  Ad-hoc-Netzwerks (und nicht eines
		  ESS-Netzwerks).</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>P</literal></term>

	      <listitem>
		<para>Privacy.  Alle Datenframes, die innerhalb des
		  BSS ausgetauscht werden, sind verschlüsselt.
		  Dieses BSS verwendet dazu kryptografische Verfahren
		  wie WEP, TKIP oder AES-CCMP.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>S</literal></term>

	      <listitem>
		<para>Short Preamble.  Das Netzwerk verwendet eine
		  kurze Präambel (definiert in 802.11b High
		  Rate/DSSS PHY). Eine kurze Präambel verwendet
		  ein 56&nbsp;Bit langes Sync-Feld (im Gegensatz
		  zu einer langen Präambel, die ein
		  128&nbsp;Bit langes Sync-Feld verwendet).</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>s</literal></term>

	      <listitem>
		<para>Short slot time.  Das 802.11g-Netzwerk verwendet
		  eine kurze Slotzeit, da es in diesem Netzwerk keine
		  veralteten (802.11b) Geräte gibt.</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Um eine Liste der bekannten Netzwerke auszugeben,
	    verwenden Sie den folgenden Befehl:</para>

	  <screen>&prompt.root; <userinput>ifconfig wlan0 list scan</userinput></screen>

	  <para>Diese Liste kann entweder automatisch durch das
	    drahtlose Gerät oder manuell durch eine
	    <option>scan</option>-Aufforderung aktualisiert werden.
	    Veraltete Informationen werden dabei automatisch
	    entfernt.</para>
	</sect4>

	<sect4>
	  <title>Basiseinstellungen</title>

	  <para>Dieser Abschnitt beschreibt, wie Sie ein einfaches
	    drahtloses Netzerk ohne Verschlüsselung unter &os;
	    einrichten.  Nachdem Sie sich mit den Informationen dieses
	    Abschnitts vertraut gemacht haben, sollten Sie Ihr
	    drahtloses Netzwerk mit <link linkend="network-wireless-wpa">WPA</link>
	    verschlüsseln.</para>

	  <para>Das Einrichten eines drahtlosen Netzwerks erfolgt
	    in drei Schritten:  Der Auswahl eines Access Points, der
	    Anmeldung Ihrer Station sowie der Konfiguration Ihrer
	    IP-Adresse.</para>

	  <sect5>
	    <title>Einen Access Point auswählen</title>

	    <para>Im Normalfall wird sich Ihre Station automatisch mit
	      einem der zur Verfügung stehenden Access Points
	      verbinden.  Sie müssen dazu lediglich Ihr
	      drahtloses Gerät aktivieren.  Alternativ können
	      Sie auch einen Eintrag ähnlich dem folgenden in
	      <filename>/etc/rc.conf</filename> aufnehmen:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="DHCP"</programlisting>

	    <note>
	      <para>Wie bereits erwähnt, benötigen Sie unter
		&os;&nbsp;7.X anstelle dieser beiden Zeilen nur eine
		Zeile (mit dem entsprechenden Gerätetreiber):</para>

	      <programlisting>ifconfig_ath0="DHCP"</programlisting>
	    </note>

	    <para>Wollen Sie sich hingegen mit einem bestimmten
	      Access Point verbinden, müssen Sie dessen
	      SSID angeben:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="ssid <replaceable>Ihre_SSID</replaceable> DHCP"</programlisting>

	    <para>Gibt es in Ihrem Netzwerk mehrere Access Points
	      mit der gleichen SSID (was der Einfachheit wegen
	      häufig der Fall ist), können Sie sich dennoch
	      mit einem bestimmten Access Point verbinden.  Dazu
	      müssen Sie lediglich die BSSID des Access Points
	      angeben (die Angabe der SSID ist in diesem Fall nicht
	      erforderlich):</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="ssid <replaceable>Ihre_SSID</replaceable> bssid <replaceable>xx:xx:xx:xx:xx:xx</replaceable> DHCP"</programlisting>

	    <para>Es gibt noch weitere Möglichkeiten, den Zugriff
	      auf bestimmte Access Point zu beschränken,
	      beispielsweise durch die Begrenzung der Frequenzen, auf
	      denen eine Station nach einem Access Point sucht.  Sinnvoll
	      ist ein solches Vorgehen beispielsweise, wenn Ihr
	      drahtloses Gerät in verschiedenen Frequenzbereichen
	      arbeiten kann, da in diesem Fall das Prüfen aller
	      Frequenzen sehr zeitintensiv ist.  Um nur innerhalb eines
	      bestimmten Frequenzbereichs nach einem Access Point zu
	      suchen, verwenden Sie die Option <option>mode</option>:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="mode <replaceable>11g</replaceable> ssid <replaceable>Ihre_SSID</replaceable> DHCP"</programlisting>

	    <para>Dadurch sucht Ihr drahtloses Gerät nur im
	      2,4&nbsp;GHz-Band (802.11g), aber nicht innerhalb des
	      5&nbsp;GHz-Bandes nach einem Access Point.  Mit der
	      Option <option>channel</option> können Sie eine
	      bestimmte Frequenz vorgeben, auf der gesucht werden
	      soll.   Die Option <option>chanlist</option> erlaubt
	      die Angabe mehrerer erlaubter Frequenzen.  Eine
	      umfassende Beschreibung dieser Optionen finden Sie in
	      der Manualpage &man.ifconfig.8;.</para>
	  </sect5>

	  <sect5>
	    <title>Authentifizierung</title>

	    <para>Wenn Sie einen Access Point gefunden haben, muss
	      sich Ihrem Station am Access Point anmelden, bevor
	      Sie Daten übertragen kann.  Dazu gibt es
	      verschiedene Möglichkeiten.  Am häufigsten
	      wird nach wie vor die sogenannte <emphasis>offene
	      Authentifizierung</emphasis> verwendet.  Dabei wird
	      es jeder Station erlaubt, sich mit einem Netzwerk
	      zu verbinden und Daten zu übertragen.  Aus
	      Sicherheitsgründen sollte diese Methode allerdings
	      nur zu Testzwecken bei der erstmaligen Einrichtung
	      eines drahtlosen Netzwerks verwendet werden.  Andere
	      Authentifizierungsmechanismen erfordern den Austausch
	      kryptografischer Informationen, bevor Sie die
	      Übertragung von Daten erlauben.  Dazu gehören
	      der Austausch fixer (vorher vereinbarter) Schlüssel
	      oder Kennwörter sowie der Einsatz komplexerer
	      Verfahren mit Backend-Diensten wie RADIUS.  Die meisten
	      Netzwerke nutzen allerdings nach wie vor die offene
	      Authentifizierung, da dies die Voreinstellung ist.  Am
	      zweithäufigsten kommt das weiter unten beschriebene
	      <link linkend="network-wireless-wpa-wpa-psk">WPA-PSK</link>
	      (das auch als <foreignphrase>WPA Personal</foreignphrase>
	      bezeichnet wird) zum Einsatz.</para>

	    <note>
	      <para>Verwenden Sie eine
		&apple; &airport; Extreme-Basisstation als Access Point,
		benötigen Sie wahrscheinlich sowohl die
		Shared-Key-Authentifizierung als auch einen
		WEP-Schlüssel.  Die entsprechende Konfiguration
		erfolgt entweder in der Datei
		<filename>/etc/rc.conf</filename> oder über das
		Programm &man.wpa.supplicant.8;.  Verwenden Sie nur
		eine einzige &airport;-Basisstation, benötigen
		Sie einen Eintrag ähnlich dem folgenden:</para>

	      <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="authmode shared wepmode on weptxkey <replaceable>1</replaceable> wepkey <replaceable>01234567</replaceable> DHCP"</programlisting>


	      <para>Normalerweise sollten Sie
		Shared-Key-Authentifizierung aber nicht verwenden,
		da diese die Sicherheit des WEP-Schlüssel noch
		weiter verringert.  Müssen Sie WEP einsetzen
		(beispielsweise weil Sie zu veralteten Geräten
		kompatibel bleiben müssen),  sollten Sie WEP
		nur zusammen mit der offenen Authentifizierung
		(<literal>open</literal> authentication) verwenden.
		WEP wird im <xref linkend="network-wireless-wep"/> näher
		beschrieben.</para>
	    </note>
	  </sect5>

	  <sect5>
	    <title>Eine IP-Adresse über DHCP beziehen</title>

	    <para>Nachdem Sie einen Access Point gefunden und sich
	      authentifiziert haben, benötigen Sie noch eine
	      IP-Adresse, die Sie in der Regel über DHCP
	      zugewiesen bekommen.  Dazu müssen Sie lediglich
	      die Option <literal>DHCP</literal> in Ihre
	      in der Datei <filename>/etc/rc.conf</filename>
	      vorhandene Konfiguration Ihres drahtlosen Geräts
	      aufnehmen:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="DHCP"</programlisting>

	    <para>Nun können Sie Ihr drahtloses Gerät
	      starten:</para>

	    <screen>&prompt.root; <userinput>/etc/rc.d/netif start</userinput></screen>

	    <para>Nachdem Sie das Gerät aktiviert haben,
	      können Sie mit <command>ifconfig</command> den
	      Status des Geräts <filename>ath0</filename>
	      abfragen:</para>

	    <screen>&prompt.root; <userinput>ifconfig wlan0</userinput>
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        ether 00:11:95:d5:43:62
        inet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255
        media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
        status: associated
        ssid dlinkap channel 11 (2462 Mhz 11g) bssid 00:13:46:49:41:76
        country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
        scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
        roam:rate 5 protmode CTS wme burst</screen>


	    <para><literal>status: associated</literal> besagt, dass
	      sich Ihr Gerät mit dem drahtlosen Netzwerk verbunden
	      hat (konkret mit dem Netzwerk <literal>dlinkap</literal>).
	      <literal>bssid 00:13:46:49:41:76</literal> gibt die
	      MAC-Adresse Ihres Access Points aus und die Zeile mit
	      <literal>authmode OPEN</literal> informiert Sie darüber,
	      dass Ihre Kommunikation nicht verschlüsselt wird.</para>
	  </sect5>

	  <sect5>
	    <title>Statische IP-Adressen</title>

	    <para>Alternativ zu dynamischen IP-Adressen
	      können Sie auch eine statische IP-Adresse verwenden.
	      Dazu ersetzen Sie in Ihrer Konfiguration
	      <literal>DHCP</literal> durch die zu verwendende
	      IP-Adresse.  Beachten Sie dabei, dass Sie die anderen
	      Konfigurationsparameter nicht versehentlich
	      verändern:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="inet <replaceable>192.168.1.100</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>your_ssid_here</replaceable>"</programlisting>
	  </sect5>
	</sect4>

	<sect4 xml:id="network-wireless-wpa">
	  <title>WPA</title>

	  <para>Bei WPA (Wi-Fi Protected Access) handelt es sich um ein
	    Sicherheitsprotokoll, das in 802.11-Netzwerken verwendet
	    wird, um die Nachteile von <link linkend="network-wireless-wep">WEP</link> (fehlende
	    Authentifizierung und schwache Verschlüsselung)
	    zu vermeiden.  WPA stellt das aktuelle
	    802.1X-Authentifizierungsprotokoll dar und verwendet
	    eine von mehreren Chiffren, um die Datensicherheit
	    zu gewährleisten.  Die einzige Chiffre, die von
	    WPA verlangt wird, ist TKIP (<foreignphrase>Temporary
	    Key Integrity Protocol</foreignphrase>), eine Chiffre,
	    die die von WEP verwendete RC4-Chiffre um Funktionen
	    zur Prüfung der Datenintegrität und zur
	    Erkennung und Bekämpfung von Einbruchsversuchen
	    erweitert.
	    TKIP ist durch Softwaremodifikationen auch unter
	    veralteter Hardware lauffähig.  Im Vergleich zu
	    WEP ist WPA zwar sehr viel sicherer, es ist aber dennoch
	    nicht völlig immun gegen Angriffe.  WPA definiert
	    mit AES-CCMP noch eine weitere Chiffre als Alternative
	    zu TKIP.  AES-CCMP (das häufig als WPA2 oder RSN
	    bezeichnet wird) sollte, wenn möglich, eingesetzt
	    werden.</para>

	  <para>WPA definiert Authentifizierungs- und
	    Verschlüsselungsprotokolle.  Die Authentifizierung
	    erfolgt in der Regel über eine der folgenden
	    Techniken:  802.1X gemeinsam mit einem
	    Backend-Authentifizierungsdienst wie RADIUS, oder durch
	    einen Minimal-Handshake zwischen der Station und dem
	    Access Point mit einem vorher vereinbarten gemeinsamen
	    Schlüssel.  Die erste Technik wird als
	    <foreignphrase>WPA Enterprise</foreignphrase>, die zweite
	    hingegen als <foreignphrase>WPA Personal</foreignphrase>
	    bezeichnet.  Da sich der Aufwand für das Aufsetzen
	    eines RADIUS-Backend-Servers für die meisten
	    drahtlosen Netzwerke nicht lohnt, wird WPA in der Regel
	    als WPA-PSK (WPA, Pre-Shared-Key) konfiguriert.</para>

	  <para>Die Kontrolle der drahtlosen Verbindung sowie die
	    vorangehende Authentifizierung (über Schlüssel
	    oder durch die Kommunikation mit einem Server) erfolgt
	    über das Programm &man.wpa.supplicant.8;, das
	    über die Datei
	    <filename>/etc/wpa_supplicant.conf</filename>
	    eingerichtet wird.  Ausführliche Informationen
	    zur Konfiguration des Programms finden sich in der
	    Manualpage &man.wpa.supplicant.conf.5;.</para>

	  <sect5 xml:id="network-wireless-wpa-wpa-psk">
	    <title>WPA-PSK</title>

	    <para>WPA-PSK oder WPA-Personal basiert auf einem
	      gemeinsamen (vorher vereinbarten) Schlüssel (PSK),
	      der aus einem Passwort generiert und danach als
	      Master-Key des drahtlosen Netzwerks verwendet wird.
	      Jeder Benutzer des drahtlosen Netzwerks verwendet daher
	      <emphasis>den gleichen</emphasis> Schlüssel.  WPA-PSK
	      sollte nur in kleinen Netzwerken eingesetzt werden, in
	      denen die Konfiguration eines Authentifizierungsservers
	      nicht möglich oder erwünscht ist.</para>

	    <warning>
	      <para>Achten Sie darauf, dass Sie immer starke
		Passwörter verwenden, die ausreichend lang
		sind und, wenn möglich, auch Sonderzeichen
		enthalten, damit diese nicht leicht erraten und/oder
		umgangen werden können.</para>
	    </warning>

	    <para>Der erste Schritt zum Einsatz von WPA-PSK ist die
	      Konfiguration der SSID und des gemeinsamen Schlüssels
	      Ihres Netzwerks in der Datei
	      <filename>/etc/wpa_supplicant.conf</filename>:</para>

	    <programlisting>network={
  ssid="freebsdap"
  psk="freebsdmall"
}</programlisting>

	    <para>Danach geben Sie in <filename>/etc/rc.conf</filename>
	      an, dass WPA zur Verschlüsselung eingesetzt werden
	      soll und dass die IP-Adresse über DHCP bezogen
	      wird:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"</programlisting>

	    <para>Nun können Sie Ihr Netzgerät aktivieren:</para>

	    <screen>&prompt.root; <userinput>/etc/rc.d/netif start</userinput>
Starting wpa_supplicant.
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 5
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 6
DHCPOFFER from 192.168.0.1
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <para>Alternativ können Sie die Konfiguration von
	      <link linkend="network-wireless-wpa-wpa-psk">WPA-PSK</link>
	      auch manuell durchführen, wobei Sie wiederum die
	      Konfigurationsdatei
	      <filename>/etc/wpa_supplicant.conf</filename>
	      verwenden:</para>

	    <screen>&prompt.root; <userinput>wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</userinput>
Trying to associate with 00:11:95:c3:0d:ac (SSID='freebsdap' freq=2412 MHz)
Associated with 00:11:95:c3:0d:ac
WPA: Key negotiation completed with 00:11:95:c3:0d:ac [PTK=CCMP GTK=CCMP]
CTRL-EVENT-CONNECTED - Connection to 00:11:95:c3:0d:ac completed (auth) [id=0 id_str=]</screen>

	    <para>Im zweiten Schritt starten Sie nun
	      <command>dhclient</command>, um eine IP-Adresse vom
	      DHCP-Server zu beziehen:</para>

	    <screen>&prompt.root; <userinput>dhclient wlan0</userinput>
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 -- renewal in 300 seconds.
&prompt.root; <userinput>ifconfig wlan0</userinput>
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <note>
	      <para>Enthält Ihre <filename>/etc/rc.conf</filename>
		bereits die Zeile <literal>ifconfig_wlan0="DHCP"</literal>,
		müssen Sie <command>dhclient</command> nicht mehr
		manuell aufrufen, da <command>dhclient</command> in
		diesem Fall automatisch gestartet wird, nachdem
		<command>wpa_supplicant</command> die Schlüssel
		übergibt.</para>
	    </note>

	    <para>Sollte der Einsatz von DHCP nicht möglich sein,
	      können Sie auch eine statische IP-Adresse
	      angeben, nachdem <command>wpa_supplicant</command> Ihre
	      Station authentifiziert hat:</para>

	    <screen>&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.100 netmask 255.255.255.0</userinput>
&prompt.root; <userinput>ifconfig wlan0</userinput>
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.100 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <para>Verwenden Sie DHCP nicht, müssen Sie
	      zusätzlich noch das Standard-Gateway sowie
	      den/die Nameserver manuell festlegen:</para>

	    <screen>&prompt.root; <userinput>route add default your_default_router</userinput>
&prompt.root; <userinput>echo "nameserver your_DNS_server" &gt;&gt; /etc/resolv.conf</userinput></screen>
	  </sect5>

	  <sect5 xml:id="network-wireless-wpa-eap-tls">
	    <title>WPA und EAP-TLS</title>

	    <para>Die zweite Möglichkeit, WPA einzusetzen, ist
	      die Verwendung eines
	      802.1X-Backend-Authentifizierungsservers.  Diese
	      Variante wird als WPA-Enterprise bezeichnet, um sie
	      vom weniger sicheren WPA-Personal abzugrenzen, das
	      auf dem Austausch gemeinsamer (und vorher vereinbarter
	      Schlüssel) basiert.  Die bei WPA-Enterprise
	      verwendete Authentifizierung basiert auf EAP
	      (<foreignphrase>Extensible Authentication
	      Protocol</foreignphrase>).</para>

	    <para>EAP selbst bietet keine Verschlüsselung,
	      sondern operiert in einem verschlüsselten
	      Tunnel.  Es gibt verschiedene, auf EAP basierende
	      Authentifizierungsmethoden, darunter EAP-TLS,
	      EAP-TTLS sowie EAP-PEAP.</para>

	    <para>Bei EAP-TLS (<foreignphrase>EAP with Transport Layers
	      Security</foreignphrase>) handelt es sich um sehr gut
	      unterstütztes Authentifizierungsprotokoll, da es
	      sich dabei um die erste EAP-Methode handelt, die von
	      der <link xlink:href="http://www.wi-fi.org/">Wi-Fi
	      Alliance</link> zertifiziert wurde.  EAP-TLS
	      erfordert drei Zertifikate:  Das (auf allen Rechnern
	      installierte) CA-Zertifikat, das Server-Zertifikat
	      Ihres Authentifizierungsservers, sowie ein
	      Client-Zertifikat für jeden drahtlosen Client.
	      Sowohl der Authentifizierungsservers als auch die
	      drahtlosen Clients authentifizieren sich gegenseitig
	      durch ihre Zertifikate, wobei sie überprüfen,
	      ob diese Zertifikate auch von der
	      Zertifizierungs-Authorität (CA) des jeweiligen
	      Unternehmens signiert wurden.</para>

	    <para>Die Konfiguration erfolgt (analog zu WPA-PSK)
	      über die Datei
	      <filename>/etc/wpa_supplicant.conf</filename>:</para>

	    <programlisting>network={
  ssid="freebsdap" <co xml:id="co-tls-ssid"/>
  proto=RSN  <co xml:id="co-tls-proto"/>
  key_mgmt=WPA-EAP <co xml:id="co-tls-kmgmt"/>
  eap=TLS <co xml:id="co-tls-eap"/>
  identity="loader" <co xml:id="co-tls-id"/>
  ca_cert="/etc/certs/cacert.pem" <co xml:id="co-tls-cacert"/>
  client_cert="/etc/certs/clientcert.pem" <co xml:id="co-tls-clientcert"/>
  private_key="/etc/certs/clientkey.pem" <co xml:id="co-tls-pkey"/>
  private_key_passwd="freebsdmallclient" <co xml:id="co-tls-pwd"/>
}</programlisting>

	    <calloutlist>
	      <callout arearefs="co-tls-ssid">
		<para>Der Name des Netzwerks (die SSID).</para>
	      </callout>

	      <callout arearefs="co-tls-proto">
		<para>Das RSN/WPA2-Protokoll (&ieee; 802.11i) wird
		  verwendet.</para>
	      </callout>

	      <callout arearefs="co-tls-kmgmt">
		<para>Die <literal>key_mgmt</literal>-Zeile bezieht
		  sich auf das verwendete Key-Management-Protokoll.
		  In diesem Beispiel wird WPA gemeinsam mit der
		  EAP-Authentifizierung verwendet
		  (<literal>WPA-EAP</literal>).</para>
	      </callout>

	      <callout arearefs="co-tls-eap">
		<para>Die für die Verbindung verwendete
		  EAP-Methode.</para>
	      </callout>

	      <callout arearefs="co-tls-id">
		<para>Das <literal>identity</literal>-Feld enthält
		  den von EAP verwendeten Identifizierungsstring.</para>
	      </callout>

	      <callout arearefs="co-tls-cacert">
		<para>Das Feld <literal>ca_cert</literal> gibt den Pfad
		  zum CA-Zertifikat an.  Dieses Datei wird benötigt,
		  um das Server-Zertifikat zu verifizieren.</para>
	      </callout>

	      <callout arearefs="co-tls-clientcert">
		<para>Die <literal>client_cert</literal>-Zeile gibt den
		  Pfad zum Client-Zertifikat an.  Jeder Client hat ein
		  eigenes, innerhalb des Netzwerks eindeutiges,
		  Zertifikat.</para>
	      </callout>

	      <callout arearefs="co-tls-pkey">
		<para>Das Feld <literal>private_key</literal> gibt den
		  Pfad zum privaten Schlüssel des
		  Client-Zertifikat an.</para>
	      </callout>

	      <callout arearefs="co-tls-pwd">
		<para>Das Feld <literal>private_key_passwd</literal>
		  enthält die Passphrase für den privaten
		  Schlüssel.</para>
	      </callout>
	    </calloutlist>

	    <para>Danach fügen Sie die folgende Zeile in
	      <filename>/etc/rc.conf</filename> ein:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"</programlisting>

	    <para>Nun können Sie Ihr drahtloses Gerät
	      über das <filename>rc.d</filename>-System
	      aktivieren:</para>

	    <screen>&prompt.root; <userinput>/etc/rc.d/netif start</userinput>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <para>Alternativ können Sie Ihr drahtloses Gerält
	      wiederum manuell über
	      <command>wpa_supplicant</command> und
	      <command>ifconfig</command> aktivieren.</para>
	  </sect5>

	  <sect5 xml:id="network-wireless-wpa-eap-ttls">
	    <title>WPA und EAP-TTLS</title>

	    <para>Bei EAP-TLS müssen sowohl der
	      Authentifizierungsserver als auch die Clients jeweils
	      ein eigenes Zertifikat aufweisen.  Setzen Sie hingegen
	      EAP-TTLS (<foreignphrase>EAP-Tunneled
	      Transport Layer Security</foreignphrase>) ein, ist das
	      Client-Zertifikat optional.  EAP-TTLS geht dabei
	      ähnlich vor wie verschlüsselte Webseiten,
	      bei denen der Webserver einen sicheren SSL-Tunnel
	      erzeugen kann, ohne dass der Besucher dabei über
	      ein client-seitiges Zertifikat verfügen muss.
	      EAP-TTLS verwendet einen verschlüsselten
	      TLS-Tunnel zum sicheren Transport der
	      Authentifizierungsdaten.</para>

	    <para>Die Konfiguration von EAP-TTLS erfolgt in der
	      Datei <filename>/etc/wpa_supplicant.conf</filename>:</para>

	    <programlisting>network={
  ssid="freebsdap"
  proto=RSN
  key_mgmt=WPA-EAP
  eap=TTLS <co xml:id="co-ttls-eap"/>
  identity="test" <co xml:id="co-ttls-id"/>
  password="test" <co xml:id="co-ttls-passwd"/>
  ca_cert="/etc/certs/cacert.pem" <co xml:id="co-ttls-cacert"/>
  phase2="auth=MD5" <co xml:id="co-ttls-pha2"/>
}</programlisting>

	    <calloutlist>
	      <callout arearefs="co-ttls-eap">
		<para>Die für die Verbindung verwendete
		  EAP-Methode.</para>
	      </callout>

	      <callout arearefs="co-ttls-id">
		<para>Das <literal>identity</literal>-Feld enthält
		  den Identifizierungsstring für die
		  EAP-Authentifizierung innerhalb des
		  verschlüsselten TlS-Tunnels.</para>
	      </callout>

	      <callout arearefs="co-ttls-passwd">
		<para>Das <literal>password</literal>-Feld enthält
		  die Passphrase für die
		  EAP-Authentifizierung.</para>
	      </callout>

	      <callout arearefs="co-ttls-cacert">
		<para>Das Feld <literal>ca_cert</literal> gibt den
		  Pfad zum CA-Zertifikat an, das benötigt wird,
		  um das Server-Zertifikat zu verifizieren.</para>
	      </callout>

	      <callout arearefs="co-ttls-pha2">
		<para>Die innerhalb des verschlüsselten TLS-Tunnels
		  verwendete Authentifizierungsmethode.  In unserem
		  Beispiel handelt es sich dabei um EAP und MD5.  Diese
		  Phase der <quote>inneren Authentifizierung</quote> wird
		  oft als <quote>phase2</quote> bezeichnet.</para>
	      </callout>
	    </calloutlist>

	    <para>Folgende Zeilen müssen zusätzlich in die Datei
	      <filename>/etc/rc.conf</filename> aufgenommen werden:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"</programlisting>

	    <para>Nun können Sie Ihr drahtloses Gerät
	      aktivieren:</para>

	    <screen>&prompt.root; <userinput>/etc/rc.d/netif start</userinput>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>
	  </sect5>

	  <sect5 xml:id="network-wireless-wpa-eap-peap">
	    <title>WPA und EAP-PEAP</title>

	    <para>PEAP (<foreignphrase>Protected EAP</foreignphrase>)
	      wurde als Alternative zu EAP-TTLS entwickelt.  Es gibt
	      zwei verschiedene PEAP-Methoden, wobei es sich bei
	      PEAPv0/EAP-MSCHAPv2 um die häufiger verwendete
	      Methode handelt.  In den folgenden Ausführungen
	      wird der Begriff PEAP synonym für diese
	      EAP-Methode verwendet.  PEAP ist nach EAP-TLS der
	      am häufigsten verwendete und am besten
	      unterstützte EAP-Standard.</para>

	    <para>PEAP arbeitet ähnlich wie EAP-TTLS:  Es
	      verwendet ein server-seitiges Zertifikat, um
	      einen verschlüsselten TLS-Tunnel zu erzeugen,
	      über den die sichere Authentifizierung zwischen
	      den Clients und dem Authentifizierungsserver erfolgt.
	      In Sachen Sicherheit unterscheiden sich EAP-TTLS und
	      PEAP allerdings:  PEAP überträgt den
	      Benutzernamen im Klartext und verschlüsselt nur
	      das Passwort, während EAP-TTLS sowohl den
	      Benutzernamen als auch das Passwort über den
	      TLS-Tunnel überträgt.</para>

	    <para>Um EAP-PEAP einzurichten, müssen Sie die
	      Konfigurationsdatei
	      <filename>/etc/wpa_supplicant.conf</filename>
	      anpassen:</para>

	    <programlisting>network={
  ssid="freebsdap"
  proto=RSN
  key_mgmt=WPA-EAP
  eap=PEAP <co xml:id="co-peap-eap"/>
  identity="test" <co xml:id="co-peap-id"/>
  password="test" <co xml:id="co-peap-passwd"/>
  ca_cert="/etc/certs/cacert.pem" <co xml:id="co-peap-cacert"/>
  phase1="peaplabel=0" <co xml:id="co-peap-pha1"/>
  phase2="auth=MSCHAPV2" <co xml:id="co-peap-pha2"/>
}</programlisting>

	    <calloutlist>
	      <callout arearefs="co-peap-eap">
		<para>Die für die Verbindung verwendete
		  EAP-Methode.</para>
	      </callout>

	      <callout arearefs="co-peap-id">
		<para>Das <literal>identity</literal>-Feld enthält
		  den Identifizierungsstring für die innerhalb
		  des verschlüsselten TLS-Tunnels erfolgende
		  EAP-Authentifizierung.</para>
	      </callout>

	      <callout arearefs="co-peap-passwd">
		<para>Das Feld <literal>password</literal> enthält
		  die Passphrase für die EAP-Authentifizierung.</para>
	      </callout>

	      <callout arearefs="co-peap-cacert">
		<para>Das Feld <literal>ca_cert</literal> gibt den Pfad
		  zum CA-Zertifikat an, das zur Verifizierung des
		  Server-Zertifikats benötigt wird.</para>
	      </callout>

	      <callout arearefs="co-peap-pha1">
		<para>Dieses Feld enthält die Parameter für
		  die erste Phase der Authentifizierung (also den
		  TLS-Tunnel).  Je nach dem, welchen
		  Authentifizierungsserver Sie verwenden, müssen
		  Sie hier einen unterschiedlichen Wert angeben.
		  In den meisten Fällen wird dieses Feld den
		  Wert <quote>client EAP encryption</quote> aufweisen,
		  der durch die Angabe von
		  <literal>peaplabel=0</literal> gesetzt wird.  Weitere
		  Informationen zur Konfiguration von PEAP finden Sie
		  in der Manualpage &man.wpa.supplicant.conf.5;.</para>
	      </callout>

	      <callout arearefs="co-peap-pha2">
		<para>Das innerhalb des verschlüsselten TLS-Tunnels
		  verwendete Authentifizierungsprotokoll.  In unserem
		  Beispiel handelt es sich dabei um
		  <literal>auth=MSCHAPV2</literal>.</para>
	      </callout>
	    </calloutlist>

	    <para>Danach fügen Sie die folgende Zeile in
	      <filename>/etc/rc.conf</filename> ein:</para>

	    <programlisting>ifconfig_ath0="WPA DHCP"</programlisting>

	    <para>Zuletzt müssen Sie die Netzwerkkarte noch
	      aktivieren:</para>

	    <screen>&prompt.root; <userinput>/etc/rc.d/netif start</userinput>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>
	  </sect5>
	</sect4>

	<sect4 xml:id="network-wireless-wep">
	  <title>WEP</title>

	  <para>WEP (Wired Equivalent Privacy) ist Teil des
	    ursprünglichen 802.11-Standards.  Es enthält
	    keinen Authentifzierungsmechanismus und verfügt
	    lediglich über eine schwache Zugriffskontrolle,
	    die sehr leicht umgangen werden kann.</para>

	  <para>WEP kann über <command>ifconfig</command>
	    aktiviert werden:</para>

	  <screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0</userinput>
&prompt.root; <userinput>ifconfig wlan0 inet 192.168.1.100 netmask 255.255.255.0 \
	    ssid my_net wepmode on weptxkey 3 wepkey 3:0x3456789012</userinput></screen>

	  <itemizedlist>
	    <listitem>
	      <para> Mit <literal>weptxkey</literal> geben Sie an,
		welcher WEP-Schlüssel für für die
		Datenübertragung verwendet wird (in unserem
		Beispiel ist dies der dritte Schlüssel).  Der
		gleiche Schlüssel muss auch am Access Point
		eingestellt sein.  Kennen Sie den vom Access Point
		verwendeten Schlüssel nciht, sollten Sie zuerst
		den Wert <literal>1</literal> (d.h. den ersten
		Schlüssel) für diese Variable verwenden.</para>
	    </listitem>

	    <listitem>
	      <para>Mit <literal>wepkey</literal> legen Sie den zu
		verwendenden WEP-Schlüssel in der Form
		<replaceable>Nummer:Schlüssel</replaceable> fest.
		Ist der Schlüssel "Nummer" nicht vorhanden, wird
		automatisch Schlüssel <literal>1</literal>
		verwendet.  Die Angabe von "Nummer" ist zwingend
		nötig, wenn Sie einen anderen als den ersten
		Schlüssel verwenden wollen.</para>

	      <note>
		<para>In Ihrer Konfiguration müssen Sie
		  <literal>0x3456789012</literal> durch den an
		  Ihrem Access Point konfigurierten Schlüssel
		  ersetzen.</para>
	      </note>
	    </listitem>
	  </itemizedlist>

	  <para>Weitere Informationen finden Sie in der Manualpage
	    &man.ifconfig.8;.</para>

	  <para>Das Programm <command>wpa_supplicant</command>
	    eignet sich ebenfalls dazu, WEP für Ihr drahtloses
	    Gerät zu aktivieren.  Obige Konfiguration lässt
	    sich dabei durch die Aufnahme der folgenden Zeilen in die
	    Datei <filename>/etc/wpa_supplicant.conf</filename>
	    realisieren:</para>

	  <programlisting>network={
  ssid="my_net"
  key_mgmt=NONE
  wep_key3=3456789012
  wep_tx_keyidx=3
}</programlisting>

	  <para>Danach müssen Sie das Programm noch aufrufen:</para>

	  <screen>&prompt.root; <userinput>wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</userinput>
Trying to associate with 00:13:46:49:41:76 (SSID='dlinkap' freq=2437 MHz)
Associated with 00:13:46:49:41:76</screen>
	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Ad-hoc-Modus</title>

      <para>Der IBSS-Modus (auch als Ad-hoc-Modus bezeichnet), ist
	für Punkt-zu-Punkt-Verbindungen vorgesehen.  Um
	beispielsweise eine Ad-hoc-Verbindung zwischen den Rechnern
	<systemitem>A</systemitem> und <systemitem>B</systemitem> aufzubauen,
	benötigen Sie lediglich zwei IP-Adressen und eine
	SSID.</para>

      <para>Auf dem Rechner <systemitem>A</systemitem> geben Sie Folgendes
	ein:</para>

      <screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0 wlanmode adhoc</userinput>
&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap</userinput>
&prompt.root; <userinput>ifconfig wlan0</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:c3:0d:ac
      inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
      status: running
      ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
      protmode CTS wme burst</screen>

      <para>Der <literal>adhoc</literal>-Parameter gibt an, dass die
	Schnittstelle im IBSS-Modus läuft.</para>

      <para>Rechner <systemitem>B</systemitem> sollte nun in der Lage sein,
	Rechner <systemitem>A</systemitem> zu finden:</para>

      <screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0 wlanmode adhoc</userinput>
&prompt.root; <userinput>ifconfig wlan0 up scan</userinput>
  SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
  freebsdap       02:11:95:c3:0d:ac    2   54M -64:-96  100 IS   WME</screen>

      <para>Der Wert <literal>I</literal> (Spalte CAPS) gibt an,
	dass sich Rechner <systemitem>A</systemitem> im Ad-hoc-Modus befindet.
	Nun müssen Sie nur noch Rechner <systemitem>B</systemitem> eine
	unterschiedliche IP-Adresse zuweisen:</para>

      <screen>&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</userinput>
&prompt.root; <userinput>ifconfig wlan0</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
      status: running
      ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
      protmode CTS wme burst</screen>

      <para>Damit sind die Rechner <systemitem>A</systemitem> und
	<systemitem>B</systemitem> bereit und können untereinander
	Daten austauschen.</para>
    </sect2>

    <sect2 xml:id="network-wireless-ap">
      <title>&os; Host Access Points</title>

      <para>&os; kann als Access Point (AP) agieren. Dies verhindert,
        dass man sich einen Hardware AP kaufen oder ein ad-hoc
        Netzwerk laufen lassen muss.  Dies kann sinnvoll sein,
        falls Ihre &os;-Computer als Gateway zu einem anderen
        Netzwerk (z.B. Internet) fungiert.</para>

      <sect3 xml:id="network-wireless-ap-basic">
        <title>Grundeinstellungen</title>

        <para>Bevor Sie ihren &os;-Computer als einen AP konfigurieren,
          muss der Kernel mit dem für ihre Wireless-Karte
          entsprechenden Treibern konfiguriert werden.  Sie
          müssen ebenfalls die Sicherheitsprotokolle, die Sie
          nutzen wollen, dem Kernel hinzufügen.  Für
          weitere Informationen siehe:
          <xref linkend="network-wireless-basic"/>.</para>

        <note>
          <para>Die Verwendung der NDIS und &windows; Treiber erlauben
            zur Zeit keinen AP-Modus. Nur die nativen
            &os;-Wireless-Treiber unterstüten den AP Modus.</para>
        </note>

        <para>Nachdem die Unterstützung für ihr drahtloses
          Netzwerk geladen ist, können Sie überprüfen, ob
          Ihr Wireless-Gerät den hostbasierenden Access-Point Modus
          (auch bekannt als hostap Modus) unterstützt:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0</userinput>
&prompt.root; <userinput>ifconfig wlan0 list caps</userinput>
drivercaps=6f85edc1&lt;STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG&gt;
cryptocaps=1f&lt;WEP,TKIP,AES,AES_CCM,TKIPMIC&gt;</screen>

	<para>Diese Ausgabe zeigt die Möglichkeiten der Karte. Das
	  Wort <literal>HOSTAP</literal> bestätigt, dass diese
	  Wireless-Karte als Access Point agieren kann.  Die
	  verschiedenen unterstützten Algorithmen
	  (z.B. WEP, TKIP, AES usw.) werden ebenfalls angezeigt.
	  Diese Informationen sind wichtig, wenn Sie wissen wollen,
	  welche Sicherheitsprotokolle auf diesem Access Point
	  verwendbar sind.</para>

	<para>Das Wireless-Gerät kann nur während der Erzeugung
	  des Pseudo-Geräts in den hostap-Modus gesetzt werden.
	  Zuvor erstellte Pseudo-Geräte müssen also vorher
	  zerstört werden:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 destroy</userinput></screen>

	<para>Danach muss das Gerät erneut erstellt werden, bevor
	  die restlichen Netzwerkparameter konfiguriert werden
	  können:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0 wlanmode hostap</userinput>
&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1</userinput></screen>

	<para>Benutzen Sie danach erneut den Befehl
	  <command>ifconfig</command>, um den Status der
	  <filename>wlan0</filename>-Schnittstelle abzufragen:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:c3:0d:ac
      inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
      status: running
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
      protmode CTS wme burst dtimperiod 1 -dfs</screen>

	<para>Die <literal>hostap</literal>-Parameter geben die
	  Schnittstelle an, die im hostbasierenden Access Point Modus
	  läuft.</para>

	<para>Die Konfiguration der Schnittstelle kann durch
	  Hinzufügen der folgenden Zeilen in die Datei
	  <filename>/etc/rc.conf</filename> automatisch während
	  des Bootvorganges erfolgen:</para>

	<programlisting>wlans_ath0="wlan0"
create_args_wlan0="wlanmode hostap"
ifconfig_wlan0="inet <replaceable>192.168.0.1</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>freebsdap</replaceable> mode 11g channel <replaceable>1</replaceable>"</programlisting>
      </sect3>

      <sect3>
	<title>Hostbasierender Access Point ohne Authentifizierung
	  oder Verschlüsselung</title>

	<para>Obwohl es nicht empfohlen wird, einen AP ohne jegliche
	  Authentifizierung oder Verschlüsselung laufen zu lassen,
	  ist es eine einfache Art zu testen, ob der AP funktioniert.
	  Diese Konfiguration ist auch wichtig für die Fehlersuche
	  bei Client-Problemen.</para>

	<para>Nachdem Sie den AP, wie oben beschrieben, konfiguriert
	  haben, ist es möglich von einem anderen drahtlosen
	  Computer eine Suche nach dem AP zu starten:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0</userinput>
&prompt.root; <userinput>ifconfig wlan0 up scan</userinput>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M -66:-96  100 ES   WME</screen>

	<para>Der Client-Rechner fand den Access Point und kann mit ihm
	  verbunden werden:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</userinput>
&prompt.root; <userinput>ifconfig wlan0</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
      scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
      roam:rate 5 protmode CTS wme burst</screen>
      </sect3>

      <sect3>
	<title>WPA-basierender Host-Access Point</title>

	<para>Dieser Abschnitt beschäftigt sich mit dem Konfigurieren
	  eines &os;-Access-Points mit dem WPA-Sicherheitsprotokoll.
	  Weitere Einzelheiten zu WPA und der Konfiguration von Clients mit
	  WPA finden Sie im
	  <xref linkend="network-wireless-wpa"/>.</para>

	<para>Der <application>hostapd</application>-Dienst wird genutzt,
	  um die Client-Authentifizierung und das Schlüsselmanagement
	  auf dem Access Point mit aktiviertem WPA zu nutzen.</para>

	<para>In den folgenden Abschnitten werden allen Konfigurationen
	  auf dem &os;-Computer ausgeführt, der als AP agiert.
	  Nachdem der AP korrekt arbeitet, sollte
	  <application>hostapd</application> automatisch beim Booten
	  durch folgende Zeile in der <filename>/etc/rc.conf</filename>
	  aktiviert werden:</para>

	<programlisting>hostapd_enable="YES"</programlisting>

	<para>Bevor Sie versuchen <application>hostapd</application>
	  zu konfigurieren, stellen Sie sicher, dass die
	  Grundeinstellungen, wie in
	  <xref linkend="network-wireless-ap-basic"/> beschrieben,
	  ausgeführt wurden.</para>

	<sect4>
	  <title>WPA-PSK</title>

	  <para>WPA-PSK ist für kleine Netzwerke gedacht, in denen die
	    Verwendung eines Authentifizierungs-Backend-Server nicht
	    möglich oder erwünscht ist.</para>

	  <para>Die Konfiguration wird in
	    <filename>/etc/hostapd.conf</filename>
	    durchgeführt:</para>

	  <programlisting>interface=wlan0 <co xml:id="co-ap-wpapsk-iface"/>
debug=1 <co xml:id="co-ap-wpapsk-dbug"/>
ctrl_interface=/var/run/hostapd <co xml:id="co-ap-wpapsk-ciface"/>
ctrl_interface_group=wheel <co xml:id="co-ap-wpapsk-cifacegrp"/>
ssid=freebsdap <co xml:id="co-ap-wpapsk-ssid"/>
wpa=1 <co xml:id="co-ap-wpapsk-wpa"/>
wpa_passphrase=freebsdmall <co xml:id="co-ap-wpapsk-pass"/>
wpa_key_mgmt=WPA-PSK <co xml:id="co-ap-wpapsk-kmgmt"/>
wpa_pairwise=CCMP TKIP <co xml:id="co-ap-wpapsk-pwise"/></programlisting>

	  <calloutlist>
	    <callout arearefs="co-ap-wpapsk-iface">
	      <para>Dieses Feld zeigt die Wireless-Schnittstelle an, die
	        für den Access Point verwendet wird an.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-dbug">
	      <para>Dieses Feld legt den debuglevel von
	        <application>hostapd</application> während der
	        Ausführung fest.  Ein Wert von <literal>1</literal>
	        ist der kleinste zulässige Wert.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-ciface">
	      <para>Das <literal>ctrl_interface</literal>-Feld gibt
	        den Pfadnamen des Verzeichnisses an, der von
	        <application>hostapd</application> dazu genutzt wird,
	        um die domain socket Dateien zu speichern, die für
	        die Kommunikation mit externen Programmen,
	        wie z.B. &man.hostapd.cli.8;, benutzt werden.
	        Hier wurden die Standardwerte benutzt.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-cifacegrp">
	      <para>Die Zeile <literal>ctrl_interface_group</literal>
	        legt fest, welche Gruppe (hier ist es die
	        <systemitem class="groupname">wheel</systemitem>-Gruppe) die Erlaubnis hat,
	        die Schnittstellendateien zu kontrollieren.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-ssid">
	      <para>Dieses Feld setzt den Netzwerknamen.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-wpa">
	      <para>Das <literal>wpa</literal>-Feld aktiviert WPA und
	        gibt an welches WPA-Authentifizierungprotokoll
	        benötigt wird.  Ein Wert von <literal>1</literal>
	        konfiguriert den AP mit WPA-PSK.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-pass">
	      <para>Das <literal>wpa_passphrase</literal>-Feld
	        beinhaltet das ASCII-Passwort für die
	        WPA-Authentifikation.</para>

	      <warning>

	        <para>Verwenden Sie immer sichere Passwörter,
	          die ausreichend lang sind und aus vielen
	          unterschiedlichen Zeichen bestehen, damit sie nicht
	          erraten werden oder umgangen werden können.</para>
	      </warning>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-kmgmt">

	      <para>Die <literal>wpa_key_mgmt</literal> Zeile bestimmt
	        das Schlüsselmanagement-Protokoll, das benutzt wird.
	        In unserem Fall ist es WPA-PSK.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-pwise">
	      <para>Das <literal>wpa_pairwise</literal> Feld zeigt die
	        zulässigen Verschlüsselungs-Algorithmen
	        des Access Points.  Hier werden beide, TKIP (WPA) und
	        CCMP (WPA2), akzeptiert.  CCMP-Verschlüsselung ist
	        eine Alternative zu TKIP und sollte wenn möglich
	        eingesetzt werden.  TKIP sollte nur da eingesetzt werden,
	        wo kein CCMP möglich ist.</para>
	    </callout>
	  </calloutlist>

	  <para>Als nächstes wird der
	    <application>hostapd</application> gestartet:</para>

	  <screen>&prompt.root; <userinput>/etc/rc.d/hostapd forcestart</userinput></screen>

	<screen>&prompt.root; <userinput>ifconfig wlan0</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 2290
      inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
      inet6 fe80::211:95ff:fec3:dac%ath0 prefixlen 64 scopeid 0x4
      ether 00:11:95:c3:0d:ac
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
      status: associated
      ssid freebsdap channel 1 bssid 00:11:95:c3:0d:ac
      authmode WPA2/802.11i privacy MIXED deftxkey 2 TKIP 2:128-bit txpowmax 36 protmode CTS dtimperiod 1 bintval 100</screen>

 	  <para>Der Access Point läft nun, die Clients
 	    können mit ihm verbunden werden.  Weitere
 	    Informationen finden Sie im
 	    <xref linkend="network-wireless-wpa"/>.  Es ist möglich
 	    zu sehen, welche Stationen mit dem AP verbunden sind.
 	    Dazu geben Sie den Befehl
 	    <command>ifconfig wlan0 list sta</command>
 	    ein.</para>
 	</sect4>
      </sect3>

      <sect3>
 	<title>WEP hostbasierender Access Point</title>

 	  <para>Es ist nicht empfehlenswert, einen Access Point mit
 	    WEP zu konfigurieren, da es keine
 	    Authentifikationsmechanismen gibt und WEP leicht zu
 	    knacken ist.  Einige ältere WLAN-Karten
 	    unterstützen nur WEP als Sicherheitsprotokoll.  Für
 	    solche Karten ist es notwendig den AP ohne
 	    Authentifikation, Verschlüsselung oder mit dem
 	    WEP-Protokoll zu konfigurieren.</para>

 	  <para>Das Wireless-Gerät kann nun in den hostap-Modus
 	    versetzt werden und mit der korrekten SSID und IP-Adresse
 	    konfiguriert werden:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0 wlanmode hostap</userinput>
&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 \
      ssid freebsdap wepmode on weptxkey 3 wepkey 3:0x3456789012 mode 11g</userinput></screen>

	  <itemizedlist>
	    <listitem>
	      <para>Der <literal>weptxkey</literal> gibt an,
	        welcher WEP-Schlüssel bei der Übertragung
	        benutzt wird.  Hier nutzen wir den 3. Schlüssel
	        (die Nummerierung der Schlüssel beginnt bei
	        <literal>1</literal>).  Dieses Parameter muss angegeben
	        sein, damit die Daten wirklich verschlüsselt
	        werden.</para>
	    </listitem>

	    <listitem>
	      <para>Der <literal>wepkey</literal> gibt den
	        gewählten WEP-Schlüssel an.  Er sollte im
	        folgenden Format <replaceable>index:key</replaceable>
	        vorliegen.  Wenn kein Index vorhanden ist, wird der
	        Schlüssel <literal>1</literal> benutzt.  Das bedeutet
	        wir brauchen einen Index, falls wir einen anderen
	        Schlüssel als den ersten nutzen wollen.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Benutzen Sie den Befehl <command>ifconfig</command>
	    noch einmal um den Status der
	    <filename>wlan0</filename>-Schnittstelle zu sehen:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:c3:0d:ac
      inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
      status: running
      ssid freebsdap channel 4 (2427 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy ON deftxkey 3 wepkey 3:40-bit
      txpower 21.5 scanvalid 60 protmode CTS wme burst dtimperiod 1 -dfs</screen>

	  <para>Es ist möglich, von einem anderen drahtlosen
	    Computer eine Suche nach dem AP zu starten:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0</userinput>
&prompt.root; <userinput>ifconfig wlan0 up scan</userinput>
SSID            BSSID              CHAN RATE  S:N   INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M 22:1   100 EPS</screen>

	  <para>Der Client-Rechner fand den Access Point und kann
	    mit den korrekten Parametern (Schlüssel usw.)
	    mit ihm verbunden werden.  Weitere Informationen gibt es in
	    folgendem <xref linkend="network-wireless-wep"/></para>
      </sect3>
    </sect2>

    <sect2>
      <title>Benutzung von drahtgebundenen und drahtlosen
	Verbindungen</title>

      <para>Eine Verbindung per Kabel bietet eine bessere Leistung
        und eine höhere Zuverlässigkeit, während die
        Wireless-Verbindung eine höhere Flexibilität
        und Mobilität bietet.  Benutzer von Laptops wollen
        normalerweise beides nutzen und zwischen beiden hin und her
        schalten.</para>

      <para>Unter &os; ist es möglich zwei oder mehr
        Netzwerkschnittstellen in einem <quote>failover</quote>-Mode zu
        kombinieren, so dass automatisch die beste verfügbare Verbindung
        aus der Gruppe ausgewählt wird, sobald der Linkstatus
        wechselt.</para>

      <para>Wir behandeln Link-Aggregation und Failover in dem Kapitel
        <xref linkend="network-aggregation"/>.  Dort gibt es auch ein
        Beispiel (<xref linkend="networking-lagg-wired-and-wireless"/>)
        für die Verwendung von sowohl kabelgebundenen wie
        auch drahtlosen Verbindungen.</para>
    </sect2>

    <sect2>
      <title>Problembehandlung</title>

      <para>Die folgenden Auflistung zeigt, wie Sie einige
	häufig auftretende Probleme bei der Einrichtung
	Ihres drahtlosen Netzwerks beheben können.</para>

      <itemizedlist>
	<listitem>
	  <para>Wird Ihr Access Point bei der Suche nicht gefunden,
	    sollten Sie überprüfen, ob Sie bei Konfiguration
	    Ihres drahtlosen Geräts die Anzahl der Kanäle
	    beschränkt haben.</para>
	</listitem>

	<listitem>
	  <para>Wenn Sie sich nicht mit Ihrem Access Point verbinden
	    können, sollten Sie überprüfen, ob die
	    Konfiguration Ihrer Station auch der des Access Points
	    entspricht.  Achten Sie dabei speziell auf die
	    Authentifzierungsmethode und die Sicherheitsprotokolle.
	    Halten Sie Ihre Konfiguration so einfach wie möglich.
	    Verwenden Sie ein Sicherheitsprotokoll wie WPA oder WEP,
	    sollten Sie testweise Ihren Access Point auf
	    <emphasis>offene Authentifizierung</emphasis> und
	    <emphasis>keine Sicherheit</emphasis> einstellen.
	    Danach versuchen Sie sich erneut mit Ihren Access Point
	    zu verbinden.</para>
	</listitem>

	<listitem>
	  <para>Nachdem Sie sich mit dem Access Point verbinden
	    können, prüfen Sie die Sicherheitseinstellungen,
	    beginnend mit einfachen Werkzeugen wie &man.ping.8;.</para>

	  <para>Das Programm <command>wpa_supplicant</command>
	    kann Ihnen bei der Fehlersuche helfen.  Dazu starten
	    Sie es manuell mit der Option <option>-dd</option> und
	    durchsuchen anschließend die Protokollinformationen
	    nach eventuellen Fehlermeldungen.</para>
	</listitem>

	<listitem>
	  <para>Zusätzlich gibt es auch zahlreiche
	    Low-Level-Debugging-Werkzeuge.  Die Ausgabe von
	    Debugging-Informationen des 802.11 Protocol Support Layers
	    lassen sich mit dem Programm <command>wlandebug</command>
	    (das sich unter
	    <filename>/usr/src/tools/tools/net80211</filename>
	    befindet) aktivieren.  Um beispielsweise während
	    der Suche nach Access Points und des Aufbaus von
	    802.11-Verbindungen
	    (<foreignphrase>Handshake</foreignphrase>) auftretende
	    Systemmeldungen auf die Konsole auszugeben, verwenden
	    Sie den folgenden Befehl:</para>

	  <screen>&prompt.root; <userinput>wlandebug -i ath0 +scan+auth+debug+assoc</userinput>
  net.wlan.0.debug: 0 =&gt; 0xc80000&lt;assoc,auth,scan&gt;</screen>

	  <para>Der 802.11-Layer liefert umfangreiche Statistiken,
	    die Sie mit dem Werkzeug <command>wlanstats</command>
	    abrufen können.  Diese Statistiken sollten alle
	    Fehler identifizieren, die im 802.11-Layer auftreten.
	    Beachten Sie aber, dass einige Fehler bereits im
	    darunterliegenden Gerätetreiber auftreten und
	    daher in diesen Statistiken nicht enthalten sind.  Wie
	    Sie Probleme des Gerätetreibers identifizieren,
	    entnehmen Sie bitte der Dokumentation Ihres
	    Gerätetreibers.</para>
	</listitem>
      </itemizedlist>

      <para>Können Sie Ihr Problem durch diese
	Maßnahmen nicht lösen, sollten Sie einen
	Problembericht (PR) erstellen und die Ausgabe der weiter
	oben genannten Werkzeuge in den Bericht aufnehmen.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="network-bluetooth">
    <info><title>Bluetooth</title>
      <authorgroup>
        <author><personname><firstname>Pav</firstname><surname>Lucistnik</surname></personname><contrib>Beigetragen von </contrib><affiliation>
            <address><email>pav@FreeBSD.org</email></address>
          </affiliation></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>Bluetooth</primary></indexterm>

    <sect2>
      <title>Übersicht</title>

      <para>Bluetooth ermöglicht die Bildung von persönlichen
	Netzwerken über drahtlose Verbindungen bei einer maximalen
	Reichweite von 10 Metern und operiert im unlizensierten
	2,4-GHz-Band.  Solche Netzwerke werden normalerweise spontan
	gebildet, wenn sich mobile Geräte, wie Mobiltelefone,
	Handhelds oder Notebooks miteinander verbinden.  Im Gegensatz zu
	Wireless LAN ermöglicht Bluetooth auch höherwertige
	Dienste, wie FTP-ähnliche Dateiserver, Filepushing,
	Sprachübertragung, Emulation von seriellen Verbindungen
	und andere mehr.</para>

      <para>Der Bluetooth-Stack von &os; verwendet das
	Netgraph-Framework (&man.netgraph.4;).  Viele
	Bluetooth-USB-Adapter werden durch den &man.ng.ubt.4;-Treiber
	unterstützt.  Auf dem Chip BCM2033
	von Broadcom basierende	Bluetooth-Geräte werden von den
	Treibern &man.ubtbcmfw.4; sowie &man.ng.ubt.4; unterstützt.
	Die Bluetooth-PC-Card 3CRWB60-A von 3Com verwendet den
	&man.ng.bt3c.4;-Treiber.  Serielle sowie auf UART basierende
	Bluetooth-Geräte werden von &man.sio.4;, &man.ng.h4.4;
	sowie &man.hcseriald.8;	unterstützt.  Dieses Kapitel
	beschreibt die Verwendung von USB-Bluetooth-Adaptern.</para>
    </sect2>

    <sect2>
      <title>Die Bluetooth-Unterstützung aktivieren</title>

      <para>Bluetooth-Unterstützung ist in der Regel als
	Kernelmodul verfügbar.  Damit ein Gerät funktioniert,
	muss der entsprechende Treiber im Kernel geladen werden:</para>

      <screen>&prompt.root; <userinput>kldload ng_ubt</userinput></screen>

      <para>Ist das Bluetooth-Gerät beim Systemstart angeschlossen,
        kann das entsprechende Modul auch von
        <filename>/boot/loader.conf</filename> geladen werden:</para>

      <programlisting>ng_ubt_load="YES"</programlisting>

      <para>Schließen Sie Ihren USB-Adapter an, sollte eine
	Meldung ähnlich der folgenden auf der Konsole (oder in
	syslog) erscheinen:</para>

      <screen>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2
ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,
      wMaxPacketSize=49, nframes=6, buffer size=294</screen>

      <para>Zum Starten und Beenden des Bluetooth-Stacks verwenden Sie
	das Skript <filename>/etc/rc.d/bluetooth</filename>.  Es ist
	empfehlenswert, den Bluetooth-Stack zu beenden, bevor Sie den
	Adapter entfernen.  Selbst wenn Sie dies nicht tun, kommt es
	(normalerweise) zu keinem fatalen Fehler.  Wenn Sie den
	Bluetooth-Stack starten, erhalten Sie eine Meldung ähnlich
	der folgenden:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/bluetooth start ubt0</userinput>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO link&gt;
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</screen>

    </sect2>

    <sect2>
      <title>Das Host Controller Interface (HCI)</title>

      <indexterm><primary>HCI</primary></indexterm>

      <para>Das <foreignphrase>Host Controller Interface</foreignphrase>
	(HCI) bietet eine Befehlsschnittstelle zum Basisbandcontroller
	und Linkmanager, sowie Zugriff auf den Hardwarestatus und die
	Kontrollregister.  Dadurch wird ein einheitlicher Zugriff auf
	die Fähigkeiten des Bluetooth-Basisbands möglich.  Die
	HCI-Layer des Rechners tauschen Daten und Befehle mit der
	HCI-Firmware der Bluetooth-Geräte aus.  Über den
	Host Controller Transport Layer-Treiber (also den physikalischen
	Bus) können beide HCI-Layer miteinander
	kommunizieren.</para>

      <para>Eine einzelne Netgraph-Gerätedatei vom Typ
	<emphasis>hci</emphasis> wird für ein einzelnes
	Bluetooth-Gerät erzeugt.  Die HCI-Gerätedatei ist
	normalerweise mit der Bluetooth-Gerätetreiberdatei
	(downstream) sowie der L2CAP-Gerätedatei (upstream)
	verbunden.  Alle HCI-Operationen müssen über die
	HCI-Gerätedatei und nicht über die Treiberdatei
	erfolgen.  Der Standardname für die HCI-Gerätedatei
	(die in &man.ng.hci.4; beschrieben wird) lautet
	<quote>devicehci</quote>.</para>

      <para>Eine der wichtigsten Aufgaben ist das Auffinden von sich
	in Reichweite befindenden Bluetooth-Geräten.  Diese
	Funktion wird als <emphasis>inquiry</emphasis> bezeichnet.
	Inquiry sowie andere mit HCI in Verbindung stehende Funktionen
	werden von &man.hccontrol.8; zur Verfügung gestellt.  Das
	folgende Beispiel zeigt, wie man herausfindet, welche
	Bluetooth-Geräte sich in Reichweite befinden.  Eine solche
	Abfrage dauert nur wenige Sekunden.  Beachten Sie, dass ein
	Gerät nur dann antwortet, wenn es sich im Modus
	<emphasis>discoverable</emphasis> befindet.</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci inquiry</userinput>
Inquiry result, num_responses=1
Inquiry result #0
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error [00]</screen>

      <para><literal>BD_ADDR</literal> stellt, ähnlich der
	MAC-Adresse einer Netzwerkkarte, die eindeutige Adresse eines
	Bluetooth-Gerätes dar.  Diese Adresse ist für die
	Kommunikation mit dem Gerät nötig.  Es ist aber auch
	möglich, BD_ADDR einen Klartextnamen zuzuweisen.  Die
	Datei <filename>/etc/bluetooth/hosts</filename> enthält
	Informationen über die bekannten Bluetooth-Rechner.  Das
	folgende Beispiel zeigt, wie man den Klartextnamen eines
	entfernten Geräts in Erfahrung bringen kann:</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4</userinput>
BD_ADDR: 00:80:37:29:19:a4
Name: Pav's T39</screen>

      <para>Wenn Sie ein entferntes Bluetooth-Gerät abfragen, wird
	dieses Ihren Rechner unter dem Namen
	<quote>your.host.name (ubt0)</quote> finden.  Dieser Name kann
	aber jederzeit geändert werden.</para>

      <para>Bluetooth ermöglicht Punkt-zu-Punkt-Verbindungen (an
	denen nur zwei Bluetooth-Geräte beteiligt sind), aber auch
	Punkt-zu-Multipunkt-Verbindungen, bei denen eine Verbindung von
	mehreren Bluetooth-Geräten gemeinsam genutzt wird.  Das
	folgende Beispiel zeigt, wie man die aktiven
	Basisbandverbindungen des lokalen Gerätes anzeigen kann:</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci read_connection_list</userinput>
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</screen>

      <para>Ein <emphasis>connection handle</emphasis> ist für die
	Beendigung einer Basisbandverbindung nützlich.  Im
	Normalfall werden inaktive Verbindungen aber automatisch vom
	Bluetooth-Stack getrennt.</para>

      <screen>&prompt.root; <userinput>hccontrol -n ubt0hci disconnect 41</userinput>
Connection handle: 41
Reason: Connection terminated by local host [0x16]</screen>

      <para>Rufen Sie <command>hccontrol help</command> auf, wenn Sie
	eine komplette Liste aller verfügbaren HCI-Befehle
	benötigen.  Die meisten dieser Befehle müssen nicht
	als <systemitem class="username">root</systemitem> ausgeführt werden.</para>
    </sect2>

    <sect2>
      <title>Das Logical Link Control and Adaptation Protocol (L2CAP)</title>

      <indexterm><primary>L2CAP</primary></indexterm>

      <para>Das <foreignphrase>Logical Link Control and Adaptation
	Protocol</foreignphrase> (L2CAP) bietet
	höherwertigen Protokollen verbindungsorientierte und
	verbindungslose Datendienste an.  Dazu gehören auch
	Protokollmultiplexing, Segmentierung und Reassemblierung.
	L2CAP erlaubt höherwertigen Protokollen und Programmen den
	Versand und Empfang von L2CAP-Datenpaketen mit einer Länge
	von bis zu 64 Kilobytes.</para>

      <para>L2CAP arbeitet <emphasis>kanal</emphasis>basiert.  Ein
	Kanal ist eine logische Verbindung innerhalb einer
	Basisbandverbindung.  Jeder Kanal ist dabei an ein einziges
	Protokoll gebunden.  Mehrere Geräte können an das
	gleiche Protokoll gebunden sein, es ist	aber nicht möglich,
	einen Kanal an mehrere Protokolle zu binden.  Jedes über
	einen Kanal ankommende L2CAP-Paket wird an das entsprechende
	höherwertige Protokoll weitergeleitet.  Mehrere Kanäle
	können sich die gleiche Basisbandverbindung teilen.</para>

      <para>Eine einzelne Netgraph-Gerätedatei vom Typ
	<emphasis>l2cap</emphasis> wird für ein einzelnes
	Bluetooth-Gerät erzeugt.  Die L2CAP-Gerätedatei ist
	normalerweise mit der Bluetooth-HCI-Gerätedatei
	(downstream) sowie der Bluetooth-Socket-Gerätedatei
	(upstream) verbunden.  Der Standardname für die
	L2CAP-Gerätedatei, die in &man.ng.l2cap.4; beschrieben
	wird, lautet <quote>devicel2cap</quote>.</para>

      <para>Ein nützlicher Befehl zum Anpingen von anderen
	Geräten ist &man.l2ping.8;.  Einige Bluetooth-Geräte
	senden allerdings nicht alle erhaltenen Daten zurück.  Die
	Ausgabe <literal>0 bytes</literal> ist also kein Fehler:</para>

      <screen>&prompt.root; <userinput>l2ping -a 00:80:37:29:19:a4</userinput>
0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0</screen>

      <para>Das Programm &man.l2control.8; liefert Informationen
	über L2CAP-Dateien.  Das folgende Beispiel zeigt, wie man
	die Liste der logischen Verbindungen (Kanäle) sowie die
	Liste der Basisbandverbindungen abfragen kann:</para>

      <screen>&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_channel_list</userinput>
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_connection_list</userinput>
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</screen>

      <para>&man.btsockstat.1; ist ein weiteres Diagnoseprogramm.  Es
	funktioniert analog zu &man.netstat.1;, arbeitet aber mit
	Bluetooth-Datenstrukturen.  Das folgende Beispiel zeigt die
	gleiche Liste der logischen Verbindungen wie &man.l2control.8;
	im vorherigen Beispiel.</para>

      <screen>&prompt.user; <userinput>btsockstat</userinput>
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</screen>

    </sect2>

    <sect2>
      <title>Das RFCOMM-Protokoll</title>

      <indexterm><primary>RFCOMM</primary></indexterm>

      <para>Das RFCOMM-Protokoll emuliert serielle Verbindungen
	über das L2CAP-Protokoll.  Es basiert auf dem ETSI-Standard
	TS 07.10.  Bei RFCOMM handelt es sich um ein einfaches
	Transportprotokoll, das um Funktionen zur Emulation der
	9poligen Schaltkreise von mit RS-232 (EIATIA-232-E) kompatiblen
	seriellen Ports ergänzt wurde.  RFCOMM erlaubt bis zu 60
	simultane Verbindungen (RFCOMM-Kanäe) zwischen zwei
	Bluetooth-Geräten.</para>

      <para>Eine RFCOMM-Kommunikation besteht aus zwei Anwendungen (den
	Kommunikationsendpunkten), die über das
	Kommunikationssegment miteinander verbunden sind.  RFCOMM
	unterstützt Anwendungen, die auf serielle Ports angewiesen
	sind.  Das Kommunikationssegment entspricht der (direkten)
	Bluetooth-Verbindung zwischen den beiden Geräten.</para>

      <para>RFCOMM kümmert sich um die direkte Verbindung von zwei
	Geräten, oder um die Verbindung zwischen einem Gerät
	und einem Modem (Netzwerkverbindung).  RFCOMM unterstützt
	auch andere Konfigurationen.  Ein Beispiel dafür sind
	Module, die drahtlose Bluetooth-Geräte mit einer
	verkabelten Schnittstelle verbinden können.</para>

      <para>Unter &os; wurde das RFCOMM-Protokoll im Bluetooth Socket-Layer
	implementiert.</para>
    </sect2>

    <sect2>
      <title>Erstmaliger Verbindungsaufbau zwischen zwei
	Bluetooth-Geräten (<foreignphrase>Pairing</foreignphrase>)
      </title>

      <indexterm><primary>Pairing</primary></indexterm>

      <para>In der Voreinstellung nutzt Bluetooth keine
	Authentifizierung, daher kann sich jedes Bluetoothgerät mit
	jedem anderen Gerät verbinden.  Ein Bluetoothgerät
	(beispielsweise ein Mobiltelefon) kann jedoch für einen
	bestimmten Dienst (etwa eine Einwählverbindung) eine
	Authentifizierung anfordern.  Bluetooth verwendet zu diesem
	Zweck <emphasis>PIN-Codes</emphasis>.  Ein PIN-Code ist ein
	maximal 16 Zeichen langer ASCII-String.  Damit eine Verbindung
	zustande kommt, muss auf beiden Geräten der gleiche
	PIN-Code verwendet werden.  Nachdem der Code eingegeben wurde,
	erzeugen beide Geräte einen <emphasis>link key</emphasis>,
	der auf den Geräten gespeichert wird.  Beim nächsten
	Verbindungsaufbau wird der zuvor erzeugte Link Key verwendet.
	Diesen Vorgang bezeichnet man als
	<foreignphrase>Pairing</foreignphrase>.  Geht der Link Key auf
	einem Gerät verloren, muss das Pairing wiederholt
	werden.</para>

      <para>Der &man.hcsecd.8;-Daemon verarbeitet alle
	Bluetooth-Authentifzierungsanforderungen und wird über die
	Datei <filename>/etc/bluetooth/hcsecd.conf</filename>
	konfiguriert.  Der folgende Ausschnitt dieser Datei zeigt die
	Konfiguration für ein Mobiltelefon, das den PIN-Code
	<quote>1234</quote> verwendet:</para>

      <programlisting>device {
        bdaddr  00:80:37:29:19:a4;
        name    "Pav's T39";
        key     nokey;
        pin     "1234";
      }</programlisting>

      <para>Von der Länge abgesehen, unterliegen PIN-Codes keinen
	Einschränkungen.  Einige Geräte, beispielsweise
	Bluetooth-Headsets, haben einen festen PIN-Code eingebaut.  Die
	Option <option>-d</option> sorgt dafür, dass der
	&man.hcsecd.8;-Daemon im Vordergrund läuft.  Dadurch kann
	der Ablauf einfach verfolgt werden.  Stellen Sie das entfernte
	Gerät auf <foreignphrase>receive pairing</foreignphrase>
	und initiieren Sie die Bluetoothverbindung auf dem entfernten
	Gerät.  Sie erhalten die Meldung, dass Pairing akzeptiert
	wurde und der PIN-Code benötigt wird.  Geben Sie den
	gleichen PIN-Code ein, den Sie in
	<filename>hcsecd.conf</filename> festgelegt haben.  Ihr Computer
	und das entfernte Gerät sind nun miteinander verbunden.
	Alternativ können Sie das Pairing auch auf dem entfernten
	Gerät initiieren.</para>

      <para><application>hcsecd</application> kann durch das Einfügen
	der folgenden Zeile in <filename>/etc/rc.conf</filename>
	beim Systemstart automatisch aktiviert werden:</para>

      <programlisting>hcsecd_enable="YES"</programlisting>

      <para>Es folgt nun eine beispielhafte Ausgabe
	des <application>hcsecd</application>-Daemons:</para>

<programlisting>hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4</programlisting>

    </sect2>

    <sect2>
      <title>Das Service Discovery Protocol (SDP)</title>

      <indexterm><primary>SDP</primary></indexterm>

      <para>Das <foreignphrase>Service Discovery Protocol</foreignphrase>
	(SDP) erlaubt es Clientanwendungen, von Serveranwendungen
	angebotene Dienste sowie deren Eigenschaften abzufragen.  Zu
	diesen Eigenschaften gehören die Art oder die Klasse der
	angebotenen Dienste sowie der Mechanismus oder das Protokoll,
	die zur Nutzung des Dienstes notwendig sind.</para>

      <para>SDP ermöglicht Verbindungen zwischen einem SDP-Server
	und einem SDP-Client.  Der Server enthält eine Liste mit
	den Eigenschaften der vom Server angebotenen Dienste.  Jeder
	Eintrag beschreibt jeweils einen einzigen Serverdienst.  Ein
	Client kann diese Informationen durch eine SDP-Anforderung
	vom SDP-Server beziehen.  Wenn der Client oder eine Anwendung
	des Clients einen Dienst nutzen will, muss eine seperate
	Verbindung mit dem Dienstanbieter aufgebaut werden.  SDP bietet
	einen Mechanismus zum Auffinden von Diensten und deren
	Eigenschaften an, es bietet aber keine Mechanismen zur Verwendung
	dieser Dienste.</para>

      <para>Normalerweise sucht ein SDP-Client nur nach Diensten, die
	bestimmte geforderte Eigenschaften erfüllen.  Es ist aber
	auch möglich, anhand der Dienstbeschreibungen eine
	allgemeine Suche nach den von einem Server angebotenen Diensten
	durchzuführen.  Diesen Vorgang bezeichnet man als
        <foreignphrase>Browsing</foreignphrase>.</para>

      <para>Der Bluetooth-SDP-Server &man.sdpd.8; und der
	Kommandozeilenclient &man.sdpcontrol.8; sind bereits in der
	Standardinstallation von &os; enthalten.  Das folgende Beispiel
	zeigt, wie eine SDP-Abfrage durchgeführt wird:</para>

      <screen>&prompt.user; <userinput>sdpcontrol -a 00:01:03:fc:6e:ec browse</userinput>
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server (0x1000)
Protocol Descriptor List:
        L2CAP (0x0100)
                Protocol specific parameter #1: u/int/uuid16 1
                Protocol specific parameter #2: u/int/uuid16 1

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor (0x1001)

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP (0x1102)
Protocol Descriptor List:
        L2CAP (0x0100)
        RFCOMM (0x0003)
                Protocol specific parameter #1: u/int8/bool 1
Bluetooth Profile Descriptor List:
        LAN Access Using PPP (0x1102) ver. 1.0
</screen>

      <para>... und so weiter.  Beachten Sie, dass jeder Dienst eine
	Liste seiner Eigenschaften (etwa den RFCOMM-Kanal)
	zurückgibt.  Je nach dem, welche Dienste Sie
	benötigen, sollten Sie sich einige dieser Eigenschaften
	notieren.  Einige Bluetooth-Implementationen unterstützen
	kein <foreignphrase>Service Browsing</foreignphrase> und geben
	daher eine leere Liste zurück.  Ist dies der Fall, ist es
	dennoch möglich, nach einem bestimmten Dienst zu suchen.
	Das folgende Beispiel demonstriert die Suche nach dem
	OBEX Object Push (OPUSH) Dienst:</para>

      <screen>&prompt.user; <userinput>sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH</userinput></screen>

      <para>Unter &os; ist es die Aufgabe des &man.sdpd.8;-Servers,
	Bluetooth-Clients verschiedene Dienste anzubieten.  Sie
	können diesen Server durch das Einfügen der folgenden
	Zeile in die Datei <filename>/etc/rc.conf</filename>
	aktivieren:</para>

      <programlisting>sdpd_enable="YES"</programlisting>

      <para>Nun kann der <application>sdpd</application>-Daemon durch
	folgene Eingabe gestartet werden:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/sdpd start</userinput></screen>

      <para>Der lokale Server, der den entfernten Clients
	Bluetooth-Dienste anbieten soll, bindet diese Dienste an den
	lokalen SDP-Daemon.  Ein Beispiel für eine solche
	Anwendung ist &man.rfcomm.pppd.8;.  Einmal gestartet, wird der
	Bluetooth-LAN-Dienst an den lokalen SDP-Daemon gebunden.</para>

      <para>Die Liste der vorhandenen Dienste, die am lokalen SDP-Server
	registriert sind, lässt sich durch eine SDP-Abfrage
	über einen lokalen Kontrollkanal abfragen:</para>

      <screen>&prompt.root; <userinput>sdpcontrol -l browse</userinput></screen>

    </sect2>

    <sect2>
      <title>Einwahlverbindungen (Dial-Up Networking (DUN)) oder
	Netzwerkverbindungen mit PPP (LAN)-Profilen einrichten</title>

      <para>Das
	<foreignphrase>Dial-Up Networking (DUN)</foreignphrase>-Profil
	wird vor allem für Modems und Mobiltelefone verwendet.
	Dieses Profil ermöglicht folgende Szenarien:</para>

      <itemizedlist>
        <listitem><para>Die Verwendung eines Mobiltelefons oder eines
	  Modems durch einen Computer als drahtloses Modem, um sich
	  über einen Einwahlprovider mit dem Internet zu verbinden
	  oder andere Einwahldienste zu benutzen.</para>
	</listitem>

        <listitem><para>Die Verwendung eines Mobiltelefons oder eines
	  Modems durch einen Computers, um auf Datenabfragen zu
	  reagieren.</para>
	</listitem>
      </itemizedlist>

      <para>Der Zugriff auf ein Netzwerk über das PPP (LAN)-Profil
	kann in folgenden Situationen verwendet werden:</para>

      <itemizedlist>
        <listitem><para>Den LAN-Zugriff für ein einzelnes
	  Bluetooth-Gerät</para>
	</listitem>

        <listitem><para>Den LAN-Zugriff für mehrere
	  Bluetooth-Geräte</para>
	</listitem>

        <listitem><para>Eine PC-zu-PC-Verbindung (unter Verwendung
	  einer PPP-Verbindung über eine emulierte serielle
	  Verbindung)</para>
	</listitem>
      </itemizedlist>

      <para>Beide Profile werden unter &os; durch &man.ppp.8; sowie
	&man.rfcomm.pppd.8; implementiert - einem Wrapper, der
	RFCOMM Bluetooth-Verbindungen unter PPP nutzbar macht.  Bevor
	ein Profil verwendet werden kann, muss ein neuer PPP-Abschnitt
	in <filename>/etc/ppp/ppp.conf</filename> erzeugt werden.
	Beispielkonfigurationen zu diesem Thema finden Sie in
	&man.rfcomm.pppd.8;.</para>

      <para>Im folgenden Beispiel verwenden wir &man.rfcomm.pppd.8;, um
	eine RFCOMM-Verbindung zu einem entfernten Gerät mit der
	<literal>BD_ADDR 00:80:37:29:19:a4</literal> auf dem
	RFCOMM-Kanal <literal>DUN</literal> aufzubauen.  Die aktuelle
	RFCOMM-Kanalnummer erhalten Sie vom entfernten Gerät
	über SDP.  Es ist auch möglich, manuell einen
	RFCOMM-Kanal festzulegen.  In diesem Fall führt
	&man.rfcomm.pppd.8; keine SDP-Abfrage durch.  Verwenden Sie
	&man.sdpcontrol.8;, um die RFCOMM-Kanäle des entfernten
	Geräts herauszufinden.</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</userinput></screen>

      <para>Der &man.sdpd.8;-Server muss laufen, damit ein Netzzugriff
	mit dem PPP (LAN)-Profil möglich ist.  Außerdem muss
	für den LAN-Client ein neuer Eintrag in
	<filename>/etc/ppp/ppp.conf</filename> erzeugt werden.
	Beispielkonfigurationen zu diesem Thema finden Sie in
	&man.rfcomm.pppd.8;.  Danach starten Sie den RFCOMM PPP-Server
	über eine gültige RFCOMM-Kanalnummer.  Der
	RFCOMM PPP-Server bindet dadurch den Bluetooth-LAN-Dienst an den
	lokalen SDP-Daemon.  Das folgende Beispiel zeigt Ihnen, wie man
	den RFCOMM PPP-Server startet.</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -s -C 7 -l rfcomm-server</userinput></screen>

    </sect2>

    <sect2>
      <title>Das Profil OBEX-Push (OPUSH)</title>

      <indexterm><primary>OBEX</primary></indexterm>

      <para>OBEX ist ein häufig verwendetes Protokoll für den
	Dateitransfer zwischen Mobilgeräten.  Sein Hauptzweck ist
	die Kommunikation über die Infrarotschnittstelle.  Es dient
	daher zum Datentransfer zwischen Notebooks oder PDAs sowie zum
	Austausch von Visitenkarten oder Kalendereinträgen zwischen
	Mobiltelefonen und anderen Geräten mit PIM-Funktionen.</para>

      <para>Server und Client von OBEX werden durch das Softwarepaket
	<application>obexapp</application> bereitgestellt, das als Port
	<package>comms/obexapp</package> verfügbar
	ist.</para>

      <para>Mit dem OBEX-Client werden Objekte zum OBEX-Server geschickt
	oder angefordert.  Ein Objekt kann etwa eine Visitenkarte oder
	ein Termin sein.  Der OBEX-Client fordert über SDP die
	Nummer des RFCOMM-Kanals vom entfernten Gerät an.  Dies
	kann auch durch die Verwendung des Servicenamens anstelle der
	RFCOMM-Kanalnummer erfolgen.  Folgende Dienste werden
	unterstützt:  IrMC, FTRN und OPUSH.  Es ist möglich,
	den RFCOMM-Kanal als Nummer anzugeben.  Es folgt nun ein
	Beispiel für eine OBEX-Sitzung, bei der ein
	Informationsobjekt vom Mobiltelefon angefordert und ein neues
	Objekt (hier eine Visitenkarte) an das Telefonbuch des
	Mobiltelefons geschickt wird:</para>

      <screen>&prompt.user; <userinput>obexapp -a 00:80:37:29:19:a4 -C IrMC</userinput>
obex&gt; get telecom/devinfo.txt
Success, response: OK, Success (0x20)
obex&gt; put new.vcf
Success, response: OK, Success (0x20)
obex&gt; di
Success, response: OK, Success (0x20)</screen>

      <para>Um OBEX-Push-Dienste anbieten zu können, muss der
	<application>sdpd</application>-Server gestartet sein.  Ein
	Wurzelverzeichnis, in dem alle ankommenden Objekt gespeichert
	werden, muss zusätzlich angelegt werden.  In der
	Voreinstellung ist dies <filename>/var/spool/obex</filename>.
	Starten Sie den OBEX-Server mit einer gültigen Kanalnummer.
	Der OBEX-Server registriert nun den OBEX-Push-Dienst mit dem
	lokalen SDP-Daemon.  Um den OBEX-Server zu starten, geben Sie
	Folgendes ein:</para>

      <screen>&prompt.root; <userinput>obexapp -s -C 10</userinput></screen>

    </sect2>

    <sect2>
      <title>Das Profil Serial-Port (SPP)</title>

      <para>Durch dieses Profil können Bluetooth-Geräte RS232-
	(oder damit kompatible) serielle Kabelverbindungen emulieren.
	Anwendungen sind dadurch in der Lage, über eine virtuelle
	serielle Verbindung Bluetooth als Ersatz für eine
	Kabelverbindung zu nutzen.</para>

      <para>Das Profil Serial-Port wird durch &man.rfcomm.sppd.1;
	verwirklicht.  Pseudo-tty wird hier als virtuelle serielle
	Verbindung verwendet.  Das folgende Beispiel zeigt, wie man sich
	mit einem entfernten Serial-Port-Dienst verbindet.  Beachten
	Sie, dass Sie den RFCOMM-Kanal nicht angeben müssen, da
	&man.rfcomm.sppd.1; diesen über SDP vom entfernten
	Gerät abfragen kann.  Wenn Sie dies nicht wollen,
	können Sie einen RFCOMM-Kanal auch manuell festlegen.</para>

      <screen>&prompt.root; <userinput>rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</userinput>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</screen>

      <para>Sobald die Verbindung hergestellt ist, kann pseudo-tty als
        serieller Port verwenden werden.</para>

      <screen>&prompt.root; <userinput>cu -l ttyp6</userinput></screen>
    </sect2>

    <sect2>
      <title>Problembehandlung</title>

      <sect3>
        <title>Ein entferntes Gerät kann keine Verbindung
	  aufbauen</title>

	<para>Einige ältere Bluetooth-Geräte unterstützen
	  keinen Rollentausch.  Wenn &os; eine neue Verbindung
	  akzeptiert, wird versucht, die Rolle zu tauschen, um zum
	  Master zu werden.  Geräte, die dies nicht
	  unterstützen, können keine Verbindung aufbauen.
	  Beachten Sie, dass der Rollentausch ausgeführt wird,
	  sobald eine neue Verbindung aufgebaut wird, daher ist es
	  nicht möglich, das entfernte Gerät zu fragen, ob es
	  den Rollentausch unterstützt.  Dieses Verhalten von &os;
	  kann aber durch eine HCI-Option geändert werden:</para>

        <screen>&prompt.root; <userinput>hccontrol -n ubt0hci write_node_role_switch 0</userinput></screen>

      </sect3>

      <sect3>
        <title>Wo finde ich genaue Informationen darüber, was
	  schiefgelaufen ist?</title>

	<para>Verwenden Sie <application>hcidump</application>,
	  das Sie über den Port <package>comms/hcidump</package> installieren
	  können.  <application>hcidump</application> hat
	  Ähnlichkeiten mit &man.tcpdump.1;.  Es dient zur Anzeige
	  der Bluetooth-Pakete in einem Terminal oder zur Speicherung
	  der Pakete in einer Datei (Dump).</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="network-bridging">
    <info><title>LAN-Kopplung mit einer Bridge</title>
      <authorgroup>
	<author><personname><firstname>Andrew</firstname><surname>Thompson</surname></personname><contrib>Geschrieben von </contrib></author>
      </authorgroup>
    </info>

    

    <sect2>
      <title>Einführung</title>

      <indexterm><primary>Subnetz</primary></indexterm>
      <indexterm><primary>Bridge</primary></indexterm>

      <para>Manchmal ist es nützlich, ein physikalisches Netzwerk
	(wie ein Ethernetsegment) in zwei separate Netzwerke
	aufzuteilen, ohne gleich IP-Subnetze zu erzeugen, die über
	einen Router miteinander verbunden sind.  Ein Gerät, das
	zwei Netze auf diese Weise verbindet, wird als
	<emphasis>Bridge</emphasis> bezeichnet.  Jedes FreeBSD-System
	mit zwei Netzwerkkarten kann als Bridge fungieren.</para>

      <para>Die Bridge arbeitet, indem sie die MAC Layeradressen
	(Ethernet Adressen) der Geräte in ihren
	Netzwerksegmenten lernt.  Der Verkehr wird nur dann zwischen
	zwei Segmenten weitergeleitet, wenn sich Sender und
	Empfänger in verschiedenen Netzwerksegmenten
	befinden.</para>

      <para>In vielerlei Hinsicht entspricht eine Bridge daher einem
        Ethernet-Switch mit sehr wenigen Ports.</para>
    </sect2>

    <sect2>
      <title>Situationen, in denen <emphasis>Bridging</emphasis>
	angebracht ist</title>

      <para>Es gibt zahlreiche Situationen, in denen der Einsatz
	einer Bridge sinnvoll ist:</para>

      <sect3>
	<title>Verbinden von Netzwerken</title>

	<para>Die Hauptaufgabe einer Bridge ist die Verbindung von zwei
	  oder mehreren Netzwerksegmenten zu einem gemeinsamen Netzwerk.
	  Es ist oft sinnvoller, eine hostbasierte Bridge anstelle
	  normaler Netzwerkkomponenten (wie Kabelverbindungen),
	  Firewalls oder Pseudonetzwerken über die
	  Schnittstelle einer virtuellen Maschine einzusetzen.
	  Eine Bridge kann außerdem ein drahtloses Gerät mit
	  einem Kabelnetzwerk verbinden.  Diese Fähigkeit der
	  Bridge wird als <foreignphrase>HostAP-Modus</foreignphrase>
	  bezeichnet.  Die Bridge agiert in diesem Fall als
	  Access Point für das drahtlose Gerät.</para>
      </sect3>

      <sect3>
	<title>Filtering/Traffic Shaping Firewall</title>

	<indexterm><primary>Firewall</primary></indexterm>
	<indexterm><primary>NAT</primary></indexterm>

	<para>Häufig kommt es vor, dass Firewallfunktionen
	  benötigt werden, ohne dass Routing oder
	  <foreignphrase>Network Adress Translation</foreignphrase>
	  (NAT) verwendet werden soll.</para>

	<para>Ein Beispiel dafür wäre ein kleines Unternehmen,
	  das über DSL oder ISDN an seinen ISP angebunden ist.  Es
	  verfügt über 13 weltweit erreichbare IP-Adressen,
	  sein Netzwerk besteht aus 10 Rechnern.  In dieser Situation
	  ist der Einsatz von Subnetzen sowie einer routerbasierten
	  Firewall schwierig.</para>

	<indexterm><primary>Router</primary></indexterm>
	<indexterm><primary>DSL</primary></indexterm>
	<indexterm><primary>ISDN</primary></indexterm>

	<para>Eine brigdebasierte Firewall kann konfiguriert und in den
	  ISDN/DSL-Downstreampfad ihres Routers eingebunden werden, ohne
	  dass Sie sich um IP-Adressen kümmern müssen.</para>
      </sect3>

      <sect3>
	<title>Netzwerküberwachung</title>

	<para>Eine Bridge kann zwei Netzwerksegmente miteinander
	  verbinden und danach alle Ethernet-Rahmen überprüfen,
	  die zwischen den beiden Netzwerksegmenten ausgetauscht werden.
	  Dazu verwendet man entweder &man.bpf.4;/&man.tcpdump.1; auf
	  dem Netzgerät der Bridge oder schickt Kopien aller
	  Rahmen an ein zusätzliches Netzgerät (den sogenannten
	  <foreignphrase>Span Port</foreignphrase>).</para>
      </sect3>

      <sect3>
	<title>Layer&nbsp;2-VPN</title>

	<para>Zwei Ethernetnetzwerke können über einen IP-Link
	  miteinander verbunden werden, indem Sie die beiden Netzwerke
	  über einen EtherIP-Tunnel koppeln oder eine
	  &man.tap.4;-basierte Lösung wie OpenVPN einsetzen.</para>
      </sect3>

      <sect3>
	<title>Layer&nbsp;2-Redundanz</title>

	<para>Die Systeme eines Netzwerks können redundant
	  miteinander verbunden sein.  In diesem Fall verwenden Sie das
	  <foreignphrase>Spanning Tree Protocol</foreignphrase>, um
	  redundante Pfade zu blockieren.  Damit ein Ethernetnetzwerk
	  korrekt arbeitet, darf immer nur ein aktiver Pfad zwischen
	  zwei Geräten des Netzwerks existieren.  Aufgabe des
	  Spanning Tree Protocols ist es daher, Schleifen zu entdecken
	  und redundante Links in den Status
	  <emphasis>blockiert</emphasis> zu versetzen.  Fällt ein
	  aktiver Link aus, so berechnet das Protokoll einen neuen
	  Pfad.  Dazu wird ein blockierter Pfad in den Status
	  <emphasis>aktiv</emphasis> versetzt, damit alle Systeme des
	  Netzwerks wieder miteinander kommunizieren können.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Kernelkonfiguration</title>

      <para>Dieser Abschnitt beschreibt nur die
	&man.if.bridge.4;-Bridge-Implementierung.  Ein
	Netgraph-Bridge-Treiber ist ebenfalls verfügbar, wird
	hier aber nicht behandelt.  Lesen Sie die Manualpage
	&man.ng.bridge.4;, wenn Sie diesen Treiber einsetzen
	wollen.</para>

      <para>Bei diesem Treiber handelt es sich um ein
	Kernelmodul, das von &man.ifconfig.8; automatisch geladen
	wird, wenn ein Bridge-Interface erzeugt wird.  Alternativ ist
	es aber auch möglich, die Unterstützung für
	den Treiber in Ihren Kernel zu kompilieren.  Dazu fügen
	Sie die Zeile <literal>device if_bridge</literal> in Ihre
	Kernelkonfigurationsdatei ein und bauen danach den Kernel
	neu.</para>

      <para>Paketfilter können mit allen Firewallpaketen verwendet
	werden, die das &man.pfil.9;-Framework benutzen.  Die Firewall
	kann dabei entweder als Kernelmodul geladen oder in den Kernel
	kompiliert werden.</para>

      <para>Eine Bridge kann auch als <foreignphrase>Traffic
	Shaper</foreignphrase> verwendet werden, wenn Sie
	&man.altq.4; oder &man.dummynet.4; einsetzen.</para>
    </sect2>

    <sect2>
      <title>Die LAN-Kopplung aktivieren</title>

      <para>Eine Bridge wird durch das Klonen von Schnittstellen
	erzeugt.  Um eine Bridge zu erzeugen, verwenden Sie den Befehl
	&man.ifconfig.8;.  Ist der Bridge-Treiber nicht in Ihren Kernel
	kompiliert, wird er automatisch geladen.</para>

      <screen>&prompt.root; <userinput>ifconfig bridge create</userinput>
bridge0
&prompt.root; <userinput>ifconfig bridge0</userinput>
bridge0: flags=8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        id 00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:00:00:00:00:00 priority 0 ifcost 0 port 0</screen>

      <para>Im obigen Beispiel wird die Bridge erzeugt und erhält
	automatisch eine zufällig generierte Ethernet-Adresse
	zugewiesen.  Die Parameter <literal>maxaddr</literal> sowie
	<literal>timeout</literal> legen fest, wie viele MAC-Adressen
	die Bridge in ihrer Forward-Tabelle halten kann beziehungsweise
	wie viele Sekunden jeder Eintrag erhalten bleiben soll, nachdem
	er zuletzt verwendet wurde.  Die restlichen Parameter sind
	für die Konfiguration von Spanning&nbsp;Tree notwendig.</para>

      <para>Im nächsten Schritt werden die Schnittstellen, die
	die Bridge verbinden soll, zugewiesen.  Damit die Bridge
	Datenpakete weiterleiten kann, müssen sowohl die Bridge
	als auch die Schnittstellen (der zu verbindenden
	Netzwerksegmente) aktiviert sein:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge0 addm fxp0 addm fxp1 up</userinput>
&prompt.root; <userinput>ifconfig fxp0 up</userinput>
&prompt.root; <userinput>ifconfig fxp1 up</userinput></screen>

      <para>Danach ist die Bridge in der Lage, Ethernet-Rahmen zwischen
	den Schnittstellen <filename>fxp0</filename> und
	<filename>fxp1</filename> weiterzuleiten.  Um diese
	Konfiguration beim Systemstart automatisch zu aktivieren,
	müssen Sie folgende Einträge in die Datei
	<filename>/etc/rc.conf</filename> aufnehmen:</para>

      <programlisting>cloned_interfaces="bridge0"
ifconfig_bridge0="addm fxp0 addm fxp1 up"
ifconfig_fxp0="up"
ifconfig_fxp1="up"</programlisting>

      <para>Benötigen Sie für die Bridge eine IP-Adresse,
	müssen Sie diese der Schnittstelle der Bridge zuweisen
	(und nicht einer der Schnittstellen der gekoppelten
	Netzwerksegmente).  Dabei können Sie die IP-Adresse
	sowohl statisch als auch dynamisch über DHCP
	zuweisen:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge0 inet 192.168.0.1/24</userinput></screen>

      <para>Sie können der Bridge-Schnittstelle auch eine
	IPv6-Adresse zuweisen.</para>
    </sect2>

    <sect2>
      <title>Firewalls</title>
      <indexterm><primary>firewall</primary></indexterm>

      <para>Nachdem ein Paketfilter aktiviert wurde, können
	Datenpakete, die von den Schnittstellen der gekoppelten
	Netzwerksegmente gesendet und empfangen werden, über
	die Bridge weitergeleitet oder nach bestimmten Regeln
	gefiltert oder auch komplett geblockt werden.  Ist die
	Richtung des Paketflusses wichtig, ist es am besten, eine
	Firewall auf den Schnittstellen der einzelnen
	Netzwerksegmente einzurichten und nicht auf der Bridge
	selbst.</para>

      <para>Eine Bridge verfügt über verschiedene Optionen,
	über die Sie die Weiterleitung von Nicht-IP- und
	ARP-Paketen sowie den Einsatz von Layer&nbsp;2-Firewalls
	(mit IPFW) steuern können.  Lesen Sie die Manualpage
	&man.if.bridge.4;, wenn Sie diese Funktionen
	benötigen.</para>
    </sect2>

    <sect2>
      <title>Spanning&nbsp;Tree</title>

      <para>Der Bridge-Treiber implementiert das <foreignphrase>Rapid
	Spanning Tree Protocol</foreignphrase> (RSTP oder 802.1w), das
	abwärtskompatibel zum veralteten <foreignphrase>Spanning
	Tree Protocol</foreignphrase> (STP) ist.  Spanning&nbsp;Tree
	dient dazu, Schleifen in einer Netzwerktopologie zu entdecken
	und zu entfernen.  RSTP arbeitet dabei schneller als das
	veraltete STP.  RSTP tauscht Informationen mit
	benachbarten Switchen aus, um Pakete korrekt weiterzuleiten
	und eine Schleifenbildung zu verhindern.</para>

      <para>&os; unterstützt die Betriebsmode RSTP sowie STP,
	von denen RSTP als Standardmodus voreingestellt ist.</para>

      <para>Spanning&nbsp;Tree kann auf den Schnittstellen der
	durch die Bridge verbundenen Netzwerksegmente über die
	Option <literal>stp</literal> aktiviert werden.  Für eine
	Bridge, die die Schnittstellen <filename>fxp0</filename> und
	<filename>fxp1</filename> verbindet, aktivieren Sie STP wie
	folgt:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge0 stp fxp0 stp fxp1</userinput>
bridge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether d6:cf:d5:a0:94:6d
        id 00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0
        member: fxp0 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 3 priority 128 path cost 200000 proto rstp
                role designated state forwarding
        member: fxp1 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role designated state forwarding</screen>

      <para>Diese Bridge hat die Spanning-Tree-ID
	<literal>00:01:02:4b:d4:50</literal> und die Priorität
	<literal>32768</literal>.  Da diese ID mit der
	<literal>Root-ID</literal> identisch ist, handelt es sich um die
	Root-Bridge dieses Netzwerks.</para>

      <para>Auf einer anderen Bridge des Netzwerks ist Spanning&nbsp;Tree
	ebenfalls aktiviert:</para>

      <screen>bridge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        id 00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4
        member: fxp0 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role root state forwarding
        member: fxp1 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 5 priority 128 path cost 200000 proto rstp
                role designated state forwarding</screen>

      <para>Die Zeile <literal>root id 00:01:02:4b:d4:50 priority 32768
	ifcost 400000 port 4</literal> zeigt an, dass die Root-Bridge wie
	im obigen Beispiel die ID <literal>00:01:02:4b:d4:50</literal>
	hat.  Die Pfadkosten hin zur Root-Bridge betragen
	<literal>400000</literal>, wobei der Pfad zur Root-Bridge
	über <literal>Port&nbsp;4</literal> geht (der wiederum
	der Schnittstelle <filename>fxp0</filename>
	entspricht).</para>
    </sect2>

    <sect2>
      <title>Fortgeschrittene Funktionen</title>

      <sect3>
	<title>Den Datenfluss rekonstruieren</title>

	<para>Die Bridge unterstützt den Monitormodus.  Dabei
	  werden alle Pakete verworfen, nachdem sie von &man.bpf.4;
	  verarbeitet wurden.  In diesem Modus erfolgt keine weitere
	  Bearbeitung und auch keine Weiterleitung von Datenpaketen.
	  Es ist daher möglich, die Eingabe von zwei oder mehr
	  Netzwerkschnittstellen in einen einzigen gemeinsamen
	  &man.bpf.4;-Stream zu vereinen.  Ein solcher Datenstrom
	  ist beispielsweise nützlich, um den Datenverkehr für
	  ""network taps"" zu rekonstruieren, die ihre RX/TX-Signale
	  über verschiedene Schnittstellen senden.</para>

	<para>Um die Eingabe von vier Netzwerkschnittstellen in einzigen
	  gemeinsamen Datenstrom zu vereinen, geben Sie Folgendes
	  ein:</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up</userinput>
&prompt.root; <userinput>tcpdump -i bridge0</userinput></screen>
      </sect3>

      <sect3>
	<title>Span Ports</title>

	<para>Eine Kopie jedes Ethernet-Rahmens, der an der Bridge
	  ankommt, wird über einen festgelegten
	  <foreignphrase>Span&nbsp;Port</foreignphrase> verschickt.
	  Auf einer Bridge können
	  beliebig viele Span&nbsp;Ports festgelegt werden.  Wird
	  eine Schnittstelle als Span&nbsp;Port konfiguriert, kann
	  sie nicht mehr als normaler Bridge-Port verwendet werden.
	  Eine derartige Konfiguration ist beispielsweise sinnvoll,
	  um den Datenverkehr, der in einem Netzwerk über die
	  Bridge läuft, auf einen Rechner zu übertragen,
	  der mit einem Span&nbsp;Port der Bridge verbunden
	  ist.</para>

	<para>Um eine Kopie aller Ethernet-Rahmen über die
	  Schnittstelle <filename>fxp4</filename> zu verschicken,
	  geben Sie Folgendes ein:</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 span fxp4</userinput></screen>
      </sect3>

      <sect3>
	<title>Private Schnittstellen</title>

	<para>Eine private Schnittstelle leitet keine Daten an einen
	  Port weiter, bei dem es sich ebenfalls um eine private
	  Schnittstelle handelt.  Der Datenverkehr wird dabei komplett
	  blockiert, auch Ethernet-Rahmen und ARP-Pakete werden nicht
	  weitergeleitet.  Wollen Sie hingegen nur spezifische
	  Datenpakete blockieren, sollten Sie eine Firewall
	  einsetzen.</para>
      </sect3>

      <sect3>
	<title>Schnittstellen als <foreignphrase>sticky</foreignphrase>
	  kennzeichnen</title>

	<para>Wenn die Schnittstelle eines über eine Bridge
	  verbundenen Netzwerksegments als
	  <foreignphrase>sticky</foreignphrase> gekennzeichnet wird,
	  werden alle dynamisch gelernten Adressen als statische Adressen
	  behandelt, sobald sie in den Forward-Cache der Bridge
	  aufgenommen wurden.  Sticky-Einträge werden niemals aus
	  dem Cache entfernt oder ersetzt.  Selbst dann nicht, wenn die
	  Adresse von einer anderen Schnittstelle verwendet wird.  Sie
	  können dadurch die Vorteile statischer Adresseinträge
	  nutzen, ohne die Forward-Tabelle vor dem Einsatz der Bridge
	  mit statischen Einträgen füllen zu müssen.
	  Clients, die sich in einem bestimmten von der Bridge
	  verwalteten Segmente befinden, können dabei nicht in ein
	  anderes Segment wechseln.</para>

	<para>Ein weiteres Beispiel für den Einsatz von
	  Sticky-Adressen wäre die Kombination einer Bridge mit
	  mehreren VLANs, um einen Router zu konfigurieren, der in
	  in der Lage ist, einzelne Kundennetzwerke voneinander zu
	  trennen, ohne IP-Adressbereiche zu verschwenden.  Für das
	  folgende Beispiel nehmen wir an, dass sich der Client
	  <systemitem class="fqdomainname">CustomerA</systemitem> im VLAN
	  <literal>vlan100</literal> und der Client
	  <systemitem class="fqdomainname">CustomerB</systemitem> im VLAN
	  <literal>vlan101</literal> befinden.  Die Bridge hat die
	  IP-Adresse <systemitem class="ipaddress">192.168.0.1</systemitem> und ist
	  als Internet-Router konfiguriert.</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101</userinput>
&prompt.root; <userinput>ifconfig bridge0 inet 192.168.0.1/24</userinput></screen>

	<para>Beide Clients sehen <systemitem class="ipaddress">192.168.0.1</systemitem> als Ihr Default-Gateway.
	  Da der Brücken-Cache <emphasis>sticky</emphasis> ist,
	  sind Sie nicht dazu in der Lage, die MAC-Adresse des
	  anderen Kunden zu spoofen und dessen Datenverkehr
	  abzufangen.</para>

	<para>Sie können die Kommunikation zwischen den VLANs
	  vollständig unterbinden, wenn Sie private Schnittstellen
	  (oder eine Firewall) einsetzen:</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 private vlan100 private vlan101</userinput></screen>

	<para>Die Kunden sind nun komplett voneinander isoliert und
	  der komplette <systemitem class="netmask">/24</systemitem>-Adressbereich
	  kann zugewiesen werden, ohne dass Sie Subnetze einsetzen
	  müssen.</para>
      </sect3>

      <sect3>
	<title>Adressen-Limitierung</title>

	<para>Die maximale mögliche Anzahl an eindeutigen
	  MAC-Adressen hinter einer Schnittstelle kann festgelegt werden.
	  Sobald das Limit erreicht ist, werden Pakete mit einer
	  unbekannten Quell-Adresse solange verworfen, bis ein
	  exisitierender Eintrag gelöscht wird oder
	  abläuft.</para>

	<para>Das folgende Beispiel setzt die maximale Anzahl von
	  Netzgeräten für
	  <systemitem class="fqdomainname">CustomerA</systemitem> für
	  das VLAN <literal>vlan100</literal> auf 10.</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 ifmaxaddr vlan100 10</userinput></screen>
      </sect3>

      <sect3>
	<title>SNMP-Monitoring</title>

	<para>Die Schnittstelle der Bridge sowie die STP-Parameter
	  können durch den bereits im Basissystem enthaltenen
	  SNMP-Daemon überwacht werden.  Die exportierten
	  Bridge-MIBs entsprechen den IETF-Standards, daher können
	  Sie einen beliebigen SNMP-Client oder ein beliebiges
	  Monitoring-Werkzeug einsetzen, um die benötigten Daten
	  zu erhalten.</para>

	<para>Auf dem Rechner, auf dem die Bridge konfiguriert ist,
	  aktivieren Sie die Zeile
	  <literal>begemotSnmpdModulePath."bridge" = "/usr/lib/snmp_bridge.so"</literal>
	  in der Datei <filename>/etc/snmp.config</filename> und starten
	  danach den <application>bsnmpd</application>-Daemon.
	  Eventuell benötigen Sie noch weitere
	  Konfigurationsparameter wie Community-Namen und
	  Zugriffslisten.  Die Konfiguration dieser Parameter wird
	  in den Manualpages &man.bsnmpd.1; sowie &man.snmp.bridge.3;
	  beschrieben.</para>

	<para>Die folgenden Beispiele verwenden das Softwarepaket
	  <application>Net-SNMP</application> (<package>net-mgmt/net-snmp</package>), um die Bridge
	  abzufragen.  Alternativ können Sie dafür auch den
	  Port <package>net-mgmt/bsnmptools</package>
	  einsetzen.  Auf dem SNMP-Client fügen Sie danach die
	  folgenden Zeilen in die Datei
	  <filename>$HOME/.snmp/snmp.conf</filename> ein, um die
	  MIB-Definitionen der Bridge in
	  <application>Net-SNMP</application> zu importieren:</para>

	<programlisting>mibdirs +/usr/share/snmp/mibs
mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB</programlisting>

	<para>Um eine einzelne Bridge über den IETF BRIDGE-MIB
	  (RFC4188) zu überwachen, geben Sie Folgendes ein:</para>

	<screen>&prompt.user; <userinput>snmpwalk -v 2c -c public bridge1.example.com mib-2.dot1dBridge</userinput>
BRIDGE-MIB::dot1dBaseBridgeAddress.0 = STRING: 66:fb:9b:6e:5c:44
BRIDGE-MIB::dot1dBaseNumPorts.0 = INTEGER: 1 ports
BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 = Timeticks: (189959) 0:31:39.59 centi-seconds
BRIDGE-MIB::dot1dStpTopChanges.0 = Counter32: 2
BRIDGE-MIB::dot1dStpDesignatedRoot.0 = Hex-STRING: 80 00 00 01 02 4B D4 50
...
BRIDGE-MIB::dot1dStpPortState.3 = INTEGER: forwarding(5)
BRIDGE-MIB::dot1dStpPortEnable.3 = INTEGER: enabled(1)
BRIDGE-MIB::dot1dStpPortPathCost.3 = INTEGER: 200000
BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 = Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedCost.3 = INTEGER: 0
BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 = Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedPort.3 = Hex-STRING: 03 80
BRIDGE-MIB::dot1dStpPortForwardTransitions.3 = Counter32: 1
RSTP-MIB::dot1dStpVersion.0 = INTEGER: rstp(2)</screen>

	<para>Der Wert der Variable
	  <literal>dot1dStpTopChanges.0</literal> ist hier 2, die
	  STP-Topologie der Bridge wurde also bereits zweimal
	  geändert.  Unter einer Änderung versteht man dabei
	  die Anpassung eines oder mehrerer Links und die Kalkulation
	  eines neuen Baums.  Der Wert der Variable
	  <literal>dot1dStpTimeSinceTopologyChange.0</literal> gibt an,
	  wann dies zuletzt geschah.</para>

	<para>Um mehrere Bridge-Schnittstellen zu überwachen,
	  können Sie den privaten BEGEMOT-BRIDGE-MIB
	  einsetzen:</para>

	<screen>&prompt.user; <userinput>snmpwalk -v 2c -c public bridge1.example.com</userinput>
enterprises.fokus.begemot.begemotBridge
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName."bridge0" = STRING: bridge0
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName."bridge2" = STRING: bridge2
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress."bridge0" = STRING: e:ce:3b:5a:9e:13
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress."bridge2" = STRING: 12:5e:4d:74:d:fc
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts."bridge0" = INTEGER: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts."bridge2" = INTEGER: 1
...
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange."bridge0" = Timeticks: (116927) 0:19:29.27 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange."bridge2" = Timeticks: (82773) 0:13:47.73 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges."bridge0" = Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges."bridge2" = Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot."bridge0" = Hex-STRING: 80 00 00 40 95 30 5E 31
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot."bridge2" = Hex-STRING: 80 00 00 50 8B B8 C6 A9</screen>

	<para>Um die über den
	  <literal>mib-2.dot1dBridge</literal>-Subtree überwachte
	  Bridge-Schnittstelle zu ändern, geben Sie Folgendes
	  ein:</para>

	<screen>&prompt.user; <userinput>snmpset -v 2c -c private bridge1.example.com</userinput>
BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2</screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="network-aggregation">
    <info><title>Link-Aggregation und Failover</title>
      <authorgroup>
        <author><personname><firstname>Andrew</firstname><surname>Thompson</surname></personname><contrib>Geschrieben von </contrib></author>
      </authorgroup>

      <authorgroup>
        <author><personname><firstname>Benedict</firstname><surname>Reuschling</surname></personname><contrib>Übersetzt von </contrib></author>
        <author><personname><firstname>Sharon</firstname><surname>Bahagi</surname></personname></author>
      </authorgroup>
    </info>
    

    <indexterm><primary>lagg</primary></indexterm>
    <indexterm><primary>failover</primary></indexterm>
    <indexterm><primary>fec</primary></indexterm>
    <indexterm><primary>lacp</primary></indexterm>
    <indexterm><primary>loadbalance</primary></indexterm>
    <indexterm><primary>roundrobin</primary></indexterm>

    <sect2>
      <title>Einleitung</title>
      <para>Die &man.lagg.4;-Schnittstelle erlaubt die Aggregation von
        mehreren Netzwerkadaptern als eine virtuelle Schnittstelle mit dem
        Ziel, Ausfallsicherheit (Failover) und Hochgeschwindigkeitsverbindungen
        bereitzustellen.</para>
    </sect2>

    <sect2>
      <title>Anwendungsoptionen</title>

      <variablelist>

	<varlistentry><term>Ausfallsicherheit (Failover)</term>

	<listitem>
	<para>Sendet und empfängt Netzwerkverkehr nur auf dem
	  Masterport.  Sollte der Masterport nicht zur Verfügung stehen,
	  wird der nächste aktive Port verwendet.  Der zuerst
	  hinzugefügte Adapter wird zum Masterport, jeder weitere Adapter
	  dient als Gerät zur Ausfallsicherheit.</para>
        </listitem>
        </varlistentry>

	<varlistentry><term>&cisco; Fast &etherchannel;</term>

	<listitem>
	<para>&cisco; Fast &etherchannel; (FEC), ist eine statische
          Konfiguration und handelt weder Aggregation mit der Gegenstelle aus,
          noch werden Frames zur Überwachung der Verbindung ausgetauscht.
          Wenn der Switch LACP unterstützt, sollte diese Option auch
          verwendet werden.</para>

	<para><acronym>FEC</acronym> balanciert den ausgehenden Verkehr
          über die aktiven Ports, basierend auf gehashten
          Protokollheaderinformationen und akzeptiert eingehenden Verkehr auf
          jedem aktiven Port.  Der Hash enthält die Ethernet-Quell- und
          Zieladresse, und, falls verfügbar, den VLAN-Tag, sowie die
          IPv4/IPv6 Quell- und Zieladresse.</para>
        </listitem>
	</varlistentry>

	<varlistentry><term>LACP</term>

	<listitem>
	<para>Das &ieee; 802.3ad Link-Aggregation Control Protokoll
	  (LACP) und das Marker Protocol. LACP wird eine Menge von
	  aggregierbaren Verbindungen mit der Gegenstelle in einer oder
	  mehreren Link Aggregated Groups (LAG) aushandeln.  Jede LAG besteht
	  aus Ports der gleichen Geschwindigkeit, eingestellt auf
	  Voll-Duplex-Betrieb.  Der Verkehr wird über die Ports
	  in der LAG mit der größten Gesamtgeschwindigkeit
	  balanciert, in den meisten Fällen wird es nur eine LAG geben,
	  die alle Ports enthält.  Im Falle von Änderungen in der
	  physischen Anbindung wird die Link-Aggregation schnell zu einer
	  neuen Konfiguration konvergieren.</para>

	<para><acronym>LACP</acronym> balanciert ausgehenden Verkehr
          über die aktiven Ports basierend auf der gehashten
          Protokollheaderinformation und akzeptiert eingehenden Verkehr auf
          jedem aktiven Port.  Der Hash beinhaltet die Ethernet-Quell- und
          Zieladresse, und, soweit verfügbar, den VLAN-Tag, sowie die
          IPv4/IPv6 Quell- und Zieladresse.</para>
        </listitem>
	</varlistentry>

	<varlistentry><term>Lastverteilung (Loadbalance)</term>

	<listitem>
	<para>Dabei handelt es sich um einen Alias des
	  <emphasis>FEC</emphasis>-Modus.</para>
        </listitem>
        </varlistentry>

	<varlistentry><term>Round-Robin</term>

	<listitem>
	<para>Verteilt ausgehenden Verkehr mittels einer Round-Robin-Zuteilung
          über alle aktiven Ports und akzeptiert eingehenden Verkehr auf
          jedem aktiven Port. Dieser Modus verletzt die Reihenfolge von
          Ethernet-Frames und sollte mit Vorsicht eingesetzt werden.</para>
        </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>Beispiele</title>

      <example xml:id="networking-lacp-aggregation-cisco">
	<title>LACP Aggregation mit einem Switch von &cisco;</title>

	<para>Dieses Beispiel verbindet zwei Adapter auf einer &os;-Maschine
          mit dem Switch als eine einzelne, lastverteilte und ausfallsichere
          Verbindung.  Weitere Adapter können hinzugefügt werden, um
          den Durchsatz zu erhöhen und die Ausfallsicherheit zu steigern.
          Da die Reihenfolge der Frames bei Ethernet zwingend eingehalten
          werden muss, fließt auch jeglicher Verkehr zwischen zwei
          Stationen über den gleichen physischen Kanal, was die maximale
          Geschwindigkeit der Verbindung auf die eines einzelnen Adapters
          beschränkt.  Der Übertragungsalgorithmus versucht, so viele
          Informationen wie möglich zu verwenden, um die verschiedenen
          Verkehrsflüsse zu unterscheiden und balanciert diese über
          die verfügbaren Adapter.</para>

	<para>Fügen Sie auf dem &cisco;-Switch die Adapter
	  <replaceable>FastEthernet0/1</replaceable> und
	  <replaceable>FastEthernet0/2</replaceable> zu der
	  channel-group <replaceable>1</replaceable> hinzu:</para>

	<screen><userinput>interface FastEthernet0/1
 channel-group 1 mode active
 channel-protocol lacp</userinput>
!
<userinput>interface FastEthernet0/2
 channel-group 1 mode active
 channel-protocol lacp</userinput></screen>

	<para>Auf der Maschine mit &os; erstellen Sie die
	  &man.lagg.4;-Schnittstelle unter Verwendung von
	  <replaceable>fxp0</replaceable> und
	  <replaceable>fxp1</replaceable>:</para>

        <screen>&prompt.root; <userinput>ifconfig lagg0 create </userinput>
&prompt.root; <userinput>ifconfig lagg0 up laggproto lacp laggport fxp0 laggport fxp1</userinput></screen>

	<para>Überprüfen Sie den Status der Schnittstelle, indem
	  Sie folgendes eingeben:</para>

	<screen>&prompt.root; <userinput>ifconfig lagg0</userinput></screen>

	<para>Ports, die als <emphasis>ACTIVE</emphasis> markiert sind, sind
	  Teil der aktiven Aggregations-Gruppe, die mit dem Switch
	  ausgehandelt wurde und der Verkehr wird über diese
	  übertragen und empfangen.  Benutzen Sie die ausführliche
	  Ausgabe von &man.ifconfig.8;, um sich die LAG-Identifikatoren
	  anzeigen zu lassen.</para>

	<screen>lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        media: Ethernet autoselect
        status: active
        laggproto lacp
        laggport: fxp1 flags=1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;
        laggport: fxp0 flags=1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;</screen>

	<para>Um den  Status der Ports auf dem Switch anzuzeigen, geben Sie
	  <userinput>show lacp neighbor</userinput> ein:</para>

	<screen>switch# show lacp neighbor
Flags:  S - Device is requesting Slow LACPDUs
        F - Device is requesting Fast LACPDUs
        A - Device is in Active mode       P - Device is in Passive mode

Channel group 1 neighbors

Partner's information:

                  LACP port                        Oper    Port     Port
Port      Flags   Priority  Dev ID         Age     Key     Number   State
Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D
Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D</screen>

	<para>Benutzen Sie das Kommando <userinput>show lacp neighbor
	  detail</userinput>, um weitere Informationen zu erhalten.</para>
      </example>
      <example xml:id="networking-lagg-failover">
	<title>Ausfallsicherer Modus</title>

	<para>Der ausfallsichere Modus kann verwendet werden, um zu einer
	  zweiten Schnittstelle zu wechseln, sollte die Verbindung mit der
	  Master-Schnittstelle ausfallen.  Erstellen und konfigurieren Sie die
	  <replaceable>lagg0</replaceable>-Schnittstelle mit
	  <replaceable>fxp0</replaceable> als Master und
	  <replaceable>fxp1</replaceable> als die sekundäre
	  Schnittstelle:</para>

        <screen>&prompt.root; <userinput>ifconfig lagg0 create</userinput>
&prompt.root; <userinput>ifconfig lagg0 up laggproto failover laggport fxp0 laggport fxp1</userinput></screen>

	<para>Die Schnittstelle wird so ähnlich wie im folgenden
	  aussehen, mit dem großen Unterschied, dass die
	  <acronym>MAC</acronym>-Adresse und die Gerätenamen
	  unterschiedlich sein werden:</para>

        <screen>&prompt.root; <userinput>ifconfig lagg0</userinput>
lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: fxp1 flags=0&lt;&gt;
        laggport: fxp0 flags=5&lt;MASTER,ACTIVE&gt;</screen>

	<para>Der Verkehr wird auf <replaceable>fxp0</replaceable>
          übertragen und empfangen.  Wenn die Verbindung auf
          <replaceable>fxp0</replaceable> abbricht, so wird
	  <replaceable>fxp1</replaceable> die Verbindung übernehmen.
	  Sobald die Verbindung auf der Master-Schnittstelle wiederhergestellt
	  ist, wird diese auch wieder als aktive Schnittstelle genutzt.</para>
      </example>

      <example xml:id="networking-lagg-wired-and-wireless">
        <title>Failover Modus zwischen drahtgebundenen und drahtlosen
          Schnittstellen</title>

        <para>Für Laptop-Benutzer ist es normalerweise
          wünschenswert, wireless als sekundäre Schnittstelle
          einzurichten, die verwendet wird, wenn die Verbindung via Kabel
          nicht verfügbar ist.  Mit &man.lagg.4; ist es möglich,
          eine IP-Adresse für die Kabelverbindung zu verwenden.
          Sie ist leistungsfähig und sicher.  Gleichzeitig haben Sie
          die Möglichkeit Daten über die drahtlose Verbindung
          zu übertragen.</para>

        <para>In dieser Konfiguration, müssen wir die zugrunde
          liegenden <acronym>MAC</acronym>-Adresse der WLAN-Schnittstelle
          überschreiben, damit sie zur Adresse von &man.lagg.4; passt,
          welche von der drahtgebundenen Masterschnittstelle vererbt
          wurde.</para>

        <para>In dieser Konfiguration behandeln wir die drahtgebundene
          Schnittstelle <replaceable>bge0</replaceable> als die Master und
          die drahtlose Schnittstelle <replaceable>wlan0</replaceable> als
          die Failover-Schnittstelle.  Die <replaceable>wlan0</replaceable>
          wurde von der <replaceable>iwn0</replaceable> mit der
          <acronym>MAC</acronym>-Adresse der kabelgebundenen eingerichtet.
          Im ersten Schritt erhalten wir die <acronym>MAC</acronym>-Adresse
          der kabelgebundenen Schnittstelle:</para>

        <screen>&prompt.root; <userinput>ifconfig bge0</userinput>
bge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
 options=19b&lt;RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM,TSO4&gt;
 ether 00:21:70:da:ae:37
 inet6 fe80::221:70ff:feda:ae37%bge0 prefixlen 64 scopeid 0x2
 nd6 options=29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt;
 media: Ethernet autoselect (1000baseT &lt;full-duplex&gt;)
 status: active</screen>

	<para>Sie können <replaceable>bge0</replaceable> in
	  ihre tatsächliche ändern und werden eine andere
	  <literal>ether</literal>-Zeile mit der
	  <acronym>MAC</acronym>-Adresse ihrer kabelgebundenen
	  Schnittstelle erhalten. Nun ändern wir die zugrunde liegende
	  drahtlose Schnittstelle <replaceable>iwn0</replaceable>:</para>

	<screen>&prompt.root; <userinput>ifconfig iwn0 ether 00:21:70:da:ae:37</userinput></screen>

	<para>Starten Sie den Wireless-Schnittstelle, aber ohne
	  IP-Adresse:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev iwn0 ssid my_router up</userinput></screen>

	<para>Erstellen Sie die &man.lagg.4; Schnittstelle mit
	  <replaceable>bge0</replaceable> als Master und
	  <replaceable>wlan0</replaceable> als Failover falls
	  notwendig:</para>

	<screen>&prompt.root; <userinput>ifconfig lagg0 create</userinput>
&prompt.root; <userinput>ifconfig lagg0 up laggproto failover laggport bge0 laggport wlan0</userinput></screen>

	<para>Die Schnittstelle sieht änhlich aus, die Hauptunterschiede
	  werden die <acronym>MAC</acronym>-Adresse und die Gerätenamen
	  sein:</para>

	<screen>&prompt.root; <userinput>ifconfig lagg0</userinput>
lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=8&lt;VLAN_MTU&gt;
        ether 00:21:70:da:ae:37
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: wlan0 flags=0&lt;&gt;
        laggport: bge0 flags=5&lt;MASTER,ACTIVE&gt;</screen>

        <para>Um zu vermeiden, dass Sie dies nach jedem Neustart machen müssen, können Sie
          etwas in der Art in ihre <filename>/etc/rc.conf</filename>
          Datei schreiben:</para>

        <programlisting>ifconfig_bge0="up"
ifconfig_iwn0="ether 00:21:70:da:ae:37"
wlans_iwn0="wlan0"
ifconfig_wlan0="WPA"
cloned_interfaces="lagg0"
ifconfig_lagg0="laggproto failover laggport bge0 laggport wlan0 DHCP"
	</programlisting>
      </example>
    </sect2>
  </sect1>

  <sect1 xml:id="network-diskless">
    <info><title>Start und Betrieb von FreeBSD über ein Netzwerk</title>
      <authorgroup>
        <author><personname><firstname>Jean-Fran&ccedil;ois</firstname><surname>Dock&egrave;s</surname></personname><contrib>Aktualisiert von </contrib></author>
      </authorgroup>

      <authorgroup>
	<author><personname><firstname>Alex</firstname><surname>Dupre</surname></personname><contrib>Reorganisiert und erweitert von </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>plattenloser Arbeitsplatz</primary>
    </indexterm>
    <indexterm>
      <primary>plattenloser Betrieb</primary>
    </indexterm>

    <para>FreeBSD kann über ein Netzwerk starten und arbeiten, ohne
      eine lokale Festplatte zu verwenden, indem es Dateisysteme eines
      <acronym>NFS</acronym>-Servers in den eigenen Verzeichnisbaum
      einhängt.  Dazu sind, von den Standardkonfigurationsdateien
      abgesehen, keine Systemänderungen nötig.  Ein solches
      System kann leicht installiert werden, da alle notwendigen
      Elemente bereits vorhanden sind:</para>

    <itemizedlist>
      <listitem>
        <para>Es gibt mindestens zwei Möglichkeiten, den Kernel
          über das Netzwerk zu laden:</para>

        <itemizedlist>
          <listitem>
	    <para><acronym>PXE</acronym>: Das
              <quote>Preboot eXecution Environment System</quote> von
	      &intel; ist eine Art intelligentes Boot-ROM, das in
	      einigen Netzwerkkarten oder Hauptplatinen verwendet wird.
	      Weitere Informationen finden Sie in &man.pxeboot.8;.
	    </para>
          </listitem>

          <listitem>
            <para>Der Port
	      <application>Etherboot</application>
	      (<package>net/etherboot</package>)
	      erzeugt ROM-fähigen Code, um einen Kernel über
	      das Netzwerk zu laden.  Dieser Code kann entweder auf ein
              Boot-PROM einer Netzwerkkarte gebrannt werden, was von vielen
              Netzwerkkarten unterstützt wird.  Oder er kann von einer
              lokalen Diskette, Festplatte oder von einem laufenden
              &ms-dos;-System geladen werden.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Das Beispielskript
	  <filename>/usr/share/examples/diskless/clone_root</filename>
	  erleichtert die Erzeugung und die Wartung des
	  root-Dateisystems auf dem Server.  Das Skript muss
	  wahrscheinlich angepasst werden, dennoch werden Sie schnell zu
	  einem Ergebnis kommen.</para>
      </listitem>

      <listitem>
        <para>Die Startdateien, die einen plattenlosen Systemstart
          erkennen und unterstützen, sind nach der Installation
          in <filename>/etc</filename> vorhanden.</para>
      </listitem>

      <listitem>
	<para>Dateiauslagerungen können sowohl via
	  <acronym>NFS</acronym> als auch auf die lokale Platte
	  erfolgen.</para>
      </listitem>
    </itemizedlist>

    <para>Es gibt verschiedene Wege, einen plattenlosen Rechner
      einzurichten.  Viele Elemente sind daran beteiligt, die fast
      immer an den persönlichen Geschmack angepasst werden
      können.  Im folgenden Abschnitt wird die Installation
      eines kompletten Systems beschrieben, wobei der
      Schwerpunkt auf Einfachheit und Kompatibilität zu den
      Standardstartskripten von FreeBSD liegt.  Das beschriebene
      System hat folgende Eigenschaften:</para>

    <itemizedlist>
      <listitem>
        <para>Die plattenlosen Rechner haben ein gemeinsames
          <filename>/</filename>- sowie ein gemeinsames
          <filename>/usr</filename>-Dateisystem, die jeweils
          schreibgeschützt sind.</para>

        <para>Das root-Dateisystem ist eine Kopie
          eines Standardwurzelverzeichnisses von FreeBSD
          (üblicherweise das des Servers), bei dem einige
          Konfigurationsdateien durch für den plattenlosen
          Betrieb geeignete Versionen ersetzt wurden.</para>

        <para>Für die Bereiche des root-Dateisystems, die
          beschreibbar sein müssen, werden mit &man.md.4;
          virtuelle Dateisysteme erzeugt.  Dies bedeutet aber auch, dass
          alle Veränderungen verloren gehen, wenn das System neu
          gestartet wird.</para>
      </listitem>

      <listitem>
	<para>Der Kernel wird, in Abhängigkeit von der jeweiligen
	  Situation, entweder von <application>Etherboot</application>
	  oder von <acronym>PXE</acronym> transferiert und geladen.
	</para>
      </listitem>
    </itemizedlist>

    <caution><para>Das hier beschriebene System ist nicht sicher.  Es
      sollte nur in einem gesicherten Bereich eines Netzwerks verwendet
      werden und für andere Rechner nicht erreichbar sein.</para>
    </caution>

    <para>Alle Informationen in diesem Abschnitt wurden unter
      &os;&nbsp;5.2.1-RELEASE getestet.</para>

    <sect2>
      <title>Hintergrundinformationen</title>

      <para>Die Einrichtung von plattenlosen Rechnern ist einfach, aber
	auch fehleranfällig.  Der Grund dafür sind auftretende
	Fehler, die sich oft nur schwer zuordnen lassen.  Unter anderem
	sind dafür folgende Umstände verantwortlich:</para>

      <itemizedlist>
	<listitem>
	  <para>Kompilierte Optionen haben zur Laufzeit unterschiedliche
	    Auswirkungen.</para>
	</listitem>

	<listitem>
	  <para>Fehlermeldungen sind oft kryptisch oder fehlen
	    vollständig.</para>
	</listitem>
      </itemizedlist>

      <para>Daher ist es nützlich, über die im Hintergrund
	ablaufenden Mechanismen Bescheid zu wissen.  Dadurch wird es
	einfacher, eventuell auftretende Fehler zu beheben.</para>

      <para>Verschiedene Operationen müssen ausgeführt werden,
	um ein System erfolgreich zu starten:</para>

      <itemizedlist>
	<listitem>
	  <para>Der Rechner benötigt einige Startparameter, wie
	    seine IP-Adresse, die Namen ausführbarer Dateien, den
	    Servernamen sowie den root-Pfad.  Für die
	    Übermittlung dieser Informationen wird entweder das
	    <acronym>DHCP</acronym>- oder das BOOTP-Protokoll verwendet.
	    Bei <acronym>DHCP</acronym> handelt es sich um eine
	    abwärtskompatible Erweiterung von BOOTP, die die
	    gleichen Portnummern und das gleiche Paketformat verwendet.
	  </para>

	  <para>Es ist möglich, das System so zu konfigurieren,
	    dass es nur BOOTP verwendet.  Das Serverprogramm
	    &man.bootpd.8; ist bereits im &os;-Basissystem enthalten.
	  </para>

	  <para><acronym>DHCP</acronym> hat im Vergleich zu BOOTP
	    allerdings mehrere Vorteile (bessere Konfigurationsdateien,
	    die Möglichkeit zur Verwendung von
	    <acronym>PXE</acronym>, sowie viele andere, die nicht in
	    direktem Zusammenhang mit dem plattenlosen Betrieb stehen).
	    Dieser Abschnitt beschreibt die Konfiguration mittels
	    <acronym>DHCP</acronym>.  Wenn möglich, werden aber
	    entsprechende Beispiele für &man.bootpd.8;
	    angeführt.  Die Beispielkonfiguration nutzt das
	    Softwarepaket <application>ISC DHCP</application>.</para>
	</listitem>

	<listitem>
	  <para>Der Rechner muss ein oder mehrere Programme in den
	    lokalen Speicher laden.  Dazu wird entweder
	    <acronym>TFTP</acronym> oder <acronym>NFS</acronym>
	    verwendet.  Die Auswahl zwischen <acronym>TFTP</acronym> und
	    <acronym>NFS</acronym> erfolgt über das Setzen von
	    verschiedenen Kompilieroptionen.  Ein häufig gemachter
	    Fehler ist es, Dateinamen für das falsche Protokoll
	    anzugeben:  <acronym>TFTP</acronym> transferiert
	    normalerweise alle Dateien aus einem einzigen Verzeichnis
	    des Servers, und erwartet einen Pfad relativ zu diesem
	    Verzeichnis.  <acronym>NFS</acronym> verlangt hingegen
	    absolute Dateipfade.</para>
	</listitem>

	<listitem>
	  <para>Die möglichen Bootstrap-Programme und der Kernel
	    müssen initialisiert und ausgeführt werden.  Dabei
	    gibt es zwei Möglichkeiten:</para>

	  <itemizedlist>
	    <listitem>
	      <para><acronym>PXE</acronym> lädt &man.pxeboot.8;.
	        Dabei handelt es sich um eine modifizierte Version des
	        &os;-Laders der Boot-Phase drei.  Der &man.loader.8;
	        beschafft alle für den Systemstart notwendigen
	        Parameter, und hinterlegt diese in der Kernelumgebung,
	        bevor er die Kontrolle übergibt.  Es ist hier
	        möglich, den <filename>GENERIC</filename>-Kernel
	        zu verwenden.</para>
	    </listitem>

	    <listitem>
	      <para><application>Etherboot</application> lädt den
	        Kernel hingegen direkt.  Dafür müssen Sie
	        allerdings einen Kernel mit spezifischen Optionen
	        erzeugen.</para>
	    </listitem>
	  </itemizedlist>

	  <para><acronym>PXE</acronym> und
	    <application>Etherboot</application> sind zwar im
	    Großen und Ganzen gleichwertig, da der Kernel
	    aber viele Aufgaben an &man.loader.8; übergibt, sollte
	    bevorzugt <acronym>PXE</acronym> eingesetzt werden.</para>

	  <para>Wenn Ihr <acronym>BIOS</acronym> und Ihre Netzwerkkarten
	    <acronym>PXE</acronym> unterstützen, sollten Sie es
	    auch verwenden.</para>
	</listitem>

	<listitem>
	   <para>Zuletzt muss der Rechner auf seine Dateisysteme
	     zugreifen können.  Dafür wird stets
	     <acronym>NFS</acronym> verwendet.</para>
	</listitem>
      </itemizedlist>

      <para>Weitere Informationen finden Sie in &man.diskless.8;.</para>
    </sect2>

    <sect2>
      <title>Installationsanweisungen</title>

      <sect3>
	<title>Konfiguration unter Verwendung von
	  <application>ISC DHCP</application></title>

	<indexterm>
	  <primary>DHCP</primary>
	  <secondary>plattenloser Betrieb</secondary>
	</indexterm>

	<para>Der <application>ISC DHCP</application>-Server kann
	  Anfragen sowohl von BOOTP als auch von DHCP beantworten.
	</para>

	<para><application>isc-dhcp 3.1</application> ist nicht Teil
	  des Basissystems.  Sie müssen es daher zuerst
	  installieren.  Verwenden Sie dazu den Port
	  <package>net/isc-dhcp31-server</package>
	  oder das entsprechende Paket.</para>

	<para>Nachdem <application>ISC DHCP</application> installiert
	  ist, muss das Programm konfiguriert werden (normalerweise in
	  <filename>/usr/local/etc/dhcpd.conf</filename>).  Im
	  folgenden Beispiel verwendet Rechner <systemitem>margaux</systemitem>
	  <application>Etherboot</application>, während Rechner
	  <systemitem>corbieres</systemitem> <acronym>PXE</acronym> verwendet:
	</para>

	<programlisting>          default-lease-time 600;
          max-lease-time 7200;
          authoritative;

          option domain-name "example.com";
          option domain-name-servers 192.168.4.1;
          option routers 192.168.4.1;

          subnet 192.168.4.0 netmask 255.255.255.0 {
            use-host-decl-names on; <co xml:id="co-dhcp-host-name"/>
            option subnet-mask 255.255.255.0;
            option broadcast-address 192.168.4.255;

            host margaux {
              hardware ethernet 01:23:45:67:89:ab;
              fixed-address margaux.example.com;
              next-server 192.168.4.4;<co xml:id="co-dhcp-next-server"/>
              filename "/tftpboot/kernel.diskless";<co xml:id="co-dhcp-filename"/>
              option root-path "192.168.4.4:/data/misc/diskless";<co xml:id="co-dhcp-root-path"/>
            }
           host corbieres {
             hardware ethernet 00:02:b3:27:62:df;
              fixed-address corbieres.example.com;
              next-server 192.168.4.4;
              filename "pxeboot";
              option root-path "192.168.4.4:/data/misc/diskless";
            }
          }
        </programlisting>

	<calloutlist>
	  <callout arearefs="co-dhcp-host-name"><para>Diese Option
	    weist <application>dhcpd</application> an, den Wert der
	    <literal>host</literal>-Deklaration als Rechnernamen des
	    plattenlosen Rechners zu senden.  Alternativ kann man der
	    <literal>host</literal>-Deklaration Folgendes
	    hinzufügen: <literal>option host-name
	    margaux</literal></para>
	  </callout>

	  <callout arearefs="co-dhcp-next-server"><para>Die Anweisung
	    <literal>next-server</literal> bestimmt den
	    <acronym>TFTP</acronym>- oder
	    <acronym>NFS</acronym>-Server, von dem der Loader oder
	    der Kernel geladen werden (in der Voreinstellung ist das
	    der <acronym>DHCP</acronym>-Server selbst).</para>
	  </callout>

	  <callout arearefs="co-dhcp-filename"><para>Die Anweisung
	    <literal>filename</literal> bestimmt die Datei, die
	    <application>Etherboot</application> als nächstes
	    lädt.  Das genaue Format hängt von der
	    gewählten Transfermethode ab.
	    <application>Etherboot</application> kann sowohl mit
	    <acronym>NFS</acronym> als auch mit
	    <acronym>TFTP</acronym> kompiliert werden.  In der
	    Voreinstellung wird der &os;-Port mit
	    <acronym>NFS</acronym>-Unterstützung kompiliert.
	    <acronym>PXE</acronym> verwendet <acronym>TFTP</acronym>,
	    daher wird im Beispiel ein relativer Dateipfad verwendet.
	    Dies kann aber, je nach Konfiguration des
	    <acronym>TFTP</acronym>-Servers, auch anders sein.
	    Beachten Sie, dass <acronym>PXE</acronym>
	    <filename>pxeboot</filename> lädt, und nicht den
	    Kernel.  Es ist auch möglich, das Verzeichnis
	    <filename>/boot</filename> einer
	    &os;-CD-ROM von <filename>pxeboot</filename> laden zu
	    lassen.  &man.pxeboot.8; kann einen
	    <filename>GENERIC</filename>-Kernel laden, dadurch ist es
	    möglich, <acronym>PXE</acronym> von einer entfernten
	    CD-ROM zu starten.</para>
	  </callout>

	  <callout arearefs="co-dhcp-root-path"><para>Die Option
	    <literal>root-path</literal> bestimmt den Pfad des
	    root-Dateisystems in normaler NFS-Schreibweise.  Wird
	    <acronym>PXE</acronym> verwendet, ist es möglich,
	    die IP-Adresse des Rechners wegzulassen, solange nicht
	    die Kerneloption BOOTP aktiviert wird.  Der
	    <acronym>NFS</acronym>-Server entspricht in diesem Fall
	    dem <acronym>TFTP</acronym>-Server.</para>
	  </callout>
	</calloutlist>
      </sect3>

      <sect3>
	<title>Konfiguration bei Verwendung von BOOTP</title>

	<indexterm>
	  <primary>BOOTP</primary>
	  <secondary>plattenloser Betrieb</secondary>
	</indexterm>

	<para>Es folgt nun eine der Konfiguration von DHCP
	  entsprechende Konfiguration (für einen Client) für
	  <application>bootpd</application>.  Zu finden ist die
	  Konfigurationsdatei unter <filename>/etc/bootptab</filename>.
	</para>

	<para>Beachten Sie bitte, dass
	  <application>Etherboot</application> mit der Option
	  <literal>NO_DHCP_SUPPORT</literal> kompiliert werden muss,
	  damit BOOTP verwendet werden kann.  <acronym>PXE</acronym>
	  hingegen <emphasis>benötigt</emphasis>
	  <acronym>DHCP</acronym>.  Der einzige offensichtliche
	  Vorteil von <application>bootpd</application> ist, dass es
	  bereits im Basissystem vorhanden ist.</para>

	<programlisting>.def100:\
  :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
  :sm=255.255.255.0:\
  :ds=192.168.4.1:\
  :gw=192.168.4.1:\
  :hd="/tftpboot":\
  :bf="/kernel.diskless":\
  :rp="192.168.4.4:/data/misc/diskless":

margaux:ha=0123456789ab:tc=.def100</programlisting>
      </sect3>

      <sect3>
        <title>Ein Startprogramm unter Verwendung von
          <application>Etherboot</application> erstellen</title>

        <indexterm>
          <primary>Etherboot</primary>
        </indexterm>

	<para>Die <link xlink:href="http://etherboot.sourceforge.net">
	  Internetseite von Etherboot</link> enthält
	  <link xlink:href="http://etherboot.sourceforge.net/doc/html/userman/t1.html">
          ausführliche Informationen</link>, die zwar vor allem
          für Linux gedacht sind, aber dennoch nützliche
          Informationen enthalten.  Im Folgenden wird daher nur grob
          beschrieben, wie Sie <application>Etherboot</application> auf
          einem FreeBSD-System einsetzen können.</para>

        <para>Als Erstes müssen Sie
          <package>net/etherboot</package> als Paket
          oder als Port installieren.</para>

	<para>Sie können <application>Etherboot</application> so
	  konfigurieren, dass <acronym>TFTP</acronym> anstelle von
	  <acronym>NFS</acronym> verwendet wird, indem Sie die Datei
	  <filename>Config</filename> im Quellverzeichnis von
	  <application>Etherboot</application> bearbeiten.</para>

        <para>Für unsere Installation verwenden wir eine
          Startdiskette.  Für Informationen zu anderen Methoden
	  (PROM oder &ms-dos;-Programme) lesen Sie bitte die
	  Dokumentation zu <application>Etherboot</application>.</para>

        <para>Um eine Startdiskette zu erzeugen, legen Sie eine Diskette
          in das Laufwerk des Rechners ein, auf dem Sie
          <application>Etherboot</application> installiert haben.  Danach
          wechseln Sie in das Verzeichnis <filename>src</filename> des
          <application>Etherboot</application>-Verzeichnisbaums und geben
          Folgendes ein:</para>

	<screen>&prompt.root; <userinput>gmake bin32/devicetype.fd0</userinput></screen>

        <para><replaceable>devicetype</replaceable> hängt vom Typ
          der Ethernetkarte ab, über die der plattenlose Rechner
          verfügt.  Lesen Sie dazu <filename>NIC</filename> im
          gleichen Verzeichnis, um den richtigen Wert für
        <replaceable>devicetype</replaceable> zu bestimmen.</para>
      </sect3>

      <sect3>
	<title>Das System mit <acronym>PXE</acronym> starten</title>

	<para>In der Voreinstellung lädt der
	  &man.pxeboot.8;-Loader den Kernel über
	  <acronym>NFS</acronym>.  Soll stattdessen
	  <acronym>TFTP</acronym> verwendet werden, muss beim
	  Kompilieren die Option
	  <literal>LOADER_TFTP_SUPPORT</literal> in der Datei
	  <filename>/etc/make.conf</filename> eingetragen sein. Sehen
	  Sie sich die Datei
	  <filename>/usr/share/examples/etc/make.conf</filename>
	  für weitere Anweisungen an.</para>

	<para>Es gibt zwei Optionen für
	  <filename>make.conf</filename>, die nützlich sein
	  können, wenn Sie eine plattenlose serielle Konsole
	  einrichten wollen:
	  <literal>BOOT_PXELDR_PROBE_KEYBOARD</literal>, und
	  <literal>BOOT_PXELDR_ALWAYS_SERIAL</literal>.</para>

	<para>Um <acronym>PXE</acronym> beim Systemstart zu verwenden,
	  müssen Sie im <acronym>BIOS</acronym> des Rechner die
	  Option <literal>Über das Netzwerk starten</literal>
	  aktivieren.  Alternativ können Sie während der
	  PC-Initialisierung auch eine Funktionstaste drücken.
	</para>
      </sect3>

      <sect3>
	<title>Serverkonfiguration - <acronym>TFTP</acronym> und
	  <acronym>NFS</acronym></title>

        <indexterm>
          <primary>TFTP</primary>
          <secondary>plattenloser Betrieb</secondary>
        </indexterm>

        <indexterm>
          <primary>NFS</primary>
          <secondary>plattenloser Betrieb</secondary>
        </indexterm>

	<para>Wenn Sie <acronym>PXE</acronym> oder
	  <application>Etherboot</application> so konfiguriert haben,
	  dass diese <acronym>TFTP</acronym> verwenden, müssen
	  Sie auf dem Dateiserver <application>tftpd</application>
	  aktivieren:</para>

        <procedure>
          <step>
            <para>Erzeugen Sie ein Verzeichnis, in dem
	      <application>tftpd</application> seine Dateien ablegt,
              beispielsweise <filename>/tftpboot</filename>.</para>
          </step>

          <step>
            <para>Fügen Sie folgende Zeile in
              <filename>/etc/inetd.conf</filename> ein:</para>

            <programlisting>tftp    dgram   udp     wait    root  /usr/libexec/tftpd    tftpd -s /tftpboot</programlisting>

            <note><para>Anscheinend benötigen zumindest einige
	      <acronym>PXE</acronym>-Versionen die
	      <acronym>TCP</acronym>-Version von
	      <acronym>TFTP</acronym>.  Sollte dies bei Ihnen der
              Fall sein, fügen Sie eine zweite Zeile ein, in der
              Sie <literal>dgram udp</literal> durch
              <literal>stream tcp</literal> ersetzen.</para>
            </note>
          </step>

          <step>
	    <para>Weisen Sie <application>inetd</application> an, seine
	      Konfiguration erneut einzulesen (Damit der folgende
	      Befehl funktioniert, muss die Option
	      <option>inetd_enable="YES"</option> in der Datei
	      <filename>/etc/rc.conf</filename> vorhanden sein.):</para>

            <screen>&prompt.root; <userinput>/etc/rc.d/inetd restart</userinput></screen>
          </step>
        </procedure>

        <para>Sie können das Verzeichnis
          <filename>/tftpboot</filename> an einem beliebigen Ort auf dem
          Server ablegen.  Stellen Sie aber sicher, dass Sie diesen Ort
          sowohl in <filename>inetd.conf</filename> als auch in
	  <filename>dhcpd.conf</filename> eingetragen haben.</para>

        <para>Außerdem müssen Sie NFS aktivieren und die
          entsprechenden Verzeichnisse exportieren.</para>

        <procedure>
          <step>
            <para>Fügen Sie folgende Zeile in
              <filename>/etc/rc.conf</filename> ein:</para>

            <programlisting>nfs_server_enable="YES"</programlisting>
          </step>

          <step>
            <para>Exportieren Sie das Verzeichnis, in dem sich das
              Wurzelverzeichnis für den plattenlosen Betrieb
              befindet, indem Sie folgende Zeile in
              <filename>/etc/exports</filename> einfügen (passen
	      Sie dabei den <foreignphrase>mountpoint</foreignphrase>
	      an und ersetzen Sie
	      <replaceable>margaux corbieres</replaceable> durch den
	      Namen Ihres plattenlosen Rechners):</para>

            <programlisting><replaceable>/data/misc</replaceable> -alldirs -ro <replaceable>margaux</replaceable></programlisting>
          </step>

          <step>
	    <para>Weisen sie nun <application>mountd</application> an,
	      seine Konfigurationsdatei erneut einzulesen.  Wenn Sie
	      <acronym>NFS</acronym> erst in der Datei
	      <filename>/etc/rc.conf</filename> aktivieren mussten,
              sollten Sie stattdessen den Rechner neu starten.  Dadurch
              wird die Konfigurationsdatei ebenfalls neu eingelesen.
            </para>

            <screen>&prompt.root; <userinput>/etc/rc.d/mountd restart</userinput></screen>
          </step>
        </procedure>
      </sect3>

      <sect3>
        <title>Einen plattenlosen Kernel erzeugen</title>

        <indexterm>
          <primary>plattenloser Betrieb</primary>
          <secondary>Kernelkonfiguration</secondary>
        </indexterm>

	<para>Wenn Sie <application>Etherboot</application> verwenden,
	  müssen Sie in die Kernelkonfigurationsdatei Ihres
	  plattenlosen Clients zusätzlich folgende Optionen
	  einfügen:</para>

        <programlisting>options     BOOTP          # Use BOOTP to obtain IP address/hostname
options     BOOTP_NFSROOT  # NFS mount root file system using BOOTP info</programlisting>

        <para>Außerdem können Sie die Optionen
	  <literal>BOOTP_NFSV3</literal>,
	  <literal>BOOT_COMPAT</literal> sowie
          <literal>BOOTP_WIRED_TO</literal> verwenden (sehen Sie sich
	  dazu auch die Datei <filename>NOTES</filename> an).</para>

	 <para>Die Namen dieser Optionen sind historisch bedingt.
	   Sie ermöglichen eine unterschiedliche Verwendung von
	   <acronym>DHCP</acronym> und BOOTP innerhalb des Kernels.
	   Es ist auch möglich, eine strikte Verwendung von BOOTP
	   oder <acronym>DHCP</acronym> zu erzwingen.</para>

        <para>Erzeugen Sie den neuen Kernel (lesen Sie dazu auch
	  <xref linkend="kernelconfig"/>) und kopieren Sie ihn an den
	  in <filename>dhcpd.conf</filename> festgelegten Ort.</para>

	<note><para>Wenn Sie <acronym>PXE</acronym> verwenden, ist die
	    Erzeugung eines Kernels zwar nicht unbedingt nötig, sie
	    wird allerdings dennoch empfohlen.  Die Aktivierung dieser
	    Optionen bewirkt, dass die Anzahl der möglichen
	    <acronym>DHCP</acronym>-Anforderungen während des
	    Kernelstarts erhöht wird.  Ein kleiner Nachteil sind
	    eventuell auftretende Inkonsistenzen zwischen den neuen
	    Werten und den von &man.pxeboot.8; erhaltenen Werten.  Der
	    große Vorteil dieser Variante ist es, dass dabei der
	    Rechnername gesetzt wird, den Sie ansonsten durch eine
	    andere Methode, beispielsweise in einer clientspezifischen
	    <filename>rc.conf</filename>-Datei festlegen müssten.
	  </para>
	</note>

	<note><para>Damit der Kernel von
	    <application>Etherboot</application> geladen werden kann,
	    müssen <foreignphrase>device hints</foreignphrase> im
	    Kernel einkompiliert sein.  Dazu setzen Sie normalerweise
	    folgende Option in die Kernelkonfigurationsdatei (sehen Sie
	    sich dazu auch die kommentierte Datei
	    <filename>NOTES</filename> an):</para>

	  <programlisting>hints         "GENERIC.hints"</programlisting>
	</note>
      </sect3>

      <sect3>
        <title>Das root-Dateisystem erzeugen</title>

        <indexterm>
          <primary>Root-Dateisystem</primary>
	  <secondary>plattenloser Betrieb</secondary>
        </indexterm>

        <para>Sie müssen für den plattenlosen Rechner ein
          root-Dateisystem erzeugen, und zwar an dem in
          <filename>dhcpd.conf</filename> als
	  <literal>root-path</literal> festgelegten Ort.</para>

	<sect4>
	  <title><command>make world</command> zum Füllen des
	    Dateisystems einsetzen</title>

	  <para>Diese schnelle Methode installiert ein komplettes
	    <quote>jungfräuliches</quote> System (und nicht nur ein
	    root-Dateisystem) nach <envar>DESTDIR</envar>.  Dazu
	    müssen Sie lediglich das folgende Skript
	    ausführen:</para>

	  <programlisting>#!/bin/sh
export DESTDIR=/data/misc/diskless
mkdir -p ${DESTDIR}
cd /usr/src; make buildworld &amp;&amp; make buildkernel
make installworld &amp;&amp; make installkernel
cd /usr/src/etc; make distribution</programlisting>

	  <para>Danach müssen Sie noch die dadurch in
	    <envar>DESTDIR</envar> erzeugten Dateien
	    <filename>/etc/rc.conf</filename> sowie
	    <filename>/etc/fstab</filename> Ihren Wünschen
	    anpassen.</para>
	</sect4>
      </sect3>

      <sect3>
        <title>Den Auslagerungsbereich konfigurieren</title>

	<para>Falls nötig, kann eine auf dem
	  <acronym>NFS</acronym>-Server liegende Datei als
	  Auslagerungsdatei eingerichtet werden.</para>

	<sect4>
	  <title>Eine <acronym>NFS</acronym>-Auslagerungsdatei
	    einrichten</title>

	  <para>Der Kernel unterstützt beim Systemstart keine
	    <acronym>NFS</acronym>-Auslagerungsdatei.  Diese muss daher
	    in den Startskripten aktiviert werden, indem ein
	    beschreibbares Dateisystem eingehängt wird, um dort
	    die Auslagerungsdatei zu erzeugen und zu aktivieren.  Um
	    eine Auslagerungsdatei zu erzeugen, gehen Sie wie folgt
	    vor:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=/path/to/swapfile bs=1k count=1 oseek=100000</userinput></screen>

	  <para>Um die Auslagerungsdatei zu aktivieren, fügen Sie
	    folgende Zeile in <filename>rc.conf</filename> ein:</para>

	  <programlisting>swapfile=<replaceable>/path/to/swapfile</replaceable></programlisting>
	</sect4>
      </sect3>

      <sect3>
        <title>Verschiedenes</title>

        <sect4>
          <title>Schreibgeschütztes Dateisystem
	    <filename>/usr</filename></title>

          <indexterm>
            <primary>plattenloser Betrieb</primary>
            <secondary>/usr schreibgeschützt</secondary>
          </indexterm>

          <para>Wenn am plattenlosen Rechner X läuft, müssen
            Sie die Konfigurationsdatei von
            <application>XDM</application> anpassen, da Fehlermeldungen
            in der Voreinstellung auf <filename>/usr</filename>
            geschrieben werden.</para>
        </sect4>

        <sect4>
          <title>Der Server läuft nicht unter FreeBSD</title>

	  <para>Wenn das root-Dateisystem nicht auf einem
	    FreeBSD-Rechner liegt, muss das Dateisystem zuerst unter
	    FreeBSD erzeugt werden.  Anschließend wird es
	    beispielsweise mit <command>tar</command> oder
	    <command>cpio</command> an den gewünschten Ort
	    kopiert.</para>

	  <para>Dabei kann es Probleme mit den Gerätedateien
	    in <filename>/dev</filename> geben, die durch eine
	    unterschiedliche Darstellung der  Major- und Minor-Number
	    von Geräten auf beiden Systemen hervorgerufen werden.
	    Eine Problemlösung besteht darin, das root-Verzeichnis
	    auf einem FreeBSD-Rechner einzuhängen und die
	    Gerätedateien dort mit &man.devfs.5; zu erzeugen.</para>
        </sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="network-isdn">
    <title>ISDN &ndash; diensteintegrierendes digitales Netzwerk</title>

    <indexterm>
      <primary>ISDN</primary>
    </indexterm>

    <para>Eine gute Quelle für Informationen zu ISDN ist die
      <link xlink:href="http://www.alumni.caltech.edu/~dank/isdn/">
      ISDN-Seite</link> von Dan Kegel.</para>

    <para>Welche Informationen finden Sie in diesem Abschnitt?</para>

    <itemizedlist>
      <listitem>
        <para>Wenn Sie in Europa leben, könnte der Abschnitt
          über ISDN-Karten für Sie interessant sein.</para>
      </listitem>

      <listitem>
        <para>Wenn Sie ISDN hauptsächlich dazu verwenden wollen, um
          sich über einen Anbieter ins Internet einzuwählen,
          sollten Sie den Abschnitt über Terminaladapter lesen.
          Dies ist die flexibelste Methode, die auch die wenigsten
          Probleme verursacht.</para>
      </listitem>

      <listitem>
        <para>Wenn Sie zwei Netzwerke miteinander verbinden, oder sich
          über eine ISDN-Standleitung mit dem Internet verbinden
          wollen, finden Sie entsprechende Informationen im Abschnitt
          über Router und Bridges.</para>
      </listitem>
    </itemizedlist>

    <para>Bei der Wahl der gewünschten Lösung sind die
      entstehenden Kosten ein entscheidender Faktor.  Die folgenden
      Beschreibungen reichen von der billigsten bis zur teuersten
      Variante.</para>

    <sect2 xml:id="network-isdn-cards">
      <info><title>ISDN-Karten</title>
        <authorgroup>
          <author><personname><firstname>Hellmuth</firstname><surname>Michaelis</surname></personname><contrib>Beigetragen von </contrib></author>
        </authorgroup>
      </info>

      

      <indexterm>
        <primary>ISDN</primary>
        <secondary>Karten</secondary>
      </indexterm>

      <para>Das ISDN-Subsystem von FreeBSD unterstützt den
        DSS1/Q.931- (oder Euro-ISDN)-Standard nur für passive
        Karten.  Zusätzlich werden aber auch einige
        aktive Karten unterstützt, bei denen die Firmware auch
        andere Signalprotokolle unterstützt;  dies schließt
        auch die erste ISDN-Karte mit
        Primärmultiplex-Unterstützung mit ein.</para>

      <para><application>isdn4bsd</application> ermöglicht es
	Ihnen, sich unter Nutzung von
	<emphasis>IP over raw HDLC</emphasis> oder
        <emphasis>synchronem PPP</emphasis> mit anderen ISDN-Routern zu
        verbinden.  Dazu verwenden Sie entweder Kernel-&man.ppp.8;
	(via <literal>isppp</literal>, einem modifizierten
	sppp-Treiber), oder Sie benutzen User-&man.ppp.8;.  Wenn Sie
	User-&man.ppp.8; verwenden, können Sie zwei oder mehrere
	ISDN-B-Kanäle bündeln.  Im Paket enthalten ist auch
	ein Programm mit Anrufbeantworterfunktion sowie verschiedene
	Werkzeuge, wie ein Softwaremodem, das 300&nbsp;Baud
	unterstützt.</para>

      <para>FreeBSD unterstützt eine ständig wachsende Anzahl
        von PC-ISDN-Karten, die weltweit erfolgreich eingesetzt werden.
      </para>

      <para>Von FreeBSD unterstützte passive ISDN-Karten enthalten
        fast immer den ISAC/HSCX/IPAC ISDN-Chipsatz von Infineon
        (ehemals Siemens).  Unterstützt werden aber auch Karten mit
        Cologne Chip (diese allerdings nur für den ISA-Bus),
        PCI-Karten mit Winbond W6692 Chipsatz, einige Karten mit dem
        Tiger 300/320/ISAC Chipsatz sowie einige Karten mit einem
        herstellerspezifischen Chipsatz, wie beispielsweise die
        Fritz!Card PCI V.1.0 und die Fritz!Card PnP von AVM.</para>

      <para>An aktiven ISDN-Karten werden derzeit die AVM B1 BRI-Karten
        (ISA und PCI-Version) sowie die AVM T1 PRI-Karten (PCI-Version)
        unterstützt.</para>

      <para>Informationen zu <application>isdn4bsd</application> finden
	Sie auf der
        <link xlink:href="http://www.freebsd-support.de/i4b/">Internetseite</link>
        von <application>isdn4bsd</application>.  Dort finden Sie auch
        Verweise zu Tipps, Korrekturen, sowie weiteren Informationen,
        wie dem
        <link xlink:href="http://people.FreeBSD.org/~hm/">isdn4bsd-Handbuch</link>.
      </para>

      <para>Falls Sie an der Unterstützung eines zusätzlichen
        ISDN-Protokolls, einer weiteren ISDN-Karte oder an einer anderen
        Erweiterung von <application>isdn4bsd</application> interessiert
        sind, wenden Sie sich bitte an &a.hm;.</para>

      <para>Für Fragen zur Installation, Konfiguration und zu
        sonstigen Problemen von <application>isdn4bsd</application> gibt
        es die Mailingliste &a.isdn.name;.</para>
    </sect2>

    <sect2>
      <title>ISDN-Terminaladapter</title>

      <indexterm>
        <primary>Terminaladapter</primary>
      </indexterm>

      <para>Terminaladapter (TA) sind für ISDN, was Modems für
        analoge Telefonleitungen sind.</para>

      <indexterm>
        <primary>Modem</primary>
      </indexterm>

      <para>Die meisten Terminaladapter verwenden den
	Standardbefehlssatz für Modems von Hayes (AT-Kommandos) und
	können daher als Modemersatz verwendet werden.</para>

      <para>Ein Terminaladapter funktioniert prinzipiell wie ein Modem,
	allerdings erfolgt der Verbindungsaufbau um einiges schneller.
	Die Konfiguration von <link linkend="ppp">PPP</link> entspricht
	dabei exakt der eines Modems.  Stellen Sie dabei allerdings
	die serielle Geschwindigkeit so hoch wie möglich ein.
      </para>

      <indexterm>
        <primary>PPP</primary>
      </indexterm>

      <para>Der Hauptvorteil bei der Verwendung eines Terminaladapters
	zur Verbindung mit einem Internetanbieter ist die
	Möglichkeit zur Nutzung von dynamischem PPP.  Da
	IP-Adressen immer knapper werden, vergeben die meisten Provider
	keine statischen IP-Adressen mehr.  Die meisten Router
	unterstützen allerdings keine dynamische Zuweisung von
	IP-Adressen.</para>

      <para>Der PPP-Daemon bestimmt die Stabilität und
	Eigenschaften der Verbindung, wenn Sie einen Terminaladapter
	verwenden.  Daher können Sie unter FreeBSD einfach von
	einer Modemverbindung auf eine ISDN-Verbindung wechseln, wenn
	Sie PPP bereits konfiguriert haben.  Allerdings bedeutet
	dies auch, das bereits bestehende Probleme mit PPP auch unter
	ISDN auftreten werden.</para>

      <para>Wenn Sie an maximaler Stabilität interessiert sind,
        verwenden Sie Kernel-<link linkend="ppp">PPP</link>, und
	nicht das <link linkend="userppp">User-PPP</link>.</para>

      <para>Folgende Terminaladapter werden von FreeBSD
	unterstützt:</para>

      <itemizedlist>
        <listitem>
          <para>Motorola BitSurfer und Bitsurfer Pro</para>
        </listitem>

        <listitem>
          <para>Adtran</para>
        </listitem>
      </itemizedlist>

      <para>Die meisten anderen Terminaladapter werden wahrscheinlich
	ebenfalls funktionieren, da die Hersteller von Terminaladaptern
	darauf achten, dass ihre Produkte den Standardbefehlssatz
	möglichst gut unterstützen.</para>

      <para>Das wirkliche Problem mit einem externen Terminaladapter ist,
        dass, ähnlich wie bei Modems, eine gute serielle Karte
        eine Grundvoraussetzung ist.</para>

      <para>Sie sollten sich die
        <link xlink:href="&url.articles.serial-uart.en;/index.html">
        Anleitung für die Nutzung serieller Geräte unter
        FreeBSD</link> ansehen, wenn Sie detaillierte Informationen
        über serielle Geräte und die Unterschiede zwischen
	asynchronen und synchronen seriellen Ports benötigen.
      </para>

      <para>Ein Terminaladapter, der an einem (asynchronen)
	seriellen Standardport angeschlossen ist, beschränkt
	Sie auf 115,2&nbsp;Kbs.  Dies
        selbst dann, wenn Sie eine Verbindung mit 128&nbsp;Kbs haben.
        Um die volle Leistungsfähigkeit von ISDN (128&nbsp;Kbs)
        nutzen zu können, müssen Sie den Terminaladapter
	daher an eine synchrone serielle Karte anschließen.</para>

      <para>Kaufen Sie keinen internen Terminaladapter in der Hoffnung,
        damit das synchron/asynchron-Problem vermeiden zu können.
	Interne Terminaladapter haben einen (asynchronen) seriellen
	Standardportchip eingebaut.  Der einzige Vorteil interner
	Terminaladapter ist es, dass Sie ein serielles sowie ein
	Stromkabel weniger benötigen.</para>

      <para>Eine synchrone Karte mit einem Terminaladapter ist
	mindestens so schnell wie ein autonomer ISDN-Router,
	und, in Kombination mit einem einfachen 386-FreeBSD-System,
	wahrscheinlich flexibler.</para>

      <para>Die Entscheidung zwischen synchroner Karte/Terminaladapter
	und einem autonomen ISDN-Router ist beinahe eine religiöse
        Angelegenheit.  Zu diesem Thema gibt es viele Diskussionen
        in den Mailinglisten.  Suchen Sie in den
        <link xlink:href="&url.base;/search/index.html"> Archiven</link>
        danach, wenn Sie an der kompletten Diskussion interessiert
        sind.</para>
    </sect2>

    <sect2>
      <title>ISDN-Bridges und Router</title>

      <indexterm>
        <primary>ISDN</primary>
        <secondary>Autonome Bridge/Router</secondary>
      </indexterm>

      <para>ISDN-Bridges und Router sind keine Eigenheit von
        FreeBSD oder eines anderen Betriebssystems.  Für eine
        vollständigere Beschreibung von Routing und
        Netzwerkkopplungen mit einer Bridge informieren Sie sich
        bitte durch weiterführende Literatur.</para>

      <para>In diesem Abschnitt werden die Begriffe Router und
        Bridge synonym verwendet.</para>

      <para>ISDN-Router und Bridges werden immer günstiger und
	damit auch immer beliebter.  Ein ISDN-Router ist eine kleine
	Box, die direkt an Ihr lokales Ethernet-Netzwerk angeschlossen
	wird und sich mit einem Router oder einer Bridge verbindet.
	Die eingebaute Software ermöglicht die Kommunikation
	über PPP oder andere beliebte Protokolle.</para>

      <para>Ein Router ermöglicht einen deutlich höheren
        Datendurchsatz als ein herkömmlicher Terminaladapter,
	da er eine vollsynchrone ISDN-Verbindung nutzt.</para>

      <para>Das Hauptproblem mit ISDN-Routern und Bridges ist,
        dass die Zusammenarbeit zwischen Geräten verschiedener
        Hersteller nach wie vor ein Problem ist.  Wenn Sie sich auf
        diese Weise mit einem Internetanbieter verbinden wollen,
        klären Sie daher vorher ab, welche Anforderungen Ihre
        Geräte erfüllen müssen.</para>

      <para>Eine ISDN-Bridge ist eine einfache und wartungsarme
	Lösung, zwei Netze, beispielsweise Ihr privates Netz
	und Ihr Firmennetz, miteinander zu verbinden.  Da Sie die
        technische Ausstattung für beide Seiten kaufen müssen,
        ist sichergestellt, dass die Verbindung funktionieren
        wird.</para>

      <para>Um beispielsweise einen privaten Computer oder eine
        Zweigstelle mit dem Hauptnetzwerk zu verbinden, könnte
        folgende Konfiguration verwendet werden:</para>

      <example>
        <title>Kleines Netzwerk (Privatnetz)</title>

        <indexterm>
          <primary>10 base 2</primary>
        </indexterm>

        <para>Das Netzwerk basiert auf der Bustopologie mit 10base2
          Ethernet (<quote>Thinnet</quote>).  Falls nötig, stellen
          Sie die Verbindung zwischen Router und Netzwerkkabel mit einem
          AUI/10BT-Transceiver her.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="advanced-networking/isdn-bus"/>
          </imageobject>

          <textobject>
            <literallayout class="monospaced">
---Sun Workstation
|
---FreeBSD Rechner
|
---Windows 95
|
Autonomer Router
   |
ISDN BRI Verbindung
            </literallayout>
          </textobject>

          <textobject>
            <phrase>10Base2 - Ethernet</phrase>
          </textobject>
        </mediaobject>

        <para>Wenn Sie nur einen einzelnen Rechner verbinden wollen,
          können Sie auch ein Twisted-Pair-Kabel (Cross-Over)
          verwenden, das direkt an den Router angeschlossen wird.</para>
      </example>

      <example>
        <title>Großes Netzwerk (Firmennetz)</title>

        <indexterm>
          <primary>10 base T</primary>
        </indexterm>

        <para>Dieses Netzwerk basiert auf der Sterntopologie und 10baseT
          Ethernet (<quote>Twisted Pair</quote>).</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="advanced-networking/isdn-twisted-pair"/>
          </imageobject>

          <textobject>
            <literallayout class="monospaced">
-------Novell Server
    | H |
    |   ---Sun
    |   |
    | U ---FreeBSD
    |   |
    |   ---Windows 95
    | B |
    |___---Autonomer Router
                |
        ISDN BRI Verbindung
            </literallayout>
          </textobject>

          <textobject>
            <phrase>ISDN Netzwerkdiagramm</phrase>
          </textobject>
        </mediaobject>
      </example>

      <para>Ein großer Vorteil der meisten Router und Bridges
	ist es, dass man <emphasis>gleichzeitig</emphasis> zwei
	<emphasis>unabhängige</emphasis> PPP-Verbindungen
	zu zwei verschiedenen Zielen aufbauen kann.  Diese
        Funktion bieten die meisten Terminaladapter nicht.  Die
        Ausnahme sind spezielle (meist teure) Modelle, die über
        zwei getrennte serielle Ports verfügen.  Verwechseln Sie
        dies aber nicht mit Kanalbündelung oder MPP.</para>

      <para>Dies kann sehr nützlich sein, wenn Sie eine
        ISDN-Standleitung in Ihrem Büro haben, die sie
        aufteilen wollen, ohne eine zusätzliche ISDN-Leitung
        zu installieren.  Ein ISDN-Router kann über einen B-Kanal
        (64&nbsp;Kbps) eine dedizierte Verbindung ins Internet aufbauen,
        und gleichzeitig den anderen B-Kanal für eine separate
        Datenverbindung nutzen.  Der zweite B-Kanal kann beispielsweise
        für ein- oder ausgehende Verbindungen verwendet werden.
        Sie können ihn aber auch dynamisch mit dem ersten B-Kanal
        bündeln, um Ihre Bandbreite zu erhöhen.</para>

      <indexterm>
        <primary>IPX/SPX</primary>
      </indexterm>

      <para>Eine Ethernet-Bridge kann Daten nicht nur im IP-Protokoll,
        sondern auch in beliebigen anderen Protokollen versenden.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="network-natd">
    <info><title>NAT - Network Address Translation</title>
      <authorgroup>
        <author><personname><firstname>Chern</firstname><surname>Lee</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
    </info>

    

    <sect2 xml:id="network-natoverview">
      <title>Überblick</title>

      <indexterm>
        <primary><application>natd</application></primary>
      </indexterm>

      <para>&man.natd.8;, der Network-Address-Translation-Daemon von
        FreeBSD, akzeptiert ankommende Raw-IP-Pakete, ändert den
        Sender der Daten in den eigenen Rechner und leitet diese Pakete
        in den ausgehenden IP-Paketstrom um, indem IP-Adresse und Port
        des Senders so geändert werden, dass bei einer Antwort der
        ursprüngliche Sender wieder bestimmt und die Daten an
        ihn weitergeleitet werden können.</para>

      <indexterm><primary>Internet connection sharing</primary></indexterm>

      <indexterm><primary>NAT</primary></indexterm>

      <para>Der häufigste Grund für die Verwendung von NAT ist
        die gemeinsame Nutzung einer Internetverbindung.</para>
    </sect2>

    <sect2 xml:id="network-natsetup">
      <title>Einrichtung</title>

      <para>Wegen der begrenzten Verfügbarkeit von IPv4-Adressen
        und der gestiegenen Anzahl von Breitbandverbindungen über
        Kabelmodem oder DSL, wird die gemeinsame Nutzung von
        Internetverbindungen immer wichtiger.  Der &man.natd.8;-Daemon
        ermöglicht die Anbindung von mehreren Rechnern an das
        Internet unter Nutzung einer gemeinsamen Verbindung und einer
        IP-Adresse.</para>

      <para>Häufig soll ein über Kabelmodem oder DSL und eine
        IP-Adresse an das Internet angebundener Rechner mehreren
        Rechnern eines lokalen Netzwerks Internetdienste anbieten.</para>

      <para>Um dies zu ermöglichen, muss der FreeBSD-Rechner als
        Gateway fungieren.  Dazu sind zwei Netzwerkkarten notwendig.  Eine
        für die Verbindung zum Internet, die zweite für die
        Verbindung mit dem lokalen Netzwerk.  Sämtliche Rechner
        des lokalen Netzwerks sind über einen Hub oder einen Switch
        miteinander verbunden.</para>

      <note>
        <para>Es gibt verschiedene Möglichkeiten, ein LAN über
          ein &os;-Gateway an das Internet anzubinden.  Das folgende
          Beispiel beschreibt ein Gateway, das zumindest zwei
          Netzwerkkarten enthält.</para>
      </note>

      <mediaobject>
        <imageobject>
          <imagedata fileref="advanced-networking/natd"/>
        </imageobject>

        <textobject>
         <literallayout class="monospaced">  _______       __________       ________
 |       |     |          |     |        |
 |  Hub  |-----| Client B |-----| Router |----- Internet
 |_______|     |__________|     |________|
     |
 ____|_____
|          |
| Client A |
|__________|</literallayout>
        </textobject>

        <textobject>
          <phrase>Network Layout</phrase>
        </textobject>
      </mediaobject>

      <para>Eine derartige Netzwerkkonfiguration wird vor allem zur
        gemeinsamen Nutzung einer Internetverbindung verwendet.  Ein
        Rechner des lokalen Netzwerks (<acronym>LAN</acronym>) ist mit
        dem Internet verbunden.  Alle anderen Rechner des lokalen
        Netzwerks haben nur über diesen
        <quote>Gateway</quote>-Rechner Zugriff auf das Internet.</para>
    </sect2>

    <sect2 xml:id="network-natdloaderconfiguration">
      <title>Boot Loader Konfiguration</title>

      <indexterm>
        <primary>boot loader</primary>
        <secondary>configuration</secondary>
      </indexterm>

      <para>Die Kerneleigenschaften für Network Address Translation mit
        &man.natd.8; sind im <filename>GENERIC</filename>-Kernel nicht
        aktiviert, können aber bereits zur Bootzeit geladen werden, indem
        ein paar Zeilen in die Datei <filename>/boot/loader.conf</filename>
        hinzugefügt werden:</para>

      <programlisting>ipfw_load="YES"
ipdivert_load="YES"</programlisting>

      <para>Zusätzlich kann die Option
        <literal>net.inet.ip.fw.default_to_accept</literal> auf
        <literal>1</literal> gesetzt werden:</para>

      <programlisting>net.inet.ip.fw.default_to_accept="1"</programlisting>

      <note>
        <para>Es ist eine gute Idee, diese Option während den ersten
          Versuchen, eine Firewall und ein NAT-Gateway aufzusetzen, zu
          aktivieren.  Damit ist die Standardvorgehensweise von &man.ipfw.8;
          diejenige, <literal>allow ip from any to any</literal>, anstatt der
          weniger freizügigen <literal>deny ip from any to any</literal>.
          Es wird dadurch etwas schwieriger, sich aus Versehen nach einem
          Neustart aus dem System auszusperren.</para>
      </note>
    </sect2>

    <sect2 xml:id="network-natdkernconfiguration">
      <title>Kernelkonfiguration</title>

      <indexterm>
        <primary>Kernel</primary>
        <secondary>Konfiguration</secondary>
      </indexterm>

      <para>Wenn Module nicht in Frage kommen oder Sie bevorzugen, alle
        notwendigen Eigenschaften in den laufenden Kernel einzubauen,
        müssen die folgenden Optionen in die Kernelkonfigurationsdatei
        eingetragen werden:</para>

      <programlisting>options IPFIREWALL
options IPDIVERT</programlisting>

      <para>Die folgende Optionen können ebenfalls eingetragen
        werden:</para>

       <programlisting>options IPFIREWALL_DEFAULT_TO_ACCEPT
options IPFIREWALL_VERBOSE</programlisting>
    </sect2>

    <sect2 xml:id="network-natdsystemconfiguration">
      <title>System Bootkonfiguration</title>

      <para>Um Firewall- und NAT-Unterstützung zur Bootzeit zu aktivieren,
        tragen Sie Folgendes in <filename>/etc/rc.conf</filename> ein:</para>

      <programlisting>gateway_enable="YES" <co xml:id="co-natd-gateway-enable"/>
firewall_enable="YES" <co xml:id="co-natd-firewall-enable"/>
firewall_type="OPEN" <co xml:id="co-natd-firewall-type"/>
natd_enable="YES"
natd_interface="<replaceable>fxp0</replaceable>" <co xml:id="co-natd-natd-interface"/>
natd_flags="" <co xml:id="co-natd-natd-flags"/></programlisting>

      <calloutlist>
        <callout arearefs="co-natd-gateway-enable">
          <para>Richtet den Rechner als Gateway ein.  Die
            Ausführung von
            <command>sysctl net.inet.ip.forwarding=1</command>
            hätte den gleichen Effekt.</para>
        </callout>

        <callout arearefs="co-natd-firewall-enable">
          <para>Aktiviert die Firewallregeln in
            <filename>/etc/rc.firewall</filename> beim
            Systemstart.</para>
        </callout>

        <callout arearefs="co-natd-firewall-type">
          <para>Ein vordefinierter Satz von Firewallregeln, der alle
            Pakete durchlässt.  Sehen Sie sich
            <filename>/etc/rc.firewall</filename> an, wenn Sie diese
            Option verwenden wollen.</para>
        </callout>

        <callout arearefs="co-natd-natd-interface">
          <para>Die Netzwerkkarte, die Pakete weiterleitet (und mit dem
            Internet verbunden ist).</para>
        </callout>

        <callout arearefs="co-natd-natd-flags">
          <para>Zusätzliche Konfigurationsoptionen, die beim
            Systemstart an &man.natd.8; übergeben werden.</para>
        </callout>
      </calloutlist>

      <para>Durch die Definition dieser Optionen in
        <filename>/etc/rc.conf</filename> wird die Anweisung
        <command>natd -interface fxp0</command> beim Systemstart
        ausgeführt.  Dies kann aber auch manuell erfolgen.</para>

      <note>
        <para>Falls Sie viele Optionen an &man.natd.8; übergeben
          müssen, können Sie auch eine Konfigurationsdatei
          verwenden.  Dazu fügen Sie folgende Zeile in
          <filename>/etc/rc.conf</filename> ein:</para>

      <programlisting>natd_flags="-f /etc/natd.conf"</programlisting>

      <para>Die Datei <filename>/etc/natd.conf</filename> enthält
        verschiedene Konfigurationsoptionen, wobei jede Option in einer
        Zeile steht.  Das Beispiel im nächsten Abschnitt würde
        folgende Konfigurationsdatei verwenden:</para>

      <programlisting>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</programlisting>

      <para>Wenn Sie eine Konfigurationsdatei verwenden wollen, sollten
        Sie sich die Handbuchseite zu &man.natd.8; durchlesen,
        insbesondere den Abschnitt über die Nutzung der Option
        <option>-f</option>.</para>
      </note>

      <para>Jedem Rechner und jeder Schnittstelle des lokalen Netzwerks
        sollte eine IP-Adresse des im <link xlink:href="ftp://ftp.isi.edu/in-notes/rfc1918.txt">RFC 1918</link>
        definierten privaten Adressraums zugewiesen werden.  Der
        Standardgateway entspricht der internen IP-Adresse des
        <application>natd</application>-Rechners.</para>

      <para>Im Beispiel werden den LAN-Clients <systemitem>A</systemitem> und
        <systemitem>B</systemitem> die IP-Adressen
        <systemitem class="ipaddress">192.168.0.2</systemitem> und
        <systemitem class="ipaddress">192.168.0.3</systemitem> zugewiesen,
        während die LAN-Netzwerkkarte des
        <application>natd</application>-Rechners die IP-Adresse
        <systemitem class="ipaddress">192.168.0.1</systemitem> erhält.  Der
        <application>natd</application>-Rechner mit der IP-Adresse
        <systemitem class="ipaddress">192.168.0.1</systemitem> wird als
        Standardgateway für die Clients <systemitem>A</systemitem> und
        <systemitem>B</systemitem> gesetzt.  Die externe Netzwerkkarte des
        <application>natd</application>-Rechners muss für die
        korrekte Funktion von &man.natd.8; nicht konfiguriert
        werden.</para>
    </sect2>

    <sect2 xml:id="network-natdport-redirection">
      <title>Ports umleiten</title>

      <para>Wenn Sie &man.natd.8; verwenden, sind Ihre LAN-Clients von
        aussen nicht erreichbar.  LAN-Clients können zwar
        Verbindungen nach aussen aufbauen, sind aber für
        ankommende Verbindungen nicht erreichbar.  Wenn Sie
        Internetdienste auf einem LAN-Client anbieten wollen, haben Sie
        daher ein Problem.  Eine einfache Lösung ist die Umleitung
        von bestimmten Internetports des
        <application>natd</application>-Rechners auf einen LAN-Client.</para>

      <para>Beispielsweise könnte ein IRC-Server auf Client
        <systemitem>A</systemitem> und ein Webserver auf Client
        <systemitem>B</systemitem> laufen.  Damit diese Konfiguration
        funktioniert, müssen Verbindungen, die auf den Ports 6667
        (IRC) und 80 (Web) ankommen, auf die entsprechenden Clients
        umgeleitet werden.</para>

      <para>Dazu wird die Option <option>-redirect_port</option> unter
        Nutzung folgender Syntax an &man.natd.8; übergeben:</para>

      <programlisting>     -redirect_port proto targetIP:targetPORT[-targetPORT]
                 [aliasIP:]aliasPORT[-aliasPORT]
                 [remoteIP[:remotePORT[-remotePORT]]]</programlisting>

      <para>Für unser Beispiel heißt das:</para>

      <programlisting>    -redirect_port tcp 192.168.0.2:6667 6667
    -redirect_port tcp 192.168.0.3:80 80</programlisting>

      <para>Dadurch werden die entsprechenden
        <emphasis>tcp</emphasis>-Ports auf die jeweiligen LAN-Clients
        umgeleitet.</para>

      <para>Mit <option>-redirect_port</option> können auch ganze
        Portbereiche statt einzelner Ports umgeleitet werden.  So werden
        mit <replaceable>tcp 192.168.0.2:2000-3000
        2000-3000</replaceable> alle Verbindungen, die auf den Ports
        2000 bis 3000 ankommen, auf die entsprechenden Ports des Clients
        <systemitem>A</systemitem> umgeleitet.</para>

      <para>Diese Optionen können während des Betriebs von
        &man.natd.8; oder über die Option
        <literal>natd_flags=""</literal> in
        <filename>/etc/rc.conf</filename> gesetzt werden.</para>

      <para>Eine ausführliche Konfigurationsanleitung finden Sie
        in &man.natd.8;.</para>
    </sect2>

    <sect2 xml:id="network-natdaddress-redirection">
      <title>Adressen umleiten</title>

      <indexterm><primary>address redirection</primary></indexterm>

      <para>Die Umleitung von Adressen ist nützlich, wenn mehrere
        IP-Adressen verfügbar sind, die aber alle auf einem Rechner
        verbleiben sollen.  In diesem Fall kann &man.natd.8; jedem
        LAN-Client eine eigene externe IP-Adresse zuweisen.  Ausgehende
        Pakete eines LAN-Clients werden so der entsprechenden
        externen IP-Adresse des Clients zugeordnet.  Ankommender Verkehr
        für diese IP-Adresse wird automatisch an den entsprechenden
        LAN-Client weitergeleitet.  Diesen Vorgang bezeichnet man
        auch als statisches NAT.  Dem
        <application>natd</application>-Gatewayrechner könnten
        beispielsweise die IP-Adressen
        <systemitem class="ipaddress">128.1.1.1</systemitem>,
        <systemitem class="ipaddress">128.1.1.2</systemitem> sowie
        <systemitem class="ipaddress">128.1.1.3</systemitem> zugewiesen werden.
        <systemitem class="ipaddress">128.1.1.1</systemitem> wird als die externe
        IP-Adresse des <application>natd</application>-Gatewayrechners
        verwendet, während <systemitem class="ipaddress">128.1.1.2</systemitem>
        und <systemitem class="ipaddress">128.1.1.3</systemitem> an die LAN-Clients
        <systemitem>A</systemitem> und <systemitem>B</systemitem> weitergegeben werden.
      </para>

      <para><option>-redirect_address</option> benutzt folgende
        Syntax:</para>

      <programlisting>-redirect_address localIP publicIP</programlisting>

      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
          <tbody>
            <row>
              <entry>localIP</entry>

              <entry>Die interne IP-Adresse des LAN-Clients</entry>
            </row>
            <row>
              <entry>publicIP</entry>

              <entry>Die externe IP-Adresse des LAN-Clients</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Für unser Beispiel hieße dies:</para>

      <programlisting>-redirect_address 192.168.0.2 128.1.1.2
-redirect_address 192.168.0.3 128.1.1.3</programlisting>

      <para>Analog zur Option <option>-redirect_port</option>
        können Sie diese Argumente auch in der Option
        <literal>natd_flags=""</literal> in
        <filename>/etc/rc.conf</filename> angeben.  Bei der Nutzung
        der Adressumleitung ist die Portumleitung überflüssig,
        weil alle für eine bestimmte IP-Adresse ankommenden Daten
        umgeleitet werden.</para>

      <para>Die externe IP-Adresse des
        <application>natd</application>-Rechners muss aktiv sein und
        der externen Netzwerkkarte zugewiesen sein.  Weitere Informationen
         zu diesem Thema finden Sie in &man.rc.conf.5;.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="network-plip">
    <title>PLIP &ndash; Parallel Line IP</title>

    <indexterm>
      <primary>PLIP</primary>
    </indexterm>

    <indexterm>
      <primary>Parallel Line IP</primary>
      <see>PLIP</see>
    </indexterm>

    <para>PLIP ermöglicht TCP/IP-Verbindungen zwischen zwei
      Rechnern, die über ihre parallelen Schnittstellen
      verbunden sind.  Eine solche Verbindung ist nützlich,
      wenn zwei Rechner nicht mit Netzwerkkarten ausgestattet sind,
      oder wenn eine Installation auf einem Laptop erfolgen soll.
      Dieser Abschnitt behandelt folgende Themen:</para>

    <itemizedlist>
      <listitem>
	<para>Die Herstellung eines parallelen (Laplink-) Kabels</para>
      </listitem>

      <listitem>
	<para>Die Verbindung von zwei Computern über PLIP</para>
      </listitem>
    </itemizedlist>

    <sect2 xml:id="network-create-parallel-cable">
      <title>Ein paralleles Kabel herstellen</title>

      <para>Ein paralleles (Laplink-)Kabel können Sie in fast jedem
	Computergeschäft kaufen.  Falls dies nicht möglich
	sein sollte, oder Sie einfach wissen wollen, wie ein solches
	Kabel aufgebaut ist, sollten Sie sich die folgende Tabelle
	ansehen.  Sie beschreibt die Herstellung eines parallelen
	Netzwerkkabels aus einem gewöhnlichen parallelen
	Druckerkabel.</para>

      <table frame="none">
	<title>Die Netzwerk-Verdrahtung eines parallelen Kabels</title>

	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry>A-Name</entry>

	      <entry>A-Ende</entry>

	      <entry>B-Ende</entry>

	      <entry>Beschreibung</entry>

	      <entry>Post/Bit</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><literallayout>DATA0
-ERROR</literallayout></entry>

	      <entry><literallayout>2
15</literallayout></entry>

	      <entry><literallayout>15
2</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x01
1/0x08</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA1
+SLCT</literallayout></entry>

	      <entry><literallayout>3
13</literallayout></entry>

	      <entry><literallayout>13
3</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x02
1/0x10</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA2
+PE</literallayout></entry>

	      <entry><literallayout>4
12</literallayout></entry>

	      <entry><literallayout>12
4</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x04
1/0x20</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA3
-ACK</literallayout></entry>

	      <entry><literallayout>5
10</literallayout></entry>

	      <entry><literallayout>10
5</literallayout></entry>

	      <entry>Strobe</entry>

	      <entry><literallayout>0/0x08
1/0x40</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA4
BUSY</literallayout></entry>

	      <entry><literallayout>6
11</literallayout></entry>

	      <entry><literallayout>11
6</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x10
1/0x80</literallayout></entry>
	    </row>

	    <row>
	      <entry>GND</entry>

	      <entry>18-25</entry>

	      <entry>18-25</entry>

	      <entry>GND</entry>

	      <entry>-</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>

    <sect2 xml:id="network-plip-setup">
      <title>PLIP einrichten</title>

      <para>Als Erstes benötigen Sie ein Laplink-Kabel.  Danach
	müssen Sie sicherstellen, dass beide Computerkernel den
	&man.lpt.4;-Treiber unterstützen:</para>

      <screen>&prompt.root; <userinput>grep lp /var/run/dmesg.boot</userinput>
lpt0: &lt;Printer&gt; on ppbus0
lpt0: Interrupt-driven port</screen>

      <para>Der Parallelport muss Interrupt-gesteuert sein, daher
	sollte die Datei <filename>/boot/device.hints</filename>
	zwei Zeilen ähnlich den folgenden enthalten:</para>

      <programlisting>hint.ppc.0.at="isa"
hint.ppc.0.irq="7"</programlisting>

      <para>Danach überprüfen Sie, ob die
	Kernelkonfigurationsdatei die Zeile
	<literal>device plip</literal> enthält, oder ob das
	Kernelmodul <filename>plip.ko</filename> geladen wurde. In
	beiden Fällen sollte die parallele Schnittstelle
	von &man.ifconfig.8; angezeigt werden:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0</userinput>
plip0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</screen>

      <para>Verbinden Sie die parallelen Schnittstellen der beiden
	Computer über das (Laplink-)Kabel.</para>

      <para>Konfigurieren Sie die Netzwerkparameter auf beiden Rechnern
	als <systemitem class="username">root</systemitem>.  Wenn Sie beispielsweise den Rechner
	<systemitem>host1</systemitem> mit dem Rechner <systemitem>host2</systemitem>
	verbinden wollen, gehen Sie folgendermaßen vor:</para>

      <programlisting>                 host1 &lt;-----&gt; host2
IP Address    10.0.0.1      10.0.0.2</programlisting>

      <para>Richten Sie die parallele Schnittstelle von
	<systemitem>host1</systemitem> ein, indem Sie Folgendes eingeben:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0 10.0.0.1 10.0.0.2</userinput></screen>

      <para>Danach richten Sie die parallele Schnittstelle von
	<systemitem>host2</systemitem> ein:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0 10.0.0.2 10.0.0.1</userinput></screen>

      <para>Sie sollten nun über eine funktionierende Verbindung
	verfügen.  Bei Problemen lesen Sie bitte die Hilfeseiten
	&man.lp.4; sowie &man.lpt.4;.</para>

      <para>Zusätzlich sollten beide Rechner in
	<filename>/etc/hosts</filename> eingetragen werden:</para>

      <programlisting>127.0.0.1               localhost.my.domain localhost
10.0.0.1                host1.my.domain host1
10.0.0.2                host2.my.domain host2</programlisting>

      <para>Um die Verbindung zu überprüfen, pingen Sie jeden
	Rechner vom anderen Rechner aus an.  Auf <systemitem>host1</systemitem>
	gehen Sie dazu folgendermaßen vor:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0</userinput>
plip0: flags=8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 --&gt; 10.0.0.2 netmask 0xff000000
&prompt.root; <userinput>netstat -r</userinput>
Routing tables

Internet:
Destination        Gateway          Flags     Refs     Use      Netif Expire
host2              host1              UH          0       0       plip0
&prompt.root; <userinput>ping -c 4 host2</userinput>
PING host2 (10.0.0.2): 56 data bytes
64 bytes from 10.0.0.2: icmp_seq=0 ttl=255 time=2.774 ms
64 bytes from 10.0.0.2: icmp_seq=1 ttl=255 time=2.530 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=255 time=2.556 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=255 time=2.714 ms

--- host2 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 2.530/2.643/2.774/0.103 ms</screen>
    </sect2>
  </sect1>

  <sect1 xml:id="network-ipv6">
    <info><title>IPv6 &ndash; Internet Protocol Version 6</title>
      <authorgroup>
        <author><personname><firstname>Aaron</firstname><surname>Kaplan</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>

      <authorgroup>
        <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Überarbeitet und erweitert von </contrib></author>
      </authorgroup>

      <authorgroup>
        <author><personname><firstname>Brad</firstname><surname>Davis</surname></personname><contrib>Erweitert von </contrib></author>
      </authorgroup>
    </info>

    

    <para>Bei IPv6 (auch als IPng oder
      <foreignphrase>IP next generation</foreignphrase>
      bekannt) handelt es sich um die neueste Version des bekannten
      IP-Protokolls (das auch als <acronym>IPv4</acronym> bezeichnet
      wird).  FreeBSD enthält, genauso wie die anderen frei
      erhältlichen BSD-Systeme, die IPv6-Referenzimplementation
      von KAME.  FreeBSD erfüllt damit bereits
      alle für die Nutzung von IPv6 nötigen Voraussetzungen.
      Dieser Abschnitt konzentriert sich daher auf die Konfiguration
      und den Betrieb von IPv6.</para>

    <para>Anfang der 90er Jahre wurde man auf den stark steigenden
      Verbrauch von IPv4-Adressen aufmerksam.  Im Hinblick auf das
      Wachstums des Internets gab es zwei Hauptsorgen:</para>

    <itemizedlist>
      <listitem>
        <para>Die drohende Knappheit von IPv4-Adressen.  Dieses Problem
          konnte durch die Einführung von privaten
          Adressräumen gemäß RFC1918 (mit Adressen wie
          <systemitem class="ipaddress">10.0.0.0/8</systemitem>,
          <systemitem class="ipaddress">172.16.0.0/12</systemitem>, oder
          <systemitem class="ipaddress">192.168.0.0/16</systemitem>) sowie der
          Entwicklung von <foreignphrase>Network Address
          Translation</foreignphrase> (<acronym>NAT</acronym>)
          weitestgehend entschärft werden.</para>
      </listitem>

      <listitem>
        <para>Die immer größer werdenden Einträge in
          Router-Tabellen.  Dieses Problem ist auch heute noch
          aktuell.</para>
      </listitem>
    </itemizedlist>

    <para>IPv6 ist in der Lage, diese, aber auch viele andere Probleme
      zu lösen:</para>

    <itemizedlist>
      <listitem>
        <para>IPv6 hat einen 128&nbsp;Bit großen Adressraum. Es sind
          also theoretisch
          340.282.366.920.938.463.463.374.607.431.768.211.456 Adressen
          verfügbar.  In anderen Worten: Für jeden
          Quadratmeter der Erdoberfläche sind etwa
          6,67&nbsp;*&nbsp;10^27 IPv6-Adressen verfügbar.</para>
      </listitem>

      <listitem>
        <para>Router speichern nur noch Netzwerk-Aggregationsadressen in
          Ihren Routingtabellen.  Dadurch reduziert sich die
          durchschnittliche Größe  einer Routingtabelle auf
          8192&nbsp;Einträge.</para>
      </listitem>
    </itemizedlist>

    <para>Weitere nützliche Eigenschaften von IPv6 sind:</para>

    <itemizedlist>
      <listitem>
        <para>Die automatische Konfiguration von Adressen, die im
          <link xlink:href="http://www.ietf.org/rfc/rfc2462.txt">RFC2462</link>
          beschrieben wird.</para>
      </listitem>

      <listitem>
        <para>Anycast-Adressen (<quote>eine-von-vielen</quote>)</para>
      </listitem>

      <listitem>
        <para>Verpflichtende Multicast-Adressen</para>
      </listitem>

      <listitem>
        <para>Die Unterstützung von IPsec (IP-Security)</para>
      </listitem>

      <listitem>
        <para>Eine vereinfachte Headerstruktur</para>
      </listitem>

      <listitem>
        <para>Mobile <acronym>IP</acronym>-Adressen</para>
      </listitem>

      <listitem>
        <para>Die Umwandlung von IPv4- in IPv6-Adressen</para>
      </listitem>
    </itemizedlist>

    <para>Weitere Informationsquellen:</para>

    <itemizedlist>
      <listitem>
        <para>Beschreibung von IPv6 auf
          <link xlink:href="http://playground.sun.com/pub/ipng/html/ipng-main.html">playground.sun.com</link>
        </para>
      </listitem>

      <listitem>
        <para><link xlink:href="http://www.kame.net">KAME.net</link></para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>Hintergrundinformationen zu IPv6-Adressen</title>

      <para>Es gibt verschiedene Arten von IPv6-Adressen: Unicast-,
        Anycast- und Multicast-Adressen.</para>

      <para>Unicast-Adressen sind die herkömlichen Adressen. Ein
        Paket, das an eine Unicast-Adresse gesendet wird, kommt nur an
        der Schnittstelle an, die dieser Adresse zugeordnet ist.</para>

      <para>Anycast-Adressen unterscheiden sich in ihrer Syntax nicht
        von Unicast-Adressen, sie wählen allerdings aus
	mehreren Schnittstellen eine Schnittstelle aus.
	Ein für eine Anycast-Adresse
	bestimmtes Paket kommt an der nächstgelegenen
	(entsprechend der Router-Metrik) Schnittstelle
        an.  Anycast-Adressen werden nur von Routern verwendet.</para>

      <para>Multicast-Adressen bestimmen Gruppen, denen mehrere
        Schnittstellen angehören.  Ein
        Paket, das an eine Multicast-Adresse geschickt wird, kommt an
        allen Schnittstellen an, die zur Multicast-Gruppe gehören.</para>

        <note><para>Die von IPv4 bekannte Broadcast-Adresse
          (normalerweise
          <systemitem class="ipaddress">xxx.xxx.xxx.255</systemitem>) wird bei IPv6
          durch Multicast-Adressen verwirklicht.</para></note>

      <table frame="none">
        <title>Reservierte IPv6-Adressen</title>

        <tgroup cols="4">
          <thead>
            <row>
              <entry>IPv6-Adresse</entry>
              <entry>Präfixlänge</entry>
              <entry>Beschreibung</entry>
              <entry>Anmerkungen</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><systemitem>::</systemitem></entry>
              <entry>128 Bit</entry>
              <entry>nicht festgelegt</entry>
              <entry>entspricht <systemitem class="ipaddress">0.0.0.0</systemitem>
                bei IPv4</entry>
            </row>

            <row>
              <entry><systemitem>::1</systemitem></entry>
              <entry>128 Bit</entry>
              <entry>Loopback-Adresse</entry>
              <entry>entspricht <systemitem class="ipaddress">127.0.0.1</systemitem>
                bei IPv4</entry>
            </row>

            <row>
              <entry><systemitem>::00:xx:xx:xx:xx</systemitem></entry>
              <entry>96 Bit</entry>
              <entry>Eingebettete IPv4-Adresse</entry>
              <entry>Die niedrigen 32&nbsp;Bit entsprechen der IPv4-Adresse.
                Wird auch als <quote>IPv4-kompatible IPv6-Adresse
                bezeichnet</quote>.</entry>
	    </row>

            <row>
              <entry><systemitem>::ff:xx:xx:xx:xx</systemitem></entry>
              <entry>96 Bit</entry>
	      <entry>Eine auf IPv6 abgebildete IPv4-Adresse</entry>
              <entry>Die niedrigen 32&nbsp;Bit entsprechen der IPv4-Adresse.
                Notwendig für Rechner, die IPv6 nicht
                unterstützen.</entry>
            </row>

            <row>
              <entry><systemitem>fe80::</systemitem> - <systemitem>feb::</systemitem></entry>
              <entry>10 Bit</entry>
              <entry><foreignphrase>link-local</foreignphrase></entry>
              <entry>Entspricht der Loopback-Adresse bei IPv4</entry>
            </row>

            <row>
              <entry><systemitem>fec0::</systemitem> - <systemitem>fef::</systemitem></entry>
              <entry>10 Bit</entry>
              <entry><foreignphrase>site-local</foreignphrase></entry>
              <entry>&nbsp;</entry>
            </row>

            <row>
              <entry><systemitem>ff::</systemitem></entry>
              <entry>8 Bit</entry>
              <entry>Multicast</entry>
              <entry>&nbsp;</entry>
            </row>

            <row>
              <entry><systemitem>001</systemitem>
		(im Dualsystem)</entry>
              <entry>3 Bit</entry>
              <entry>Globaler Unicast</entry>
              <entry>Alle globalen Unicastadressen stammen aus diesem
                Pool.  Die ersten 3&nbsp;Bit lauten <quote>001</quote>.
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>

    <sect2>
      <title>IPv6-Adressen verstehen</title>

      <para>Die kanonische Form von IPv6-Adressen lautet
        <systemitem>x:x:x:x:x:x:x:x</systemitem>, jedes
        <quote>x</quote> steht dabei für einen
        16-Bit-Hexadezimalwert.  Ein Beispiel für eine IPv6-Adresse
        wäre etwa
        <systemitem>FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</systemitem>.</para>

      <para>Eine IPv6-Adresse enthält oft Teilzeichenfolgen aus lauter
        Nullen.  Eine solche Zeichenfolge kann zu <quote>::</quote>
        verkürzt werden.  Bis zu drei führende Nullen eines
        Hexquads können ebenfalls weggelassen werden.
        <systemitem>fe80::1</systemitem> entspricht also der Adresse
        <systemitem>fe80:0000:0000:0000:0000:0000:0000:0001</systemitem>.
      </para>

      <para>Eine weitere Möglichkeit ist die Darstellung der
        letzten 32&nbsp;Bit in  der bekannten (dezimalen) IPv4-Darstellung,
        bei der Punkte (<quote>.</quote>) zur Trennung verwendet werden.
        <systemitem>2002::10.0.0.1</systemitem> ist also nur eine
        andere Schreibweise für die (hexadezimale) kanonische Form
        <systemitem>2002:0000:0000:0000:0000:0000:0a00:0001</systemitem>,
        die wiederum der Adresse
        <systemitem>2002::a00:1</systemitem> entspricht.</para>

      <para>Sie sollten nun in der Lage sein, die folgende Ausgabe zu
        verstehen:</para>

      <screen>&prompt.root; <userinput>ifconfig</userinput>
rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active</screen>

      <para>Bei
        <systemitem>fe80::200:21ff:fe03:8e1%rl0</systemitem>
        handelt es sich um eine automatisch konfigurierte
        <foreignphrase>link-local</foreignphrase>-Adresse.  Sie
        wird im Rahmen der automatischen Konfiguration aus der
        MAC-Adresse erzeugt.</para>

      <para>Weitere Informationen zum Aufbau von IPv6-Adressen finden
        Sie im <link xlink:href="http://www.ietf.org/rfc/rfc3513.txt">
        RFC3513</link>.</para>
    </sect2>

    <sect2>
      <title>Eine IPv6-Verbindung herstellen</title>

      <para>Es gibt derzeit vier Möglichkeiten, sich mit anderen
        IPv6-Rechnern oder Netzwerken zu verbinden:</para>

      <itemizedlist>
        <listitem>
          <para>Fragen Sie Ihren Internetprovider, ob er IPv6
            bereits unterstützt.</para>
        </listitem>

        <listitem>
          <para><link xlink:href="http://www.sixxs.net">SixXS</link>
            bietet weltweit IPv6-Tunnelverbindungen an.</para>
        </listitem>

        <listitem>
          <para>Die Verwendung eines 6-nach-4-Tunnels
            (<link xlink:href="http://www.ietf.org/rfc/rfc3068.txt">RFC3068</link>).</para>
        </listitem>

        <listitem>
          <para>Die Verwendung des Ports
            <filename>/usr/ports/net/freenet6</filename> bei der Einwahl
            ins Internet.</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>DNS in der IPv6-Welt</title>

      <para>Ursprünglich gab es zwei verschiedene DNS-Einträge
        für IPv6.  Da A6-Einträge von der IETF für
        obsolet erklärt wurden, sind AAAA-Einträge nun
        Standard.</para>

      <para>Weisen Sie die erhaltene IPv6-Adresse Ihrem Rechnernamen zu,
        indem Sie den Eintrag</para>

      <programlisting>MYHOSTNAME           AAAA    MYIPv6ADDR</programlisting>

      <para>in Ihre primäre DNS-Zonendatei einfügen.  Falls
        Sie nicht für Ihre <acronym>DNS</acronym>-Zone
        verantwortlich sind, bitten Sie den dafür
        Zuständigen, diese Änderung durchzuführen.
        Die aktuellen Versionen von <application>bind</application>
        (Version&nbsp;8.3 oder 9) sowie
        <package>dns/djbdns</package> (bei Verwendung
        des IPv6-Patches) unterstützen AAAA-Einträge.</para>
    </sect2>

    <sect2>
      <title><filename>/etc/rc.conf</filename> für die Nutzung von
        IPv6 anpassen</title>

      <sect3>
        <title>Einen Client unter IPv6 einrichten</title>

        <para>Dieser Abschnitt beschreibt die Konfiguration eines
          Rechners, der in Ihrem LAN als Client, aber nicht als Router
          verwendet wird.  Um die Schnittstelle während des
          Systemstarts mit &man.rtsol.8; automatisch einzurichten,
          fügen Sie folgende Zeile in
          <filename>/etc/rc.conf</filename> ein:</para>

        <programlisting>ipv6_enable="YES"</programlisting>

        <para>Durch die folgende Zeile weisen Sie Ihrer Schnittstelle
          <filename>fxp0</filename> die statische IP-Adresse <systemitem>2001:471:1f11:251:290:27ff:fee0:2093</systemitem>
          zu:</para>

        <programlisting>ipv6_ifconfig_fxp0="2001:471:1f11:251:290:27ff:fee0:2093"</programlisting>

        <para>Um <systemitem>2001:471:1f11:251::1</systemitem>
          als Standardrouter festzulegen, fügen Sie folgende Zeile
          in <filename>/etc/rc.conf</filename> ein:</para>

        <programlisting>ipv6_defaultrouter="2001:471:1f11:251::1"</programlisting>
      </sect3>

      <sect3>
        <title>Gateways und Router unter IPv6 einrichten</title>

        <para>Dieser Abschnitt beschreibt, wie Sie Ihren Rechner mit
          Hilfe der von Ihrem Tunnel-Anbieter erhaltenen
          Anweisungen dauerhaft für die Nutzung von IPv6
          einrichten.  Um den Tunnel beim Systemstart
          wiederherzustellen, passen Sie
          <filename>/etc/rc.conf</filename> wie folgt an:</para>

        <para>Listen Sie die einzurichtenden Tunnelschnittstellen
          (hier <filename>gif0</filename>) auf:</para>

        <programlisting>gif_interfaces="gif0"</programlisting>

        <para>Um den lokalen Endpunkt
          <replaceable>MY_IPv4_ADDR</replaceable> über diese
          Schnittstelle mit dem entfernten Endpunkt
          <replaceable>REMOTE_IPv4_ADDR</replaceable> zu
          verbinden, verwenden Sie folgende Zeile:</para>

        <programlisting>gifconfig_gif0="<replaceable>MY_IPv4_ADDR REMOTE_IPv4_ADDR</replaceable>"</programlisting>

        <para>Um die Ihnen zugewiesene IPv6-Adresse als Endpunkt Ihres
          IPv6-Tunnels zu verwenden, fügen Sie folgende Zeile
          ein:</para>

        <programlisting>ipv6_ifconfig_gif0="<replaceable>MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR</replaceable>"</programlisting>

        <para>Nun müssen Sie nur noch die IPv6-Standardroute
          angeben.  Diese legt das andere Ende des IPv6-Tunnels
          fest.</para>

        <programlisting>ipv6_defaultrouter="<replaceable>MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR</replaceable>"</programlisting>
      </sect3>

      <sect3>
        <title>Einen IPv6-Tunnel einrichten</title>

        <para>Wenn Ihr Server IPv6-Verkehr zwischen Ihrem Netzwerk und
          der Außenwelt routen muss, benötigen Sie
          zusätzlich die folgenden Zeilen in Ihrer
          <filename>/etc/rc.conf</filename>:</para>

        <programlisting>ipv6_gateway_enable="YES"</programlisting>

      </sect3>
    </sect2>

    <sect2>
      <title>Bekanntmachung von Routen und automatische
        Rechnerkonfiguration</title>

      <para>Dieser Abschnitt beschreibt die Einrichtung von
        &man.rtadvd.8;, das Sie bei der Bekanntmachung der
        IPv6-Standardroute unterstützt.</para>

      <para>Um &man.rtadvd.8; zu aktivieren, fügen Sie folgende
        Zeile in <filename>/etc/rc.conf</filename> ein:</para>

      <programlisting>rtadvd_enable="YES"</programlisting>

      <para>Es ist wichtig, die Schnittstelle anzugeben, über die
        IPv6-Routen bekanntgemacht werden sollen.  Soll &man.rtadvd.8;
        <filename>fxp0</filename> verwenden, ist folgender Eintrag
        nötig:</para>

      <programlisting>rtadvd_interfaces="fxp0"</programlisting>

      <para>Danach erzeugen Sie die Konfigurationsdatei
        <filename>/etc/rtadvd.conf</filename>.  Dazu ein Beispiel:</para>

      <programlisting>fxp0:\
    :addrs#1:addr="2001:471:1f11:246::":prefixlen#64:tc=ether:</programlisting>

      <para>Ersetzen Sie dabei <filename>fxp0</filename> durch die
        zu verwendende Schnittstelle.</para>

      <para>Anschließend ersetzen Sie
        <systemitem>2001:471:1f11:246::</systemitem> durch das
        Präfix der Ihnen zugewiesenen Verbindung.</para>

      <para>Wenn Sie eine <systemitem class="netmask">/64</systemitem>-Netzmaske
        verwenden, müssen Sie keine weiteren Anpassungen vornehmen.
        Anderenfalls müssen Sie <literal>prefixlen#</literal>
        auf den korrekten Wert setzen.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="network-atm">
    <info><title>ATM - Asynchronous Transfer Mode</title>
      <authorgroup>
        <author><personname><firstname>Harti</firstname><surname>Brandt</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
    </info>

    

    <sect2>
      <title><foreignphrase>Classical IP over ATM</foreignphrase>
        als PVC-Verbindung einrichten</title>

      <para><foreignphrase>Classical IP over ATM</foreignphrase>
        (<acronym>CLIP</acronym>) ist die einfachste Möglichkeit,
        um IP-Verkehr über ATM (<foreignphrase>Asynchronous
        Transfer Mode</foreignphrase>-Verbindungen zu übertragen.
        CLIP kann sowohl mit geschalteten Verbindungen (SVCs) als auch
        mit permanenten Verbindungen (PVCs) verwendet werden.  Dieser
        Abschnitt beschreibt die Einrichtung eines PVC-basierten
        Netzwerks.</para>

      <sect3>
        <title>Ein vollständig vermaschtes Netzwerk aufbauen</title>

        <para>Bei einem vollständig vermaschten
          (<foreignphrase>fully meshed</foreignphrase>) Netzwerk ist
          jeder Rechner über eine dezidierte Verbindung mit jedem
          anderen Rechner des Netzwerks verbunden.  Die Konfiguration
          ist - vor allem für kleinere Netzwerke - relativ einfach.
          Unser Beispielnetzwerk besteht aus vier Rechnern, die jeweils
          über eine
          <acronym role="Asynchronous Transfer Mode">ATM</acronym>-Adapterkarte
          mit dem
          <acronym role="Asynchronous Transfer Mode">ATM</acronym>-Netzwerk
          verbunden sind.  Als ersten Konfigurationsschritt planen wir
          die Vergabe von IP-Adressen sowie die anzulegenden
          <acronym role="Asynchronous Transfer Mode">ATM</acronym>-Verbindungen:
        </para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*"/>
	    <colspec colwidth="1*"/>
	    <thead>
	      <row>
		<entry>Rechner</entry>
		<entry>IP-Adresse</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><systemitem>hostA</systemitem></entry>
		<entry><systemitem class="ipaddress">192.168.173.1</systemitem></entry>
	      </row>

	      <row>
		<entry><systemitem>hostB</systemitem></entry>
		<entry><systemitem class="ipaddress">192.168.173.2</systemitem></entry>
	      </row>

	      <row>
		<entry><systemitem>hostC</systemitem></entry>
		<entry><systemitem class="ipaddress">192.168.173.3</systemitem></entry>
	      </row>

	      <row>
		<entry><systemitem>hostD</systemitem></entry>
		<entry><systemitem class="ipaddress">192.168.173.4</systemitem></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

        <para>Um ein vollständiges Netz aufzubauen, benötigen
          wir für jedes Rechnerpaar eine eigene ATM-Verbindung:</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*"/>
	    <colspec colwidth="1*"/>
	    <thead>
	      <row>
		<entry>Rechnerpaar</entry>
		<entry>VPI.VCI-Paar</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><systemitem>hostA</systemitem> - <systemitem>hostB</systemitem></entry>
		<entry>0.100</entry>
	      </row>

	      <row>
		<entry><systemitem>hostA</systemitem> - <systemitem>hostC</systemitem></entry>
		<entry>0.101</entry>
	      </row>

	      <row>
		<entry><systemitem>hostA</systemitem> - <systemitem>hostD</systemitem></entry>
		<entry>0.102</entry>
	      </row>

	      <row>
		<entry><systemitem>hostB</systemitem> - <systemitem>hostC</systemitem></entry>
		<entry>0.103</entry>
	      </row>

	      <row>
		<entry><systemitem>hostB</systemitem> - <systemitem>hostD</systemitem></entry>
		<entry>0.104</entry>
	      </row>

	      <row>
		<entry><systemitem>hostC</systemitem> - <systemitem>hostD</systemitem></entry>
		<entry>0.105</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

        <para>Die Werte VPI und VCI an den Verbindungsenden können
          natürlich unterschiedlich sein.  Wir nehmen hier aber an,
          dass sie gleich sind.  Nun müssen wir die
          ATM-Schnittstellen auf jedem Rechner einrichten:</para>

        <screen>hostA&prompt.root; <userinput>ifconfig hatm0 192.168.173.1 up</userinput>
hostB&prompt.root; <userinput>ifconfig hatm0 192.168.173.2 up</userinput>
hostC&prompt.root; <userinput>ifconfig hatm0 192.168.173.3 up</userinput>
hostD&prompt.root; <userinput>ifconfig hatm0 192.168.173.4 up</userinput></screen>

        <para>Dabei setzen wir voraus, dass
          <filename>hatm0</filename> auf allen Rechnern die
          ATM-Schnittstelle darstellt.  Danach werden, beginnend mit
          <systemitem>hostA</systemitem>, die PVCs auf den einzelnen Rechnern
          eingerichtet (Wir nehmen an, dass die PVCs auf den
          ATM-Switches bereits eingerichet sind.  Lesen Sie die
          entsprechenden Handbücher, wenn Sie einen Switch
          einrichten müssen.):</para>

        <screen>hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 100 llc/snap ubr</userinput>
hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 101 llc/snap ubr</userinput>
hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 102 llc/snap ubr</userinput>

hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 100 llc/snap ubr</userinput>
hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 103 llc/snap ubr</userinput>
hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 104 llc/snap ubr</userinput>

hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 101 llc/snap ubr</userinput>
hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 103 llc/snap ubr</userinput>
hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 105 llc/snap ubr</userinput>

hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 102 llc/snap ubr</userinput>
hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 104 llc/snap ubr</userinput>
hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 105 llc/snap ubr</userinput></screen>

        <para>Statt UBR können auch andere
          <foreignphrase>traffic contracts</foreignphrase> verwendet
          werden.  Voraussetzung ist allerdings, dass diese von Ihrem
          ATM-Adapter unterstützt werden.  Ist dies der Fall,
          folgen auf den Namen des
          <foreignphrase>traffic contracts</foreignphrase> die
          entsprechenden Konfigurationsparameter.  Weitere Informationen
          zur Konfiguration von ATM-Adapterkarten erhalten Sie über
          den Befehl</para>

        <screen>&prompt.root; <userinput>atmconfig help natm add</userinput></screen>

        <para>oder durch das Lesen von &man.atmconfig.8;.</para>

        <para>Die Konfiguration von ATM-Adaptern kann auch über die
          Datei <filename>/etc/rc.conf</filename> erfolgen.  Für
          <systemitem>hostA</systemitem> sähe die Konfiguration so
          aus:</para>

        <programlisting>network_interfaces="lo0 hatm0"
ifconfig_hatm0="inet 192.168.173.1 up"
natm_static_routes="hostB hostC hostD"
route_hostB="192.168.173.2 hatm0 0 100 llc/snap ubr"
route_hostC="192.168.173.3 hatm0 0 101 llc/snap ubr"
route_hostD="192.168.173.4 hatm0 0 102 llc/snap ubr"</programlisting>

        <para>Mit dem folgenden Befehl lässt sich der derzeitige
          Status aller <acronym>CLIP</acronym>-Routen anzeigen:</para>

        <screen>hostA&prompt.root; <userinput>atmconfig natm show</userinput></screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="carp">
    <info><title>CARP - Common Address Redundancy Protocol</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>CARP</primary></indexterm>
    <indexterm><primary>Common Address Redundancy Protocol (CARP)</primary></indexterm>

    <para>Das <foreignphrase>Common Address Redundancy
      Protocol</foreignphrase> (<acronym>CARP</acronym>) erlaubt es,
      mehreren Rechnern die gleiche <acronym>IP</acronym>-Adresse
      zuzuweisen.  Durch ein solches Vorgehen läßt sich
      beispielsweise die Verfügbarkeit bestimmter Dienste
      verbessern oder die Last zwischen einzelnen Systemen besser
      verteilen.  Den auf diese Art und Weise konfigurierten Systemen
      kann zusätzlich eine eigene (im Netzwerk eindeutige)
      <acronym>IP</acronym>-Adresse zugewiesen werden (wie dies auch
      im folgenden Beispiel erfolgt).</para>

    <para>Um <acronym>CARP</acronym> zu aktivieren, müssen Sie die
      &os;-Kernelkonfigurationsdatei um die folgende Option erweitern
      und danach den &os;-Kernel (wie in <xref linkend="kernelconfig"/> beschrieben) neu bauen:</para>

    <programlisting>device	carp</programlisting>

    <para>Alternativ können Sie aber auch das Kernelmodul
      <filename>if_carp.ko</filename> beim Systemstart
      automatisch laden.  Dazu nehmen Sie die folgende Zeile
      in die Datei <filename>/boot/loader.conf</filename>
      auf:</para>

    <programlisting>if_carp_load="YES"</programlisting>

    <para>Danach ist <acronym>CARP</acronym> auf Ihrem System
      verfügbar und kann über verschiedene
      <command>sysctl</command>-Optionen (<acronym>OID</acronym>s)
      gesteuert werden.</para>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>OID</entry>
	    <entry>Beschreibung</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><varname>net.inet.carp.allow</varname></entry>
	    <entry>Akzeptiert ankommende <acronym>CARP</acronym>-Pakete.
	      In der Voreinstellung aktiviert.</entry>
	  </row>

	  <row>
	    <entry><varname>net.inet.carp.preempt</varname></entry>
	    <entry>Diese Option deaktiviert alle
	      <acronym>CARP</acronym>-Geräte, sobald eines von
	      ihnen ausfällt.  In der Voreinstellung
	      deaktiviert.</entry>
	  </row>

	  <row>
	    <entry><varname>net.inet.carp.log</varname></entry>
	    <entry>Hat diese Variable den Wert <literal>0</literal>, wird
	      kein Protokoll generiert, während mit dem Wert
	      <literal>1</literal> nur inkorrekte
	      <acronym>CARP</acronym>-Pakete protokolliert werden.  Hat
	      die Variable einen Wert größer
	      <literal>1</literal>, werden nur die Statuswechsel von
	      <acronym>CARP</acronym>-Geräten protokolliert.  In der
	      Voreinstellung hat diese Variable den Wert
	      <literal>1</literal>.</entry>
	  </row>

	  <row>
	    <entry><varname>net.inet.carp.arpbalance</varname></entry>
	    <entry>Gleicht die Netzwerklast im lokalen Netzwerk durch
	      den Einsatz von <acronym>ARP</acronym> aus.  In der
	      Voreinstellung deaktiviert.</entry>
	  </row>

	  <row>
	    <entry><varname>net.inet.carp.suppress_preempt</varname></entry>
	    <entry>Eine nur lesbare <acronym>OID</acronym>, die
	      den <foreignphrase>Preemption Suppression</foreignphrase>-Status
	      anzeigt. Preemption kann verhindert werden.  Dies auch dann,
	      wenn ein Gerät ausfällt.  Hat die Variable
	      den Wert <literal>0</literal>, bedeutet dies, dass Preemption
	      nicht verhindert wird.  Tritt ein Problem auf, wird der Wert
	      dieser <acronym>OID</acronym> um <literal>1</literal>
	      erhöht.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Das <acronym>CARP</acronym>-Gerät selbst erzeugen Sie mit dem
      <command>ifconfig</command>-Befehl:</para>

    <screen>&prompt.root; <userinput>ifconfig carp0 create</userinput></screen>

    <para>Damit Sie dieses Protokoll in Ihrem Netzwerk einsetzen
      können, muss jede Netzwerkkarte eine eindeutige
      Identifikationsnummer, die sogenannte <acronym>VHID</acronym>
      (<foreignphrase>Virtual Host Identification</foreignphrase>),
      besitzen, da sich ansonsten die Rechner Ihres Netzwerks nicht
      voneinander unterscheiden lassen.</para>

    <sect2>
      <title>Die Serververfügbarkeit mit CARP
	verbessern</title>

      <para>Wie bereits weiter oben erwähnt wurde, können Sie
	<acronym>CARP</acronym> dazu verwenden, die Verfübarkeit
	Ihrer Server zu verbessern.  Im folgenden Bespiel werden
	insgesamt drei Server (mit jeweils eigener, eindeutiger
	<acronym>IP</acronym>-Adresse), die alle den gleichen Inhalt
	anbieten, in einer <foreignphrase>Round Robin</foreignphrase>
	<acronym>DNS</acronym>-Konfiguration eingerichtet.
	Der Backup-Server verfügt über zwei
	<acronym>CARP</acronym>-Schnittstellen (für die beiden
	<acronym>IP</acronym>-Adressen der Content-Server).  Tritt bei
	einem Content-Server ein Problem auf, übernimmt der
	Backup-Server die <acronym>IP</acronym>-Adresse des
	ausgefallenen Servers.  Dadurch sollte die Auswahl eines Servers
	vom Anwender nicht bemerkt werden.  Der Backup-Server muss
	identisch konfiguriert sein und die gleichen Daten und Dienste
	anbieten wie das System, das er ersetzen soll.</para>

      <para>Die beiden Content-Server werden (abgesehen von ihren
	jeweiligen Hostnamen und <acronym>VHID</acronym>s) identisch
	konfiguriert und heißen in unserem Beispiel
	<systemitem>hosta.example.org</systemitem> beziehungsweise
	<systemitem>hostb.example.org</systemitem>.  Damit Sie
	<acronym>CARP</acronym> einsetzen können, müssen
	Sie als Erstes die Datei <filename>rc.conf</filename> auf
	beiden Systemen anpassen.  Für das System
	<systemitem>hosta.example.org</systemitem> nehmen Sie dazu folgende
	Zeilen in <filename>rc.conf</filename> auf:</para>

      <programlisting>hostname="hosta.example.org"
ifconfig_fxp0="inet 192.168.1.3 netmask 255.255.255.0"
cloned_interfaces="carp0"
ifconfig_carp0="vhid 1 pass testpass 192.168.1.50/24"</programlisting>

      <para>Für das System <systemitem>hostb.example.org</systemitem>
	benötigen Sie zusätzlich folgende Zeilen in
	<filename>rc.conf</filename>:</para>

      <programlisting>hostname="hostb.example.org"
ifconfig_fxp0="inet 192.168.1.4 netmask 255.255.255.0"
cloned_interfaces="carp0"
ifconfig_carp0="vhid 2 pass testpass 192.168.1.51/24"</programlisting>

      <note>
	<para>Achten Sie unbedingt darauf, dass die durch die Option
	  <option>pass</option> an <command>ifconfig</command>
	  übergebenen Passwörter auf beiden Systemen
	  identisch sind, da
	  <filename>carp</filename>-Geräte nur mit Systemen
	  kommunizieren können, die über ein korrektes Passwort
	  verfügen.  Beachten Sie weiters, dass sich die
	  <acronym>VHID</acronym>s der beiden Systeme unterscheiden
	  müssen.</para>
      </note>

      <para>Nun richten Sie noch das dritte System,
	<systemitem>provider.example.org</systemitem>, ein, das aktiviert
	wird, wenn eines der beiden zuvor konfigurierten Systeme
	ausfällt.  Dieses dritte System benötigt zwei
	<filename>carp</filename>-Geräte, um bei Bedarf
	eines der beiden anderen
	Systeme ersetzen zu können.  Dazu konfigurieren Sie
	<filename>rc.conf</filename> analog zur folgenden
	Beispielkonfiguration:</para>

      <programlisting>hostname="provider.example.org"
ifconfig_fxp0="inet 192.168.1.5 netmask 255.255.255.0"
cloned_interfaces="carp0 carp1"
ifconfig_carp0="vhid 1 advskew 100 pass testpass 192.168.1.50/24"
ifconfig_carp1="vhid 2 advskew 100 pass testpass 192.168.1.51/24"</programlisting>

      <para>Durch die beiden <filename>carp</filename>-Geräte
	ist es <systemitem>provider.example.org</systemitem> möglich,
	festzustellen, ob eines der beiden anderen Systeme nicht mehr
	reagiert.  In diesem Fall übernimmt
	<systemitem>provider.example.org</systemitem> die
	<acronym>IP</acronym>-Adresse des betroffenen Systems.</para>

      <note>
        <para>Ist im installierten &os;-Kernel die Option
	  "preemption" aktiviert, kann es sein, dass
	  <systemitem>provider.example.org</systemitem> die übernommene
	  <acronym>IP</acronym>-Adresse nicht mehr an den
	  Content-Server zurückgibt (wenn dieser wieder
	  funktioniert).  In diesem Fall muss ein Administrator die
	  entsprechende Schnittstelle dazu zwingen, dies zu tun.
	  Dazu gibt er auf dem Rechner
	  <systemitem>provider.example.org</systemitem> den folgenden
	  Befehl ein:</para>

	<screen>&prompt.root; <userinput>ifconfig carp0 down &amp;&amp; ifconfig carp0 up</userinput></screen>

	<para>Dieser Befehl muss auf das
	  <filename>carp</filename>-Gerät ausgeführt
	  werden, das dem betroffenen System zugeordnet ist.</para>
      </note>

      <para>Damit ist <acronym>CARP</acronym> vollständig
	konfiguriert und der Testbetrieb kann beginnen.  Zuvor
	müssen Sie allerdings noch alle Systeme neu starten
	(beziehungsweise die Netzwerkkonfiguration auf allen
	Systemen neu einlesen), um die Einstelllungen zu
	übernehmen.</para>

      <para>Für weitere Informtionen lesen Sie bitte die Manualpage
        &man.carp.4;.</para>
    </sect2>
  </sect1>
</chapter>
