<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/boot/chapter.xml,v 1.63 2012/04/22 20:05:15 bcr Exp $
     basiert auf: 1.76
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="boot">
  <info><title>FreeBSDs Bootvorgang</title>
    <authorgroup>
      <author><personname><firstname>Hans-Christian</firstname><surname>Ebke</surname></personname><contrib>Übersetzt von </contrib></author>
    </authorgroup>
  </info>
  

  <sect1 xml:id="boot-synopsis">
    <title>Übersicht</title>
    <indexterm><primary>booten</primary></indexterm>
    <indexterm><primary>Bootstrap</primary></indexterm>

    <para>Das Starten des Computers und das Laden des Betriebssystems
      wird im Allgemeinen als <quote>Bootstrap-Vorgang</quote>
      bezeichnet, oder einfach als <quote>Booten</quote>.  FreeBSDs
      Bootvorgang ermöglicht große Flexibilität, was
      das Anpassen dessen anbelangt, was passiert, wenn das System
      gestartet wird.  Es kann zwischen verschiedenen Betriebssystemen,
      die auf demselben Computer installiert sind oder verschiedenen
      Versionen desselben Betriebssystems oder installierten Kernels
      gewählt werden.</para>

    <para>Dieses Kapitel zeigt die zur Verfügung stehenden
      Konfigurationsmöglichkeiten und wie man den Bootvorgang anpasst.
      Dies schließt alles ein, bis der Kernel gestartet worden ist,
      der dann alle Geräte gefunden hat und &man.init.8; gestartet hat.
      Falls Sie sich nicht ganz sicher sind, wann dies passiert:
      Es passiert, wenn die Farbe des Textes während des Bootvorgangs
      von weiß zu Hellgrau wechselt.</para>

    <para>Dieses Kapitel informiert über folgende Punkte:</para>

    <itemizedlist>
      <listitem>
	<para>Die Komponenten des FreeBSD-Bootvorgangs und deren
	  Interaktion.</para>
      </listitem>

      <listitem>
	<para>Die Optionen, mit denen Sie den FreeBSD-Bootvorgang steuern
	  können.</para>
      </listitem>

      <listitem>
	<para>Wie Geräte mit &man.device.hints.5; konfiguriert
	  werden.</para>
      </listitem>
    </itemizedlist>

    <note>
      <title>nur x86</title>

      <para>Dieses Kapitel erklärt den Bootvorgang von FreeBSD auf
        Intel X86 Plattformen.</para>
    </note>
  </sect1>

  <sect1 xml:id="boot-introduction">
    <title>Das Problem des Bootens</title>

    <para>Wenn der Computer eingeschaltet wird und das Betriebssystem
      gestartet werden soll, entsteht ein interessantes Dilemma, denn der
      Computer weiß per Definition nicht, wie er irgendetwas tut, bis
      das Betriebssystem gestartet wurde.  Das schließt das Starten von
      Programmen, die sich auf der Festplatte befinden, ein.  Wenn nun
      der Computer kein Programm von der Festplatte starten kann, sich
      das Betriebssystem aber dummerweise genau dort befindet, wie
      wird es dann gestartet?</para>

    <para>Dieses Problem ähnelt einer Geschichte des Barons von
      Münchhausen.  Dort war eine Person in einen Sumpf gefallen
      und hat sich selbst an den Riemen seiner Stiefel (engl.
      <foreignphrase>bootstrap</foreignphrase>) herausgezogen.  In den
      jungen Jahren des Computerzeitalters wurde mit dem Begriff
      Bootstrap dann die Technik das Betriebssystem zu laden bezeichnet
      und wurde hinterher mit booten abgekürzt.</para>

    <indexterm><primary>BIOS</primary></indexterm>

    <indexterm>
      <primary>Basic Input/Output System</primary>
      <see>BIOS</see>
    </indexterm>

    <para>Auf x86-Plattformen ist das BIOS (Basic Input/Output System)
      dafür verantwortlich, das Betriebssystem zu laden.  Dazu
      liest das BIOS den Master Bootsektor (MBR; Master Boot Record)
      aus, der sich an einer bestimmten Stelle auf der
      Festplatte/Diskette befinden muss.  Das BIOS kann den MBR
      selbstständig laden und ausführen und geht davon aus,
      dass dieser die restlichen Dinge, die für das Laden des
      Betriebssystems notwendig sind, selbst oder mit Hilfe des BIOS
      erledigen kann.</para>

    <indexterm><primary>Master Boot Record (MBR)</primary></indexterm>

    <indexterm><primary>Boot Manager</primary></indexterm>

    <indexterm><primary>Boot Loader</primary></indexterm>

    <para>Der Code innerhalb des MBRs wird für gewöhnlich als
      <emphasis>Boot-Manager</emphasis> bezeichnet, insbesondere, wenn
      eine Interaktion mit dem Anwender stattfindet.  Ist dies der Fall,
      verwaltet der Boot-Manager zusätzlichen Code im ersten
      <emphasis>Track</emphasis> der Platte oder in Dateisystemen
      anderer Betriebssysteme.  (Boot-Manager werden manchmal auch als
      <emphasis>Boot Loader</emphasis> bezeichnet, unter FreeBSD wird
      dieser Begriff aber für eine spätere Phase des
      Systemstarts verwendet.)  Zu den bekanntesten Boot-Managern
      gehören <application>boot0</application> (der auch als
      <application>Boot Easy</application> bekannte
      Standard-Boot-Manager von &os;), <application>Grub</application>,
      <application>GAG</application>, sowie
      <application>LILO</application>.
      (Von diesen Boot-Managern hat nur <application>boot0</application>
      innerhalb des MBRs Platz.)</para>

    <para>Falls nur ein Betriebssystem installiert ist, ist der
      Standard MBR ausreichend.  Dieser MBR sucht nach dem ersten
      bootbaren Slice (das dabei als <emphasis>active</emphasis>
      gekennzeichnet ist) auf dem Laufwerk und führt den dort
      vorhandenen Code aus, um das restliche Betriebssystem zu
      laden.  Der von &man.fdisk.8; in der Voreinstellung
      installierte MBR ist ein solcher MBR und basiert auf
      <filename>/boot/mbr</filename>.</para>

    <para>Falls mehrere Betriebssysteme installiert sind, sollte
      man einen anderen Boot-Manager installieren, der eine Liste der
      verfügbaren Betriebssysteme anzeigt und einen wählen
      lässt, welches man booten möchte.  Der nächste
      Abschnitt beschreibt zwei Boot-Manager mit diesen
      Fähigkeiten.</para>

    <para>Das restliche FreeBSD-Bootstrap-System ist in drei Phasen
      unterteilt.  Die erste Phase wird vom MBR durchgeführt, der
      gerade genug Funktionalität besitzt um den Computer in
      einen bestimmten Status zu verhelfen und die zweite Phase zu
      starten.  Die zweite Phase führt ein wenig mehr Operationen
      durch und startet schließlich die dritte Phase, die das Laden
      des Betriebssystems abschließt.  Der ganze Prozess wird in drei
      Phasen durchgeführt, weil der PC Standard die Größe
      der Programme, die in Phase eins und zwei ausgeführt
      werden, limitiert.  Durch das Verketten der durchzuführenden
      Aufgaben wird es FreeBSD möglich, ein sehr flexibles
      Ladeprogramm zu besitzen.</para>

    <indexterm><primary>Kernel</primary></indexterm>
    <indexterm><primary><command>init</command></primary></indexterm>

    <para>Als nächstes wird der Kernel gestartet, der zunächst nach
      Geräten sucht und sie für den Gebrauch
      initialisiert.  Nach dem Booten des Kernels übergibt dieser
      die Kontrolle an den Benutzer Prozess &man.init.8;, der erst
      sicherstellt, dass alle Laufwerke benutzbar sind und die
      Ressourcen Konfiguration auf Benutzer Ebene startet.  Diese
      wiederum mountet Dateisysteme, macht die Netzwerkkarten für
      die Kommunikation mit dem Netzwerk bereit und startet generell
      alle Prozesse, die auf einem FreeBSD-System normalerweise beim
      Hochfahren gestartet werden.</para>
</sect1>

  <sect1 xml:id="boot-blocks">
    <title>Boot-Manager und Boot-Phasen</title>

    <indexterm><primary>Boot Manager</primary></indexterm>

    <sect2 xml:id="boot-boot0">
      <title>Der Boot-Manager</title>

      <indexterm><primary>Master Boot Record (MBR)</primary></indexterm>

      <para>Der Code im MBR oder im Boot-Manager wird manchmal auch
        als <emphasis>stage zero</emphasis> des Boot-Prozesses
        bezeichnet.  Dieser Abschnitt beschreibt zwei der weiter
        oben erwähnten Boot-Manager:
        <application>boot0</application> sowie
        <application>LILO</application>.</para>

      <formalpara><title>Der <application>boot0</application> Boot-Manager:</title>

        <para>Der vom FreeBSD-Installationsprogramm oder &man.boot0cfg.8;
          in der Voreinstelung installierte Master Boot Record (MBR)
          basiert auf <filename>/boot/boot0</filename>.
          Bei <application>boot0</application> handelt es sich um ein
          sehr einfaches Programm, da im <abbrev>MBR</abbrev> lediglich
          446&nbsp;Bytes verfügbar sind, weil der restliche Platz
          für die  Partitionstabelle sowie den
          <literal>0x55AA</literal>-Identifier
          am Ende des MBRs benötigt wird.  Falls Sie
          <application>boot0</application> verwenden und mehrere
          Betriebssysteme auf Ihrer Festplatte installiert haben, werden
          Sie beim Starten des Computers eine Anzeige ähnlich der
          folgenden sehen:</para></formalpara>

      <example xml:id="boot-boot0-example">
	<title><filename>boot0</filename>-Screenshot</title>

	<screen>F1 DOS
F2 FreeBSD
F3 Linux
F4 ??
F5 Drive 1

Default: F2</screen>
      </example>

      <para>Diverse Betriebssysteme, insbesondere &windows;,
        überschreiben den MBR ungefragt mit ihrem
        eigenen.  Falls einem dies passiert sein sollte, kann man mit
        folgendem Kommando den momentanen MBR durch den FreeBSD-MBR
        ersetzen:</para>

      <screen>&prompt.root; <userinput>fdisk -B -b /boot/boot0 Gerät</userinput></screen>

      <para>Bei <replaceable>Gerät</replaceable> handelt es sich
        um das Gerät, von dem gebootet wird, also beispielsweise
        <filename>ad0</filename> für die erste IDE-Festplatte,
        <filename>ad2</filename> für die erste IDE-Festplatte
        am zweiten IDE-Controller, <filename>da0</filename>
        für die erste SCSI-Festplatte, usw.  Diese Einstellungen
        können aber über &man.boot0cfg.8; angepasst
        werden.</para>

      <formalpara><title>Der LILO-Boot-Manager:</title>

        <para>Damit dieser Boot-Manager auch FreeBSD booten kann, starten
          Sie zuerst Linux und fügen danach folgende Zeilen in die
          Konfigurationsdatei <filename>/etc/lilo.conf</filename>
          ein:</para></formalpara>

      <programlisting>other=/dev/hdXY
table=/dev/hdX
loader=/boot/chain.b
label=FreeBSD</programlisting>

      <para>Dabei müssen Sie die primäre Partition von FreeBSD
	sowie dessen Platte im Linux-Format angeben.  Dazu ersetzen Sie
	<replaceable>X</replaceable> durch die Linux-Bezeichnung der
	Platte und <replaceable>Y</replaceable> durch die von Linux
	verwendete Partitionsnummer.  Wenn Sie ein
	<acronym>SCSI</acronym>-Laufwerk verwenden, müssen Sie
	<replaceable>/dev/sd</replaceable> anstelle von
	<replaceable>/dev/hd</replaceable> verwenden.  Die Zeile
	<option>loader=/boot/chain.b</option> kann weggelassen werden,
	wenn beide Betriebssysteme auf der gleichen Platte installiert
	sind.  Geben Sie danach <command>/sbin/lilo&nbsp;-v</command>
	ein, um Ihre Änderungen zu übernehmen.  Achtung Sie
	dabei besonders auf etwaige Fehlermeldungen.</para>
    </sect2>

    <sect2 xml:id="boot-boot1">
      <title>Phase Eins, <filename>/boot/boot1</filename> und Phase Zwei,
	<filename>/boot/boot2</filename></title>

      <para>Im Prinzip sind die erste und die zweite Phase Teile
        desselben Programms, im selben Bereich auf der
        Festplatte.  Aufgrund von Speicherplatz-Beschränkungen
        wurden sie aufgeteilt, aber man installiert sie eigentlich
        generell zusammen.  Beide werden entweder vom Installer oder
        von <application>bsdlabel</application> aus der kombinierten
        Datei <filename>/boot/boot</filename> kopiert.</para>

      <para>Beide Phasen befinden sich außerhalb des Dateisystems
        im Bootsektor des Boot-Slices, wo <link linkend="boot-boot0">boot0</link> oder ein anderer Boot-Manager
        ein Programm erwarten, das den weiteren Bootvorgang
        durchführen kann.  Die Anzahl der dabei verwendeten
        Sektoren wird durch die Größe von
        <filename>/boot/boot</filename> bestimmt.</para>

      <para><filename>boot1</filename> ist ein sehr einfaches
        Programm, da es nur 512&nbsp;Bytes groß sein darf, und es
        besitzt gerade genug Funktionalität, um FreeBSDs
        <firstterm>bsdlabel</firstterm>, das Informationen über
        den Slice enthält, auszulesen, und um
        <filename>boot2</filename> zu finden und
        auszuführen.</para>

      <para><filename>boot2</filename> ist schon ein wenig
        umfangreicher und besitzt genügend Funktionalität, um
        Dateien in FreeBSDs Dateisystem zu finden.  Außerdem hat es
        eine einfache Schnittstelle, die es ermöglicht, den zu
        ladenden Kernel oder Loader auszuwählen.</para>

      <para>Da der <link linkend="boot-loader">Loader</link> einen
        weitaus größeren Funktionsumfang hat und eine schöne
        und einfach zu bedienende Boot-Konfigurations-Schnittstelle zur
        Verfügung stellt, wird er gewöhnlich von
        <filename>boot2</filename> anstatt des Kernels
        gestartet.  Früher war es jedoch dazu da den Kernel direkt
        zu starten.</para>

      <example xml:id="boot-boot2-example">
	<title><filename>boot2</filename>-Screenshot</title>

	<screen>&gt;&gt; FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:</screen>
      </example>

      <para>Um das installierte
        <filename>boot1</filename> und <filename>boot2</filename> zu
        ersetzen, benutzt man &man.bsdlabel.8;:</para>

      <screen>&prompt.root; <userinput>bsdlabel -B diskslice</userinput></screen>

      <para>Wobei <replaceable>Slice</replaceable> das Laufwerk und die Slice
        darstellt, von dem gebootet wird, beispielsweise
        <filename>ad0s1</filename> für die erste Slice
        auf der ersten IDE-Festplatte.</para>

      <warning>
	<title>Dangerously Dedicated Mode</title>

	<para>Wenn man nur den Festplatten-Namen, also
          z.B. <filename>ad0</filename>, in &man.bsdlabel.8;
          benutzt wird eine "dangerously dedicated disk" erstellt,
          ohne Slices.  Das ist ein Zustand, den man meistens nicht
          hervorrufen möchte.  Aus diesem Grund sollte man ein
          &man.bsdlabel.8;-Kommando noch einmal prüfen, bevor
          man <keycap>Return</keycap> betätigt.</para>
      </warning>
    </sect2>

    <sect2 xml:id="boot-loader">
      <title>Phase drei, <filename>/boot/loader</filename></title>

      <indexterm><primary>boot-loader</primary></indexterm>
      <para>Der boot-loader ist der letzte von drei Schritten im
        Bootstrap-Prozess und kann im Dateisystem normalerweise unter
        <filename>/boot/loader</filename> gefunden werden.</para>

      <para>Der Loader soll eine benutzerfreundliche
        Konfigurations-Schnittstelle sein mit einem einfach zu
        bedienenden eingebauten Befehlssatz, ergänzt durch einen
        umfangreichen Interpreter mit einem komplexeren
        Befehlssatz.</para>

      <sect3 xml:id="boot-loader-flow">
        <title>Loader Ablauf</title>

        <para>Der Loader sucht während seiner Initialisierung
          nach Konsolen und Laufwerken, findet heraus, von welchem
          Laufwerk er gerade bootet, und setzt dementsprechend
          bestimmte Variablen.  Dann wird ein Interpreter gestartet,
          der Befehle interaktiv oder von einem Skript empfangen
          kann.</para>
        <indexterm><primary>loader</primary></indexterm>
        <indexterm><primary>loader Konfiguration</primary></indexterm>

        <para>Danach liest der Loader die Datei
          <filename>/boot/loader.rc</filename> aus, welche ihn
          standardmäßig anweist
          <filename>/boot/defaults/loader.conf</filename> zu lesen, wo
          sinnvolle Standardeinstellungen für diverse Variablen
          festgelegt werden und wiederum
          <filename>/boot/loader.conf</filename> für lokale
          Änderungen an diesen Variablen ausgelesen
          wird.  Anschließend arbeitet dann
          <filename>loader.rc</filename> entsprechend dieser Variablen
          und lädt die ausgewählten Module und den
          gewünschten Kernel.</para>

        <para>In der Voreinstellung wartet der Loader
          10&nbsp;Sekunden lang auf eine Tastatureingabe und bootet den
          Kernel, falls keine Taste betätigt wurde.  Falls doch
          eine Taste betätigt wurde wird dem Benutzer eine
          Eingabeaufforderung angezeigt.  Sie nimmt einen einfach zu
          bedienenden Befehlssatz entgegen, der es dem Benutzer
          erlaubt, Änderungen an Variablen vorzunehmen, Module zu
          laden, alle Module zu entladen oder schließlich zu booten
          bzw. neu zu booten.</para>

      </sect3>

      <sect3 xml:id="boot-loader-commands">
        <title>Die eingebauten Befehle des Loaders</title>

        <para>Hier werden nur die gebräuchlichsten Befehle
          bearbeitet.  Für eine erschöpfende Diskussion aller
          verfügbaren Befehle konsultieren Sie bitte
          &man.loader.8;.</para>

      <variablelist>
	<varlistentry>
	  <term>autoboot <replaceable>Sekunden</replaceable></term>

	  <listitem>
	    <para>Es wird mit dem Booten des Kernels fortgefahren,
              falls keine Taste in der gegebenen Zeitspanne
              betätigt wurde.  In der gegebenen Zeitspanne, Vorgabe
	      sind 10&nbsp;Sekunden, wird ein Countdown angezeigt.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>boot
	    <optional>-options</optional>
	    <optional>Kernelname</optional></term>

	  <listitem>
	    <para>Bewirkt das sofortige Booten des Kernels mit den
              gegebenen Optionen, falls welche angegeben wurden, und
              mit den angegebenen Kernel, falls denn einer angegeben
              wurde.  Das übergeben eines Kernelnamens ist nur
              nach einem <emphasis>unload</emphasis>-Befehl anwendbar,
              andernfalls wird der zuvor verwendete Kernel benutzt.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>boot-conf</term>

	  <listitem>
	    <para>Bewirkt die automatische Konfiguration der Module,
              abhängig von den entsprechenden Variablen.  Dieser
              Vorgang ist identisch zu dem Vorgang, den der Bootloader
              ausführt und daher nur sinnvoll, wenn zuvor
              <command>unload</command> benutzt wurde und Variablen
              (gewöhnlich <envar>kernel</envar>) verändert
              wurden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>help
	    <optional>Thema</optional></term>

	  <listitem>
	    <para>Zeigt die Hilfe an, die zuvor aus der Datei
              <filename>/boot/loader.help</filename> gelesen
              wird.  Falls <literal>index</literal> als Thema angegeben
              wird, wird die Liste der zur Verfügung stehenden
              Hilfe-Themen angezeigt.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>include <replaceable>Dateiname</replaceable>
	    &hellip;</term>

	  <listitem>
	    <para>Verarbeitet die angegebene Datei.  Das Einlesen und
	      Interpretieren geschieht Zeile für Zeile und wird im Falle eines
	      Fehlers umgehend unterbrochen.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>load <optional>-t
	    Typ</optional>
	    <replaceable>Dateiname</replaceable></term>

	  <listitem>
	    <para>Lädt den Kernel, das Kernel-Modul, oder die Datei
	      des angegebenen Typs.  Optionen, die auf den Dateinamen folgen, werden
	      der Datei übergeben.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>ls <optional>-l</optional>
	    <optional>Pfad</optional></term>

	  <listitem>
	    <para>Listet die Dateien im angegebenen Pfad auf, oder das
	      root-Verzeichnis(/), falls kein Pfad angegeben
	      wurde.  Die Option <option>-l</option> bewirkt, dass die
	      Dateigrössen ebenfalls angezeigt werden.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>lsdev <optional>-v</optional></term>

	  <listitem>
	    <para>Listet alle Geräte auf, für die Module geladen
	      werden können.  Die Option <option>-v</option> bewirkt
	      eine detailreichere Ausgabe.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>lsmod <optional>-v</optional></term>

	  <listitem>
	    <para>Listet alle geladenen Module auf.  Die Option
	      <option>-v</option> bewirkt eine detailreichere
	      Ausgabe.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>more <replaceable>Dateiname</replaceable></term>

	  <listitem>
	    <para>Zeigt den Dateinhalt der angegebenen Datei an, wobei
	      eine Pause alle <varname>LINES</varname> Zeilen gemacht
	      wird.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>reboot</term>

	  <listitem>
	    <para>Bewirkt einen umgehenden Neustart des Systems.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>set <replaceable>Variable</replaceable></term>
	  <term>set
	    <replaceable>Variable</replaceable>=<replaceable>Wert</replaceable></term>

	  <listitem>
	    <para>Setzt die Umgebungsvariablen des Loaders.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>unload</term>

	  <listitem>
	    <para>Entlädt sämtliche geladenen Module.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect3>

    <sect3 xml:id="boot-loader-examples">
      <title>Beispiele für die Loader Bedienung</title>

      <para>Hier ein paar praktische Beispiele für die Bedienung
	des Loaders.</para>

      <itemizedlist>
	<listitem>
	  <para>Um den gewöhnlichen Kernel im Single-User Modus<indexterm><primary>Single-User Modus</primary></indexterm> zu
	    starten:</para>

	  <screen><userinput>boot -s</userinput></screen>
	</listitem>

	<listitem>
	  <para>Um alle gewöhnlichen Kernelmodule zu entladen und dann
	    nur den alten (oder jeden beliebigen anderen) Kernel zu
	    laden:</para>

	  <screen><userinput>unload</userinput>
<userinput>load kernel.old</userinput></screen>

	  <para>Es kann <filename>kernel.GENERIC</filename> verwendet
            werden, um den allgemeinen Kernel zu bezeichnen, der
            vorinstalliert wird.  <filename>kernel.old</filename><indexterm><primary><filename>kernel.old</filename></primary></indexterm>
            bezeichnet den Kernel, der vor dem aktuellen installiert
            war (falls man einen neuen Kernel kompiliert und
            installiert hat zum Beispiel).</para>
	  <note>
	    <para>Der folgende Befehl lädt die gewöhnlichen Module mit
              einem anderen Kernel:</para>

	    <screen><userinput>unload</userinput>
<userinput>set kernel="kernel.old"</userinput>
<userinput>boot-conf</userinput></screen></note>
	</listitem>

	<listitem>
	  <para>Folgendes lädt ein Kernelkonfigurations-Skript (ein
	    automatisiertes Skript, dass dasselbe tut, was der
	    Benutzer normalerweise von Hand an der Eingabeaufforderung
	    durchführen würde):</para>

	  <screen><userinput>load -t userconfig_script /boot/kernel.conf</userinput></screen>
	</listitem>
      </itemizedlist>
    </sect3>

    <sect3 xml:id="boot-splash">
      <info><title>Willkommmensbildschirme während des Bootvorgangs</title>
        <authorgroup>
          <author><personname><firstname>Joseph J.</firstname><surname>Barbish</surname></personname><contrib>Contributed by </contrib></author>
        </authorgroup>

        <authorgroup>
          <author><personname><firstname>Benedict</firstname><surname>Reuschling</surname></personname><contrib>Übersetzt von </contrib></author>
        </authorgroup>
      </info>

      

      <para>Die Willkommmensbildschirme erzeugen einen visuell viel
        ansprechenderen Bootvorgang im Vergleich zu den herkömmlichen
        Bootmeldungen.  Diese Bildschirme werden entweder bis zu einem
        Konsolen-Login-Prompt oder dem eines X-Display Managers
        angezeigt.</para>

      <para>Es existieren zwei grundlegende Umgebungen in &os;.  Die erste
        ist die altbekannte, auf virtuellen Konsolen basierte Kommandozeile.
        Nachdem das System den Bootvorgang abgeschlossen hat, wird ein
        Anmeldebildschirm auf der Konsole anzeigt.  Die zweite Umgebung
        ist die graphische X11-Desktop Umgebung.  Nachdem <link linkend="x-install">X11</link> und eine der <link linkend="x11-wm">Graphischen Oberflächen</link>, wie
        <application>GNOME</application>, <application>KDE</application>, oder
        <application>XFce</application> installiert wurden, kann der
        X11-Desktop über das Kommando <command>startx</command>
        gestartet werden.</para>

      <para>Manche Benutzer ziehen den graphischen Anmeldebildschirm von X11
        dem traditionellen, textbasierten Anmeldeprompt vor.  Display-Manager
        wie <application>XDM</application> für &xorg;,
        <application>gdm</application> für
        <application>GNOME</application> und <application>kdm</application>
        für <application>KDE</application> (und viele weitere aus der
        Ports-Sammlung) bieten einen graphischen statt dem konsolenbasierten
        Anmeldebildschirm.  Nach einer erfolgreichen Anmeldung kann der
        Benutzer die graphische Oberfläche verwenden.</para>

      <para>In der Kommandozeilen-Umgebung würde der Willkommensbildschirm
        alle Erkennungsmeldungen des Bootvorgangs und die Startmeldungen von
        Diensten verstecken, bevor der Anmeldebildschirm erscheint.  In der
        X11-Umgebung erhalten die Anwender einen klareren visuellen Eindruck
        des Startvorgangs, ähnlich zu dem, den &microsoft; &windows;
        (oder ein nicht-Unix-artiger Systemtyp) zur Verfügung
        stellt.</para>

      <sect4 xml:id="boot-splash-function">
        <title>Willkommensbildschirm-Funktionalität</title>

        <para>Die Willkommensbildschirm-Funktionalität unterstützt
          nur 256-Farben Bitmaps (<filename>.bmp</filename>), ZSoft
          <acronym>PCX</acronym> (<filename>.pcx</filename>) oder
          TheDraw (<filename>.bin</filename>) Dateien.
          Zusätzlich muss die Willkommensbildschirm-Datei eine
          Auflösung von 320 mal 200 Pixeln oder weniger besitzen, damit
          Standard-VGA Geräte damit arbeiten können.</para>

        <para>Um grössere Bilder bis zu einer maximalen Auflösung
          von 1024 mal 768 Pixeln zu verwenden, muss Unterstützung
          für <acronym>VESA</acronym> in &os; enthalten sein.  Dies kann
          durch das Laden des <acronym>VESA</acronym>-Moduls während
          des Systemstarts geschehen, oder durch Hinzufügen der
          <literal>VESA</literal>-Kernelkonfigurationsoption und
          anschliessendem Bau des Kernels (Lesen Sie dazu <xref linkend="kernelconfig"/>).  Die
          <acronym>VESA</acronym>-Unterstützung ermöglicht es den
          Benutzern, Willkommensbildschirme als Vollbild anzuzeigen, die den
          gesamten Bildschirm ausfüllen.</para>

        <para>Wenn der Willkommensbildschirm beim Bootvorgang angezeigt wird,
          kann dieser jederzeit mit einem beliebigen Tastendruck ausgeschaltet
          werden.</para>

        <para>Der Willkommensbildschirm ist standardmässig so
          eingestellt, dass er als Bildschirmschoner ausserhalb von X11
          verwendet wird.  Nach einer bestimmten Zeit der Untätigkeit
          wird der Willkommensbildschirm angezeigt und wechselt durch
          verschiedene Stufen der Intensität von hell zu einem
          sehr dunklen Bild und wieder zurück.  Dieses Verhalten des
          Standard-Willkommensbildschirms (Screen-Saver) kann durch
          hinzufügen einer <literal>saver=</literal>-Zeile in
          <filename>/etc/rc.conf</filename> geändert werden.  Die Option
          <literal>saver=</literal> besitzt mehrere eingebaute Screen-Saver,
          aus denen man wählen kann, und deren komplette Liste in der
          &man.splash.4;-Manualpage enthalten ist.  Der Standard-Screen-Saver
          ist <quote>warp</quote>.  Beachten Sie, dass sich die
          <literal>saver=</literal>-Option in
          <filename>/etc/rc.conf</filename> nur auf virtuelle Konsolen
          bezieht.  Sie hat keinen Effekt auf X11-Display-Manager.</para>

        <para>Ein paar Nachrichten des Bootloaders und ganz besonders das
          Menü mit den Bootoptionen und dem Warte-Countdown werden
          zur Bootzeit angezeigt, selbst wenn der Willkommensbildschirm
          aktiviert ist.</para>

        <para>Dateien mit Beispiel-Willkommensbildschirmen können von
          der Galerie auf <link xlink:href="http://artwork.freebsdgr.org/node/3/">http://artwork.freebsdgr.orgb</link> heruntergeladen werden.
          Durch die Installation des Ports <package>sysutils/bsd-splash-changer</package> können
          Willkommensbildschirme von einer zufällig ausgewählten
          Sammlung von Bildern bei jedem Neustart angezeigt werden.</para>
      </sect4>

      <sect4 xml:id="boot-splash-enable">
        <title>Aktivieren der Willkommensbildschirm-Funktionalität</title>

        <para>Die Willkommensbildschirm-Datei (<filename>.bmp</filename>,
          <filename>.pcx</filename> oder <filename>.bin</filename>) muss
          im Wurzelverzeichnis, z.B. <filename>/boot</filename> abgelegt werden.</para>

        <para>Für die Standard-Auflösung (256-Farben, 320 mal
          200 Pixel oder weniger) beim Booten bearbeiten Sie die Datei
          <filename>/boot/loader.conf</filename>, so dass diese die
          folgenden Zeilen enthält:</para>

        <programlisting>splash_bmp_load="YES"
bitmap_load="YES"
bitmap_name="<replaceable>/boot/splash.bmp</replaceable>"</programlisting>

        <para>Für grössere Video-Auflösungen bis zum Maximum
          von 1024 mal 768 Pixeln ändern Sie die Datei
          <filename>/boot/loader.conf</filename>, damit diese die folgenden
          Zeilen enthält:</para>

        <programlisting>vesa_load="YES"
splash_bmp_load="YES"
bitmap_load="YES"
bitmap_name="<replaceable>/boot/splash.bmp</replaceable>"</programlisting>

        <para>Das Beispiel oben nimmt an, dass
          <filename>/boot/splash.bmp</filename>
          als Willkommensbildschirm verwendet wird.  Wenn eine
          <acronym>PCX</acronym>-Datei verwendet werden soll, benutzen Sie
          die folgenden Zeilen, inklusive der
          <literal>vesa_load="YES"</literal>-Zeile, abhängig von der
          Auflösung.</para>

        <programlisting>splash_pcx_load="YES"
bitmap_load="YES"
bitmap_name="<replaceable>/boot/splash.pcx</replaceable>"</programlisting>

        <para>In der Version 8.3 kann als weitere Option ascii-Kunst im
          <link xlink:href="https://en.wikipedia.org/wiki/TheDraw">TheDraw</link>
          Format verwendet werden.</para>

        <programlisting>splash_txt="YES"
bitmap_load="YES"
bitmap_name="<replaceable>/boot/splash.bin</replaceable>"</programlisting>

        <para>Wie das Beispiel oben demonstriert, ist der Dateiname nicht auf
          <quote>splash</quote> beschränkt.  Es ist beliebig, so lange
          es den Dateityp <acronym>BMP</acronym> oder <acronym>PCX</acronym>
          besitzt, z.B.
          <filename>splash_640x400.bmp</filename>
  	  oder
  	  <filename>blue_wave.pcx</filename>.</para>

        <para>Weitere interessante Optionen für
          <filename>loader.conf</filename> sind:</para>

        <variablelist>
          <varlistentry>
            <term><literal>beastie_disable="YES"</literal></term>

            <listitem>
              <para>Diese Option verhindert die Anzeige des Menüs mit
                den Bootoptionen, aber der Countdown ist immer noch aktiv.
                Selbst wenn das Bootmenü deaktiviert ist, kann
                während des Countdowns eine der korrespondierenden
                Optionen ausgewählt werden.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>loader_logo="beastie"</literal></term>

            <listitem>
              <para>Dies ersetzt die Standardanzeige des Wortes
                <quote>&os;</quote>. Stattdessen wird wie in der Vergangenheit
                auf der rechten Seite des Bootmenüs das bunte Beastie-Logo
                angezeigt.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Für weitere Informationen lesen Sie die Manualpages
          &man.splash.4;, &man.loader.conf.5; und &man.vga.4;.</para>
     </sect4>
    </sect3>
   </sect2>
  </sect1>

  <sect1 xml:id="boot-kernel">
    <title>Kernel Interaktion während des Bootprozesses</title>
    <indexterm>
      <primary>Kernel</primary>
      <secondary>boot interaction</secondary>
    </indexterm>

    <para>Wenn der Kernel einmal geladen ist, entweder durch den <link linkend="boot-loader">Loader</link> (die Standardmethode) oder
	durch <link linkend="boot-boot1">boot2</link> (den Loader
	umgehend), verhält sich gemäß seiner Boot-Flags, falls es
	welche gibt.</para>

    <sect2 xml:id="boot-kernel-bootflags">
      <title>Kernel Boot-Flags</title>
      <indexterm>
        <primary>Kernel</primary>
        <secondary>bootflags</secondary>
      </indexterm>

      <para>Es folgt eine Auflistung der gebräuchlichsten
        Boot-Flags:</para>

      <variablelist xml:id="boot-kernel-bootflags-list">
	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
	    <para>Bewirkt, dass der Benutzer während der
	      Kernel-Initialisierung gefragt wird, welches Gerät als
	      Root-Dateisystem gemounted werden soll.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-C</option></term>

	  <listitem>
	    <para>Es wird von CD-ROM gebootet.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-c</option></term>

	  <listitem>
	    <para>UserConfig, das Boot-Zeit Konfigurationsprogramm,
	      wird gestartet.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-s</option></term>

	  <listitem>
	    <para>Bewirkt den Start des Single-User Modus.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Zeigt mehr Informationen während des Starten des
	      Kernels an.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <note>
	<para>Andere Boot-Flags sind in der Hilfeseite
	  &man.boot.8; erläutert.</para></note>
    </sect2>

<!--    <sect2 id="boot-kernel-userconfig">
      <title>UserConfig: Das Boot-Zeit Konfigurationsprogramm</title>

      <para> </para>
    </sect2> -->
  </sect1>

  <sect1 xml:id="device-hints">
    <info><title>Konfiguration von Geräten</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
      
    </info>

    

    <indexterm>
      <primary>device.hints</primary>
    </indexterm>

    <para>Der Boot-Loader liest während des Systemstarts die Datei
      &man.device.hints.5;, die Variablen, auch <quote>device hints</quote>
      genannt, zur Konfiguration von Geräten enthält.</para>

    <para>Die Variablen können auch mit Kommandos in der <link linkend="boot-loader">Phase&nbsp;3 des Boot-Loaders</link> bearbeitet
      werden.  Neue Variablen werden mit <command>set</command> gesetzt,
      <command>unset</command> löscht schon definierte Variablen und
      <command>show</command> zeigt Variablen an.  Variablen aus
      <filename>/boot/device.hints</filename> können zu diesem Zeitpunkt
      überschrieben werden.  Die hier durchgeführten Änderungen
      sind nicht permanent und beim nächsten Systemstart nicht mehr
      gültig.</para>

    <para>Nach dem Systemstart können alle Variablen mit &man.kenv.1;
      angezeigt werden.</para>

    <para>Pro Zeile enthält <filename>/boot/device.hints</filename> eine
      Variable.  Kommentare werden, wie üblich, durch
      <literal>#</literal> eingeleitet.  Die verwendete Syntax
      lautet:</para>

    <screen><userinput>hint.driver.unit.keyword="value"</userinput></screen>

    <para>Der Boot-Loader verwendet die nachstehende Syntax:</para>

    <screen><userinput>set hint.driver.unit.keyword=value</userinput></screen>

    <para>Der Gerätetreiber wird mit <replaceable>driver</replaceable>,
      die Nummer des Geräts mit <replaceable>unit</replaceable>
      angegeben.  <replaceable>keyword</replaceable> ist eine Option aus
      der folgenden Liste:</para>

    <itemizedlist>
      <listitem>
	<para><option>at</option>: Gibt den Bus, auf dem sich das
	  Gerät befindet, an.</para>
      </listitem>

      <listitem>
	<para><option>port</option>: Die Startadresse des
	  <acronym>I/O</acronym>-Bereichs.</para>
      </listitem>

      <listitem>
	<para><option>irq</option>: Gibt die zu verwendende
	  Unterbrechungsanforderung (IRQ) an.</para>
      </listitem>

      <listitem>
	<para><option>drq</option>: Die Nummer des DMA Kanals.</para>
      </listitem>

      <listitem>
	<para><option>maddr</option>: Die physikalische Speicheradresse des
	  Geräts.</para>
      </listitem>

      <listitem>
	<para><option>flags</option>: Setzt verschiedene
	  gerätespezifische Optionen.</para>
      </listitem>

      <listitem>
	<para><option>disabled</option>: Deaktiviert das Gerät, wenn
	  der Wert auf <literal>1</literal> gesetzt wird.</para>
      </listitem>
    </itemizedlist>

    <para>Ein Gerätetreiber kann mehr Optionen, als die hier
      beschriebenen, besitzen oder benötigen.  Schlagen Sie die
      Optionen bitte in der Online-Hilfe des Treibers nach.  Weitere
      Informationen erhalten Sie in &man.device.hints.5;, &man.kenv.1;,
      &man.loader.conf.5; und &man.loader.8;.</para>
  </sect1>

  <sect1 xml:id="boot-init">
    <title>Init: Initialisierung der Prozess-Kontrolle</title>
    <indexterm>
      <primary><command>init</command></primary>
    </indexterm>

    <para>Nachdem der Kernel den Bootprozess abgeschlossen hat,
      übergibt er die Kontrolle an den Benutzer-Prozess
      &man.init.8;.  Dieses Programm befindet sich in
      <filename>/sbin/init</filename>, oder dem Pfad, der durch die
      Variable <envar>init_path</envar> im <command>Loader</command>
      spezifiziert wird.</para>

    <sect2 xml:id="boot-autoreboot">
      <title>Der automatische Reboot-Vorgang</title>

      <para>Der automatische Reboot-Vorgang stellt sicher, dass alle
        Dateisysteme des Systems konsistent sind.  Falls dies nicht der
        Fall ist und die Inkonsistenz nicht durch
        &man.fsck.8; behebbar ist, schaltet
        &man.init.8; das System in den <link linkend="boot-singleuser">Single-User Modus</link>, damit der
        Systemadministrator sich des Problems annehmen kann.</para>
    </sect2>

    <sect2 xml:id="boot-singleuser">
      <title>Der Single-User Modus</title>
      <indexterm><primary>Single-User Modus</primary></indexterm>
      <indexterm><primary>Konsole</primary></indexterm>

      <para>Das Schalten in diesen Modus kann erreicht werden durch <link linkend="boot-autoreboot">den automatischen
	Reboot-Vorgang</link>, durch das Booten mit der Option
	<option>-s</option> oder das Setzen der
	<envar>boot_single</envar> Variable in
	<command>Loader</command>.</para>

      <para>Weiterhin kann der Single-User Modus aus dem <link linkend="boot-multiuser">Mehrbenutzermodus</link> heraus durch
        den Befehl &man.shutdown.8; ohne die reboot
        (<option>-r</option>) oder halt (<option>-h</option>) Option
        erreicht werden.</para>

      <para>Falls die System-Konsole (<literal>console</literal>) in
        <filename>/etc/ttys</filename> auf <literal>insecure</literal>
        (dt.: unsicher) gesetzt ist, fordert das System allerdings zur
        Eingabe des Passworts von <systemitem class="username">root</systemitem> auf,
	bevor es den Single-User Modus aktiviert.</para>

      <example xml:id="boot-insecure-console">
	<title>Auf insecure gesetzte Konsole in
	  <filename>/etc/ttys</filename></title>

	<programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off insecure</programlisting>
      </example>

      <note>
        <para>Eine Konsole sollte auf <literal>insecure</literal>
	  gesetzt sein, wenn die physikalische Sicherheit der Konsole
	  nicht gegeben ist und sichergestellt werden soll, dass nur
	  Personen, die das Passwort von <systemitem class="username">root</systemitem> kennen,
	  den Single-User Modus benutzen können.  Es bedeutet nicht,
	  dass die Konsole "unsicher" laufen wird.  Daher sollte man
	  <literal>insecure</literal> wählen, wenn man auf Sicherheit
	  bedacht ist, nicht <literal>secure</literal>.</para>
      </note>
    </sect2>

    <sect2 xml:id="boot-multiuser">
      <title>Mehrbenutzermodus</title>
      <indexterm><primary>Mehrbenutzermodus</primary></indexterm>

      <para>Stellt &man.init.8; fest, dass das Dateisystem
        in Ordnung ist, oder der Benutzer den <link linkend="boot-singleuser">Single-User Modus</link> beendet,
        schaltet das System in den Mehrbenutzermodus, in dem dann die
        Ressourcen Konfiguration des Systems gestartet wird.</para>

      <sect3 xml:id="boot-rc">
	<title>Ressourcen Konfiguration, rc-Dateien</title>
      <indexterm><primary>rc-Dateien</primary></indexterm>

	<para>Das Ressourcen Konfigurationssystem (engl.
	  <foreignphrase>resource configuration</foreignphrase>, rc)
	  liest seine Standardkonfiguration von
	  <filename>/etc/defaults/rc.conf</filename> und
	  System-spezifische Details von
	  <filename>/etc/rc.conf</filename>.  Dann mountet es die
	  Dateisysteme gemäß <filename>/etc/fstab</filename>, startet
	  die Netzwerkdienste, diverse System Daemons und führt
	  schließlich die Start-Skripten der lokal installierten
	  Anwendungen aus.</para>

	<para>Die &man.rc.8; Handbuch Seite ist eine gute Quelle für
	  Informationen über das Ressourcen Konfigurationssystem und
	  ebenso über die Skripte an sich.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="boot-shutdown">
    <title>Der Shutdown-Vorgang</title>
    <indexterm>
      <primary><command>shutdown</command></primary>
    </indexterm>

    <para>Im Falle eines regulären Herunterfahrens durch
      &man.shutdown.8; führt &man.init.8;
      <filename>/etc/rc.shutdown</filename> aus, sendet dann
      sämtlichen Prozessen ein <literal>TERM</literal> Signal und
      schließlich ein <literal>KILL</literal> Signal an alle Prozesse,
      die sich nicht schnell genug beendet haben.</para>

    <para>FreeBSD-Systeme, die Energieverwaltungsfunktionen
      unterstützen, können Sie mit dem Kommando
      <command>shutdown -p now</command> ausschalten.  Zum Neustart des
      Systems benutzen Sie <command>shutdown -r now</command>.  Das
      Kommando &man.shutdown.8; kann nur von <systemitem class="username">root</systemitem> oder
      Mitgliedern der Gruppe <systemitem class="groupname">operator</systemitem> benutzt
      werden.  Sie können auch die Kommandos &man.halt.8; und
      &man.reboot.8; verwenden.  Weitere Informationen finden Sie in den
      Hilfeseiten der drei Kommandos.</para>

    <note>
      <para>Unter FreeBSD müssen Sie die
	&man.acpi.4;-Unterstützung im Kernel aktivieren oder das Modul
	geladen haben, damit Sie die Energieverwaltungsfunktionen benutzen
	können.</para>
    </note>
  </sect1>
</chapter>
