<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/firewalls/chapter.xml,v 1.53 2012/04/30 16:15:52 bcr Exp $
     basiert auf:  1.100
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="firewalls">
  <info><title>Firewalls</title>
    <authorgroup>
      <author><personname><firstname>Joseph J.</firstname><surname>Barbish</surname></personname><contrib>Beigetragen von </contrib></author>
    </authorgroup>
    <authorgroup>
      <author><personname><firstname>Brad</firstname><surname>Davis</surname></personname><contrib>Nach SGML konvertiert und aktualisiert von </contrib></author>
    </authorgroup>
    <authorgroup>
      <author><personname><firstname>Michael</firstname><surname>Bunzel</surname></personname><contrib>Übersetzt von </contrib></author>
      <author><personname><firstname>Johann</firstname><surname>Kois</surname></personname></author>
      <author><personname><firstname>Benjamin</firstname><surname>Lukas</surname></personname></author>
    </authorgroup>

  </info>

  

  <indexterm><primary>firewall</primary></indexterm>

  <indexterm>
    <primary>security</primary>

    <secondary>firewalls</secondary>
  </indexterm>

  <sect1 xml:id="firewalls-intro">
    <title>Einführung</title>

    <para>Firewalls ermöglichen es, den ein- und ausgehenden
      Netzwerkverkehr Ihres Systems zu filtern.  Dazu verwendet eine
      Firewall eine oder mehrere Gruppen von <quote>Regeln</quote>,
      um ankommende Netzwerkpakete zu untersuchen und entweder
      durchzulassen oder zu blockieren.  Die Regeln einer
      Firewall untersuchen charakteristische Eigenschaften von
      Datenpaketen, darunter den Protokolltyp, die Quell- und
      Zieladresse sowie den Quell- und Zielport.</para>

    <para>Firewalls können die Sicherheit eines Rechners oder
      eines Netzwerks erhöhen, indem sie folgende Aufgaben
      übernehmen:</para>

    <itemizedlist>
      <listitem>
        <para>Den Schutz der Anwendungen, Dienste und Rechner Ihres
          internen Netzwerks vor unerwünschtem Datenverkehr
          aus dem Internet.</para>
      </listitem>

      <listitem>
        <para>Die Beschränkung des Zugriffs von Rechnern des
          internen Netzwerk auf Rechner oder Dienste des externen
          Internets.</para>
      </listitem>

      <listitem>
        <para>Den Einsatz von Network Address Translation
          (<acronym>NAT</acronym>), die es Ihnen durch die Verwendung
          von privaten <acronym>IP</acronym>-Adressen ermöglicht,
          eine einzige gemeinsame Internetverbindung für mehrere
          Rechner zu nutzen (entweder über eine einzige Adresse
          oder über eine Gruppe von jeweils automatisch
          zugewiesenen öffentlichen
          <acronym>IP</acronym>-Adressen).</para>
      </listitem>
    </itemizedlist>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie:</para>

    <itemizedlist>
      <listitem>
      	<para>Wissen, wie man korrekte Paketfilterregeln erstellt.</para>
      </listitem>

      <listitem>
      	<para>Die Unterschiede zwischen den in &os; eingebauten Firewalls
      	  kennen.</para>
      </listitem>

      <listitem>
        <para>Wissen, wie man die <application>PF</application>-Firewall
          von OpenBSD konfiguriert und einsetzt.</para>
      </listitem>

      <listitem>
        <para><application>IPFILTER</application> konfigurieren und
          einsetzen können.</para>
      </listitem>

      <listitem>
        <para>Wissen, wie man <application>IPFW</application> konfiguriert
          und einsetzt.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie:</para>

    <itemizedlist>
      <listitem>
        <para>Die grundlegenden Konzepte von &os; und dem Internet
          verstehen.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="firewalls-concepts">
    <title>Firewallkonzepte</title>

    <indexterm>
      <primary>firewall</primary>

      <secondary>rulesets</secondary>
    </indexterm>

    <para>Es gibt zwei grundlegende Arten, Regelgruppen für
      Firewalls zu erstellen: <quote>einschließend</quote>
      (<foreignphrase>inclusive firewall</foreignphrase>) sowie
      <quote>auschließend</quote> (<foreignphrase>exclusive
      Firewall</foreignphrase>).  Eine auschließende Firewall
      lässt jeden Datenverkehr durch, der nicht durch eine Regel
      ausgeschlossen wurde.  Eine einschließende Firewall macht
      das genaue Gegenteil.  Sie lässt Datenverkehr nur dann
      durch, wenn er einer der definierten Regeln entspricht.</para>

    <para>Eine inclusive Firewall bietet eine wesentlich bessere Kontrolle
      des ausgehenden Verkehrs, macht sie zur besseren Wahl für Systeme,
      die Services für das Internet anbieten.  Sie kontrolliert
      auch den Verkehr vom Internet zu ihrem privaten Netzwerk.  Jeder Verkehr,
      der keiner Regel entspricht wird geblockt und geloggt.  Inclusive
      Firewalls sind generell sicherer als exclusive Firewalls, da sie das
      Risiko, dass unerwünschter Verkehr hindurch geht, drastisch
      reduzieren.</para>

    <note>
      <para>Wenn nicht anders vermerkt, verwenden alle Konfigurationen
        und Beispielregelsets dieses Kapitels inclusive Firewalls.</para>
    </note>

    <para>Die Sicherheit einer Firewall kann durch den Einsatz einer
      <quote>zustandsabhängigen Firewall</quote>
      (<foreignphrase>stateful firewall</foreignphrase>) weiter
      erhöht werden.  Dieser Typ einer Firewall
      überwacht alle durch die Firewall gehenden offenen
      Verbindungen und erlaubt nur schon bestehenden Verkehr oder
      Datenverkehr, der eine neue Verbindung öffnet.  Der Nachteil
      einer zustandsabhängigen Firewall ist allerdings, dass sie
      anfällig für Denial of Service (<acronym>DoS</acronym>)
      -Attacken ist, wenn sehr schnell sehr viele neue Verbindungen
      erstellt werden.  Bei den meisten Firewalls können Sie eine
      Kombination aus zustandsabhängigem und nicht
      zustandsabhängigem Verhalten verwenden, um eine für Ihre
      Bedürfnisse optimale Firewall einzurichten.</para>
  </sect1>

  <sect1 xml:id="firewalls-apps">
    <title>Firewallpakete</title>

    <para>Das Basissystem von &os; enthält bereits drei
      Firewallpakete:  <emphasis>IPFILTER</emphasis> (auch als
      <acronym>IPF</acronym> bekannt), <emphasis>IPFIREWALL</emphasis>
      (auch als <acronym>IPFW</acronym> bezeichnet) sowie das von OpenBSD
      übernommene <emphasis>PacketFilter</emphasis> (das auch als
      <acronym>PF</acronym> bezeichnet wird).  Zusätzlich
      verfügt &os; über zwei eingebaute Pakete für das
      sogenannte <foreignphrase>traffic shaping</foreignphrase> (dabei
      handelt es sich die Steuerung des Bandbreitenverbrauchs):
      &man.altq.4; sowie &man.dummynet.4;.  Dummynet steht traditionell
      in enger Verbindung mit <acronym>IPFW</acronym>, während
      <acronym>ALTQ</acronym> gemeinsam mit <acronym>PF</acronym>
      eingesetzt wird.  Traffic Shaping für IPFILTER ist derzeit
      mit IPFILTER für NAT sowie Filterung und
      mit <acronym>IPFW</acronym> und &man.dummynet.4;
      <emphasis>oder</emphasis> durch die Kombination von
      <acronym>PF</acronym> mit <acronym>ALTQ</acronym> möglich.
      Gemeinsam ist allen Firewallpaketen (IPF, IPFW sowie PF), dass sie
      Regeln einsetzen, um den Transfer von Datenpaketen auf und von
      Ihrem System zu regeln.  Unterschiedlich sind aber die Art und
      Weise, wie dies realisiert wird.  Auch die für diese Regeln
      verwendete Syntax ist unterschiedlich.</para>

    <para>&os; überlässt es dem Anwender, das Firewallsystem
      zu wählen, dass seinen Anforderungen und Vorlieben am Besten
      entspricht.  Keines der im Basissystem enthaltenen Firewallpakete
      wird dabei als <quote>das beste</quote> angesehen.</para>

    <para>IPFILTER hat etwa den Vorteil, dass dessen
      zustandsabhängige Regeln relativ einfach in einer
      <acronym>NAT</acronym>-Umgebung implementiert werden können.
      Außerdem verfügt es über einen eigenen FTP-Proxy,
      der die Erstellung von sicheren Regeln für ausgehende
      FTP-Verbindungen vereinfacht.</para>

    <para>Da alle Firewalls auf der Untersuchung der Werte
      ausgewählter Kontrollfelder von Datenpaketen basieren, ist es
      für die Erstellung von Firewallregeln notwendig, die
      Funktionsweise von <acronym>TCP/IP</acronym> zu verstehen.
      Außerdem muss man dazu wissen, was die Werte der einzelnen
      Kontrollfelder bedeuten und wie diese während einer
      Verbindung eingesetzt werden.  Eine gute Erklärung dieser
      Thematik finden Sie unter <uri xlink:href="http://www.ipprimer.com/overview.cfm">http://www.ipprimer.com/overview.cfm</uri>.</para>
  </sect1>

  <sect1 xml:id="firewalls-pf">
    <info><title>Paket Filter (PF) von OpenBSD und
      <acronym>ALTQ</acronym></title>
      <authorgroup>
        <author><personname><firstname>John</firstname><surname>Ferrell</surname></personname><contrib>Revised and updated by </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>firewall</primary>

      <secondary>PF</secondary>
    </indexterm>

    <para>Im Juli 2003 wurde <acronym>PF</acronym>, die
      Standard-Firewall von OpenBSD, nach &os; portiert und in die
      &os;-Ports-Sammlung aufgenommen.  2004 war <acronym>PF</acronym> in
      &os;&nbsp;5.3 Teil des Basissystems.  Bei <acronym>PF</acronym>
      handelt es sich um eine komplette, vollausgestattete Firewall,
      die optional auch <acronym>ALTQ</acronym> (Alternatives
      Queuing) unterstützt.  <acronym>ALTQ</acronym> bietet Ihnen
      <foreignphrase>Quality of Service</foreignphrase>
      (<acronym>QoS</acronym>)-Bandbreitenformung.</para>

    <para>Das OpenBSD-Projekt leistet bereits hervorragende
      Dokumentationsarbeit mit der <link xlink:href="http://www.openbsd.org/faq/pf/">PF FAQ</link>.  Aus diesem Grund
      konzentriert sich dieser Handbuchabschnitt nur auf diejenigen
      Besonderheiten von <acronym>PF</acronym>, die &os; betreffen, sowie ein
      paar allgemeine Informationen hinsichtlich der Verwendung.  Genauere
      Informationen zum Einsatz erhalten Sie in der <link xlink:href="http://www.openbsd.org/faq/pf/">PF FAQ</link>.</para>

    <para>Weitere Informationen zu <acronym>PF</acronym> für &os; finden
      Sie unter <uri xlink:href="http://pf4freebsd.love2party.net/">http://pf4freebsd.love2party.net/</uri>.</para>

    <sect2>
      <title>Verwendung der PF-Kernelmodule</title>

      <para>Um die PF Kernel Module zu laden, fügen Sie folgende
        Zeile in ihre <filename>/etc/rc.conf</filename> ein:</para>

      <programlisting>pf_enable="YES"</programlisting>

      <para>Danach starten Sie das Startup Script um die Module
        zu laden:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/pf start</userinput></screen>

      <para>Das PF Modul wird nicht geladen, falls es die Ruleset
        Konfigurationsdatei nicht findet.  Standardmässig befindet
        sich diese Datei in <filename>/etc/pf.conf</filename>.  Falls das
        PF Ruleset sich an einem anderen Platz befindet, können Sie das
        durch Hinzufügen einer Zeile ähnlich der folgenden, in
        ihrer <filename>/etc/rc.conf</filename> ändern:</para>

      <programlisting>pf_rules="<replaceable>/path/to/pf.conf</replaceable>"</programlisting>

      <note>
		<para>Ein Beispiel für die Datei <filename>pf.conf</filename>
		  finden Sie im Verzeichnis <filename>/usr/share/examples/pf/</filename>.</para>
      </note>

      <para>Das <acronym>PF</acronym>-Modul kann auch manuell über die
        Kommandozeile geladen werden:</para>

      <screen>&prompt.root; <userinput>kldload pf.ko</userinput></screen>

      <para>Protokollierungsfunktionen für PF werden durch das Modul
        <literal>pflog.ko</literal> zur Verfügung gestellt und
        können durch folgenden Eintrag in der
        <filename>/etc/rc.conf</filename> aktiviert werden:</para>

      <programlisting>pflog_enable="YES"</programlisting>

      <para>Danach starten Sie das Startup Script, um das Modul
        zu laden:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/pflog start</userinput></screen>

      <para>Falls Sie noch weitere Features für
        <acronym>PF</acronym> benötigen, müssen Sie diese in den
        Kernel einbauen.</para>
    </sect2>

    <sect2>
      <title>PF Kernel-Optionen</title>

      <indexterm>
		<primary>Kerneloptionen</primary>

		<secondary>device pf</secondary>
      </indexterm>

      <indexterm>
		<primary>Kerneloptionen</primary>

		<secondary>device pflog</secondary>
      </indexterm>

      <indexterm>
		<primary>Kerneloptionen</primary>

		<secondary>device pfsync</secondary>
      </indexterm>

      <para>Es ist nicht zwingend nötig, dass Sie
        <acronym>PF</acronym>-Unterstützung in den &os;-Kernel
        kompilieren.  Sie werden dies tun müssen, um eine von PFs
        fortgeschritteneren Eigenschaften nutzen zu können, die nicht als
        Kernelmodul verfügbar ist.  Genauer handelt es sich dabei um
        &man.pfsync.4;, ein Pseudo-Gerät, welches bestimmte
        Änderungen der <acronym>PF</acronym>-Zustandstabelle offenlegt.
        Es kann mit &man.carp.4; kombiniert werden, um ausfallsichere
        Firewalls mit <acronym>PF</acronym> zu realisieren.  Weitere
        Informationen zu <acronym>CARP</acronym> erhalten Sie in
        <xref linkend="carp"/> des Handbuchs.</para>

      <para>Die Kernelkonfigurationsoptionen von <acronym>PF</acronym> befinden
        sich in <filename>/usr/src/sys/conf/NOTES</filename> und sind im
        Folgenden wiedergegeben:</para>

      <programlisting>device pf
device pflog
device pfsync</programlisting>

      <para>Die Option <literal>device pf</literal> aktiviert die
        Unterstützung für die <quote>Packet
        Filter</quote>-Firewall (&man.pf.4;).</para>

      <para>Die Option <literal>device pflog</literal> aktiviert das optionale
        &man.pflog.4;-Pseudonetzwerkgerät, das zum Protokollieren
        des Datenverkehrs über einen &man.bpf.4;-Deskriptor
        dient.  &man.pflogd.8; ist in der Lage, diese Protokolldateien
        auf Ihre Platte zu speichern.</para>

      <para>Die Option <literal>device pfsync</literal> aktiviert das optionale
        &man.pfsync.4;-Pseudonetzwerkgerät für die
        Überwachung von <quote>Statusänderungen</quote>.</para>
    </sect2>

    <sect2>
      <title>Verfügbare rc.conf-Optionen</title>

      <para>Die	folgenden &man.rc.conf.5;-Einträge konfigurieren
        <acronym>PF</acronym> und &man.pflog.4; beim Systemstart:</para>

      <programlisting>pf_enable="YES"                 # PF aktivieren (Modul, wenn nötig, aktivieren)
pf_rules="/etc/pf.conf"         # Datei mit Regeldefinitionen für pf
pf_flags=""                     # zusätzliche Parameter für den Start von pfctl
pflog_enable="YES"              # starte pflogd(8)
pflog_logfile="/var/log/pflog"  # wo soll pflogd die Protokolldatei speichern
pflog_flags=""                  # zusätzliche Parameter für den Start von pflogd</programlisting>

      <para>Wenn Sie ein lokales Netzwerk hinter dieser Firewall betreiben
        und Pakete für dessen Rechner weiterleiten oder NAT verwenden
        wollen, benötigen Sie zusätzlich die folgende Option:</para>

      <programlisting>gateway_enable="YES"            # LAN Gateway aktivieren</programlisting>
    </sect2>

    <sect2>
      <title>Filterregeln erstellen</title>

      <para><acronym>PF</acronym> liest seine konfigurierten Regeln aus
        &man.pf.conf.5; (standardmässig <filename>/etc/pf.conf</filename>)
        und modifiziert, verwirft oder lässt Pakete passieren anhand der
        Regeln oder Definitionen, die in dieser Datei gespeichert sind.  &os;
        enthält dazu nach der Installation mehrere Beispieldateien, die
        in <filename>/usr/share/examples/pf/</filename> abgelegt sind.
        Für eine ausführliche Behandlung des
        <acronym>PF</acronym>-Regelwerks lesen Sie bitte die <link xlink:href="http://www.openbsd.org/faq/pf/">PF FAQ</link>.</para>

      <warning>
        <para>Beim Lesen der <link xlink:href="http://www.openbsd.org/faq/pf/">PF FAQ</link> wollten Sie
          darauf achten, dass verschiedene Versionen von &os; auch
          unterschiedliche Versionen von PF enthalten.
	  &os;&nbsp;8.<replaceable>X</replaceable> (und älter)
          &os;-Versionen benutzen <acronym>PF</acronym> aus OpenBSD&nbsp;4.1.
	  &os;&nbsp;9.<replaceable>X</replaceable> (und neuer) benutzen
	  hingegen <acronym>PF</acronym> aus OpenBSD&nbsp;4.5.</para>
      </warning>

      <para>Die &a.pf; ist eine erste Anlaufstelle für
        Fragen zur Konfiguration und dem Einsatz der <acronym>PF</acronym>
        Firewall.  Vergessen Sie nicht, vorher die Mailinglistenarchive zu
        durchsuchen, bevor Sie dort eine Frage stellen!</para>
    </sect2>

    <sect2>
      <title>Arbeiten mit PF</title>

      <para>Benutzen Sie &man.pfctl.8;, um <acronym>PF</acronym> zu steuern.
        Unten finden Sie ein paar nützliche Befehle (lesen Sie auch die
        Manualpage zu &man.pfctl.8;, um alle verfügbaren Optionen
        nachzuschlagen):</para>

      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Befehl</entry>
              <entry>Zweck</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><command>pfctl -e</command></entry>
              <entry>PF aktivieren</entry>
            </row>

            <row>
              <entry><command>pfctl -d</command></entry>
              <entry>PF deaktivieren</entry>
            </row>

            <row>
              <entry><command>pfctl -F all -f /etc/pf.conf</command></entry>
              <entry>Alle Filterregeln zurücksetzen (NAT, Filter, Zustand,
                Tabelle, etc.) und erneut aus der Datei
                <filename>/etc/pf.conf</filename> auslesen</entry>
            </row>

            <row>
              <entry><command>pfctl -s [ rules | nat |
                states ]</command></entry>
              <entry>Bericht über die Filterregeln, NAT-Regeln, oder
                Zustandstabellen</entry>
            </row>

            <row>
              <entry><command>pfctl -vnf /etc/pf.conf</command></entry>
              <entry>überprüft <filename>/etc/pf.conf</filename> auf
                Fehler, lädt aber das Regelwerk nicht neu</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title><acronym>ALTQ</acronym> aktivieren</title>

      <para><acronym>ALTQ</acronym> muss vor der Verwendung in den
        &os;-Kernel kompiliert werden.  Beachten Sie, dass
        <acronym>ALTQ</acronym> nicht von allen verfügbaren
        Netzwerkkartentreibern unterstützt wird.  Sehen Sie daher
        zuerst in &man.altq.4; nach, ob Ihre Netzwerkkarte diese
        Funktion unter Ihrer &os;-Version unterstützt.</para>

      <para>Die	folgenden Kerneloptionen aktivieren <acronym>ALTQ</acronym>
        sowie alle Zusatzfunktionen:</para>

      <programlisting>options         ALTQ
options         ALTQ_CBQ        # Class Bases Queuing (CBQ)
options         ALTQ_RED        # Random Early Detection (RED)
options         ALTQ_RIO        # RED In/Out
options         ALTQ_HFSC       # Hierarchical Packet Scheduler (HFSC)
options         ALTQ_PRIQ       # Priority Queuing (PRIQ)
options         ALTQ_NOPCC      # Wird von SMP benötigt</programlisting>

      <para><literal>options ALTQ</literal> aktiviert das
	<acronym>ALTQ</acronym>-Framework.</para>

      <para><literal>options ALTQ_CBQ</literal> aktiviert das
        <emphasis>Class Based Queuing</emphasis> (<acronym>CBQ</acronym>).
        <acronym>CBQ</acronym> erlaubt es, die Bandbreite einer Verbindung in
        verschiedene Klassen oder Warteschlangen zu unterteilen, um die
        Priorität von Datenpaketen basierend auf Filterregeln zu
        ändern.</para>

      <para><literal>options ALTQ_RED</literal> aktiviert
        <emphasis>Random Early Detection</emphasis>
        (<acronym>RED</acronym>).  <acronym>RED</acronym> wird
        zur Vermeidung einer Netzwerkverstopfung verwendet.  Dazu
        ermittelt <acronym>RED</acronym> die Größe der
        Warteschlange und vergleicht diesen Wert mit den minimalen
        und maximalen Grenzwerten der Warteschlange.  Ist die
        Warteschlange größer als das erlaubte Maximum,
        werden alle neuen Pakete verworfen.  Getreu seinem Namen
        verwirft <acronym>RED</acronym> Pakete unterschiedlicher
        Verbindungen nach dem Zufallsprinzip.</para>

      <para><literal>options ALTQ_RIO</literal> aktiviert
        <emphasis>Random Early Detection In and	Out</emphasis>.</para>

      <para><literal>options ALTQ_HFSC</literal> aktiviert den
        <emphasis>Hierarchical Fair Service Curve</emphasis>-Paketplaner.
        Weitere Informationen zu <acronym>HFSC</acronym> finden Sie
        unter <uri xlink:href="http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html">http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html</uri>.</para>

      <para><literal>options ALTQ_PRIQ</literal> aktiviert
        <emphasis>Priority Queuing</emphasis> (<acronym>PRIQ</acronym>).
        <acronym>PRIQ</acronym>	lässt Verkehr einer Warteschlange mit
        höherer Priorität zuerst durch.</para>

      <para><literal>options ALTQ_NOPCC</literal> aktiviert die
        <acronym>SMP</acronym> Unterstützung von
        <acronym>ALTQ</acronym>.  Diese Option ist nur auf
        <acronym>SMP</acronym>-System erforderlich.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="firewalls-ipf">
    <title>Die IPFILTER-Firewall (IPF)</title>

    <indexterm>
      <primary>firewall</primary>

      <secondary>IPFILTER</secondary>
    </indexterm>

    <para>Geschrieben wurde IPFILTER von Darren Reed.  IPFILTER ist vom
      Betriebssystem unabhängig: Es ist eine Open Source Anwendung,
      die auf die Betriebssysteme &os;, NetBSD, OpenBSD, &sunos;, HP/UX
      und &solaris; portiert wurde.  IPFILTER wird aktiv betreut und
      gepflegt.  Es werden regelmäßig neue Versionen
      herausgegeben.</para>

    <para>IPFILTER basiert auf einer kernelseitigen Firewall und einem
      <acronym>NAT</acronym> Mechanismus, der durch Anwenderprogramme
      betreut und gesteuert werden kann.  Die Regeln der Firewall werden
      mit dem Programm &man.ipf.8; gesetzt oder gelöscht.  Für
      die Manipulation der <acronym>NAT</acronym> Regeln verwendet man
      &man.ipnat.1;.  Mit &man.ipfstat.8; werden Laufzeitstatistiken der
      kernelseitigen Anteile von IPFILTER aufgelistet.  Und mit dem
      Programm &man.ipmon.8; kann man die Aktionen von IPFILTER in die
      Protokolldateien des Systems speichern.</para>

    <para>IPF funktionierte ursprünglich mit einer
      Regel-Prozess-Logik &agrave; la <quote>die letzte Regel, die
      passt, entscheidet</quote> und verwendete ausschließlich
      Regeln ohne feste Zustände.  Inzwischen wurde die
      Regel-Prozess-Logik drastisch modernisiert:  Es gibt eine
      <option>quick</option> und eine zustandsorientierte <option>
      keep-state</option> Option.  Die offizielle Dokumentation beinhaltet
      leider nur die veralteten Parameter zur Regelerstellung - die neuen
      Funktionen werden nur als Zusatzoptionen aufgelistet, was ihre
      Vorteile beim Erstellen einer weit überlegenen und viel
      sichereren Firewall völlig untergräbt.</para>

    <para>Die Anweisungen in diesem Kapitel basieren darauf, Regeln mit
      den Optionen <option>quick</option> und <option>keep-state</option>
      zu erstellen.  Mit diesem Grundwissen wird man einen kompletten
      einschließenden Regelsatz erstellen können.</para>

    <para>Für eine ausführliche Erläuterung der alten Methode
      zur Regelverarbeitung schauen Sie bitte auf <uri xlink:href="http://www.obfuscation.org/ipf/ipf-howto.html#TOC_1">http://www.obfuscation.org/ipf/ipf-howto.html#TOC_1</uri>
      oder <uri xlink:href="http://coombs.anu.edu.au/~avalon/ip-filter.html">http://coombs.anu.edu.au/~avalon/ip-filter.html</uri>.</para>

    <para>Antworten auf häufige Fragen finden Sie unter
      <uri xlink:href="http://www.phildev.net/ipf/index.html">http://www.phildev.net/ipf/index.html</uri>.</para>

    <para>Und ein durchsuchbares Archiv der Mailingliste zu IPFILTER
      gibt es unter <uri xlink:href="http://marc.theaimsgroup.com/?l=ipfilter">http://marc.theaimsgroup.com/?l=ipfilter</uri>.</para>

    <sect2>
      <title>Aktivieren von IPF</title>

      <indexterm>
	<primary>IPFILTER</primary>

	<secondary>enabling</secondary>
      </indexterm>

      <para>&os; enthält IPF in der Standardversion als ladbares
        Kernelmodul.  Dieses Modul wird vom System automatisch geladen,
        wenn in der <filename>rc.conf</filename> der Eintrag<literal>
        ipfilter_enable="YES"</literal> angelegt wird. In dieser
        ursprünglichen Konfiguration ist die Protokollierung aktiv
        und	die Option <literal>default pass all</literal> ("Pakete passieren
        lassen") als Standard gesetzt.  Um die <literal>block all</literal>
        ("alles Blockieren") Option zu setzen, muss man nicht gleich
        einen neuen Kernel bauen - es reicht, <literal>block all</literal>
        als letzte Position des Regelsatzes aufzulisten.</para>
    </sect2>

    <sect2>
      <title>Kernel-Optionen</title>

	  <indexterm>
	  	<primary>Kerneloptionen</primary>

		<secondary>IPFILTER</secondary>
      </indexterm>

      <indexterm>
		<primary>Kerneloptionen</primary>

		<secondary>IPFILTER_LOG</secondary>
      </indexterm>

      <indexterm>
		<primary>Kerneloptionen</primary>

		<secondary>IPFILTER_DEFAULT_BLOCK</secondary>
      </indexterm>

      <indexterm>
		<primary>IPFILTER</primary>

		<secondary>Kerneloptionen</secondary>
      </indexterm>

      <para>Es ist nicht unbedingt notwendig, IPF durch die folgenden
        Optionen direkt in der Kernel einzubinden.  Diese Möglichkeit
        der Verwendung von IPF wird hier mehr als Hintergrundwissen angeboten.
        Man sollte nur wissen, dass dadurch nicht mehr das Kernelmodul geladen
        wird - und dementsprechend auch nicht mehr entladen werden kann.</para>

      <para>Die Beschreibung der einzelnen Optionen von IPF für die
        Verwendung in der Kernelkonfiguration finden Sie auch in der Datei
        <filename>/usr/src/sys/conf/NOTES</filename>.</para>

      <programlisting>options IPFILTER
options IPFILTER_LOG
options IPFILTER_DEFAULT_BLOCK</programlisting>

      <para><literal>options IPFILTER</literal> aktiviert die Verwendung
	der <quote>IPFILTER</quote> Firewall.</para>

      <para><literal>options IPFILTER_LOG</literal> aktiviert den
        Logging-Mechanismus.  Das bedeutet, dass jedes Paket geloggt wird,
        auf das eine Regel passt, die das Schlüsselwort
        <literal>log</literal> enthält.  Dazu wird der
        Pseudo&mdash;Device	<filename>ipl</filename> verwendet.</para>

      <para><literal>options IPFILTER_DEFAULT_BLOCK</literal> ändert
        das Verhalten der Firewall dahingehend, dass jedes Paket, dass nicht
        explizit von einer <literal>pass</literal> Regel Zugang erhält,
        abgewiesen, bzw. geblockt, wird.</para>

      <para>Diese Einstellungen werden erst aktiv, wenn der Kernel, in den sie
      	eingebunden wurden, kompiliert, installiert und gebootet wurde.</para>
    </sect2>

    <sect2>
      <title>Optionen in rc.conf</title>

      <para>Um IPF während des Bootvorgangs einzubinden, braucht man
        lediglich die folgenden Zeilen der Datei
        <filename>/etc/rc.conf</filename> anzufügen:</para>

      <programlisting>ipfilter_enable="YES"             # Startet IPF
ipfilter_rules="/etc/ipf.rules"   # liest den Regelsatz aus einer Datei
ipmon_enable="YES"                # Startet das IP-Monitor Log
ipmon_flags="-Ds"                 # D = Als Da:mon starten
                                  # s = Protokollierung via syslog
                                  # v = Protokollierung von tcp window, ack, seq
                                  # n = Namen statt IP &amp; port ausgeben
      </programlisting>

      <para>Falls sich hinter der Firewall ein lokales Netzwerk befindet,
        das den reservierten privaten Adressbereich verwendet, müssen
        die folgenden Zeilen zur Aktivierung von <acronym>NAT</acronym>
        ebenfalls in <filename>/etc/rc.conf</filename> eingetragen
        werden:</para>

      <programlisting>gateway_enable="YES"              # Aktivierung des LAN-Gateways
ipnat_enable="YES"                # Startet die ipnat Funktion
ipnat_rules="/etc/ipnat.rules"    # Liest die ipnat-Regeldefinitionen aus einer Datei
      </programlisting>
    </sect2>

    <sect2>
      <title>Der Befehl ipf</title>

      <indexterm><primary><command>ipf</command></primary></indexterm>

      <para>Mit dem Befehl &man.ipf.8; liest man die Datei, die den Regelsatz
      	enthält ein.  Mit dem folgenden Befehl können Sie Ihre
      	eigenen, für Ihr System maßgeschneiderten Regeln einlesen
      	und so in einem Schritt alle Regeln der laufenden Firewall
      	ersetzen:</para>

      <screen>&prompt.root; <userinput>ipf -Fa -f /etc/ipf.rules</userinput></screen>

      <para><option>-Fa</option> bedeutet, dass alle intern gespeicherten
        Tabellen mit Regeln gelöscht werden.</para>

      <para><option>-f</option> gibt die Datei an, aus der die neuen Regeln
        gelesen werden sollen.</para>

      <para>Mit diesen beiden Optionen erhalten Sie die Möglichkeit,
        Änderungen an der Datei mit Ihrem Regelsatz vorzunehmen und
        gleich die Firewall mit den neuen Regeln zu bestücken, ohne
        den Rechner neu starten zu müssen.  Da dieser Vorgang beliebig
        wiederholt werden kann, ist es ein sehr bequemer Weg, neue Regeln
        einzuarbeiten und zu testen.</para>

      <para>Um mehr über diese und weitere Optionen von &man.ipf.8;
        zu erfahren, konsultieren Sie bitte die Manpage.</para>

      <para>&man.ipf.8; erwartet, dass es sich bei der Datei mit dem Regelsatz
        um eine Standard-Textdatei handelt.  Eine Datei, die ein Skript oder
        Variablen enthält, wird nicht verarbeitet.</para>

      <para>Es gibt allerdings doch einen Weg, IPF Regeln mit Hilfe von
        Skripten und Variablen zu erstellen.  Weitere Informationen dazu
        finden Sie unter <xref linkend="firewalls-ipf-rules-script"/>.</para>
    </sect2>

    <sect2>
      <title>IPFSTAT</title>

      <indexterm><primary><command>ipfstat</command></primary></indexterm>

      <indexterm>
		<primary>IPFILTER</primary>

		<secondary>statistics</secondary>
     </indexterm>

      <para>Das normale Verhalten von &man.ipfstat.8; ist, die Zusammenfassung
      	der angefallenen Statistiken, die als Resultat der Anwendung von
      	nutzerspezifischen Regeln auf ein- und ausgehende Pakete seit dem
      	letzten Start der Firewall oder seit dem letzten Zurücksetzen
      	der Zähler auf Null durch das Kommando
      	<command>ipf -Z</command> angesammelt wurden, abzurufen und
      	anzuzeigen.</para>

      <para>Für weiterführende Informationen schauen Sie bitte
        auf die Manpage von &man.ipfstat.8;!</para>

      <para>Die Ausgabe von &man.ipfstat.8;, wenn keine Parameter
        übergeben wurden, sieht etwa so aus:</para>

      <screen>input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0
output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0
input packets logged: blocked 99286 passed 0
output packets logged: blocked 0 passed 0
packets logged: input 0 output 0
log failures: input 3898 output 0
fragment state(in): kept 0 lost 0
fragment state(out): kept 0 lost 0
packet state(in): kept 169364 lost 0
packet state(out): kept 431395 lost 0
ICMP replies: 0 <acronym>TCP</acronym> RSTs sent: 0
Result cache hits(in): 1215208 (out): 1098963
IN Pullups succeeded: 2 failed: 0
OUT Pullups succeeded: 0 failed: 0
Fastroute successes: 0 failures: 0
<acronym>TCP</acronym> cksum fails(in): 0 (out): 0
Packet log flags set: (0)</screen>

      <para>Wenn die Option <option>-i</option> für
        <quote>eingehend</quote> oder <option>-o</option> für
        <quote>ausgehend</quote> übergeben wird, liefert das Kommando
        eine entsprechende Liste von Filter-Regeln, die gerade installiert
        sind und vom Kernel verwendet werden.</para>

      <para><command>ipfstat -in</command> zeigt alle aktive Regeln
        für eingehende Verbindungen zusammen mit ihren Nummern.</para>

      <para><command>ipfstat -on</command> erledigt dasselbe für die
      	ausgehenden Verbindungen.</para>

      <para>Die Ausgabe sieht in etwa folgendermaßen aus:</para>

      <screen>@1 pass out on xl0 from any to any
@2 block out on dc0 from any to any
@3 pass out quick on dc0 proto tcp/udp from any to any keep state</screen>

      <para><command>ipfstat -ih</command> zeigt die Tabelle der aktiven
        Regeln für eingehende Verbindungen zusammen mit der Anzahl,
        wie oft jeder einzelnen Regel entsprochen wurde.</para>

      <para><command>ipfstat -oh</command> zeigt das Gleiche für
      	die ausgehenden Verbindungen.</para>

      <para>Hier wird die Ausgabe so oder so ähnlich aussehen:</para>

      <screen>2451423 pass out on xl0 from any to any
354727 block out on dc0 from any to any
430918 pass out quick on dc0 proto tcp/udp from any to any keep state</screen>

      <para>Einer der wichtigsten Funktionen von <command>ipfstat</command>
        wird über die Option <option>-t</option> bereitgestellt.  Mit
        ihr wird eine Statustabelle vergleichbar der Prozess-Tabelle
        von &man.top.1; ausgegeben.  Mit dieser Funktion erhalten Sie im
        Falle eines Angriffs die Möglichkeit, die angreifenden Pakete
        zu identifizieren, abzufangen und auszuwerten.  Weitere Unteroptionen
        eröffnen, die IP-Adresse, den Port oder das Protokoll, geteilt
        nach Herkunft und Ziel, auszuwählen und dann in Echtzeit zu
        beobachten. Lesen Sie dazu bitte auch die Manpage von
        &man.ipfstat.8;.</para>
    </sect2>

    <sect2>
      <title>IPMON</title>

      <indexterm><primary><command>ipmon</command></primary></indexterm>

      <indexterm>
		<primary>IPFILTER</primary>

		<secondary>logging</secondary>
     </indexterm>

      <para>Damit der Befehl <command>ipmon</command> korrekt arbeiten kann,
        muss die Option <literal>IPFILTER_LOG</literal> in die
        Kernelkonfiguration eingearbeitet werden.  Das Kommando selbst
        arbeitet in zwei verschiedenen Modi.  Für den nativen Modus
        startet man <command>ipmon</command> auf der Kommandozeile ohne die
        Option <option>-D</option>.</para>

      <para>Der Hintergrundmodus (<literal>daemon mode</literal>) dient der
        Erstellung eines stetigen Systemprotokolls, so dass Einträge
        vergangener Ereignisse inspiziert werden können. So sollen &os;
        und IPFILTER entsprechend ihrer Konfiguration zusammen arbeiten.
        &os; kann mit einem eingebauten Mechanismus Systemprotokolle
        turnusmäßig abspeichern.  Aus diesem Grund sollte man
        besser &man.syslogd.8; verwenden anstatt die Protokollinformationen
        in eine Datei zu schreiben, wie es als Standard vorgesehen ist.  In
        der Standard-<filename>rc.conf</filename>-Datei (im Ordner
        <filename>/etc/defaults/</filename>) wird dem Eintrag
        <literal>ipmon_flags</literal> die Option <option>-Ds</option>
        übergeben:</para>

      <programlisting>ipmon_flags="-Ds" # D = Als Da:mon starten
# s = Protokollierung via syslog
# v = Protokollierung von tcp window, ack, seq
# n = Namen statt IP &amp; port ausgeben</programlisting>

      <para>Die Vorteile des Protokollierens liegen auf der Hand:  Sie
        versetzen den Administrator in die Lage, nach einem Vorfall
        Informationen abzurufen, etwa welche Pakete aussortiert wurden,
       	welche Adressen diese Pakete gesendet haben oder wohin sie gesendet
       	werden sollten.  Alles in allem erhält er ein sehr gutes Werkzeug
       	zum Aufspüren von Angreifern.</para>

      <para>Jedoch, auch wenn die Protokollierung aktiviert ist, wird IPF
        keine einzige Regel zum Protokollieren von alleine entwerfen und
        umsetzen.  Der Administrator der Firewall entscheidet, welche Regeln
        in seinem Regelsatz mitgeschrieben werden sollen und er muss
        dementsprechend das Schlüsselword <literal>log</literal> in
        dieser Regel angeben.  Normalerweise werden nur Treffer auf abweisende
        Regeln protokolliert.</para>

      <para>Es ist üblich, als letzte Regel eine alles blockierende
        Regel mit dem Schlüsselwort <literal>log</literal> in den
        Regelsatz einzutragen. Dadurch erkennt man alle Pakete, die keiner
        Regel im Regelsatz entsprachen.</para>
    </sect2>

    <sect2>
      <title>IPMON Logging</title>

      <para><application>Syslogd</application> verwendet seine eigene Methode
        zum Sortieren der gesammtelten Protokolldaten - spezielle Gruppierungen
        namens <quote>facility</quote> und <quote>level</quote>.  IPMON
        verwendet im <literal>daemon</literal>-Modus als
        <quote>facility</quote> den Wert <literal>security</literal>.  Die
        folgenden <quote>level</quote> können für eine genauere
        Trennung der Protokolldaten verwendet werden:</para>

      <screen>LOG_INFO - Alle zu protokollierenden Pakete
LOG_NOTICE - Protokollierte Pakete, die passieren durften
LOG_WARNING - Protokollierte Pakete, die blockiert wurden
LOG_ERR - Protokollierte Pakete, deren Headerdaten nicht komplett vorlagen</screen>

      <para>Damit IPFILTER angewiesen werden kann, alle Protokolldaten in
        die Datei <filename>/var/log/ipfilter.log</filename> zu schreiben,
        muss diese erst erstellt werden.  Folgendes Kommando
        übernimmt diese Aufgabe:</para>

      <screen>&prompt.root; <userinput>touch /var/log/ipfilter.log</userinput></screen>

      <para>Die Funktionen von &man.syslogd.8; werden durch Definition in
        der Datei <filename>/etc/syslog.conf</filename> gesteuert.  In dieser
        Datei kann sehr weitläfig eingestellt werden, wie
        <application>syslog</application> mit den Systemnachrichten umgehen
        soll, die ihm von Anwendungen wie IPF übergeben werden.</para>

      <para>Fügen Sie folgende Definition in die Datei
        <filename>/etc/syslog.conf</filename> ein, um die Protokollierung
        für IPF via <filename>syslog</filename> zu aktivieren:</para>

      <programlisting>security.* /var/log/ipfilter.log</programlisting>

      <para><literal>security.*</literal> bedeutet, dass alle Nachrichten
        der Klasse <literal>security.*</literal> am angegebenen Ort (hier
        eine Datei) geschrieben werden sollen.</para>

      <para>Um Änderungen an der Datei
        <filename>/etc/syslog.conf</filename> zu aktivieren müssen Sie
        den Rechner neu starten, oder den Befehl</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/syslogd reload</userinput></screen>

      <para>ausführen.</para>

      <para>Vergessen Sie nicht, <filename>/etc/newsyslog.conf</filename>
        anzupassen, damit die neuen Protokolldateien, die eben konfiguriert
        wurden, auch in den Rotationsturnus eingefügt werden!</para>
    </sect2>

    <sect2>
      <title>Die Formatierung der Logdatei</title>

      <para>Nachrichten, die durch <command>ipmon</command> erzeugt werden,
        bestehen aus durch Leerstellen getrennten Datenfeldern.  Folgende
        Felder sind in allen Nachrichten enthalten:</para>

      <orderedlist>
		<listitem>
		  <para>Das Datum der Paketerstellung.</para>
		</listitem>

		<listitem>
		  <para>Die Uhrzeit der Paketerstellung in der Form
		    <literal>HH:MM:SS.F</literal>, mit Stunden, Minuten, Sekunden
		    und Sekundenbruchteilen, wobei letztere mehrere Stellen lang
		    sein können.</para>
		</listitem>

		<listitem>
		  <para>Der Name der Schnittstelle, die das Paket verarbeitet hat,
		    bspw. <filename>dc0</filename>.</para>
		</listitem>

		<listitem>
		  <para>Die Gruppe und die Nummer der angewandten Regel, bspw.
		    <literal>@0:17</literal>.</para>
		</listitem>

		<listitem>
		  <para>Die ausgeführte Aktion: p für
		    <literal>passed</literal> (zugelassen), b für blockiert,
		    S für <literal>short packet</literal> (unvollständiger
		    Header), n für <literal>no match</literal> (gar keine Regel
		    wurde berührt) und L für Log-Regel.  Die Reihe, in der
		    die Flags angezeigt werden ist:  S, p, b, n, L.  Ein groß
		    geschriebenes P oder B bedeutet, dass das Paket aufgrund einer
		    globalen Einstellung protokolliert wurde und nicht wegen einer
		    einzelnen Regel.</para>
		</listitem>

		<listitem>
		  <para>Die Adressen.  Diese bestehen aus drei Feldern:  Der
		    Quelladresse mit Port (getrennt durch ein Komma), dem Symbol
		    <quote>-&gt;</quote> und der Zieladresse. Also bspw.
		    <literal>209.53.15.22,80 -&gt; 198.64.221.18,1722</literal>.</para>
		</listitem>

		<listitem>
		  <para><literal>PR</literal> gefolgt vom Namen eines
		    Netzwerk-Protokolls oder dessen Nummer.  Bspw.
		    <literal>PR tcp</literal>.</para>
		</listitem>

		<listitem>
		  <para><literal>len</literal> gefolgt von der Länge des Headers
		    und der Gesamtlänge des Paketes, beispielsweise
		    <literal>len 20 40</literal>.</para>
		</listitem>
      </orderedlist>

      <para>Wenn es sich um ein <acronym>TCP</acronym>-Paket handelt, wird
        ein weiteres Feld, beginnend mit einem Querstrich und gefolgt von
        Buchstaben, die den gesetzten Flags entsprechen, angezeigt.  Lesen
        Sie bitte die Manpage &man.ipmon.8; für eine Liste der Buchstaben
        und deren Bedeutungen.</para>

      <para>Falls das Paket ein ICMP-Paket ist, werden zwei Felder am Ende
        hinzugefügt - das erstere ist immer <quote>ICMP</quote>, das
        zweite enthält die ICMP-Nachricht und den Nachrichtentyp,
        getrennt durch einen Schrägstrich.  <literal>ICMP 3/3</literal>
        steht beispielsweise für <quote>Port nicht
        erreichbar</quote>.</para>
    </sect2>

    <sect2 xml:id="firewalls-ipf-rules-script">
      <title>Die Erstellung eines Regelsatzes mit Variablen</title>

      <para>Erfahrenere IPF Anwender erstellen sich eine Datei, die die
        Regeln enthält und gestalten diese als ein Skript, in dem
        Variablen verwendet werden.  Der wichtigste Vorteil besteht darin,
        dass man lediglich den Wert der Variablen anpassen muss und diese,
        sobald das Skript gestartet wird, durch die entsprechenden Werte
        ersetzt	und die Regeln entsprechend formuliert werden.  In Skripten
        kann man so häufig verwendete Werte einfach als Variable in
        mehreren Regeln zuweisen.  Am folgenden Beispiel soll das
        verdeutlicht werden.</para>

      <para>Die Syntax dieses Skriptes ist kompatibel mit den Shells
        &man.sh.1;, &man.csh.1; und &man.tcsh.1;.</para>

      <para>Variablen beginnen mit einem Dollar-Zeichen:
        <literal>&dollar;Variablenname</literal>.  Im Beispiel unten steht
        <literal>&dollar;oif</literal> für die Variable, in der der Name
        der Schnittstelle abgelegt wird, über die der Verkehr nach
        außen erfolgt.</para>

      <para>In Variablenzuweisungen fehlt das beginnende &dollar;-Zeichen.
        Alleine der Name der Variable wird angegeben, gefolgt von einem
        Gleichheitszeichen, und dem Wert, der der Variablen zugewiesen werden
        soll.  Dieser muss in doppelten Anführungszeichen
        (<literal>""</literal>) stehen.  Also folgt eine Zuweisung dem Schema
        <literal>Variablenname = "Wert"</literal>.</para>

      <programlisting>############# Start of IPF rules script ########################

oif="dc0"            # Name der Internet-Schnittstelle
odns="192.0.2.11"    # IP des DNS-Servers unseres ISPs
myip="192.0.2.7"     # die statische IP, die uns der ISP zugeteilt hat
ks="keep state"
fks="flags S keep state"

# Sie haben die Wahl, aus diesem Skript eine eigene
# /etc/ipf.rules erstellen zu lassen oder es einfach
# direkt als Skript laufen zu lassen.
#
# Entfernen Sie dazu das eine Kommentarzeichen
# und kommentieren Sie die andere Zeile aus!
#
# 1) Diese Zeile verwenden Sie zur Erstellung von /etc/ipf.rules
#cat &gt; /etc/ipf.rules &lt;&lt; EOF
#
# 2) Diese Zeile, wenn Sie direkt mit dem Skript arbeiten wollen
/sbin/ipf -Fa -f - &lt;&lt; EOF

# Erlaubnis ausgehenden Verkehrs an den Nameserver des ISPs
pass out quick on &dollar;oif proto tcp from any to &dollar;odns port = 53 &dollar;fks
pass out quick on &dollar;oif proto udp from any to &dollar;odns port = 53 &dollar;ks

# Erlaubnis ausgehenden unsicheren www-Verkehrs
pass out quick on &dollar;oif proto tcp from &dollar;myip to any port = 80 &dollar;fks

# Erlaubnis ausgehenden sicheren www-Verkehrs https via TLS SSL
pass out quick on &dollar;oif proto tcp from &dollar;myip to any port = 443 &dollar;fks
EOF
################## End of IPF rules script ########################</programlisting>

      <para>Das ist schon alles.  Die Regeln selbst sind im Beispiel nicht
        so wichtig - achten Sie auf die Anwendung der Variablenzuweisung
        am Anfang und die Verwendung der Variablen im Skript.  Falls das
        obige Beispiel in einer Datei namens
        <filename>/etc/ipf.rules.script</filename> gespeichert wurde,
        können die	Regeln mit folgenden Kommando neu geladen
        werden:</para>

      <screen>&prompt.root; <userinput>sh /etc/ipf.rules.script</userinput></screen>

      <para>Es gibt ein Problem mit Regelsatz-Dateien, die Variablen
        verwenden: IPF kann mit Variablen nichts anfangen - und kann derartige
        Skripte	nicht direkt einlesen.</para>

      <para>Unser kleines Skript kann daher nur auf eine der beiden folgenden
        Weisen verwendet werden:</para>

      <itemizedlist>
		<listitem>
		  <para>Entfernen Sie das Kommentarzeichen der Zeile, die mit
		    <literal>cat</literal> beginnt.  Kommentieren Sie die Zeile aus,
		    die mit <literal>/sbin/ipf</literal> beginnt.  Schreiben Sie die
		    Zeile <literal>ipfilter_enable="YES"</literal> in die Datei
		    <filename>/etc/rc.conf</filename> und rufen Sie dann das Skript
		    auf, um <filename>/etc/ipf.rules</filename> zu erstellen oder
		    zu erneuern.</para>
		</listitem>

		<listitem>
		  <para>Deaktivieren Sie IPFILTER in den Systemstart-Skripten, indem
		    Sie die Zeile <literal>ipfilter_enable="NO"</literal> in die
		    Datei <filename>/etc/rc.conf</filename> eintragen (was auch der
		    Standard-Einstellung entspricht).</para>

		  <para>Fügen Sie ein Skript ähnlich dem folgenden in Ihr
		    Verzeichnis <filename>/usr/local/etc/rc.d/</filename>.  Es
		    sinnvoll, dem Skript einen offensichtlichen Namen zu geben, wie
		    etwa <filename>ipf.loadrules.sh</filename>.  Die Endung
		    <filename>.sh</filename> ist dabei verbindlich.</para>

	 	 <programlisting>#!/bin/sh
sh /etc/ipf.rules.script</programlisting>

		  <para>Die Zugriffsrechte für die Datei, die das Skript
		    enthält, müssen für den Eigentümer
		    <systemitem class="username">root</systemitem> auf Lesen, Schreiben und Ausführen
		    gesetzt werden.</para>

		  <screen>&prompt.root; <userinput>chmod 700 /usr/local/etc/rc.d/ipf.loadrules.sh</userinput></screen>
		</listitem>
      </itemizedlist>

      <para>Wenn nun Ihr System startet, werden Ihre IPF-Regeln geladen.</para>
    </sect2>

    <sect2>
      <title>IPF Regelsätze</title>

      <para> Ein Regelsatz ist eine Gruppe von IPF-Regeln, die anhand der
        Werte eines Netzwerkpaketes entscheiden, ob dieses Paket durchgelassen
        oder blockiert wird.  Der Austausch von Paketen erfolgt immer
        zweiseitig in Form einer sogenannten Session.  Der Regelsatz der
        Firewall verarbeitet sowohl die eingehenden Pakete aus dem
        öffentlichen Internet als auch die Pakete, die vom System als
        Antwort auf die Ersteren gesendet werden.  Jeder Dienst, der via
        <acronym>TCP/IP</acronym> arbeitet, zum Beispiel
        <literal>telnet</literal>, <literal>www</literal> oder
        <literal>mail</literal>, ist vordefiniert durch sein Protokoll und
        seinen privilegierten Port,	an dem er auf Anfragen wartet und
        reagieren kann.  Pakete, die gezielt einen Dienst ansprechen sollen,
        werden von einem unprivilegierten Port des Senders an einen konkreten
        privilegierten Port des Zielsystems	geschickt.  Alle genannten
        Parameter (Ports, Adressen usw.) können als Auswahlkriterien zum
        erstellen von Regeln eingesetzt werden, die	Dienste erlauben oder
        blockieren.</para>

      <indexterm>
		<primary>IPFILTER</primary>

		<secondary>rule processing order</secondary>
      </indexterm>

      <para>IPF wurde ursprünglich mit einer Regel-Prozess-Logik
        geschrieben, die ausschließlich statusfreie Regeln zuließ
        und nach dem Prinzip <quote>die letzte Regel, die passt,
        entscheidet</quote> arbeitete.  Mit der Zeit erhielt IPF eine
        <option>quick</option> Option sowie <option>keep-state</option> Option
        für die Anwendung von zustandsorientierten Regeln, was die
        Regel-Prozess-Logik signifikant modernisierte.</para>

      <para>Die Anweisungen in diesem Kapitel basieren auf der Verwendung
        von Regeln, die diese beiden neuen Optionen verarbeiten.  Dies ist
        das Framework zur Entwicklung eines Firewallregelsatzes.</para>

      <warning>
	<para>Wenn Sie mit einer Firewall arbeiten, seien Sie
	<emphasis>sehr vorsichtig</emphasis>.  Durch wenige Einstellungen
	können Sie sich aus Ihrem System
	<emphasis>aussperren</emphasis>.  Wenn Sie auf der sicheren Seite
	sein wollen, führen Sie die Firewall-Konfiguration direkt am
	entsprechenden Gerät aus und nicht über eine
	Netzwerkverbindung wie bspw. <application>ssh</application>.</para>
     </warning>
    </sect2>

    <sect2>
      <title>IPF Regel-Syntax</title>

      <indexterm>
	<primary>IPFILTER</primary>

	<secondary>rule syntax</secondary>
      </indexterm>

      <para>Die Syntax zur Erstellung der Regeln, die hier vorgestellt wird,
        ist dahingehend vereinfacht worden, dass sie ausschliesslich auf
        den modernen Regelkontext, mit statusbehafteten Regeln und einer
        <quote>die erste Regel, die passt, gewinnt</quote>-Logik,
        zurückgreift.  Um alles über die veraltete Syntax zu
        erfahren, lesen Sie bitte die Man-Page von &man.ipf.8;.</para>

      <para>Ein <literal>#</literal>-Zeichen markiert den Beginn eines
        Kommentars.  Es darf nach nach einer Regel stehen oder als erstes
        Zeichen einer Zeile.  Leere Zeilen werden von der
        Regel-Prozess-Logik ignoriert.</para>

      <para>Regeln enthalten Schlüsselwörter.  Diese
        Schlüsselwörter müssen in einer bestimmten Reihenfolge
        von links nach rechts in einer Zeile erscheinen.  Als solche
        identifizierte Schlüsselwörter werden fett wiedergegeben.
        Einige Schlüsselwörter haben Unteroptionen, die wiederum
        selbst Schlüsselwörter sein und ebenfalls weiter
        Unteroptionen einschließen können.</para>

      <!-- This section is probably wrong. See the OpenBSD flag -->
      <!-- What is the "OpenBSD flag"?  Reference please -->

      <para><replaceable>ACTION IN-OUT OPTIONS SELECTION STATEFUL PROTO
        SRC_ADDR,DST_ADDR OBJECT PORT_NUM TCP_FLAG
        STATEFUL</replaceable></para>

      <para><replaceable>ACTION</replaceable> = block | pass</para>

      <para><replaceable>IN-OUT</replaceable> = in | out</para>

      <para><replaceable>OPTIONS</replaceable> = log | quick | on
        interface-name</para>

      <para><replaceable>SELECTION</replaceable> = proto value |
        source/destination IP | port = number | flags flag-value</para>

      <para><replaceable>PROTO</replaceable> = tcp/udp | udp | tcp |
        icmp</para>

      <para><replaceable>SRC_ADD,DST_ADDR</replaceable> = all | from
        object to object</para>

      <para><replaceable>OBJECT</replaceable> = IP address | any</para>

      <para><replaceable>PORT_NUM</replaceable> = port number</para>

      <para><replaceable>TCP_FLAG</replaceable> = S</para>

      <para><replaceable>STATEFUL</replaceable> = keep state</para>

      <sect3>
		<title>ACTION</title>

		<para>Die <quote>ACTION</quote> bestimmt, was mit dem Paket passieren
		  soll, wenn der Rest der Regel zutrifft.  Dieser Teil muss
		  für jede Regel angegeben werden.</para>

		<para>Das Schlüsselwort <literal>block</literal> gibt an, dass
		  das Paket verfallen soll, wenn die Auswahlparameter zutreffen.</para>

		<para>Das Schlüsselwort <literal>pass</literal> gibt an, dass
		  das Paket durch die Firewall durchgelassen werden soll, wenn die
		  Auswahlparameter zutreffen.</para>
      </sect3>

      <sect3>
		<title>IN-OUT</title>

		<para>Ebenfalls verbindlich ist die Angabe, welchen Teil der
		  Verbindung, Ein- oder Ausgang, die Regel beeinflussen soll.  Das
		  nächste Schlüsselwort muss daher entweder
		  <literal>in</literal>, für eingehend, oder
		  <literal>out</literal>, für ausgehend, lauten - oder die Regel
		  wird aufgrund eines Syntaxfehlers nicht umgesetzt.</para>

		<para><literal>in</literal> bedeutet, dass diese Regel auf eingehende
		  Pakete angewendet wird, die gerade an der dem öffentlichen
		  Internet zugewandten Schnittstelle empfangen wurden.</para>

		<para><literal>out</literal> bedeutet, das diese Regel auf ausgehende
		  Pakete angewendet wird, also Pakete die gerade gesendet werden und
		  deren Zieladresse im öffentlichen Internet liegt.</para>
      </sect3>

      <sect3>
		<title>OPTIONS</title>

		<note>
		  <para>Die Optionen müssen in der hier aufgeführten
		    Reihenfolge verwendet werden.</para>
		</note>

        <para><literal>log</literal> bestimmt, dass die Kopfdaten des Paketes
          an die Systemschnittstelle &man.ipl.4; geschrieben werden sollen.
          Genaueres dazu weiter unten im Abschnitt LOGGING.</para>

		<para><literal>quick</literal> bestimmt, dass,
		  <emphasis>wenn</emphasis> die Auswahlkriterien der Regel auf das
		  Paket zutreffen, keine weiteren Regeln ausgewertet werden.  So
		  vermeidet man das Abarbeiten des gesamten Regelsatzes.  Diese Option
		  ist eine verbindliche Vorraussetzung der modernen
		  Regel-Prozess-Logik.</para>

		<para><literal>on</literal> bestimmt den Namen der Schnittstelle,
		  der als Auswahlkriterium hinzugefügt werden soll.  Die Namen
		  aller verfügbaren Schnittstellen werden durch den Befehl
		  &man.ifconfig.8; angezeigt.  wenn man diese Option verwendet,
		  passt die Regeln nur auf Pakete, die durch diese Schnittstelle
		  empfangen (<literal>in</literal>) oder gesendet
		  (<literal>out</literal>) wurden.  Für die modernisierte
		  Regel-Prozess-Logik ist die Verwendung dieser Option
		  verbindlich.</para>

		<para>Wenn ein Paket protokolliert wird, werden die Kopfdaten in
		  die Pseudo-Schnittstelle &man.ipl.4; geschrieben.  Folgende Parameter
		  können zusätzlich übergeben werden, müssen dazu
		  aber direkt nach dem Schlüsselwort <literal>log</literal> und in
		  gleicher Reihenfolge stehen:</para>

		<para><literal>body</literal> bestimmt, dass die ersten 128 Bytes des
		  Paketinhaltes zusätzlich zu den Kopfdaten protokolliert
		  werden.</para>

		<para><literal>first</literal> trifft nur zu, wenn das
		  Schlüsselwort <literal>log</literal> zusammen mit
		  <literal>keep-state</literal> verwendet wird.  Es bestimmt, dass nur
		  das auslösende Paket protokolliert wird und nicht jedes weitere
		   Paket, dass von der gespeicherten Status-Regel betroffen ist.</para>
      </sect3>

      <sect3>
		<title>SELECTION</title>

		<para>Die Schlüsselwörter, die in diesem Abschnitt
		  vorgestellt werden, dienen zur Beschreibung von Attributen, anhand
		  derer geprüft und entschieden wird, ob eine Regel zutrifft
		  oder nicht.  Es gibt ein Schlüsselwort, und das hat mehrere
		  Optionen, von denen eine ausgewählt werden muss.  Die
		  folgenden allgemeinen Attribute können beliebig zum Erstellen
		  einer Regel verwendet werden, allerdings nur in der vorgestellten
		  Reihenfolge:</para>
      </sect3>

      <sect3>
		<title>PROTO</title>

		<para><literal>proto</literal> ist das Schlüsselwort für
		  das im Paket angewendete Protokoll.  Als Option ein Protokoll aus
		  Auswahlkriterium übergeben.  Diese Option ist verbindlich, wenn
		  man die moderne Regel-Prozess-Logik verwendet.</para>

		<para><literal>tcp/udp | udp | tcp | icmp</literal> oder irgendein
		  Protokollname, der in der Datei <filename>/etc/protocols</filename>
		  zu finden ist, kann übergeben werden.  Außerdem kann das
		  Schlüsselwort <literal>tcp/udp</literal> verwendet werden, wenn
		  sowohl <acronym>TCP</acronym> als auch <acronym>UDP</acronym> von der
		  Regel betroffen sein sollen.  Dieses Schlüsselwort wurde
		  eingeführt, um Duplikate sonst identischer Regeln zu
		  vermeiden.</para>
      </sect3>

      <sect3>
		<title>SRC_ADDR/DST_ADDR</title>

		<para>Das Schlüsselwort <literal>all</literal> ist ein Synonym
		  für <quote>from any to any</quote> ohne weitere
		  Auswahlkriterien.</para>

		<para><literal>from src to dst</literal>: Die Schlüsselwörter
		  <literal>from</literal> und <literal>to</literal> dienen zur Angabe
		  von Quelle und Ziel in Form von IP-Adressen oder -Bereichen.
		  Innerhalb einer Regel muss immer beides angegeben werden.
		  Statt einer Adresse kann auch das Schlüsselwort
		  <literal>any</literal> übergeben werden, das für jede
		  beliebige IP-Adresse steht.  Zum Beispiel:
		  <literal>from any to any</literal> oder
		  <literal>from 0.0.0.0/0 to any</literal> oder
		  <literal>from any to 0.0.0.0/0</literal> oder
		  <literal>from 0.0.0.0 to any</literal> oder
		  <literal>from any to 0.0.0.0</literal> bedeuten alle das
		  Gleiche.</para>

		<para>IP-Bereiche können nur in der CIDR-Notation angegeben
		  werden.  Der Port <package>net-mgmt/ipcalc</package>
		  hilft Ihnen bei der Berechnung der richtigen Angaben.
		  Weiterführende Informationen zu CIDR finden Sie auf der Webseite
		  von <link xlink:href="http://www.rfc-editor.org/rfc/rfc1519.txt"><literal>ipcalc</literal></link>.</para>
      </sect3>

      <sect3>
		<title>PORT</title>

		<para>Wenn ein Port als Auswahlkriterium übergeben wurde, bei
		  Quelle und/oder Ziel, wird er nur bei <acronym>TCP</acronym> und
		  <acronym>UDP</acronym> Paketen verwendet.  Angegeben werden kann
		  entweder die Portnummer oder der Dienstname aus
		  <filename>/etc/services</filename>.  Die Verwendung der
		  Portoption mit dem <literal>to</literal>-Objekt ist verbindlich
		  für die Verwendung der modernisierten Regel-Prozess-Logik.
		  Ein Beispiel für die Filterung Paketen von allen Quell-IPs mit
		  beliebiger Portnummer auf beliebige Ziel-IPs mit der Portnummer 80
		  (dem <literal>www</literal>-Port):
		  <literal>from any to any port = 80</literal>.</para>

	<!-- XXX: Rewritten, but probably needs more changes -->

		<para>Einfache Portvergleiche können auf verschiedenen Wegen
		  erfolgen.  Mehrere Vergleichsoperatoren stehen dafür zur
		  Verfügung.  Genauso können Bereiche angegeben
		  werden.</para>

		<para>port "=" | "!=" | "&lt;" | "&gt;" | "&lt;=" | "&gt;=" | "eq"
		  | "ne" | "lt" | "gt" | "le" | "ge".</para>

		<para>Um einen Bereich anzugeben: port "&lt;&gt;" | "&gt;&lt;"</para>

		<warning>
          <para>Genau wie die Trefferspezifikation für Quelle und Ziel
            sind auch die beiden folgenden Parameter obligatorisch bei der
            Verwendung der modernen Regel-Prozess-Logik.</para>
		</warning>
      </sect3>

      <sect3>
		<title><acronym>TCP</acronym>_FLAG</title>

		<para>Flags spielen nur beim Filtern von <acronym>TCP</acronym> eine
		  Rolle.  Die Buchstaben entsprechen jeweils einem möglichen
		  Flag, dass in den Kopfdaten der <acronym>TCP</acronym>-Pakete
		  geprueft werden soll.</para>

		<para>Die moderne Regel-Prozess-Logik verwendet den Parameter
		  <literal>flags S</literal> um eine Anfrage zum Start einer
		  <acronym>TCP</acronym>-Session zu identifizieren.</para>
      </sect3>

      <sect3>
		<title>STATEFUL</title>

		<para><literal>keep state</literal> zeigt bei einer Passage-Regel an,
		  dass für alle Pakete, die die Selektion erfolgreich durchlaufen,
		  <literal>Stateful Filtering</literal> eingerichtet werden
		  soll.</para>

		<note>
		  <para>Diese Option ist obligatorisch für die Verwendung der
		    modernen Prozess-Regel-Logik.</para>
		</note>
      </sect3>
    </sect2>
<!-- xxxxxxxxxxx Benjamin bis hier xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  //-->
    <sect2>
      <title>Stateful Filtering</title>

      <indexterm>
	<primary>IPFILTER</primary>

	<secondary>stateful filtering</secondary>
      </indexterm>

      <!-- XXX: duplicated -->

      <para>Stateful filtering treats traffic as a bi-directional
	exchange of packets comprising a session conversation.  When
	activated, keep-state dynamically generates internal rules for
	each anticipated packet being exchanged during the
	bi-directional session conversation.  It has sufficient matching
	capabilities to determine if the session conversation between the
	originating sender and the destination are following the valid
	procedure of bi-directional packet exchange.  Any packets that
	do not properly fit the session conversation template are
	automatically rejected as impostors.</para>

      <para>Keep state will also allow <acronym>ICMP</acronym> packets related to a
	<acronym>TCP</acronym> or <acronym>UDP</acronym> session through.  So if you get
	<acronym>ICMP</acronym> type 3 code 4 in response to some web surfing allowed out
	by a keep state rule, they will be automatically allowed in.
	Any packet that IPF can be certain is part of an active
	session, even if it is a different protocol, will be let
	in.</para>

      <para>What happens is:</para>

      <para>Packets destined to go out through the interface connected to the
	public Internet are first checked against the dynamic state
	table.  If the packet matches the next expected packet
	comprising an active session conversation, then it exits the
	firewall and the state of the session conversation flow is
	updated in the dynamic state table.  Packets that do not belong to
	an already active session, are simply checked against the outbound
	ruleset.</para>

      <para>Packets coming in from the interface connected to the public
	Internet are first checked against the dynamic state table.  If
	the packet matches the next expected packet comprising an
	active session conversation, then it exits the firewall and
	the state of the session conversation flow is updated in the
	dynamic state table.  Packets that do not belong to an already active
	session, are simply checked against the inbound ruleset.</para>

      <para>When the conversation completes it is removed from the
	dynamic state table.</para>

      <para>Stateful filtering allows you to focus on blocking/passing
	new sessions.  If the new session is passed, all its subsequent
	packets will be allowed through automatically and any impostors
	automatically rejected.  If a new session is blocked, none of
	its subsequent packets will be allowed through.  Stateful
	filtering has technically advanced matching abilities
	capable of defending against the flood of different attack
	methods currently employed by attackers.</para>
    </sect2>

    <sect2>
      <!-- XXX: This section needs a rewrite -->

      <title>Inclusive Ruleset Example</title>

      <para>The following ruleset is an example of how to code a very
	secure inclusive type of firewall.  An inclusive firewall only
	allows services matching <literal>pass</literal> rules through, and blocks all
	others by default.  Firewalls intended to protect other machines,
	also called <quote>network firewalls</quote>, should have at least
	two interfaces, which are generally configured to trust one side
	(the <acronym>LAN</acronym>) and not the other (the public Internet).  Alternatively,
	a firewall might be configured to protect only the system it is
	running on&mdash;this is called a
	<quote>host based firewall</quote>, and is particularly appropriate
	for servers on an untrusted network.</para>

      <para>All &unix; flavored systems including &os; are designed to
	use interface <filename>lo0</filename> and IP address
	<systemitem class="ipaddress">127.0.0.1</systemitem> for internal
	communication within the operating system.  The firewall rules
	must contain rules to allow free unmolested movement of these
	special internally used packets.</para>

      <para>The interface which faces the public Internet is the one
	to place the rules that authorize and control access of the outbound
	and inbound connections.  This can be your user PPP
	<filename>tun0</filename> interface or your NIC that is
	connected to your DSL or cable modem.</para>

      <para>In cases where one or more NICs are cabled to private network
	segments, those interfaces may require rules to allow packets
	originating from those LAN interfaces transit to each other and/or
	to the outside (Internet).</para>

      <para>The rules should be organized into three major
	sections: first trusted interfaces, then the public
	interface outbound, and last the public untrusted interface inbound.</para>

      <para>The rules in each of the public interface sections should
	have the most frequently matched rules placed before less
	commonly matched rules, with the last rule in the section
	blocking and logging all packets on that interface and
	direction.</para>

      <para>The Outbound section in the following ruleset only
	contains <literal>pass</literal> rules which contain selection values that
	uniquely identify the service that is authorized for public
	Internet access.  All the rules have the <literal>quick</literal>, <literal>on</literal>,
	<literal>proto</literal>, <literal>port</literal>, and <literal>keep state</literal> options set.  The <literal>proto
	tcp</literal> rules have the <literal>flag</literal> option included to identify the
	session start request as the triggering packet to activate the
	stateful facility.</para>

      <para>The Inbound section has all the blocking of undesirable
	packets first, for two different reasons.  The first is that
	malicious packets may be partial matches for legitimate traffic.
	These packets have to be discarded rather than allowed in, based on
	their partial matches against <literal>allow</literal> rules.
	The second reason is that known and uninteresting rejects may be
	blocked silently, rather than being caught and logged by the last
	rules in the section.  The final rule in each section, blocks and
	logs all packets and can be used to create the legal evidence needed
	to prosecute the people who are attacking your system.</para>

      <para>Another thing that should be taken care of, is to ensure there is no
	response returned for any of the undesirable traffic.  Invalid
	packets should just get dropped and vanish.  This way the attacker
	has no knowledge if his packets have reached your system.  The
	less the attackers can learn about your system, the more
	time they must invest before actually doing something bad.
	Rules that include a <literal>log first</literal> option, will only
	log the event the first time they are triggered.  This option is
	included in the sample <literal>nmap OS fingerprint</literal> rule.
	The <package>security/nmap</package> utility is
	commonly used by attackers who attempt to identify the operating
	system of your server.</para>

      <para>Any time there are logged messages on a rule with
	the <literal>log first</literal> option, an <command>ipfstat -hio</command>
	command should be executed to evaluate how many times the rule has
	actually matched.  Large number of matches usually indicate that the
	system is being flooded (i.e.: under attack).</para>

      <para>The <filename>/etc/services</filename> file may be used to
	lookup unknown port numbers.  Alternatively,
	visit <uri xlink:href="http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers">http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers</uri>
	and do a port number lookup to find the purpose of a particular
	port number.</para>

      <para>Check out this link for port numbers used by Trojans <uri xlink:href="http://www.sans.org/security-resources/idfaq/oddports.php">http://www.sans.org/security-resources/idfaq/oddports.php</uri>.</para>

      <para>The following ruleset creates a complete and very secure
	<literal>inclusive</literal> type of firewall ruleset that has been
	tested on production systems.  It can be easily modified for your
	own system.  Just comment out any <literal>pass</literal> rules for
	services that should not be authorized.</para>

      <para>To avoid logging unwanted messages,
	just add a <literal>block</literal> rule in the inbound section.</para>

      <para>The <filename>dc0</filename> interface name has to be changed
	in every rule to the real interface name of the NIC
	card that connects your system to the public Internet.  For
	user PPP it would be <filename>tun0</filename>.</para>

      <para>Add the following statements to
	<filename>/etc/ipf.rules</filename>:</para>

      <programlisting>#################################################################
# No restrictions on Inside LAN Interface for private network
# Not needed unless you have LAN
#################################################################

#pass out quick on xl0 all
#pass in quick on xl0 all

#################################################################
# No restrictions on Loopback Interface
#################################################################
pass in quick on lo0 all
pass out quick on lo0 all

#################################################################
# Interface facing Public Internet (Outbound Section)
# Match session start requests originating from behind the
# firewall on the private network
# or from this gateway server destined for the public Internet.
#################################################################

# Allow out access to my ISP's Domain name server.
# xxx must be the IP address of your ISP's DNS.
# Dup these lines if your ISP has more than one DNS server
# Get the IP addresses from /etc/resolv.conf file
pass out quick on dc0 proto tcp from any to xxx port = 53 flags S keep state
pass out quick on dc0 proto udp from any to xxx port = 53 keep state

# Allow out access to my ISP's DHCP server for cable or DSL networks.
# This rule is not needed for 'user ppp' type connection to the
# public Internet, so you can delete this whole group.
# Use the following rule and check log for IP address.
# Then put IP address in commented out rule &amp; delete first rule
pass out log quick on dc0 proto udp from any to any port = 67 keep state
#pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state


# Allow out non-secure standard www function
pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state

# Allow out secure www function https over TLS SSL
pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state

# Allow out send &amp; get email function
pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state

# Allow out Time
pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state

# Allow out nntp news
pass out quick on dc0 proto tcp from any to any port = 119 flags S keep state

# Allow out gateway &amp; LAN users' non-secure FTP ( both passive &amp; active modes)
# This function uses the IP<acronym>NAT</acronym> built in FTP proxy function coded in
# the nat rules file to make this single rule function correctly.
# If you want to use the pkg_add command to install application packages
# on your gateway system you need this rule.
pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state

# Allow out ssh/sftp/scp (telnet/rlogin/FTP replacements)
# This function is using SSH (secure shell)
pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Allow out insecure Telnet
pass out quick on dc0 proto tcp from any to any port = 23 flags S keep state

# Allow out FreeBSD CVSup
pass out quick on dc0 proto tcp from any to any port = 5999 flags S keep state

# Allow out ping to public Internet
pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state

# Allow out whois from LAN to public Internet
pass out quick on dc0 proto tcp from any to any port = 43 flags S keep state

# Block and log only the first occurrence of everything
# else that's trying to get out.
# This rule implements the default block
block out log first quick on dc0 all

#################################################################
# Interface facing Public Internet (Inbound Section)
# Match packets originating from the public Internet
# destined for this gateway server or the private network.
#################################################################

# Block all inbound traffic from non-routable or reserved address spaces
block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918 private IP
block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918 private IP
block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918 private IP
block in quick on dc0 from 127.0.0.0/8 to any       #loopback
block in quick on dc0 from 0.0.0.0/8 to any         #loopback
block in quick on dc0 from 169.254.0.0/16 to any    #DHCP auto-config
block in quick on dc0 from 192.0.2.0/24 to any      #reserved for docs
block in quick on dc0 from 204.152.64.0/23 to any   #Sun cluster interconnect
block in quick on dc0 from 224.0.0.0/3 to any       #Class D &amp; E multicast

##### Block a bunch of different nasty things. ############
# That I do not want to see in the log

# Block frags
block in quick on dc0 all with frags

# Block short tcp packets
block in quick on dc0 proto tcp all with short

# block source routed packets
block in quick on dc0 all with opt lsrr
block in quick on dc0 all with opt ssrr

# Block nmap OS fingerprint attempts
# Log first occurrence of these so I can get their IP address
block in log first quick on dc0 proto tcp from any to any flags FUP

# Block anything with special options
block in quick on dc0 all with ipopts

# Block public pings
block in quick on dc0 proto icmp all icmp-type 8

# Block ident
block in quick on dc0 proto tcp from any to any port = 113

# Block all Netbios service. 137=name, 138=datagram, 139=session
# Netbios is MS/Windows sharing services.
# Block MS/Windows hosts2 name server requests 81
block in log first quick on dc0 proto tcp/udp from any to any port = 137
block in log first quick on dc0 proto tcp/udp from any to any port = 138
block in log first quick on dc0 proto tcp/udp from any to any port = 139
block in log first quick on dc0 proto tcp/udp from any to any port = 81

# Allow traffic in from ISP's DHCP server. This rule must contain
# the IP address of your ISP's DHCP server as it's the only
# authorized source to send this packet type. Only necessary for
# cable or DSL configurations. This rule is not needed for
# 'user ppp' type connection to the public Internet.
# This is the same IP address you captured and
# used in the outbound section.
pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state

# Allow in standard www function because I have apache server
pass in quick on dc0 proto tcp from any to any port = 80 flags S keep state

# Allow in non-secure Telnet session from public Internet
# labeled non-secure because ID/PW passed over public Internet as clear text.
# Delete this sample group if you do not have telnet server enabled.
#pass in quick on dc0 proto tcp from any to any port = 23 flags S keep state

# Allow in secure FTP, Telnet, and SCP from public Internet
# This function is using SSH (secure shell)
pass in quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Block and log only first occurrence of all remaining traffic
# coming into the firewall. The logging of only the first
# occurrence avoids filling up disk with Denial of Service logs.
# This rule implements the default block.
block in log first quick on dc0 all
################### End of rules file #####################################</programlisting>
    </sect2>

    <sect2>
      <title><acronym>NAT</acronym></title>

      <indexterm><primary>NAT</primary></indexterm>

      <indexterm>
	<primary>IP masquerading</primary>

	<see>NAT</see>
      </indexterm>

      <indexterm>
	<primary>network address translation</primary>

	<see>NAT</see>
      </indexterm>

      <para><acronym>NAT</acronym> stands for <emphasis>Network Address
	  Translation</emphasis>.  To those familiar with &linux;, this concept is
	called IP Masquerading; <acronym>NAT</acronym> and IP
	Masquerading are the same thing.  One of the many things the
	IPF <acronym>NAT</acronym> function enables is the ability to
	have a private Local Area Network (LAN) behind the firewall
	sharing a single ISP assigned IP address on the public
	Internet.</para>

      <para>You may ask why would someone want to do this.  ISPs
	normally assign a dynamic IP address to their non-commercial
	users.  Dynamic means that the IP address can be different each
	time you dial in and log on to your ISP, or for cable and DSL
	modem users, when the modem is power cycled.  This dynamic IP
	address is used to identify your system to the public Internet.</para>

      <para>Now lets say you have five PCs at home and each one needs
	Internet access.  You would have to pay your ISP for an
	individual Internet account for each PC and have five phone
	lines.</para>

      <para>With <acronym>NAT</acronym> only a single account is needed
	with your ISP.  The other four PCs may then be cabled to a switch and
	the switch to the NIC in your &os; system which is going to
	service your LAN as a gateway. <acronym>NAT</acronym> will
	automatically translate the private LAN IP address for each
	separate PC on the LAN to the single public IP address as it
	exits the firewall bound for the public Internet.  It also does
	the reverse translation for returning packets.</para>

      <para>There is a special range of IP addresses reserved for
	<acronym>NAT</acronym>ed private LANs.  According to
	RFC 1918, the following IP ranges may be used for private nets
	which will never be routed directly to the public
	Internet:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <colspec colwidth="1*"/>

	  <colspec colwidth="1*"/>

	  <colspec colwidth="1*"/>

	  <tbody>
	    <row>
	      <entry>Start IP <systemitem class="ipaddress">10.0.0.0</systemitem></entry>

	      <entry>-</entry>

	      <entry>Ending IP <systemitem class="ipaddress">10.255.255.255</systemitem></entry>
	    </row>

	    <row>
	      <entry>Start IP <systemitem class="ipaddress">172.16.0.0</systemitem></entry>

	      <entry>-</entry>

	      <entry>Ending IP <systemitem class="ipaddress">172.31.255.255</systemitem></entry>
	    </row>

	    <row>
	      <entry>Start IP <systemitem class="ipaddress">192.168.0.0</systemitem></entry>

	      <entry>-</entry>

	      <entry>Ending IP <systemitem class="ipaddress">192.168.255.255</systemitem></entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>IP<acronym>NAT</acronym></title>

      <indexterm>
	<primary>NAT</primary>

	<secondary>and IPFILTER</secondary>
      </indexterm>

      <indexterm><primary><command>ipnat</command></primary></indexterm>

      <para><acronym>NAT</acronym> rules are loaded by using the
	<command>ipnat</command> command.  Typically the
	<acronym>NAT</acronym> rules are stored in
	<filename>/etc/ipnat.rules</filename>.  See &man.ipnat.1; for
	details.</para>

      <para>When changing the <acronym>NAT</acronym> rules after
	<acronym>NAT</acronym> has been started, make your changes to
	the file containing the NAT rules, then run the <command>ipnat</command> command with
	the <option>-CF</option> flags to delete the internal in use
	<acronym>NAT</acronym> rules and flush the contents of the
	translation table of all active entries.</para>

      <para>To reload the <acronym>NAT</acronym> rules issue a command
	like this:</para>

      <screen>&prompt.root; <userinput>ipnat -CF -f /etc/ipnat.rules</userinput></screen>

      <para>To display some statistics about your
	<acronym>NAT</acronym>, use this command:</para>

      <screen>&prompt.root; <userinput>ipnat -s</userinput></screen>

      <para>To list the <acronym>NAT</acronym> table's current
	mappings, use this command:</para>

      <screen>&prompt.root; <userinput>ipnat -l</userinput></screen>

      <para>To turn verbose mode on, and display information relating
	to rule processing and active rules/table entries:</para>

      <screen>&prompt.root; <userinput>ipnat -v</userinput></screen>
    </sect2>

    <sect2>
      <title>IP<acronym>NAT</acronym> Rules</title>

      <para><acronym>NAT</acronym> rules are very flexible and can
	accomplish many different things to fit the needs of commercial
	and home users.</para>

      <para>The rule syntax presented here has been simplified to what
	is most commonly used in a non-commercial environment.  For a
	complete rule syntax description see the &man.ipnat.5; manual
	page.</para>

      <para>The syntax for a <acronym>NAT</acronym> rule looks
	something like this:</para>

      <programlisting>map <replaceable>IF</replaceable> <replaceable>LAN_IP_RANGE</replaceable> -&gt; <replaceable>PUBLIC_ADDRESS</replaceable></programlisting>

      <para>The keyword <literal>map</literal> starts the rule.</para>

      <para>Replace <replaceable>IF</replaceable> with the external
	interface.</para>

      <para>The <replaceable>LAN_IP_RANGE</replaceable> is what your
	internal clients use for IP Addressing, usually this is
	something like <systemitem class="ipaddress">192.168.1.0/24</systemitem>.</para>

      <para>The <replaceable>PUBLIC_ADDRESS</replaceable> can either
	be the external IP address or the special keyword
	<literal>0/32</literal>, which means to use the IP address
	assigned to <replaceable>IF</replaceable>.</para>
    </sect2>

    <sect2>
      <title>How <acronym>NAT</acronym> works</title>

      <para>A packet arrives at the firewall from the LAN with a public
	destination.  It passes through the outbound filter rules,
	<acronym>NAT</acronym> gets its turn at the packet and applies
	its rules top down, first matching rule wins.
	<acronym>NAT</acronym> tests each of its rules against the
	packet's interface name and source IP address.  When a packet's
	interface name matches a <acronym>NAT</acronym> rule then the
	source IP address (i.e.: private LAN IP address) of the packet
	is checked to see if it falls within the IP address range
	specified to the left of the arrow symbol on the
	<acronym>NAT</acronym> rule.  On a match the packet has its
	source IP address rewritten with the public IP address
	obtained by the <literal>0/32</literal> keyword.
	<acronym>NAT</acronym> posts an entry in its internal
	<acronym>NAT</acronym> table so when the packet returns from
	the public Internet it can be mapped back to its original
	private IP address and then passed to the filter rules for
	processing.</para>
    </sect2>

    <sect2>
      <title>Enabling IP<acronym>NAT</acronym></title>

      <para>To enable IP<acronym>NAT</acronym> add these statements to
	<filename>/etc/rc.conf</filename>.</para>

      <para>To enable your machine to route traffic between
	interfaces:</para>

      <programlisting>gateway_enable="YES"</programlisting>

      <para>To start IP<acronym>NAT</acronym> automatically each
	time:</para>

      <programlisting>ipnat_enable="YES"</programlisting>

      <para>To specify where to load the IP<acronym>NAT</acronym> rules
	from:</para>

      <programlisting>ipnat_rules="/etc/ipnat.rules"</programlisting>
    </sect2>

    <sect2>
      <title><acronym>NAT</acronym> for a very large LAN</title>

      <para>For networks that have large numbers of PC's on the LAN or
	networks with more than a single LAN, the process of funneling
	all those private IP addresses into a single public IP address
	becomes a resource problem that may cause problems with the
	same port numbers being used many times across many
	<acronym>NAT</acronym>ed LAN PC's, causing collisions.  There
	are two ways to relieve this resource problem.</para>

      <sect3>
	<title>Assigning Ports to Use</title>

	<!-- What does it mean ? Is there something missing ?-->
	<!-- XXXBLAH <- Apparently you can't start a sect
	     with a <programlisting> tag ?-->

	<para>A normal NAT rule would look like:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 0/32</programlisting>

	<para>In the above rule the packet's source port is unchanged
	  as the packet passes through IP<acronym>NAT</acronym>.  By
	  adding the <literal>portmap</literal> keyword,
	  IP<acronym>NAT</acronym> can be directed to only use source ports in the specified range.
	  For example the following rule will tell
	  IP<acronym>NAT</acronym> to modify the source port to be
	  within the range shown:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp 20000:60000</programlisting>

	<para>Additionally we can make things even easier by using the
	  <literal>auto</literal> keyword to tell
	  IP<acronym>NAT</acronym> to determine by itself which ports
	  are available to use:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp auto</programlisting>
      </sect3>

      <sect3>
	<title>Using a Pool of Public Addresses</title>

	<para>In very large LANs there comes a point where there are just too
	  many LAN addresses to fit into a single public address.  If a block
	  of public IP addresses is available, these addresses can be used as
	  a <quote>pool</quote>, and IP<acronym>NAT</acronym> may pick one of
	  the public IP addresses as packet-addresses are mapped on their way
	  out.</para>

	<para>For example, instead of mapping all packets through a single
	  public IP address, as in:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 204.134.75.1</programlisting>

	<para>A range of public IP addresses can be specified either with a
	  netmask:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/255.255.255.0</programlisting>

	<para>or using CIDR notation:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/24</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Port Redirection</title>

      <para>A very common practice is to have a web server, email
	server, database server and DNS server each segregated to a
	different PC on the LAN.  In this case the traffic from these
	servers still have to be <acronym>NAT</acronym>ed, but there
	has to be some way to direct the inbound traffic to the
	correct LAN PCs.  IP<acronym>NAT</acronym> has the redirection
	facilities of <acronym>NAT</acronym> to solve this problem.
	For example, assuming a web server operating on LAN address <systemitem class="ipaddress">10.0.10.25</systemitem> and using a single public IP
	address of <systemitem class="ipaddress">20.20.20.5</systemitem> the rule would
	be coded as follows:</para>

	<programlisting>rdr dc0 20.20.20.5/32 port 80 -&gt; 10.0.10.25 port 80</programlisting>

	<para>or:</para>

	<programlisting>rdr dc0 0.0.0.0/0 port 80 -&gt; 10.0.10.25 port 80</programlisting>

	<para>or for a LAN DNS Server on LAN address of <systemitem class="ipaddress">10.0.10.33</systemitem> that needs to receive
	  public DNS requests:</para>

	<programlisting>rdr dc0 20.20.20.5/32 port 53 -&gt; 10.0.10.33 port 53 udp</programlisting>
    </sect2>

    <sect2>
      <title>FTP and <acronym>NAT</acronym></title>

      <para>FTP is a dinosaur left over from the time before the
	Internet as it is known today, when research universities were
	leased lined together and FTP was used to share files among
	research Scientists.  This was a time when data security was
	not a consideration.  Over the years the FTP protocol became
	buried into the backbone of the emerging Internet and its
	username and password being sent in clear text was never
	changed to address new security concerns.  FTP has two flavors,
	it can run in active mode or passive mode.  The difference is
	in how the data channel is acquired.  Passive mode is more
	secure as the data channel is acquired by the ordinal ftp
	session requester.  For a real good explanation of FTP and the
	different modes see <uri xlink:href="http://www.slacksite.com/other/ftp.html">http://www.slacksite.com/other/ftp.html</uri>.</para>

      <sect3>
	<title>IP<acronym>NAT</acronym> Rules</title>

	<para>IP<acronym>NAT</acronym> has a special built in FTP proxy
	  option which can be specified on the <acronym>NAT</acronym>
	  map rule.  It can monitor all outbound packet traffic for FTP
	  active or passive start session requests and dynamically
	  create temporary filter rules containing only the port number
	  really in use for the data channel.  This eliminates the
	  security risk FTP normally exposes the firewall to from
	  having large ranges of high order port numbers open.</para>

	<para>This rule will handle all the traffic for the internal
	  LAN:</para>

	<programlisting>map dc0 10.0.10.0/29 -&gt; 0/32 proxy port 21 ftp/tcp</programlisting>

	<para>This rule handles the FTP traffic from the
	  gateway:</para>

	<programlisting>map dc0 0.0.0.0/0 -&gt; 0/32 proxy port 21 ftp/tcp</programlisting>

	<para>This rule handles all non-FTP traffic from the internal
	  LAN:</para>

	<programlisting>map dc0 10.0.10.0/29 -&gt; 0/32</programlisting>

	<para>The FTP map rule goes before our regular map rule.  All
	  packets are tested against the first rule from the top.
	  Matches on interface name, then private LAN source IP
	  address, and then is it a FTP packet.  If all that matches
	  then the special FTP proxy creates temp filter rules to let
	  the FTP session packets pass in and out, in addition to also
	  <acronym>NAT</acronym>ing the FTP packets.  All LAN packets
	  that are not FTP do not match the first rule and fall
	  through to the third rule and are tested, matching on
	  interface and source IP, then are
	  <acronym>NAT</acronym>ed.</para>
      </sect3>

      <sect3>
	<title>IP<acronym>NAT</acronym> FTP Filter Rules</title>

	<para>Only one filter rule is needed for FTP if the
	  <acronym>NAT</acronym> FTP proxy is used.</para>

	<para>Without the FTP Proxy, the following three rules will be
	  needed:</para>

	<programlisting># Allow out LAN PC client FTP to public Internet
# Active and passive modes
pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state

# Allow out passive mode data channel high order port numbers
pass out quick on rl0 proto tcp from any to any port &gt; 1024 flags S keep state

# Active mode let data channel in from FTP server
pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state</programlisting>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="firewalls-ipfw">
    <title>IPFW</title>

    <indexterm>
      <primary>firewall</primary>

      <secondary>IPFW</secondary>
    </indexterm>

    <para>Die <emphasis>IPFIREWALL</emphasis>
      (<acronym>IPFW</acronym>) ist eine vom &os; Project
      gesponserte Software-Firewall.  Sie wurde und wird
      freiwillig von Mitgliedern des &os; Projects geschrieben und
      gewartet.  Mit zustandslosen Regeln und einer Grammatik für
      Regeln implementiert sie eine sogenannte <quote>Einfache
      Zustandsgesteuerte Logik</quote>.</para>

    <para>Die Standardinstallation von IPFW  enthält
      einen beispielhaften Regelsatz
      (<filename>/etc/rc.firewall</filename> und
      <filename>/etc/rc.firewall6</filename>).  Dieser ist eher
      einfach gehalten; es ist nicht zu erwarten, dass dieser
      ohne Modifikationen angewandt werden kann.  Dieses Beispiel
      nutzt keine zustandsorientierte Filterung, von der allerdings
      die meisten Installationen profitieren sollten.  Deshalb wird sich
      dieser Abschnitt auch nicht auf diese Beispiele stützen.</para>

    <para>Die zustandslose IPFW Regel-Syntax ist durch ihre technisch
      ausgefeilten Selektions-Fähigkeiten, die über das
      Niveau der gebrächlichen Firewall-Installationsprogramme
      weit hinausgehen, sehr mächtig.  IPFW richtet sich an
      professionelle oder technisch versierte Nutzer mit
      weitergehenden Anforderungen an die Paket-Auswahl.  Um die
      Ausdrucksstärke der IPFW zu nutzen, ist sehr detailliertes
      Wissen über die Art und Weise, wie verschiedene Protokolle ihre
      jeweilige Paket-Header-Information erzeugen und nutzen,
      erforderlich.  Im Rahmen dieses Abschnitts ist es nicht möglich,
      auf alle diese Punkte detailliert einzugehen.</para>

    <para>IPFW besteht aus sieben Komponenten:  Hauptbestandteil ist der
      Kernel Firewall Filter, ein Regel-Prozessor mit integrierter
      Paket-Buchführung.  Außerdem enthalten
      ist eine Komponente zur Protokollierung der Aktivitäten der
      Firewall (also ein Logfunktion).  Weiters besteht die IPFW aus einer
      Regel zum Umleiten des Datenverkehrs (<literal>divert</literal>), die
      auch Network Address Translation (<acronym>NAT</acronym>)
      unterstützt.  Die restlichen Bestandteile dienen verschiedenen
      fortgeschrittenen Zwecken.  Der
      <foreignphrase>Traffic Shaper</foreignphrase> &man.dummynet.4;
      gestattet es beispielsweise,  den Datenverkehr zu lenken, während
      die <literal>fwd</literal>-Regel zum Weiterleiten von Datenpaketen
      dient.  Komplettiert wird IPFW durch Funktionen zum
      Überbrücken von Netzwerkgrenzen
      (<foreignphrase>Bridge</foreignphrase>-Funktion) sowie
      <foreignphrase>ipstealth</foreignphrase>, das es gestattet,
      bridging-Funktionen durchzuführen, ohne dabei das TTL-Feld im
      IP-Paket zu erhöhen.  IPFW unterstützt IPv4 und IPv6.</para>

    <sect2 xml:id="firewalls-ipfw-enable">
      <title>IPFW aktivieren</title>

      <indexterm>
	<primary>IPFW</primary>

	<secondary>aktivieren</secondary>
      </indexterm>

      <para>IPFW ist in der &os;-Installation standardmäßig
	als ein zur Laufzeit ladbares Kernelmodul enthalten, das
	vom System automatisch geladen wird, wenn in der Datei
	<filename>rc.conf</filename> die Option
	<varname>firewall_enable="YES"</varname> gesetzt wird.  Es ist
	daher in der Regel nicht notwendig, IPFW statisch in den Kernel zu
	kompilieren.  Es sei denn, man benötigt die
	NAT-Funktionalität.</para>

      <para>Während des Systemstart wird bei gesetzter Option
	<varname>firewall_enable="YES"</varname> (in der Datei
	<filename>rc.conf</filename>) folgende Nachricht ausgegeben:</para>

      <screen>ipfw2 initialized, divert disabled, rule-based forwarding disabled, default to deny, logging disabled</screen>

      <para>Das Kernelmodul hat eine Protokollierungsfunktion.  Um
	diese zu aktivieren und einen Schwellwert für die
	Protokollierung zu definieren, ist es erforderlich, folgende
	Ausdrücke der <filename>/etc/sysctl.conf</filename>
	hinzuzufügen:</para>

      <programlisting>net.inet.ip.fw.verbose=1
net.inet.ip.fw.verbose_limit=5</programlisting>
    </sect2>

    <sect2 xml:id="firewalls-ipfw-kernel">
      <title>Kerneloptionen</title>

      <indexterm>
	<primary>Kerneloptionen</primary>

	<secondary>IPFIREWALL</secondary>
      </indexterm>

      <indexterm>
	<primary>Kerneloptionen</primary>

	<secondary>IPFIREWALL_VERBOSE</secondary>
      </indexterm>

      <indexterm>
	<primary>Kerneloptionen</primary>

	<secondary>IPFIREWALL_VERBOSE_LIMIT</secondary>
      </indexterm>

      <indexterm>
	<primary>IPFW</primary>

	<secondary>Kerneloptionen</secondary>
      </indexterm>

      <para>IPFW muss nicht durch einkompilieren bestimmter, im
	folgenden konkretisierter Optionen in den Kernel aktiviert
	werden, es sei denn, man benötigt
	<acronym>NAT</acronym>-Funktionalität.  Die
	erforderlichen Optionen werden deshalb hier lediglich als
	Hintergrundinformation aufgeführt.</para>

      <programlisting>options IPFIREWALL</programlisting>

      <para>Diese Option aktiviert IPFW als Bestandteil des
	Kernels.</para>

      <programlisting>options IPFIREWALL_VERBOSE</programlisting>

      <para>Diese Option aktiviert die Funktion, alle Pakete, die durch
	IPFW verarbeitet werden und bei denen das Schlüsselwort
	<literal>log</literal> gesetzt ist, zu protokollieren.</para>

      <programlisting>options IPFIREWALL_VERBOSE_LIMIT=5</programlisting>

      <para>Diese Option limitiert die Anzahl der durch &man.syslogd.8;
	protokollierten Pakete auf das angegebene Maximum.  Sie wird
	in feindlichen Umgebungen verwandt, in denen die
	Protokollierung der Firewall-Aktivität erwünscht
	ist.  Dadurch wird ein möglicher Denial-of-Service-Angriff
	durch Überflutung von &man.syslogd.8; verhindert.</para>

      <indexterm>
	<primary>Kerneloptionen</primary>

	<secondary>IPFIREWALL_DEFAULT_TO_ACCEPT</secondary>
      </indexterm>

      <programlisting>options IPFIREWALL_DEFAULT_TO_ACCEPT</programlisting>

      <para>Diese Option erlaubt allen Paketen, die Firewall zu passieren.
	Diese Einstellung kann beispielsweise bei der ersten Konfiguration
	der Firewall hilfreich sein.</para>

      <indexterm>
	<primary>Kerneloptionen</primary>

	<secondary>IPDIVERT</secondary>
      </indexterm>

      <programlisting>options IPDIVERT</programlisting>

      <para>Dies aktiviert die Nutzung der
	<acronym>NAT</acronym>-Funktionalität.</para>

      <note>
	<para>Die Firewall wird alle eingehenden oder ausgehenden
	  Pakete blockieren, wenn entweder die Kernel-Option
	  <literal>IPFIREWALL_DEFAULT_TO_ACCEPT</literal> fehlt oder
	  aber keine Regel, die die betreffenden Verbindungen explizit
	  gestattet, existiert.  Dies enstpricht im Wesentlichen der
	  Einstellung <quote>default to deny</quote></para>
      </note>
    </sect2>

    <sect2 xml:id="firewalls-ipfw-rc">
      <title>Optionen in <filename>/etc/rc.conf</filename></title>

      <para>Der Eintrag</para>

      <programlisting>firewall_enable="YES"</programlisting>

      <para>aktiviert die Firewall während des Systemstarts.</para>

      <para>Die Auswahl einer für &os; verfügbaren Firewall
	erfolgt durch einen entsprechenden Eintrag in der Datei
	<filename>/etc/rc.firewall</filename>, durch den der Firewalltyp
	festgelegt wird.</para>

      <programlisting>firewall_type="open"</programlisting>

      <para>Konkret sind folgende Einträge erlaubt:</para>

      <itemizedlist>
	<listitem>
	  <para><literal>open</literal> &mdash; gestattet jeglichen
	    Datenverkehr</para>
	</listitem>

	<listitem>
	  <para><literal>client</literal> &mdash; schützt nur die
	    jeweilige Maschine (Client/Mandant)</para>
	</listitem>

	<listitem>
	  <para><literal>simple</literal> &mdash; schützt das
	    gesamte Netzwerk</para>
	</listitem>

	<listitem>
	  <para><literal>closed</literal> &mdash; unterbindet
	    jeglichen IP-Datenverkehr mit Ausnahme des Verkehrs
	    über die Loopback-Schnittstelle.</para>
	</listitem>

	<listitem>
	  <para><literal>UNKNOWN</literal> &mdash; deaktiviert das
	    Laden von Firewallregeln</para>
	</listitem>

	<listitem>
	  <para><filename>filename</filename>
	    &mdash; absoluter Pfad zu einer Datei, in der die
	    Firewallregeln definiert sind</para>
	</listitem>
      </itemizedlist>

      <para>Angepasste Regeln für &man.ipfw.8; können auf zwei
	verschiedene Arten geladen werden.  Einerseits kann man durch die
	Variable <varname>firewall_type</varname> den absoluten Pfad
	der Datei angeben, welche die <emphasis>Firewallregeln</emphasis>
	(ohne weitere Optionen) für &man.ipfw.8; enthält.  Ein
	einfaches Beispiel für einen Regelsatz, der jeglichen
	eingehenden und ausgehenden Datenverkehr blockiert, könnte
	beispielsweise so aussehen:</para>

      <programlisting>add deny in add deny out</programlisting>

      <para>Andererseits ist es möglich, den Wert der
	<varname>firewall_type</varname>-Variable mit dem absoluten
	Pfad einer Datei zu belegen, die (als ausführbares Skript)
	die &man.ipfw.8;-Kommandos enthält, die beim Booten
	ausgeführt werden sollen.   Ein gültiges Skript (das die
	gleiche Funktion hat wie die Zeile im letzten Beispiel) könnte
	beispielsweise so aussehen:</para>

      <programlisting>#!/bin/sh

ipfw -q flush

ipfw add deny in
ipfw add deny out</programlisting>

      <note>
	<para>Wenn die Variable <varname>firewall_type</varname>
	  entweder auf <literal>client</literal> oder
	  <literal>simple</literal> gesetzt ist, sollten die
	  Standardregeln in der Datei
	  <filename>/etc/rc.firewall</filename> geprüft und an die
	  Konfiguration der gegebenen Maschine angepasst werden.  Beachten
	  Sie dabei bitte, dass die Beispiele dieses Kapitels davon
	  ausgehen, dass das <varname>firewall_script</varname> auf
	  <filename>/etc/ipfw.rules</filename> gesetzt ist.</para>
      </note>

      <para>Das Logging wird durch folgenden Eintrag aktiviert:</para>

      <programlisting>firewall_logging="YES"</programlisting>

      <warning>
	<para>Die Variable <varname>firewall_logging</varname> definiert
	  lediglich die sysctl-Variable als
	  <varname>net.inet.ip.fw.verbose = 1</varname> (lesen Sie dazu
	  bitte auch den Abschnitt <xref linkend="firewalls-ipfw-enable"/>
	  des Handbuchs).  Es gibt keine
	  <filename>rc.conf</filename>-Variable, mit der man
	  Protokollierungsschwellen setzen könnte.  Dies kann
	  lediglich über &man.sysctl.8; geschehen, wobei Sie in
	  der Datei <filename>/etc/sysctl.conf</filename> nur
	  Werte &gt; 1 angeben sollten:</para>

	<programlisting>net.inet.ip.fw.verbose_limit=5</programlisting>
      </warning>

      <para>Sollte Ihre Maschinen als Gateway fungieren (also mittels
	&man.natd.8; <foreignphrase>Network Address
	Translation</foreignphrase> (<acronym>NAT</acronym>)
	durchführen), finden Sie in Abschnitt
	<xref linkend="network-natd"/> weitere Optionen für die
	  <filename>/etc/rc.conf</filename>.</para>
    </sect2>

    <sect2 xml:id="firewalls-ipfw-cmd">
      <title>Der Befehl IPFW</title>

      <indexterm><primary><command>ipfw</command></primary></indexterm>

      <para>Mit &man.ipfw.8; ist es möglich, im laufenden Betrieb
	einzelne Regeln hinzuzufügen oder zu entfernen.  Problematisch
	ist allerdings, dass diese Änderungen verloren gehen, wenn
	das System neu gestartet wird.  Daher ist es empfehlenswert,
	eigene Regeln in einer Datei zu definieren und diese zu laden, um
	die Regeln der Firewall im laufenden Betrieb anzupassen.</para>

      <para>&man.ipfw.8; ist jedoch hilfreich, um die Regeln der laufenden
	Firewall in der Konsole auszugeben.  IPFW erzeugt dynamisch einen
	Zähler, der jedes Paket, auf das eine Regel zutrifft,
	zählt.  Dadurch wird es möglich, die Funktion einer
	Regel zu überprüfen.</para>

      <para>Eine sequentielle Liste aller Regeln erhalten Sie mit:</para>

      <screen>&prompt.root; <userinput>ipfw list</userinput></screen>

      <para>Eine Liste aller Regeln inklusive des letzten Treffers
	erhalten Sie durch den folgenden Befehl:</para>

      <screen>&prompt.root; <userinput>ipfw -t list</userinput></screen>

      <para>Um eine Liste aller Regeln inklusive der Anzahl der Pakete, die
	von einer Regel gefiltert wurden, zu erhalten, geben Sie
	den folgenden Befehl ein:</para>

      <screen>&prompt.root; <userinput>ipfw -a list</userinput></screen>

      <para>Eine Liste, die zusätzlich allen dynamischen Regeln
	enthält, erhalten Sie mit:</para>

      <screen>&prompt.root; <userinput>ipfw -d list</userinput></screen>

      <para>Um diese Liste um alle <quote>abgelaufenen</quote> Regeln zu
	erweitern, ädern Sie diesen Befehl wie folgt ab:</para>

      <screen>&prompt.root; <userinput>ipfw -d -e list</userinput></screen>

      <para>Alle Zähler auf Null zurücksetzen:</para>

      <screen>&prompt.root; <userinput>ipfw zero</userinput></screen>

      <para>Es ist auch möglich, einen spezifischen Zähler
	auszuwählen und zurückzusetzen:</para>

      <screen>&prompt.root; <userinput>ipfw zero NUM</userinput></screen>
    </sect2>

    <sect2 xml:id="firewalls-ipfw-rules">
      <title>IPFW-Regeln</title>

      <para>Ein Regelwerk ist eine Menge von IPFW-Regeln, die in
	Abhängigkeit von bestimmten Paketeigenschaften Pakete
	entweder passieren lassen oder abweisen.  Der
	zustandshafte bidirektionale Transfer von Paketen zwischen
	Rechnern wird als Sitzung bezeichnet.  Das Regelwerk der Firewall
	verarbeitet sowohl ankommende Pakete (aus dem öffentlichen
	Internet) als auch Pakete, deren Ursprung in einer Antwort des
	Systems auf empfangene Pakete liegt.  Jeder
	<acronym>TCP/IP</acronym>-Dienst (wie telnet, www, mail) ist
	durch sein Protokoll und durch den priveligierten
	(eingehenden) Port definiert.  An einen spezifischen Dienst
	adressierte Pakete kommen von einer Quelladresse und einem
	unprivilegierten (high order) Port. Sie adressieren den
	spezifischen Port des Dienstes an der Zieladresse.  Alle weiter
	oben aufgeführten Parameter (also Ports und Adressen)
	können als Selektionskriterium zur Erzeugung von Regeln
	genutzt werden, die ein Passieren der Firewall für oder
	ein Blockieren von Diensten bewirken.</para>

      <indexterm>
	<primary>IPFW</primary>

	<secondary>rule processing order</secondary>
      </indexterm>

      <!-- Needs rewording to include note below -->

      <para>Wenn ein Paket die Firewall <quote>betritt</quote>, also
	von der Firewall geprüft und verarbeitet wird, wird die
	erste Regel des Regelwerkes auf das Paket angewandt.  Auf
	diese Weise wird in aufsteigender Reihenfolge der Regelnummer
	mit allen weiteren Regeln verfahren.  Falls die
	Selektionsparameter einer Regel auf ein Paket zutreffen, wird
	das Aktionsfeld der Regel ausgeführt und die Prüfung
	des Pakets beendet, nachfolgende Regeln werden also nicht
	mehr geprüft.  Diese Suchmethode wird als <quote>erster
	Treffer gewinnt</quote> bezeichnet.  Falls keine Regel auf
	das betreffende Paket zutrifft, wird die obligatorische
	IPFW-Rückfallregel (also Regel 65535) angewendet und das
	Paket wird ohne Rückantwort verworfen.</para>

      <note>
	<para>Die Prüfung der Regeln wird nach Treffern von mit
	  <literal>count</literal>, <literal>skipto</literal> und
	  <literal>tee</literal> parametrisierten Regeln ungeachtet
	  des <quote>erster Treffer gewinnt</quote>-Prinzips weiter
	  fortgeführt.</para>
      </note>

      <para>Die Anweisungen basieren auf der Nutzung von Regeln
	mit den zustandsgesteuerten Optionen <literal>keep</literal>,
	<literal>state</literal>, <literal>limit</literal>,
	<literal>in</literal> und <literal>out</literal>.  Diese
	bilden die Basis für die Spezifikation von
	Firewallregeln.</para>

      <warning>
	<para>Bei der Arbeit mit Firewallregeln ist Vorsicht geboten.
	  Es ist sehr einfach, sich selbst auszuschließen.</para>
      </warning>

      <sect3 xml:id="firewalls-ipfw-rules-syntax">
	<title>Syntax der Firewallregeln</title>

	<indexterm>
	  <primary>IPFW</primary>

	  <secondary>rule syntax</secondary>
	</indexterm>

	<para>Mit der in diesem Abschnitt dargestellten Syntax der
	  Regeln kann ein Standardregelsatz für eine
	  <quote>einschließende</quote> Firewall erstellt
	  werden.  Für eine vollständige Beschreibung der
	  Regelsyntax lesen Sie bitte die Manualpage &man.ipfw.8;</para>

	<para>Regelausdrücke werden <quote>von links nach
	  rechts</quote> ausgewertet.  Schlüsselwörter
	  werden in fetter Schrift dargestellt.  Manche
	  Schlüsselworte beinhalten Unteroptionen, die wiederum
	  selbst aus Schlüsselworten samt Optionen bestehen
	  können.</para>

	<para>Kommentare sind mit einen führenden Doppelkreuz
	  (<literal>#</literal>) ausgezeichnet.  Sie können am
	  Ende einer Regel oder in einzelnen, separaten Zeilen stehen.
	  Leerzeilen werden ignoriert.</para>

	<para><replaceable>CMD RULE_NUMBER ACTION LOGGING SELECTION
	  STATEFUL</replaceable></para>

	<sect4>
	  <title>CMD</title>

	  <para>Jede neue Regel benötigt das Präfix
	    <literal>add</literal>, um die Regel der internen
	    Tabelle hinzuzfügen.</para>
	</sect4>

	<sect4>
	  <title>RULE_NUMBER</title>

	  <para>Zu jeder Regel gehört eine Regelnummer zwischen 1
	    und 65535.</para>
	</sect4>

	<sect4>
	  <title>ACTION</title>

	  <para>Eine Regel kann mit einer der vier folgenden Aktionen
	    verbunden sein, die ausgeführt werden, wenn ein Paket
	    den Selektionskriterien der Regel entspricht.</para>

	  <para><parameter>allow | accept | pass | permit</parameter></para>

	  <para>Alle diese Aktionen bewirken das Gleiche:  Pakete, die
	    den Selektionskriterien der Regel entsprechen, verlassen den
	    Regelprüfungsabschnitt der Firewall und die
	    Regelprüfung wird beendet.</para>

	  <para><parameter>check-state</parameter></para>

	  <para>Diese Aktion prüft das Paket gegen die Regeln aus
	    den dynamischen Regeltabellen.  Trifft ein
	    Selektionskriterium zu, wird die zur dynamischen Regel
	    gehörende Aktion ausgeführt.  Anderenfalls wird
	    gegen die nächste Regel geprüft.  Die
	    <literal>check-state</literal>-Regel selbst hat kein
	    Selektionskriterium.  Sollte eine
	    <literal>check-state</literal>-Regel im Regelwerk fehlen,
	    wird gegen die erste <literal>keep-state</literal>- oder
	    <literal>limit</literal>-Regel in den dynamischen Regeln
	    geprüft.</para>

	  <para><parameter>deny | drop</parameter></para>

	  <para>Beide Schlüsselworte bewirken dieselbe Aktion:
	    Ein Paket, dass die Selektionskriterien der Regel
	    erfüllt, wird verworfen und die Regelprüfung
	    wird beendet.</para>
	</sect4>

	<sect4>
	  <title>Protokollierung</title>

	  <para><parameter>log</parameter> oder
	    <parameter>logamount</parameter></para>

	  <para>Erfüllt ein Paket die Selektionskriterien mit dem
	    Schlüsselwort <literal>log</literal>, wird dies von
	    &man.syslogd.8; mit der Annotation SECURITY protokolliert.
	    Dies erfolgt allerdings nur, wenn die Anzahl der
	    protokollierten Pakete der betreffenden Regel die im
	    <literal>logamount</literal>-Parameter definierte
	    Schwelle nicht übersteigt.  Ist der Parameter
	    <literal>logamount</literal> nicht definiert, wird diese
	    Grenze aus der <command>sysctl</command>-Variable
	    <varname>net.inet.ip.fw.verbose_limit</varname> ermittelt.
	    Ist einer dieser beiden Werte auf <quote>Null</quote>
	    gesetzt, wird unbegrenzt protokolliert.  Wurde hingegen
	    ein definierter Schwellenwert erreicht, wird die
	    Protokollierung deaktiviert.  Um sie zu reaktivieren,
	    können Sie entweder den Protokoll- oder den
	    Paketzähler rücksetzen (und zwar über den
	    Befehl <command>ipfw reset log</command>).</para>

	  <note>
	    <para>Die Protokollierung findet statt, nachdem alle
	      Paketselektionskriterien geprüft und bevor die
	      daraus folgende, endgültige Aktion
	      (<literal>accept</literal> oder <literal>deny</literal>)
	      auf das Paket ausgeführt wird.  Die Entscheidung,
	      welche Regel protokolliert werden soll, bleibt Ihnen
	      überlassen.</para>
	  </note>
	</sect4>

	<sect4>
	  <title>Selektion</title>

	  <para>Die in diesem Abschnitt beschriebenen
	    Schlüsselwörter beschreiben die Attribute eines
	    Pakets, durch die bestimmt wird, ob eine Regel auf ein
	    Paket zutrifft.  Die folgenden Attribute dienen der
	    Bestimmung des Protokolls und müssen in der angegebenen
	    Reihenfolge verwendet werden.</para>

	  <para><parameter>udp | tcp | icmp</parameter></para>

	  <para>Weitere in <filename>/etc/protocols</filename>
	    angegebene Protokolle werden ebenfalls erkannt und
	    können daher verwendet werden, um das Protokoll zu
	    definieren, gegen das Pakete geprüft werden. Die
	    Angabe des Protokolls ist verpflichtend.</para>

	  <para><parameter>from src to dst</parameter></para>

	  <para>Die Schlüsselwörter <literal>from</literal>
	    und <literal>to</literal> beziehen sich auf IP-Adressen und
	    definieren sowohl Ursprungs- als auch Zieladresse einer
	    Datenverbindung.  Firewallregeln müssen Parameter
	    für den Ursprung <emphasis>und</emphasis> das Ziel
	    enthalten.  Das Schlüsselwort <literal>any</literal>
	    steht für beliebige IP-Adressen.  Bei
	    <literal>me</literal> handelt es sich um ein spezielles
	    Schlüsselwort, das alle IP-Adressen beschreibt, die
	    einer bestimmten Netzwerkschnittstelle Ihres Systems
	    (auf dem die Firewall läuft) zugeordnet sind.
	    Beispiele hierfür sind
	    <literal>from me to any</literal>,
	    <literal>from any to me</literal>,
	    <literal>from 0.0.0.0/0 to any </literal>,
	    <literal>from any to 0.0.0.0/0</literal>,
	    <literal>from 0.0.0.0 to any</literal>,
	    <literal>from any to 0.0.0.0</literal> oder
	    <literal>from me to 0.0.0.0</literal>.  IP-Adressen werden
	    entweder in <acronym>CIDR</acronym>-Notation
	    oder durch Punkte getrennt mit Suffixen
	    (<systemitem class="ipaddress">192.168.2.101/24</systemitem>) für
	    die Netzmaske oder als einzelne numerische, durch Punkte
	    getrennte Adressen
	    (<systemitem class="ipaddress">192.168.2.101</systemitem>) angegeben.
	    Die dafür notwendigen Berechnungen erleichtert der
	    Port <package>net-mgmt/ipcalc</package>.
	    Weiterführende Informationen finden sich auf
	    <uri xlink:href="http://jodies.de/ipcalc">http://jodies.de/ipcalc</uri>.</para>

	  <para><parameter>port number</parameter></para>

	  <para>Bei der Verarbeitung von Protokollen wie
	    <acronym>TCP</acronym> oder <acronym>UDP</acronym>, die
	    Portnummern verwenden, muss die Portnummer des
	    betreffenden Dienstes angegeben werden.  Anstelle der
	    Portnummer kann auch der in der Datei
	    <filename>/etc/services</filename> definierte Name des
	    Dienstes angegeben werden.</para>

	  <para><parameter>in | out</parameter></para>

	  <para>Diese Schlüsselwörter beziehen sich auf die
	    Richtung des Datenverkehrs.  Jede Regel
	    <emphasis>muss</emphasis> eines dieser beiden
	    Schlüsselwörter enthalten.</para>

	  <para><parameter>via IF</parameter></para>

	  <para>Eine Regel mit dem Schlüsselwort
	    <literal>via IF</literal> betrifft nur Pakete, die über
	    die angegebene Schnittstellte geroutet werden (ersetzen Sie
	    <literal>IF</literal> durch den Namen Ihrer
	    Netzwerkschnittstelle).  Die Angabe des
	    Schlüsselwortes <literal>via</literal> bewirkt, dass
	    die Netzwerkschnittstelle in die Regelprüfung
	    aufgenommen wird.</para>

	  <para><parameter>setup</parameter></para>

	  <para>Dieses obligatorische Schlüsselwort bezeichnet
	    die Anforderung des Sitzungsstarts für
	    <acronym>TCP</acronym>-Pakete.</para>

	  <para><parameter>keep-state</parameter></para>

	  <para>Dieses obligatorische Schlüsselwort bewirkt,
	    dass die Firewall eine dynamische Regel erzeugt, die
	    bidirektionalen Datenverkehr zwischen Ursprungs- und
	    Zieladresse sowie Ursprungs- und Zielport prüft,
	    der das gleiche Protokoll verwendet.</para>

	  <para><parameter>limit {src-addr | src-port | dst-addr |
	      dst-port}</parameter></para>

	  <para>Wird das Schlüsselwort <literal>limit</literal>
	    verwendet, sind nur <literal>N</literal> durch diese
	    Regel definierte Verbindungen erlaubt.  Es können
	    dabei ein oder mehrere Ursprungs- und Zieladressen sowie
	    ein oder mehrere Ports angegeben werden.  Die
	    Schlüsselwörter <literal>limit</literal>
	    und <literal>keep-state</literal> können nicht in
	    derselben Regel verwendet werden.  Die Option
	    <literal>limit</literal> bewirkt dieselbe Zustandsteuerung
	    wie die Option <literal>keep-state</literal>, erweitert
	    diese jedoch um eigene Regeln.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>Optionen für zustandsgesteuerte Regeln</title>

	<indexterm>
	  <primary>IPFW</primary>

	  <secondary>stateful filtering</secondary>
	</indexterm>

	<!-- XXX: duplicated -->

	<para>Eine zustandsgesteuerte Filterung behandelt Datenverkehr
	  als einen bidirektionalen Austausch von Datenpaketen (die eine
	  sogenannte Konversation innerhalb einer Sitzung darstellen).
	  Sie ist in der Lage, zu bestimmen, ob die Konversation von
	  originärem Sender und Empfänger gültigen
	  Prozeduren des bidirektionalen Pakettausches entspricht.
	  Pakete, die dem Muster von Konversationen in Sitzungen nicht
	  folgen, werden automatisch als <quote>Betrüger</quote>
	  abgelehnt.</para>

	<para>Die <literal>check-state</literal>-Option wird verwendet,
	  wo genau innerhalb des IPFW-Regelwerks die Prüfung
	  dynamischer Regeln stattfinden soll.  Erfüllt ein
	  Datenpaket die Selektionskriterien der Regel, verlässt
	  das Paket die Firewall.  Gleichzeitig wird eine neue
	  dynamische Regel erzeugt, die für das nächste Paket
	  der bidirektionalen Konversation in der Sitzung vorgesehen
	  ist.  Falls ein Paket die (dyanmische) Regel nicht erfüllt,
	  wird es gegen die nächste Regel im Regelwerk
	  geprüft.</para>

	<para>Dynamische Regeln sind für einem sogenannten
	  <foreignphrase>SYN-flood</foreignphrase>-Angriff anfällig,
	  bei dem eine riesige Anzahl <quote>schwebender</quote>
	  dynamischer Regelprüfungungsinstanzen erzeugt wird.  Um
	  einem solchen Angriff zu begegnen, wurde in &os; die neue
	  Option <literal>limit</literal> geschaffen.  Diese Option
	  begrenzt die Anzahl der gleichzeitig möglichen
	  Sitzungen und/oder Konversationen.  Es handelt sich dabei um
	  einen Zähler, der die Anzahl von Instanzen dynamischer
	  Regelprüfungen in Abhängigkeit von einer eindeutigen
	  Urspungs- und Quelladresskombination zählt.
	  Übersteigt der Zähler den durch
	  <literal>limit</literal> definierten Schwellenwert, wird
	  das Paket verworfen.</para>
      </sect3>

      <sect3>
	<title>Protokollierung von Firewall-Nachrichten</title>

	<indexterm>
	  <primary>IPFW</primary>

	  <secondary>logging</secondary>
	</indexterm>

	<para>Die Vorteile einer Protokollierung sind offensichtlich.
	  Sie ermöglicht nach Aktivierung von Regeln zu
	  untersuchen, welche Pakete verworfen wurden, von wo diese
	  stammen und für welche Systeme sie bestimmt waren.  Diese
	  Informationen sind sehr nützlich bei der Erkennung
	  eventueller Angriffe sowie bei deren Abwehr.</para>

	<para>IPFW protokolliert nur jene Regeln, für die ein
	  Administrator dies explizit aktiviert.  Ein Aktivieren
	  der Protolllfunktion führt also nicht dazu, dass
	  automatisch alle Regeln protokolliert werden.  Vielmehr
	  entscheidet der Administrator der Firewall, welche Regeln
	  protokolliert werden sollen.  Dazu wird die Option
	  <literal>log</literal> für diese Regeln aktiviert.  Im
	  Regelfall werden nur <literal>deny</literal>-Regeln
	  protokolliert, beispielsweise  die <literal>deny</literal>-Regel
	  für eintreffende <acronym>ICMP</acronym>-Nachrichten.
	  Üblicherweise wird die <quote>ipfw default deny
	  everything</quote>-Regel doppelt angelegt.  Einmal mit und
	  einmal ohne aktivierte Option <literal>log</literal>.  Dadurch
	  erhält man eine Auflistung aller Pakete, auf die keine
	  Regel zutraf.</para>

	<para>Protokollierung ist allerdings ein zweischneidiges
	  Schwert, bei mangelnder Vorsicht wird man mit einer enormen
	  Flut von Protokollierungsdaten förmlich
	  <emphasis>überschwemmt</emphasis> und belastet
	  zusätzlich die Festplatte des Systems durch rasch
	  wachsende Protokolldateien.  DoS-Angriffe, die auf diese
	  Art und Weise Festplatten an die Kapazitätsgrenze treiben,
	  gehören zu den ältesten Angriffen überhaupt.
	  Außerdem werden Protokollnachrichten nicht nur an
	  &man.syslogd.8; geschickt, sondern auch auf einem
	  root-Terminal angezeigt.</para>

	<para>Die Kerneloption
	  <varname>IPFIREWALL_VERBOSE_LIMIT=5</varname> begrenzt die
	  Anzahl gleicher Nachrichten an &man.syslogd.8; für
	  eine gegebene Regel auf fünf Nachrichten.  Ist diese
	  Option im Kernel aktiviert, wird nach Erreichen der
	  festgelegten Anzahl die Protokollierung einer (sich
	  unmittelbar hintereinander wiederholenden) Nachricht auf den
	  angegebenen Schwellenwert begrenzt, da beispielsweise die
	  Speicherung von 200 gleichen Protokollnachrichten durch
	  &man.syslogd.8; sinnlos ist.  Daher werden durch diesen
	  nur füf derartige Nachrichten protokolliert.  Alle
	  weiteren derartigen Nachrichten werden nur gezählt und
	  deren Gesamtzahl wird schließlich von &man.syslogd.8;
	  durch folgenden Ausdruck ausgegeben:</para>

	<programlisting>last message repeated 45 times</programlisting>

	<para>Alle protokollierten Nachrichten für Datenpakete
	  werden in der Voreinstellung in die Datei
	  <filename>/var/log/security</filename> (die in der Datei
	  <filename>/etc/syslog.conf</filename> definiert wird),
	  geschrieben.</para>
      </sect3>

      <sect3 xml:id="Firewalls-ipfw-rules-script">
	<title>Skripte zur Regeldefinition erstellen</title>

	<para>Die meisten fortgeschrittenen IPFW-Nutzer erzeugen eine
	  Datei, die die Regeln für die Firewall enthält,
	  um diese als Skript ausführen zu können.
	  Der Hauptvorteil einer derartigen Konfiguration ist es, dass
	  dadurch mehrere Regeln gleichzeitig geändert und
	  (re-)aktiviert werden können, ohne dass dazu das System
	  neu gestartet werden muss.  Dies ist auch beim Testen von
	  Regeländerungen sehr hilfreich.  Weil es sich bei der
	  Datei, in der die Regeln gespeichert sind, um ein Skript
	  handelt, ist es auch möglich, häufig verwendete
	  Werte/Befehle durch Aliase zu ersetzen und diese so in mehreren
	  Regeln zu nutzen.  Diese Funktion wird im folgenden Beispiel
	  näher vorgestellt.</para>

	<para>Die Syntax des folgenden Skripts entspricht der Syntax von
	  &man.sh.1;, &man.csh.1; sowie &man.tcsh.1;.  Felder, die
	  symbolisch substituiert werden, haben das Präfix
	  &dollar; (das Dollarzeichen).  Symbolische Felder haben dieses
	  &dollar;-Praefix nicht.  Der Wert, mit dem das symbolische
	  Feld belegt wird, muss in
	  <quote>doppelten Anführungszeichen</quote>
	  eingeschlossen sein.</para>

	<para>Beginnen Sie Ihre Regeldatei wie folgt:</para>

	<programlisting>############### start of example ipfw rules script #############
#
ipfw -q -f flush       # Delete all rules
# Set defaults
oif="tun0"             # out interface
odns="192.0.2.11"      # ISP's DNS server IP address
cmd="ipfw -q add "     # build rule prefix
ks="keep-state"        # just too lazy to key this each time
&dollar;cmd 00500 check-state
&dollar;cmd 00502 deny all from any to any frag
&dollar;cmd 00501 deny tcp from any to any established
&dollar;cmd 00600 allow tcp from any to any 80 out via &dollar;oif setup &dollar;ks
&dollar;cmd 00610 allow tcp from any to &dollar;odns 53 out via &dollar;oif setup &dollar;ks
&dollar;cmd 00611 allow udp from any to &dollar;odns 53 out via &dollar;oif &dollar;ks
################### End of example ipfw rules script ############</programlisting>

	<para>Die Regeln in diesem Beispiel sind nicht wichtig.  Wichtig
	  ist es, zu zeigen, wie die symbolische Substitution innerhalb
	  der Regeln verwendet wird.</para>

	<para>Wurde dieses Beispiel in der Datei
	  <filename>/etc/ipfw.rules</filename> gespeichert, so können
	  alle Regeln durch die Ausführung des folgenden Befehls
	  neu geladen werden:</para>

	<screen>&prompt.root; <userinput>sh /etc/ipfw.rules</userinput></screen>

	<para>Statt <filename>/etc/ipfw.rules</filename> können Sie
	  auch einen beliebigen anderen Namen und/oder Speicherort
	  verwenden.</para>

	<para>Alternativ könnten Sie die einzelnen Befehle dieses
	  Skripts auch manuell starten:</para>

	<screen>&prompt.root; <userinput>ipfw -q -f flush</userinput>
&prompt.root; <userinput>ipfw -q add check-state</userinput>
&prompt.root; <userinput>ipfw -q add deny all from any to any frag</userinput>
&prompt.root; <userinput>ipfw -q add deny tcp from any to any established</userinput>
&prompt.root; <userinput>ipfw -q add allow tcp from any to any 80 out via tun0 setup keep-state</userinput>
&prompt.root; <userinput>ipfw -q add allow tcp from any to 192.0.2.11 53 out via tun0 setup keep-state</userinput>
&prompt.root; <userinput>ipfw -q add 00611 allow udp from any to 192.0.2.11 53 out via tun0 keep-state</userinput></screen>
      </sect3>

      <sect3>
	<title>Zustandsgesteuertes Regelwerk</title>

	<para>Das folgende Regelwerk (ohne
	  <acronym>NAT</acronym>-Funktionalität) ist ein Beispiel
	  dafür, wie man eine sehr sichere
	  <quote>einschließende</quote> Firewall aufsetzen kann.
	  Eine einschließende Firewall erlaubt es nur Diensten,
	  für die explizite Regeln existieren, die Firewall zu
	  passieren.  Alle anderen Dienste und Pakete werden hingegen
	  blockiert.  Firewalls, die ganze Netzwerksegmente schützen
	  sollen, benötigen mindestens zwei Netzwerkschnittstellen,
	  für die jeweils eigene Regeln definiert werden müssen,
	  damit die Firewall ordnungsgemäß funktioniert.</para>

	<para>Alle unixoiden Betriebssysteme (aber auch solche, die
	  Konzepte aus &unix; implementieren), darunter auch &os;,
	  verwenden die Schnittstelle <filename>lo0</filename> mit
	  der IP-Adresse <systemitem class="ipaddress">127.0.0.1</systemitem> zur
	  internen Kommunikation mit dem Betriebssystem.  Die Firewall
	  muss so eingestellt sein, dass sie den Datenverkehr dieser
	  speziellen (und nur intern genutzten) Pakete ungehindert
	  durchlässt.</para>

	<para>Die Regeln, die den Zugriff auf eingehene und ausgehende
	  Verbindungen regeln, autorisieren und kontrollieren,
	  müssen mit der für die Verbindung zum
	  öffentlichen Internet verantwortlichen Schnittstelle
	  assoziiert werden.  Bei dieser Schnittstelle kann es sich
	  beispielsweise um
	  <acronym>PPP</acronym>/<filename>tun0</filename> oder
	  die Netzwerkkarte handelt, über, die mit Ihrem
	  <acronym>DSL</acronym>- oder Kabelmodem verbunden
	  ist.</para>

	<para>Falls mehr als eine Netzwerkkarte mit einem privaten
	  Netzwerk (hinter der Firewall) verbunden sind, müssen
	  die Firewallregeln für alle diese Schnittstellen
	  entstammenden Datenpakete freien und ungehinderten
	  Datenverkehr erlauben.</para>

	<para>Es ist sinnvoll, die Regeln in drei Abschnitte
	  aufzuteilen.  Der erste Abschnitt enthält die freien,
	  von der Firewall nicht zu überwachenden
	  Netzwerkschnittstellen.  Danach folgen die öffentlichen,
	  für den ausgehenden Verkehr verantwortlichen
	  Schnittstellen.  Zuletzt kommen dann die Schnittstellen,
	  die für den eingehenden Datenverkehr verantwortlich
	  sind.</para>

	<para>Innerhalb der einzelnen Abschnitte ist es sinnvoll, die
	  am häufigsten verwendeten Regeln vor den seltener
	  verwendeten Regel zu platzieren.  Jeder Abschnitt sollte
	  mit einer letzten Regel (die alle Pakete, auf die keine
	  Regel zutraf, verwirft) abgeschlossen werden.</para>

	<para>Der Abschnitt für den ausgehenden Datenverkehr des
	  folgenden Beispiels enthät nur
	  <literal>allow</literal>)-Regeln, in denen der Dienst, dem
	  der Zugriff auf das öffentliche Internet gewährt
	  wird, eindeutig definiert ist.  Alle Regeln verwenden die
	  Optionen <literal>proto</literal>, <literal>port</literal>,
	  <literal>in/out</literal>, <literal>via</literal> sowie
	  <literal>keep state</literal> kodiert.  Die
	  Regeln mit <literal>proto tcp</literal> verwenden
	  zusätzlich die Option <literal>setup</literal>, damit
	  die initiale, eine Sitzung beginnende Anfrage identifiziert
	  werden kann, damit die die Zustandsttabelle gefüllt
	  werden kann.</para>

	<para>Der Abschnitt für den eingehenden Datenverkehr
	  beginnt mit allen Regeln, die zur Blockierung
	  unerwünschten Datenverkehrs benötigt werden.
	  Für diese Vorgehensweise gibt es zwei Gründe:
	  Zum einen könnten bösartige Pakete legtitimen
	  Datenverker so sehr ähneln, dass sie die
	  Bedingungen von <literal>allow</literal>-Regeln erfüllen
	  und daher die Firewall passieren dürfen.  Daher sollten
	  derartige Pakete direkt verworden werden.  Zum anderen
	  sollten unerwünschte Pakete mit bekannten (und somit
	  uninteressanten Mustern) sofort ohne Rückmeldung blockiert
	  werden, anstatt erst von der letzten, generischen Regel
	  blockiert (und, was noch wichtiger ist, auch noch
	  protokolliert).  Die letzte Regel jedes Abschnittes blockiert
	  und protokolliert; sie kann daher dazu verwendet werden,
	  vor Gericht haltbare Beweise zu erhalten, damit sie gegen
	  Personen vorgehen können, die versuchen, Ihre Systeme
	  anzugreifen.</para>

	<para>Achten Sie darauf, dass Sie keine Netwerkantworten für
	  geblockte Pakete senden.  Diese müssen ohne
	  Rückmeldung verworfen werden, damit ein Angreifer keine
	  Informationen darüber erhält, ob seine Datenpakete
	  Ihr System erreicht hat.  Je weniger Information ein Angreifer
	  über Ihr System erhält, desto sicherer ist Ihr
	  System.  Datenpakete an Ports, die nicht bekannten Diensten
	  zugeordnet werden können, können über die Datei
	  <filename>/etc/services</filename> identifiziert werden.
	  Alternativ kann eine Anfrage an <uri xlink:href="http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers">http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers</uri>
	  Klarheit über die Aufgabe/Funktion einer bestimmten Portnummer
	  bringen.  Auf der Seite <uri xlink:href="http://www.sans.org/security-resources/idfaq/oddports.php">http://www.sans.org/security-resources/idfaq/oddports.php</uri>
	  kann man Information über bekannte Trojaner und von
	  diesen verwendete Portnummern erhalten.</para>
      </sect3>

      <sect3>
	<title>Ein Beispiel für einschließende
	  Regeln</title>

	<para>Das folgende Regelwerk (ohne
	  <acronym>NAT</acronym>-Funktionalität) beschreibt ein
	  vollständiges, einschließendes Regelwerk.  Dieses
	  Regelwerk kann direkt auf Ihren eigenen Systemen eingesetzt
	  werden, wenn alle <literal>pass</literal>-Regeln
	  für von Ihnen nicht benötigten Dienste
	  auskommentiert werden.  Falls Sie keine Protokollierung
	  benötigen, können Sie diese im Abschnitt für
	  den eingehenden Datenverkehr durch eine
	  <literal>deny</literal> deaktivieren.  Die im Beispiel
	  verwendete Netzwerkschnittstelle <filename>dc0</filename>
	  müssen Sie durch die auf Ihrem System für
	  ausgehenden Datenverkehr vorgesehenen Netzwerkschnittstelle
	  ersetzen.  Im Falle von benutzergesteuertem
	  <acronym>PPP</acronym>s wäre dies
	  beispielsweise <filename>tun0</filename>.</para>

	<para>Alle Regeln folgen einem bestimmten Muster.</para>

	<itemizedlist>
	  <listitem>
	    <para>Alle Ausdrücke, die eine Anfrage zum Beginn
	      einer zustandsgesteuerten darstellen, beinhalten den
	      Ausdruck <literal>keep-state</literal>.</para>
	  </listitem>

	  <listitem>
	    <para>Alle Dienste aus dem öffentlichen Internet
	      beinhalten die Option <literal>limit</literal>, um
	      gegebenenfalls
	      <foreignphrase>flooding</foreignphrase> zu
	      unterbinden.</para>
	  </listitem>

	  <listitem>
	    <para>Alle Regeln bezeichnen die Richtung durch der
	      Ausdrücke <literal>in</literal> oder
	      <literal>out</literal>.</para>
	  </listitem>

	  <listitem>
	    <para>Alle Regeln legen die verwendete
	      Netzwerkschnittstelle die Ausdrücke
	      <literal>via</literal> und
	      <replaceable>interface-name</replaceable> fest.</para>
	  </listitem>
	</itemizedlist>

	<para>Die folgenden Regeln werden in der Datei
	  <filename>/etc/ipfw.rules</filename> definiert.</para>

	<programlisting>################ Start of IPFW rules file ###############################
# Flush out the list before we begin.
ipfw -q -f flush

# Set rules command prefix
cmd="ipfw -q add"
pif="dc0"     # public interface name of NIC
              # facing the public Internet

#################################################################
# No restrictions on Inside LAN Interface for private network
# Not needed unless you have LAN.
# Change xl0 to your LAN NIC interface name
#################################################################
#&dollar;cmd 00005 allow all from any to any via xl0

#################################################################
# No restrictions on Loopback Interface
#################################################################
&dollar;cmd 00010 allow all from any to any via lo0

#################################################################
# Allow the packet through if it has previous been added to the
# the "dynamic" rules table by a allow keep-state statement.
#################################################################
&dollar;cmd 00015 check-state

#################################################################
# Interface facing Public Internet (Outbound Section)
# Interrogate session start requests originating from behind the
# firewall on the private network or from this gateway server
# destined for the public Internet.
#################################################################

# Allow out access to my ISP's Domain name server.
# x.x.x.x must be the IP address of your ISP.s DNS
# Dup these lines if your ISP has more than one DNS server
# Get the IP addresses from /etc/resolv.conf file
&dollar;cmd 00110 allow tcp from any to x.x.x.x 53 out via &dollar;pif setup keep-state
&dollar;cmd 00111 allow udp from any to x.x.x.x 53 out via &dollar;pif keep-state

# Allow out access to my ISP's DHCP server for cable/DSL configurations.
# This rule is not needed for .user ppp. connection to the public Internet.
# so you can delete this whole group.
# Use the following rule and check log for IP address.
# Then put IP address in commented out rule &amp; delete first rule
&dollar;cmd 00120 allow log udp from any to any 67 out via &dollar;pif keep-state
#&dollar;cmd 00120 allow udp from any to x.x.x.x 67 out via &dollar;pif keep-state

# Allow out non-secure standard www function
&dollar;cmd 00200 allow tcp from any to any 80 out via &dollar;pif setup keep-state

# Allow out secure www function https over TLS SSL
&dollar;cmd 00220 allow tcp from any to any 443 out via &dollar;pif setup keep-state

# Allow out send &amp; get email function
&dollar;cmd 00230 allow tcp from any to any 25 out via &dollar;pif setup keep-state
&dollar;cmd 00231 allow tcp from any to any 110 out via &dollar;pif setup keep-state

# Allow out FBSD (make install &amp; CVSUP) functions
# Basically give user root "GOD" privileges.
&dollar;cmd 00240 allow tcp from me to any out via &dollar;pif setup keep-state uid root

# Allow out ping
&dollar;cmd 00250 allow icmp from any to any out via &dollar;pif keep-state

# Allow out Time
&dollar;cmd 00260 allow tcp from any to any 37 out via &dollar;pif setup keep-state

# Allow out nntp news (i.e. news groups)
&dollar;cmd 00270 allow tcp from any to any 119 out via &dollar;pif setup keep-state

# Allow out secure FTP, Telnet, and SCP
# This function is using SSH (secure shell)
&dollar;cmd 00280 allow tcp from any to any 22 out via &dollar;pif setup keep-state

# Allow out whois
&dollar;cmd 00290 allow tcp from any to any 43 out via &dollar;pif setup keep-state

# deny and log everything else that.s trying to get out.
# This rule enforces the block all by default logic.
&dollar;cmd 00299 deny log all from any to any out via &dollar;pif

#################################################################
# Interface facing Public Internet (Inbound Section)
# Check packets originating from the public Internet
# destined for this gateway server or the private network.
#################################################################

# Deny all inbound traffic from non-routable reserved address spaces
&dollar;cmd 00300 deny all from 192.168.0.0/16 to any in via &dollar;pif  #RFC 1918 private IP
&dollar;cmd 00301 deny all from 172.16.0.0/12 to any in via &dollar;pif     #RFC 1918 private IP
&dollar;cmd 00302 deny all from 10.0.0.0/8 to any in via &dollar;pif          #RFC 1918 private IP
&dollar;cmd 00303 deny all from 127.0.0.0/8 to any in via &dollar;pif        #loopback
&dollar;cmd 00304 deny all from 0.0.0.0/8 to any in via &dollar;pif            #loopback
&dollar;cmd 00305 deny all from 169.254.0.0/16 to any in via &dollar;pif   #DHCP auto-config
&dollar;cmd 00306 deny all from 192.0.2.0/24 to any in via &dollar;pif       #reserved for docs
&dollar;cmd 00307 deny all from 204.152.64.0/23 to any in via &dollar;pif  #Sun cluster interconnect
&dollar;cmd 00308 deny all from 224.0.0.0/3 to any in via &dollar;pif         #Class D &amp; E multicast

# Deny public pings
&dollar;cmd 00310 deny icmp from any to any in via &dollar;pif

# Deny ident
&dollar;cmd 00315 deny tcp from any to any 113 in via &dollar;pif

# Deny all Netbios service. 137=name, 138=datagram, 139=session
# Netbios is MS/Windows sharing services.
# Block MS/Windows hosts2 name server requests 81
&dollar;cmd 00320 deny tcp from any to any 137 in via &dollar;pif
&dollar;cmd 00321 deny tcp from any to any 138 in via &dollar;pif
&dollar;cmd 00322 deny tcp from any to any 139 in via &dollar;pif
&dollar;cmd 00323 deny tcp from any to any 81 in via &dollar;pif

# Deny any late arriving packets
&dollar;cmd 00330 deny all from any to any frag in via &dollar;pif

# Deny ACK packets that did not match the dynamic rule table
&dollar;cmd 00332 deny tcp from any to any established in via &dollar;pif

# Allow traffic in from ISP's DHCP server. This rule must contain
# the IP address of your ISP.s DHCP server as it.s the only
# authorized source to send this packet type.
# Only necessary for cable or DSL configurations.
# This rule is not needed for .user ppp. type connection to
# the public Internet. This is the same IP address you captured
# and used in the outbound section.
#&dollar;cmd 00360 allow udp from any to x.x.x.x 67 in via &dollar;pif keep-state

# Allow in standard www function because I have apache server
&dollar;cmd 00400 allow tcp from any to me 80 in via &dollar;pif setup limit src-addr 2

# Allow in secure FTP, Telnet, and SCP from public Internet
&dollar;cmd 00410 allow tcp from any to me 22 in via &dollar;pif setup limit src-addr 2

# Allow in non-secure Telnet session from public Internet
# labeled non-secure because ID &amp; PW are passed over public
# Internet as clear text.
# Delete this sample group if you do not have telnet server enabled.
&dollar;cmd 00420 allow tcp from any to me 23 in via &dollar;pif setup limit src-addr 2

# Reject &amp; Log all incoming connections from the outside
&dollar;cmd 00499 deny log all from any to any in via &dollar;pif

# Everything else is denied by default
# deny and log all packets that fell through to see what they are
&dollar;cmd 00999 deny log all from any to any
################ End of IPFW rules file ###############################</programlisting>
      </sect3>

      <sect3>
	<title>Ein Beispiel für zustandshafte
	  <acronym>NAT</acronym>-Regeln</title>

	<indexterm>
	  <primary>NAT</primary>
	  <secondary>und IPFW</secondary>
	</indexterm>

	<para>Es müssen einige zusätzliche
	  Konfigurationseinstellungen vorgenommen werden, um die
	  die <acronym>NAT</acronym>-Funktion von IPFW zu nutzen.  Die
	  Kernelquellen müssen mit der Option
	  <literal>IPDIVERT</literal> (im IPFIREWALL-Abschnitt der
	  Kernelkonfigurationsdatei) neu gebaut werden, um den
	  benötigten angepassten Kernel zu erzeugen.</para>

	<para>Zusätzlich werden folgende Optionen in der
	  <filename>/etc/rc.conf</filename> benötigt:</para>

	<programlisting>natd_enable="YES"                   # Enable <acronym>NAT</acronym>D function
natd_interface="rl0"                # interface name of public Internet NIC
natd_flags="-dynamic -m"            # -m = preserve port numbers if possible</programlisting>

	<para>Zustandshafte Regeln bei aktiviertem
	  <literal>divert natd</literal> (<foreignphrase>Network
	  Address Translation</foreignphrase>) verkomplizieren die
	  Formulierung des Regelwerkes beträchtlich.  Damit Ihre
	  Firewall funktioniert, kommt es insbesondere auf die Position
	  der Ausdrücke <literal>check-state</literal> sowie
	  <literal>divert natd</literal> an.  Sie können nicht
	  länger einen einfachen, kaskadierenden Ablauf verwenden
	  (also einen Regelsatz, bei dem einfach auf eine Regel nach der
	  anderen geprüft wird.  Vielmehr wird der neue
	  Aktionstyp <literal>skipto</literal> benötigt.  Dies
	  erfordert, dass jede Regel über eine eindeutige Nummer
	  verfügt, um so eindeutige Sprungziele zu erhalten.</para>

	<para>Im Folgenden wird anhand eines umkommentierten Beispiels
	  der Paketfluss durch das Regelwerk verdeutlicht.</para>

	<para>Die Verarbeitung beginnt mit der ersten Regel (also am
	  Anfang der Regeldatei.  Sie setzt sich Regel für Regel
	  weiter fort, bis das Ende der Datei erreicht ist oder eine
	  Regel für das Paket einen Treffer erzielt und das Paket
	  so die Firewall verlassen kann.  Achten Sie besonders auf die
	  Position der Regeln mit den Nummern
	  <literal>100, 101, 450, 500</literal> sowie
	  <literal>510</literal>.  Diese Regeln steuern die
	  Adressumsetzung ausgehender und eingehender Pakete, so dass
	  deren entsprechende Einträge in der Zustandstabelle immer
	  die private LAN-Adressen abbilden.  Zusätzlich werden in
	  allen Regeln die Richtung des Pakets (eingehend oder
	  ausgehend) so die vom Paket zu verwendende Netzwerkschnittstelle
	  definiert.  Ausgehende Anfragen, die eine Sitzung starten, rufen
	  immer <literal>skipto rule 500</literal>, damit
	  <acronym>NAT</acronym> verwendet werden kann.</para>

	<para>Nehmen wir nun an, dass ein Nutzer einen Webbrowser
	  verwendet, um eine Internetseite aufzurufen.  Derartige
	  Anfragen werden in der Regel über Port 80 geleitet.  Die
	  zugehörigen Pakete werden durch die Firewall verarbeitet.
	  Regel 100 trifft nicht zu, denn das Paket geht nach außen,
	  nicht nach innen.  Regel 101 trifft ebenfalls nicht zu, denn es
	  handelt sich um das erste Paket.  Folglich wird die Sitzung
	  erst initiiert und kann somit noch nicht in der
	  Zustandstabelle enthalten sein kann.  Die erste Regel, die
	  zutrifft, ist Regel 125.  Das Paket will das lokale Netzwerk
	  über die Schnittstelle zum öffentlichen Internet (das
	  heißt nach außen) verlassen, es hat aber noch die
	  Quelladresse des privaten lokalen Netzwerks.  Da Regel 125
	  zutrifft, werden zwei Aktionen ausgeführt:  Die Option
	  <literal>keep-state</literal> bewirkt, dass das Paket in der
	  internen Tabelle für zustandshafte, dynamische Regeln
	  registriert wird.  Danach wird der Aktionsteil der Regel
	  ausgeführt.  Dieser ist Bestandteil der Informationen, die
	  in die in der Tabelle für dynamische Regeln aufgenommen
	  wird und lautet <literal>skipto rule  500</literal>.  Die
	  Regel 500 führt <acronym>NAT</acronym>s auf die
	  IP-Adresse des Paketes durch.  Danach verlässt das Paket
	  das LAN nach außen in Richtung des öffentlichen
	  Internets.  Dieser letzte Teil ist für funktionierendes
	  NAT von entscheidender Bedeutung.  Nachdem dieses Paket
	  am Bestimmungsort angekommen ist, wird dort eine Antwort
	  generiert und zurückgeschickt.  Dieses Paket wird auf die
	  gleiche Art und Weise durch das gegebene Regelwerk
	  verarbeitet.  Dieses Mal trifft Regel 100 auf das Paket zu,
	  damit wird die Bestimmungsadresse auf die zugehörige
	  (lokale) LAN-Adresse (rück-)abgebildet.  Danach wird es
	  von der <literal>check-state</literal>-Regel verarbeitet,
	  die Zustandstabelle erkennt, dass eine zugehörige
	  aktive Sitzung vorliegt und das Paket wird freigegeben
	  und in das LAN geleitet.  Es wird innerhalb des LANs von dem PC,
	  der die zugehörige Sitzung hält, empfangen, der
	  ein neues Paket absendet und ein weiteres Datensegment vom
	  entfernten Server anfordert.  Dieses Mal wird bei der
	  Prüfung der <literal>check-state</literal>-Regel ein
	  nach außen gehender zugehöriger Eintrag in der
	  Zustandstabelle gefunden und die entsprechende Aktion (also
	  <literal>skipto 500</literal>) wird ausgeführt.  Das
	  Paket springt zu Regel 500 und wird durch diese Regel für
	  das öffentliche Internet freigegeben.</para>
<!-- gecheckt bis hier - jkois - 2012-01-08 -->
	<para>Innerhalb des durch die Firewall geschützten
	  Netzwerks werden alle eingehenden Pakete, die zu einer
	  existierenden Sitzung gehören, durch die Regel
	  <literal>check-state</literal> sowie entsprechend platzierte
	  <literal>divert natd</literal>-Regeln verarbeitet.  Die
	  notwendige Arbeit beschränkt sich darauf, alle
	  <quote>schlechten</quote> Pakete zu blockieren und nur
	  authorisierten Diensten zugehörige Pakete
	  durchzulassen.  In Umkehrung des bisherigen Beispiels nehmen
	  wir nun, dass auf dem Rechner, auf dem die Firewall läuft,
	  auch ein Apache Webserver läuft, auf den von außen,
	  also aus dem öffentlichen Internet, zugegriffen werden
	  kann.  Das erste von außen eintreffende Paket (das auch
	  eine neue Sitzung startet) erfüllt Regel 100.  Die
	  Zieladresse des Paketes wird daher auf die LAN-Adresse des
	  Firewallrechners abgebildet.  Das Paket wird dann weiter auf
	  alle in der Firewall definierten Regeln geprüft und trifft
	  schließlich auf Regel 425.  Durch diese Regel werden
	  zwei Aktionen ausgelösst:  Erstens wird aus dem Paket
	  eine dynamische Regel generiert und in die Zustandstabelle
	  geschrieben.  Zusätzlich wird jedoch die Anzahl neuer
	  Sitzungsanfragen (von der gleichen Quell-IP-Adresse) auf
	  <literal>2</literal> begrenzt, um so DoS-Angriffe auf Dienste,
	  die auf diesem Port laufen, zu verhindern.  Die Aktion dieser
	  Regel ist <literal>allow</literal>, daher wird das Paket
	  freigegeben und in das LAN weitergeleitet.  Das als Antwort
	  generierte Paket wird durch die
	  <literal>check-state</literal>-Regel als zu einer Sitzung
	  gehörend erkannt.  Damit wird es der Regel 500
	  zugeführt, <acronym>NAT</acronym> wird durchgeführt
	  und über die Schnittstelle zum öffentlichen Internet
	  nach außen geroutet.</para>

	<para>Beispiel 1 für einen Regelsatz:</para>

	<programlisting>#!/bin/sh
cmd="ipfw -q add"
skip="skipto 500"
pif=rl0
ks="keep-state"
good_tcpo="22,25,37,43,53,80,443,110,119"

ipfw -q -f flush

&dollar;cmd 002 allow all from any to any via xl0  # exclude LAN traffic
&dollar;cmd 003 allow all from any to any via lo0  # exclude loopback traffic

&dollar;cmd 100 divert natd ip from any to any in via &dollar;pif
&dollar;cmd 101 check-state

# Authorized outbound packets
&dollar;cmd 120 &dollar;skip udp from any to xx.168.240.2 53 out via &dollar;pif &dollar;ks
&dollar;cmd 121 &dollar;skip udp from any to xx.168.240.5 53 out via &dollar;pif &dollar;ks
&dollar;cmd 125 &dollar;skip tcp from any to any &dollar;good_tcpo out via &dollar;pif setup &dollar;ks
&dollar;cmd 130 &dollar;skip icmp from any to any out via &dollar;pif &dollar;ks
&dollar;cmd 135 &dollar;skip udp from any to any 123 out via &dollar;pif &dollar;ks


# Deny all inbound traffic from non-routable reserved address spaces
&dollar;cmd 300 deny all from 192.168.0.0/16  to any in via &dollar;pif  #RFC 1918 private IP
&dollar;cmd 301 deny all from 172.16.0.0/12   to any in via &dollar;pif  #RFC 1918 private IP
&dollar;cmd 302 deny all from 10.0.0.0/8      to any in via &dollar;pif  #RFC 1918 private IP
&dollar;cmd 303 deny all from 127.0.0.0/8     to any in via &dollar;pif  #loopback
&dollar;cmd 304 deny all from 0.0.0.0/8       to any in via &dollar;pif  #loopback
&dollar;cmd 305 deny all from 169.254.0.0/16  to any in via &dollar;pif  #DHCP auto-config
&dollar;cmd 306 deny all from 192.0.2.0/24    to any in via &dollar;pif  #reserved for docs
&dollar;cmd 307 deny all from 204.152.64.0/23 to any in via &dollar;pif  #Sun cluster
&dollar;cmd 308 deny all from 224.0.0.0/3     to any in via &dollar;pif  #Class D &amp; E multicast

# Authorized inbound packets
&dollar;cmd 400 allow udp from xx.70.207.54 to any 68 in &dollar;ks
&dollar;cmd 420 allow tcp from any to me 80 in via &dollar;pif setup limit src-addr 1


&dollar;cmd 450 deny log ip from any to any

# This is skipto location for outbound stateful rules
&dollar;cmd 500 divert natd ip from any to any out via &dollar;pif
&dollar;cmd 510 allow ip from any to any

######################## end of rules  ##################</programlisting>

	<para>Das folgende Beispiel ist praktisch identisch mit dem ersten
	  Regelsatz.  Allerdings wurden die Regel umfassend kommentiert und
	  umgeschrieben, damit sie für weniger erfahrene Benutzer
	  leichter verständlich werden.</para>

	<para>Beispiel 2 für einen Regelsatz:</para>

	<programlisting>#!/bin/sh
################ Start of IPFW rules file ###############################
# Flush out the list before we begin.
ipfw -q -f flush

# Set rules command prefix
cmd="ipfw -q add"
skip="skipto 800"
pif="rl0"     # public interface name of NIC
              # facing the public Internet

#################################################################
# No restrictions on Inside LAN Interface for private network
# Change xl0 to your LAN NIC interface name
#################################################################
&dollar;cmd 005 allow all from any to any via xl0

#################################################################
# No restrictions on Loopback Interface
#################################################################
&dollar;cmd 010 allow all from any to any via lo0

#################################################################
# check if packet is inbound and nat address if it is
#################################################################
&dollar;cmd 014 divert natd ip from any to any in via &dollar;pif

#################################################################
# Allow the packet through if it has previous been added to the
# the "dynamic" rules table by a allow keep-state statement.
#################################################################
&dollar;cmd 015 check-state

#################################################################
# Interface facing Public Internet (Outbound Section)
# Check session start requests originating from behind the
# firewall on the private network or from this gateway server
# destined for the public Internet.
#################################################################

# Allow out access to my ISP's Domain name server.
# x.x.x.x must be the IP address of your ISP's DNS
# Dup these lines if your ISP has more than one DNS server
# Get the IP addresses from /etc/resolv.conf file
&dollar;cmd 020 &dollar;skip tcp from any to x.x.x.x 53 out via &dollar;pif setup keep-state


# Allow out access to my ISP's DHCP server for cable/DSL configurations.
&dollar;cmd 030 &dollar;skip udp from any to x.x.x.x 67 out via &dollar;pif keep-state

# Allow out non-secure standard www function
&dollar;cmd 040 &dollar;skip tcp from any to any 80 out via &dollar;pif setup keep-state

# Allow out secure www function https over TLS SSL
&dollar;cmd 050 &dollar;skip tcp from any to any 443 out via &dollar;pif setup keep-state

# Allow out send &amp; get email function
&dollar;cmd 060 &dollar;skip tcp from any to any 25 out via &dollar;pif setup keep-state
&dollar;cmd 061 &dollar;skip tcp from any to any 110 out via &dollar;pif setup keep-state

# Allow out FreeBSD (make install &amp; CVSUP) functions
# Basically give user root "GOD" privileges.
&dollar;cmd 070 &dollar;skip tcp from me to any out via &dollar;pif setup keep-state uid root

# Allow out ping
&dollar;cmd 080 &dollar;skip icmp from any to any out via &dollar;pif keep-state

# Allow out Time
&dollar;cmd 090 &dollar;skip tcp from any to any 37 out via &dollar;pif setup keep-state

# Allow out nntp news (i.e. news groups)
&dollar;cmd 100 &dollar;skip tcp from any to any 119 out via &dollar;pif setup keep-state

# Allow out secure FTP, Telnet, and SCP
# This function is using SSH (secure shell)
&dollar;cmd 110 &dollar;skip tcp from any to any 22 out via &dollar;pif setup keep-state

# Allow out whois
&dollar;cmd 120 &dollar;skip tcp from any to any 43 out via &dollar;pif setup keep-state

# Allow ntp time server
&dollar;cmd 130 &dollar;skip udp from any to any 123 out via &dollar;pif keep-state

#################################################################
# Interface facing Public Internet (Inbound Section)
# Check packets originating from the public Internet
# destined for this gateway server or the private network.
#################################################################

# Deny all inbound traffic from non-routable reserved address spaces
&dollar;cmd 300 deny all from 192.168.0.0/16  to any in via &dollar;pif  #RFC 1918 private IP
&dollar;cmd 301 deny all from 172.16.0.0/12   to any in via &dollar;pif  #RFC 1918 private IP
&dollar;cmd 302 deny all from 10.0.0.0/8      to any in via &dollar;pif  #RFC 1918 private IP
&dollar;cmd 303 deny all from 127.0.0.0/8     to any in via &dollar;pif  #loopback
&dollar;cmd 304 deny all from 0.0.0.0/8       to any in via &dollar;pif  #loopback
&dollar;cmd 305 deny all from 169.254.0.0/16  to any in via &dollar;pif  #DHCP auto-config
&dollar;cmd 306 deny all from 192.0.2.0/24    to any in via &dollar;pif  #reserved for docs
&dollar;cmd 307 deny all from 204.152.64.0/23 to any in via &dollar;pif  #Sun cluster
&dollar;cmd 308 deny all from 224.0.0.0/3     to any in via &dollar;pif  #Class D &amp; E multicast

# Deny ident
&dollar;cmd 315 deny tcp from any to any 113 in via &dollar;pif

# Deny all Netbios service. 137=name, 138=datagram, 139=session
# Netbios is MS/Windows sharing services.
# Block MS/Windows hosts2 name server requests 81
&dollar;cmd 320 deny tcp from any to any 137 in via &dollar;pif
&dollar;cmd 321 deny tcp from any to any 138 in via &dollar;pif
&dollar;cmd 322 deny tcp from any to any 139 in via &dollar;pif
&dollar;cmd 323 deny tcp from any to any 81  in via &dollar;pif

# Deny any late arriving packets
&dollar;cmd 330 deny all from any to any frag in via &dollar;pif

# Deny ACK packets that did not match the dynamic rule table
&dollar;cmd 332 deny tcp from any to any established in via &dollar;pif

# Allow traffic in from ISP's DHCP server. This rule must contain
# the IP address of your ISP's DHCP server as it's the only
# authorized source to send this packet type.
# Only necessary for cable or DSL configurations.
# This rule is not needed for 'user ppp' type connection to
# the public Internet. This is the same IP address you captured
# and used in the outbound section.
&dollar;cmd 360 allow udp from x.x.x.x to any 68 in via &dollar;pif keep-state

# Allow in standard www function because I have Apache server
&dollar;cmd 370 allow tcp from any to me 80 in via &dollar;pif setup limit src-addr 2

# Allow in secure FTP, Telnet, and SCP from public Internet
&dollar;cmd 380 allow tcp from any to me 22 in via &dollar;pif setup limit src-addr 2

# Allow in non-secure Telnet session from public Internet
# labeled non-secure because ID &amp; PW are passed over public
# Internet as clear text.
# Delete this sample group if you do not have telnet server enabled.
&dollar;cmd 390 allow tcp from any to me 23 in via &dollar;pif setup limit src-addr 2

# Reject &amp; Log all unauthorized incoming connections from the public Internet
&dollar;cmd 400 deny log all from any to any in via &dollar;pif

# Reject &amp; Log all unauthorized out going connections to the public Internet
&dollar;cmd 450 deny log all from any to any out via &dollar;pif

# This is skipto location for outbound stateful rules
&dollar;cmd 800 divert natd ip from any to any out via &dollar;pif
&dollar;cmd 801 allow ip from any to any

# Everything else is denied by default
# deny and log all packets that fell through to see what they are
&dollar;cmd 999 deny log all from any to any
################ End of IPFW rules file ###############################</programlisting>
      </sect3>
    </sect2>
  </sect1>

</chapter>
