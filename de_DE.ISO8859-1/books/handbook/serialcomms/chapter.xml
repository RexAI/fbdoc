<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/serialcomms/chapter.xml,v 1.89 2012/04/30 16:20:14 bcr Exp $
     basiert auf: 1.139
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="serialcomms">
  <info><title>Serielle Datenübertragung</title>
    <authorgroup>
      <author><personname><firstname>Martin</firstname><surname>Heinen</surname></personname><contrib>Übersetzt von </contrib></author>
    </authorgroup>
  </info>

  

  <sect1 xml:id="serial-synopsis">
    <title>Übersicht</title>

    <indexterm><primary>serielle Datenübertragung</primary></indexterm>
    <para>&unix; Systeme unterstützten schon immer die serielle
      Datenübertragung.  Tatsächlich wurden Ein- und Ausgaben auf
      den ersten &unix; Maschinen über serielle Leitungen
      durchgeführt.  Seit der Zeit, in der ein durchschnittlicher
      <quote>Terminal</quote> aus einem seriellen Drucker mit
      10&nbsp;Zeichen/Sekunde und einer Tastatur bestand, hat sich viel
      verändert.  Dieses Kapitel behandelt einige Möglichkeiten,
      serielle Datenübertragung unter FreeBSD zu verwenden.</para>

    <para>Nachdem Sie dieses Kapitel durchgearbeitet haben, werden
      Sie Folgendes wissen:</para>
    <itemizedlist>
      <listitem><para>Wie Sie Terminals an Ihr FreeBSD anschließen.
	</para></listitem>
      <listitem><para>Wie Sie sich mit einem Modem auf einem entfernten
        Rechner einwählen.</para></listitem>
      <listitem><para>Wie Sie entfernten Benutzern erlauben, sich mit einem
        Modem in Ihr System einzuwählen.</para></listitem>
      <listitem><para>Wie Sie Ihr System über eine serielle Konsole
        booten.</para></listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>
    <itemizedlist>
      <listitem><para>einen neuen Kernel konfigurieren und installieren
        können (<xref linkend="kernelconfig"/>).</para></listitem>
      <listitem><para>Das Berechtigungskonzept von &unix; und Prozesse
        verstehen (<xref linkend="basics"/>).</para></listitem>
      <listitem><para>Zudem sollten Sie Zugriff auf die Handbücher der
        seriellen Komponenten (Modem oder Multiportkarte) haben, die Sie
	mit FreeBSD verwenden wollen.</para></listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="serial">
    <title>Einführung</title>

    <warning>
      <para>Mit &os;&nbsp;8.0 wurden die Gerätedateien für
	serielle Ports von
	<filename>/dev/ttydN</filename> in
	<filename>/dev/ttyuN</filename>
	umbenannt.  Setzen Sie noch &os;&nbsp;7.X ein, müssen
	Sie die Befehle in den folgenden Abschnitten entsprechend
	anpassen.</para>
    </warning>

    <!-- XXX Write me! -->

    <sect2 xml:id="serial-terminology">
      <title>Begriffe</title>

      <variablelist>
        <indexterm><primary>bits-per-second</primary></indexterm>
	<varlistentry>
	  <term>bps</term>
	  <listitem>
	    <para>Bits pro Sekunde &ndash; Einheit für die
	      Übertragungsgeschwindigkeit.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>DEE (DTE)</term>

	  <listitem>
	    <indexterm><primary>DEE</primary></indexterm>
	    <indexterm><primary>DTE</primary></indexterm>

	    <para>Datenendeinrichtung (Data Terminal Equipment) &ndash;
	      zum Beispiel Ihr Computer.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>DÜE (DCE)</term>

	  <listitem>
	    <indexterm><primary>DÜE</primary></indexterm>
	    <indexterm><primary>DCE</primary></indexterm>

	    <para>Datenübertragungseinrichtung (Data Communications
	      Equipment) &ndash;  Ein Modem.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>RS-232</term>

	  <listitem>
	    <indexterm><primary>RS-232C Kabel</primary></indexterm>

	    <para>EIA (Electronic Industries Association) Norm für
	      die serielle Datenübertragung.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>In diesem Abschnitt wird der Begriff <quote>Baud</quote> nicht
        für Übertragungsgeschwindigkeiten gebraucht.  Baud
	bezeichnet elektrische Zustandswechsel pro Zeiteinheit, die Taktfrequenz,
	während <quote>bps</quote> (Bits pro Sekunde) der
	<emphasis>richtige</emphasis> Begriff für die
	Übertragungsgeschwindigkeit ist (die meisten Pedanten sollten
	damit zufrieden sein).</para>
    </sect2>

    <sect2 xml:id="serial-cables-ports">
      <title>Kabel und Schnittstellen</title>

      <para>Um ein Modem oder einen Terminal an Ihr FreeBSD-System
        anzuschließen, muss Ihr Computer über eine serielle
	Schnittstelle verfügen.  Zusätzlich brauchen Sie noch das
	passende Kabel, um das Gerät mit der Schnittstelle zu
	verbinden.  Wenn Sie mit Ihren Geräten und den nötigen
	Kabeln schon vertraut sind, können Sie diesen Abschnitt
	überspringen.</para>

      <sect3 xml:id="term-cables">
	<title>Kabel</title>

	<para>Es gibt verschiedene serielle Kabel.  Die zwei häufigsten
	  sind Nullmodemkabel und Standard-RS-232-Kabel.  Die
	  Dokumentation Ihrer Hardware sollte beschreiben, welchen Kabeltyp
	  Sie benötigen.</para>

	<sect4 xml:id="term-cables-null">
	  <title>Nullmodemkabel</title>

	  <indexterm>
	    <primary>Nullmodemkabel</primary>
	  </indexterm>
	  <para>Ein Nullmodemkabel verbindet einige Signale, wie die
	    Betriebserde, eins zu eins, andere Signale werden getauscht:
	    Die Sende- und Empfangsleitungen werden zum Beispiel
	    gekreuzt.</para>

	  <para>Sie können das Kabel für die Anbindung eines
	    Terminals auch selbst herstellen.  Die folgende Tabelle
	    enthält die <link linkend="serialcomms-signal-names">Signalnamen</link> von
	    RS-232C sowie die Pinbelegung für einen Stecker vom
	    Typ DB-25.  Beachten Sie dabei aber, dass der Standard
	    zwar eine direkte Verbindung beider Pin 1
	    (<emphasis>Protective Ground</emphasis>) vorschreibt, diese
	    aber in vielen Fällen nicht vorhanden ist.  Einige
	    Terminals benötigen nur die Pins 2, 3 und 7 für
	    eine korrekte Funktion, während andere eine
	    unterschiedliche Konfiguration als die in den folgenden
	    Beispielen gezeigte benötigen.</para>

	  <table frame="none" pgwide="1">
	    <title>Nullmodemkabel vom Typ DB-25-zu-DB-25</title>

	    <tgroup cols="5">
	      <thead>
		<row>
		  <entry align="left">Signal</entry>
		  <entry align="left">Pin #</entry>
		  <entry align="left"/>
		  <entry align="left">Pin #</entry>
		  <entry align="left">Signal</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>SG</entry>
		  <entry>7</entry>
		  <entry>verbunden mit</entry>
		  <entry>7</entry>
		  <entry>SG</entry>
		</row>

		<row>
		  <entry>TD</entry>
		  <entry>2</entry>
		  <entry>verbunden mit</entry>
		  <entry>3</entry>
		  <entry>RD</entry>
		</row>

		<row>
		  <entry>RD</entry>
		  <entry>3</entry>
		  <entry>verbunden mit</entry>
		  <entry>2</entry>
		  <entry>TD</entry>
		</row>

		<row>
		  <entry>RTS</entry>
		  <entry>4</entry>
		  <entry>verbunden mit</entry>
		  <entry>5</entry>
		  <entry>CTS</entry>
		</row>

		<row>
		  <entry>CTS</entry>
		  <entry>5</entry>
		  <entry>verbunden mit</entry>
		  <entry>4</entry>
		  <entry>RTS</entry>
		</row>

		<row>
		  <entry>DTR</entry>
		  <entry>20</entry>
		  <entry>verbunden mit</entry>
		  <entry>6</entry>
		  <entry>DSR</entry>
		</row>

		<row>
		  <entry>DTR</entry>
		  <entry>20</entry>
		  <entry>verbunden mit</entry>
		  <entry>8</entry>
		  <entry>DCD</entry>
		</row>

		<row>
		  <entry>DSR</entry>
		  <entry>6</entry>
		  <entry>verbunden mit</entry>
		  <entry>20</entry>
		  <entry>DTR</entry>
		</row>

		<row>
		  <entry>DCD</entry>
		  <entry>8</entry>
		  <entry>verbunden mit</entry>
		  <entry>20</entry>
		  <entry>DTR</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>

	  <para>Die folgenden zwei Schemata werden heutzutage ebenfalls
	    häufig eingesetzt:</para>

          <table frame="none" pgwide="1">
            <title>Nullmodemkabel vom Typ DB-9-zu-DB-9</title>

            <tgroup cols="5">
              <thead>
                <row>
                  <entry align="left">Signal</entry>
                  <entry align="left">Pin #</entry>
                  <entry align="left"/>
                  <entry align="left">Pin #</entry>
                  <entry align="left">Signal</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>RD</entry>
                  <entry>2</entry>
                  <entry>verbunden mit</entry>
                  <entry>3</entry>
                  <entry>TD</entry>
                </row>

                <row>
                  <entry>TD</entry>
                  <entry>3</entry>
                  <entry>verbunden mit</entry>
                  <entry>2</entry>
                  <entry>RD</entry>
                </row>

                <row>
                  <entry>DTR</entry>
                  <entry>4</entry>
                  <entry>verbunden mit</entry>
                  <entry>6</entry>
                  <entry>DSR</entry>
                </row>

                <row>
                  <entry>DTR</entry>
                  <entry>4</entry>
                  <entry>verbunden mit</entry>
                  <entry>1</entry>
                  <entry>DCD</entry>
                </row>

                <row>
                  <entry>SG</entry>
                  <entry>5</entry>
                  <entry>verbunden mit</entry>
                  <entry>5</entry>
                  <entry>SG</entry>
                </row>

                <row>
                  <entry>DSR</entry>
                  <entry>6</entry>
                  <entry>verbunden mit</entry>
                  <entry>4</entry>
                  <entry>DTR</entry>
                </row>

                <row>
                  <entry>DCD</entry>
                  <entry>1</entry>
                  <entry>verbunden mit</entry>
                  <entry>4</entry>
                  <entry>DTR</entry>
                </row>

                <row>
                  <entry>RTS</entry>
                  <entry>7</entry>
                  <entry>verbunden mit</entry>
                  <entry>8</entry>
                  <entry>CTS</entry>
                </row>

                <row>
                  <entry>CTS</entry>
                  <entry>8</entry>
                  <entry>verbunden mit</entry>
                  <entry>7</entry>
                  <entry>RTS</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <table frame="none" pgwide="1">
            <title>Nullmodemkabel vom Typ DB-9-zu-DB-25</title>

            <tgroup cols="5">
              <thead>
                <row>
                  <entry align="left">Signal</entry>
                  <entry align="left">Pin #</entry>
                  <entry align="left"/>
                  <entry align="left">Pin #</entry>
                  <entry align="left">Signal</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>RD</entry>
                  <entry>2</entry>
                  <entry>verbunden mit</entry>
                  <entry>2</entry>
                  <entry>TD</entry>
                </row>

                <row>
                  <entry>TD</entry>
                  <entry>3</entry>
                  <entry>verbunden mit</entry>
                  <entry>3</entry>
                  <entry>RD</entry>
                </row>

                <row>
                  <entry>DTR</entry>
                  <entry>4</entry>
                  <entry>verbunden mit</entry>
                  <entry>6</entry>
                  <entry>DSR</entry>
                </row>

                <row>
                  <entry>DTR</entry>
                  <entry>4</entry>
                  <entry>verbunden mit</entry>
                  <entry>8</entry>
                  <entry>DCD</entry>
                </row>

                <row>
                  <entry>SG</entry>
                  <entry>5</entry>
                  <entry>verbunden mit</entry>
                  <entry>7</entry>
                  <entry>SG</entry>
                </row>

                <row>
                  <entry>DSR</entry>
                  <entry>6</entry>
                  <entry>verbunden mit</entry>
                  <entry>20</entry>
                  <entry>DTR</entry>
                </row>

                <row>
                  <entry>DCD</entry>
                  <entry>1</entry>
                  <entry>verbunden mit</entry>
                  <entry>20</entry>
                  <entry>DTR</entry>
                </row>

                <row>
                  <entry>RTS</entry>
                  <entry>7</entry>
                  <entry>verbunden mit</entry>
                  <entry>5</entry>
                  <entry>CTS</entry>
                </row>

                <row>
                  <entry>CTS</entry>
                  <entry>8</entry>
                  <entry>verbunden mit</entry>
                  <entry>4</entry>
                  <entry>RTS</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

	  <note>
	    <para>Wird ein Pin eines Kabels mit zwei Pins des anderen
	      Kabels verbunden, werden dazu in der Regel zuerst die
	      beiden Pins mit einem kurzem Draht verbunden.  Danach
	      wird dieser Draht mit dem Pin des anderen Endes
	      verbunden.</para>
	  </note>

	  <para>Die eben besprochenen Schemata scheinen die beliebtesten
	    zu sein.  Es gibt aber noch weitere Varianten.  Im Buch
	    <emphasis>RS-232 Made Easy</emphasis> wird beispielsweise
	    SG mit SG verbunden, TD mit RD, RTS und CTS mit DCD, DTR
	    mit DSR, und umgekehrt.</para>
	</sect4>

	<sect4 xml:id="term-cables-std">
	  <title>Standard RS-232C Kabel</title>
	  <indexterm><primary>RS-232C Kabel</primary></indexterm>

	  <para>Ein Standard-RS-232C-Kabel verbindet alle Signale direkt,
	    das heißt das Signal <quote>Transmitted Data</quote> wird mit
	    dem Signal <quote>Transmitted Data</quote> der Gegenstelle verbunden.
	    Dieses Kabel wird benötigt, um ein Modem mit einem
	    FreeBSD-System zu verbinden.  Manche Terminals benötigen dieses
	    Kabel ebenfalls.</para>
	</sect4>
      </sect3>

      <sect3 xml:id="term-ports">
	<title>Schnittstellen</title>

	<para>Über serielle Schnittstellen werden Daten zwischen dem
	  FreeBSD-System und dem Terminal übertragen.  Dieser
	  Abschnitt beschreibt die verschiedenen Schnittstellen und wie sie
	  unter FreeBSD angesprochen werden.</para>

	<sect4 xml:id="term-portkinds">
	  <title>Arten von Schnittstellen</title>

	  <para>Da es verschiedene Schnittstellen gibt, sollten Sie vor
	    dem Kauf oder Selbstbau eines Kabels sicherstellen, dass
	    dieses zu den Schnittstellen Ihres Terminals und
	    FreeBSD-Systems passt.</para>

	  <para>Die meisten Terminals besitzen DB-25-Stecker.
	    Personal Computer haben DB-25- oder DB-9-Stecker.  Wenn
	    Sie eine serielle Multiportkarte für Ihren PC besitzen,
	    haben Sie vielleicht RJ-12- oder RJ-45-Anschlüsse.</para>

	  <para>Die Dokumentation Ihrer Geräte sollte Aufschluss
	    über den Typ der benötigten Anschlüsse geben.
	    Oft hilft es, wenn Sie sich den Anschluss einfach
	    ansehen.</para>
	</sect4>

	<sect4 xml:id="term-portnames">
	  <title>Schnittstellenbezeichnung</title>

	  <para>Unter FreeBSD sprechen Sie die serielle Schnittstelle
	    (Port) über einen Eintrag im <filename>/dev</filename>
	    Verzeichnis an.  Es gibt dort zwei verschiedene
	    Einträge:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Schnittstellen für eingehende Verbindungen werden
	        <filename>/dev/ttyuN</filename>
		genannt.  Dabei ist <replaceable>N</replaceable> die Nummer
		der Schnittstelle, deren Zählung bei Null beginnt.
		Allgemein wird diese Schnittstelle für Terminals
		benutzt.  Diese Schnittstelle funktioniert nur, wenn ein
		<quote>Data Carrier Detect</quote> Signal (DCD)
		vorliegt.</para>
	    </listitem>

	    <listitem>
	      <para>Für ausgehende Verbindungen wird
	        <filename>/dev/cuadN</filename>
		verwendet.  Dieser Port wird normalerweise nur von
		Modems genutzt.  Sie können ihn allerdings für
		Terminals benutzen, die das <quote>Data Carrier Detect</quote>
		Signal nicht unterstützen.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Wenn Sie einen Terminal an die erste serielle Schnittstelle
	    (<filename>COM1</filename> in &ms-dos;), angeschlossen haben,
	    sprechen Sie ihn über <filename>/dev/ttyu0</filename> an.
	    Wenn er an der zweiten seriellen Schnittstelle angeschlossen
	    ist, verwenden Sie <filename>/dev/ttyu1</filename>, usw.</para>

	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Kernelkonfiguration</title>

      <para>In der Voreinstellung benutzt FreeBSD vier serielle
        Schnittstellen, die in &ms-dos;-Kreisen als
	<filename>COM1</filename>, <filename>COM2</filename>,
	<filename>COM3</filename> und <filename>COM4</filename>
	bekannt sind.  Momentan unterstützt FreeBSD einfache
	Multiportkarten (z.B. die BocaBoard 1008 und 2016) und bessere wie
	die von Digiboard und Stallion Technologies.  In der Voreinstellung
	sucht der Kernel allerdings nur nach den
	Standardanschlüssen.</para>

      <para>Um zu überprüfen, ob der Kernel eine Ihrer seriellen
        Schnittstellen erkennt, achten Sie auf die Meldungen beim Booten,
	oder schauen sich diese später mit
	<command>/sbin/dmesg</command> an.  Insbesondere sollten Sie auf
	Meldungen achten, die mit den Zeichen <literal>sio</literal>
	anfangen.</para>

      <tip><para>Das folgende Kommando zeigt Ihnen nur die Meldungen an,
        die die Folge <literal>sio</literal> enthalten:</para>

      <screen>&prompt.root; <userinput>/sbin/dmesg | grep 'sio'</userinput></screen>
      </tip>

      <para>Auf einem System mit vier seriellen Schnittstellen sollte der
        Kernel die folgenden Meldungen ausgeben:</para>

      <screen>sio0 at 0x3f8-0x3ff irq 4 on isa
sio0: type 16550A
sio1 at 0x2f8-0x2ff irq 3 on isa
sio1: type 16550A
sio2 at 0x3e8-0x3ef irq 5 on isa
sio2: type 16550A
sio3 at 0x2e8-0x2ef irq 9 on isa
sio3: type 16550A</screen>

      <para>Wenn Ihr Kernel nicht alle seriellen Schnittstellen erkennt,
	müssen Sie Ihren Kernel über die Datei
	<filename>/boot/device.hints</filename> konfigurieren.
	Zusätzlich können Sie Einträge für
	Geräte, die auf Ihrem System nicht vorhanden sind, aus dem
	Kernel entfernen.</para>

      <para>Die Hilfeseite &man.sio.4; enthält weitere Informationen
	zu seriellen Schnittstellen und Multiportkarten.
	Seien Sie vorsichtig, wenn Sie Konfigurationsdateien
	von älteren FreeBSD-Versionen verwenden, da sich die Syntax
	und die Bedeutung der Optionen zwischen verschiedenen
	Versionen geändert hat.</para>

      <note>
	<para><literal>port IO_COM1</literal> ist ein Ersatz für
	  <literal>port 0x3f8</literal>, <literal>IO_COM2</literal>
	  bedeutet <literal>port 0x2f8</literal>, <literal>IO_COM3</literal>
	  bedeutet <literal>port 0x3e8</literal> und <literal>IO_COM4</literal>
	  steht für <literal>port 0x2e8</literal>.  Die angegebenen
	  IO-Adressen sind genau wie die Interrupts 4, 3, 5 und 9
	  üblich für serielle Schnittstellen.  Beachten Sie
	  bitte, dass sich normale serielle Schnittstellen auf ISA-Bussen
	  <emphasis>keine</emphasis> Interrupts teilen können.
	  Multiportkarten besitzen zusätzliche Schaltkreise, die es
	  allen 16550As auf der Karte erlauben, sich einen oder zwei
	  Interrupts zu teilen.</para>
      </note>

    </sect2>

    <sect2>
      <title>Gerätedateien</title>

      <para>Die meisten Geräte im Kernel werden durch
        Gerätedateien in <filename>/dev</filename> angesprochen.  Die
	<filename>sio</filename> Geräte werden durch
	<filename>/dev/ttyuN</filename>
	für eingehende Verbindungen und durch
	<filename>/dev/cuadN</filename> für
	ausgehende Verbindungen angesprochen.  Zum Initialisieren der
	Geräte stellt FreeBSD die Dateien
	<filename>/dev/ttyuN.init</filename> und
	<filename>/dev/cuadN.init</filename>
	zur Verfügung.
	Zusätzlich existieren Dateien für das Sperren von
	Gerätedateien (<foreignphrase>Locking</foreignphrase>).
	Dabei handelt es sich um die Dateien
	<filename>/dev/ttyuN.lock</filename>
	und
	<filename>/dev/cuadN.lock</filename>.
	Diese Dateien werden benutzt, um Kommunikationsparameter beim
	Öffnen eines Ports vorzugeben.  Für Modems, die zur
	Flusskontrolle <literal>RTS/CTS</literal> benutzen, kann damit
	<literal>crtscts</literal> gesetzt werden.  Die Geräte
	<filename>/dev/ttyldN</filename> und
	<filename>/dev/cualaN</filename> (locking
	devices) werden genutzt, um bestimmte Parameter festzuschreiben und
	vor Veränderungen zu schützen.  Weitere Informationen
	zu Terminals finden Sie in &man.termios.4;, &man.sio.4; erklärt
	die Dateien zum Initialisieren und Sperren der Geräte,
	&man.stty.1; beschreibt schließlich
	Terminal-Einstellungen.</para>
    </sect2>

    <sect2 xml:id="serial-hw-config">
      <title>Konfiguration der seriellen Schnittstelle</title>

    <indexterm><primary><filename>ttyu</filename></primary></indexterm>
    <indexterm><primary><filename>cuad</filename></primary></indexterm>

    <para>Anwendungen benutzen normalerweise die Geräte
      <filename>ttyuN</filename> oder
      <filename>cuadN</filename>.  Das
      Gerät besitzt einige Voreinstellungen für Terminal-I/O,
      wenn es von einem Prozess geöffnet wird.  Mit dem folgenden
      Kommando können Sie sich diese Einstellungen ansehen:</para>

    <screen>&prompt.root; <userinput>stty -a -f /dev/ttyu1</userinput></screen>

    <para>Sie können diese Einstellungen verändern, sie bleiben
      allerdings nur solange wirksam, bis das Gerät geschlossen wird.
      Wenn das Gerät danach wieder geöffnet wird, sind die
      Voreinstellungen wieder wirksam.  Um die Voreinstellungen zu
      ändern, öffnen Sie das Gerät, das zum Initialisieren
      dient und verändern dessen Einstellungen.  Um beispielsweise
      für <filename>ttyu5</filename> den <option>CLOCAL</option>
      Modus, 8-Bit Kommunikation und <option>XON/XOFF</option>
      Flusssteuerung einzuschalten, setzen Sie das folgende
      Kommando ab:</para>

    <screen>&prompt.root; <userinput>stty -f /dev/ttyu5.init clocal cs8 ixon ixoff</userinput></screen>

    <indexterm>
      <primary>rc-Dateien</primary>
      <secondary><filename>rc.serial</filename></secondary>
    </indexterm>

    <para>In <filename>/etc/rc.d/rc.serial</filename> werden die
      systemweiten Voreinstellungen für serielle Geräte
      vorgenommen.</para>

    <para>Um zu verhindern, dass Einstellungen von Anwendungen
      verändert werden, können Sie die Geräte zum
      Festschreiben von Einstellungen (<quote>locking devices</quote>)
      benutzen.  Wenn sie beispielsweise die Geschwindigkeit von
      <filename>ttyu5</filename> auf 57600&nbsp;bps festlegen wollen,
      benutzen Sie das folgende Kommando:</para>

    <screen>&prompt.root; <userinput>stty -f /dev/ttyld5 57600</userinput></screen>

    <para>Eine Anwendung, die <filename>ttyu5</filename> öffnet,
      kann nun nicht mehr die Geschwindigkeit ändern und muss
      57600&nbsp;bps benutzen.</para>

    <para>Die Geräte zum Initialisieren und Festschreiben von
      Einstellungen sollten selbstverständlich nur von
      <systemitem class="username">root</systemitem> beschreibbar sein.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="term">
    <info><title>Terminals</title>
      <authorgroup>
        <author><personname><firstname>Sean</firstname><surname>Kelly</surname></personname><contrib>Beigetragen von </contrib></author>
	<!-- 28 July 1996 -->
      </authorgroup>
    </info>
    

    <warning>
      <para>Mit &os;&nbsp;8.0 wurden die Gerätedateien für
	serielle Ports von
	<filename>/dev/ttydN</filename> in
	<filename>/dev/ttyuN</filename>
	umbenannt.  Setzen Sie noch &os;&nbsp;7.X ein, müssen
	Sie die Befehle in den folgenden Abschnitten entsprechend
	anpassen.</para>
    </warning>

    <indexterm><primary>Terminals</primary></indexterm>

    <para>Wenn Sie sich nicht an der Konsole oder über ein Netzwerk an
      Ihrem FreeBSD-System anmelden können, sind Terminals ein
      bequemer und billiger Weg auf Ihr System zuzugreifen.  Dieser
      Abschnitt beschreibt wie Sie Terminals mit FreeBSD benutzen.</para>

    <sect2 xml:id="term-uses">
      <title>Terminaltypen</title>

      <para>Das ursprüngliche &unix; System besaß keine Konsolen.
	Zum Anmelden und Starten von Programmen wurden stattdessen
	Terminals benutzt, die an den seriellen Schnittstellen des Rechners
	angeschlossen waren.  Dies entspricht der Benutzung eines Modems
	zum Anmelden auf einem entfernten System, um dort mit einem
	Terminalemulator im Textmodus zu arbeiten.</para>

      <para>Die Konsolen heutiger PCs besitzen sehr gute
	Grafikfähigkeiten, trotzdem gibt es in fast jedem &unix; System
	die Möglichkeit, sich über die serielle Schnittstelle
	anzumelden; FreeBSD ist da keine Ausnahme.  Sie können sich an
	einem Terminal anmelden und dort jedes Textprogramm, das Sie
	normalerweise an der Konsole oder in einem <command>xterm</command>
	Fenster im X Window System benutzen, laufen lassen.</para>

      <para>Im kommerziellen Umfeld können Sie viele Terminals an ein
        FreeBSD-System anschließen und diese auf den
	Arbeitsplätzen Ihrer Angestellten aufstellen.  Im privaten
	Umfeld kann ein älterer IBM PC oder &macintosh; als Terminal
	dienen.  Damit verwandeln Sie einen Einzelarbeitsplatz in ein
	leistungsfähiges Mehrbenutzersystem.</para>

      <para>FreeBSD kennt drei verschiedene Terminals:</para>

      <itemizedlist>
	<listitem>
	  <para><link linkend="term-dumb">Dumb terminals,</link></para>
	</listitem>

	<listitem>
	  <para><link linkend="term-pcs">PCs, die als Terminals
	    fungieren,</link></para>
	</listitem>

	<listitem>
	  <para><link linkend="term-x">X Terminals.</link></para>
	</listitem>
      </itemizedlist>

      <para>Die folgenden Abschnitte beschreiben jeden dieser Terminals.</para>

      <sect3 xml:id="term-dumb">
	<title>Dumb-Terminals</title>

	<para>Dumb-Terminals (unintelligente Datenstationen) sind
	  Geräte, die über die serielle Schnittstelle mit einem
	  Rechner verbunden werden.  Sie werden
	  <quote>unintelligent</quote> genannt, weil sie nur Text senden
	  und empfangen und keine Programme laufen lassen können.
	  Alle Programme, wie Texteditoren, Compiler oder Spiele befinden
	  sich auf dem Rechner, der mit dem Terminal verbunden ist.</para>

	<para>Es gibt viele Dumb-Terminals, die von verschiedenen
	  Herstellern produziert werden, wie zum Beispiel der VT-100 von
	  Digital Equipment Corporation oder der WY-75 von Wyse.  So gut
	  wie jeder der verschiedenen Terminals sollte mit FreeBSD
	  zusammenarbeiten.  Manche High-End Geräte verfügen
	  sogar über Grafikfähigkeiten, die allerdings nur von
	  spezieller Software genutzt werden kann.</para>

	<para>Dumb-Terminals sind in Umgebungen beliebt, in denen keine
	  Grafikanwendungen, wie zum Beispiel X-Programme, laufen
	  müssen.</para>
      </sect3>

      <sect3 xml:id="term-pcs">
	<title>PCs, die als Terminal fungieren</title>

	<para>Jeder PC kann die Funktion eines <link linkend="term-dumb">
	    Dumb-Terminals</link>, der ja nur
	  Text senden und empfangen kann, übernehmen.  Dazu brauchen
	  Sie nur das richtige Kabel und eine
	  <emphasis>Terminalemulation</emphasis>, die auf dem PC
	  läuft.</para>

	<para>Diese Konfiguration ist im privaten Umfeld sehr beliebt.  Wenn
	  Ihr Ehepartner zum Beispiel gerade an der FreeBSD-Konsole arbeitet,
	  können Sie einen weniger leistungsstarken PC, der als
	  Terminal mit dem FreeBSD-System verbunden ist, benutzen, um dort
	  gleichzeitig im Textmodus zu arbeiten.</para>

	<para>Bereits im Basissystem sind mindestens zwei Werkzeuge
	  vorhanden, die Sie zur Arbeit über eine serielle Konsole
	  einsetzen können:  &man.cu.1; sowie &man.tip.1;.</para>

	<para>Um sich von einem &os;-System aus über eine serielle
	  Verbindung mit einem anderen System zu verbinden, geben Sie
	  folgenden Befehl ein:</para>

	<screen>&prompt.root; <userinput>cu -l serial-port-device</userinput></screen>

	<para><quote>serial-port-device</quote> ist hier der Name der
	  Gerätedatei, die einer bestimmten seriellen Schnittstelle
	  Ihres Systems zugewiesen ist.  Diese Gerätedateien werden
	  <filename>/dev/cuadN</filename>
	  genannt.</para>

	<para>Der Buchstabe <quote>N</quote> muss dabei durch die Nummer
	  des seriellen Ports Ihres Systems ersetzt werden.</para>

	<note>
	  <para>Beachten Sie, dass die Numerierung dieses Daten (im
	    Gegensatz etwa zu &ms-dos;-kompatiblen Systemen) unter &os;
	    mit Null und nicht mit Eins beginnt.  Die Schnittstelle
	    <quote>COM1</quote> entspricht daher in der Regel
	    <filename>/dev/cuad0</filename> unter &os;.</para>
	</note>

	<note>
	  <para>In der Ports-Sammlung finden sich weitere Programme
	    (beispielsweise <package>comms/minicom</package>), mit denen Sie
	    eine Verbindung über eine serielle Schnittstelle
	    herstellen können.</para>
	</note>
      </sect3>

      <sect3 xml:id="term-x">
	<title>X-Terminals</title>

	<para>X-Terminals sind die ausgereiftesten der verfügbaren
	  Terminals.  Sie werden nicht mit der seriellen Schnittstelle
	  sondern mit einem Netzwerk, wie dem Ethernet, verbunden.  Diese
	  Terminals sind auch nicht auf den Textmodus beschränkt,
	  sondern können jede X-Anwendung darstellen.</para>

	<para>X-Terminals sind hier nur der Vollständigkeit halber
	  aufgezählt.  Die Einrichtung von X-Terminals wird in diesem
	  Abschnitt <emphasis>nicht</emphasis> beschrieben.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="term-config">
      <title>Konfiguration</title>

      <para>Im Folgenden wird beschrieben, wie Sie Ihr FreeBSD-System
        konfigurieren müssen, um sich an einem Terminal anzumelden.
	Dabei wird vorausgesetzt, dass der Kernel bereits die
	serielle Schnittstelle, die mit dem Terminal verbunden ist,
	unterstützt.  Weiterhin sollte der Terminal schon
	angeschlossen sein.</para>

      <para>Aus <xref linkend="boot"/> wissen Sie, dass
        <command>init</command> für das Initialisieren des Systems und
	den Start von Prozessen zum Zeitpunkt des Systemstarts
	verantwortlich ist.  Unter anderem liest <command>init</command>
	<filename>/etc/ttys</filename> ein und startet für jeden
	verfügbaren Terminal einen <command>getty</command>
	Prozess.  <command>getty</command> wiederum fragt beim
	Anmelden den Benutzernamen ab und startet
	<command>login</command>.</para>

      <para>Um Terminals auf Ihrem FreeBSD-System einzurichten, führen
        Sie folgenden Schritte als <systemitem class="username">root</systemitem> durch:</para>

      <procedure>
	<step>
	  <para>Wenn er noch nicht da ist, fügen Sie einen Eintrag in
	    <filename>/etc/ttys</filename> für die serielle
	    Schnittstelle aus <filename>/dev</filename> ein.</para>
	</step>

	<step>
	  <para>Geben Sie <command>/usr/libexec/getty</command> als
	    auszuführendes Programm an.  Als Parameter für
	    <command>getty</command> geben Sie den passenden Verbindungstyp
	    aus <filename>/etc/gettytab</filename> an.</para>
	</step>

	<step>
	  <para>Geben Sie den Terminaltyp an.</para>
	</step>

	<step>
	  <para>Aktivieren Sie den Anschluss.</para>
	</step>

	<step>
	  <para>Geben Sie die Sicherheit des Anschlusses an.</para>
	</step>

	<step>
	  <para>Veranlassen Sie <command>init</command>
	    <filename>/etc/ttys</filename> erneut zu lesen.</para>
	</step>
      </procedure>

      <para>Optional können Sie in <filename>/etc/gettytab</filename>
	auch einen auf Ihre Zwecke angepassten Terminaltyp erstellen.
	Die genaue Vorgehensweise wird in diesem Abschnitt nicht
	erklärt, aber die Manualpages von &man.gettytab.5; und
	&man.getty.8; enthalten dazu weitere Informationen.</para>

      <sect3 xml:id="term-etcttys">
	<title>Hinzufügen eines Eintrags in
	  <filename>/etc/ttys</filename></title>

	<para>In <filename>/etc/ttys</filename> werden alle Terminals
	  aufgeführt, an denen Sie sich auf dem FreeBSD-System
	  anmelden können.  Hier findet sich zum Beispiel ein Eintrag
	  für die erste virtuelle Konsole
	  <filename>/dev/ttyv0</filename>, der es Ihnen ermöglicht,
	  sich dort anzumelden.  Die Datei enthält des Weiteren
	  Einträge für andere virtuelle Konsolen, serielle
	  Schnittstellen und Pseudoterminals.  Wenn Sie einen Terminal
	  konfigurieren wollen, fügen sie einen Eintrag für den
	  Namen des Gerätes aus <filename>/dev</filename> ohne das
	  Präfix <filename>/dev</filename> hinzu.  Zum Beispiel wird
	  <filename>/dev/ttyv0</filename> als
	  <filename>ttyv0</filename> aufgeführt.</para>

	<para>In der Voreinstellung enthält
	  <filename>/etc/ttys</filename> Einträge für die ersten
	  vier seriellen Schnittstellen: <filename>ttyu0</filename> bis
	  <filename>ttyu3</filename>.  Wenn Sie an eine von diesen einen
	  Terminal anschließen, brauchen Sie keinen weiteren Eintrag
	  hinzuzufügen.</para>

	<example xml:id="ex-etc-ttys">
	  <title>Einträge in <filename>/etc/ttys</filename>
	    hinzufügen</title>

	  <para>Angenommen, wir wollen an ein System zwei Terminals
	    anschließen:  Einen Wyse-50 und einen alten 286 IBM PC,
	    der mit <application>Procomm</application> einen VT-100
	    Terminal emuliert.  Den Wyse-Terminal verbinden wir mit der
	    zweiten seriellen Schnittstelle und den 286 mit der sechsten
	    seriellen Schnittstelle (einem Anschluss auf einer
	    Multiportkarte).  Die entsprechenden Einträge in
	    <filename>/etc/ttys</filename> würden dann wie folgt
	    aussehen:</para>

	  <programlisting>ttyu1<co xml:id="co-ttys-line1col1"/>  "/usr/libexec/getty std.38400"<co xml:id="co-ttys-line1col2"/>  wy50<co xml:id="co-ttys-line1col3"/>  on<co xml:id="co-ttys-line1col4"/>  insecure<co xml:id="co-ttys-line1col5"/>
ttyu5   "/usr/libexec/getty std.19200"  vt100  on  insecure
	  </programlisting>

	  <calloutlist>
	    <callout arearefs="co-ttys-line1col1">
	      <para>Das erste Feld gibt normalerweise den Namen der
	        Gerätedatei aus <filename>/dev</filename> an.</para>
	    </callout>
	    <callout arearefs="co-ttys-line1col2">

	      <para>Im zweiten Feld wird das auszuführende Kommando,
	        normal ist das &man.getty.8;, angegeben.
		<command>getty</command> initialisiert und öffnet die
		Verbindung, setzt die Geschwindigkeit und fragt den
		Benutzernamen ab.  Danach führt es &man.login.1;
		aus.</para>

	      <para><command>getty</command> akzeptiert einen optionalen
	        Parameter auf der Kommandozeile, den Verbindungstyp, der
		die Eigenschaften der Verbindung, wie die Geschwindigkeit
		und Parität, festlegt.  Die Typen und die damit
		verbundenen Eigenschaften liest <command>getty</command>
		aus <filename>/etc/gettytab</filename>.</para>

	      <para><filename>/etc/gettytab</filename> enthält viele
	        Einträge sowohl für neue wie auch alte
		Terminalverbindungen.  Die meisten Einträge, die mit
		<literal>std</literal> beginnen, sollten mit einem
		festverdrahteten Terminal funktionieren.  Für jede
		Geschwindigkeit zwischen 110&nbsp;bps und 115200&nbsp;bps
		gibt es einen <literal>std</literal> Eintrag.  Natürlich
		können Sie auch eigene Einträge erstellen,
		Informationen dazu finden Sie in &man.gettytab.5;.</para>

	      <para>Wenn Sie den Verbindungstyp in
	        <filename>/etc/ttys</filename> eintragen, stellen Sie
		bitte sicher, dass die Kommunikationseinstellungen
		auch mit denen des Terminals übereinstimmen.</para>

	      <para>In unserem Beispiel verwendet der Wyse-50 keine
	        Parität und 38400&nbsp;bps, der 286 PC benutzt ebenfalls
		keine Parität und arbeitet mit 19200&nbsp;bps.</para>

	    </callout>

	    <callout arearefs="co-ttys-line1col3">

	      <para>Das dritte Feld gibt den Terminaltyp an, der
	        normalerweise mit diesem Anschluss verbunden ist.
		Für Einwählverbindungen wird oft
		<literal>unknown</literal> oder <literal>dialup</literal>
		benutzt, da sich die Benutzer praktisch mit beliebigen
		Terminals oder Emulatoren anmelden können.  Bei
		festverdrahteten Terminals ändert sich der Typ nicht,
		so dass Sie in diesem Feld einen richtigen Typ aus der
		&man.termcap.5; Datenbank angeben können.</para>

	      <para>In unserem Beispiel benutzen wir für den Wyse-50
	        den entsprechenden Typ aus &man.termcap.5;, der 286 PC
		wird als VT-100, den er ja emuliert, angegeben.</para>

	    </callout>

	    <callout arearefs="co-ttys-line1col4">
	      <para>Das vierte Feld gibt an, ob der Anschluss
	        aktiviert werden soll.  Wenn Sie hier <literal>on</literal>
		angeben, startet <command>init</command> das Programm, das
		im zweiten Feld angegeben wurde (normal
		<command>getty</command>).  Wenn Sie <literal>off</literal>
		angeben, wird das Kommando aus dem zweiten Feld nicht
		ausgeführt und folglich können Sie sich dann an
		dem betreffenden Terminal nicht anmelden.</para>
	    </callout>

	    <callout arearefs="co-ttys-line1col5">
	      <para>Im letzten Feld geben Sie die Sicherheit des
	        Anschlusses an.  Wenn Sie hier <literal>secure</literal>
		angeben, darf sich <systemitem class="username">root</systemitem> (oder jeder
		Account mit der UID <literal>0</literal>) über diese
		Verbindung anmelden.  Wenn Sie <literal>insecure</literal>
		angeben, dürfen sich nur unprivilegierte Benutzer
		anmelden.  Diese können später mit &man.su.1;
		oder einem ähnlichen Mechanismus zu
		<systemitem class="username">root</systemitem> wechseln.</para>

	      <para>Es wird dringend empfohlen, <literal>insecure</literal>
	        nur für Terminals hinter verschlossenen Türen
		zu verwenden, da Sie mit <command>su</command> leicht zum
		Superuser werden können.</para>
	    </callout>
	  </calloutlist>
	</example>
      </sect3>

      <sect3 xml:id="term-hup">
	<title><command>init</command> zwingen,
	  <filename>/etc/ttys</filename> erneut zu lesen</title>

	<para>Nachdem Sie die nötigen Änderungen in
	  <filename>/etc/ttys</filename> vorgenommen haben, schicken Sie
	  <command>init</command> ein SIGHUP-Signal (hangup), um es zu
	  veranlassen, seine Konfigurationsdatei neu zu lesen:</para>

	<screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

	<note>
	  <para>Da <command>init</command> immer der erste Prozess auf
	    einem System ist, besitzt es immer die PID
	    <literal>1</literal>.</para>
	</note>

	<para>Wenn alles richtig eingerichtet ist, alle Kabel angeschlossen
	  und die Terminals eingeschaltet sind, sollte für jeden
	  Terminal ein <command>getty</command> Prozess laufen und auf
	  jedem Terminal sollten Sie eine Anmeldeaufforderung sehen.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="term-debug">
      <title>Fehlersuche</title>

      <para>Selbst wenn Sie den Anweisungen akribisch gefolgt sind, kann es
	immer noch zu Fehlern beim Einrichten eines Terminals kommen.  Die
	folgende Aufzählung von Symptomen beschreibt mögliche
	Lösungen:</para>

      <sect3>
	<title>Es erscheint kein Anmeldeprompt</title>

	<para>Stellen Sie sicher, dass der Terminal verbunden und
	  eingeschaltet ist.  Wenn ein PC als Terminal fungiert,
	  überprüfen Sie, dass die Terminalemulation auf
	  den richtigen Schnittstellen läuft.</para>

	<para>Stellen Sie sicher, dass Sie das richtige Kabel
	  verwenden und dass das Kabel fest mit dem Terminal und
	  dem FreeBSD-Rechner verbunden ist.</para>

	<para>Stellen Sie sicher, dass die Einstellungen für
	  die Geschwindigkeit (bps) und Parität auf dem FreeBSD
	  System und dem Terminal gleich sind.  Wenn Ihr Terminal einen
	  Bildschirm besitzt, überprüfen Sie die richtige
	  Einstellung von Helligkeit und Kontrast.  Wenn Ihr Terminal
	  druckt, stellen Sie die ausreichende Versorgung mit Papier
	  und Tinte sicher.</para>

	<para>Überprüfen Sie mit <command>ps</command>,
	  dass der <command>getty</command> Prozess für
	  den Terminal läuft:</para>

        <screen>&prompt.root; <userinput>ps -axww|grep getty</userinput></screen>

	<para>Für jeden Terminal sollten Sie einen Eintrag sehen.
	  Aus dem folgenden Beispiel erkennen Sie, dass
	  <command>getty</command> auf der zweiten seriellen
	  Schnittstelle <filename>tyyd1</filename> läuft und den
	  Verbindungstyp <literal>std.38400</literal> aus
	  <filename>/etc/gettytab</filename> benutzt:</para>

	<screen>22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyu1</screen>

	<para>Wenn <command>getty</command> nicht läuft,
	  überprüfen Sie, ob der Anschluss in
	  <filename>/etc/ttys</filename> aktiviert ist.  Haben Sie
	  <command>kill -HUP 1</command> abgesetzt, nachdem Sie
	  <filename>/etc/ttys</filename> geändert hatten?</para>

	<para>Wenn <command>getty</command> läuft, aber der
	  Terminal immer noch kein Anmeldeprompt ausgibt, oder Sie am
	  Anmeldeprompt nichts eingeben können, kann es sein,
	  dass Ihr Terminal oder Kabel keinen Hardware-Handshake
	  unterstützt.  Ändern Sie dann den Eintrag
	  <literal>std.38400</literal> in <filename>/etc/ttys</filename>
	  zu <literal>3wire.38400</literal>.  Nachdem Sie
	  <filename>/etc/ttys</filename> geändert haben, setzen
	  Sie das Kommando <command>kill -HUP 1</command> ab.  Der
	  Eintrag <literal>3wire</literal> besitzt ähnliche
	  Eigenschaften wie der Eintrag <literal>std</literal>,
	  ignoriert aber den Hardware-Handshake.  Wenn Sie den Eintrag
	  <literal>3wire</literal> verwenden, müssen Sie
	  vielleicht die Geschwindigkeit verkleinern oder die
	  Software-Flusssteuerung aktivieren, um
	  Pufferüberläufe zu vermeiden.</para>
      </sect3>

      <sect3>
	<title>Es erscheinen nur unverständliche Zeichen</title>


	<para>Stellen Sie sicher, dass die Einstellungen für
          die Geschwindigkeit (bps) und Parität auf dem FreeBSD
	  System und dem Terminal gleich sind.  Kontrollieren Sie den
	  <command>getty</command> Prozess und stellen Sie sicher,
	  dass der richtige Verbindungstyp aus
	  <filename>/etc/gettytab</filename> benutzt wird.  Wenn das
	  nicht der Fall ist, editieren Sie
	  <filename>/etc/ttys</filename> und setzen das Kommando
	  <command>kill-HUP 1</command> ab.</para>
      </sect3>

      <sect3>
	<title>Zeichen erscheinen doppelt und eingegebene
	  Passwörter erscheinen im Klartext</title>

	<para>Stellen Sie den Terminal oder die Terminalemulation von
	  <quote>half duplex</quote> oder <quote>local echo</quote> auf
	  <quote>full duplex.</quote> um.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="dialup">
    <info><title>Einwählverbindungen</title>
      <authorgroup>
	<author><personname><firstname>Guy</firstname><surname>Helmer</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
      <authorgroup>
        <author><personname><firstname>Sean</firstname><surname>Kelly</surname></personname><contrib>Mit Anmerkungen von </contrib></author>
      </authorgroup>
    </info>
    

    <warning>
      <para>Mit &os;&nbsp;8.0 wurden die Gerätedateien für
	serielle Ports von
	<filename>/dev/ttydN</filename> in
	<filename>/dev/ttyuN</filename>
	umbenannt.  Setzen Sie noch &os;&nbsp;7.X ein, müssen
	Sie die Befehle in den folgenden Abschnitten entsprechend
	anpassen.</para>
    </warning>

    <indexterm><primary>Einwählverbindungen</primary></indexterm>

    <para>Das Einrichten von Einwählverbindungen ähnelt dem
      Anschließen von Terminals, nur dass Sie anstelle eines
      Terminals ein Modem verwenden.</para>

      <sect2>
	<title>Externe und interne Modems</title>

	<para>Externe Modems sind für Einwählverbindungen besser
	  geeignet, da sie die Konfiguration in nicht flüchtigem RAM
	  speichern können.  Zudem verfügen Sie über
	  Leuchtanzeigen, die den Status wichtiger RS-232 Signale
	  anzeigen und unter Umständen Besucher beeindrucken
	  können.</para>

	<para>Interne Modems verfügen normalerweise nicht über
	  nicht flüchtiges RAM und lassen sich meist nur über
	  DIP-Schalter konfigurieren.  Selbst wenn ein internes Modem
	  Leuchtanzeigen besitzt, sind diese meist schwer einzusehen, wenn
	  das Modem eingebaut ist.</para>

      <sect3>
	<title>Modems und Kabel</title>
	<indexterm><primary>Modem</primary></indexterm>

	<para>Mit einem externen Modem müssen Sie das richtige Kabel
	  benutzen:  Ein Standard RS-232C Kabel, bei dem die folgenden
	  Signale miteinander verbunden sind, sollte ausreichen:</para>

          <table frame="none" pgwide="1" xml:id="serialcomms-signal-names">
            <title>Signalnamen</title>

            <tgroup cols="2">
              <thead>
                <row>
                  <entry align="left">Abkürzung</entry>
                  <entry align="left">Bedeutung</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><acronym>RD</acronym></entry>
                  <entry>Received Data</entry>
                </row>

                <row>
                  <entry><acronym>TD</acronym></entry>
                  <entry>Transmitted Data</entry>
                </row>

                <row>
                  <entry><acronym>DTR</acronym></entry>
                  <entry>Data Terminal Ready</entry>
                </row>

                <row>
                  <entry><acronym>DSR</acronym></entry>
                  <entry>Data Set Ready</entry>
                </row>

                <row>
                  <entry><acronym>DCD</acronym></entry>
                  <entry>Data Carrier Detect (dadurch erkennt RS-232
                    das Signal <emphasis>Received Line</emphasis>)</entry>
                </row>

                <row>
                  <entry><acronym>SG</acronym></entry>
                  <entry>Signal Ground</entry>
                </row>

                <row>
                  <entry><acronym>RTS</acronym></entry>
                  <entry>Request to Send</entry>
                </row>

                <row>
                  <entry><acronym>CTS</acronym></entry>
                  <entry>Clear to Send</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

	<para>Ab Geschwindigkeiten von 2400&nbsp;bps benötigt FreeBSD die
	  Signale <acronym>RTS</acronym> und <acronym>CTS</acronym>
	  für die Flusssteuerung.  Das Signal
	  <acronym>CD</acronym> zeigt an, ob ein Träger vorliegt, das
	  heißt ob die Verbindung aufgebaut ist oder beendet wurde.
	  <acronym>DTR</acronym> zeigt an, dass das Gerät
	  betriebsbereit ist.  Es gibt einige Kabel, bei denen nicht alle
	  nötigen Signale verbunden sind.  Wenn Sie Probleme der Art
	  haben, dass zum Beispiel die Sitzung nicht beendet wird,
	  obwohl die Verbindung beendet wurde, kann das an einem solchen
	  Kabel liegen.</para>

	<para>Wie andere &unix; Betriebssysteme auch, benutzt FreeBSD
	  Hardwaresignale, um festzustellen, ob ein Anruf
	  beantwortet wurde, eine Verbindung beendet wurde, oder um die
	  Verbindung zu schließen und das Modem zurückzusetzen.
	  FreeBSD vermeidet es, dem Modem Kommandos zu senden, oder den
	  Statusreport des Modems abzufragen.  Falls Sie ein Benutzer
	  von PC-basierenden Bulletin Board Systemen sind, mag Sie das
	  verwundern.</para>
      </sect3>
      </sect2>

      <sect2>
	<title>Schnittstellenbausteine</title>

	<para>FreeBSD unterstützt EIA RS-232C (CCITT V.24) serielle
	  Schnittstellen, die auf den NS8250, NS16450, NS16550 oder NS16550A
	  Bausteinen basieren.  Die Bausteine der Serie 16550 verfügen
	  über einen 16&nbsp;Byte großen Puffer, der als FIFO angelegt
	  ist.  Wegen Fehler in der FIFO-Logik kann der Puffer in einem 16550
	  Baustein allerdings nicht genutzt werden, das heißt der
	  Baustein muss als 16450 betrieben werden.  Bei allen
	  Bausteinen ohne Puffer und dem 16550 Baustein muss jedes
	  Byte einzeln von dem Betriebssystem verarbeitet werden, was
	  Fehler bei hohen Geschwindigkeiten oder großer Systemlast
	  erzeugt.  Es sollten daher nach Möglichkeit serielle
	  Schnittstellen, die auf 16550A Bausteinen basieren, eingesetzt
	  werden.</para>
      </sect2>

    <sect2>
      <title>Überblick</title>

      <indexterm><primary>getty</primary></indexterm>
      <para>Wie bei Terminals auch, startet <command>init</command> für
	jede serielle Schnittstelle, die eine Einwählverbindung zur
	Verfügung stellt, einen <command>getty</command> Prozess.
	Wenn das Modem beispielsweise an <filename>/dev/ttyu0</filename>
	angeschlossen ist, sollte in der Ausgabe von <command>ps
	  ax</command> eine Zeile wie die folgende erscheinen:</para>

      <screen> 4850 ??  I      0:00.09 /usr/libexec/getty V19200 ttyu0</screen>

      <para>Wenn sich ein Benutzer einwählt und die Verbindung
        aufgebaut ist, zeigt das Modem dies durch das <acronym>CD</acronym>
	Signal (Carrier Detect) an.  Der Kernel merkt, dass ein Signal
	anliegt und vollendet das Öffnen der Schnittstelle durch
	<command>getty</command>.  Dann sendet <command>getty</command> das
	Anmeldeprompt mit der ersten für die Verbindung vereinbarten
	Geschwindigkeit und wartet auf eine Antwort.  Wenn die Antwort
	unverständlich ist, weil zum Beispiel die Geschwindigkeit des
	Modems von <command>getty</command>s Geschwindigkeit abweicht,
	versucht <command>getty</command> die Geschwindigkeit solange
	anzupassen, bis es eine verständliche Antwort
	erhält.</para>

      <indexterm>
        <primary><command>/usr/bin/login</command></primary>
      </indexterm>
      <para><command>getty</command> führt, nachdem der Benutzer seinen
	Namen eingegeben hat, <filename>/usr/bin/login</filename> aus,
	welches das Passwort abfragt und danach die Shell des
	Benutzers startet.</para>
    </sect2>


    <sect2>
      <title>Konfigurationsdateien</title>

      <para>Drei Konfigurationsdateien in <filename>/etc</filename>
        steuern, ob eine Einwahl in Ihr FreeBSD-System möglich ist.
	Die erste, <filename>/etc/gettytab</filename>, konfiguriert den
	<filename>/usr/libexec/getty</filename> D&aelig;mon.  In
	<filename>/etc/ttys</filename> wird festgelegt, auf welchen
	Schnittstellen <filename>/sbin/init</filename> einen
	<command>getty</command> Prozess startet.  Schließlich
	haben Sie in <filename>/etc/rc.d/serial</filename> die
	Möglichkeit, Schnittstellen zu initialisieren.</para>

      <para>Es gibt zwei Ansichten darüber, wie Modems für
        Einwählverbindungen unter &unix; zu konfigurieren sind.  Zum
	einen kann die Geschwindigkeit zwischen dem Modem und dem Computer
	fest eingestellt werden.  Sie ist damit unabhängig von der
	Geschwindigkeit, mit der sich der entfernte Benutzer einwählt.
	Dies hat den Vorteil, dass der entfernte Benutzer das
	Anmeldeprompt sofort bekommt.  Der Nachteil bei diesem Verfahren
	ist, dass das System die tatsächliche Geschwindigkeit
	der Verbindung nicht kennt.  Damit können bildschirmorientierte
	Programme wie <application>Emacs</application> ihren
	Bildschirmaufbau nicht an langsame Verbindungen anpassen,
	um die Antwortzeiten zu verbessern.</para>

      <para>Die andere Möglichkeit besteht darin, die Geschwindigkeit
        der RS-232 Schnittstelle des lokalen Modems an die Geschwindigkeit
	des entfernten Modems anzupassen.  Bei einer V.32bis (14400&nbsp;bps)
	Verbindung kann das lokale Modem die RS-232 Schnittstelle mit
	19200&nbsp;bps betreiben, während bei einer Verbindung mit
	2400&nbsp;bps die RS-232 Schnittstelle mit 2400&nbsp;bps
	betrieben wird.  Da <command>getty</command> die
	Verbindungsgeschwindigkeit des Modems nicht kennt, startet es
	den Anmeldevorgang mit der Ausgabe
	von <prompt>login:</prompt> und wartet auf eine Antwort.  Wenn der
	Benutzer der Gegenstelle nun nur unverständliche Zeichen
	erhält, muss er solange <keycap>Enter</keycap>
	drücken, bis das Anmeldeprompt erscheint.  Solange die
	Geschwindigkeiten nicht übereinstimmen, sind die Antworten der
	Gegenstelle für <command>getty</command> ebenfalls
	unverständlich.  In diesem Fall wechselt
	<command>getty</command> zur nächsten Geschwindigkeit und gibt
	wieder <prompt>login:</prompt> aus.  In aller Regel erhält der
	Benutzer der Gegenstelle nach ein bis zwei Tastendrücken
	eine erkennbare Anmeldeaufforderung.  Diese Anmeldeprozedur sieht
	nicht so sauber wie die Methode mit einer festen Geschwindigkeit
	aus, bietet dem Benutzer einer langsamen Verbindung allerdings den
	Vorteil, dass sich bildschirmorientierte Programme an die
	Geschwindigkeit anpassen können.</para>

      <para>Im Folgenden wird die Konfiguration für beide Methoden
        besprochen, doch die Methode der angepassten Geschwindigkeit
	wird bei der Diskussion bevorzugt.</para>

      <sect3>
	<title><filename>/etc/gettytab</filename></title>

  <indexterm>
    <primary><filename>/etc/gettytab</filename></primary>
  </indexterm>
	<para>Mit <filename>/etc/gettytab</filename> wird &man.getty.8; im
	Stil von &man.termcap.5; konfiguriert.  Das Format dieser Datei und
	die Bedeutung der Einträge wird in &man.gettytab.5;
	beschrieben.</para>

	<sect4>
	  <title>Konfiguration für feste Geschwindigkeit</title>

	  <para>Wenn Sie die Modemgeschwindigkeit vorgeben, werden Sie in
	    <filename>/etc/gettytab</filename> nichts ändern
	    müssen.</para>
	</sect4>

	<sect4>
	  <title>Konfiguration für angepasste Geschwindigkeit</title>

	  <para>In <filename>/etc/gettytab</filename> müssen
	    Einträge für die Geschwindigkeiten, die Sie benutzen
	    wollen, sein.  Wenn Sie ein 2400&nbsp;bps Modem besitzen,
	    können Sie wahrscheinlich den schon vorhandenen
	    <literal>D2400</literal> Eintrag benutzen.</para>

	  <programlisting>#
# Fast dialup terminals, 2400/1200/300 rotary (can start either way)
#
D2400|d2400|Fast-Dial-2400:\
        :nx=D1200:tc=2400-baud:
3|D1200|Fast-Dial-1200:\
        :nx=D300:tc=1200-baud:
5|D300|Fast-Dial-300:\
        :nx=D2400:tc=300-baud:</programlisting>

	  <para>Wenn Sie ein Modem mit einer höheren Geschwindigkeit
	    besitzen, müssen Sie wahrscheinlich in
	    <filename>/etc/gettytab</filename> weitere Einträge
	    erstellen.  Hier ist ein Beispiel, das Sie mit einem 14400&nbsp;bps
	    Modem benutzen können:</para>

	  <programlisting>#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:</programlisting>

	  <para>Die damit erzeugten Verbindungen verwenden 8&nbsp;Bit und keine
	    Parität.</para>

	  <para>Im obigen Beispiel startet die Geschwindigkeit bei
	    19200&nbsp;bps (eine V.32bis Verbindung) und geht dann
	    über 9600&nbsp;bps (V.32), 400&nbsp;bps, 1200&nbsp;bps
	    und 300&nbsp;bps wieder zurück zu 19200&nbsp;bps.
	    Das Schlüsselwort <literal>nx=</literal>
	    (<foreignphrase>next table</foreignphrase>) sorgt für
	    das zyklische Durchlaufen der Geschwindigkeiten.  Jede Zeile
	    zieht zudem noch mit <literal>tc=</literal>
	    (<foreignphrase>table continuation</foreignphrase>)
	    die Vorgabewerte für die jeweilige Geschwindigkeit an.</para>

	  <para>Wenn Sie ein 28800&nbsp;bps Modem besitzen und/oder Kompression
	    mit einem 14400&nbsp;bps Modem benutzen wollen, brauchen Sie
	    höhere Geschwindigkeiten als 19200&nbsp;bps.  Das folgende
	    Beispiel startet mit 57600&nbsp;bps:</para>

	  <programlisting>#
# Additions for a V.32bis or V.34 Modem
# Starting at 57600 bps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:</programlisting>

	  <note>
	    <para>Wenn Sie eine langsame CPU oder ein stark ausgelastetes
	      System besitzen und sich kein 16550A in Ihrem System befindet,
	      erhalten Sie bei 57600&nbsp;bps vielleicht
	      <errorname>sio</errorname> Fehlermeldungen der Form <quote>silo
	      overflow</quote>.</para>
          </note>
	</sect4>
      </sect3>

      <sect3 xml:id="dialup-ttys">
	<title><filename>/etc/ttys</filename></title>
	<indexterm>
	  <primary><filename>/etc/ttys</filename></primary>
	</indexterm>

	<para><filename>/etc/ttys</filename> wurde bereits in <xref linkend="ex-etc-ttys"/> besprochen.  Die Konfiguration für
	  Modems ist ähnlich, allerdings braucht
	  <command>getty</command> ein anderes Argument und es muss
	  ein anderer Terminaltyp angegeben werden.  Der Eintrag für
	  beide Methoden (feste und angepasste Geschwindigkeit) hat die
	  folgende Form:</para>

	<programlisting>ttyu0   "/usr/libexec/getty <replaceable>xxx</replaceable>"   dialup on</programlisting>

	<para>Das erste Feld der obigen Zeile gibt die Gerätedatei
	  für diesen Eintrag an &ndash; <filename>ttyu0</filename>
	  bedeutet, dass <command>getty</command> mit
	  <filename>/dev/ttyu0</filename> arbeitet.  Das zweite Feld
	  <literal>"/usr/libexec/getty xxx"</literal>
	  gibt das Kommando an, das <command>init</command> für dieses
	  Gerät startet (<replaceable>xxx</replaceable> wird durch
	  einen passenden Eintrag aus <filename>/etc/gettytab</filename>
	  ersetzt).  Die Vorgabe für den Terminaltyp, hier
	  <literal>dialup</literal>, wird im dritten Feld angegeben.  Das
	  vierte Feld, <literal>on</literal>, zeigt
	  <command>init</command> an, dass die Schnittstelle aktiviert
	  ist.  Im fünften Feld könnte noch
	  <literal>secure</literal> angegeben werden, um Anmeldungen von
	  <systemitem class="username">root</systemitem> zu erlauben, doch sollte das wirklich
	  nur für physikalisch sichere Terminals, wie die
	  Systemkonsole, aktiviert werden.</para>

	<para>Die Vorgabe für den Terminaltyp,
	  <literal>dialup</literal> im obigen Beispiel, hängt von lokalen
	  Gegebenheiten ab.  Traditionell wird <literal>dialup</literal>
	  für Einwählverbindungen verwendet, so dass die
	  Benutzer in ihren Anmeldeskripten den Terminaltyp auf ihren
	  Terminal abstimmen können, wenn der Typ auf
	  <literal>dialup</literal> gesetzt ist.  Wenn Sie aber
	  beispielsweise nur VT102 Terminals oder Emulatoren einsetzen,
	  können Sie den Terminaltyp hier auch fest auf
	  <literal>vt102</literal> setzen.</para>

	<para>Nachdem Sie <filename>/etc/ttys</filename> geändert
	  haben, müssen Sie <command>init</command> ein
	  <acronym>HUP</acronym> Signal schicken, damit es die Datei wieder
	  einliest.  Sie können dazu das folgende Kommando
	  verwenden:</para>

	<screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

	<para>Wenn Sie das System zum ersten Mal konfigurieren, sollten Sie
	  dieses Kommando erst ausführen, wenn Sie Ihr Modem richtig
	  konfiguriert und angeschlossen haben.</para>

	<sect4>
	  <title>Konfiguration für feste Geschwindigkeit</title>

	  <para>Das Argument von <command>getty</command> muss in
	    diesem Fall eine feste Geschwindigkeit vorgeben.  Der Eintrag
	    für ein Modem, das fest auf 19200&nbsp;bps eingestellt ist,
	    könnte wie folgt aussehen:</para>

	  <programlisting>ttyu0   "/usr/libexec/getty std.19200"   dialup on</programlisting>

	  <para>Wenn Ihr Modem auf eine andere Geschwindigkeit eingestellt
	    ist, setzen Sie anstelle von <literal>std.19200</literal> einen
	    passenden Eintrag der Form
	    <literal>std.speed</literal> ein.
	    Stellen Sie sicher, dass dies auch ein gültiger
	    Verbindungstyp aus <filename>/etc/gettytab</filename>
	    ist.</para>
	</sect4>

	<sect4>
	  <title>Konfiguration für angepasste Geschwindigkeit</title>

	  <para>Das Argument von <command>getty</command> muss hier auf
	    einen der Einträge aus <filename>/etc/gettytab</filename>
	    zeigen, der zu einer Kette von Einträgen gehört, die
	    die zu probierenden Geschwindigkeiten beschreiben.  Wenn Sie
	    dem obigen Beispiel gefolgt sind und zusätzliche
	    Einträge in <filename>/etc/gettytab</filename> erzeugt
	    haben, können Sie die folgende Zeile verwenden:</para>

	  <programlisting>ttyu0   "/usr/libexec/getty V19200"   dialup on</programlisting>
	</sect4>
      </sect3>

      <sect3>
	<title><filename>/etc/rc.d/serial</filename></title>
	<indexterm>
	  <primary>rc-Dateien</primary>
	  <secondary><filename>rc.serial</filename></secondary>
	</indexterm>

	<para>Modems, die höhere Geschwindigkeiten unterstützen,
	  zum Beispiel V.32, V.32bis und V.34 Modems, benutzen
	  Hardware-Flusssteuerung (<literal>RTS/CTS</literal>).  Für
	  die entsprechenden Schnittstellen können Sie die
	  Flusssteuerung mit <command>stty</command> in
	  <filename>/etc/rc.d/serial</filename> einstellen.</para>

	<para>Um beispielsweise die Hardware-Flusssteuerung
	  für die Geräte zur Ein- und Auswahl der zweiten
	  seriellen Schnittstelle (<filename>COM2</filename>)
	  zu aktivieren, benutzen Sie die Dateien zur Initialisierung der
	  entsprechenden Geräte und fügen die folgenden Zeilen in
	  <filename>/etc/rc.d/serial</filename> hinzu:</para>
	<programlisting># Serial port initial configuration
stty -f /dev/ttyu1.init crtscts
stty -f /dev/cuad1.init crtscts</programlisting>

      </sect3>
    </sect2>

    <sect2>
      <title>Modemkonfiguration</title>

      <para>Wenn Sie ein Modem besitzen, das seine Konfiguration in nicht
        flüchtigem RAM speichert, werden Sie ein Terminalprogramm wie
	<application>Telix</application> unter &ms-dos; oder
	<command>tip</command> unter &os; benötigen, um die Parameter
	einzustellen.  Verbinden Sie sich mit derselben Geschwindigkeit, die
	<command>getty</command> zuerst benutzen würde, mit dem Modem und
	treffen Sie folgende Einstellungen:</para>

      <itemizedlist>
	<listitem>
	  <para><acronym>DCD</acronym> ist eingeschaltet, wenn das
	    Trägersignal des entfernten Modems erkannt wird.</para>
	</listitem>

	<listitem>
	  <para>Im Betrieb liegt <acronym>DTR</acronym> an.  Bei einem Verlust
	    von DTR legt das Modem auf und setzt sich zurück.</para>
	</listitem>

	<listitem>
	  <para><acronym>CTS</acronym> Flusssteuerung ist für
	    ausgehende Daten aktiviert.</para>
	</listitem>

	<listitem>
	  <para><acronym>XON/XOFF</acronym> Flusssteuerung ist
	    ausgeschaltet.</para>
	</listitem>

	<listitem>
	  <para><acronym>RTS</acronym> Flusssteuerung ist für
	    eingehende Daten aktiviert.</para>
	</listitem>

	<listitem>
	  <para>Keine Rückmeldungen ausgeben.</para>
	</listitem>

	<listitem>
	  <para>Die Echo-Funktion ist deaktiviert.</para>
	</listitem>
      </itemizedlist>

      <para>In der Dokumentation Ihres Modems finden Sie die nötigen
        Befehle, die Sie absetzen müssen, und/oder nötigen
        DIP-Schalterstellungen, um die obigen Einstellungen zu
	treffen.</para>

      <para>Für ein externes 14400 &usrobotics; &sportster; gelten zum
        Beispiel die folgenden Befehle:</para>

      <programlisting>ATZ
AT&amp;C1&amp;D2&amp;H1&amp;I0&amp;R2&amp;W</programlisting>

      <para>Bei dieser Gelegenheit können Sie auch gleich andere
        Einstellungen, zum Beispiel ob Sie V42.bis und/oder MNP5
	Kompression benutzen wollen, an Ihrem Modem vornehmen.</para>

      <para>Bei einem externen 14400 &usrobotics; &sportster;
	müssen Sie auch noch einige DIP-Schalter einstellen.
	Die folgenden Einstellungen können Sie vielleicht
	als Beispiel für andere Modems verwenden:</para>

      <itemizedlist>
	<listitem>
	  <para>Schalter 1: OBEN &ndash; DTR normal</para>
	</listitem>

	<listitem>
	  <para>Schalter 2: N/A (Rückmeldungen als Text/numerische
	    Rückmeldungen)</para>
	</listitem>

	<listitem>
	  <para>Schalter 3: OBEN &ndash; Keine Rückmeldungen
	    ausgeben</para>
	</listitem>

	<listitem>
	  <para>Schalter 4: UNTEN &ndash; Echo-Funktion aus</para>
	</listitem>

	<listitem>
	  <para>Schalter 5: OBEN &ndash; Rufannahme aktiviert</para>
	</listitem>

	<listitem>
	  <para>Schalter 6: OBEN &ndash; Carrier Detect normal</para>
	</listitem>

	<listitem>
	  <para>Schalter 7: OBEN &ndash; Einstellungen aus dem NVRAM laden</para>
	</listitem>

	<listitem>
	  <para>Schalter 8: N/A (Smart Mode/Dumb Mode)</para>
	</listitem>
      </itemizedlist>

      <para>Für Einwählverbindungen sollten die
        Rückmeldungen deaktiviert sein, da sonst
	<command>getty</command> dem Modem das Anmeldeprompt
	<prompt>login:</prompt> schickt und das Modem im Kommandomodus das
	Prompt wieder ausgibt (Echo-Funktion) oder eine Rückmeldung gibt.
	Das führt dann zu einer länglichen und fruchtlosen
	Kommunikation zwischen dem Modem und
	<command>getty</command>.</para>

      <sect3>
	<title>Konfiguration für feste Geschwindigkeit</title>

	<para>Die Geschwindigkeit zwischen Modem und Computer muss auf
	  einen festen Wert eingestellt werden.  Mit einem externen 14400
	  &usrobotics; &sportster; Modem setzen die folgenden Kommandos die
	  Geschwindigkeit auf den Wert der Datenendeinrichtung fest:</para>

	<programlisting>ATZ
AT&amp;B1&amp;W</programlisting>
      </sect3>

      <sect3>
	<title>Konfiguration für angepasste Geschwindigkeit</title>

	<para>In diesem Fall muss die Geschwindigkeit der seriellen
	  Schnittstelle des Modems der eingehenden Geschwindigkeit
	  angepasst werden.  Für ein externes
	  14400 &usrobotics; &sportster;
	  Modem erlauben die folgenden Befehle eine Anpassung der
	  Geschwindigkeit der seriellen Schnittstelle für
	  Verbindungen, die keine Fehlerkorrektur verwenden:</para>

	<programlisting>ATZ
AT&amp;B2&amp;W</programlisting>

	<para>Verbindungen mit Fehlerkorrektur (V.42, MNP) verwenden die
	  Geschwindigkeit der Datenendeinrichtung.</para>
      </sect3>

      <sect3>
	<title>Überprüfen der Modemkonfiguration</title>

	<para>Die meisten Modems verfügen über Kommandos, die die
	  Konfiguration des Modems in lesbarer Form ausgeben.  Auf einem
	  externen 14400 &usrobotics; &sportster; zeigt
	  <command>ATI5</command> die Einstellungen im nicht
	  flüchtigen RAM an.  Um die wirklichen
	  Einstellungen unter Berücksichtigung der DIP-Schalter zu
	  sehen, benutzen Sie <command>ATZ</command> gefolgt von
	  <command>ATI4</command>.</para>

	<para>Wenn Sie ein anderes Modem benutzen, schauen Sie bitte in der
	  Dokumentation Ihres Modems nach, wie Sie die Konfiguration des
	  Modems überprüfen können.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Fehlersuche</title>

      <para>Bei Problemen können Sie die Einwählverbindung anhand
        der folgenden Punkte überprüfen:</para>

      <sect3>
	<title>Überprüfen des FreeBSD-Systems</title>

	<para>Schließen Sie das Modem an das FreeBSD-System an und
	  booten Sie das System.  Wenn Ihr Modem über
	  Statusindikatoren verfügt, überprüfen Sie, ob der
	  <acronym>DTR</acronym> Indikator leuchtet, wenn das Anmeldeprompt
	  erscheint.  Dies zeigt an, dass das FreeBSD-System einen
	  <command>getty</command> Prozess auf der entsprechenden
	  Schnittstelle gestartet hat und das Modem auf einkommende
	  Verbindungen wartet.</para>

	<para>Wenn der <acronym>DTR</acronym>-Indikator nicht leuchtet,
	  melden Sie sich an dem FreeBSD-System an und überprüfen mit
	  <command>ps ax</command>, ob FreeBSD einen
	  <command>getty</command>-Prozess auf der entsprechenden
	  Schnittstelle gestartet hat.  Unter den angezeigten Prozessen
	  sollten Sie ähnliche wie die folgenden finden:</para>

	<screen>  114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyu0
  115 ??  I      0:00.10 /usr/libexec/getty V19200 ttyu1</screen>

	<para>Wenn das Modem noch keinen Anruf entgegengenommen hat und Sie
	  stattdessen die folgende Zeile sehen</para>

	  <screen>  114 d0  I      0:00.10 /usr/libexec/getty V19200 ttyu0</screen>

	<para>bedeutet dies, dass <command>getty</command> die
	  Schnittstelle schon geöffnet hat und zeigt Kabelprobleme
	  oder eine falsche Modemkonfiguration an, da
	  <command>getty</command> die Schnittstelle erst dann öffnen
	  kann, wenn das <acronym>CD</acronym> Signal (Carrier Detect) vom
	  Modem anliegt.</para>

	<para>Wenn Sie keine <command>getty</command>-Prozesse auf den
	  gewünschten <filename>ttyuN</filename>
	  Ports finden, untersuchen Sie bitte <filename>/etc/ttys</filename>
	  auf Fehler.  Suchen Sie auch in <filename>/var/log/messages</filename>
	  nach Meldungen von <command>init</command> oder
	  <command>getty</command>.  Wenn Sie dort Meldungen finden,
	  sollten Sie noch einmal die beiden Konfigurationsdateien
	  <filename>/etc/ttys</filename> und <filename>/etc/gettytab</filename>
	  nach Fehlern durchsehen.  Überprüfen Sie auch, ob die
	  Gerätedateien
	  <filename>/dev/ttyuN</filename>
	  vorhanden sind.</para>
      </sect3>

      <sect3>
	<title>Einwählversuch</title>

	<para>Versuchen Sie, sich in Ihr System einzuwählen.  Auf dem
	  entfernten System stellen Sie bitte die folgenden
	  Kommunikationsparameter ein: 8&nbsp;Bit, keine Parität, ein
	  Stop-Bit.  Wenn Sie kein Anmeldeprompt erhalten oder nur
	  unleserliche Zeichen sehen, drücken Sie mehrmals, in
	  Abständen von ungefähr einer Sekunde,
	  <keycap>Enter</keycap>.  Wenn Sie immer noch nicht die
	  <prompt>login:</prompt> Meldung sehen, schicken Sie ein
	  <command>BREAK</command> Kommando.  Wenn Sie zur Einwahl ein
	  Highspeed-Modem benutzen, verwenden Sie eine feste
	  Geschwindigkeit auf der seriellen Schnittstelle des Modems
	  (<command>AT&amp;B1</command> für ein
	  &usrobotics; &sportster;).</para>

	<para>Wenn Sie jetzt immer noch kein Anmeldeprompt erhalten,
	  überprüfen Sie nochmals <filename>/etc/gettytab</filename>
	  und stellen sicher, dass</para>

	<itemizedlist>
	  <listitem>
	    <para>der Verbindungstyp in <filename>/etc/ttys</filename> zu
	      einem gültigen Eintrag in <filename>/etc/gettytab</filename>
	      gehört,</para>
	  </listitem>

	  <listitem>
	    <para>jeder der <literal>nx=</literal> Einträge in
	      <filename>gettytab</filename> gültig ist und</para>
	  </listitem>

	  <listitem>
	    <para>jeder <literal>tc=</literal> Eintrag auf einen
	      gültigen Eintrag in <filename>gettytab</filename>
	      verweist.</para>
	  </listitem>
	</itemizedlist>

	<para>Wenn das Modem an Ihrem FreeBSD-System auf einen eingehenden Anruf
	  nicht antwortet, stellen Sie sicher, dass das Modem so
	  konfiguriert ist, dass es einen Anruf beantwortet, wenn
	  <acronym>DTR</acronym> anliegt.  Wenn Ihr Modem Statusindikatoren
	  besitzt, können Sie das Anliegen von <acronym>DTR</acronym>
	  anhand der Leuchten überprüfen.</para>

	<para>Wenn Sie alles schon mehrfach überprüft haben und
	  es immer noch noch nicht funktioniert, machen Sie erst einmal
	  eine Pause, bevor Sie weitermachen.  Wenn es immer noch nicht
	  funktioniert, können Sie eine Mail an die Mailingliste
	  &a.de.questions; schicken, in der Sie Ihr Modem und Ihr Problem
	  beschreiben und Ihnen sollte geholfen werden.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="dialout">
    <title>Verbindungen nach Außen</title>

    <warning>
      <para>Mit &os;&nbsp;8.0 wurden die Gerätedateien für
	serielle Ports von
	<filename>/dev/ttydN</filename> in
	<filename>/dev/ttyuN</filename>
	umbenannt.  Setzen Sie noch &os;&nbsp;7.X ein, müssen
	Sie die Befehle in den folgenden Abschnitten entsprechend
	anpassen.</para>
    </warning>

    <para>Die folgenden Ratschläge beschreiben, wie Sie mit einem
      Modem eine Verbindung zu einem anderen Computer herstellen.  Dies
      können Sie nutzen, um sich auf einem entfernten Computer
      anzumelden, oder um eine Verbindung zu einem BBS (Bulletin Board
      System) herzustellen.</para>

    <para>Weiterhin ist diese Art von Verbindungen nützlich, wenn mal
      Ihr PPP nicht funktioniert.  Wenn Sie zum Beispiel eine Datei
      mit FTP übertragen wollen und das über PPP gerade nicht
      möglich ist, melden Sie sich auf dem entfernten Rechner an und
      führen dort die FTP-Sitzung durch.  Die Dateien können Sie
      danach mit zmodem auf den lokalen Rechner übertragen.</para>

    <sect2 xml:id="hayes-unsupported">
      <title>Mein Hayes Modem wird nicht unterstützt &ndash; was kann
        ich tun?</title>

      <para>Eigentlich ist die Onlinehilfe für <command>tip</command>
	nicht mehr aktuell.  Es gibt einen eingebauten, allgemeinen
        Hayes Wähler.  Verwenden Sie einfach <literal>at=hayes</literal>
        in <filename>/etc/remote</filename>.</para>

      <para>Der Hayes-Treiber ist nicht schlau genug, um ein paar der
        erweiterten Funktionen von neueren Modems zu erkennen &ndash;
	Nachrichten wie <literal>BUSY</literal>,
	<literal>NO DIALTONE</literal> oder <literal>CONNECT 115200</literal>
	verwirren ihn nur.  Sie sollten diese Nachrichten mit Hilfe von
	<command>ATX0&amp;W</command> abschalten, wenn Sie
	<command>tip</command> benutzen.</para>

      <para>Der Anwahl-Timeout von <command>tip</command> beträgt 60
        Sekunden.  Ihr Modem sollte weniger verwenden, oder
	<command>tip</command> denkt, dass ein Kommunikationsfehler
	vorliegt.  Versuchen Sie es mit
	<command>ATS7=45&amp;W</command>.</para>
    </sect2>

    <sect2 xml:id="direct-at">
      <title>Wie soll ich die AT-Befehle eingeben?</title>

      <indexterm>
        <primary><filename>/etc/remote</filename></primary>
      </indexterm>
      <para>Erstellen Sie einen so genannten <literal>direct</literal>
        Eintrag in <filename>/etc/remote</filename>.  Wenn Ihr Modem zum
	Beispiel an der ersten seriellen Schnittstelle,
	<filename>/dev/cuad0</filename>, angeschlossen ist, dann
	fügen Sie die folgende Zeile hinzu:</para>

      <programlisting>cuad0:dv=/dev/cuad0:br#19200:pa=none</programlisting>

      <para>Verwenden Sie die höchste bps-Rate, die Ihr Modem in der
        br Fähigkeit unterstützt.  Geben Sie dann <command>tip
	cuad0</command> ein und Sie sind mit Ihrem
	Modem verbunden.</para>

      <para>Oder benutzen Sie <command>cu</command> als
        <systemitem class="username">root</systemitem> mit dem folgenden Befehl:</para>

      <screen>&prompt.root; <userinput>cu -lline -sspeed</userinput></screen>

      <para><replaceable>line</replaceable> steht für die serielle
        Schnittstelle (<filename>/dev/cuad0</filename>) und
	<replaceable>speed</replaceable> für die Geschwindigkeit
	(<literal>57600</literal>).  Wenn Sie mit dem Eingeben der AT
	Befehle fertig sind, beenden Sie mit <command>~.</command>.</para>
    </sect2>

    <sect2 xml:id="gt-failure">
      <title>Wieso funktioniert das <literal>@</literal> Zeichen für
        die pn Fähigkeit nicht?</title>

      <para>Das <literal>@</literal> Zeichen in der
        Telefonnummerfähigkeit sagt <command>tip</command>, dass
	es in der Datei <filename>/etc/phones</filename> nach einer Nummer
	suchen soll.  Aber <literal>@</literal> ist auch ein spezielles
	Zeichen in den Dateien, in denen Fähigkeiten beschrieben
	werden, wie <filename>/etc/remote</filename>.  Schreiben Sie es mit
	einem Backslash:</para>

      <programlisting>pn=\@</programlisting>
    </sect2>

    <sect2 xml:id="dial-command-line">
      <title>Wie kann ich von der Kommandozeile eine Telefonnummer
        wählen?</title>

      <para>Stellen Sie einen allgemeinen Eintrag in
        <filename>/etc/remote</filename>.  Zum Beispiel:</para>

      <programlisting>tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuad0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuad0:br#57600:at=hayes:pa=none:du:</programlisting>

      <para>Mit dem folgenden Befehl können Sie dann
        wählen:</para>

      <screen>&prompt.root; <userinput>tip -115200 5551234</userinput></screen>

      <para>Sollten Sie <command>cu</command> gegenüber
        <command>tip</command> bevorzugen, verwenden Sie einen allgemeinen
	cu-Eintrag:</para>

      <programlisting>cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuad1:br#57600:at=hayes:pa=none:du:</programlisting>

      <para>und benutzen zum Wählen das Kommando:</para>

      <screen>&prompt.root; <userinput>cu 5551234 -s 115200</userinput></screen>
    </sect2>

    <sect2 xml:id="set-bps">
      <title>Muss ich dabei jedes Mal die bps-Rate angeben?</title>

      <para>Schreiben Sie einen <literal>tip1200</literal>- oder einen
        <literal>cu1200</literal>-Eintrag, aber geben Sie auch die bps-Rate
	an, die Ihr Modem wirklich unterstützt.  Leider denkt
	&man.tip.1;, dass 1200&nbsp;bps ein guter Standardwert ist und
	deswegen sucht es nach einem <literal>tip1200</literal>-Eintrag.
	Natürlich müssen Sie nicht 1200&nbsp;bps
	benutzen.</para>
    </sect2>

    <sect2 xml:id="terminal-server">
      <title>Wie kann ich möglichst komfortabel über einen
        Terminal-Server auf verschiedene Rechner zugreifen?</title>

      <para>Sie müssen nicht warten bis Sie verbunden sind, und
        jedes Mal <command>CONNECT Rechner</command>
	eingeben, benutzen Sie <command>tip</command>s
	<literal>cm</literal>-Fähigkeit. Sie können diese
	Einträge in <filename>/etc/remote</filename> verwenden:</para>

      <programlisting>pain|pain.deep13.com|Forrester's machine:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank's machine:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cuad2:br#38400:at=hayes:du:pa=none:pn=5551234:</programlisting>

      <para>Mit den Befehlen <command>tip pain</command> oder <command>tip
        muffin</command> können Sie eine Verbindungen zu den Rechnern
	<systemitem>pain</systemitem> oder <systemitem>muffin</systemitem> herstellen;  mit
	<command>tip deep13</command> verbinden Sie sich mit dem
	Terminalserver.</para>
    </sect2>

    <sect2 xml:id="tip-multiline">
      <title>Kann <command>tip</command> mehr als eine Verbindung für
        jede Seite ausprobieren?</title>

      <para>Das ist oft ein Problem, wenn eine Universität mehrere
        Telefonleitungen hat und viele tausend Studenten diese benutzen
	wollen.</para>

      <para>Erstellen Sie einen Eintrag für Ihre Universität in
      <filename>/etc/remote</filename> und benutzen Sie
      <literal>@</literal> für die
        <literal>pn</literal>-Fähigkeit:</para>

      <programlisting>big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuad3:br#9600:at=courier:du:pa=none:</programlisting>

      <para>Listen Sie die Telefonnummern der Universität in
        <filename>/etc/phones</filename> auf:</para>

      <programlisting>big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</programlisting>

      <para><command>tip</command> probiert jede der Nummern in der
        aufgelisteten Reihenfolge und gibt dann auf.  Möchten Sie,
        dass <command>tip</command> beim Versuchen eine Verbindung
        herzustellen nicht aufgibt, lassen Sie es in einer while-Schleife
        laufen.</para>
    </sect2>

    <sect2 xml:id="multi-controlp">
      <title>Warum muss ich zweimal
        <keycombo action="simul">
          <keycap>Ctrl</keycap>
          <keycap>P</keycap>
        </keycombo>
        tippen, um ein
        <keycombo action="simul">
          <keycap>Ctrl</keycap>
          <keycap>P</keycap>
        </keycombo>
        zu senden?</title>

      <para><keycombo action="simul">
	  <keycap>Ctrl</keycap>
	  <keycap>P</keycap>
	</keycombo>
	ist das voreingestellte Zeichen, mit dem eine Übertragung
	erzwungen werden kann und wird benutzt, um <command>tip</command>
	zu sagen, dass das nächste Zeichen direkt gesendet werden
	soll und nicht als Fluchtzeichen interpretiert werden soll.  Mit
	Hilfe der Fluchtsequenz <command>~s</command>, mit der man
	Variablen setzen kann, können Sie jedes andere Zeichen als
	<quote>force</quote>-Zeichen definieren.</para>

      <para>Geben Sie
	<command>~sforce=Zeichen</command>
	gefolgt von <keycap>Enter</keycap> ein.  Für
	<replaceable>Zeichen</replaceable> können Sie ein beliebiges
	einzelnes Zeichen einsetzen.  Wenn Sie
	<replaceable>Zeichen</replaceable> weglassen, ist das
	<quote>force</quote>-Zeichen <quote>nul</quote>, das Sie mit
	<keycombo action="simul">
	  <keycap>Ctrl</keycap><keycap>2</keycap>
	</keycombo>
	oder
	<keycombo action="simul">
	  <keycap>Ctrl</keycap><keycap>Leertaste</keycap>
	</keycombo> eingeben können.  Ein guter Wert für
	<replaceable>Zeichen</replaceable> ist
	<keycombo action="simul">
	  <keycap>Shift</keycap>
	  <keycap>Ctrl</keycap>
	  <keycap>6</keycap>
	</keycombo>, welches nur auf wenigen Terminal Servern benutzt
	wird.</para>

      <para>Sie können das <quote>force</quote>-Zeichen auch
        bestimmen, indem Sie in <filename>&dollar;HOME/.tiprc</filename> das
        Folgende einstellen:</para>

      <programlisting>force=<replaceable>single-char</replaceable></programlisting>
    </sect2>

    <sect2 xml:id="uppercase">
      <title>Warum ist auf einmal alles was ich schreibe in
        GROSSBUCHSTABEN??</title>

      <para>Sie müssen
	<keycombo action="simul">
	  <keycap>Ctrl</keycap>
	  <keycap>A</keycap>
	</keycombo>, eingegeben haben, das <quote>raise</quote>-Zeichen von
	<command>tip</command>, das speziell für Leute mit defekten
	caps-lock Tasten eingerichtet wurde.  Benutzen Sie
	<command>~s</command> wie oben und setzen Sie die Variable
	<literal>raisechar</literal> auf etwas, das Ihnen angemessen
	erscheint.  Tatsächlich kann die Variable auf das gleiche
	Zeichen wie das <quote>force</quote>-Zeichen gesetzt werden, wenn
	Sie diese Fähigkeiten niemals benutzen wollen.</para>

      <para>Hier ist ein Muster der <filename>.tiprc</filename> Datei,
        perfekt für <application>Emacs</application> Benutzer, die oft
	<keycombo action="simul">
	  <keycap>Ctrl</keycap><keycap>2</keycap>
	</keycombo>
	und
	<keycombo action="simul">
	  <keycap>Ctrl</keycap><keycap>A</keycap>
	</keycombo>
	tippen müssen:</para>

      <programlisting>force=^^
raisechar=^^</programlisting>

      <para>Geben Sie für <literal>^^</literal>
	<keycombo action="simul">
	  <keycap>Shift</keycap><keycap>Ctrl</keycap><keycap>6</keycap>
	</keycombo> ein.</para>

    </sect2>

    <sect2 xml:id="tip-filetransfer">
      <title>Wie kann ich Dateien mit <command>tip</command>
        übertragen?</title>

      <para>Wenn Sie mit einem anderen &unix; System kommunizieren,
        können Sie mit <command>~p</command> (put) und
	<command>~t</command> (take) Dateien senden und empfangen.  Diese
	Befehle lassen <command>cat</command> und <command>echo</command>
	auf dem entfernten System laufen, um Dateien zu empfangen und zu
	senden.  Die Syntax ist:</para>

      <cmdsynopsis>
	<command>~p</command>
	<arg choice="plain">local-file</arg>
	<arg choice="opt">remote-file</arg>
      </cmdsynopsis>

      <cmdsynopsis>
	<command>~t</command>
	<arg choice="plain">remote-file</arg>
	<arg choice="opt">local-file</arg>
      </cmdsynopsis>

      <para>Es gibt keine Fehlerkontrolle, deshalb sollten Sie besser ein
        anderes Protokoll, wie zmodem, benutzen.</para>
    </sect2>

    <sect2 xml:id="zmodem-tip">
      <title>Wie kann ich zmodem mit <command>tip</command> laufen
        lassen?</title>

      <para>Um Dateien zu empfangen, starten Sie das Programm zum Senden
        auf dem entfernten Computer.  Geben Sie dann
	<command>~C rz</command> ein, um die Dateien lokal zu empfangen.</para>

      <para>Um Dateien zu senden, starten Sie das Programm zum Empfangen
        auf dem entfernten Computer.  Geben Sie dann
	<command>~C sz Dateien</command> ein,
	um Dateien auf das entfernte System zu senden.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="serialconsole-setup">
    <info><title>Einrichten der seriellen Konsole</title>
      <authorgroup>
        <author><personname><firstname>Kazutaka</firstname><surname>YOKOTA</surname></personname><contrib>Beigesteuert von </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Bill</firstname><surname>Paul</surname></personname><contrib>Auf Grundlage eines Dokuments von </contrib></author>
      </authorgroup>
    </info>
    

    <warning>
      <para>Mit &os;&nbsp;8.0 wurden die Gerätedateien für
	serielle Ports von
	<filename>/dev/ttydN</filename> in
	<filename>/dev/ttyuN</filename>
	umbenannt.  Setzen Sie noch &os;&nbsp;7.X ein, müssen
	Sie die Befehle in den folgenden Abschnitten entsprechend
	anpassen.</para>
    </warning>

    <indexterm><primary>serielle Konsole</primary></indexterm>

    <sect2 xml:id="serialconsole-intro">
      <title>Einführung</title>

      <para>FreeBSD kann ein System mit einem Dumb-Terminal (unintelligente
	Datenstation) an einer seriellen Schnittstelle als Konsole booten.
	Diese Konfiguration ist besonders nützlich für
	Systemadministratoren, die FreeBSD auf Systemen ohne Tastatur oder
	Monitor installieren wollen, und Entwickler, die den Kernel oder
	Gerätetreiber debuggen.</para>

      <para>Wie in <xref linkend="boot"/> beschrieben, besitzt FreeBSD drei
        Bootphasen.  Der Code für die ersten beiden Bootphasen befindet
	sich im Bootsektor am
	Anfang der FreeBSD-Slice der Bootplatte.  Dieser Bootblock
	lädt den Bootloader (<filename>/boot/loader</filename>) in
	Phase drei.</para>

      <para>Um eine serielle Konsole einzurichten, müssen Sie den
        Bootblock, den Bootloader und den Kernel konfigurieren.</para>
    </sect2>

    <sect2 xml:id="serialconsole-howto-fast">
      <title>Serielle Konsole einrichten, Kurzfassung</title>

      <para>Dieser Abschnitt fasst zusammen, wie Sie eine
	serielle Konsole einrichten.  Es wird vorausgesetzt, dass
	Sie die Voreinstellungen verwenden und wissen, wie
	serielle Schnittstellen verbunden werden.</para>

      <procedure>
	<step>
	  <para>Verbinden Sie die serielle Konsole mit
	    <filename>COM1</filename> sowie dem Kontrollterminal.</para>
	</step>

	<step>
	  <para>Um die Startmeldungen der seriellen Konsole zu sehen,
	    geben Sie als <systemitem class="username">root</systemitem> Folgendes ein:</para>

	<screen>&prompt.root; echo 'console="comconsole"' &gt;&gt; /boot/loader.conf</screen>

	</step>

	<step>
	  <para>Ändern Sie in <filename>/etc/ttys</filename>
	    den Eintrag für <filename>ttyu0</filename> von
	    <literal>off</literal> auf <literal>on</literal>.
	    Zusätzlich sollten Sie den Wert
	    <literal>dialup</literal> auf <literal>vt100</literal>
	    ändern.  Nur so wird auf der seriellen Konsole
	    eine Eingabeaufforderung mit einer Passwortabfrage
	    aktiviert.</para>
	</step>

	<step>
	  <para>Starten Sie nun das System neu, damit die serielle
	    Konsole aktiviert wird.</para>
	</step>
      </procedure>

      <para>Wenn Sie eine unterschiedliche Konfiguration benötigen,
        sollten Sie <xref linkend="serialconsole-howto"/> lesen.</para>
    </sect2>

    <sect2 xml:id="serialconsole-howto">
      <title>Konfiguration der Konsole</title>

      <procedure>
	<step>
	  <para>Bereiten Sie ein serielles Kabel vor.</para>

	  <indexterm><primary>Nullmodemkabel</primary></indexterm>
	  <para>Sie benötigen entweder ein Nullmodemkabel oder ein
	    serielles Standard Kabel mit einem Nullmodemkabel-Adapter.  In
	    <xref linkend="serial-cables-ports"/> wurden serielle Kabel
	    beschrieben.</para>
	</step>

	<step>
	  <para>Trennen Sie die Tastatur vom Computer.</para>

	  <para>Die meisten PC Systeme suchen beim Power On Self Test
	    (POST) nach einer Tastatur und geben eine Fehlermeldung aus,
	    wenn sie keine finden.  Einige Maschinen werden sich sogar
	    weigern, ohne Tastatur zu booten.</para>

	  <para>Wenn Ihr Rechner trotz einer Fehlermeldung normal
	    weiterbootet, brauchen Sie weiter nichts zu tun.
	    Beispielsweise geben einige Maschinen mit einem Phoenix BIOS
	    nur <errorname>Keyboard failed</errorname> aus und booten dann
	    normal weiter.</para>

	  <para>Wenn Ihr System ohne Tastatur nicht booten will,
	    müssen Sie das BIOS so konfigurieren, das es diesen Fehler
	    ignoriert (wenn das möglich ist).  Das Handbuch zu Ihrem
	    Motherboard sollte beschreiben, wie das zu bewerkstelligen
	    ist.</para>

	  <tip>
	    <para>Selbst wenn Sie im BIOS <quote>Not installed</quote>
	      für die Tastatur einstellen, können Sie eine
	      Tastatur angeschlossen haben und diese auch weiterhin
	      benutzen, da sie mit dieser Anweisung das BIOS
	      lediglich anweisen, nach dem Einschalten des Rechners nicht
	      nach einer Tastatur zu suchen und den Rechner ohne
	      entsprechende Fehlermeldung zu starten.  Wenn die oben
	      beschriebene Option nicht im BIOS vorhanden ist, halten Sie
	      stattdessen Ausschau nach einer <quote>Halt on Error</quote>
	      Option.  Sie können den gleichen Effekt wie oben erzielen,
	      wenn Sie diese Option auf <quote>All but Keyboard</quote> oder
	      sogar <quote>No Errors</quote> setzen.</para>
	  </tip>

	  <note>
	    <para>Wenn Ihr System über eine &ps2; Maus verfügt,
	      müssen Sie diese wahrscheinlich auch abziehen.  Da sich
	      die &ps2; Maus und die Tastatur einige Hardwarekomponenten
	      teilen, kann das dazu führen, dass die
	      Hardwareerkennung fälschlicherweise eine Tastatur findet,
	      wenn eine &ps2; Maus angeschlossen ist.  Gateway 2000
	      Pentium 90&nbsp;MHz Systemen wird dieses Verhalten nachgesagt.
	      Normalerweise ist das kein Problem, da eine Maus ohne
	      Tastatur sowieso nicht sinnvoll einsetzbar ist.</para>
	  </note>
	</step>

	<step>
	  <para>Schließen Sie einen Dumb-Terminal an
	    <filename>COM1</filename> (<filename>sio0</filename>)
	    an.</para>

	  <para>Wenn Sie keinen Dumb-Terminal besitzen, können Sie
	    einen alten PC/XT mit einem Terminalemulator oder die serielle
	    Schnittstelle eines anderen &unix; Rechners benutzen.  Sie
	    benötigen auf jeden Fall eine freie erste serielle
	    Schnittstelle (<filename>COM1</filename>).  Zurzeit ist es
	    nicht möglich, in den Bootblöcken eine andere
	    Schnittstelle zu konfigurieren, ohne diese neu zu kompilieren.
	    Wenn Sie <filename>COM1</filename> bereits für ein
	    anderes Gerät benutzen, müssen Sie dieses Gerät
	    temporär entfernen und einen neuen Bootblock sowie Kernel
	    installieren, wenn Ihr FreeBSD erst einmal installiert ist.
	    Auf einem Server sollte <filename>COM1</filename> ohnehin
	    verfügbar sein.  Wenn Sie die Schnittstelle für ein
	    anderes Gerät benutzen und Sie dieses nicht auf
	    <filename>COM2</filename> (<filename>sio1</filename>)
	    legen können, sollten Sie sich nicht an erster Stelle mit
	    dem Aufsetzen einer seriellen Konsole beschäftigen.</para>
	</step>

	<step>
	  <para>Stellen Sie sicher, dass Ihre Kernelkonfiguration die
	    richtigen Optionen für <filename>COM1</filename>
	    (<filename>sio0</filename>) enthält.</para>

	  <para>Relevante Optionen sind:</para>

	  <variablelist>
	    <varlistentry>
	      <term><literal>0x10</literal></term>

	      <listitem>
		<para>Aktiviert die Konsolenunterstützung für
		  dieses Gerät.  Zurzeit kann nur ein Gerät die
		  Konsolenunterstützung aktiviert haben.  Das erste,
		  in der Konfigurationsdatei aufgeführte Gerät,
		  mit dieser Option, verfügt über eine aktivierte
		  Konsolenunterstützung.  Beachten Sie, dass
		  diese Option alleine nicht ausreicht, um die serielle
		  Konsole zu aktivieren.  Setzen Sie entweder noch die
		  nachfolgend diskutierte Option oder verwenden Sie beim
		  Booten, wie unten beschrieben, den Schalter
		  <option>-h</option>.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>0x20</literal></term>

	      <listitem>
		<para>Das erste Gerät in der Kernelkonfigurationsdatei
		  mit dieser Option wird, unabhängig von dem unten
		  diskutierten Schalter <option>-h</option>, zur Konsole.
		  Die Option <option>0x20</option> muss zusammen mit
		  <option>0x10</option> verwendet werden.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>0x40</literal></term>

	      <listitem>
		<para>Reserviert dieses Gerät und sperrt es für
		  normale Zugriffe.  Sie sollten diese Option nicht auf dem
		  Gerät setzen, das Sie als serielle Konsole verwenden
		  wollen.  Der Zweck dieser Option ist es, dieses
		  Gerät für das Remote-Debuggen zu reservieren.
		  Das <link xlink:href="&url.books.developers-handbook.en;/index.html">
		    FreeBSD Developers' Handbook</link> enthält dazu weitere
		  Informationen.</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Beispiel:</para>

	  <programlisting>device sio0 at isa? port IO_COM1 tty flags 0x10 irq 4</programlisting>

	  <para>Weitere Einzelheiten entnehmen Sie bitte
	    &man.sio.4;.</para>

	  <para>Wenn diese Optionen nicht gesetzt sind, müssen Sie auf
	    einer anderen Konsole beim Booten UserConfig starten oder den
	    Kernel neu kompilieren.</para>
	</step>

	<step>
	  <para>Erstellen Sie <filename>boot.config</filename> im
	    Rootverzeichnis der <literal>a</literal>-Partition des
	    Bootlaufwerks.</para>

	  <para>Der Code des Bootblocks entnimmt dieser Datei, wie Sie Ihr
	    System booten möchten.  Um die serielle Konsole zu
	    aktivieren, müssen Sie hier eine oder mehrere Optionen
	    (alle in derselben Zeile) angeben.  Die folgenden Optionen
	    stehen zur Auswahl der Konsole zur Verfügung:</para>

	  <variablelist>
	    <varlistentry>
	      <term><option>-h</option></term>

	      <listitem>
		<para>Schaltet zwischen der internen und der seriellen
		  Konsole um.  Wenn Sie beispielsweise von der internen
		  Konsole (Bildschirm) booten, weist <option>-h</option>
		  den Bootloader und den Kernel an, die serielle
		  Schnittstelle als Konsole zu nehmen.  Wenn die Konsole
		  normal auf der seriellen Schnittstelle liegt, wählen
		  Sie mit <option>-h</option> den Bildschirm aus.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><option>-D</option></term>

	      <listitem>
		<para>Schaltet zwischen Einzelkonsole und Dual-Konsole um.
		  Die Einzelkonsole ist entweder die interne Konsole
		  (der Bildschirm) oder die serielle Schnittstelle, je nach
		  dem Stand von <option>-h</option>.  Im
		  Dual-Konsolen Betrieb ist die Konsole, unabhängig
		  von <option>-h</option>, gleichzeitig der Bildschirm und
		  die serielle Schnittstelle.  Dies trifft aber nur zu,
		  wenn der Bootblock ausgeführt wird.  Sobald der
		  Bootloader ausgeführt wird, wird die durch
		  <option>-h</option> gegebene Konsole die alleinige
		  Konsole.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><option>-P</option></term>

	      <listitem>
		<para>Veranlasst den Bootblock nach einer Tastatur zu
		  suchen.  Wenn keine Tastatur gefunden wird, werden
		  <option>-D</option> und <option>-h</option> automatisch
		  gesetzt.</para>

		<note>
		  <para>Wegen Platzbeschränkungen in den
		    Bootblöcken kann <option>-P</option> nur
		    erweiterte Tastaturen erkennen.  Tastaturen mit weniger
		    als 101 Tasten (und ohne F11 und F12 Tasten) werden
		    wahrscheinlich, wie vielleicht auch die Tastaturen
		    einiger Laptops, nicht erkannt.  Wenn dies bei Ihrem
		    System der Fall ist, können Sie <option>-P</option>
		    nicht verwenden, da es leider noch keine Umgehung
		    für dieses Problem gibt.</para>
		</note>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Benutzen Sie also entweder <option>-P</option>, um die
	    Konsole automatisch zu setzen, oder <option>-h</option>, um die
	    serielle Konsole zu verwenden.</para>

	  <para>In <filename>boot.config</filename> können Sie auch
	    andere, in &man.boot.8; beschriebene Optionen,
	    aufnehmen.</para>

	  <para>Mit Ausnahme von <option>-P</option> werden die Optionen an
	    den Bootloader (<filename>/boot/loader</filename>)
	    weitergegeben.  Der Bootloader untersucht dann einzig
	    <option>-h</option> um festzustellen, welches Gerät die
	    Konsole wird.  Wenn Sie also nur <option>-D</option> angegeben
	    haben, können Sie die serielle Schnittstelle nur als
	    Konsole verwenden während der Bootblock ausgeführt
	    wird.  Danach wird der Bootloader, da ja <option>-h</option>
	    fehlt, den Bildschirm zur Konsole machen.</para>
	</step>

	<step>
	  <para>Booten Sie die Maschine.</para>

	  <para>Wenn Sie das FreeBSD-System starten, werden die
	    Bootblöcke den Inhalt von <filename>/boot.config</filename>
	    auf der Konsole ausgeben:</para>

	  <screen>/boot.config: -P
Keyboard: no</screen>

	  <para>Die zweite Zeile sehen Sie nur, wenn Sie in
	    <filename>/boot.config</filename> <option>-P</option> angegeben
	    haben.  Sie zeigt an, ob eine Tastatur angeschlossen ist oder
	    nicht.  Die Meldungen gehen je nach den Einstellungen in
	    <filename>/boot.config</filename> auf die interne Konsole, die
	    serielle Konsole, oder beide Konsolen.</para>

	  <informaltable frame="none" pgwide="1">
	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry align="left">Optionen</entry>
		  <entry align="left">Meldungen erscheinen auf</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>keine</entry>
		  <entry>der internen Konsole</entry>
		</row>

		<row>
		  <entry><option>-h</option></entry>
		  <entry>der seriellen Konsole</entry>
		</row>

		<row>
		  <entry><option>-D</option></entry>
		  <entry>der seriellen und der internen Konsole</entry>
		</row>

		<row>
		  <entry><option>-Dh</option></entry>
		  <entry>der seriellen und der internen Konsole</entry>
		</row>

		<row>
		  <entry><option>-P</option>, mit Tastatur</entry>
		  <entry>der internen Konsole</entry>
		</row>

		<row>
		  <entry><option>-P</option>, ohne Tastatur</entry>
		  <entry>der seriellen Konsole</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>

	  <para>Nach den oben gezeigten Meldungen gibt es eine kleine
	    Verzögerung bevor die Bootblöcke den Bootloader
	    laden und weitere Meldungen auf der Konsole erscheinen.  Sie
	    können die Ausführung der Bootblöcke
	    unterbrechen, um zu überprüfen, ob auch alles richtig
	    aufgesetzt ist, brauchen das aber unter normalen Umständen
	    nicht zu tun.</para>

	  <para>Drücken Sie eine Taste außer
	    <keycap>Enter</keycap> um den Bootvorgang zu unterbrechen.  Sie
	    erhalten dann ein Prompt, an dem Sie weitere Eingaben
	    tätigen können:</para>

	  <screen>&gt;&gt; FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:</screen>

	  <para>Je nach Inhalt von <filename>/boot.config</filename>
	    erscheint das Prompt auf der seriellen Konsole, der internen
	    Konsole oder beiden Konsolen.  Wenn die Meldung auf der
	    richtigen Konsole erscheint, drücken Sie
	    <keycap>Enter</keycap> um fortzufahren.</para>

	  <para>Wenn Sie das Prompt auf der seriellen Konsole erwartet
	    haben, dort aber nichts sehen, liegt ein Fehler in Ihren
	    Einstellungen vor.  Als Umgehung geben Sie an der momentanen
	    Konsole <option>-h</option> ein, um den Bootblock und den
	    Bootloader auf die serielle Konsole umzustellen.  Führen
	    Sie dann den Bootvorgang mit <keycap>Enter</keycap> weiter
	    und wenn das System gebootet hat, können Sie die
	    fehlerhaften Einstellungen korrigieren.</para>
	</step>
      </procedure>

      <para>Nachdem der Bootloader geladen wurde und Sie sich in der
        dritten Bootphase befinden, können Sie immer noch zwischen der
	internen und der seriellen Konsole auswählen.  Setzen Sie dazu,
	wie in <xref linkend="serialconsole-loader"/> beschrieben, die
	entsprechenden Variablen des Bootloaders.</para>
    </sect2>

  <sect2 xml:id="serialconsole-summary">
    <title>Zusammenfassung</title>

      <para>Die folgende Übersicht zeigt, welche Konsole, abhängig
	von den getroffenen Einstellungen, ausgewählt wird.</para>

      <sect3>
	<title>Fall 1: Option 0x10 für
	  <filename>sio0</filename></title>

	<programlisting>device sio0 at isa? port IO_COM1 tty flags 0x10 irq 4</programlisting>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="4">
	    <thead>
	      <row>
		<entry align="left">Optionen in <filename>/boot.config</filename></entry>
		<entry align="left">Konsole in den Bootblöcken</entry>
		<entry align="left">Konsole im Bootloader</entry>
		<entry align="left">Konsole im Kernel</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry>keine</entry>
		<entry>interne</entry>
		<entry>interne</entry>
		<entry>interne</entry>
	      </row>

	      <row>
		<entry><option>-h</option></entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
	      </row>

	      <row>
		<entry><option>-D</option></entry>
		<entry>serielle und interne</entry>
		<entry>interne</entry>
		<entry>interne</entry>
	      </row>

	      <row>
		<entry><option>-Dh</option></entry>
		<entry>serielle und interne</entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
	      </row>

	      <row>
		<entry><option>-P</option>, mit Tastatur</entry>
		<entry>interne</entry>
		<entry>interne</entry>
		<entry>interne</entry>
	      </row>

	      <row>
		<entry><option>-P</option>, ohne Tastatur</entry>
		<entry>serielle und interne</entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>

      <sect3>
	<title>Fall 2: Option 0x30 für
	  <filename>sio0</filename></title>

	<programlisting>device sio0 at isa? port IO_COM1 tty flags 0x30 irq 4</programlisting>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="4">
	    <thead>
	      <row>
		<entry align="left">Optionen in <filename>/boot.config</filename></entry>
		<entry align="left">Konsole in den Bootblöcken</entry>
		<entry align="left">Konsole im Bootloader</entry>
		<entry align="left">Konsole im Kernel</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry>keine</entry>
		<entry>interne</entry>
		<entry>interne</entry>
		<entry>serielle</entry>
	      </row>

	      <row>
		<entry><option>-h</option></entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
	      </row>

	      <row>
		<entry><option>-D</option></entry>
		<entry>serielle und interne</entry>
		<entry>interne</entry>
		<entry>serielle</entry>
	      </row>

	      <row>
		<entry><option>-Dh</option></entry>
		<entry>serielle und interne</entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
	      </row>

	      <row>
		<entry><option>-P</option>, mit Tastatur</entry>
		<entry>interne</entry>
		<entry>interne</entry>
		<entry>serielle</entry>
	      </row>

	      <row>
		<entry><option>-P</option>, ohne Tastatur</entry>
		<entry>serielle und interne</entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>
    </sect2>

    <sect2 xml:id="serialconsole-tips">
      <title>Hinweise zur seriellen Konsole</title>

      <sect3>
	<title>Verwenden einer höheren Geschwindigkeit</title>

	<para>Die Vorgabewerte für die Kommunikationsparameter der
	  seriellen Schnittstelle sind: 9600&nbsp;baud, 8&nbsp;Bit, keine
	  Parität und ein Stopp-Bit.  Wenn Sie die
	  Standardgeschwindigkeit ändern wollen, haben Sie folgende
	  Möglichkeiten:</para>

	<itemizedlist>
	  <listitem>
	    <para>Geben Sie die neue Konsolengeschwindigkeit mit
	      <varname>BOOT_COMCONSOLE_SPEED</varname> an und
	      kompilieren Sie die Bootblöcke neu.  Ausführliche
	      Informationen zum Bau und zur Installation von neuen
	      Bootblöcken finden Sie im
	      <xref linkend="serialconsole-com2"/> des Handbuchs.</para>

	    <para>Wenn die serielle Konsole nicht mit der Option
	      <option>-h</option> gestartet wird,
	      oder wenn die verwendete serielle Konsole sich von
	      der von den Bootblöcken verwendeten unterscheidet,
	      müsssen Sie zusätzlich die folgende Option in
	      Ihre Kernelkonfigurationsdatei aufnehmen und den Kernel
	      neu bauen:</para>

	    <programlisting>options CONSPEED=19200</programlisting>
	  </listitem>

	  <listitem>
	    <para>Verwenden Sie die Option <option>-S</option>, um den
	      Kernel zu booten.  Die Option <option>-S</option> kann
	      auch in die Datei <filename>/boot.config</filename>
	      aufgenommen werden.  Eine Beschreibung dieses Vorgangs
	      sowie eine Auflistung der von
	      <filename>/boot.config</filename> unterstützten
	      Optionen finden Sie in der Manualpage &man.boot.8;.</para>
	  </listitem>

	  <listitem>
	    <para>Aktivieren Sie die Option
	      <varname>comconsole_speed</varname> in der Datei
	      <filename>/boot/loader.conf</filename>.</para>

	    <para>Diese Option setzt voraus, dass auch die Optionen
	      <varname>console</varname>,
	      <varname>boot_serial</varname>, sowie
	      <varname>boot_multicons</varname> in der Datei
	      <filename>/boot/loader.conf</filename> gesetzt sind.
	      Im Folgenden finden Sie ein Beispiel, in dem
	      <varname>comconsole_speed</varname> verwendet wird,
	      um die Geschwindigkeit der seriellen Konsole zu
	      ändern:</para>

	    <programlisting>boot_multicons="YES"
boot_serial="YES"
comconsole_speed="115200"
console="comconsole,vidconsole"</programlisting>
	  </listitem>
	</itemizedlist>
      </sect3>

      <sect3 xml:id="serialconsole-com2">
	<title>Eine andere Schnittstelle als <filename>sio0</filename>
	  benutzen</title>

	<para>Wenn Sie, warum auch immer, ein anderes Gerät als
	  <filename>sio0</filename> für die serielle Konsole
	  einsetzen wollen, kompilieren Sie bitte die Bootblöcke, den
	  Bootloader und den Kernel nach dem folgenden Verfahren
	  neu.</para>

	<procedure>
	  <step>
	    <para>Installieren Sie die Kernelquellen (siehe
	      <xref linkend="updating-upgrading"/>).</para>
	  </step>

	  <step>
	    <para>Setzen Sie in <filename>/etc/make.conf</filename>
	      <literal>BOOT_COMCONSOLE_PORT</literal> auf die Adresse der
	      Schnittstelle (0x3F8, 0x2F8, 0x3E8 oder 0x2E8), die Sie
	      benutzen möchten.  Sie können nur
	      <filename>sio0</filename> bis
	      <filename>sio3</filename> (<filename>COM1</filename>
	      bis <filename>COM4</filename>) benutzen, Multiportkarten
	      können Sie nicht als Konsole benutzen.  Interrupts
	      müssen Sie hier nicht angeben.</para>
	  </step>

	  <step>
	    <para>Erstellen Sie eine angepasste Kernelkonfiguration
	      und geben Sie dort die richtigen Optionen für die
	      Schnittstelle, die Sie benutzen möchten, an.  Wenn Sie
	      zum Beispiel <filename>sio1</filename>
	      (<filename>COM2</filename>) zur Konsole machen wollen,
	      geben Sie dort entweder</para>

	    <programlisting>device sio1 at isa? port IO_COM2 tty flags 0x10 irq 3</programlisting>

	    <para>oder</para>

	    <programlisting>device sio1 at isa? port IO_COM2 tty flags 0x30 irq 3</programlisting>

	    <para>an.  Keine andere serielle Schnittstelle sollte als
	      Konsole definiert werden.</para>
	  </step>

	  <step>
	    <para>Übersetzen und installieren Sie die
	      Bootblöcke und den Bootloader:</para>

	    <screen>&prompt.root; <userinput>cd /sys/boot</userinput>
&prompt.root; <userinput>make clean</userinput>
&prompt.root; <userinput>make</userinput>
&prompt.root; <userinput>make install</userinput></screen>
	  </step>

	  <step>
	    <para>Bauen und installieren Sie einen neuen Kernel.</para>
	  </step>

	  <step>
	    <para>Schreiben Sie die Bootblöcke mit &man.bsdlabel.8;
	      auf die Bootplatte und booten Sie den neuen Kernel.</para>
	  </step>
	</procedure>
      </sect3>

      <sect3 xml:id="serialconsole-ddb">
	<title>DDB Debugger über die serielle Schnittstelle</title>

	<para>Wenn Sie den Kerneldebugger über eine serielle
	  Verbindung bedienen möchten (nützlich, kann aber
	  gefährlich sein, wenn auf der Leitung falsche BREAK-Signale
	  generiert werden), sollten Sie einen Kernel mit
	  den folgenden Optionen erstellen:</para>

	<programlisting>options BREAK_TO_DEBUGGER
options DDB</programlisting>
      </sect3>

      <sect3>
	<title>Benutzung der seriellen Konsole zum Anmelden</title>

	<para>Da Sie schon die Bootmeldungen auf der Konsole verfolgen
	  können und den Kerneldebugger über die Konsole bedienen
	  können, wollen Sie sich vielleicht auch an der Konsole
	  anmelden.</para>

	<para>Öffnen Sie <filename>/etc/ttys</filename> in einem
	  Editor und suchen Sie nach den folgenden Zeilen:</para>

      <programlisting>ttyu0 "/usr/libexec/getty std.9600" unknown off secure
ttyu1 "/usr/libexec/getty std.9600" unknown off secure
ttyu2 "/usr/libexec/getty std.9600" unknown off secure
ttyu3 "/usr/libexec/getty std.9600" unknown off secure</programlisting>

	<para><filename>ttyu0</filename> bis <filename>ttyu3</filename>
	  entsprechen <filename>COM1</filename> bis
	  <filename>COM4</filename>.  Ändern Sie für die
	  entsprechende Schnittstelle <literal>off</literal> zu
	  <literal>on</literal>.  Wenn Sie auch die Geschwindigkeit der
	  seriellen Schnittstelle geändert haben, müssen Sie
	  <literal>std.9600</literal> auf die momentane Geschwindigkeit, zum
	  Beispiel <literal>std.19200</literal>, anpassen.</para>

	<para>Sie sollten auch den Terminaltyp von
	  <literal>unknown</literal> auf den tatsächlich verwendeten
	  Terminal setzen.</para>

	<para>Damit die Änderungen an der Datei wirksam werden,
	  müssen Sie noch <command>kill -HUP 1</command>
	  absetzen.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="serialconsole-loader">
      <title>Die Konsole im Bootloader ändern</title>

      <para>In den vorigen Abschnitten wurde beschrieben, wie Sie die
        serielle Konsole durch Änderungen im Bootblock aktivieren.
	Dieser Abschnitt zeigt Ihnen, wie Sie mit Kommandos und
	Umgebungsvariablen die Konsole im Bootloader definieren.  Da der
	Bootloader die dritte Phase im Bootvorgang ist und nach den
	Bootblöcken ausgeführt wird, überschreiben
	seine Einstellungen die des Bootblocks.</para>

      <sect3>
	<title>Festlegen der Konsole</title>

	<para>Mit einer einzigen Zeile in
	  <filename>/boot/loader.conf</filename> können Sie den
	  Bootloader und den Kernel anweisen, die serielle Schnittstelle
	  zur Konsole zu machen:</para>

	<programlisting>console="comconsole"</programlisting>

	<para>Unabhängig von den Einstellungen im Bootblock legt dies
	  die Konsole fest.</para>

	<para>Die obige Zeile sollte die erste Zeile in
	  <filename>/boot/loader.conf</filename> sein, so dass Sie die
	  Bootmeldungen so früh wie möglich auf der Konsole
	  sehen.</para>

	<para>Analog können Sie die interne Konsole verwenden:</para>

	<programlisting>console="vidconsole"</programlisting>

	<para>Wenn Sie <envar>console</envar> nicht setzen, bestimmt der
	  Bootloader (und damit auch der Kernel) die Konsole über
	  die <option>-h</option> Option des Bootblocks.</para>

	<para>Sie können die Bootkonsole in
	  <filename>/boot/loader.conf.local</filename> oder
	  <filename>/boot/loader.conf</filename> angeben.</para>

	<para>Weitere Informationen erhalten Sie in &man.loader.conf.5;.</para>

	<note>
	  <para>Momentan gibt es im Bootloader nichts vergleichbares zu
	    <option>-P</option> im Bootblock.  Damit kann die Konsole nicht
	    automatisch über das Vorhandensein einer Tastatur
	    festgelegt werden.</para>
	</note>
      </sect3>

      <sect3>
	<title>Eine andere Schnittstelle als <filename>sio0</filename>
	  benutzen</title>

	<para>Sie müssen den Bootloader neu kompilieren, wenn Sie eine
	  andere Schnittstelle als <filename>sio0</filename> benutzen
	  wollen.  Folgen Sie der Anleitung aus
	  <xref linkend="serialconsole-com2"/>.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="serialconsole-caveats">
      <title>Vorbehalte</title>

      <para>Hinter dem ganzen steckt die Idee, Server ohne Hardware
        für Grafik und ohne Tastatur zu betreiben.  Obwohl es die
	meisten Systeme erlauben, ohne Tastatur zu booten, gibt es leider
	nur wenige Systeme, die ohne eine Grafikkarte booten.  Maschinen
	mit einem AMI BIOS können ohne Grafik booten, indem Sie den
	Grafikadapter im CMOS-Setup auf <literal>Not installed</literal>
	setzen.</para>

      <para>Viele Maschinen unterstützen diese Option allerdings nicht.
        Damit diese Maschinen booten, müssen sie über eine
	Grafikkarte, auch wenn es nur eine alte Monochromkarte ist,
	verfügen.  Allerdings brauchen Sie keinen Monitor an die Karte
	anzuschließen.  Sie können natürlich auch
	versuchen, auf diesen Maschinen ein AMI BIOS zu
	installieren.</para>
    </sect2>
  </sect1>
</chapter>
