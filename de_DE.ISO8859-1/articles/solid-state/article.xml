<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE article PUBLIC "-//FreeBSD//DTD DocBook XML V5.0-Based Extension//EN"
	"http://www.FreeBSD.org/XML/share/xml/freebsd50.dtd">
<!-- Copyright (c) 2001 The FreeBSD Documentation Project

     Redistribution and use in source (SGML DocBook) and 'compiled' forms
     (SGML, HTML, PDF, PostScript, RTF and so forth) with or without
     modification, are permitted provided that the following conditions
     are met:

      1. Redistributions of source code (SGML DocBook) must retain the above
         copyright notice, this list of conditions and the following
         disclaimer as the first lines of this file unmodified.

      2. Redistributions in compiled form (transformed to other DTDs,
         converted to PDF, PostScript, RTF and other formats) must reproduce
         the above copyright notice, this list of conditions and the
         following disclaimer in the documentation and/or other materials
         provided with the distribution.

     THIS DOCUMENTATION IS PROVIDED BY THE FREEBSD DOCUMENTATION PROJECT "AS
     IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
     THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NIK CLAYTON BE LIABLE FOR ANY
     DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
     OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
     STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
     ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF THE
     POSSIBILITY OF SUCH DAMAGE.

     $FreeBSD$
     $FreeBSDde: de-docproj/articles/solid-state/article.xml,v 1.2 2010/09/18 21:55:49 jkois Exp $
     basiert auf: 1.18
-->
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="de">
  <info><title>&os; und Solid State-Geräte</title>
    

    <authorgroup>
      <author><personname><firstname>John</firstname><surname>Kozubik</surname></personname><affiliation>
	  <address><email>john@kozubik.com</email></address>
	</affiliation></author>
    </authorgroup>

    <copyright>
      <year>2001</year>
      <year>2009</year>
      <holder>The FreeBSD Documentation Project</holder>
    </copyright>

    <legalnotice xml:id="trademarks" role="trademarks">
      &tm-attrib.freebsd;
      &tm-attrib.general;
    </legalnotice>

    &legalnotice;

    <pubdate>$FreeBSD$</pubdate>

    <releaseinfo>$FreeBSD$</releaseinfo>

    <abstract>
      <para>Dieser Artikel behandelt die Verwendung von Solid State Festplatten
        in &os;, um eingebettete Systeme zu erstellen.</para>

      <para>Eingebettete Systeme haben den Vorteil, dass sie eine
	höhere Stabilität aufgrund des fehlens von beweglichen
	Bauteilen (Festplatten) besitzen.  Es muss jedoch beachtet
	werden, dass generell weniger Speicherplatz zur Verfügung
	steht und die Lebensdauer des Speichermediums geringer
	ist.</para>

      <para>Spezielle Themen die behandelt werden beinhalten die Typen
	und Attribute von Solid State Datenträgern, die in &os;
	verwendet werden, Kernel-Optionen die in solch einer Umgebung
	von Interesse sind, der
	<filename>rc.initdiskless</filename>-Mechanismus, welcher die
	Initalisierung solcher Systeme automatisiert, sowie die
	Notwendigkeit von Nur-Lese-Dateisystemen und das Erstellen von
	Dateisystemen von Grund auf.  Der Artikel schliesst mit ein
	paar generellen Strategien für kleine und Nur-Lese-&os;
	Umgebungen.</para>

      <para><emphasis>Übersetzt von Benedict
	  Reuschling</emphasis>.</para>
    </abstract>
  </info>

  <sect1 xml:id="intro">
    <title>Solid State Festplattengeräte</title>

    <para>Der Umfang des Artikels ist auf Solid State Geräte
      beschränkt, die auf Flash-Speicher basieren.  Flash-Speicher ist
      ein Solid State Speicher (keine beweglichen Teile), der nicht
      flüchtig ist (der Speicher behält die Daten sogar nachdem alle
      Energiequellen ausgeschaltet wurden).  Flash-Speicher kann
      grossen physischen Schock aushalten und ist vergleichsweise
      schnell (die Flash-Speicher Lösungen, die in diesem Artikel
      behandelt werden, sind nur wenig langsamer als eine
      EIDE-Festplatte in der Schreibgeschwindigkeit und viel schneller
      bei Lese-Operationen).  Ein sehr wichtiger Aspekt von
      Flash-Speichern, dessen Auswirkungen später in diesem Artikel
      diskutiert werden, ist, dass jeder Sektor eine begrenzte
      Kapazität zur Wiederbeschreibung besitzt.  Man kann nur eine
      bestimmte Anzahl von Schreib-, Lösch- und
      Wiederbeschreibungsvorgängen durchführen, bevor der Sektor
      permanent unbrauchbar wird.  Obwohl viele Flash-Speicher
      Produkte automatisch schlechte Blöcke markieren und manche
      Geräte Schreiboperationen gleichmässig verteilen, bleibt
      weiterhin die Anzahl der durchführbaren Schreibvorgänge
      begrenzt.  Verschiedene Geräteeinheiten besitzen zwischen
      1,000,000 und 10,000,000 Schreibzyklen pro Sektor in ihren
      Spezifikationen.  Diese Zahlen variieren aufgrund der
      Umgebungstemperatur.</para>

    <para>Im Speziellen werden wir ATA-kompatible Compact-Flash-Karten
      betrachten, welche als Speichermedien für Digitalkameras
      ziemlich populär sind.  Von besonderem Interesse ist der
      Umstand, dass diese direkt an den IDE-Bus angeschlossen werden
      und kompatibel zu den ATA-Befehlen sind.  Aus diesem Grund
      können diese Geräte mit einem einfachen und billigen Adapter
      direkt an den IDE-Bus eines Computers angeschlossen werden.  Auf
      diese Weise sehen Betriebssysteme wie &os; diese Geräte dann als
      normale (wenn auch sehr kleine) Festplatten an.</para>

    <para>Andere Solid State Plattenlösungen existieren, jedoch
      platzieren deren Kosten, Obskurität und ihre Unhandlichkeit sie
      aussserhalb des Umfangs dieses Artikels.</para>
  </sect1>

  <sect1 xml:id="kernel">
      <title>Kerneloptionen</title>

    <para>Ein paar Kerneloptionen sind von besonderem Interesse für
      diejenigen, welche diese eingebetteten &os;-Systeme erstellen
      möchten.</para>

    <para>Alle eingebetteten &os;-Systeme, die Flash-Speicher als
      Systemplatte verwenden, sind interessant für Dateisysteme im
      Hauptspeicher und RAM-Disks.  Wegen der begrenzten Anzahl von
      Schreibzyklen, die auf Flash-Speicher durchgeführt werden
      können, werden die Platte und die Dateisysteme darauf mit
      grosser Wahrscheinlichkeit nur lesend eingehängt werden.  In
      dieser Umgebung werden Dateisysteme wie
      <filename>/tmp</filename> und <filename>/var</filename> als
      RAM-Disks eingebunden, um dem System zu erlauben, Logdateien
      anzulegen und Zähler sowie temporäre Dateien zu aktualisieren.
      RAM-Disks sind eine kritische Komponente für eine erfolgreiche
      Solid State Umsetzung in &os;.</para>

    <para>Sie sollten dafür sorgen, dass die folgenden Zeilen in Ihrer
      Kernelkonfigurationsdatei vorhanden sind:</para>

    <programlisting>options         MFS             # Memory Filesystem
options         MD_ROOT         # md device usable as a potential root device
pseudo-device   md              # memory disk</programlisting>
  </sect1>

  <sect1 xml:id="ro-fs">
    <title>Die <literal>rc</literal>-Subsysteme und nur-Lese
      Dateisysteme</title>

    <para>Die Initialisierung nach dem Bootvorgang eines eingebetteten
      &os;-Systems wird von <filename>/etc/rc.initdiskless</filename>
      kontrolliert.</para>

    <para><filename>/etc/rc.d/var</filename> hängt
      <filename>/var</filename> als RAM-Disk ein, erstellt eine
      konfigurierbare Liste von Verzeichnissen in
      <filename>/var</filename> mittels des &man.mkdir.1;-Kommandos
      und ändert die Attribute von ein paar dieser Verzeichnisse.  Bei
      der Ausführung von <filename>/etc/rc.d/var</filename> kommt eine
      andere <filename>rc.conf</filename>-Variable ins Spiel:
      <literal>varsize</literal>.  Die Datei <filename>/etc/rc.d/var</filename>
      erstellt eine <filename>/var</filename>-Partition basierend auf
      dem Wert dieser Variable in <filename>rc.conf</filename>:</para>

    <programlisting>varsize=8192</programlisting>

    <para>Standardmässig wird dieser Wert in Sektoren
      angegeben.</para>

    <para>Der Fakt, dass es sich bei <filename>/var</filename> um ein
      nur-Lese Dateisystem handelt, ist eine wichtige Unterscheidung,
      da die <filename>/</filename>-Partition (und jede andere
      Partition, die Sie auf Ihrem Flash-Medium haben) nur lesend
      eingehängt wird.  Erinnern Sie sich, dass in <xref linkend="intro"/> die Beschränkungen von Flash-Speichern
      erläutert wurden, speziell deren begrenzte Kapazität zum
      Schreiben.  Die Notwendigkeit, Dateisysteme auf Flash-Speichern
      nur lesend einzubinden und keine Swap-Dateien zu verwenden, kann
      nicht oft genug erwähnt werden.  Eine Swap-Datei auf einem
      ausgelasteten System kann in weniger als einem Jahr den gesamten
      Flash-Speicher aufbrauchen. Häufige Protokollierung oder das
      Erstellen und Löschen von temporären Dateien kann das gleiche
      verursachen.  Aus diesem Grund sollten Sie zusätzlich zum
      entfernen des <literal>swap</literal>-Eintrags aus ihrer
      <filename>/etc/fstab</filename>-Datei auch noch die
      Optionsfelder für jedes Dateisystem auf <literal>ro</literal>
      wie folgt stellen:</para>

    <programlisting># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ad0s1a             /               ufs     ro              1       1</programlisting>

    <para>Ein paar Anwendungen im normalen System werden sofort nach
      dieser Änderung ausfallen.  Beispielsweise wird Cron nicht
      richtig funktionieren, aufgrund von fehlenden Cron-Tabellen in
      <filename>/var</filename> die von
      <filename>/etc/rc.d/var</filename> erstellt wurden.  Syslog und
      DHCP werden ebenfalls Probleme durch das nur-Lese Dateisystem
      und fehlende Elemente im Verzeichnis <filename>/var</filename>
      verursachen, die <filename>/etc/rc.d/var</filename> erstellt
      hat.  Diese Probleme sind jedoch nur vorübergehend und werden
      zusammen mit Lösungen zur Ausführung von anderen gebräuchlichen
      Softwarepaketen in <xref linkend="strategies"/>
      angesprochen.</para>

    <para>Eine wichtige Sache, an die man sich erinnern sollte, ist,
      dass ein Dateisystem, welches als nur lesend in
      <filename>/etc/fstab</filename> eingebunden wurde, jederzeit als
      schreibend durch das folgende Kommando eingehängt werden
      kann:</para>

    <screen>&prompt.root; <userinput>/sbin/mount -uw partition</userinput></screen>

    <para>und auch wieder zurück auf nur lesend durch den Befehl:</para>

    <screen>&prompt.root; <userinput>/sbin/mount -ur partition</userinput></screen>
  </sect1>

  <sect1>
    <title>Ein Dateisystem von Grund auf neu erstellen</title>

    <para>Wenn ATA-kompatible Compact-Flash-Karten von &os; als
      normale IDE-Festplatten erkannt werden, könnten Sie theoretisch
      &os; aus dem Netzwerk mittels der Kern- und mfsroot-Floppies
      oder einer CD installieren.</para>

    <para>Jedoch kann selbst eine kleine Installation von &os; durch
      die normale Installationsprozedur ein System erzeugen, dass
      grösser als 200&nbsp;MB ist.  Da die meisten Leute kleinere
      Flash-Speichermedien einsetzen (128&nbsp;MB wird hier als gross
      angesehen - 32 oder sogar 16&nbsp;MB sind gebräuchlich) ist eine
      gewöhnliche Installation mit normalen Methoden nicht möglich, da
      es einfach nicht genug freien Plattenplatz gibt, selbst für die
      kleinste Installationsart.</para>

    <para>Der einfachste Weg, diese Speicherlimitierung zu umgehen,
      ist, &os; auf konventionelle Weise auf eine normale Festplatte
      zu installieren.  Nachdem die Installation abgeschlossen wurde,
      kürzen Sie das Betriebssystem auf das nötigste, bis Sie eine
      Grösse erreicht hat, die auf das Flash-Medium passt und benutzen
      Sie dann tar auf dem gesamten Dateisystem.  Die folgenden
      Schritte werden Sie durch den Prozess der Vorbereitung eines
      Flash-Mediums für ihr getartes Dateisystem führen.  Beachten
      Sie, dass Operationen wie Partitionierung, Benennung, Erstellung
      von Dateisystemen, etc. von Hand durchgeführt werden müssen, da
      eine normale Installation nicht möglich ist.  Zusätzlich zu den
      Kern- und mfsroot-Disketten benötigen Sie auch die
      fixit-Floppy.</para>

    <procedure>
      <step>
	<title>Partitionierung Ihrer Flash-Medien</title>

	<para>Wählen Sie nach dem Starten der Kern- und
	  mfsroot-Disketten, <literal>custom</literal> aus dem
	  Installationsmenü.  In diesem Menü wählen Sie dann
	  <literal>partition</literal> aus.  Dort sollten Sie alle
	  bestehenden Partitionen mit Hilfe der Taste
	  <keycap>d</keycap> löschen.  Nachdem alle bestehenden
	  Partitionen gelöscht wurden, erstellen Sie mittels der Taste
	  <keycap>c</keycap> eine Partition und akzeptieren Sie den
	  Standardwert für die Grösse der Partition.  Wenn Sie nach
	  dem Typ der Partition gefragt werden, stellen Sie sicher,
	  dass der Wert auf <literal>165</literal> eingestellt ist.
	  Schreiben Sie jetzt diese Partitionstabelle auf die Platte
	  durch betätigen der Taste <keycap>w</keycap> (dies ist die
	  versteckte Option auf diesem Bildschirm).  Wenn Sie eine
	  ATA-kompatible Compact Flash-Karte verwenden, sollten Sie
	  den &os; Bootmanager auswählen.  Drücken Sie nun die Taste
	  <keycap>q</keycap>, um das Partitionsmenü zu verlassen.  Sie
	  werden das Menü des Bootmanagers noch ein weiteres Mal
	  gezeigt bekommt.  In diesem Fall wiederholen Sie die Auswahl
	  von vorher.</para>
      </step>

      <step>
	<title>Anlegen von Dateisystemen auf Ihrem
	  Flashspeicher-Gerät</title>

	<para>Verlassen Sie das Installationsmenü und wählen Sie aus
	  dem Hauptinstallationsmenü die Option
	  <literal>fixit</literal>.  In der fixit-Umgebung angelangt,
	  geben Sie den folgenden Befehl ein:</para>

	<screen>&prompt.root; <userinput>disklabel -e /dev/ad0c</userinput></screen>

	<para>Zu diesem Zeitpunkt sollten Sie sich im vi-Editor unter
	  der Herrschaft des disklabel-Kommandos befinden.  Als
	  nächstes müssen Sie die eine <literal>a:</literal>-Zeile an
	  das Ende der Datei hinzufügen.  Diese
	  <literal>a:</literal>-Zeile sollte wie folgt
	  aussehen:</para>

	<programlisting>a:      <replaceable>123456</replaceable>  0       4.2BSD  0       0</programlisting>

	<para>Wobei <replaceable>123456</replaceable> eine Zahl
	  darstellt, die exakt der gleichen Zahl in der bestehenden
	  Zeile mit dem <literal>c:</literal>-Eintrag entspricht.  Sie
	  kopieren quasi die bestehende Zeile <literal>c:</literal>
	  als eine neue Zeile <literal>a:</literal> und stellen
	  sicher, dass fstype <literal>4.2BSD</literal> entspricht.
	  Speichern Sie die Datei und verlassen Sie den Editor.</para>

	<screen>&prompt.root; <userinput>disklabel -B -r /dev/ad0c</userinput>
&prompt.root; <userinput>newfs /dev/ad0a</userinput></screen>
      </step>

      <step>
	<title>Schreiben des Dateisystems auf Ihr Flash-Medium</title>

	<para>Hängen Sie das neu erstellte Flash-Medium ein:</para>

	<screen>&prompt.root; <userinput>mount /dev/ad0a /flash</userinput></screen>

	<para>Verbinden Sie diese Maschine mit dem Netzwerk, um die
	  tar-Datei zu übertragen und extrahieren Sie es auf das
	  Dateisystem des Flash-Mediums.  Ein Beispiel dazu wäre
	  folgendes:</para>

	<screen>&prompt.root; <userinput>ifconfig xl0 192.168.0.10 netmask 255.255.255.0</userinput>
&prompt.root; <userinput>route add default 192.168.0.1</userinput></screen>

	<para>Jetzt da die Maschine ans Netzwerk angeschlossen ist,
	  kopieren Sie die tar-Datei.  An diesem Punkt werden Sie
	  möglicherweise mit einem Dilemma konfrontiert - sollte Ihr
	  Flash-Speicher beispielsweise 128&nbsp;MB gross sein und
	  Ihre tar-Datei grösser als 64&nbsp;MB, können Sie ihre
	  tar-Datei auf dem Flash-Speicher nicht entpacken - Ihnen
	  wird vorher der Speicherplatz ausgehen.  Eine Lösung für
	  dieses Problem, sofern Sie FTP verwenden, ist, dass Sie die
	  Datei entpacken können, während es von FTP übertragen wird.
	  Wenn Sie die Übertragung auf diese Weise durchführen, haben
	  Sie niemals die tar-Datei und deren Inhalt zur gleichen Zeit
	  auf Ihrem Medium:</para>

	<screen><prompt>ftp&gt;</prompt> <userinput>get tarfile.tar "| tar xvf -"</userinput></screen>

	<para>Sollte Ihre tar-Datei gezippt sein, können Sie dies
	  ebenso bewerkstelligen:</para>

	<screen><prompt>ftp&gt;</prompt> <userinput>get tarfile.tar "| zcat | tar xvf -"</userinput></screen>

	<para>Nachdem der Inhalt Ihrer tar-Datei auf dem Dateisystem
	  des Flash-Mediums abgelegt wurden, können Sie den
	  Flash-Speicher aushängen und neu starten:</para>

	<screen>&prompt.root; <userinput>cd /</userinput>
&prompt.root; <userinput>umount /flash</userinput>
&prompt.root; <userinput>exit</userinput></screen>

	<para>In der Annahme, dass Sie Ihr Dateisystem richtig
	  konfiguriert haben, als es noch auf der gewöhnlichen
	  Festplatte gebaut wurde (mit Ihren Nur-Lese-Dateisystemen
	  und den nötigen Optionen im Kernel), sollten Sie nun
	  erfolgreich von Ihrem &os; Embedded-System starten
	  können.</para>
      </step>
    </procedure>
  </sect1>

  <sect1 xml:id="strategies">
    <title>Systemstrategien für kleine und Nur-Lese-Umgebungen</title>

    <para>In <xref linkend="ro-fs"/> wurde darauf hingewiesen, dass
      das <filename>/var</filename>-Dateisystem von
      <filename>/etc/rc.d/var</filename> konstruiert wurde und die
      Präsenz eines Nur-Lese-Wurzeldateisystems Probleme mit vielen in
      &os; gebrächlichen Softwarepaketen verursacht.  In diesem
      Artikel werden Vorschläge für das erfolgreiche Betreiben von
      cron, syslog, Installationen von Ports und dem Apache-Webserver
      unterbreitet.</para>

    <sect2>
      <title>cron</title>

      <para>Während des Bootvorgangs wird <filename>/var</filename> von
        <filename>/etc/rc.d/var</filename> anhand der Liste aus
        <filename>/etc/mtree/BSD.var.dist</filename> gefüllt, damit
        <filename>cron</filename>, <filename>cron/tabs</filename>, <filename>at</filename> und ein paar weitere
        Standardverzeichnisse erstellt werden.</para>

      <para>Jedoch löst das noch nicht das Problem, Crontabs über
	Neustarts des Systems hinaus zu erhalten.  Wenn das System neu
	gestartet wird, verschwindet das
	<filename>/var</filename>-Dateiystem, welches sich im
	Hauptspeicher befunden hat und jegliche Crontabs, die Sie
	hatten werden ebenfalls verschwinden. Aus diesem Grund besteht
	eine Lösung darin, Crontabs für diejenigen Benutzer zu
	erstellen, die diese auch benötigen.  Dazu sollte das
	<filename>/</filename>-Dateisystem lesend und schreibend
	eingehängt und diese Crontabs an einen sicheren Ort kopiert
	werden, wie beispielsweise <filename>/etc/tabs</filename>.
	Fügen Sie dann eine Zeile an das Ende der Datei
	<filename>/etc/rc.initdiskless</filename> hinzu, die diese
	Crontabs in <filename>/var/cron/tabs</filename> kopiert,
	nachdem dieses Verzeichnis während der Systeminitialisierung
	erstellt wurde.  Sie werden auch eine Zeile hinzufügen mössen,
	welche die Besitzer und Berechtigungen auf diesen
	Verzeichnissen, die Sie erstellen und den dazugehörigen
	Dateien, die Sie mittels
	<filename>/etc/rc.initdiskless</filename> kopieren,
	setzen.</para>
    </sect2>

    <sect2>
      <title>syslog</title>

      <para>Die Datei <filename>syslog.conf</filename> spezifiziert
	den Ort von bestimmten Logdateien, welche in
	<filename>/var/log</filename> existieren.  Diese Dateien
	werden nicht von <filename>/etc/rc.d/var</filename> während
	der Systeminitialisierung erstellt.  Aus diesem Grund müssen
	Sie irgendwo in <filename>/etc/rc.d/var</filename> nach dem
	Abschnitt, der die Verzeichnisse in <filename>/var</filename>
	erstellt, eine Zeile ähnlich der folgenden hinzufügen:</para>

      <screen>&prompt.root; <userinput>touch /var/log/security /var/log/maillog /var/log/cron /var/log/messages</userinput>
&prompt.root; <userinput>chmod 0644 /var/log/*</userinput></screen>
    </sect2>

    <sect2>
      <title>Installation von Ports</title>

      <para>Bevor die notwendigen Änderungen erkärt werden, einen
	Ports-Baum zu verwenden, ist es notwendig, Sie an die
	Nur-Lese-Besonderheit Ihres Dateisystems auf dem Flash-Medium
	zu erinnern.  Da dieses nur lesend verfügbar ist, müssen Sie
	es vorübergehend mit Schreibrechten ausstatten, indem Sie die
	mount-Syntax, wie in <xref linkend="ro-fs"/> dargestellt wird,
	verwenden.  Sie sollten immer diese Dateisysteme erneut mit
	nur-Lese-Rechten einhängen wenn Sie damit fertig sind -
	unnötige Schreibvorgänge auf dem Flash-Medium kann dessen
	Lebenszeit erheblich verkürzen.</para>

      <para>Um es zu ermöglichen, in das Ports-Verzeichnis zu wechseln
	und erfolgreich <command>make</command>
	<buildtarget>install</buildtarget> auszuführen, müssen wir ein
	Paketverzeichnis auf einem Nicht-Hauptspeicherdateisystem
	erstellen, welches die Pakete über Neustarts hinweg im Auge
	behält.  Weil es sowieso nötig ist, Ihre Dateisysteme mit
	Lese-Schreibrechten für die Installation eines Pakets
	einzuhängen, ist es sinnvoll anzunehmen, dass ein Bereich
	Ihres Flash-Mediums ebenfalls für Paketinformationen, die
	darauf abgespeichert werden, verwendet wird.</para>

      <para>Erstellen Sie zuerst ein Verzeichnis für die
	Paketdatenbank.  Normalerweise ist dies
	<filename>/var/db/pkg</filename>, jedoch können wir es dort
	nicht unterbringen, da es jedesmal verschwinden wird, wenn das
	System neu gestartet wird.</para>

      <screen>&prompt.root; <userinput>mkdir /etc/pkg</userinput></screen>

      <para>Fügen Sie nun eine Zeile in
	<filename>/etc/rc.d/var</filename> hinzu, welche das
	<filename>/etc/pkg</filename>-Verzeichnis mit
	<filename>/var/db/pkg</filename> verknüpft.  Ein
	Beispiel:</para>

      <screen>&prompt.root; <userinput>ln -s /etc/pkg /var/db/pkg</userinput></screen>

      <para>Nun wird jedes Mal, wenn Sie Ihre Dateisysteme mit
	Lese-Schreibrechten einbinden und ein Paket installieren, der
	Befehl <command>make</command>
	<buildtarget>install</buildtarget> funktionieren und
	Paketinformationen werden erfolgreich nach
	<filename>/etc/pkg</filename> geschrieben (da zu diesem
	Zeitpunkt das Dateisystem mit Lese-Schreibrechten eingebunden
	ist), welche dann stets dem Betriebssystem als
	<filename>/var/db/pkg</filename> zur Verfügung stehen.</para>
    </sect2>

    <sect2>
      <title>Apache Webserver</title>

      <note>
	<para>Die Anweisungen in diesem Abschnitt sind nur notwendig,
	  wenn Apache so eingerichtet ist, dass dieser seine PID oder
	  Protokollierungsinformationen ausserhalb von <filename>/var</filename> ablegt.  Standardmässig
	  bewahrt Apache seine PID-Datei in <filename>/var/run/httpd.pid</filename> und seine
	  Protokolldateien in <filename>/var/log</filename> auf.</para>
      </note>

      <para>Es wird nun davon ausgegangen, dass Apache seine
	Protokolldateien in einem Verzeichnis namens <filename>apache_log_dir</filename>
	ausserhalb von <filename>/var</filename>
	speichert.  Wenn dieses Verzeichnis auf einem
	nur-Lese-Dateisystem existiert, wird Apache nicht in der Lage
	sein, Protokolldateien zu speichern und wird vermutlich nicht
	richtig funktionieren.  Wenn dies der Fall ist, muss ein neues
	Verzeichnis zu der Liste der Verzeichnisse in
	<filename>/etc/rc.d/var</filename> hinzugefügt werden, um
	dieses in <filename>/var</filename> zu erstellen und um
	<filename>apache_log_dir</filename>
	nach <filename>/var/log/apache</filename> zu verknüpfen.  Es
	ist auch nötig, Berechtigungen und Besitzer auf diesem neuen
	Verzeichnis zu setzen.</para>

      <para>Fügen Sie zuerst das Verzeichnis
	<literal>log/apache</literal> zu der Liste von Verzeichnissen
	hinzu, die in <filename>/etc/rc.d/var</filename> angelegt
	werden sollen.</para>

      <para>Danach tragen Sie die folgenden Befehle in
	<filename>/etc/rc.d/var</filename> nach dem Abschnitt zum
	Erstellen der Verzeichnisse ein:</para>

      <screen>&prompt.root; <userinput>chmod 0774 /var/log/apache</userinput>
&prompt.root; <userinput>chown nobody:nobody /var/log/apache</userinput></screen>

      <para>Schliesslich löschen Sie das bestehende <filename>apache_log_dir</filename>
	Verzeichnis und ersetzen es mit einer Verknüpfung:</para>

      <screen>&prompt.root; <userinput>rm -rf apache_log_dir</userinput>
&prompt.root; <userinput>ln -s /var/log/apache apache_log_dir</userinput></screen>
    </sect2>
  </sect1>
</article>
