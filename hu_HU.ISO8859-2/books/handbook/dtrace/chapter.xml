<?xml version="1.0" encoding="iso-8859-2"?>
<!--
     The FreeBSD Documentation Project
     $FreeBSD$
-->
<!-- The FreeBSD Hungarian Documentation Project
     Translated by: PALI, Gabor <pgj@FreeBSD.org>
     %SOURCE%   en_US.ISO8859-1/books/handbook/dtrace/chapter.xml
     %SRCID%    1.8
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="dtrace" xml:lang="hu">
  <info><title>&dtrace;</title>
    <authorgroup>
      <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Írta: </contrib></author>
    </authorgroup>
  </info>

  

  <sect1 xml:id="dtrace-synopsis">
    <title>Áttekintés</title>

    <indexterm><primary>&dtrace;</primary></indexterm>
    <indexterm>
      <primary>&dtrace; támogatás</primary>
      <see>&dtrace;</see>
    </indexterm>

    <para>A &dtrace;, vagy más néven Dynamic Tracing
      technológiát a &sun; dolgozta ki szerverek
      teljesítményében jelentkezõ szûk
      keresztmetszetek felderítésének
      megkönnyítésére.  Ez nem egy
      nyomkövetésre szolgáló megoldást
      takar, hanem inkább a rendszer valós idejû
      elemzését és
      teljesítményének vizsgálatát
      elõsegítõ eszközt.</para>

    <para>A &dtrace; figyelemre méltó
      elemzõeszköz, rengeteg rendkívül hasznos
      képességgel rendelkezik a rendszerben
      felbukkanó problémák
      diagnosztizálására.  Elõre programozott
      szkriptek segítségével pedig ezen
      képességek további elõnyeit tudjuk
      kihasználni, ugyanis a &dtrace; programozható egy
      ún.  D nyelven, amelynek révén a
      különbözõ vizsgálatokat könnyen a
      saját igényeink szerint tudjuk
      alakítani.</para>

    <para>A fejezet elolvasása során
      megismerjük:</para>

    <itemizedlist>
      <listitem>
	<para>mi is az a &dtrace; és milyen lehetõségei
      vannak;</para>
      </listitem>

      <listitem>
	<para>a &solaris; és &os; operációs
	  rendszereken megtalálható &dtrace;
	  implementációk közti
	  eltéréseket;</para>
      </listitem>

      <listitem>
	<para>a &dtrace; &os; alatt hogyan engedélyezhetõ
      és használható.</para>
      </listitem>
    </itemizedlist>

    <para>A fejezet elolvasásához ajánlott:</para>

    <itemizedlist>
      <listitem>
	<para>a &unix; és &os; alapvetõ ismerete (<xref linkend="basics"/>);</para>
      </listitem>

      <listitem>
	<para>a rendszermag konfigurációjának
	  és fordításának alapvetõ
	  ismerete (<xref linkend="kernelconfig"/>);</para>
      </listitem>

      <listitem>
	<para>az operációs rendszerek és azon
	  belül a &os; biztonsági fogalmainak minimális
	  ismerete (<xref linkend="security"/>);</para>
      </listitem>

      <listitem>
	<para>a &os; forrásainak megszerzésének
	  és azok lefordításának ismerete
	  (<xref linkend="updating-upgrading"/>).</para>
      </listitem>
    </itemizedlist>

   <warning>
      <para>Ez a funkció még folyamatos tesztelés
	alatt áll.  Bizonyos részei még
	egyáltalán nem, vagy csak korlátozottan
	érhetõek el.  A dokumentáció annak
	megfelelõen fog majd változni, hogy ezek az elemek
	fokozatosan elérik az éles
	felhasználáshoz szükséges
	szintet.</para>
    </warning>
  </sect1>

  <sect1 xml:id="dtrace-implementation">
    <title>Eltérések az
      implementációban</title>

    <para>Noha a &os; alatt megtalálható &dtrace;
      implementáció nagyon hasonló az eredeti,
      &solaris; alatt futó változathoz, tartalmaz bizonyos
      különbségeket, amelyeket a
      továbblépés elõtt mindenképpen
      érdemes megemlítenünk.  Az egyik legfontosabb
      ilyen szembetûnõ különbség, hogy a &os;
      esetén a &dtrace; használatát külön
      engedélyezni kell.  A &dtrace; megfelelõ
      mûködéséhez tehát a rendszermag
      konfigurációs állományában meg
      kell adnunk bizonyos beállításokat és
      modulokat kell betöltenünk.  Ezekrõl hamarosan
      szó lesz.</para>

    <para>A rendszermag konfigurációs
      állományában a <literal>DDB_CTF</literal>
      opció segítségével tudjuk
      engedélyezni ún.  <acronym>CTF</acronym> adatok
      betöltését mind a rendszermag
      moduljaiból, mind pedig magából a
      rendszermagból egyaránt.  A <acronym>CTF</acronym> a
      &solaris; <quote>Compact Type Format</quote>
      elnevezésû formátumára utal, amellyel
      például a <acronym>DWARF</acronym>
      megoldásához hasonló módon
      tárolhatunk tömörített alakban
      különbözõ típusú
      nyomkövetési információkat.  Ilyen
      <acronym>CTF</acronym> adatok többek közt a
      <command>ctfconvert</command> és a
      <command>ctfmerge</command> használatával
      rendelhetõek hozzá bináris
      állományokhoz.  A <command>ctfconvert</command>
      segédprogram a fordítóprogram által az
      <acronym>ELF</acronym> állományokban szereplõ
      <acronym>DWARF</acronym> típusú szakaszokban
      tárolt információkat képes beolvasni,
      és a <command>ctfmerge</command> a
      tárgykódban található
      <acronym>CTF</acronym> típusú <acronym>ELF</acronym>
      szakaszokat tudja végrehajtható
      állományokká vagy osztott
      könyvtárakka összefûzni.  Röviden
      beszélni fogunk arról, hogyan lehet mindezeket a
      &os; alaprendszerébe és rendszermagjába is
      beépíteni.</para>

    <para>&os; és &solaris; esetén elõfordulhat, hogy
      más fajta providerek állnak
      rendelkezésünkre.  Ezek közül talán a
      legfontosabb a <literal>dtmalloc</literal>, amely a &os;
      rendszermagjában típus szerint teszi
      lehetõvé a <function>malloc()</function>
      függvény követését.</para>

    <para>&os; alatt kizárólag csak a
      <systemitem class="username">root</systemitem> tudja használni a &dtrace;-t.  Ennek
      oka a két operációs rendszer
      biztonsági megoldásai közti
      különbségekben keresendõ, mivel a &solaris;
      esetén létezik néhány olyan
      alacsonyszintû ellenõrzés, amely a
      &os;-nél még nincs.  Ezért
      például a <filename>/dev/dtrace/dtrace</filename>
      eszköz szigorúan csak a <systemitem class="username">root</systemitem>
      számára érhetõ el.</para>

    <para>Végezetül megemlítjük, hogy a &dtrace;
      felhasználására a &sun; <acronym>CDDL</acronym>
      licence vonatkozik.  A <literal>Common Development and
      Distribution License</literal> &os; a
      <filename>/usr/src/cddl/contrib/opensolaris/OPENSOLARIS.LICENSE</filename>
      állományban található, vagy interneten
      keresztül a <uri xlink:href="http://www.opensolaris.org/os/licensing">http://www.opensolaris.org/os/licensing</uri>
      címen.</para>

    <para>Ezen licenc értelmében a &dtrace;
      támogatással készített &os;
      rendszermagok továbbra is <acronym>BSD</acronym>
      licencûek maradnak, azonban a rendszerrel terjesztett
      binárisok futtatásakor vagy a modulok
      betöltésekor már a <acronym>CDDL</acronym>
      érvényesül.</para>
  </sect1>

  <sect1 xml:id="dtrace-enable">
    <title>A &dtrace; támogatásának
      engedélyezése</title>

    <para>A &dtrace; által felkínált
      lehetõségeket a következõ sorok
      hozzáadásával tudjuk engedélyezni a
      rendszermag konfigurációs
      állományában:</para>

    <programlisting>options         KDTRACE_HOOKS
options         DDB_CTF</programlisting>

    <note>
      <para>AMD64 architektúrán ezeken kívül
	még az alábbi sor is kelleni fog:</para>

      <programlisting>options         KDTRACE_FRAME</programlisting>

      <para>Ezzel a beállítással az
	<acronym>FBT</acronym> (<quote>function boundary tracing</quote>)
	részére nyújtunk támogatást.
	A &dtrace; ugyan enélkül is képes lesz
	mûködni, de akkor csak korlátozott
	mértékben tudunk ilyen típusú
	vizsgálatokat végezni.</para>
      </note>

    <para>Az egész rendszert újra kell fordítanunk
      a <acronym>CTF</acronym> használatával.  Ennek
      elvégzéséhez a következõ
      parancsokat kell kiadnunk:</para>

    <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make WITH_CTF=1 kernel</userinput></screen>

    <para>A fordítás befejezõdése után
      indítsuk újra a rendszerünket.</para>

    <para>A rendszer újraindulása és az új
      rendszermag betöltõdése után
      szükségünk lesz egy Korn-féle
      parancsértelmezõre is, mivel a &dtrace;
      eszköztárában rengeteg, a
      <command>ksh</command> programra épülõ
      eszközt fogunk találni.  Ezért tehát
      telepítsük a <package>shells/ksh93</package> csomagot, de
      megjegyezzük, hogy ugyanezen eszközök
      számára a <package>shells/pdksh</package> vagy <package>shells/mksh</package> csomagok is
      megfelelnek.</para>

    <para>Végül töltsük le a &dtrace;
      eszköztárának legfrissebb
      változatát.  Az aktuális verzió a <uri xlink:href="http://www.opensolaris.org/os/community/dtrace/dtracetoolkit/">http://www.opensolaris.org/os/community/dtrace/dtracetoolkit/</uri>
      címen érhetõ el.  Képes
      önmagát telepíteni, de a benne
      található eszközök
      használatához nem kötelezõ ezt
      elvégezni.</para>
  </sect1>

  <sect1 xml:id="dtrace-using">
    <title>A &dtrace; használata</title>

    <para>A &dtrace; funkcióinak alkalmazásához
      léteznie kell egy &dtrace; eszköznek.  Ennek
      létrehozásához be kell töltenünk a
      megfelelõ modult:</para>

    <screen>&prompt.root; <userinput>kldload dtraceall</userinput></screen>

    <para>Innentõl már mûködésre
      kész a &dtrace;.  Rendszeradminisztrátorként a
      következõ módon kérdezhetjük le a
      rendelkezésre álló
      vizsgálatokat:</para>

    <screen>&prompt.root; <userinput>dtrace -l | more</userinput></screen>

    <para>Mivel lekérdezés eredménye pillanatok
      alatt betöltené az egész képernyõt,
      ezért az egészet még
      átirányítjuk a <command>more</command>
      parancshoz.  Ha ez rendesen lefut, akkor a &dtrace;
      ténylegesen használhatónak tekinthetõ.
      Ezt követõen tekintsük át a
      hozzá tartozó eszközkészletet.</para>

    <para>Ez a mellékelt eszközkészlet
      lényegében a rendszerrel kapcsolatos
      információk összegyûjtésére
      alkalmas szkripteket tartalmaz.  Vannak szkriptek, amelyekkel a
      megnyitott állományokat, a memóriát, a
      processzorhasználatot és még sok minden
      mást kérdezhetünk le.  A szkriptek a
      következõ parancs segítségével
      tömöríthetõek ki:</para>

    <screen>&prompt.root; <userinput>gunzip -c DTraceToolkit* | tar xvf -</userinput></screen>

    <para>A <command>cd</command> parancs
      segítségével lépjünk be az
      így keletkezõ könyvtárba, és a
      kisbetûs névvel rendelkezõ
      állományok engedélyeit állítsuk
      be a <literal>755</literal> módra.</para>

    <para>Mindegyik szkriptben el kell végeznünk némi
      módosítást: a <filename>/usr/bin/ksh</filename>
      hivatkozásokat írjuk át mindenhol a
      <filename>/usr/local/bin/ksh</filename> névre, illetve a
      <filename>/usr/bin/sh</filename> hivatkozásokat
      <filename>/bin/sh</filename> névre, majd
      végezetül pedig a <filename>/usr/bin/perl</filename>
      hivatkozásokat a <filename>/usr/local/bin/perl</filename>
      névre.</para>

    <important>
      <para>Itt még egyszer kiemelnénk, hogy a &os;-ben
	jelenleg megtalálható &dtrace; támogatás
	<emphasis>még nem teljes</emphasis> és
	<emphasis>kísérleti jelleggel</emphasis> szerepel.
	Ezért bizonyos szkriptek nem fognak mûködni,
	vagy azért, mert túlságosan &solaris;
	lehetõségeihez igazodnak, vagy pedig azért,
	mert a jelenlegi implementáció által
	még nem ismert vizsgálatokra
	támaszkodnak.</para>
    </important>

    <para>Jelenlegi ismereteink szerint a &os; egyelõre csak
      két szkriptet támogat teljes mértékben,
      ezek a <filename>hotkernel</filename> és a
      <filename>procsystime</filename>.  A szakasz további
      részében ezzel a kettõvel fogunk
      részletesebben foglalkozni.</para>

    <para>A <filename>hotkernel</filename> feladata segíteni
      beazonosítani azokat a függvényeket, amelyek a
      legtöbb idõt veszik igénybe a rendszermagon
      belül.  A szkript futtatásakor nagyjából
      a következõt csinálja:</para>

    <screen>&prompt.root; <userinput>./hotkernel</userinput>
Sampling... Hit Ctrl-C to end.</screen>

    <para>A folyamat <keycombo action="simul"><keycap>Ctrl</keycap><keycap>C</keycap> </keycombo>
      billentyûkombináció hatására
      állítható meg.  A szkript
      futásának befejezõdésekor
      különbözõ rendszermagbeli
      függvények és a hozzájuk tartozó
      idõk jelennek meg, az utóbbi szerint növekvõ
      sorrendben:</para>

    <screen>kernel`_thread_lock_flags                                   2   0.0%
0xc1097063                                                  2   0.0%
kernel`sched_userret                                        2   0.0%
kernel`kern_select                                          2   0.0%
kernel`generic_copyin                                       3   0.0%
kernel`_mtx_assert                                          3   0.0%
kernel`vm_fault                                             3   0.0%
kernel`sopoll_generic                                       3   0.0%
kernel`fixup_filename                                       4   0.0%
kernel`_isitmyx                                             4   0.0%
kernel`find_instance                                        4   0.0%
kernel`_mtx_unlock_flags                                    5   0.0%
kernel`syscall                                              5   0.0%
kernel`DELAY                                                5   0.0%
0xc108a253                                                  6   0.0%
kernel`witness_lock                                         7   0.0%
kernel`read_aux_data_no_wait                                7   0.0%
kernel`Xint0x80_syscall                                     7   0.0%
kernel`witness_checkorder                                   7   0.0%
kernel`sse2_pagezero                                        8   0.0%
kernel`strncmp                                              9   0.0%
kernel`spinlock_exit                                       10   0.0%
kernel`_mtx_lock_flags                                     11   0.0%
kernel`witness_unlock                                      15   0.0%
kernel`sched_idletd                                       137   0.3%
0xc10981a5                                              42139  99.3%</screen>

    <para>Ez a szkript modulok esetén is alkalmazható.
      Ezt a módját a <option>-m</option> kapcsoló
      megadásával aktiválhatjuk:</para>

    <screen>&prompt.root; <userinput>./hotkernel -m</userinput>
Sampling... Hit Ctrl-C to end.
^C
MODULE                                                  COUNT   PCNT
0xc107882e                                                  1   0.0%
0xc10e6aa4                                                  1   0.0%
0xc1076983                                                  1   0.0%
0xc109708a                                                  1   0.0%
0xc1075a5d                                                  1   0.0%
0xc1077325                                                  1   0.0%
0xc108a245                                                  1   0.0%
0xc107730d                                                  1   0.0%
0xc1097063                                                  2   0.0%
0xc108a253                                                 73   0.0%
kernel                                                    874   0.4%
0xc10981a5                                             213781  99.6%</screen>

    <para>A <filename>procsystime</filename> szkript egy adott
      azonosítóval vagy névvel rendelkezõ
      programhoz tudja megadni az általa kezdeményezett
      rendszerhívások által felhasznált
      idõt.  A most következõ példában
      elindítjuk a <filename>/bin/csh</filename> egy újabb
      példányát.  A
      <filename>procsystime</filename> elindul, majd megvárja,
      amíg kiadunk néhány parancsot a
      <command>csh</command> frissen indított
      másolatában.  A teszt eredményei tehát
      a következõk lesznek:</para>

    <screen>&prompt.root; <userinput>./procsystime -n csh</userinput>
Tracing... Hit Ctrl-C to end...
^C

Elapsed Times for processes csh,

         SYSCALL          TIME (ns)
          getpid               6131
       sigreturn               8121
           close              19127
           fcntl              19959
             dup              26955
         setpgid              28070
            stat              31899
       setitimer              40938
           wait4              62717
       sigaction              67372
     sigprocmask             119091
    gettimeofday             183710
           write             263242
          execve             492547
           ioctl             770073
           vfork            3258923
      sigsuspend            6985124
            read         3988049784</screen>

    <para>Jól megfigyelhetõ, hogy (nanomásodpercekben
      mérve) a legtöbb idõt a
      <function>read()</function>, a legkevesebb idõt pedig a
      <function>getpid()</function> rendszerhívás vette
      igénybe.</para>
  </sect1>

  <sect1 xml:id="dtrace-language">
    <title>A D nyelv</title>

    <para>A &dtrace; eszköztárában
      megtalálható számos szkript a &dtrace;
      saját programozási nyelvén
      íródott.  Ezt a nyelvet nevezik a &sun;
      implementációjában <quote>a D
      nyelvnek</quote>.  Ennek ismertetésére itt most
      külön nem térünk ki, azonban a <uri xlink:href="http://wikis.sun.com/display/DTrace/Documentation">http://wikis.sun.com/display/DTrace/Documentation</uri>
      címen igen részletesen olvashatunk
      róla.</para>
  </sect1>
</chapter>
