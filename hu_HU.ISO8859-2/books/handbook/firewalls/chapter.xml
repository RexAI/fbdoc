<?xml version="1.0" encoding="iso-8859-2"?>
<!--
     The FreeBSD Documentation Project

     $FreeBSD$
-->
<!-- The FreeBSD Hungarian Documentation Project
     Translated by: PALI, Gabor <pgj@FreeBSD.org>
     %SOURCE%	en_US.ISO8859-1/books/handbook/firewalls/chapter.xml
     %SRCID%	1.94
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="firewalls" xml:lang="hu">
  <info><title>Tûzfalak</title>
    <authorgroup>
      <author><personname><firstname>Joseph J.</firstname><surname>Barbish</surname></personname><contrib>Írta: </contrib></author>
    </authorgroup>
    <authorgroup>
      <author><personname><firstname>Brad</firstname><surname>Davis</surname></personname><contrib>SGML formátumúra alakította
	  és aktualizálta: </contrib></author>
    </authorgroup>
  </info>

  

  <indexterm><primary>tûzfalak</primary></indexterm>

  <indexterm>
    <primary>biztonság</primary>
    <secondary>tûzfalak</secondary>
  </indexterm>

  <sect1 xml:id="firewalls-intro">
    <title>Bevezetés</title>

    <para>A tûzfalakkal a rendszerünkön
      keresztülfolyó bejövõ és kimenõ
      forgalmat tudjuk szûrni.  A tûzfalak egy vagy több
      <quote>szabályrendszer</quote> alapján
      vizsgálják az éppen érkezõ vagy
      távozó hálózati csomagokat, és
      vagy továbbengedik ezeket vagy
      megállítják.  A tûzfalak
      szabályai a csomagok egy vagy több
      jellemzõjét veszik szemügyre, amelyek lehetnek
      például a protokoll típusa, a forrás
      vagy cél hálózati címe, esetleg a
      forrás- vagy a célport.</para>

    <para>A tûzfalak jelentõs mértékben
      képesek gyarapítani egy gép vagy egy
      hálózat védelmét.  Leginkább a
      következõkre tudjuk felhasználni:</para>

    <itemizedlist>
      <listitem>
	<para>A belsõ hálózatunkban futó
	  alkalmazások, szolgáltatások,
	  gépek megvédésére és
	  elszigetelésére az internetrõl
	  érkezõ nem kívánt forgalom
	  ellen</para>
      </listitem>

      <listitem>
	<para>A belsõ hálózatban levõ
	  gépek elérését tudjuk
	  korlátozni vagy letiltani az interneten
	  elérhetõ szolgáltatások
	  felé</para>
      </listitem>

      <listitem>
	<para>A hálózati címfordítás
	  (Network Address Translation, <acronym>NAT</acronym>)
	  beállításához, ahol a belsõ
	  hálózatunk privát
	  <acronym>IP</acronym>-címeket használnak
	  és egy közös kapcsolaton keresztül
	  érik el az internetet (egyetlen
	  <acronym>IP</acronym>-címmel, vagy pedig automatikusan
	  kiosztott publikus címekkel).</para>
      </listitem>
    </itemizedlist>

    <para>A fejezet elolvasása során
      megismerjük:</para>

    <itemizedlist>
      <listitem>
	<para>hogyan adjuk meg helyesen a csomagok
	  szûrését leíró
	  szabályokat;</para>
      </listitem>

      <listitem>
	<para>a &os;-be épített tûzfalak közti
	  különbségeket;</para>
      </listitem>

      <listitem>
	<para>hogyan állítsuk be és
	  használjuk az OpenBSD <application>PF</application>
	  tûzfalát;</para>
      </listitem>

      <listitem>
	<para>hogyan állítsuk be és
	  használjuk az <application>IPFILTER</application>
	  tûzfalat;</para>
      </listitem>

      <listitem>
	<para>hogyan állítsuk be és
	  használjuk az <application>IPFW</application>
	  tûzfalat.</para>
      </listitem>
    </itemizedlist>

    <para>A fejezet elolvasása elõtt ajánlott:</para>

    <itemizedlist>
      <listitem>
	<para>a &os;-hez és az internethez kötõdõ
	  alapvetõ fogalmak ismerete.</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 xml:id="firewalls-concepts">
    <title>Röviden a tûzfalakról</title>

    <indexterm>
      <primary>tûzfalak</primary>
      <secondary>szabályrendszerei</secondary>
    </indexterm>

    <para>A tûzfalak szabályrendszereit alapvetõen
      kétféleképpen tudjuk
      összeállítani: <quote>inkluzív</quote>,
      vagyis megengedõ, illetve <quote>exkluzív</quote>
      vagyis kizáró módon.  Az exkluzív
      tûzfalak minden forgalmat átengednek, amirõl nem
      rendelkeznek a tûzfal szabályai.  Az inkluzív
      tûzfalak ennek pontosan az ellenkezõjét teszik.
      Csak azt a forgalmat engedik át, amirõl van
      szabály és minden mást blokkolnak.</para>

    <para>Az inkluzív tûzfalak alkalmazásával
      sokkal jobban kezünkbentudjuk tartani a
      hálózatunk kimenõ forgalmát,
      ezért leginkább az internetes
      szolgáltatásokat futtató rendszerek
      esetében bizonyulhat jobb választásnak.
      Emellett az internetrõl a hálózatunk
      felé irányuló forgalmat is képes
      szabályozni.  Ekkor az egyetlen szabályra sem
      illeszkedõ csomagokat egyszerûen eldobjuk és
      naplózzuk.  Az inkluzív tûzfalak
      általában biztonságosabbak az exkluzív
      típusú társaiknál, mivel
      esetükben jelentõs mértékben visszaszorul
      a nem kívánatos átfolyó
      forgalom.</para>

    <note>
      <para>Hacsak nem emeljük ki külön, a fejezet
	további részében minden
	példaként megadott szabályrendszer
	inkluzív tûzfalat hoz létre.</para>
    </note>

    <para>Ez a típusú védelem még
      tovább fokozható az
      <quote>állapottartó tûzfalak</quote> (stateful
      firewall) használatával.  Az ilyen
      típusú tûzfalak szemmel tartják a rajtuk
      keresztül megnyitott kapcsolatokat, és vagy csak a
      már meglevõ kapcsolathoz tartozó forgalmat
      engedik át vagy nyitnak egy újat.  Az
      állapottartó tûzfalak hátránya,
      hogy a <quote>Denial of Service</quote> (<acronym>DoS</acronym>)
      típusú támadásokkal szemben sokkal
      sérülékenyebbek olyan helyzetekben, amikor az
      új kapcsolatok nagyon gyorsan jönnek létre.  A
      legtöbb tûzfal esetében azonban tudjuk
      vegyíteni az állapottartó és nem
      állapottartó viselkedést, és ezzel egy
      ideális beállítást
      kialakítani.</para>

  </sect1>

  <sect1 xml:id="firewalls-apps">
    <title>Tûzfalak</title>

    <para>A &os; alaprendszerébe három
      különbözõ tûzfalat
      építettek be, melyek a következõk: az
      <emphasis>IPFILTER</emphasis> (másik nevén
      <acronym>IPF</acronym>), az <emphasis>IPFIREWALL</emphasis>
      (más néven <acronym>IPFW</acronym>) és az
      <emphasis>OpenBSD csomagszûrõje</emphasis> (Packet
      Filter, azaz <acronym>PF</acronym>).  A forgalom
      szabályozására (vagyis alapvetõen a
      sávszélesség
      kihasználtságának
      vezérlésére) a &os; két
      beépített csomagot tartalmaz: ez az &man.altq.4;
      és a &man.dummynet.4;.  Általában a Dummynet
      az <acronym>IPFW</acronym>, míg az <acronym>ALTQ</acronym>
      a <acronym>PF</acronym> partnere.  Az IPFILTER esetében
      maga az IPFILTER végzi a címfordítást
      és a szûrést, a
      sávszélességet pedig az
      <acronym>IPFW</acronym> a &man.dummynet.4;
      <emphasis>vagy</emphasis> a <acronym>PF</acronym> az
      <acronym>ALTQ</acronym> segítségével.  Az
      <acronym>IPFW</acronym> és a <acronym>PF</acronym>
      szabályokkal rendelkezik a rendszerünkbe
      érkezõ vagy onnan távozó
      csomagokról, habár megoldásaik teljesen
      máshogy mûködnek és a szabályok
      megadási módja is eltér.</para>

    <para>A &os; azért tartalmaz egyszerre ennyiféle
      tûzfalat, mert az emberek elvárásai és
      igényei eltérnek.  Egyikük sem tekinthetõ
      a legjobbnak.</para>

    <para>A szerzõ egyébként az IPFILTER
      megoldását részesíti elõnyben,
      mivel egy hálózati címfordítást
      alkalmazó környezetben sokkal könnyebb vele
      megfogalmazni az állapottartó szabályokat,
      valamint tartalmaz egy beépített FTP proxyt is,
      amivel így a kimenõ FTP kapcsolatok
      beállítása még tovább
      egyszerûsödik.</para>

    <para>Mivel az összes tûzfal a csomagok
      fejlécének bizonyos mezõinek alapján
      dolgozik, ezért a tûzfal
      szabályrendszerét megalkotó egyénnek
      teljesen tisztában kell lennie a <acronym>TCP/IP</acronym>
      mûködésével, továbbá azzal,
      hogy ezekben a mezõkben milyen értékek
      szerepelhetnek és ezeket hogyan használják
      egy átlagos kapcsolat alatt.  Ebben a témában
      a <uri xlink:href="http://www.ipprimer.com/overview.cfm">http://www.ipprimer.com/overview.cfm</uri>
      címen találhatunk egy remek ismertetõt
      (angolul).</para>

  </sect1>

  <sect1 xml:id="firewalls-pf">
    <info><title>Az OpenBSD csomagszûrõje (PF) és az
      <acronym>ALTQ</acronym></title>
      <authorgroup>
	<author><personname><firstname>John</firstname><surname>Ferrell</surname></personname><contrib>Átnézte és
	    aktualizálta:</contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>tûzfalak</primary>
      <secondary>PF</secondary>
    </indexterm>

    <para>2003 júliusában az OpenBSD <acronym>PF</acronym>
      néven ismert csomagszûrõjét
      átírták &os;-re és
      elérhetõvé tették a &os;
      Portgyûjteményének részeként.  A
      <acronym>PF</acronym> programot beépítetten
      tartalmazó elsõ kiadás pedig 2004
      novemberében a &os;&nbsp;5.3 volt.  A <acronym>PF</acronym>
      egy teljes, mindentudó tûzfal, amely támogatja
      az ún.  <acronym>ALTQ</acronym> (Alternate Queuing, vagyis
      a <quote>váltóbesorolás</quote>)
      megoldást.  Az <acronym>ALTQ</acronym> lehetõvé
      teszi a sávszélesség
      korlátozását a szolgáltatás
      minõsége (Quality of Service, <acronym>QoS</acronym>)
      alapján.</para>

   <para>Az OpenBSD Projekt kiváló munkát
      végez a PF <link xlink:href="http://www.openbsd.org/faq/pf/">felhasználói
	útmutatójának</link>
      karbantartásával.  A kézikönyv ezen
      szakasza ezért elsõsorban azzal foglalkozik, hogyan
      kell a <acronym>PF</acronym>-et &os; alatt használni,
      miközben igyekszik egy általános
      összefoglalást adni a témáról.  A
      részletesebb információkkal kapcsolatban
      azonban feltétlenül nézzük meg a
      felhasználói útmutatót.</para>

    <para>A <uri xlink:href="http://pf4freebsd.love2party.net/">http://pf4freebsd.love2party.net/</uri>
      címen olvashatunk többet arról (angolul), hogy
      a <acronym>PF</acronym>-et hogyan használjunk
      &os;-n.</para>

    <sect2>
      <title>A PF rendszermagmodulok használata</title>

      <para>A <acronym>PF</acronym> modul
	betöltéséhez a következõ sort kell
	felvennünk az <filename>/etc/rc.conf</filename>
	állományba:</para>

      <programlisting>pf_enable="YES"</programlisting>

      <para>Ezt követõen futtassuk le a
	hozzá tartozó rendszerindító
	szkriptet:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/pf start</userinput></screen>

      <para>A <acronym>PF</acronym> modul abban az esetben nem fog
	betöltõdni, ha nem találja a szabályokat
	tartalmazó konfigurációs
	állományt.  Ez alapértelmezés
	szerint az <filename>/etc/pf.conf</filename>
	állomány.  Ha a szabályok
	leírása rendszerünkön máshol
	található, akkor az
	<filename>/etc/rc.conf</filename> állományban a
	következõ módon adhatjuk meg annak pontos
	helyét:</para>

      <programlisting>pf_rules="<replaceable>/elérési/út/pf.conf</replaceable>"</programlisting>

      <note>
	<para>A &os;&nbsp;7.0 kiadással a minta
	  <filename>pf.conf</filename> állomány az
	  <filename>/etc</filename>
	  könyvtárból átkerült a
	  <filename>/usr/share/examples/pf</filename>
	  könyvtárba.  A &os;&nbsp;7.0 elõtti
	  kiadásokban alapértelmezés szerint
	  található egy <filename>pf.conf</filename>
	  állomány az <filename>/etc</filename>
	  könyvtárban.</para>
      </note>

      <para>A <acronym>PF</acronym> modul parancssorból
	akár kézzel is betölthetõ:</para>

      <screen>&prompt.root; <userinput>kldload pf.ko</userinput></screen>

      <para>A <acronym>PF</acronym> mûködésének
	naplózását a <literal>pflog.ko</literal>
	teszi lehetõvé, amelyet az alábbi sor
	hozzáadásával engedélyezhetünk
	az <filename>/etc/rc.conf</filename>
	állományban:</para>

      <programlisting>pflog_enable="YES"</programlisting>

      <para>A modul betöltését a
	hozzá tartozó rendszerindító szkript
	segítségével kérhetjük:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/pflog start</userinput></screen>

      <para>Ha a <acronym>PF</acronym> többi
	funkcióját is használni szeretnénk,
	akkor ehhez egy új rendszermagot kell fordítanunk
	<acronym>PF</acronym> támogatással.</para>
    </sect2>

    <sect2>
      <title>A PF rendszermagbeli
	beállításai</title>

      <indexterm>
	<primary>a rendszermag
	  beállításai</primary>
	<secondary>device pf</secondary>
      </indexterm>

      <indexterm>
	<primary>a rendszermag
	  beállításai</primary>
	<secondary>device pflog</secondary>
      </indexterm>

      <indexterm>
	<primary>a rendszermag
	  beállításai</primary>
	<secondary>device pfsync</secondary>
      </indexterm>

      <para>Noha egyáltalán nem szükséges
	beépítenünk a <acronym>PF</acronym>
	támogatását a rendszermagba, abban az
	esetben mégis szükségünk lehet
	rá, amikor a <acronym>PF</acronym> olyan komolyabb
	lehetõségeit szeretnénk kiaknázni,
	amelyek már nem részei a modulnak.  Ilyen
	például a &man.pfsync.4;, amely a
	<acronym>PF</acronym> által használt
	állapottáblázatok bizonyos
	változásainak megjelenítésére
	alkalmas pszeudoeszköz.  A &man.carp.4;
	megoldásával párosítva így
	akár hibatûrõ tûzfalak is
	kialakíthatóak a <acronym>PF</acronym>-fel.  A
	<acronym>CARP</acronym> megoldásáról a
	kézikönyvben bõvebb ismertetést a <xref linkend="carp"/> ad.</para>

      <para>A <acronym>PF</acronym> rendszermag
	konfigurációs beállításai a
	<filename>/usr/src/sys/conf/NOTES</filename>
	állományban találhatóak:</para>

      <programlisting>device pf
device pflog
device pfsync</programlisting>

      <para>A <literal>device pf</literal>
	beállítás engedélyezi a
	csomagszûrõ tûzfalat (&man.pf.4;).</para>

      <para>A <literal>device pflog</literal> megadásával
	keletkezik egy &man.pflog.4; pszeudo hálózati
	eszköz, amellyel egy &man.bpf.4; eszközre
	érkezõ forgalmat tudunk naplózni.
	Ezután a &man.pflogd.8; démon
	használható tõle származó
	naplózott adatok
	rögzítésére.</para>

      <para>A <literal>device pfsync</literal> engedélyezi a
	&man.pfsync.4; pszeudo hálózati eszköz
	létrejöttét, amely az ún.
	<quote>állapotváltások</quote>
	megfigyelésére alkalmas.</para>
    </sect2>

    <sect2>
      <title>Az <filename>rc.conf</filename> állományban
	elérhetõ beállítások</title>

      <para>A következõ &man.rc.conf.5;
	beállítások aktiválják a
	rendszerindítás során a
	<acronym>PF</acronym> és a &man.pflog.4;
	használatát:</para>

      <programlisting>pf_enable="YES"                 # a PF engedélyezése (a modul betöltése, ha kell)
pf_rules="/etc/pf.conf"         # a pf szabályait tartalmazó állomány
pf_flags=""                     # a pfctl indításához szükséges további paraméterek
pflog_enable="YES"              # a pflogd(8) elindítása
pflog_logfile="/var/log/pflog"  # hol tartsa a pflogd az naplóit
pflog_flags=""                  # a pflogd indításához szükséges paraméterek</programlisting>

      <para>Ha a tûzfalunk mögött egy helyi
	hálózat is meghúzódik, akkor az ott
	levõ gépek számára valamilyen
	módon tudnunk kell továbbítani a csomagokat
	vagy címfordítást kell végezni,
	így ez is mindenképpen kelleni fog:</para>

      <programlisting>gateway_enable="YES"            # az átjáró funkciók engedélyezése</programlisting>
    </sect2>

    <sect2>
      <title>A szûrési szabályok
	megfogalmazása</title>

      <para>A <acronym>PF</acronym> a beállításait
	a &man.pf.conf.5; állomány tárolja (amely
	alapértelmezés szerint az
	<filename>/etc/pf.conf</filename> helyen
	található), és az ebben
	található szabályok alapján
	módosítja, dobja el vagy éppen engedi
	át a csomagokat.  A &os; rendszerünkben ehhez
	találhatunk néhány példát a
	<filename>/usr/share/examples/pf/</filename>
	könyvtárban.  A <acronym>PF</acronym> által
	használt szabályokról minden
	részletre kiterjedõen a PF <link xlink:href="http://www.openbsd.org/faq/pf/">felhasználói
	  útmutatójában</link> olvashatunk.</para>

      <warning>
	<para>A PF <link xlink:href="http://www.openbsd.org/faq/pf/">felhasználói
	    útmutatójának</link>
	  olvasásakor ne feledkezzünk meg róla, hogy
	  a különbözõ &os; verziók
	  különbözõ <acronym>PF</acronym>
	  verziókat tartalmaznak.  A
	  &os;&nbsp;7.<replaceable>X</replaceable> és
	  késõbbi változatok az OpenBSD&nbsp;4.1
	  kiadásában szereplõ <acronym>PF</acronym>
	  változatot tartalmazzák.</para></warning>

      <para>A &a.pf; remek hely a <acronym>PF</acronym> tûzfal
	beállításával és
	futtatásával kapcsolatos kérdésekre.
	A kérdezés elõtt azonban ne felejtsük el
	alaposan átnézni az archívumot!</para>
    </sect2>

    <sect2>
      <title>A PF használata</title>

      <para>A <acronym>PF</acronym> a &man.pfctl.8;
	segítségével vezérelhetõ.  Az
	alábbiakban ezzel kapcsolatban most összefoglalunk
	néhány hasznos parancsot (de ne felejtsük el
	megnézni a &man.pfctl.8; man oldalon
	található többi lehetõséget
	sem):</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Parancs</entry>
	      <entry>Leírás</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><command>pfctl -e</command></entry>
	      <entry>A PF engedélyezése</entry>
	    </row>

	    <row>
	      <entry><command>pfctl -d</command></entry>
	      <entry>A PF tiltása</entry>
	    </row>

	    <row>
	      <entry><command>pfctl -F all -f /etc/pf.conf</command></entry>
	      <entry>Az összes (címfordítási,
		szûrési, állapottartási stb.)
		szabály törlése, és az
		<filename>/etc/pf.conf</filename> állomány
		újratöltése</entry>
	    </row>

	    <row>
	      <entry><command>pfctl -s [ rules | nat | state ]</command></entry>
	      <entry>A szûrési (<literal>rules</literal>),
		címfordítási
		(<literal>nat</literal>) és
		állapottartási (<literal>state</literal>)
		információk
		lekérdezése</entry>
	    </row>

	    <row>
	      <entry><command>pfctl -vnf /etc/pf.conf</command></entry>
	      <entry>Az <filename>/etc/pf.conf</filename>
		állomány ellenõrzése a benne
		levõ szabályok betöltése
		nélkül</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Az <acronym>ALTQ</acronym>
	engedélyezése</title>

      <para>Az <acronym>ALTQ</acronym> kizárólag csak
	úgy használható, ha a
	konfigurációs beállításokon
	keresztül beépítjük a &os;
	rendszermagjába.  Az <acronym>ALTQ</acronym>
	alkalmazását nem minden hálózati
	kártya meghajtója támogatja, ezért
	ezt a &man.altq.4; man oldalon ellenõrizzük.</para>

      <para>A következõ rendszermag
	konfigurációs beállításokkal
	engedélyezhetjük az <acronym>ALTQ</acronym>
	használatát és bõvíthetjük
	azt további lehetõségekkel:</para>

      <programlisting>options         ALTQ
options         ALTQ_CBQ        # osztályozás alapú besorolás (Class Bases Queuing, CBQ)
options         ALTQ_RED        # véletlen korai észlelés (Random Early Detection, RED)
options         ALTQ_RIO        # RED befele/kifele
options         ALTQ_HFSC       # hiearchikus csomagütemezõ (Hierarchical Packet Scheduler, HFSC)
options         ALTQ_PRIQ       # prioritásos besorolás (Priority Queuing, PRIQ)
options         ALTQ_NOPCC      # az SMP esetén kell</programlisting>

      <para>Az <literal>options ALTQ</literal> az
	<acronym>ALTQ</acronym> rendszert engedélyezi.</para>

      <para>Az <literal>options ALTQ_CBQ</literal> engedélyezi a
	osztályozás alapú besorolást
	(<emphasis>Class Based Queuing</emphasis>,
	<acronym>CBQ</acronym>).  A <acronym>CBQ</acronym>
	használatával a kapcsolatunkhoz tartozó
	sávszélességet
	különbözõ osztályokra vagy sorokra
	tudjuk bontani és a szûrési
	szabályoknak megfelelõen osztályozni
	segítségükkel a forgalmat.</para>

      <para>Az <literal>options ALTQ_RED</literal> a véletlen
	korai észlelés (<emphasis>Random Early
	Detection</emphasis>, <acronym>RED</acronym>)
	használatát engedélyezi.  A
	<acronym>RED</acronym> a hálózati forgalomban
	keletkezõ torlódások
	elkerülésére alkalmas.  A
	<acronym>RED</acronym> ezt a problémát úgy
	oldja meg, hogy méri a sorok hosszát és
	összeveti a hozzá tartozó minimális
	és maximális
	küszöbértékekkel.  Ha a sor hossza
	meghaladja a számára elõírt
	maximális értéket, akkor az új
	csomagokat eldobja.  Nevéhez hûen a
	<acronym>RED</acronym> az eldobásra ítélt
	csomagokat véletlenszerûen választja
	ki.</para>

      <para>Az <literal>options ALTQ_RIO</literal> engedélyezi a
	<acronym>RED</acronym> használatát mind a
	két irányba, tehát be- és
	kifelé.</para>

      <para>Az <literal>options ALTQ_HFSC</literal> a pártatlan
	hierachikus szolgáltatási görbe alapú
	csomagütemezõt (<emphasis>Hierarchical Fair Service
	Curve Packet Scheduler</emphasis>, <acronym>HFSC</acronym>)
	engedélyezi.  Vele kapcsolatban a <uri xlink:href="http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html">http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html</uri>
	címen találhatunk bõvebben
	olvasnivalót (angolul).</para>

      <para>Az <literal>options ALTQ_PRIQ</literal> a prioritásos
	besorolást (<emphasis>Priority Queuing</emphasis>,
	<acronym>PRIQ</acronym>) teszi elérhetõvé.  A
	<acronym>PRIQ</acronym> mindig elsõként a nagyobb
	értékû sorban levõ forgalmat
	továbbítja.</para>

      <para>Az <literal>options ALTQ_NOPCC</literal> az
	<acronym>ALTQ</acronym> <acronym>SMP</acronym>, vagyis
	többprocesszoros támogatását adja meg.
	Ilyen típusú rendszerekben ez
	kötelezõ.</para>

    </sect2>
  </sect1>

  <sect1 xml:id="firewalls-ipf">
    <title>Az IPFILTER (IPF) tûzfal</title>

    <indexterm>
      <primary>tûzfalak</primary>
      <secondary>IPFILTER</secondary>
    </indexterm>

    <para>Az IPFILTER szerzõje Darren Reed.  Az IPFILTER nem
      kötõdik egyik rendszerhez sem: ez egy olyan nyílt
      forráskódú alkalmazás, amelyet
      átírtak &os;, NetBSD, OpenBSD, &sunos;, HP/UX
      és &solaris; operációs rendszerekre.  Az
      IPFILTER karbantartása és támogatása
      pillanatnyilag is aktív, folyamatosan jelennek meg
      újabb változatai.</para>

    <para>Az IPFILTER egy rendszermag oldalán
      mûködõ tûzfalazási és egy
      címfordítási mechanizmusra alapszik, amelyet
      felhasználói programokkal tudunk felügyelni
      és vezérelni.  A tûzfal szabályai az
      &man.ipf.8; segédprogrammal
      állíthatóak be vagy
      törölhetõek.  A hálózati
      címfordításra vonatkozó
      szabályokat az &man.ipnat.1; segédprogrammal
      állíthatjuk be vagy törölhetjük.  Az
      &man.ipfstat.8; segédprogram képes futás
      közben statisztikákat készíteni az
      IPFILTER rendszermagban elhelyezkedõ részeinek
      viselkedésérõl.  Az &man.ipmon.8; program pedig
      az IPFILTER cselekvéseit képes a
      rendszernaplókba feljegyezni.</para>

    <para>Az IPF eredetileg olyan szabályfeldolgozási
      módszer szerint készült, amelyben <quote>az
      utolsó egyezõ szabály nyer</quote> és
      csak állapotnélküli szabályokat ismert.
      Az idõ múlásával az IPF
      részévé vált a <quote>quick</quote>
      opció és a <quote>keep state</quote> opción
      keresztül az állapottartás is, melyek
      drámai mértékben
      korszerûsítették a szabályok
      feldolgozásának elvét.  Az IPF hivatalos
      dokumentációja csak a régi szabályok
      létrehozását és azok
      feldolgozásának leírását
      tartalmazza.  A korszerûsített funkciók csak
      kiegészítésképpen jelennek meg,
      és az általuk felkínált
      elõnyök megértése egy sokkal magasabb
      szintû és biztonságosabb tûzfal
      megépítését teszik
      lehetõvé.</para>

    <para>A szakaszban szereplõ utasításokban olyan
      szabályok szerepelnek, amelyek kihasználják a
      <quote>quick</quote> és <quote>keep state</quote>
      opciókat.  Ezek az inkluzív
      tûzfalszabályok létrehozásának
      alapjai.</para>

    <para>A régi típusú szabályokról
      a <uri xlink:href="http://www.obfuscation.org/ipf/ipf-howto.html#TOC_1">http://www.obfuscation.org/ipf/ipf-howto.html#TOC_1</uri>
      és <uri xlink:href="http://coombs.anu.edu.au/~avalon/ip-filter.html">http://coombs.anu.edu.au/~avalon/ip-filter.html</uri>
      címeken olvashatunk (angolul).</para>

    <para>Az IPF gyakran ismételt kérdései a <uri xlink:href="http://www.phildev.net/ipf/index.html">http://www.phildev.net/ipf/index.html</uri> címen
      érhetõek el (angolul).</para>

    <para>A nyílt forrású IPFILTER
      levelezési lista kereshetõ archívumait a <uri xlink:href="http://marc.theaimsgroup.com/?l=ipfilter">http://marc.theaimsgroup.com/?l=ipfilter</uri>
      címen találjuk (angolul).</para>

    <sect2>
      <title>Az IPF engedélyezése</title>

      <indexterm>
	<primary>IPFILTER</primary>
	<secondary>engedélyezés</secondary>
      </indexterm>

      <para>Az IPF megtalálható a &os;
	alaptelepítésében mint menet közben
	külön betölthetõ modul.  Ha az
	<filename>rc.conf</filename> állományba
	beírjuk a <literal>ipfilter_enable="YES"</literal> sort,
	akkor ez a modul dinamikusan betöltõdik.  A
	betölthetõ modul alapból naplóz
	és a <literal>default pass all</literal>
	beállítást tartalmazza.  Ha helyette a
	<literal>block all</literal> szabályt akarjuk
	használni, akkor emiatt még nem kell
	feltétlenül újrafordítanunk a &os;
	rendszermagját, elég ha egyszerûen csak a
	szabályrendszerünk végére
	beszúrjuk.</para>

    </sect2>

    <sect2>
      <title>A rendszermag beállításai</title>

      <indexterm>
	<primary>a rendszermag
	  beállításai</primary>
	<secondary>IPFILTER</secondary>
      </indexterm>

      <indexterm>
	<primary>a rendszermag
	  beállításai</primary>
	<secondary>IPFILTER_LOG</secondary>
      </indexterm>

      <indexterm>
	<primary>a rendszermag
	  beállításai</primary>
	<secondary>IPFILTER_DEFAULT_BLOCK</secondary>
      </indexterm>

      <indexterm>
	<primary>IPFILTER</primary>
	<secondary>a rendszermag
	  beállításai</secondary>
      </indexterm>

      <para>Az IPF használatához nem kötelezõ a
	következõ beállításokkal
	újrafordítani a &os; rendszermagját, itt
	csupán
	háttérinformációként
	szerepel.  Amikor az IPF a rendszermagba kerül, a
	betölhetõ modulra nem lesz szükség.</para>

      <para>Az IPF a rendszermag forrásai között
	található
	<filename>/usr/src/sys/conf/NOTES</filename>
	állományban megadott
	beállításai a következõ
	módon foglalhatóak össze:</para>

      <programlisting>options IPFILTER
options IPFILTER_LOG
options IPFILTER_DEFAULT_BLOCK</programlisting>

      <para>Az <literal>options IPFILTER</literal> engedélyezi az
	<quote>IPFILTER</quote> tûzfal
	támogatását.</para>

      <para>Az <literal>options IPFILTER_LOG</literal>
	hatására az IPF az <filename>ipl</filename>
	csomagnaplózó pszeudo eszközre jegyzi fel a
	forgalmat &mdash; minden olyan szabály esetén,
	ahol megjelenik a <literal>log</literal> kulcsszó.</para>

      <para>Az <literal>options IPFILTER_DEFAULT_BLOCK</literal>
	megváltoztatja az alapértelmezett
	viselkedést, tehát minden olyan csomag, amely nem
	illeszkedik a tûzfal valamelyik <literal>pass</literal>
	típusú (átengedõ)
	szabályára, blokkolásra kerül.</para>

      <para>Ezek a beállítások csak azt
	követõen érvényesülnek, ha
	fordítottunk és telepítettünk
	velük egy új rendszermagot.</para>

    </sect2>

    <sect2>
      <title>Az <filename>rc.conf</filename> állomány
	beállításai</title>

      <para>Az <filename>/etc/rc.conf</filename>
	állományban a következõ
	utasításokra lesz szükségünk az
	IPF mûködésbe hozására a rendszer
	indítása során:</para>

      <programlisting>ipfilter_enable="YES"             # az ipf tûzfal indítása
ipfilter_rules="/etc/ipf.rules"   # betölti a szabályokat tartalmazó szöveges állományt
ipmon_enable="YES"                # elindítja az IP monitor naplózását
ipmon_flags="-Ds"                 # D = indítás démonként
                                  # s = naplózás a syslog használatával
                                  # v = a tcp ablak, ack, seq csomagok naplózása
                                  # n = az IP-címek és portok feloldása</programlisting>

      <para>Ha olyan helyi hálózat áll meg a
	tûzfal mögött, amely egy fenntartott
	privát IP-címtartományt használ,
	akkor még a következõ
	utasításokra is szükségünk lesz a
	címfordítás
	bekapcsolásához:</para>

      <programlisting>gateway_enable="YES"              # a helyi hálózat átjárója
ipnat_enable="YES"                # az ipnat funkció elindítása
ipnat_rules="/etc/ipnat.rules"    # az ipnat mûködéséhez szükséges definíciók</programlisting>

    </sect2>

    <sect2>
      <title>IPF</title>

      <indexterm><primary><command>ipf</command></primary></indexterm>

      <para>Az &man.ipf.8; parancs használható a
	szabályokat tartalmazó állomány
	betöltésére.  Általában egy
	állományba írjuk össze a tûzfal
	szabályait és ezzel a paranccsal
	cseréljük le egyszerre a tûzfalban levõ
	jelenlegi szabályokat:</para>

      <screen>&prompt.root; <userinput>ipf -Fa -f /etc/ipf.rules</userinput></screen>

      <para>Az <option>-Fa</option> az összes belsõ
	szabály törlését jelenti.</para>

      <para>Az <option>-f</option> jelzi, hogy egy
	állományból kell beolvasni a
	betöltendõ szabályokat.</para>

      <para>Ezzel mintegy lehetõségünk van
	változtatni a korábban
	összeállított szabályainkon, futtatni
	a fenti IPF parancsot és ezen keresztül úgy
	frissíteni a szabályok friss
	másolatával a már mûködõ
	tûzfalat, hogy nem is kell újraindítanunk a
	rendszert.  Ez a módszer igen kényelmes az
	új szabályok
	kipróbálásához, mivel
	bármikor tetszõlegesen
	végrehajtható.</para>

      <para>Az &man.ipf.8; man oldala tartalmazza a parancsnak
	megadható további
	beállításokat.</para>

      <para>Az &man.ipf.8; parancs a szabályokat
	tároló állományt egy
	szabványos szöveges állománynak
	tekinti, semmilyen szimbolikus helyettesítést
	alkalmazó szkriptet nem fogad el.</para>

      <para>Lehetõségünk van azonban olyan IPF
	szabályokat készíteni, amelyek
	kiaknázzák a szkriptek szimbolikus
	helyettesítésének lehetõségeit.
	Errõl bõvebben lásd <xref linkend="firewalls-ipf-rules-script"/>.</para>

    </sect2>

    <sect2>
      <title>Az IPFSTAT</title>

      <indexterm><primary><command>ipfstat</command></primary></indexterm>

      <indexterm>
	<primary>IPFILTER</primary>
	<secondary>statisztika</secondary>
      </indexterm>

      <para>Az &man.ipfstat.8; alapértelmezés szerint a
	arra használatos, hogy le tudjuk kérdezni
	és megjeleníteni a tûzfalhoz tartozó
	számlálók értékeit, amelyek a
	legutóbbi indítás vagy az <command>ipf
	-Z</command> parancs által kiadott
	lenullázásuk óta a bejövõ vagy
	kimenõ forgalomból a megadott szabályoknak
	megfelelõ csomagok alapján gyûjtenek össze
	statisztikákat.</para>

      <para>A parancs mûködésének
	részleteit az &man.ipfstat.8; man oldalon
	olvashatjuk.</para>

      <para>Az &man.ipfstat.8; meghívása alapból
	így néz ki:</para>

      <screen>input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0
 output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0
 input packets logged: blocked 99286 passed 0
 output packets logged: blocked 0 passed 0
 packets logged: input 0 output 0
 log failures: input 3898 output 0
 fragment state(in): kept 0 lost 0
 fragment state(out): kept 0 lost 0
 packet state(in): kept 169364 lost 0
 packet state(out): kept 431395 lost 0
 ICMP replies: 0 <acronym>TCP</acronym> RSTs sent: 0
 Result cache hits(in): 1215208 (out): 1098963
 IN Pullups succeeded: 2 failed: 0
 OUT Pullups succeeded: 0 failed: 0
 Fastroute successes: 0 failures: 0
 <acronym>TCP</acronym> cksum fails(in): 0 (out): 0
 Packet log flags set: (0)</screen>

      <para>Az <option>-i</option> mint bejövõ (inbound), vagy
	az <option>-o</option> mint kimenõ (outbound) forgalomra
	vonatkozó paraméterek megadásával a
	rendszermagban az adott oldalon jelenleg telepített
	és alkalmazott szabályokat kérhetjük
	le és jeleníthetjük meg.</para>

      <para>Az <command>ipfstat -in</command> parancs így a
	bejövõ forgalomra vonatkozó belsõ
	szabályokat mutatja a szabályok
	számával.</para>

      <para>Az <command>ipfstat -on</command> parancs a kimenõ
	forgalmat érintõ belsõ szabályokat
	mutatja a szabályok számával.</para>

      <para>Az eredmény körülbelül ilyen
	lesz:</para>

      <screen>@1 pass out on xl0 from any to any
@2 block out on dc0 from any to any
@3 pass out quick on dc0 proto tcp/udp from any to any keep state</screen>

      <para>Az <command>ipfstat -ih</command> a bejövõ
	forgalomhoz tartozó belsõ szabályokat mutatja
	és mindegyik elé odaírja, hogy eddig mennyi
	csomag illeszkedett rájuk.</para>

      <para>Az <command>ipfstat -oh</command> ugyanígy a
	kimentõ forgalom esetén mutatja a belsõ
	szabályokat és mindegyik elõtt
	feltünteti, hogy az adott pillanatig mennyi csomag
	illeszkedett rájuk.</para>

      <para>A kimenete nagyjából ilyen lesz:</para>

      <screen>2451423 pass out on xl0 from any to any
354727 block out on dc0 from any to any
430918 pass out quick on dc0 proto tcp/udp from any to any keep state</screen>

      <para>Az <command>ipfstat</command> parancs talán egyik
	legfontosabb funkciója a <option>-t</option>
	kapcsolóval csalható elõ, melynek
	hatására a rendszerben aktív
	állapotok táblázatát mutatja meg
	ugyanúgy, ahogy a &man.top.1; a &os; rendszerben
	futó programokat.  Amikor a tûzfalunk
	támadás alatt áll, ezzel a
	funkcióval tudjuk a problémát
	beazonosítani, leásni a mélyébe
	és látni a támadótól
	érkezõ csomagokat.  A
	kiegészítésképpen megadható
	alkapcsolók megadásával
	kiválaszthatjuk azt a cél vagy forrás
	IP-címet, portot vagy protokollt, amelyet valós
	idõben meg akarunk figyelni.  Ennek részleteit az
	&man.ipfstat.8; man oldalán láthatjuk.</para>

    </sect2>

    <sect2>
      <title>Az IPMON</title>

      <indexterm><primary><command>ipmon</command></primary></indexterm>

      <indexterm>
	<primary>IPFILTER</primary>
	<secondary>naplózás</secondary>
      </indexterm>

      <para>Az <command>ipmon</command> megfelelõ
	mûködéséhez be kell kapcsolnunk a
	rendszermag <literal>IPFILTER_LOG</literal>
	beállítását.  Ez a parancs
	két különbözõ módban
	használható.  Ha parancsot a <option>-D</option>
	opció nélkül gépeljük be, akkor
	ezek közül alapból a natív módot
	kapjuk meg.</para>

      <para>A démon mód abban az esetben hasznos, ha
	folyamatosan naplózni akarjuk a rendszerben zajló
	eseményeket, majd késõbb ezeket
	átnézni.  Így képes egymással
	együttmûködni a &os; és az IPFILTER.  A
	&os; beépítve tartalmaz olyan
	lehetõséget, aminek révén
	magától cseréli a rendszernaplókat.
	Ezért ha átküldjük a &man.syslogd.8;
	démonnak a naplózandó üzeneteket,
	akkor sokkal jobban járunk, mintha egyszerûen csak
	mezei állományba naplóznánk.  Az
	<filename>rc.conf</filename> alapértelmezései
	között az <literal>ipmon_flags</literal>
	beállítás a <option>-Ds</option>
	kapcsolókat rögzíti:</para>

      <programlisting>ipmon_flags="-Ds" # D = indítás démonként
                  # s = naplózás a syslog használatával
                  # v = a tcp ablak, ack, seq csomagok naplózása
                  # n = az IP-címek és portok nevének feloldása</programlisting>

      <para>Ennek a viselkedésnek az elõnyei minden
	bizonnyal egyértelmûek.
	Segítségével képesek vagyunk az
	esetek megtörténte után
	átnézni, hogyan milyen csomagokat dobott el a
	rendszer, azok milyen címekrõl érkeztek
	és hova szánták.  Ez egy komoly fegyver a
	támadók lenyomozásában.</para>

      <para>Hiába engedélyezzük a
	naplózást, az IPF
	önszántából semmilyen
	naplózási szabályt nem fog gyártani.
	A tûzfal gazdájának kell eldöntenie,
	hogy a szabályokat közül melyiket akarja
	naplózni, és így neki kell megadnia a
	<literal>log</literal> kulcsszót ezekben az esetekben.
	Normális esetben csak a <literal>deny</literal>
	szabályokat naplózzák.</para>

      <para>Egyáltalán nem ritka, hogy a
	szabályrendszer végén egy
	alapértelmezés szerint mindent eldobó
	szabály áll, amely naplóz.  Ezzel
	lehetõségünk nyílik
	rögzíteni azokat a csomagokat, amelyek egyetlen
	szabályra sem illeszkedtek.</para>

    </sect2>

    <sect2>
      <title>Naplózás az IPMON
	használatával</title>

      <para>A <application>syslogd</application> egy saját
	módszert alkalmaz a naplózott adatok
	elkülönítésére.  Egy
	<quote>funkciók</quote> (facility) és
	<quote>szintek</quote> (level) segítségével
	kialakított speciális csoportosítást
	alkalmaz.  Az IPMON <option>-Ds</option> módja
	alapértelmezés szerint a <literal>local0</literal>
	<quote>funkciót</quote> használja.  Ezen
	túl a következõ szinteken
	különíthetjük el igényeinknek
	megfelelõen a naplózott adatokat:</para>

      <screen>LOG_INFO - az átengedés vagy blokkolás helyett a "log" kulcsszóval ellátott csomagok
LOG_NOTICE - az át is engedett csomagok
LOG_WARNING - a blokkolt csomagok
LOG_ERR - a naplózott csomagok közül azok, amelyek túlságosan kicsik (hibás a fejlécük)</screen>

      <para>Az IPFILTER csak akkor tud naplózni a
	<filename>/var/log/ipfilter.log</filename>
	állományba, ha elõtte létrehozzuk.  Az
	alábbi parancs erre tökéletesen
	megfelelõ:</para>

      <screen>&prompt.root; <userinput>touch /var/log/ipfilter.log</userinput></screen>

      <para>A &man.syslogd.8; mûködését az
	<filename>/etc/syslog.conf</filename> állományban
	szereplõ definíciók vezérlik.  A
	<filename>syslog.conf</filename> állomány
	számottevõ mértékben képes
	meghatározni azt, ahogy a
	<application>syslog</application> az IPF és a
	hozzá hasonló alkalmazásoktól kapott
	rendszerszintû üzeneteket kezeli.</para>

      <para>Az <filename>/etc/syslog.conf</filename>
	állományba az alábbi sor kell
	felvennünk:</para>

      <programlisting>local0.* /var/log/ipfilter.log</programlisting>

      <para>A <literal>local0.*</literal> megadásával az
	összes ilyen típusú üzenet egy
	elõre rögzített helyre kerül.</para>

      <para>Az <filename>/etc/syslog.conf</filename>
	állományban elvégzett
	módosításokat úgy
	léptethetjük érvénybe, ha
	újraindítjuk a
	számítógépet vagy az
	<command>/etc/rc.d/syslogd reload</command> paranccsal
	megkérjük a &man.syslogd.8; démont, hogy
	olvassa újra az <filename>/etc/syslog.conf</filename>
	állományt.</para>

      <para>Az imént létrehozott naplót ne
	felejtsük el megadni az
	<filename>/etc/newsyslog.conf</filename>
	állományban sem, és akkor ezzel a
	cseréjét is megoldjuk.</para>

    </sect2>

    <sect2>
      <title>A naplózott üzenetek formátuma</title>

      <para>Az <command>ipmon</command> által létrehozott
	üzenetek whitespace karakterekkel elválasztott
	adatmezõkbõl állnak.  A következõ
	mezõk az összes üzenet esetében
	megjelennek:</para>

      <orderedlist>
	<listitem>
	  <para>A csomag megérkezésének
	    dátuma</para>
	</listitem>

	<listitem>
	  <para>A csomag megérkezésének
	    idõpontja.  ÓÓ:PP:MM.E alakban jelennek
	    meg az órák, percek, másodpercek
	    és ezredmásodpercek (ez több
	    számjegy hosszú is lehet) szerint</para>
	</listitem>

	<listitem>
	  <para>Azon interfész a neve, ahol a csomag
	    feldolgozásra került, például
	    <filename>dc0</filename></para>
	</listitem>

	<listitem>
	  <para>A szabályhoz tartozó csoport és
	    sorszám, például
	    <literal>@0:17</literal></para>
	</listitem>
      </orderedlist>

      <para>Ezek az <command>ipfstat -in</command> paranccsal
	nézhetõek meg.</para>

      <orderedlist>
	<listitem>
	  <para>Cselekvés: a p mint átment (passed), b
	    mint blokkolt (blocked), S mint rövid csomag (short
	    packet), n mint egyik szabályra sem illeszkedett (not
	    match), L mint naplózás (log).  A
	    módosítók
	    megjelenítésének sorrendje: S, p, b, n,
	    L.  A nagybetûs P és B azt jelzi, hogy a
	    csomagot egy felsõbb szintû
	    beállítás miatt
	    naplózták, nem egy szabály
	    hatására.</para>
	</listitem>

	<listitem>
	  <para>Címek: ez tulajdonképpen három
	    mezõt takar: a forrás címet és
	    portot (melyet egy vesszõ választ el), a -&gt;
	    jelet és cél címet és portot.
	    Például: <literal>209.53.17.22,80 -&gt;
	    198.73.220.17,1722</literal>.</para>
	</listitem>

	<listitem>
	  <para>A <literal>PR</literal> után a protokoll neve
	    vagy száma olvasható, például
	    <literal>PR tcp</literal>.</para>
	</listitem>

	<listitem>
	  <para>A <literal>len</literal> csomaghoz tartozó
	    fejléc és törzsének teljes
	    hosszát jelöli, például
	    <literal>len 20 40</literal>.</para>
	</listitem>
      </orderedlist>

      <para>Amennyiben a csomag <acronym>TCP</acronym>, egy
	kötõjellel kezdõdõen további
	mezõk is megjelenhetnek a beállított
	opcióknak megfelelõ betûk
	képében.  A betûket és
	beállításaikat az &man.ipf.5; man
	oldalán olvashatjuk.</para>

      <para>Amennyiben a csomag ICMP, a sort két mezõ
	zárja, melyek közül az elsõ tartalma
	mindig <quote>ICMP</quote>, és ezt egy perjellel
	elválasztva az ICMP üzenet típusa és
	altípusa követi.  Tehát például
	az ICMP 3/3 a <quote>nem elérhetõ port</quote>
	üzenetet hordozza.</para>

    </sect2>

    <sect2 xml:id="firewalls-ipf-rules-script">
      <title>A szabályok felírása szimbolikus
	helyettesítéssel</title>

      <para>Az IPF használatában gyakorlott
	felhasználók közül
	néhányan képesek olyan
	stílusú szabályrendszert
	készíteni, ahol szimbolikus
	helyettesítést használnak.  Ennek az egyik
	legnagyobb elõnye az, hogy ilyenkor elég csak a
	szimbolikus névhez tartozó értéket
	megváltoztatni és amikor a szkript lefut, akkor az
	összes rá hivatkozó szabályba ez
	kerül be.  Szkript lévén a szimbolikus
	helyettesítéssel ki tudjuk emelni a gyakran
	használt értékeket és
	behelyettesíteni ezeket több helyre.  Ezt a most
	következõ példában
	láthatjuk.</para>

      <para>Az itt alkalmazott felírás kompatibilis az
	&man.sh.1;, &man.csh.1; és &man.tcsh.1;
	parancsértelmezõkkel.</para>

      <para>A szimbolikus helyettesítést egy
	dollárjellel fejezzük ki:
	<literal>&dollar;</literal>.</para>

      <para>A szimbolikus mezõkben nem szerepel a &dollar;
	jelölés.</para>

      <para>A szimbolikus mezõ tartalmát kettõs
	idézõjelbe (<literal>"</literal>)
	tesszük.</para>

      <para>Kezdjük így el a szabályok
	írását:</para>

      <programlisting>######### Az IPF szabályait tartalmazó szkript eleje ###########

oif="dc0"            # a kimenõ interfész neve
odns="192.0.2.11"    # az internet szolgáltató névszerverének IP-címe
myip="192.0.2.7"     # a szolgáltatótól kapott statikus IP-címünk
ks="keep state"
fks="flags S keep state"

# Választhatunk, hogy az /etc/ipf.rules állományt ebbõl a szkriptbõl
# hozzuk létre vagy futtathatjuk "magát" a szkriptet.
#
# Egyszerre csak az egyik sort használjuk.
#
# 1) Ezzel gyárhatjuk le az /etc/ipf.rules állományt:
#cat &gt; /etc/ipf.rules &lt;&lt; EOF
#
# 2) Ezzel futtathajuk "magát" a szkriptet:
/sbin/ipf -Fa -f - &lt;&lt; EOF

# Engedélyezzük a szolgáltató névszerverének elérését.
pass out quick on &dollar;oif proto tcp from any to &dollar;odns port = 53 &dollar;fks
pass out quick on &dollar;oif proto udp from any to &dollar;odns port = 53 &dollar;ks

# Engedélyezzük kifelé a titkosítatlan www funkciót.
pass out quick on &dollar;oif proto tcp from &dollar;myip to any port = 80 &dollar;fks

# Engedélyezzük kifelé a TLS SSL felett üzemelõ titkosított www funkciót.
pass out quick on &dollar;oif proto tcp from &dollar;myip to any port = 443 &dollar;fks
EOF
################## Itt az IPF szkript vége ########################</programlisting>

      <para>Ennyi lenne.  A példában szereplõ
	szabályok most nem annyira lényegesek, a
	hangsúly most igazából a szimbolikus
	helyettesítésen és annak
	használatán van.  Ha a fenti példát
	az <filename>/etc/ipf.rules.script</filename>
	állományba mentjük, akkor ezeket a
	szabályokat a következõ paranccsal újra
	tudjuk tölteni:</para>

      <screen>&prompt.root; <userinput>sh /etc/ipf.rules.script</userinput></screen>

      <para>Egyetlen aprócska gond van a beágyazott
	szimbólumokat tartalmazó
	állományokkal: az IPF maga nem képes
	megérteni a helyettesítéseket, azért
	közvetlenül nem olvassa a szkriptet.</para>

      <para>Ez a szkript két módon
	hasznosítható:</para>

      <itemizedlist>
	<listitem>
	  <para>Vegyük ki megjegyzésbõl a
	    <literal>cat</literal> paranccsal kezdõdõ sort,
	    és tegyük megjegyzésbe az
	    <literal>/sbin/ipf</literal> kezdetût.  A megszokottak
	    szerint tegyük az
	    <literal>ipfilter_enable="YES"</literal> sort az
	    <filename>/etc/rc.conf</filename> állományba,
	    majd minden egyes módosítása
	    után futtassuk le a szkriptet az
	    <filename>/etc/ipf.rules</filename> állomány
	    létrehozásához vagy
	    frissítéséhez.</para>
	</listitem>

	<listitem>
	  <para>Tiltsuk le az IPFILTER aktiválását
	    a rendszerindításkor, tehát
	    írjuk bele az <literal>ipfilter_enable="NO"</literal>
	    sort (ami mellesleg az alapértelmezett
	    értéke) az <filename>/etc/rc.conf</filename>
	    állományba.</para>

	  <para>Tegyünk egy, az alábbi szkripthez
	    hasonlót az <filename>/usr/local/etc/rc.d/</filename>
	    könyvtárba.  A szkriptnek adjuk valamilyen
	    értelmes nevet, például
	    <filename>ipf.loadrules.sh</filename>.  Az
	    <filename>.sh</filename> kiterjesztés
	    használata kötelezõ.</para>

	  <programlisting>#!/bin/sh
sh /etc/ipf.rules.script</programlisting>

	  <para>A szkript engedélyeit állítsuk be
	    úgy, hogy a <systemitem class="username">root</systemitem>
	    tulajdonában legyen és képes legyen
	    olvasni, írni valamint végrehajtani.</para>

	  <screen>&prompt.root; <userinput>chmod 700 /usr/local/etc/rc.d/ipf.loadrules.sh</userinput></screen>
	</listitem>
      </itemizedlist>

      <para>Most miután a rendszer elindult, az IPF
	szabályai be fognak töltõdni.</para>

    </sect2>

    <sect2>
      <title>Szabályrendszerek az IPF-ben</title>

      <para>Az IPF esetében a szabályrendszer olyan
	szabályokból áll, amelyek a
	csomagokról tartalmuk alapján eldöntik, hogy
	át kell engedni vagy vissza kell tartani.  A gépek
	közt két irányban áramló
	csomagok egy munkamenet alapú társalgást
	képeznek.  A tûzfalhoz tartozó
	szabályrendszer egyaránt feldolgozza a
	internetrõl a hálózatunk felé
	igyekvõ csomagokat, illetve a hálózatunk
	ezekre adott válaszait.  Az egyes
	<acronym>TCP/IP</acronym> szolgáltatásokat (mint
	például telnet, www, levelezés stb.) a
	hozzájuk tartozó protokol és
	szabványos (fogadó) portszám írja
	le.  Ezekre a forrásról általában
	valamilyen nem szabványos (magasabb
	értékû) portról érkeznek
	csomagok.  Ekkor a kommunikáció összes
	paramétere (vagyis a portok és címek)
	bármelyike alapján definiálhatunk
	blokkolást vagy továbbengedést
	leíró szabályokat.</para>

      <indexterm>
	<primary>IPFILTER</primary>
	<secondary>a szabályok feldolgozásának
	  sorrendje</secondary>
       </indexterm>

      <para>Az IPF eredetileg úgy íródott, hogy a
	szabályokat <quote>az utolsó illeszkedõ
	szabály nyer</quote> stílusban dolgozza fel
	és csak állapot nélküli
	szabályokat ismert.  Az idõk folyamán az IPF
	szabályai kiegészültek a <quote>quick</quote>
	és az állapottartásra vonatkozó
	<quote>keep state</quote> opciókkal, amelynek
	köszönhetõen óriási
	mértékben korszerûsödött a
	szabályok feldolgozása.</para>

      <para>A szakaszban szereplõ utasítások olyan
	szabályokat alkalmaznak, amelyekben egyaránt
	szerepel a <quote>quick</quote> és az
	állapottartásért felelõs <quote>keep
	state</quote> beállítás.  Ez az
	inkluzív tûzfalak
	létrehozásának egyik
	alapeszköze.</para>

      <warning>
	<para>A tûzfal szabályainak
	  összeállítása során
	  <emphasis>nagyon óvatosnak</emphasis> kell
	  lennünk!  Bizonyos beállítások
	  hatására akár <emphasis>ki is
	  zárhatjuk magunkat</emphasis> a
	  szerverünkrõl.  Az ebbõl fakadó
	  esetleges kellemetlenségek elkerülése
	  érdekében javasoljuk, hogy a tûzfal
	  alapjait elõször helyi konzolról
	  építsük fel, ne pedig
	  távolról, például
	  <application>ssh</application>
	  segítségével.</para>
      </warning>

    </sect2>

    <sect2>
      <title>A szabályok felépítése</title>

      <indexterm>
	<primary>IPFILTER</primary>
	<secondary>a szabályok
	  felépítése</secondary>
      </indexterm>

      <para>A szabályok felépítésének
	bemutatását itt most leszûkítjük
	a modern állapottartó szabályokra és
	az <quote>elsõ illeszkedõ szabály nyer</quote>
	típusú feldolgozásra.  A szabályok
	felírásának régebbi módjai az
	&man.ipf.8; man oldalon találhatóak.</para>

      <para>A <literal>#</literal> karakterrel egy megjegyzés
	kezdetét jelezzük, és általában
	a sor végén vagy egy külön sorban bukkan
	fel.  Az üres sorokat a rendszer nem veszi
	figyelembe.</para>

      <para>A szabályok kulcsszavakat tartalmaznak.  Ezeknek a
	kulcsszavaknak balról jobbra haladva adott sorrendben
	kell szerepelniük.  A kulcsszavakat kiemeltük.  Egyes
	kulcsszavakhoz további beállítások
	is tartozhatnak, amelyek maguk is kulcsszavak lehetnek,
	és még további opciókkal
	rendelkezhetnek.  Az alábbi nyelvtan mindegyik
	elemét kiemeltük és az alábbiakban
	egyenként kifejtjük a részleteiket.</para>

      <para><replaceable>CSELEKVÉS BE-KI OPCIÓK
	SZûRÉS ÁLLAPOTTARTÓ PROTOKOLL
	FORRÁS_CÍM,CÉL_CÍM OBJEKTUM
	PORTSZÁM TCP_BEÁLLÍTÁS
	ÁLLAPOTTARTÓ</replaceable></para>

      <para><replaceable>CSELEKVÉS</replaceable> = block |
	pass</para>

      <para><replaceable>BE-KI</replaceable> = in | out</para>

      <para><replaceable>OPCIÓK</replaceable> = log | quick | on
	<replaceable>interfész</replaceable></para>

      <para><replaceable>SZûRÉS</replaceable> = proto
	<replaceable>érték</replaceable> |
	<replaceable>forrás/cél IP</replaceable> | port =
	<replaceable>szám</replaceable> | flags
	<replaceable>beállítás</replaceable></para>

      <para><replaceable>PROTOKOLL</replaceable> = tcp/udp | udp | tcp |
	icmp</para>

      <para><replaceable>FORRÁS_CÍM,CÉL_CÍM</replaceable>
	= all | from <replaceable>objektum</replaceable> to
	<replaceable>objektum</replaceable></para>

      <para><replaceable>OBJEKTUM</replaceable> =
	<replaceable>IP-cím</replaceable> | any</para>

      <para><replaceable>PORTSZÁM</replaceable> =
	<replaceable>portszám</replaceable></para>

      <para><replaceable>TCP_BEÁLLÍTÁS</replaceable>
	= S</para>

      <para><replaceable>ÁLLAPOTTARTÓ</replaceable> = keep
	state</para>

      <sect3>
	<title>CSELEKVÉS</title>

	<para>A cselekvés határozza meg, hogy mit kell
	  tenni azokkal a csomagokkal, amelyek illeszkednek a
	  szabály többi részére.  Minden
	  szabályhoz tartoznia <emphasis>kell</emphasis> egy
	  cselekvésnek.  A következõ cselekvések
	  közül választhatunk:</para>

	<para>A <literal>block</literal> megadásával a
	  szabályban szereplõ szûrési
	  feltételre illeszkedõ csomagot eldobjuk.</para>

	<para>A <literal>pass</literal> megadásával a
	  szabályban szereplõ szûrési
	  feltételre illeszkedõ csomagot
	  átengedjük a tûzfalon.</para>

      </sect3>

      <sect3>
	<title>BE-KI</title>

	<para>Az összes szûrési szabály
	  esetében kötelezõ egyértelmûen
	  nyilatkozunk arról, hogy a bemenõ vagy a
	  kimenõ forgalomra vonatkozik.  Ezért a
	  következõ kulcsszó vagy az
	  <literal>in</literal> vagy pedig az <literal>out</literal>, de
	  közülük egyszerre csak az egyiket szabad
	  használni, máskülönben a
	  szabály hibásnak minõsül.</para>

	<para>Az <literal>in</literal> jelenti, hogy a szabályt
	  az internet felõl az adott interfészen
	  beérkezõ csomagokra kell alkalmazni.</para>

	<para>Az <literal>out</literal> jelenti, hogy a szabályt
	  az internet felé az adott interfészen
	  kiküldött csomagokra kell alkalmazni.</para>
      </sect3>

      <sect3>
	<title>OPCIÓK</title>

	<note>
	  <para>Ezek az opciók csak a lentebb bemutatott
	    sorrendben használhatók.</para>
	</note>

	<para>A <literal>log</literal> jelzi, hogy illeszkedés
	  esetén a csomag fejlécét az
	  <filename>ipl</filename> eszközön keresztül
	  naplózni kell (lásd a
	  naplózásról szóló
	  szakaszt).</para>

	<para>A <literal>quick</literal>jelzi, hogy illeszkedés
	  esetén ez lesz a legutolsónak
	  ellenõrzött szabály és így egy
	  olyan <quote>rövidzárat</quote> tudunk
	  képezni a feldolgozásban, amellyel
	  elkerüljük a csomagra egyébként
	  vonatkozó többi szabály
	  illesztését.  Ez az opció a
	  korszerûsített szabályfeldolgozás
	  kihasználásához elengedhetetlen.</para>

	<para>Az <literal>on</literal> használatával a
	  szûrés feltételei közé
	  bevonhatjuk a csomaghoz tartozó hálózati
	  interfészt.  Itt az interfészek az
	  &man.ifconfig.8; által megjelenített
	  formában adhatóak meg.  Az opció
	  megadásával csak az adott interfészen az
	  adott irányba (befelé/kifelé)
	  közlekedõ csomagokra fog illeszkedni a
	  szabály.  Ez az opció a
	  korszerûsített szabályfeldolgozás
	  kihasználásához
	  nélkülözhetetlen.</para>

	<para>Amikor naplózunk egy csomagot, akkor a
	  hozzá tartozó fejléc az
	  <acronym>IPL</acronym> csomagnaplózó pszeudo
	  eszközhöz kerül.  A <literal>log</literal>
	  kulcsszó után közvetlenül a
	  következõ minõsítõk szerepelhetnek
	  (a következõ sorrendben):</para>

	<para>A <literal>body</literal> jelzi, hogy a csomag
	  tartalmának elsõ 128 byte-ját még
	  jegyezzük fel a fejléc mellé.</para>

	<para>A <literal>first</literal> minõsítõt
	  akkor érdemes használnunk, amikor a
	  <literal>log</literal> kulcsszót a <literal>keep
	  state</literal> opcióval együtt alkalmazzuk, mivel
	  ilyenkor csak a szabályt kialakító csomag
	  kerül naplózásra és nem minden
	  olyan, ami illeszkedik az állapottartási
	  feltételekre.</para>
      </sect3>

      <sect3>
	<title>SZûRÉS</title>

	<para>Ebben a szakaszban olyan kulcsszavak jelenhetnek meg,
	  amelyekkel a csomagok különféle
	  tulajdonságai alapján
	  ítélkezhetünk azok
	  illeszkedésérõl.  Itt adott egy
	  kiinduló kulcsszó, amelyhez további
	  kulcsszavak is tartoznak, és amelyek közül
	  csak egyet választhatunk.  Az alábbi
	  általános tulajdonságok alapján
	  tudjuk szûrni a csomagokat, ebben a sorrendben:</para>

      </sect3>

      <sect3>
	<title>PROTOKOLL</title>

	<para>A <literal>proto</literal> egy olyan kulcsszó,
	  amelyhez hozzá kell rendelnünk még
	  valamelyik opcióját is.  Ez az opció
	  segít az adott protokolloknak megfelelõen
	  válogatni a csomagok között.  A
	  korszerûsített szabályfeldolgozás
	  lehetõségeinek
	  kihasználásához
	  nélkülözhetetlen.</para>

	<para>Opcióként a <literal>tcp/udp | udp | tcp |
	  icmp</literal>, vagy bármelyik, az
	  <filename>/etc/protocols</filename> állományban
	  megtalálható kulcsszó
	  felhasználható.  A <literal>tcp/udp</literal>
	  ebbõl a szempontból speciálisnak
	  tekinthetõ, mivel hatására egyszerre
	  illeszthetõek a szabályra a <acronym>TCP</acronym>
	  és <acronym>UDP</acronym> csomagok, és
	  így a protokolltól eltekintve azonos
	  szabályok felesleges
	  többszörözését
	  kerülhetjük el.</para>

      </sect3>

      <sect3>
	<title>FORRÁS_CÍM/CÉL_CÍM</title>

	<para>Az <literal>all</literal> kulcsszó gyakorlatilag a
	  <quote>from any to any</quote> (<quote>bárhonnan
	  bárhova</quote>) szinonímája és
	  nem tartozik hozzá paraméter.</para>

	<para>A <literal>from forrás
	  to cél</literal>
	  felépítése: a <literal>from</literal>
	  és <literal>to</literal> kulcsszavak az IP-címek
	  illesztésére használhatóak.
	  Ilyenkor a szabályokban a forrás
	  <emphasis>és</emphasis> a cél
	  paramétereknek is szerepelniük kell.  Az
	  <literal>any</literal> egy olyan speciális
	  kulcsszó, amely tetszõleges IP-címre
	  illeszkedik.  Néhány példa az
	  alkalmazására: <literal>from any to
	  any</literal> vagy <literal>from 0.0.0.0/0 to any</literal>,
	  <literal>from any to 0.0.0.0/0</literal>, <literal>from
	  0.0.0.0/0 to any</literal> vagy <literal>from any to
	  0.0.0.0</literal>.</para>

	<para>Az IP-címek megadhatóak pontozott numerikus
	  formában a hálózati maszk bitekben
	  mért hosszával együtt, vagy akár
	  egyetlen pontozott numerikus IP-címként.</para>

	<para>Nincs lehetõség olyan
	  IP-címtartományok illesztésére,
	  amelyek nem adhatóak meg kényelmesen ponttal
	  elválasztott számok és maszk
	  hosszával.  A <package>net-mgmt/ipcalc</package> port az ilyen
	  számításokat könnyíti meg.  A
	  hálózati maszkok hosszának
	  megállapításban segíthet az
	  említett segédprogram (angol nyelvû)
	  honlapja: <uri xlink:href="http://jodies.de/ipcalc">http://jodies.de/ipcalc</uri>.</para>
      </sect3>

      <sect3>
	<title>PORT</title>

	<para>Amikor portra vonatkozó illeszkedést
	  írunk elõ, megadhatjuk a forrásra és
	  célra, amit aztán vagy csak
	  <acronym>TCP</acronym> vagy pedig csak <acronym>UDP</acronym>
	  csomagokra alkalmazunk.  A portok feltételeinek
	  megfogalmazásánál használhatjuk a
	  portok számát vagy az
	  <filename>/etc/services</filename> állományban
	  szereplõ nevüket.  Amikor a port egy
	  <literal>from</literal> típusú objektum
	  leírásában jelenik meg, akkor
	  automatikusan a forrásportot jelenti, míg a
	  <literal>to</literal> objektum leírásában
	  pedig a célportot.  A <literal>to</literal>
	  objektumoknál a port megadása elengedhetetlen a
	  korszerûsített szabályfeldolgozás
	  elõnyeinek kihasználásához.
	  Példa: <literal>from any to any port =
	  80</literal>.</para>

	<para>Az egyes portokat különbözõ
	  mûveletek segítségével, numerikusan
	  hasonlíthatjuk össze, ahol akár
	  porttartományt is megadhatunk.</para>

	<para>port "=" | "!=" | "&lt;" | "&gt;" | "&lt;=" | "&gt;=" |
	  "eq" | "ne" | "lt" | "gt" | "le" | "ge".</para>

	<para>A porttartományok megadásához
	  használjuk a <literal>port</literal> "&lt;&gt;" |
	  "&gt;&lt;" felírási módot.</para>

	<warning>
	  <para>A forrásra és célra
	    vonatkozó paraméterek után
	    szereplõ másik két paraméter
	    nélkülözhetetlen a
	    korszerûsített szabályfeldolgozás
	    mûködéséhez.</para>
	</warning>
      </sect3>

      <sect3>
	<title><acronym>TCP</acronym>_BEÁLLÍTÁS</title>

	<para>A beállítások csak a
	  <acronym>TCP</acronym> forgalom
	  szûrésénél
	  érvényesülnek.  A betûk jelölik
	  azokat a lehetséges beállításokat,
	  amelyek a <acronym>TCP</acronym> csomagok
	  fejlécében
	  megvizsgálhatóak.</para>

	<para>A korszerûsített
	  szabályfeldolgozás a <literal>flags S</literal>
	  paraméter segítségével ismeri fel
	  a <acronym>TCP</acronym> munkameneteket
	  kezdeményezõ kéréseket.</para>

      </sect3>

      <sect3>
	<title>ÁLLAPOTTARTÓ</title>

	<para>A <literal>keep state</literal> jelzi, hogy a
	  szabály paramétereinek megfelelõ
	  bármely csomag aktiválja az
	  állapottartó szûrés
	  használatát.</para>

	<note>
	  <para>Ez a beállítás
	    feltétlenül szükséges a
	    korszerûsített szabályfeldolgozás
	    megfelelõ kihasználásához.</para>
	</note>

      </sect3>
    </sect2>

    <sect2>
      <title>Állapottartó csomagszûrés</title>

      <indexterm>
	<primary>IPFILTER</primary>
	<secondary>állapottartó
	  szûrés</secondary>
      </indexterm>

      <para>Az állapottartó szûrés a csomagok
	kétirányú áramlását
	egy létrejött kapcsolatba sorolja be.  Amikor
	aktiválódik, az állapottartó
	szabály elõre dinamikusan létrehozza a
	kétirányú kommunikációban
	megforduló csomagokhoz a megfelelõ belsõ
	szabályokat.  Olyan vizsgálatokat végez,
	amelyek segítségével ki tudja
	deríteni, hogy a csomag küldõje és
	címzettje között fennálló
	kétirányú kapcsolat érvényes
	szabályok szerint zajlik-e.  Minden olyan csomagot, amely
	nem illeszkedik megfelelõen a kapcsolatra vonatkozó
	sémára, csalásnak tekintjük és
	automatikusan eldobjuk.</para>

      <para>Az állapottartás révén
	lehetõségünk van a <acronym>TCP</acronym> vagy
	<acronym>UDP</acronym> kapcsolatokhoz tartozó
	<acronym>ICMP</acronym> csomagokat is átengedni a
	tûzfalon.  Tehát ha kapunk egy 3-as
	típusú, 4-es kódú
	<acronym>ICMP</acronym> választ valamilyen
	böngészésre használt
	állapottartó szabályon keresztül
	kiküldött kérésre, akkor az
	automatikusan bejöhet.  Amelyik csomagot az IPF
	egyértelmûen képes besorolni az aktív
	kapcsolatba, még ha az eltérõ protokollt is
	használ, beengedi.</para>

      <para>Ami ilyenkor történik:</para>

      <para>Az internethez csatlakozó interfészen
	keresztül kifelé haladó csomagokat
	elõször egy dinamikus állapottábla
	alapján illesztjük, és ha a csomag
	illeszkedik az aktív kapcsolatban
	következõként várt csomagra, akkor
	átmegy a tûzfalon és a dinamikus
	állapottáblában frissül a kapcsolat
	állapota.  Az aktív munkameneten kívül
	csomagok pedig egyszerûen a kimenõ
	szabályrendszer szerint kerülnek
	ellenõrzésre.</para>

      <para>Hasonlóan az elõzõhöz, az internethez
	csatlakozó interfészen keresztül
	befelé haladó csomagokat elõször egy
	dinamikus állapottábla alapján
	illesztjük, és ha a csomag illeszkedik az
	aktív kapcsolatban következõként
	várt csomagra, akkor átmegy a tûzfalon
	és a dinamikus állapottáblában
	frissül a kapcsolat állapota.  Az aktív
	munkamenethez nem tartozó csomagok pedig egyszerûen
	a bejövõ szabályrendszer szerint kerülnek
	ellenõrzésre.</para>

      <para>Amikor egy kapcsolat befejezõdik, automatikusan
	törlõdik a dinamikus
	állapottáblából.</para>

      <para>Az állapottartó csomagszûrés
	használatával az újonnan keletkezõ
	kapcsolatok elutasítására vagy
	engedélyezésére tudunk koncentrálni.
	Ha engedélyeztük egy új kapcsolat
	létrejöttét, akkor a
	rákövetkezõ összes többi csomag
	automatikusan átmegy a tûzfalon és minden
	más hamis csomag eldobódik.  Ha tiltjuk az
	új kapcsolatot, akkor egyetlen
	rákövetkezõ csomag sem juthat át.  Az
	állapottartó szûrés által
	felkínált fejlett elemzési
	lehetõségek képesek védelmet
	nyújtani a behatolók részérõl
	alkalmazott megannyi különbözõ
	támadási módszer ellen.</para>
    </sect2>

    <sect2>
      <title>Példa inkluzív
	szabályrendszerre</title>

      <para>A most következõ szabályrendszer arra mutat
	példát, hogyan programozzunk le egy nagyon
	biztonságos inkluzív tûzfalat.  Az
	inkluzív tûzfalak csak a szabályainak
	megfelelõ szolgáltatásokat engedik
	keresztül, és alapértelmezés szerint
	minden mást blokkolnak.  Egy hálózat
	gépeit védõ tûzfalnak, amelyet gyakran
	<quote>hálózati tûzfalnak</quote> (network
	firewall) is neveznek, legalább két
	hálózati interfésszel kell rendelkeznie.
	Ezeket az interfészeket általában
	úgy állítják be, hogy
	tökéletesen megbíznak az egyik oldalban (a
	helyi hálózatban), a másikban (az
	internetben) pedig egyáltalán nem.  A
	tûzfalat egyébként úgy is
	beállíthatjuk, hogy csak a tûzfalat
	mûködtetõ gépet védje &mdash; ezt
	<quote>egyrendszeres tûzfalnak</quote> (host based
	firewall) nevezik.  Az ilyen típusú
	megoldásokat nem biztonságos
	hálózaton keresztül kommunikáló
	szervereknél alkalmaznak.</para>

      <para>Mindegyik &unix;-típusú rendszert,
	köztük a &os;-t is úgy
	alakították ki, hogy az operációs
	rendszeren belüli kommunikáció az
	<filename>lo0</filename> interfészen és a
	<systemitem class="ipaddress">127.0.0.1</systemitem> IP-címen
	keresztül történik.  A tûzfal
	szabályai között feltétlenül
	szerepelniük kell olyanoknak, amelyek lehetõvé
	teszik ezen a speciális intefészen a csomagok
	zavartalan mozgását.</para>

      <para>Az internetre csatlakozó interfészhez kell
	rendelni a kifelé és befelé haladó
	forgalom hitelesítését é a
	hozzáférésének
	vezérlését.  Ez lehet a
	felhasználói PPP által létrehozott
	<filename>tun0</filename> interfész vagy a DSL-,
	illetve kábelmodemhez csatlakozó
	hálózati kártya.</para>

      <para>Ahol egy vagy több hálózati kártya
	is csatlakozik több különbözõ helyi
	hálózathoz, úgy kell
	beállítani a hozzájuk tartozó
	interfészeket, hogy egymás felé és
	az internet felé képesek legyenek küldeni
	és fogadni.</para>

      <para>A szabályokat elõször három nagy
	csoportba kell szerveznünk: elõször jönnek a
	megbízható interfészek, ezeket követik
	az internet felé mutató interfészek,
	végül internet felõl jövõ, nem
	megbízható interfészeke.</para>

      <para>Az egyes csoportokban szereplõ szabályokat
	úgy kell megadni, hogy közülük elõre
	kerüljenek a leggyakrabban alkalmazottak, és a
	csoport utolsó szabálya blokkoljon és
	naplózzon minden csomagot az adott interfészen
	és irányban.</para>

      <para>A kimenõ forgalomat vezérlõ
	szabályrendszer csak <literal>pass</literal>
	(tehát átengedõ) szabályokat
	tartalmazhat, amelyek bentrõl az interneten
	elérhetõ szolgáltatásokat
	azonosítják egyértelmûen.  Az
	összes ilyen szabályban meg kell jelenni a
	<literal>quick</literal>, <literal>on</literal>,
	<literal>proto</literal>, <literal>port</literal> és
	<literal>keep state</literal>
	beállításoknak.  A <literal>proto
	tcp</literal> szabályok esetében meg kell adni a
	<literal>flag</literal> opciót is, amivel fel tudjuk
	ismertetni a kapcsolatok keletkezését és
	ezen keresztül aktiválni az
	állapottartást.</para>

      <para>A bejövõ forgalmat vezérlõ
	szabályrendszerben elõször az eldobni
	kívánt csomagokat kell megadni, aminek két
	eltérõ oka van.  Elõször is
	elõfordulhat, hogy a veszélyes csomagok
	részleges illeszkedés miatt szabályosnak
	tûnnek.  Az ilyen csomagokat értelemszerûen nem
	lenne szabad beengedni a szabályok részleges
	megfelelése alapján.  A másodszor az eleve
	ismerten problémás és értelmetlen
	csomagokat csendben el kellene vetni, mielõtt a szakaszhoz
	tartozó utolsó szabály fogná meg
	és naplózná.  Ez az utolsó
	szabály egyébként szükség
	esetén felhasználható a
	támadók elleni bizonyítékok
	begyûjtésére.</para>

      <para>A másik, amire még oda kell figyelnünk,
	hogy a blokkolt csomagok esetében semmilyen válasz
	nem keletkezzen, egyszerûen csak tûnjenek el.
	Így a támadó nem fogja tudni, hogy a
	csomagjai vajon elérték-e a rendszerünket.
	Minél kevesebb információt tudnak
	összegyûjteni a rendszerünkrõl a
	támadók, annál több idõt kell
	szánniuk csínytevéseik
	kieszelésére.  A <literal>log first</literal>
	opciót tartalmazó szabályok csak az
	illeszkedésnél fogják naplózni a
	hozzájuk tartozó eseményt.  Erre
	láthatunk példát az <literal>nmap OS
	fingerprint</literal> szabálynál.  Az <package>security/nmap</package> segédprogramot
	a támadók gyakran alkalmazzák a
	megtámadni kívánt szerver
	operációs rendszerének
	felderítésére.</para>

      <para>Minden <literal>log first</literal> opcióval megadott
	szabály illeszkedésénél a
	<command>ipfstat -hio</command> parancs
	meghatározódik az eddigi illeszkedések
	aktuális száma.  Nagyobb értékek
	esetében következtethetünk arra, hogy a
	rendszerünket megtámadták (vagyis csomagokkal
	árasztják éppen el).</para>

      <para>Az ismeretlen portszámok
	felderítésére az
	<filename>/etc/services</filename> állomány,
	esetleg a <uri xlink:href="http://www.securitystats.com/tools/portsearch.php">http://www.securitystats.com/tools/portsearch.php</uri>
	(angol nyelvû) honlap használható.</para>

      <para>Érdemes továbbá megnézni a
	trójai programok által használt portokat a
	<uri xlink:href="http://www.simovits.com/trojans/trojans.html">http://www.simovits.com/trojans/trojans.html</uri>
	címen (angolul).</para>

      <para>A következõ szabályrendszer egy olyan
	biztonságos <quote>inkluzív</quote>
	típusú tûzfal, amelyet éles rendszeren
	is használnak.  Ezt a rendszerünkön nem
	használt szolgáltatásokra vonatkozó
	<literal>pass</literal> szabályok
	törlésével könnyedén a
	saját igényeink szerint
	alakíthatjuk.</para>

      <para>Ha nem akarunk látni bizonyos üzeneteket, akkor
	vegyünk fel hozzájuk egy <literal>block</literal>
	típusú szabályt a befelé
	irányuló forgalomhoz tartozó
	szabályok közé.</para>

      <para>A szabályokban írjuk át a
	<filename>dc0</filename> interfész nevét annak
	a hálózati kártyának az
	interfészére, amelyen keresztül csatlakozunk
	az internethez.  A felhasználói PPP
	esetében ez a <filename>tun0</filename> lesz.</para>

      <para>Tehát a következõket kell beírni az
	<filename>/etc/ipf.rules</filename>
	állományba:</para>

      <programlisting>#################################################################
# A helyi hálózatunkon zajló forgalmat ne korlátozzuk.
# Csak akkor kell, ha helyi hálózathoz is csatlakozunk.
#################################################################

#pass out quick on xl0 all
#pass in quick on xl0 all

#################################################################
# A belsõ interfészen szintén ne korlátozzunk semmit.
#################################################################
pass in quick on lo0 all
pass out quick on lo0 all

#################################################################
# Az internet felé forgalmazó interfész (kimenõ kapcsolatok)
# A saját hálózatunkról belülrõl vagy errõl az átjáróról
# kezdeményezett kapcsolatokat vizsgáljuk az internet felé.
#################################################################

# Engedélyezzük az internet szolgáltatók névszerverének elérését,
# az "xxx" helyett a névszervet IP-címét kell megadni.
# Másoljuk le ezeket a sorokat, ha a szolgáltatónknak több
# névszerverét is beakarjuk állítani. A címeiket az /etc/resolv.conf
# állományban találjuk.
pass out quick on dc0 proto tcp from any to xxx port = 53 flags S keep state
pass out quick on dc0 proto udp from any to xxx port = 53 keep state

# DSL vagy kábeles hálózatoknál engedélyezzük a
# szolgáltatónk DHCP szerverének elérését.
# Ez a szabály nem kell, ha "felhasználói PPP"-vel
# kapcsolódunk az internethez, ilyenkor tehát az egész
# csoport törölhetõ.
# Használjuk az alábbi szabályt és keressük meg a naplóban az
# IP-címet. Ha megtaláltuk, akkor tegyük bele a megjegyzésben
# szereplõ szabályba és töröljük az elsõ szabályt.
pass out log quick on dc0 proto udp from any to any port = 67 keep state
#pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state

# Kifelé engedélyezzük a szabványos nem biztonságos WWW funkciókat.
pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state

# Kifelé engedélyezzük a biztonságos WWW funkciókat TLS SSL
# protokollal.
pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state

# Kifelé engedélyezzük az e-mailek küldését és fogadását.
pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state

# Kifelé engedélyezzük az idõ szolgáltatást.
pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state

# Kifelé engedélyezzük az nntp híreket.
pass out quick on dc0 proto tcp from any to any port = 119 flags S keep state

# Kifelé engedélyezzük az átjáróról és a helyi hálózatról a nem
# biztonságos FTP használatát (passzív és akív módokban is). Ez a
# funkció a mûködéséhez a nat szabályokat tartalmazó állományban
# hivatkozott FTP proxyt használja. Amennyiben a pkg_add paranccsal
# csomagokat akarunk telepíteni az átjáróra, erre a szabályra
# mindenképpen szükségünk lesz.
pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state

# Kifelé engedélyezzük az ssh/sftp/scp # (biztonságos telnet/rlogin/FTP)
# szolgáltatások # elérését az SSH (secure shell) használatával.
pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Kifelé engedélyezzük a nem biztonságos telnet elérését.
pass out quick on dc0 proto tcp from any to any port = 23 flags S keep state

# Kifelé engedélyezzük FreeBSD CVSUp funkcióját.
pass out quick on dc0 proto tcp from any to any port = 5999 flags S keep state

# Kifelé engedélyezzük a pinget.
pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state

# Kifelé engedélyezzük a helyi hálózatról érkezõ whois kéréseket.
pass out quick on dc0 proto tcp from any to any port = 43 flags S keep state

# Minden mást eldobunk és naplózzuk az elsõ elõfordulásukat.
# Ez a szabály blokkol alapértelmezés szerint mindent.
block out log first quick on dc0 all

#################################################################
# Az internet felõli interfész (bejövõ kapcsolatok)
# A saját hálózatunk felé vagy erre az átjáróra
# nyitott kapcsolatokat vizsgáljuk az internet felõl.
#################################################################

# Eldobjuk az összes olyan bejövõ forgalmat, amit hivatalosan nem
# lehetne továbbítani vagy fenntartott címterülethez tartozik.
block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918: privát IP
block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918: privát IP
block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918: privát IP
block in quick on dc0 from 127.0.0.0/8 to any       #helyi
block in quick on dc0 from 0.0.0.0/8 to any         #helyi
block in quick on dc0 from 169.254.0.0/16 to any    #DHCP
block in quick on dc0 from 192.0.2.0/24 to any      #dokumentációs célokra fenntartva
block in quick on dc0 from 204.152.64.0/23 to any   #Sun klaszterek összekötésére használt
block in quick on dc0 from 224.0.0.0/3 to any       #D és E osztályú multicast

##### Itt eldobunk egy rakás csúf dolgot ############
# Ezeket nem akarjuk a naplóban látni:

# Eldobjuk a töredékcsomagokat.
block in quick on dc0 all with frags

# Eldobjuk a túlságosan rövid TCP csomagokat.
block in quick on dc0 proto tcp all with short

# Eldobjuk a forrás által közvetített (source routed) csomagokat.
block in quick on dc0 all with opt lsrr
block in quick on dc0 all with opt ssrr

# Elutasítjuk az "OS fingerprint" kéréseket.
# Naplózzuk az elsõ elõfordulást, így nálunk lesz a kíváncsiskodó
# egyén IP-címe.
block in log first quick on dc0 proto tcp from any to any flags FUP

# Eldobunk mindent, aminek speciális beállításai vannak.
block in quick on dc0 all with ipopts

# Elutasítjuk a publikus pinget.
block in quick on dc0 proto icmp all icmp-type 8

# Elutasítjuk az ident kéréseket.
block in quick on dc0 proto tcp from any to any port = 113

# Blokkoljuk az összes Netbios szolgáltatást: 137=név, 138=datagram,
# 139=session. A Netbios az MS Windows megosztását implementálja.
# Blokkoljuk az MS Windows hosts2 névszerver kéréseit is a 81-es
# porton.
block in log first quick on dc0 proto tcp/udp from any to any port = 137
block in log first quick on dc0 proto tcp/udp from any to any port = 138
block in log first quick on dc0 proto tcp/udp from any to any port = 139
block in log first quick on dc0 proto tcp/udp from any to any port = 81

# Engedélyezzük a szolgáltatónk DHCP szerverétõl érkezõ forgalmat.
# Ebben a szabályban meg kell adnunk a szolgáltató DHCP szerverének
# IP-címét, mivel itt csak a hiteles forrásból fogadunk el csomagokat.
# Erre csak DSL- és kábelmodemes kapcsolat esetében van szükség, a
# "felhasználói PPP" alkalmazása során szükségtelen. Ez az IP-cím
# megegyezik a kimenõ kapcsolatoknál megadott címmel.
pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state

# Befelé engedélyezzük a szabványos WWW funkciót, mivel webszerverünk
# van.
pass in quick on dc0 proto tcp from any to any port = 80 flags S keep state

# Befelé engedélyezzük az internetrõl érkezõ nem biztonságos telnet
# kapcsolatokat. Azért nem biztonságos, mert az azonosítókat és
# jelszavakat titkosítatlan formában közli az interneten keresztül.
# Töröljük ezt a szabályt, ha nem használunk telnet szervert.
#pass in quick on dc0 proto tcp from any to any port = 23 flags S keep state

# Befelé engedélyezzük az internetrõl # érkezõ ssh/sftp/scp (biztonságos
# telnet/rlogin/FTP) # kapcsolatokat az SSH (secure shell) használatával.
pass in quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Minden mást dobjuk el és naplózzuk az elsõ elõfordulásukat.
# Az elsõ alkalom naplózásával elejét tudjuk venni a "Denial of
# Service" típusú támadásoknak, amivel egyébként lehetséges lenne a
# napló elárasztása.
# Ez a szabály blokkol alapértelmezés szerint mindent.
block in log first quick on dc0 all
################### Itt van a szabályok vége ##############################</programlisting>
    </sect2>

    <sect2>
      <title><acronym>NAT</acronym></title>

      <indexterm><primary>NAT</primary></indexterm>
      <indexterm>
	<primary>IP maszkolás</primary>
	<see>NAT</see>
      </indexterm>

      <indexterm>
	<primary>hálózati
	  címfordítás</primary>
	<see>NAT</see>
      </indexterm>

      <para>A <acronym>NAT</acronym> jelentése <emphasis>Network
	Address Translation</emphasis>, vagyis hálózati
	címfordítás.  A &linux; esetében ezt
	<quote>IP masqueradingnak</quote>, vagyis IP maszkolásnak
	hívják.  A hálózati
	címfordítás és az IP
	maszkolás lényegben ugyanazt takarja.  Az IPF
	címfordításért felelõs
	funkciójának köszönhetõen
	képesek vagyunk a tûzfal mögött
	elhelyezkedõ helyi hálózat
	számára megosztani az
	internet-szolgáltatól kapott publikus
	IP-címet.</para>

      <para>Sokakban felmerülhet a kérdés, hogy erre
	vajon mi szükségünk lehet.  Az
	internet-szolgáltatók a
	magánszemélyeknek általában
	dinamikus IP-címeket osztanak ki.  A dinamikus itt arra
	utal, hogy a címünk minden alkalommal
	változik, amikor betárcsázunk a
	szolgáltatóhoz vagy amikor ki- és
	bekapcsoljuk a modemünket.  Ez a dinamikus IP-cím
	fog azonosítani minket az interneten.</para>

      <para>Most tegyük fel, hogy öt gépünk van
	otthon, viszont csak egyetlen elõfizetéssel
	rendelkezünk.  Ebben az esetben öt telefonvonalat
	kellene használnunk és mindegyik géphez
	elõfizetni az internetre.</para>

      <para>A hálózati címfordítás
	alkalmazásával azonban mindössze egyetlen
	elõfizetés kell.  A gépek közül
	négyet hozzákötünk egy switch-hez
	és a switch-et pedig a fennmaradó géphez,
	amelyen &os; fut.  Ez utóbbi lesz az így
	kialakított helyi hálózatunk
	átjárója.  A tûzfalban
	mûködõ címfordítás
	segítségével a helyi
	hálózaton található gépek
	IP-címeit észrevétlenül át
	tudjuk fordítani a hálózatunk publikus
	IP-címére, ahogy a csomagok elhagyják az
	átjárót.  A beérkezõ csomagok
	esetében mindez visszafelé történik
	meg.</para>

      <para>Az IP-címek közül adott egy
	tartomány, amit a címfordítást
	használó helyi hálózatok
	részére tartanak fenn.  Az RFC&nbsp;1918 szerint
	az alábbi IP-címtartományok
	használhatók a helyi hálózatban,
	mivel ezeken keresztül közvetlenül sosem lehet
	kijutni az internetre:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <colspec colwidth="1*"/>
	  <colspec colwidth="1*"/>
	  <colspec colwidth="1*"/>

	  <tbody>
	    <row>
	      <entry>Kezdõ IP: <systemitem class="ipaddress">10.0.0.0</systemitem></entry>
	      <entry>-</entry>
	      <entry>Záró IP: <systemitem class="ipaddress">10.255.255.255</systemitem></entry>
	    </row>

	    <row>
	      <entry>Kezdõ IP: <systemitem class="ipaddress">172.16.0.0</systemitem></entry>
	      <entry>-</entry>
	      <entry>Záró IP: <systemitem class="ipaddress">172.31.255.255</systemitem></entry>
	    </row>

	    <row>
	      <entry>Kezdõ IP: <systemitem class="ipaddress">192.168.0.0</systemitem></entry>
	      <entry>-</entry>
	      <entry>Záró IP: <systemitem class="ipaddress">192.168.255.255</systemitem></entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>IP<acronym>NAT</acronym></title>

      <indexterm>
	<primary>NAT</primary>
	<secondary>IPFILTER</secondary>
      </indexterm>

      <indexterm><primary><command>ipnat</command></primary></indexterm>

      <para>A címfordításra vonatkozó
	szabályokat az <command>ipnat</command> paranccsal tudjuk
	betölteni.  Az ilyen típusú
	szabályokat általában az
	<filename>/etc/ipnat.rules</filename> állományban
	találjuk.  A részleteket lásd az
	&man.ipnat.1; man oldalán.</para>

      <para>Amikor a címfordítás üzembe
	helyezése után meg akarjuk változtatni a
	címfordítás szabályait,
	elõször a címfordítás
	szabályait tartalmazó állományt
	módosítsuk, majd a belsõ
	címfordítási szabályok és a
	címfordítási táblázatban
	szereplõ aktív bejegyzések
	törléséhez futassuk le az
	<command>ipnat</command> parancsot a <option>-CF</option>
	beállítással.</para>

      <para>A címfordítási szabályok
	újratöltését egy ehhez hasonló
	paranccsal tudjuk elvégezni:</para>

      <screen>&prompt.root; <userinput>ipnat -CF -f /etc/ipnat.szabályok</userinput></screen>

      <para>A címfordításhoz tartozó
	statisztikákat ezzel a paranccsal tudjuk
	lekérdezni:</para>

      <screen>&prompt.root; <userinput>ipnat -s</userinput></screen>

      <para>A címfordítási
	táblázatban pillanatnyilag szereplõ
	összerendeléseket a következõ paranccsal
	tudjuk listázni:</para>

      <screen>&prompt.root; <userinput>ipnat -l</userinput></screen>

      <para>A szabályok feldolgozásával és
	az aktív szabályokkal/bejegyzésekkel
	kapcsolatos információk
	részletezését így
	engedélyezhetjük:</para>

      <screen>&prompt.root; <userinput>ipnat -v</userinput></screen>

    </sect2>

    <sect2>
      <title>A címfordítási
	szabályok</title>

      <para>A címfordítási szabályok nagyon
	rugalmasak és rengeteg olyan funkciót meg tudunk
	velük valósítani, ami az üzleti
	és otthoni felhasználók
	számára egyaránt hasznos.</para>

      <para>Itt most a szabályok
	felépítését csak
	egyszerûsítve mutatjuk be, leginkább a nem
	üzleti környezetek tekintetében.  A
	szabályok komplett formai leírását
	az &man.ipnat.5; man oldalán találjuk.</para>

      <para>Egy címfordítási szabály
	tehát valahogy így néz ki:</para>

      <programlisting>map <replaceable>INTERFÉSZ</replaceable> <replaceable>HELYI_IP_TARTOMÁNY</replaceable> -&gt; <replaceable>PUBLIKUS_CÍM</replaceable></programlisting>

      <para>A szabályt a <literal>map</literal> kulcsszó
	kezdi.</para>

      <para>A <replaceable>INTERFÉSZ</replaceable> helyére
	az internet felé mutató külsõ
	interfész nevét írjuk be.</para>

      <para>A <replaceable>HELYI_IP_TARTOMÁNY</replaceable> lesz
	az, amelyben a kliensek címeznek.  Ez
	például a <systemitem class="ipaddress">192.168.1.0/24</systemitem>.</para>

      <para>A <replaceable>PUBLIKUS_CÍM</replaceable> lehet egy
	külsõ IP-cím vagy a <literal>0/32</literal>
	speciális kulcsszó, amellyel a
	<replaceable>FELÜLET</replaceable>-hez rendelt
	IP-címre hivatkozunk.</para>

    </sect2>

    <sect2>
      <title>Hogyan mûködik a hálózati
	címfordítás</title>

      <para>A publikus cél felé haladó csomag
	megérkezik a helyi hálózatról.
	Miután a kimenõ kapcsolatokra vonatkozó
	szabályok átengedik, a
	címfordítás kapja meg a szerepet és
	fentrõl lefelé haladva nekilát alkalmazni a
	saját szabályait, ahol az elsõ egyezõ
	szerint cselekszik.  A címfordítás a
	szabályokat a csomaghoz tartozó interfészre
	és a forrás IP-címére illeszti.
	Amikor a csomag interfészének neve illeszkedik egy
	címfordítási szabályra, akkor
	ezután a csomag forrás (vagyis a helyi
	hálózaton belüli)
	IP-címérõl igyekszik eldönteni, hogy a
	szabály nyilának bal oldalán szereplõ
	tartományba esik-e.  Ha erre is illeszkedik, akkor a
	forrás IP-címét átírjuk a
	<literal>0/32</literal> kulcsszó alapján
	felderített publikus IP-címre.  A
	címfordító rutin ezt feljegyzi a
	saját belsõ táblázatába,
	így amikor a csomag visszatér az internetrõl,
	akkor képes lesz visszafordítani az eredeti
	belsõ IP-címére és
	feldolgozásra átadni a tûzfal
	szabályainak.</para>
    </sect2>

    <sect2>
      <title>A címfordítás
	engedélyezése</title>

      <para>A címfordítás életre
	keltéséhez a következõket kell
	beállítanunk az <filename>/etc/rc.conf</filename>
	állományban.</para>

      <para>Elõször engedélyezzük a
	gépünknek, hogy közvetítsen forgalmat az
	interfészek között:</para>

      <programlisting>gateway_enable="YES"</programlisting>

      <para>Minden alkalommal indítsuk el a
	címfordításért felelõs IPNAT
	programot:</para>

      <programlisting>ipnat_enable="YES"</programlisting>

      <para>Adjuk meg az IPNAT számára a
	betöltendõ szabályokat:</para>

      <programlisting>ipnat_rules="/etc/ipnat.rules"</programlisting>

    </sect2>

    <sect2>
      <title>Hálózati címfordítás
	nagyon nagy helyi hálózatok
	esetében</title>

      <para>Az olyan helyi hálózatokban, ahol rengeteg PC
	található vagy több alhálózatot
	is tartalmaz, az összes privát IP-cím
	egyetlen publikus IP-címbe
	tömörítése igen komoly
	problémává tud dagadni és az azonos
	portok gyakori használata a helyi hálózatra
	kötött számítógépek
	között ütközéseket okoz.  Két
	módon tudunk megoldást nyújtani erre a
	problémára.</para>

      <sect3>
	<title>A használható portok
	  kiosztása</title>

	<para>Egy normális címfordítási
	  szabály valahogy így nézne ki:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 0/32</programlisting>

	<para>A fenti szabályban a csomag
	  forrásportját az IP<acronym>NAT</acronym>
	  változatlanul a feldolgozás után hagyja.
	  Ha ehhez még hozzátesszük a
	  <literal>portmap</literal> kulcsszót, akkor ezzel
	  utasítani tudjuk az IP<acronym>NAT</acronym>-ot, hogy
	  csak az adott tartományban képezze le a
	  forrásportokat.  Például a
	  következõ szabály hatására az
	  IP<acronym>NAT</acronym> a forrásportokat egy adott
	  tartományon belül fogja
	  módosítani:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp 20000:60000</programlisting>

	<para>Ha viszont még inkább meg akarjuk
	  könnyíteni a dolgunkat, akkor itt egyszerûen
	  csak adjuk meg az <literal>auto</literal> kulcsszót,
	  amellyel az IP<acronym>NAT</acronym>
	  önmagától megállapítja, hogy
	  milyen portokat tud használni:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp auto</programlisting>

      </sect3>

      <sect3>
	<title>Több publikus cím használata</title>

	<para>Minden nagyobb helyi hálózat esetében
	  elérkezünk ahhoz a ponthoz, ahol már
	  egyetlen publikus cím nem elég.  Ha több
	  publikus IP-címmel is rendelkezünk, akkor
	  ezekbõl a címekbõl egy <quote>közös
	  készletet</quote> hozhatunk létre, amibõl
	  majd az IPNAT válogathat miközben a csomagok
	  címeit átírja kifelé
	  menetben.</para>

	<para>Például ahelyett, hogy a csomagokat egyetlen
	  publikus IP-címre képeznénk le, ahogy itt
	  tesszük:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 204.134.75.1</programlisting>

	<para>A hálózati maszk
	  segítségével meg tudjuk adni
	  IP-címek egy tartományát is:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/255.255.255.0</programlisting>

	<para>CIDR-jelöléssel:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/24</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>A portok átirányítása</title>

      <para>Gyakran elõfordul, hogy van webszerverünk,
	levelezõ szerverünk, adatbázis szerverünk
	és névszerverünk, melyek a helyi
	hálózat különbözõ
	gépein futnak.  Ebben az esetben a szerverekhez
	tartozó forgalmat is fordítanunk kell, illetve
	valamilyen módon a bejövõ forgalmat is
	át kell irányítanunk a helyi
	hálózat megfelelõ gépeihez.  Az
	IP<acronym>NAT</acronym> ezt a gondot a hálózati
	címfordítás
	átirányítást támogató
	funkcióival szünteti meg.  Tegyük fel, hogy a
	<systemitem class="ipaddress">10.0.10.25</systemitem> belsõ
	címen van egy webszerverünk, amelyhez a <systemitem class="ipaddress">20.20.20.5</systemitem> publikus IP tartozik.
	Ilyenkor a következõ szabályt adjuk meg:</para>

	<programlisting>rdr dc0 20.20.20.5/32 port 80 -&gt; 10.0.10.25 port 80</programlisting>

	<para>vagy:</para>

	<programlisting>rdr dc0 0.0.0.0/0 port 80 -&gt; 10.0.10.25 port 80</programlisting>

	<para>Így tudjuk beállítani a <systemitem class="ipaddress">10.0.10.33</systemitem> címmel
	  rendelkezõ névszervert a kintrõl
	  érkezõ névfeloldási
	  kérések fogadására:</para>

	<programlisting>rdr dc0 20.20.20.5/32 port 53 -&gt; 10.0.10.33 port 53 udp</programlisting>

    </sect2>

    <sect2>
      <title>Az FTP és a címfordítás</title>

      <para>Az FTP egy olyan õskövület, amely még
	az internet egy régi korszakából maradt fenn,
	amikor az egyetemek között még bérelt
	vonal létezett és az FTP szolgált a
	kutatók közt az állományok
	megosztására.  Ez még abban az idõben
	történt, amikor a biztonság
	egyáltalán nem volt lényeges szempont.  Az
	évek elõrehaladtával az FTP protokoll
	beleivódott a feltörekvõ internet
	gerincébe és a titkosítatlanul
	küldött azonosítóival és
	jelszavaival továbbra is ugyanolyan védtelen
	maradt.  Az FTP két változatban, aktív
	és passzív módban képes
	mûködni.  Az eltérés kettejük
	között az adatcsatorna
	megállapításában van.  A
	passzív mód sokkal biztonságosabb, mivel
	ilyenkor az adatcsatornát az FTP kapcsolatot
	kezdeményezõ állítja be.  Az FTP
	különbözõ módjainak
	magyarázatát és a köztük
	levõ különbséget a <uri xlink:href="http://www.slacksite.com/other/ftp.html">http://www.slacksite.com/other/ftp.html</uri>
	címen ismerhetjük meg részleteiben
	(angolul).</para>

      <sect3>
	<title>Az IPNAT szabályai</title>

	<para>Az IPNAT egy speciális beépített FTP
	  proxyval rendelkezik, amelyre a hálózati
	  címfordítás leképezései
	  között hivatkozhatunk.  Képes figyelni az
	  összes aktív vagy passzív FTP kapcsolathoz
	  tartozó kimenõ kérést és
	  ezekhez dinamikusan létrehozni olyan ideiglenes
	  szûrési szabályokat, amelyek valóban
	  csak az adatcsatornához felhasznált portokat
	  tartalmazzák.  Ezzel ki tudjuk
	  küszöbölni az FTP azon káros
	  hatását a tûzfalra nézve, hogy
	  egyszerre túlságosan sok magasabb
	  tartománybeli port legyen nyitva.</para>

	<para>Ez a szabály a belsõ hálózat
	  összes FTP forgalmát lekezeli:</para>

	<programlisting>map dc0 10.0.10.0/29 -&gt; 0/32 proxy port 21 ftp/tcp</programlisting>

	<para>Ez a szabály pedig az
	  átjáróról érkezõ FTP
	  forgalommal bírkózik meg:</para>

	<programlisting>map dc0 0.0.0.0/0 -&gt; 0/32 proxy port 21 ftp/tcp</programlisting>

	<para>Ez a szabály kezeli a belsõ
	  hálózatról érkezõ összes
	  nem FTP típusú forgalmat:</para>

	<programlisting>map dc0 10.0.10.0/29 -&gt; 0/32</programlisting>

	<para>Az FTP leképzésére vonatkozó
	  szabály a szokásos leképzési
	  szabály elé kerül.  Az összes csomag
	  fentrõl haladva az elsõ illeszkedõ
	  szabály alapján kerül feldolgozásra.
	  Elõször az interfész nevét
	  vizsgáljuk, majd a belsõ hálózatbeli
	  forrás IP-t, végül azt, hogy a csomag egy
	  FTP kapcsolat része.  Ha minden
	  paraméterében megfelel, akkor az FTP proxy
	  készít egy ideiglenes szûrési
	  szabályt hozzá, amellyel az FTP kapcsolathoz
	  tartozó csomagok mind a két irányba
	  képesek lesznek vándorolni, természetesen
	  a címfordítással együtt.  Az
	  összes többi bentrõl érkezõ csomag
	  átlép ezen a szabályon és
	  megáll a harmadiknál, ahol az
	  interfésznek és forrás IP-nek
	  megfelelõen átfordítjuk a
	  címét.</para>
      </sect3>

      <sect3>
	<title>Az IPNAT szûrési szabályai
	  FTP-re</title>

	<para>Az FTP esetében csak egyetlen szûrési
	  szabályra van szükségünk a
	  hálózati címfordításba
	  épített FTP proxy
	  használatához.</para>

	<para>FTP proxy nélkül az alábbi három
	  szabály kellene:</para>

	<programlisting># Kifelé engedélyezzük a belsõ gépek FTP elérést az internet irányába,
# aktív és passzív módokban.
pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state

# Kifelé engedélyezzük a passzív módhoz tartozó magasabb tartománybeli
# adatcsatornákat.
pass out quick on rl0 proto tcp from any to any port &gt; 1024 flags S keep state

# Aktív módban beengedjük az FTP szervertõl érkezõ adatcsatornát.
pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state</programlisting>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="firewalls-ipfw">
    <title>IPFW</title>

    <indexterm>
      <primary>tûzfalak</primary>
      <secondary>IPFW</secondary>
    </indexterm>

    <para>Az IPFIREWALL (<acronym>IPFW</acronym>) a &os; által
      támogatott tûzfalazó alkalmazás, melyet a
      &os; Projektben résztvevõ önkéntesek
      fejlesztettek ki és tartanak karban.  Régi
      típusú, állapottartás
      nélküli szabályokat használ, és
      az itt használatos szabályírási
      technikát <quote>egyszerû állapottartó
      megoldásnak</quote> nevezzük.</para>

    <para>Az IPFW szabvány &os;-ben levõ, mintaként
      szolgáló szabályrendszere (ez az
      <filename>/etc/rc.firewall</filename> és
      <filename>/etc/rc.firewall6</filename> állományokban
      található meg) annyira egyszerû, hogy komolyabb
      módosítások nélkül nem
      ajánlatos használni.  Ez a példa nem
      tartalmaz állapottartó szûrést, ami
      viszont a legtöbb esetben kívánatos lenne,
      ezért ezt a szakaszt nem erre alapozzuk.</para>

    <para>Az IPFW állapottartás nélküli
      szabályainak felépítésében
      olyan technikailag kifinomult leválogatási
      képességek bújnak meg, amelyek
      jócskán meghaladják az átlagos
      tûzfalépítõk tudását.  Az
      IPFW elsõsorban olyan szakemberek vagy szakmailag
      elõrehaladott felhasználók
      számára készült, akiknek
      speciális csomagszûrési igényeik vannak.
      A különbözõ protokollok
      használatának és a hozzájuk
      tartozó fejlécinformációk mindenre
      kiterjedõ ismerete szinte nélkülözhetetlen
      az IPFW valódi erejének
      kihasználásához.  Ez a szint azonban
      túlmutat a kézikönyv ezen szakaszának
      keretein.</para>

    <para>Az IPFW hét komponensbõl épül fel,
      melyek közül az elsõdleges a rendszermag
      tûzfalazásért felelõs
      szabályfeldolgozó és a
      hozzá tartozó csomagnyilvántartás, majd
      ezt követi a naplózás, a hálózati
      címfordítást aktiváló
      <literal>divert</literal> szabály, valamint a komolyabb
      célok megvalósítására alkalmas
      lehetõségek: a forgalom
      korlátozásáért felelõs dummynet,
      a továbbküldésre alkalmas <literal>fwd
      rule</literal> szabály, a hálózati hidak
      támogatása, illetve az ipstealth.  Az IPFW
      egyaránt használható IPv4 és IPv6
      esetén.</para>

    <sect2 xml:id="firewalls-ipfw-enable">
      <title>Az IPFW engedélyezése</title>

      <indexterm>
	<primary>IPFW</primary>
	<secondary>engedélyezése</secondary>
      </indexterm>

      <para>Az IPFW az alap &os; telepítésben
	külön, futás idõben betölthetõ
	modulként érhetõ el.  Ha az
	<filename>rc.conf</filename> állományban megadjuk
	a <literal>firewall_enable="YES"</literal>
	beállítást, akkor a rendszer
	indulásakor ezt a modult dinamikusan betölti.  Az
	IPFW-t csak akkor kell a &os; rendszermagjába
	beépítenünk, ha szükségünk
	van a címfordítási
	funkciójára is.</para>

      <para>Ha tehát az <filename>rc.conf</filename>
	állományban megadtuk a
	<literal>firewall_enable="YES"</literal> sort és
	újraindítottuk a
	számítógépünket, akkor a
	következõ fehérrel kiemelt üzenet fog
	megjelenni a rendszerindítás során:</para>

      <screen>ipfw2 initialized, divert disabled, rule-based forwarding disabled, default to deny, logging disabled</screen>

      <para>A <quote>logging disabled</quote> üzenetbõl
	kiderül, hogy a modul nem végez
	naplózást.  A naplózást és a
	hozzá tartozó részletesség
	szintjét úgy tudjuk beállítani, ha
	az <filename>/etc/sysctl.conf</filename>
	állományba felvesszük a következõ
	sorokat, amivel a következõ indításkor
	már mûködni fog:</para>

      <programlisting>net.inet.ip.fw.verbose=1
net.inet.ip.fw.verbose_limit=5</programlisting>

    </sect2>

    <sect2 xml:id="firewalls-ipfw-kernel">
      <title>A rendszermag beállításai</title>

      <indexterm>
	<primary>a rendszermag
	  beállításai</primary>
	<secondary>IPFIREWALL</secondary>
      </indexterm>

      <indexterm>
	<primary>a rendszermag
	  beállításai</primary>
	<secondary>IPFIREWALL_VERBOSE</secondary>
      </indexterm>

      <indexterm>
	<primary>a rendszermag
	  beállításai</primary>
	<secondary>IPFIREWALL_VERBOSE_LIMIT</secondary>
      </indexterm>

      <indexterm>
	<primary>IPFW</primary>
	<secondary>a rendszermag
	  beállításai</secondary>
      </indexterm>

      <para>Ha nem akarjuk kihasználni az IPFW által
	felkínált címfordítási
	lehetõségeket, akkor egyáltalán nem
	szükséges a &os; rendszermagjába
	belefordítani a támogatását.
	Ezért az alábbiakat csak
	kiegészítõ
	információként tüntettük
	fel.</para>

      <programlisting>options    IPFIREWALL</programlisting>

      <para>Ez a beállítás engedélyezi az
	IPFW használatát a rendszermag
	részeként.</para>

      <programlisting>options    IPFIREWALL_VERBOSE</programlisting>

      <para>Ezzel és a <literal>log</literal> kulcsszóval
	tudjuk az IPFW szabályain keresztülhaladó
	csomagokat naplózni.</para>

      <programlisting>options    IPFIREWALL_VERBOSE_LIMIT=5</programlisting>

      <para>Ez az érték korlátozza a
	&man.syslogd.8; segítségével
	naplózott azonos bejegyzések maximális
	számát.  Ezt a beállítást
	olyan veszélyes környezetekben érdemes
	használnunk, ahol naplózni akarunk.
	Segítségével meg tudjuk akadályozni,
	hogy a rendszernapló elárasztásával
	megakasszák a rendszerünket.</para>

      <indexterm>
	<primary>a rendszermag
	  beállításai</primary>
	<secondary>IPFIREWALL_DEFAULT_TO_ACCEPT</secondary>
      </indexterm>

      <programlisting>options    IPFIREWALL_DEFAULT_TO_ACCEPT</programlisting>

      <para>Ezen beállítás hatására a
	tûzfal alapértelmezés szerint mindent
	átenged, ami általában akkor jöhet
	jól, amikor elõször beállítjuk a
	tûzfalat.</para>

      <indexterm>
	<primary>a rendszermag
	  beállításai</primary>
	<secondary>IPDIVERT</secondary>
      </indexterm>

      <programlisting>options    IPDIVERT</programlisting>

      <para>Ezzel a beállítással
	engedélyezzük a címfordítás
	használatát.</para>

      <note>
	<para>Ha nem adjuk meg az IPFIREWALL_DEFAULT_TO_ACCEPT
	  beállítást, vagy ha nem
	  engedélyezzük a bejövõ csomagokat, akkor
	  a gépünkre semmilyen csomag nem lesz képes
	  bejutni, illetve onnan kijutni.</para>
      </note>

    </sect2>

    <sect2 xml:id="firewalls-ipfw-rc">
      <title>Az <filename>/etc/rc.conf</filename>
	beállításai</title>

      <para>Így tudjuk engedélyezni a
	tûzfalat:</para>

      <programlisting>firewall_enable="YES"</programlisting>

      <para>A &os;-hez mellékelt alapértelmezett
	tûzfaltípusok közül az
	<filename>/etc/rc.firewall</filename> állomány
	átolvasásával tudunk választani,
	és megadni az alábbi helyett:</para>

      <programlisting>firewall_type="open"</programlisting>

      <para>A következõ értékek állnak
	rendelkezésünkre:</para>

      <itemizedlist>
	<listitem>
	  <para><literal>open</literal> &mdash; átengedi az
	    összes forgalmat</para>
	</listitem>
	<listitem>
	  <para><literal>client</literal> &mdash; csak ezt a
	    gépet védi</para>
	</listitem>
	<listitem>
	  <para><literal>simple</literal> &mdash; az egész
	    hálózatot védi</para>
	</listitem>
	<listitem>
	  <para><literal>closed</literal> &mdash; a helyi
	    interfész kivételével minden IP
	    alapú forgalmat tilt</para>
	</listitem>
	<listitem>
	  <para><literal>UNKNOWN</literal> &mdash; tiltja a tûzfal
	    szabályainak betöltését</para>
	</listitem>
	<listitem>
	  <para><filename>állománynév</filename>
	    &mdash; a tûzfal szabályait tartalmazó
	    állomány abszolút elérési
	    útvonala</para>
	</listitem>
      </itemizedlist>

      <para>Két különbözõ módon lehet
	betölteni a saját <application>ipfw</application>
	szabályainkat.  Az egyik közülük, ha a
	<literal>firewall_type</literal> változóban
	megadjuk a <emphasis>tûzfal szabályait</emphasis>
	tartalmazó állomány abszolút
	elérési útvonalát, az &man.ipfw.8;
	parancssori beállításai nélkül.
	Az alábbi példában egy olyan egyszerû
	szabályrendszert láthatunk, amely blokkolja az
	összes bejövõ és kimenõ
	forgalmat:</para>

      <programlisting>add deny in
add deny out</programlisting>

      <para>Másrészrõl az
	<literal>firewall_script</literal> változóban is
	megadhatjuk azt a szkriptet, amelyben a
	rendszerindítás során meghívjuk
	<command>ipfw</command> parancsot.  Az iménti
	szabályrendszert az alábbi szkripttel tudjuk
	kiváltani:</para>

     <programlisting>#!/bin/sh

ipfw -q flush

ipfw add deny in
ipfw add deny out</programlisting>

      <note>
	<para>Ha a <literal>firewall_type</literal>
	  változó <literal>client</literal> vagy
	  <literal>simple</literal> értékét
	  használjuk, akkor az
	  <filename>/etc/rc.firewall</filename>
	  állományban található
	  alapértelmezett szabályokat érdemes
	  átvizsgálnunk, hogy kellõen illeszkednek-e
	  az adott géphez.  Hozzátennénk, hogy a
	  fejezetben szereplõ példák azt
	  feltételezik, hogy a <literal>firewall_script</literal>
	  értéke az <filename>/etc/ipfw.rules</filename>
	  állomány.</para>
      </note>

      <para>A naplózás így
	engedélyezhetõ:</para>

      <programlisting>firewall_logging="YES"</programlisting>

      <warning>
	<para>A <varname>firewall_logging</varname>
	  változó egyedül csak annyit tesz, hogy
	  beállítja a
	  <varname>net.inet.ip.fw.verbose</varname> sysctl
	  változónak az <literal>1</literal>
	  értéket (lásd <xref linkend="firewalls-ipfw-enable"/>).  A napló
	  korlátozására nincs külön
	  változó az <filename>rc.conf</filename>
	  állományon belül, de az
	  <filename>/etc/sysctl.conf</filename> állomány
	  segítségével és manuálisan
	  be tudjuk állítani a hozzá tartozó
	  változót:</para>

	<programlisting>net.inet.ip.fw.verbose_limit=5</programlisting>
      </warning>

      <para>Amennyiben a gépünk
	átjáróként viselkedik, tehát
	a &man.natd.8; segítségével
	címfordítást végez, a <xref linkend="network-natd"/>ban olvashatunk utána, hogy ehhez
	az <filename>/etc/rc.conf</filename> állományban
	milyen beállításokat kell megadnunk.</para>

    </sect2>

    <sect2 xml:id="firewalls-ipfw-cmd">
      <title>Az IPFW parancs</title>

      <indexterm><primary><command>ipfw</command></primary></indexterm>

      <para>Normál esetben az <command>ipfw</command> parancs
	használatos arra, hogy a tûzfal
	mûködése közben az aktív belsõ
	szabályai közé vegyünk fel vagy
	töröljünk közülük
	manuálisan bejegyzéseket.  Ennek a
	módszernek az egyedüli hátránya, hogy
	az így végrehajtott
	módosítások el fognak veszni a rendszer
	leállításával.  Itt inkább
	azt a megoldást javasoljuk, hogy az összes
	szabályt tegyük bele egy állományba
	és a rendszerindítás során ezt
	töltsük be, majd ha változtatni akarunk a
	tûzfalon, akkor ezt az állományt
	módosítsuk és a régiek
	törlésével töltsük be újra
	az egész szabályrendszert.</para>

      <para>Az <command>ipfw</command> parancs mellesleg remekül
	használható a jelenleg futó
	tûzfalszabályok megjelenítésére
	a konzolon.  Az IPFW nyilvántartásában az
	egyes szabályokhoz dinamikusan jönnek létre
	számlálók, amelyek a rá
	illeszkedõ csomagokat számolják.  A
	tûzfal tesztelése folyamán a szabályok
	és hozzá tartozó
	számlálók lekérdezése a
	megfelelõ mûködés
	ellenõrzésének egyik lehetséges
	módja.</para>

      <para>A szabályokat így tudjuk egymás
	után felsoroltatni:</para>

      <screen>&prompt.root; <userinput>ipfw list</userinput></screen>

      <para>A szabályokat így tudjuk az utolsó
	illeszkedésük idejével együtt
	megjeleníteni:</para>

      <screen>&prompt.root; <userinput>ipfw -t list</userinput></screen>

      <para>A következõ példában a
	nyilvántartási információkat
	kérdezzük le, ekkor a szabályok mellett az
	illeszkedõ csomagok száma is
	láthatóvá válik.  Az elsõ
	sorban a szabály száma szerepel, majd ezt
	követi rendre az illeszkedõ kimenõ és
	bejövõ csomagok mennyisége, valamint
	végül maga a szabály.</para>

      <screen>&prompt.root; <userinput>ipfw -a list</userinput></screen>

      <para>A statikus szabályok mellett a dinamikusakat
	így lehet kilistázni:</para>

      <screen>&prompt.root; <userinput>ipfw -d list</userinput></screen>

      <para>A lejárt dinamikus szabályokat is meg tudjuk
	nézni:</para>

      <screen>&prompt.root; <userinput>ipfw -d -e list</userinput></screen>

      <para>A számlálók
	nullázása:</para>

      <screen>&prompt.root; <userinput>ipfw zero</userinput></screen>

      <para>Csak a <replaceable>SZÁM</replaceable>
	sorszámú szabályhoz tartozó
	számlálók nullázása:</para>

      <screen>&prompt.root; <userinput>ipfw zero SZÁM</userinput></screen>

    </sect2>

    <sect2 xml:id="firewalls-ipfw-rules">
      <title>Szabályrendszerek az IPFW-ben</title>

      <para>Az IPFW esetében a szabályrendszer olyan
	szabályokból áll, amelyek a
	csomagokról tartalmuk alapján eldöntik, hogy
	át kell engedni vagy vissza kell tartani.  A gépek
	közt két irányban áramló
	csomagok egy munkamenet alapú társalgást
	képeznek.  A tûzfalhoz tartozó
	szabályrendszer egyaránt feldolgozza a
	internetrõl a hálózatunk felé
	igyekvõ csomagokat, illetve a hálózatunk
	ezekre adott válaszait.  Az egyes
	<acronym>TCP/IP</acronym> szolgáltatásokat (mint
	például telnet, www, levelezés stb.) a
	hozzájuk tartozó protokol és
	szabványos (fogadó) portszám írja
	le.  Ezekre a forrásról általában
	valamilyen nem szabványos (magasabb
	értékû) portról érkeznek
	csomagok.  Ekkor a kommunikáció összes
	paramétere (vagyis a portok és címek)
	bármelyike alapján definiálhatunk
	blokkolást vagy továbbengedést
	leíró szabályokat.</para>

      <indexterm>
	<primary>IPFW</primary>
	<secondary>a szabályok feldolgozásának
	  sorrendje</secondary>
      </indexterm>

      <para>Amikor egy csomag eléri a tûzfalat, a
	szabályrendszer elsõ szabályával
	kerül összehasonlításra és
	amíg nem illeszkedik valamelyikre, addig lefut rá
	a többi szabály is fentrõl lefelé
	egyesével, a sorszámuknak megfelelõ
	növekvõ sorrendben.  Ha a csomag megfelel valamelyik
	szabály leválogatási paramétereinek,
	akkor a benne megnevezett cselekvés zajlik le, és
	számára a feldolgozás befejezõdik.
	Ezt a viselkedést neveztük <quote>az elsõ
	illeszkedés nyer</quote> típusú
	keresésnek.  Amennyiben a csomag egyetlen
	szabályra sem illeszkedik, akkor az IPFW 65535-ös
	sorszámú állandó szabálya
	fogja elcsípni, amely feladata szerint eldobja az
	összes hozzá beérkezõ csomagot
	anélkül, hogy bármit is válaszolna a
	csomag feladójának.</para>

      <note>
	<para>A keresés a <literal>count</literal>,
	  <literal>skipto</literal> és <literal>tee</literal>
	  szabályok után még
	  folytatódik.</para>
      </note>

      <para>Az itt szereplõ utasítások
	különbözõ állapottartásra
	vonatkozó opciókat, például a
	<literal>keep state</literal>, <literal>limit</literal>,
	<literal>in</literal>, <literal>out</literal> és
	<literal>via</literal> kulcsszavakat tartalmazó
	szabályokon alapulnak.  Lényegében ezt
	tekinthetjük az inkluzív típusú
	tûzfalak kiindulási alapjaként.</para>

      <warning>
	<para>A tûzfal szabályainak
	  beállítása során nem árt
	  óvatosnak lennünk, mert
	  figyelmetlenségünk révén
	  könnyen kizárathatjuk magunkat a
	  gépünkrõl.</para>
      </warning>

      <sect3 xml:id="firewalls-ipfw-rules-syntax">
	<title>A szabályok
	  felépítése</title>

	<indexterm>
	  <primary>IPFW</primary>
	  <secondary>a szabályok
	    felépítése</secondary>
	</indexterm>

	<para>Az itt bemutatásra kerülõ
	  szabályok felépítését csak
	  olyan mértékig részletezzük, ami
	  elengedõ a szabványos inkluzív
	  típusú tûzfalak
	  kialakításához.  A szabályok
	  felépítésének pontos
	  leírását az &man.ipfw.8; man
	  oldalán találhatjuk meg.</para>

	<para>A szabályok kulcsszavakat tartalmaznak.  Ezeket a
	  kulcsszavakat soronként egy elõre
	  rögzített sorrendben kell szerepeltetni.  A
	  kulcsszavakat a szövegben kiemeltük.  Bizonyos
	  kulcsszavakhoz további opciókhoz is
	  tartozhatnak, amelyek gyakran maguk is kulcsszavak és
	  szintén további opciókat
	  tartalmazhatnak.</para>

	<para>A <literal>#</literal> egy megjegyzés
	  kezdetét jelzi, mely egyaránt megjelenhet egy
	  külön sorban, vagy egy szabályt
	  tartalmazó sor végén.  Az üres sorok
	  nem vesznek részt a feldolgozásban.</para>

	<para><replaceable>PARANCS SZABÁLY_SZÁM
	  CSELEKVÉS NAPLÓZÁS SZûRÉS
	  ÁLLAPOTTARTÁS</replaceable></para>

	<sect4>
	  <title>PARANCS</title>

	  <para>Minden új szabály elõttt az
	    <parameter>add</parameter> (mint hozzáadás)
	    parancsnak kell szerepelni, amellyel a belsõ
	    táblázatba tudjuk felvenni.</para>

	</sect4>

	<sect4>
	  <title>SZABÁLY_SZÁM</title>

	  <para>A szabályokhoz mindig tartozik egy sorszám
	    is.</para>

	</sect4>

	<sect4>
	  <title>CSELEKVÉS</title>

	  <para>A szabályhoz az alábbi cselekvések
	    valamelyike kapcsolható, amely akkor hajtódik
	    végre, amikor a csomag megfelel a
	    hozzá tartozó szûrési
	    feltételeknek.</para>

	  <para><parameter>allow | accept | pass |
	      permit</parameter></para>

	  <para>A fentiek közül mindegyik ugyanazt jelenti,
	    vagyis hatásukra az illeszkedõ csomag
	    kilép a tûzfalból.  Ez a szabály
	    megállítja a keresést.</para>

	  <para><parameter>check-state</parameter></para>

	  <para>A csomagot a dinamikus szabályokat
	    tároló táblázattal veti
	    össze.  Ha itt egyezést talál, akkor
	    végrehajtja az egyezõ dinamikus
	    szabályhoz tartozó cselekvést, minden
	    más esetben továbblép a
	    következõ szabályra.  Ennek a
	    szabálynak nincs illeszthetõ paramétere.
	    Ha a szabályrendszerben nem szerepel ilyen, akkor a
	    dinamikus szabályok vizsgálatát az
	    elsõ <literal>keep-state</literal> vagy
	    <literal>limit</literal> használatánál
	    vonja be a rendszer.</para>

	  <para><parameter>deny | drop</parameter></para>

	  <para>Mind a két szó ugyanarra utal, vagyis a
	    szabályra illeszkedõ csomagokat el kell dobni.
	    Ebben az esetben a keresés befejezõdik.</para>

	</sect4>

	<sect4>
	  <title>NAPLÓZÁS</title>

	  <para><parameter>log</parameter> vagy
	    <parameter>logamount</parameter></para>

	  <para>Amikor egy csomag egy <literal>log</literal>
	    kulcsszót tartalmazó szabályra
	    illeszkedik, akkor a rendszernaplóban egy üzenet
	    keletkezik a <literal>security</literal> (biztonság)
	    funkción keresztül.  A naplóba
	    ténylegesen csak akkor kerül bele az
	    üzenet, ha az adott szabály még nem
	    haladta meg a hozzá tartozó
	    <literal>logamount</literal> paraméter
	    értékét.  Ha ezt nem adtuk meg, akkor
	    az itt érvényes korlát a
	    <varname>net.inet.ip.fw.verbose_limit</varname> sysctl
	    változóból fog származni.  A
	    nulla érték mind a két esetben
	    megszünteti ezt a korlátozást.  Ha
	    elértük a korlátot, akkor a
	    naplózást úgy tudjuk újra
	    engedélyezni, ha töröljük a
	    naplózáshoz tartozó
	    számláló értékét,
	    lásd az <command>ipfw reset log</command>
	    parancsot.</para>

	  <note>
	    <para>A naplózás mindig az összes
	      paraméter illeszkedésének
	      ellenõrzése után történik,
	      de még a cselekvés (accept, deny)
	      elvégzése elõtt.  Teljesen rajtunk
	      múlik, hogyan milyen szabályokat
	      naplózunk.</para>
	  </note>

	</sect4>

	<sect4>
	  <title>SZûRÉS</title>

	  <para>Ebben a szakaszban azok a kulcsszavak
	    találhatóak, amelyek
	    segítségével a csomagok
	    különbözõ tulajdonságait tudjuk
	    megvizsgálni és eldönteni, hogy
	    illeszkedik-e a szabályra vagy sem.  A
	    következõ általános
	    tulajdonságokat tudjuk megvizsgálni, ebben a
	    kötött sorrendben:</para>

	  <para><parameter>udp | tcp | icmp</parameter></para>

	  <para>Bármilyen más olyan protokoll is
	    megadható, amely megtalálható az
	    <filename>/etc/protocols</filename>
	    állományban.  Ezzel adjuk a csomaghoz
	    tartozó protokollt.  Használata
	    kötelezõ.</para>

	  <para><parameter>from <replaceable>forrás</replaceable>
	    to <replaceable>cél</replaceable></parameter></para>

	  <para>Mind a <literal>from</literal> és
	    <literal>to</literal> kulcsszavak IP-címek
	    illesztésére alkalmasak.  A
	    szabályoknak tartalmazniuk kell a
	    <replaceable>forrás</replaceable> ÉS a
	    <replaceable>cél</replaceable> paramétereket
	    is.  Az <literal>any</literal> egy olyan kulcsszó,
	    amely tetszõleges IP-címre illeszkedik.  A
	    <literal>me</literal> pedig egy olyan speciális
	    kulcsszó, amely a tûzfalat
	    mûködtetõ &os;-s gép (tehát ez
	    a gép) adott interfészhez tartozó
	    IP-címét jelöli, mint ahogy a
	    <literal>from me to any</literal>, <literal>from any to
	    me</literal>, <literal>from 0.0.0.0/0 to any</literal>,
	    <literal>from any to 0.0.0.0/0</literal>, <literal>from
	    0.0.0.0 to any</literal>, <literal>from any to
	    0.0.0.0</literal> vagy <literal>from me to 0.0.0.0</literal>
	    paraméterekben.  Az IP-címek numerikus
	    pontozott formában a hálózati maszk
	    hosszával együtt (CIDR-jelöléssel),
	    vagy egyszerûen csak pontozott formában
	    adhatóak meg.  A hálózati maszkok
	    megállapításában a <package>net-mgmt/ipcalc</package> port lehet
	    segítségünkre.  Errõl bõvebb
	    információkat a segédprogram
	    honlapján, a <uri xlink:href="http://jodies.de/ipcalc">http://jodies.de/ipcalc</uri> címen
	    találhatunk (angolul).</para>

	  <para><parameter>port
	    <replaceable>szám</replaceable></parameter></para>

	  <para>A portszámokat is ismerõ protokollok
	    esetében (mint például a
	    <acronym>TCP</acronym> vagy <acronym>UDP</acronym>) adhatjuk
	    meg.  Fontos, hogy itt annak a szolgáltatásnak
	    a portszámát adjuk meg, amelyre a
	    szabály vonatkozik.  A szolgáltatás (az
	    <filename>/etc/services</filename>
	    állományból származó)
	    nevét is megadhatjuk a port száma
	    helyett.</para>

	  <para><parameter>in | out</parameter></para>

	  <para>A beérkezõ valamint a kimenõ csomagokat
	    adhatjuk meg ezen a módon.  Itt az
	    <literal>in</literal> és <literal>out</literal>
	    kulcsszavak, melyeket kötelezõ megadni a
	    szabály részeként.</para>

	  <para><parameter>via
	    <replaceable>interfész</replaceable></parameter></para>

	  <para>Név szerint az adott interfészen
	    keresztül haladó csomagokat tudjuk szûrni.
	    A <literal>via</literal> kulcsszó
	    hatására a használt interfész is
	    számítani fog a csomag feldolgozása
	    során.</para>

	  <para><parameter>setup</parameter></para>

	  <para>Ez a kulcsszó a <acronym>TCP</acronym> csomagok
	    esetében a kapcsolatok
	    felépítésére vonatkozó
	    kéréseket segít
	    beazonosítani.</para>

	  <para><parameter>keep-state</parameter></para>

	  <para>Ez egy kötelezõ kulcsszó.
	    Feldolgozásakor a tûzfal létrehoz
	    dinamikus szabályt, amely
	    alapértelmezés szerint az egyazon protokollt
	    használó forrás és cél
	    IP/port párosok közti
	    kétirányú forgalomra fog automatikusan
	    illeszkedni.</para>

	  <para><parameter>limit
	    {<replaceable>forráscím</replaceable> |
	    <replaceable>forrásport</replaceable> |
	    <replaceable>célcím</replaceable> |
	    <replaceable>célport</replaceable>}</parameter></para>

	  <para>A tûzfal csak <replaceable>N</replaceable> darab, a
	    szabálynak megfelelõ azonos
	    paraméterû kapcsolatot fog átengedi.  Itt
	    egy vagy több forrás- és
	    célcím valamint forrás- és
	    célport adható meg.  A
	    <literal>limit</literal> és a
	    <literal>keep-state</literal> egy szabályon
	    belül nem használható.  A
	    <literal>limit</literal> ugyanazokat az
	    állapottartó funkciókat
	    képviseli, mint a <literal>keep-state</literal>, csak
	    a saját kiegészítéseivel
	    megtoldva.</para>

	</sect4>
      </sect3>

      <sect3>
	<title>ÁLLAPOTTARTÁS</title>

	<indexterm>
	  <primary>IPFW</primary>
	  <secondary>állapottartó
	    szûrés</secondary>
	</indexterm>

	<para>Az állapottartó szûrés a
	  kétirányú csomagváltásokat
	  egy létrejött kapcsolatba sorolja.  Olyan
	  vizsgálatokat végez, amivel képes
	  megállapítani, hogy a csomag küldõje
	  és címzettje között kialakult
	  kommunikáció követ-e valamilyen
	  kétirányú csomagküldésre
	  érvényes folyamatot.  Az így
	  felállított sablontól eltérõ
	  összes csomag hamisnak minõsül és
	  automatikusan eldobásra kerül.</para>

	<para>A <literal>check-state</literal>
	  segítségével ellenõrizhetjük,
	  hogy az adott csomag a IPFW szerint megfelel-e valamelyik
	  dinamikusan leképzett szabálynak.  Ha egyezik
	  valamelyikõjükkel, akkor a csomag a
	  tûzfalból kilépve folytatja
	  útját és a kommunikációban
	  soron következõ csomag számára
	  létrejön egy másik dinamikus
	  szabály.  Ha nincs egyezés, akkor csomag
	  feldolgozása a szabályrendszer
	  következõ szabályánál
	  folytatódik.</para>

	<para>A dinamikus szabályokat kezelõ rutin
	  sebezhetõ, mivel ha egyszerre nagy mennyiségû
	  SYN csomagot küldünk, akkor olyan sok dinamikus
	  bejegyzés keletkezik, hogy egyszerûen kifogyunk a
	  rendelkezésre álló
	  erõforrásokból.  A &os; fejlesztõi
	  azonban az ilyen természetû
	  támadások kivédésére is
	  felkészítették, és
	  kialakították belõle a
	  <literal>limit</literal> opciót.
	  Alkalmazásával le tudjuk korlátozni az
	  egyszerre folyó párhuzamos kapcsolatok
	  számát a forrás vagy a cél a
	  <literal>limit</literal> paraméternél megadott
	  mezõinek és a csomag IP-címe
	  alapján.  Így az adott szabályhoz
	  és IP-címhez csak elõre
	  rögzített mennyiségû nyitott
	  állapotú dinamikus szabály
	  létezhet egy idõben.  Ha ezt a korlátot
	  átlépjük, a csomag eldobódik.</para>
      </sect3>

      <sect3>
	<title>A tûzfal üzeneteinek
	  naplózása</title>

	<indexterm>
	  <primary>IPFW</primary>
	  <secondary>naplózás</secondary>
	</indexterm>

	<para>A naplózás elõnyei
	  nyilvánvalóak.  Ha engedélyezzük,
	  aktiválása után képesek
	  leszünk olyan információknak
	  utánanézni, mint például milyen
	  csomagokat dobtunk el, honnan érkeztek, hova tartottak.
	  Ez egy komoly fegyverünk lehet a potenciális
	  támadókkal szemben.</para>

	<para>Azonban hiába engedélyezzünk
	  önmagában a naplózást, attól
	  az IPFW még saját magától nem fog
	  naplózást elõíró
	  szabályokat gyártani.  A tûzfal
	  karbantartóinak maguknak kell eldöntenie, hogy a
	  szabályrendszerben mely szabályokhoz tartozzon
	  naplózás, nekik kell felvenni ezekhez a
	  <literal>log</literal> kulcsszót.
	  Általában csak az eldobással
	  járó <literal>deny</literal>
	  típusú szabályokat vagy a
	  bejövõ <acronym>ICMP</acronym> pingeket
	  szokták naplózni.  Gyakran úgy
	  oldják meg ezt, hogy a szabályrendszer
	  utolsó szabályaként
	  lemásolják az <command>ipfw</command>
	  alapértelmezett <quote>mindent eldobunk</quote>
	  szabályát és a naplózást
	  adják meg benne.  Ezen a módon fény
	  derül azokra a csomagokra, amelyek a
	  szabályrendszerben semmire sem illeszkedtek.</para>

	<para>A naplózás azonban egy
	  kétélû fegyver, mivel ha nem vagyunk
	  elég körültekintõek, akkor a sok
	  naplóinformáció között
	  könnyen el tudunk veszni és a lemezünk is
	  gyorsan betelhet a mindent elfoglaló
	  naplóktól.  Mellesleg a naplók
	  megdagasztását célzó DoS
	  típusú támadás a rendszerek
	  lebénítására alkalmazott egyik
	  legõsibb technika.  Ezek az üzenetek nem csak a
	  rendszernaplóba kerülnek bele, hanem az
	  elsõdleges konzol képernyõjére is
	  kiíródnak, ami egy idõ után
	  idegesítõ tud lenni.</para>

	<para>A rendszermag
	  <literal>IPFIREWALL_VERBOSE_LIMIT=5</literal>
	  beállításával azonban
	  képesek vagyunk korlátozni azokat a
	  rendszernapló felé küldött
	  egymás után következõ üzeneteket,
	  amelyek ugyanarra a szabályra vonatkoznak.  Amikor ezt
	  a beállítást megadjuk a rendszermag
	  fordításánál, akkor az egyes
	  szabályokhoz az általa meghatározott
	  értéken felül nem jön létre
	  több hasonló üzenet.  Hiszen semmi sem
	  derül ki 200 teljesen azonos
	  naplóüzenetbõl.  Például, ha az
	  egyes szabályokhoz legfeljebb öt egymást
	  követõ üzenetet engedélyezünk,
	  akkor a többi fennmaradó azonos üzenetet
	  összeszámolja a rendszer és a
	  következõ módon közvetíti a
	  rendszernaplózó szolgáltatás
	  felé:</para>

	<programlisting>last message repeated 45 times</programlisting>

	<para>Ami magyarul így hangzik:</para>

	<programlisting>az utolsó üzenet 45 alkalommal ismétlõdött meg</programlisting>

	<para>Az összes csomagokkal kapcsolatos
	  naplózás alapértelmezés szerint a
	  <filename>/var/log/security</filename>
	  állományba kerül, amelyet az
	  <filename>/etc/syslog.conf</filename> állomány
	  definiál.</para>

      </sect3>

      <sect3 xml:id="firewalls-ipfw-rules-script">
	<title>Szabályokat tartalmazó szkript
	  készítése</title>

	<para>A rutinosabb IPFW felhasználók a
	  szabályokat egy állományban
	  programozzák le olyan stílusban, hogy
	  szkriptként is futtatható legyen.  Ennek az
	  egyik legnagyobb elõnye, hogy a tûzfal
	  szabályai így egyszerre cserélhetõek
	  a rendszer újraindítása
	  nélkül.  Ez a módszer nagyon
	  kényelmes az új szabályok
	  kipróbálásánál, mivel
	  tetszõleges alkalommal végrehajthatjuk.  Mivel ez
	  egy szkript, ki tudjuk használni az itt megszokott
	  szimbolikus helyettesítés által
	  felkínált lehetõségeket, és
	  ezzel a gyakran használt értékeket is
	  egyszerre több szabályban tudjuk
	  helyettesíteni.  Erre a következõkben fogunk
	  egy konkrét példát látni.</para>

	<para>A szkript felépítése kompatibilis a
	  &man.sh.1;, &man.csh.1; és &man.tcsh.1;
	  parancsértelmezõkkel.  A szimbolikus mezõk
	  helyettesítését a &dollar; vagyis
	  dollárjel vezeti be.  Maguk a szimbolikus mezõk
	  nem tartalmazzák a &dollar; elõtagot.  A
	  szimbolikus mezõk értékeit "kettõs
	  idézõjelek" között kell megadni.</para>

	<para>A szabályok összeírását
	  kezdjük el így:</para>

	<programlisting>####### itt kezdõdik az ipfw szabályait tartalmazó szkript ######
#
ipfw -q -f flush       # töröljük az összes aktuális szabályt
# Set defaults
oif="tun0"             # a kimenõ interfész
odns="192.0.2.11"      # az internet szolgáltató névszerverének IP-címe
cmd="ipfw -q add "     # a szabályok hozzáadásához szükséges elemek
ks="keep-state"        # csupán a lustaság miatt
&dollar;cmd 00500 check-state
&dollar;cmd 00502 deny all from any to any frag
&dollar;cmd 00501 deny tcp from any to any established
&dollar;cmd 00600 allow tcp from any to any 80 out via &dollar;oif setup &dollar;ks
&dollar;cmd 00610 allow tcp from any to &dollar;odns 53 out via &dollar;oif setup &dollar;ks
&dollar;cmd 00611 allow udp from any to &dollar;odns 53 out via &dollar;oif &dollar;ks
#### itt fejezõdik be az ipfw szabályait tartalmazó szkript ######</programlisting>

	<para>Ezzel készen is vagyunk.  Most ne
	  törõdjünk a példában
	  szereplõ szabályokkal, itt most a szimbolikus
	  helyettesítés használatát
	  igyekeztük bemutatni.</para>

	<para>Ha az iménti példát az
	  <filename>/etc/ipfw.rules</filename> állományba
	  mentettük el, akkor az alábbi parancs
	  kiadásával tudjuk újratölteni a
	  benne szereplõ szabályokat:</para>

	<screen>&prompt.root; <userinput>sh /etc/ipfw.rules</userinput></screen>

	<para>Az <filename>/etc/ipfw.rules</filename>
	  állományt egyébként
	  tetszõleges néven hívhatjuk és
	  bárhová rakhatjuk.</para>

	<para>Ugyanez természetesen elérhetõ a
	  következõ parancsok egymás utáni
	  begépelésével is:</para>

	<screen>&prompt.root; <userinput>ipfw -q -f flush</userinput>
&prompt.root; <userinput>ipfw -q add check-state</userinput>
&prompt.root; <userinput>ipfw -q add deny all from any to any frag</userinput>
&prompt.root; <userinput>ipfw -q add deny tcp from any to any established</userinput>
&prompt.root; <userinput>ipfw -q add allow tcp from any to any 80 out via tun0 setup keep-state</userinput>
&prompt.root; <userinput>ipfw -q add allow tcp from any to 192.0.2.11 53 out via tun0 setup keep-state</userinput>
&prompt.root; <userinput>ipfw -q add 00611 allow udp from any to 192.0.2.11 53 out via tun0 keep-state</userinput></screen>
      </sect3>

      <sect3>
	<title>Állapottartó
	  szabályrendszerek</title>

	<para>A most következõ
	  címfordítás nélküli
	  szabályrendszer arra mutat példát, hogyan
	  valósítsunk meg egy biztonságos
	  <quote>inkluzív</quote> tûzfalat.  Az
	  inkluzív tûzfalak csak a szabályainak
	  megfelelõ szolgáltatásokat engedik
	  át, minden mást alapértelmezés
	  szerint tiltanak.  A komplett hálózati
	  szegmensek védelmére
	  összeállított tûzfalaknak
	  legalább két interfészük van,
	  amelyek mindegyikéhez tartoznia kell
	  szabályoknak a megfelelõ
	  mûködéshez.</para>

	<para>Az &unix; mintájú operációs
	  rendszer, köztül a &os; is olyan, hogy a rendszerben
	  belüli kommunikációt a
	  <filename>lo0</filename> nevû interfészen
	  és a <systemitem class="ipaddress">127.0.0.1</systemitem>
	  IP-címen bonyolítja le.  A tûzfalban
	  mindenképpen szerepelniük kell olyan
	  szabályoknak, amelyek gondoskodnak ezen
	  speciális belsõ csomagok zavartalan
	  közlekedésérõl.</para>

	<para>Az internet felé csatlakozó interfész
	  lesz az, amelyen keresztül a kifelé menõ
	  kéréseket hitelesítjük és
	  vezéreljük az internet
	  elérését, valamint ahol szûrjük
	  az internet felõl érkezõ
	  kéréseket.  Ez lehet a <acronym>PPP</acronym>
	  esetében a <filename>tun0</filename> eszköz,
	  vagy a DSL-, illetve kábelmodemhez csatlakozó
	  hálózati kártya.</para>

	<para>Abban az esetben, amikor egy vagy több
	  hálózati kártyával csatlakozunk a
	  tûzfal mögött található
	  belsõ helyi hálózatra, szintén
	  gondoskodnunk kell a helyi hálózaton belül
	  mozgó csomagok akadálymentes
	  továbbításáról.</para>

	<para>A szabályokat elõször három
	  nagyobb osztályba kell sorolnunk: az összes
	  szabadon forgalmazó interfész, a publikus
	  kimenõ és a publikus bejövõ
	  interfész csoportjába.</para>

	<para>A publikus interfészekhez tartozó
	  csoportokban úgy kell rendeznünk a
	  szabályokat, hogy elõre kerüljenek a
	  gyakrabban használtak és hátra a
	  kevésbé használtak, valamint a csoportok
	  utolsó szabálya blokkoljon és
	  naplózzon minden csomagot az adott interfészen
	  és irányban.</para>

	<para>A következõ szabályrendszerben
	  szereplõ, a kimenõ kapcsolatokat tartalmazó
	  csoport csak olyan <literal>allow</literal>
	  típusú szabályokat tartalmaz, amelyek
	  szûrési feltételei egyértelmûen
	  azonosítják az interneten elérhetõ
	  szolgáltatásokat.  Az összes
	  szabályban megjelennek a <literal>proto</literal>,
	  <literal>port</literal>,
	  <literal>in</literal>/<literal>out</literal>,
	  <literal>via</literal> és <literal>keep
	  state</literal> opciók.  A <literal>proto
	  tcp</literal> szabályokban emellett szerepel még
	  egy <literal>setup</literal> opció is, amellyel a
	  kapcsolatokat kezdeményezõ csomagokat tudjuk
	  azonosítani és felvenni az
	  állapottartásért felelõs dinamikus
	  szabályok közé.</para>

	<para>A bejövõ forgalmat vezérlõ
	  szabályrendszerben elõször az eldobni
	  kívánt csomagokat kell megadni, aminek
	  két eltérõ oka van.  Elõször is
	  elõfordulhat, hogy a veszélyes csomagok
	  részleges illeszkedés miatt szabályosnak
	  tûnnek.  Az ilyen csomagokat értelemszerûen
	  nem lenne szabad beengedni a szabályok részleges
	  megfelelése alapján.  A másodszor az
	  eleve ismerten problémás és
	  értelmetlen csomagokat csendben el kellene vetni,
	  mielõtt a szakaszhoz tartozó utolsó
	  szabály fogná meg és
	  naplózná.  Ez az utolsó szabály
	  egyébként szükség esetén
	  felhasználható a támadók elleni
	  bizonyítékok
	  begyûjtésére.</para>

	<para>A másik, amire még oda kell figyelnünk,
	  hogy a blokkolt csomagok esetében semmilyen
	  válasz nem keletkezzen, egyszerûen csak
	  tûnjenek el.  Így a támadó nem fogja
	  tudni, hogy a csomagjai vajon elérték-e a
	  rendszerünket.  Minél kevesebb
	  információt tudnak összegyûjteni a
	  rendszerünkrõl a támadók, annál
	  biztonságosabbnak tekinthetõ.
	  Amikor ismeretlen portokra érkezõ csomagokat
	  naplózunk, érdemes az
	  <filename>/etc/services/</filename> állományban
	  vagy <uri xlink:href="http://www.securitystats.com/tools/portsearch.php">http://www.securitystats.com/tools/portsearch.php</uri>
	  címen (angolul) utánanézni a porthoz
	  tartozó szolgáltatásnak.  A
	  különbözõ trójai programok
	  által portok számai ezen a linken
	  érhetõek el (angolul): <uri xlink:href="http://www.simovits.com/trojans/trojans.html">http://www.simovits.com/trojans/trojans.html</uri>.</para>
      </sect3>

      <sect3>
	<title>Példa egy inkluzív
	  szabályrendszerre</title>

	<para>A most következõ,
	  címfordítást nem tartalmazó
	  szabályrendszer teljesen inkluzív
	  típusú.  Éles rendszereken is nyugodtan
	  alkalmazhatjuk.  Egyszerûen csak annyit kell
	  tennünk, hogy megjegyzésbe tesszük az olyan
	  szolgáltatásokra vonatkozó
	  szabályokat, amelyeket nem akarunk engedélyezni.
	  Amikor pedig olyan üzenetek jelennek meg a
	  naplóban, amelyeket nem akarunk tovább
	  látni, a bejövõ kapcsolatokhoz vegyünk
	  fel egy <literal>deny</literal> típusú
	  szabályt hozzájuk.  Minden szabályban
	  cseréljük ki a <literal>dc0</literal>
	  interfészt arra a hálózati
	  kártyára, amely közvetlenül
	  csatlakoztatja rendszerünket az internethez.  A
	  felhasználói <acronym>PPP</acronym>
	  esetében ez a <literal>tun0</literal>.</para>

	<para>A szabályok használatában
	  felfedezhetünk egyfajta
	  rendszerszerûséget:</para>

	<itemizedlist>
	  <listitem>
	    <para>Mindegyik sorban, ahol az internet felé nyitunk
	      meg egy kapcsolatot, a <literal>keep-state</literal>
	      opciót használjuk.</para>
	  </listitem>

	  <listitem>
	    <para>Az internetrõl az összes hitelesített
	      szolgáltatás elérése
	      tartalmazza a <literal>limit</literal> opciót az
	      elárasztások kivédése
	      miatt.</para>
	  </listitem>

	  <listitem>
	    <para>Az összes szabályban az
	      <literal>in</literal> vagy az <literal>out</literal>
	      paraméterrel megadjuk szûrni
	      kívánt forgalom
	      irányát.</para>
	  </listitem>

	  <listitem>
	    <para>Az összes szabályban szerepel a
	      <literal>via</literal> paraméterrel a csomagokat
	      továbbító interfész
	      neve.</para>
	  </listitem>
	</itemizedlist>

	<para>Az alábbi szabályokat tegyük az
	  <filename>/etc/ipfw.rules</filename>
	  állományba.</para>

	<programlisting>############## Itt kezdõdnek az IPFW szabályai ##########################
# Kezdés elõtt töröljük az összes aktív szabályt.
ipfw -q -f flush

# Állítsuk be a parancsok további szükséges opciót.
cmd="ipfw -q add"
pif="dc0"     # az internethez csatlakozó
              # interfész neve

#################################################################
# A belsõ hálózat számára ne korlátozzunk semmit se.
# Ha nincs helyi hálózatunk, akkor erre nincs szükségünk.
# Az 'xl0' nevét írjuk át a helyi hálózatra csatlakozó
# interfész nevére.
################################################################
#&dollar;cmd 00005 allow all from any to any via xl0

################################################################
# A rendszer belsõ interfészét se szûrjük.
################################################################
&dollar;cmd 00010 allow all from any to any via lo0

################################################################
# A csomagot engedjük át a tûzfalon, ha korábban már felvettünk
# hozzá egy dinamikus szabályt a keep-state opcióval.
################################################################
&dollar;cmd 00015 check-state

################################################################
# Az internet felé forgalmazó interfész (kimenõ kapcsolatok)
# A saját hálózatunkról belülrõl vagy errõl az átjáróról
# kezdeményezett kapcsolatokat vizsgáljuk az internet felé.
################################################################

# Kifelé engedélyezzük az internet-szolgáltatónk névszerverének
# elérését. Az x.x.x.x a szolgáltatónk névszerverének IP-címe
# legyen. Ha a szolgáltatónak több névszervere is van, akkor
# másoljuk le ezeket a sorokat és az /etc/resolv.conf
# állományban található IP-címeket helyettesítsük be.
&dollar;cmd 00110 allow tcp from any to x.x.x.x 53 out via &dollar;pif setup keep-state
&dollar;cmd 00111 allow udp from any to x.x.x.x 53 out via &dollar;pif keep-state

# Kábel/DSL konfigurációk esetében kifelé engedélyezzük a
# szolgáltatónk DHCP szerverének elérését. Ha a "felhasználói
# PPP"-t használjuk, akkor erre nem lesz szükségünk, az egész
# csoportot törölhetjük. Az alábbi szabállyal csíphetjük el a
# beírandó IP-címet. Ha a naplóban megtaláltuk, akkor vegyük
# ki az elsõ szabályt, a másodikba írjuk bele a címet és
# engedélyezzük.
&dollar;cmd 00120 allow log udp from any to any 67 out via &dollar;pif keep-state
#&dollar;cmd 00120 allow udp from any to x.x.x.x 67 out via &dollar;pif keep-state

# Kifelé engedélyezzük a szabvány nem biztonságos WWW
# funkció elérését.
&dollar;cmd 00200 allow tcp from any to any 80 out via &dollar;pif setup keep-state

# Kifelé engedélyezzük a biztonságos HTTPS funkció
# elérését TLS SSL használatával.
&dollar;cmd 00220 allow tcp from any to any 443 out via &dollar;pif setup keep-state

# Kifelé engedélyezzük a e-mailek küldését és fogadását.
&dollar;cmd 00230 allow tcp from any to any 25 out via &dollar;pif setup keep-state
&dollar;cmd 00231 allow tcp from any to any 110 out via &dollar;pif setup keep-state

# Kifelé engedélyezzük a FreeBSD (a make install és a CVSUP)
# funkcióit. Ezzel lényegében a rendszeradminisztrátornak
# ,,ISTENI'' jogokat adunk.
&dollar;cmd 00240 allow tcp from me to any out via &dollar;pif setup keep-state uid root

# Kifelé engedélyezzük a pinget.
&dollar;cmd 00250 allow icmp from any to any out via &dollar;pif keep-state

# Kifelé engedélyezzük az idõ szolgáltatást.
&dollar;cmd 00260 allow tcp from any to any 37 out via &dollar;pif setup keep-state

# Kifelé engedélyezzük az nntp news szolgáltatást
# (vagyis a hírcsoportokat)
&dollar;cmd 00270 allow tcp from any to any 119 out via &dollar;pif setup keep-state

# Kifelé engedélyezzük a biztonságos FTP, telnet és SCP
# elérését az SSH (secure shell) használatával.
&dollar;cmd 00280 allow tcp from any to any 22 out via &dollar;pif setup keep-state

# Kifelé engedélyezzük a whois szolgáltatást.
&dollar;cmd 00290 allow tcp from any to any 43 out via &dollar;pif setup keep-state

# Dobjuk el és naplózzunk mindent, ami megpróbál kijutni.
# Ez a szabály gondoskodik róla, hogy alapértelmezés szerint
# mindent blokkoljunk.
&dollar;cmd 00299 deny log all from any to any out via &dollar;pif

################################################################
# Az internet felõli interfész (bejövõ kapcsolatok)
# A saját hálózatunk felé vagy erre az átjáróra
# nyitott kapcsolatokat vizsgáljuk az internet felõl.
################################################################

# Blokkoljunk minden olyan bejövõ forgalmat, amely a fenntartott
# címtartományok felé tart.
&dollar;cmd 00300 deny all from 192.168.0.0/16 to any in via &dollar;pif  #RFC 1918: privát IP
&dollar;cmd 00301 deny all from 172.16.0.0/12 to any in via &dollar;pif   #RFC 1918: privát IP
&dollar;cmd 00302 deny all from 10.0.0.0/8 to any in via &dollar;pif      #RFC 1918: privát IP
&dollar;cmd 00303 deny all from 127.0.0.0/8 to any in via &dollar;pif     #helyi
&dollar;cmd 00304 deny all from 0.0.0.0/8 to any in via &dollar;pif       #helyi
&dollar;cmd 00305 deny all from 169.254.0.0/16 to any in via &dollar;pif  #DHCP
&dollar;cmd 00306 deny all from 192.0.2.0/24 to any in via &dollar;pif    #dokumentációs célokra fenntartott
&dollar;cmd 00307 deny all from 204.152.64.0/23 to any in via &dollar;pif #Sun klaszterek összekötésére használt
&dollar;cmd 00308 deny all from 224.0.0.0/3 to any in via &dollar;pif     #D és E osztályú multicast

# A nyilvános pingek tiltása.
&dollar;cmd 00310 deny icmp from any to any in via &dollar;pif

# Az ident szolgáltatás tiltása.
&dollar;cmd 00315 deny tcp from any to any 113 in via &dollar;pif

# Blokkoljuk az összes Netbios szolgáltatást: 137=név, 138=datagram,
# 139=session. A Netbios az MS Windows megosztását implementálja.
# Blokkoljuk az MS Windows hosts2 névszerver kéréseit is a 81-es
# porton.
&dollar;cmd 00320 deny tcp from any to any 137 in via &dollar;pif
&dollar;cmd 00321 deny tcp from any to any 138 in via &dollar;pif
&dollar;cmd 00322 deny tcp from any to any 139 in via &dollar;pif
&dollar;cmd 00323 deny tcp from any to any 81 in via &dollar;pif

# Eldobjuk az összes késõn érkezõ csomagot.
&dollar;cmd 00330 deny all from any to any frag in via &dollar;pif

# Eldobjuk azokat az ACK csomagokat, amelyek egyik dinamikus
# szabálynak sem felelnek meg.
&dollar;cmd 00332 deny tcp from any to any established in via &dollar;pif

# Befelé engedélyezzük a szolgáltató DHCP szerverének válaszát. Ebben
# a szabályban csak a DHCP szerver IP-címe szerepelhet, mivel ez az
# egyetlen olyan hitelesített forrás, ami ilyen csomagokat küldhet.
# Ez csak a kábeles és DSL típusú kapcsolatok esetében szükséges.
# Amikor a "felhasználói PPP"-vel csatlakozunk az internethez, nem
# kell ez a szabály. Ugyanazt az IP-címet kell megadnunk, amelyet a
# kimenõ kapcsolatoknál is.
#&dollar;cmd 00360 allow udp from any to x.x.x.x 67 in via &dollar;pif keep-state

# Befelé engedélyezzük a szabvány WWW funkciót, mivel webszerverünk
# is van.
&dollar;cmd 00400 allow tcp from any to me 80 in via &dollar;pif setup limit src-addr 2

# Befelé engedélyezzük a biztonságos FTP, telnet és SCP
# típusú kapcsolatokat az internetrõl.
&dollar;cmd 00410 allow tcp from any to me 22 in via &dollar;pif setup limit src-addr 2

# Befelé engedélyezzük az internetrõl érkezõ nem biztonságos telnet
# kapcsolatokat. Azért tekintjük nem biztonságosnak, mert az
# azonosítók és a jelszavak az interneten titkosítatlanul vándorolnak.
# Töröljük ezt a csoportot, ha nincs telnet szolgáltatásunk.
&dollar;cmd 00420 allow tcp from any to me 23 in via &dollar;pif setup limit src-addr 2

# Dobjuk el és naplózzuk az összes többi kintrõl érkezõ csomagot.
&dollar;cmd 00499 deny log all from any to any in via &dollar;pif

# Alapértelmezés szerint dobjuk el mindent. Az ide érkezõ
# csomagokat is naplózzuk, amibõl többet is ki tudunk majd
# deríteni.
&dollar;cmd 00999 deny log all from any to any
############# Itt fejezõdnek be az IPFW szabályai #####################</programlisting>
      </sect3>

      <sect3>
	<title>Példa hálózati
	  címfordításra és
	  állapottartásra</title>

	<indexterm>
	  <primary>címfordítás</primary>
	  <secondary>és az IPFW</secondary>
	</indexterm>

	<para>Az IPFW címfordító
	  funkciójának
	  kihasználásához további
	  konfigurációs beállítások
	  alkalmazására is szükségünk
	  lesz.  A rendszermagban opció között meg kell
	  adnunk az <literal>option IPDIVERT</literal> sort a többi
	  <literal>IPFIREWALL</literal> sor mellett, és
	  fordítanunk egy saját verziót.</para>

	<para>Emellett még az <filename>/etc/rc.conf</filename>
	  állományban is engedélyezni kell az IPFW
	  alapvetõ funkcióit.</para>

	<programlisting>natd_enable="YES"                   # engedélyezzük a címfordításért felelõs démont
natd_interface="rl0"                # az internet felé mutató hálózati kártya neve
natd_flags="-dynamic -m"            # -m = a portszámok megtartása, ha lehetséges</programlisting>

	<para>Az állapottartó szabályok
	  használata a <literal>divert natd</literal>
	  címfordítási opcióval együtt
	  nagyban növeli a szabályrendszer
	  leprogramozásának bonyolultságát.
	  A <literal>check-state</literal> és <literal>divert
	  natd</literal> szabályok helye kritikus a
	  megfelelõ mûködés tekintetében.
	  Az eddig megszokott egyszerû viselkedés itt
	  már nem érvényesül.  Bevezetünk
	  egy új cselekvést is, amelynek a neve
	  <literal>skipto</literal>.  A <literal>skipto</literal>
	  parancs használatához elengedhetetlen a
	  szabályok sorszámozása, mivel pontosan
	  tudnunk kell, hogy a <literal>skipto</literal>
	  hatására hova kell ugrania a
	  vezérlésnek.</para>

	<para>A következõ példában nem fogunk
	  sok megjegyzést látni, mivel benne az egyik
	  lehetséges programozási stílust
	  próbáljuk érzékeltetni és a
	  csomagok szabályrendszerek közti
	  áramlását magyarázzuk.</para>

	<para>A feldolgozás a szabályokat
	  tartalmazó állomány tetején
	  található elsõ szabállyal
	  kezdõdik, és innen egyesével pereg
	  végig lefelé a feldolgozás egészen
	  addig, amíg a csomag a szûrési
	  feltételek valamelyikének eleget nem tesz
	  és távozik a tûzfalból.
	  Leginkább a 100-as, 101-es, 450-es, 500-as és
	  510-es sorszámú szabályokat
	  emelnénk ki.  Ezek vezérlik kimenõ
	  és bejövõ csomagok
	  fordítását, ezért a
	  hozzájuk tartozó dinamikus
	  állapottartó bejegyzések mindig a helyi
	  hálózat IP-címeire hivatkoznak.  Amit
	  még érdemes megfigyelnünk, hogy az
	  összes áteresztõ és eldobó
	  szabályban szerepel a csomag haladási
	  iránya (tehát kimenõ vagy éppen
	  bejövõ) és az érintett
	  interfészt megnevezése.  Emellett azt is
	  vegyük észre, hogy az összes kifelé
	  irányuló kapcsolatlétrehozási
	  kérés az 500-as sorszámú
	  szabályhoz fog ugrani a
	  címfordítás
	  elvégzéséhez.</para>

	<para>Tegyük fel, hogy a helyi hálózatunkon
	  levõ felhasználók szeretnek honlapokat
	  nézgetni az interneten.  A honlapok a 80-as porton
	  keresztül kommunikálnak.  Tehát amikor egy
	  ilyen csomag eléri a tûzfalat, nem fog illeszkedni
	  a 100-as szabályra, mert a fejléce szerint
	  kifelé halad és nem befelé.  A 101-es
	  szabályon is átlép, mivel ez az elsõ
	  csomag, így a dinamikus állapottartó
	  táblázatban sem szerepel még.  A csomag
	  végül a 125-ös szabályra fog
	  illeszkedni: kifelé halad az internetre
	  csatlakozó hálózati
	  kártyán.  A csomagban azonban még mindig
	  az eredeti forrás IP-címe
	  található, amely a helyi hálózat
	  egyik gépére hivatkozik.  A szabály
	  illeszkedésekor két cselekvés is
	  végbemegy.  A <literal>keep-state</literal> opció
	  hatására ez a szabály felveszi ezt a
	  kapcsolatot az állapottartó dinamikus
	  szabályok közé és végrehajtja
	  a másik megadott feladatot.  Ez a feladat része
	  a dinamikus táblázatba rögzített
	  bejegyzésnek, ami ebben az esetben a <literal>skipto
	  500</literal> (<quote>ugorjunk az 500-as
	  szabályra</quote>) lesz.  Az 500-as szabály a
	  továbbküldés elõtt lefordítja a
	  csomag forrás IP-címét.  Ezt ne
	  felejtsük el, nagyon fontos!  A csomag ezután
	  eljut a céljához, és visszatérve
	  ismét belép a szabályrendszer
	  tetején.  Ezúttal illeszkedni fog a 100-as
	  szabályra és a cél IP-címét
	  visszafordítjuk a helyi hálózatunk
	  megfelelõ gépének címére.
	  Ezután a <literal>check-state</literal>
	  szabályhoz kerül, amely megtalálja a
	  dinamikus szabályok között és
	  továbbengedi a belsõ hálózatra.
	  Ezzel visszakerül a küldõ géphez, amely
	  egy újabb csomagot küld egy újabb
	  adatszeletet kérve a távoli szervertõl.
	  Ekkor már a <literal>check-state</literal>
	  szabály megtalálja a hozzá tartozó
	  bejegyzést a dinamikus szabályok
	  között és végrehajtódik a
	  korábban letárolt <literal>skipto 500</literal>
	  mûvelet.  A csomag erre az 500-as szabályra ugrik,
	  ahol lefordítjuk a címét és
	  továbbküldjük.</para>

	<para>Az bejövõ oldalon minden, ami egy
	  korábban kialakult kapcsolat részeként
	  érkezik, automatikusan a <literal>check-state</literal>
	  és a megfelelõ helyre rakott <literal>divert
	  natd</literal> szabályok által dolgozódik
	  fel.  Itt mindössze a rossz csomagok
	  eldobásával és a hitelesített
	  szolgáltatások elérésének
	  biztosításával kell foglalkoznunk.
	  Például a tûzfalon egy webszerver fut,
	  és azt szeretnénk, hogy az internetrõl
	  képesek legyenek elérni a rajta levõ
	  oldalakat.  Az újonnan beérkezõ
	  kapcsolatépítési kérelem a 100-as
	  szabályra fog illeszkedni, amelynek a cél
	  IP-címét a tûzfal helyi
	  hálózaton található
	  címére fogjuk leképezni.  A csomagot
	  ezután még megvizsgáljuk, nem tartalmaz-e
	  valamilyen huncutságot, majd végül a
	  425-ös szabálynál fog kikötni.  Az
	  egyezéskor két dolog történhet: a
	  csomaghoz felveszünk egy dinamikus szabályt, de
	  ezúttal az adott forrás IP-címrõl
	  érkezõ kapcsolatkérések
	  számát 2-re lekorlátozzuk.  Ezzel az
	  adott szolgáltatás portján meg tudjuk
	  óvni a tûzfalat üzemeltetõ gépet
	  a DoS típusú támadásoktól.
	  A csomagot ezután hozzá tartozó
	  cselekvés szerint továbbengedjük a
	  belsõ hálózat felé.
	  Visszatéréskor a tûzfal felismeri, hogy a
	  csomag egy már meglevõ kapcsolathoz tartozik,
	  ezért közvetlenül az 500-as szabályhoz
	  kerül címfordításra, majd a
	  kimenõ interfészen keresztül
	  továbbküldjük.</para>

	<para>Íme az elsõ példa egy ilyen
	  szabályrendszerre:</para>

	<programlisting>#!/bin/sh
cmd="ipfw -q add"
skip="skipto 500"
pif=rl0
ks="keep-state"
good_tcpo="22,25,37,43,53,80,443,110,119"

ipfw -q -f flush

&dollar;cmd 002 allow all from any to any via xl0  # nem szûrjük a belsõ hálózatot
&dollar;cmd 003 allow all from any to any via lo0  # nem szûrjük a helyi interfészt

&dollar;cmd 100 divert natd ip from any to any in via &dollar;pif
&dollar;cmd 101 check-state

# A kimenõ csomagok hitelesítése:
&dollar;cmd 120 &dollar;skip udp from any to xx.168.240.2 53 out via &dollar;pif &dollar;ks
&dollar;cmd 121 &dollar;skip udp from any to xx.168.240.5 53 out via &dollar;pif &dollar;ks
&dollar;cmd 125 &dollar;skip tcp from any to any &dollar;good_tcpo out via &dollar;pif setup &dollar;ks
&dollar;cmd 130 &dollar;skip icmp from any to any out via &dollar;pif &dollar;ks
&dollar;cmd 135 &dollar;skip udp from any to any 123 out via &dollar;pif &dollar;ks


# Az összes olyan csomagot eldobjuk, amely a fenntartott
# címtartományokba tart:
&dollar;cmd 300 deny all from 192.168.0.0/16  to any in via &dollar;pif  #RFC 1918: privát IP
&dollar;cmd 301 deny all from 172.16.0.0/12   to any in via &dollar;pif  #RFC 1918: privát IP
&dollar;cmd 302 deny all from 10.0.0.0/8      to any in via &dollar;pif  #RFC 1918: privát IP
&dollar;cmd 303 deny all from 127.0.0.0/8     to any in via &dollar;pif  #helyi
&dollar;cmd 304 deny all from 0.0.0.0/8       to any in via &dollar;pif  #helyi
&dollar;cmd 305 deny all from 169.254.0.0/16  to any in via &dollar;pif  #DHCP
&dollar;cmd 306 deny all from 192.0.2.0/24    to any in via &dollar;pif  #dokumentációs célokra fenntartott
&dollar;cmd 307 deny all from 204.152.64.0/23 to any in via &dollar;pif  #Sun klaszter
&dollar;cmd 308 deny all from 224.0.0.0/3     to any in via &dollar;pif  #D és E osztályú multicast

# Az érkezõ csomagok hitelesítése:
&dollar;cmd 400 allow udp from xx.70.207.54 to any 68 in &dollar;ks
&dollar;cmd 420 allow tcp from any to me 80 in via &dollar;pif setup limit src-addr 1


&dollar;cmd 450 deny log ip from any to any

# Ide ugrunk a kimenõ állapottartó szabályoknál:
&dollar;cmd 500 divert natd ip from any to any out via &dollar;pif
&dollar;cmd 510 allow ip from any to any

##################### a szabályok vége ##################</programlisting>

	<para>A következõ példa teljesen megegyezik az
	  elõzõvel, azonban itt már
	  dokumentációs szándékkal
	  szerepelnek megjegyzések is, melyek a tapasztalatlan
	  IPFW szabályíróknak segítik jobban
	  megérteni a szabályok pontos
	  mûködését.</para>

	<para>A második példa:</para>

	<programlisting>#!/bin/sh
############# Az IPFW szabályai itt kezdõdnek ###########################
# Kezdés elõtt töröljük az összes jelenleg aktív szabályt:
ipfw -q -f flush

# Beállítjuk a parancsok megfelelõ elõtagjait:
cmd="ipfw -q add"
skip="skipto 800"
pif="rl0"     # az internethez csatlakozó
              # hálózati interfész neve

#################################################################
# A belsõ hálózat számára ne korlátozzunk semmit se.
# Ha nincs helyi hálózatunk, akkor erre nincs szükségünk.
# Az 'xl0' nevét írjuk át a helyi hálózatra csatlakozó
# interfész nevére.
#################################################################
&dollar;cmd 005 allow all from any to any via xl0

#################################################################
# A rendszer belsõ interfészét se szûrjük.
#################################################################
&dollar;cmd 010 allow all from any to any via lo0

#################################################################
# Ellenõrizzük, hogy ez egy beérkezõ csomag és ha igen, akkor
# fordítsuk a címét.
#################################################################
&dollar;cmd 014 divert natd ip from any to any in via &dollar;pif

#################################################################
# Ha ehhez a csomaghoz korábban már vettük fel dinamikus
# szabályt a keep-state opció révén, akkor engedjük tovább.
#################################################################
&dollar;cmd 015 check-state

#################################################################
# Az internet felé forgalmazó interfész (kimenõ kapcsolatok)
# A saját hálózatunkról belülrõl vagy errõl az átjáróról
# kezdeményezett kapcsolatokat vizsgáljuk az internet felé.
#################################################################

# Kifelé engedélyezzük az internet-szolgáltatónk névszerverének
# elérését. Az x.x.x.x a szolgáltató névszerverének IP-címe
# lesz. Ha a szolgáltatónknak több névszervere is van, akkor
# az /etc/resolv.conf állományból nézzük ki a címeiket és
# másoljuk le az alábbi sor mindegyikükhöz.
&dollar;cmd 020 &dollar;skip tcp from any to x.x.x.x 53 out via &dollar;pif setup keep-state


# A kábeles és DSL kapcsolatok esetén engedélyezzük a szolgáltató
# DHCP szerverének elérését.
&dollar;cmd 030 &dollar;skip udp from any to x.x.x.x 67 out via &dollar;pif keep-state

# Kifelé engedélyezzük a szabvány nem biztonságos WWW funkciót
&dollar;cmd 040 &dollar;skip tcp from any to any 80 out via &dollar;pif setup keep-state

# Kifelé engedélyezzük a biztonságos HTTPS funkciót a TLS SSL
# használatával.
&dollar;cmd 050 &dollar;skip tcp from any to any 443 out via &dollar;pif setup keep-state

# Kifelé engedélyezzük az e-mailek küldését és fogadását.
&dollar;cmd 060 &dollar;skip tcp from any to any 25 out via &dollar;pif setup keep-state
&dollar;cmd 061 &dollar;skip tcp from any to any 110 out via &dollar;pif setup keep-state

# Kifelé engedélyezzük a FreeBSD (make install és CVSUP) funkcióit.
# Ezzel a rendszeradminisztrátornak ,,ISTENI'' jogokat adunk.
&dollar;cmd 070 &dollar;skip tcp from me to any out via &dollar;pif setup keep-state uid root

# Kifelé engedélyezzük a pinget.
&dollar;cmd 080 &dollar;skip icmp from any to any out via &dollar;pif keep-state

# Kifelé engedélyezzük az idõ szolgáltatást.
&dollar;cmd 090 &dollar;skip tcp from any to any 37 out via &dollar;pif setup keep-state

# Kifelé engedélyezzük az nntp news szolgáltatást (tehát a
# hírcsoportokat).
&dollar;cmd 100 &dollar;skip tcp from any to any 119 out via &dollar;pif setup keep-state

# Kifelé engedélyezzük a biztonságos FTP, telnet és SCP
# funkciókat az SSH (secure shell) használatával.
&dollar;cmd 110 &dollar;skip tcp from any to any 22 out via &dollar;pif setup keep-state

# Kifelé engedélyezzük ki a whois kéréseket.
&dollar;cmd 120 &dollar;skip tcp from any to any 43 out via &dollar;pif setup keep-state

# Kifelé engedélyezzük az NTP idõszerver elérését.
&dollar;cmd 130 &dollar;skip udp from any to any 123 out via &dollar;pif keep-state

#################################################################
# Az internet felõli interfész (bejövõ kapcsolatok)
# A saját hálózatunk felé vagy erre az átjáróra
# nyitott kapcsolatokat vizsgáljuk az internet felõl.
#################################################################

# Tiltsuk a fenntartott címtartományok felé haladó összes beérkezõ
# forgalmat.
&dollar;cmd 300 deny all from 192.168.0.0/16  to any in via &dollar;pif  #RFC 1918: privát IP
&dollar;cmd 301 deny all from 172.16.0.0/12   to any in via &dollar;pif  #RFC 1918: privát IP
&dollar;cmd 302 deny all from 10.0.0.0/8      to any in via &dollar;pif  #RFC 1918: privát IP
&dollar;cmd 303 deny all from 127.0.0.0/8     to any in via &dollar;pif  #helyi
&dollar;cmd 304 deny all from 0.0.0.0/8       to any in via &dollar;pif  #helyi
&dollar;cmd 305 deny all from 169.254.0.0/16  to any in via &dollar;pif  #DHCP
&dollar;cmd 306 deny all from 192.0.2.0/24    to any in via &dollar;pif  #dokumentációs célokra fenntartott
&dollar;cmd 307 deny all from 204.152.64.0/23 to any in via &dollar;pif  #Sun klaszter
&dollar;cmd 308 deny all from 224.0.0.0/3     to any in via &dollar;pif  #D és E osztályú multicast

# Az ident tiltása.
&dollar;cmd 315 deny tcp from any to any 113 in via &dollar;pif

# Blokkoljuk az összes Netbios szolgáltatást: 137=név, 138=datagram,
# 139=session. A Netbios az MS Windows megosztását implementálja.
# Blokkoljuk az MS Windows hosts2 névszerver kéréseit is a 81-es
# porton.
&dollar;cmd 320 deny tcp from any to any 137 in via &dollar;pif
&dollar;cmd 321 deny tcp from any to any 138 in via &dollar;pif
&dollar;cmd 322 deny tcp from any to any 139 in via &dollar;pif
&dollar;cmd 323 deny tcp from any to any 81  in via &dollar;pif

# Dobjuk el a késõn érkezõ csomagokat.
&dollar;cmd 330 deny all from any to any frag in via &dollar;pif

# Dobjuk el azokat az ACK csomagokat, amelyekre nincs
# dinamikus szabály.
&dollar;cmd 332 deny tcp from any to any established in via &dollar;pif

# Engedélyezzük a szolgáltató DHCP szerverétõl érkezõ forgalmat. Ennek
# a szabálynak tartalmaznia kell a DHCP szerver címét, mert csak tõle
# fogadunk el ilyen típusú csomagokat. Egyedül csak kábeles vagy DSL
# konfigurációk esetén használatos, a "felhasználói PPP" esetében
# törölhetjük. Ez ugyanaz az IP-cím, amelyet a kimenõ kapcsolatoknál
# megadtunk.
&dollar;cmd 360 allow udp from x.x.x.x to any 68 in via &dollar;pif keep-state

# Befelé engedélyezzük a szabvány WWW funkciót, mivel van
# webszerverünk.
&dollar;cmd 370 allow tcp from any to me 80 in via &dollar;pif setup limit src-addr 2

# Befelé engedélyezzük a biztonságos FTP, telnet és SCP
# használatát az internetrõl.
&dollar;cmd 380 allow tcp from any to me 22 in via &dollar;pif setup limit src-addr 2

# Befelé engedélyezzük a nem biztonságos telnet elérését az
# internetrõl. Azért nem tekintjük biztonságosnak, mert az
# azonosítókat és a jelszavakat az interneten titkosítatlanul
# közvetíti. Ha nincs telnet szolgáltatásunk, akkor törölhetjük is ezt
# a csoportot.
&dollar;cmd 390 allow tcp from any to me 23 in via &dollar;pif setup limit src-addr 2

# Dobjuk el és naplózzuk az összes internetrõl érkezõ hitelesítetlen kapcsolatot.
&dollar;cmd 400 deny log all from any to any in via &dollar;pif

# Dobjuk el és naplózzuk az összes internetre menõ hitelesítetlen kapcsolatot.
&dollar;cmd 450 deny log all from any to any out via &dollar;pif

# Ez lesz a kimenõ szabályokhoz tartozó "skipto" célja.
&dollar;cmd 800 divert natd ip from any to any out via &dollar;pif
&dollar;cmd 801 allow ip from any to any

# Minden mást alapértelmezés szerint tiltunk és naplózunk.
&dollar;cmd 999 deny log all from any to any
############# Az IPFW szabályai itt fejezõdnek be #####################</programlisting>
      </sect3>
    </sect2>
  </sect1>
</chapter>
