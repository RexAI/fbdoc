<?xml version="1.0" encoding="iso-8859-2"?>
<!--
     The FreeBSD Documentation Project
     $FreeBSD$
-->
<!-- The FreeBSD Hungarian Documentation Project
     Translated by: PALI, Gabor <pgj@FreeBSD.org>
     %SOURCE%   en_US.ISO8859-1/books/handbook/filesystems/chapter.xml
     %SRCID%    1.9
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="filesystems" xml:lang="hu">
  <info><title>Támogatott állományrendszerek</title>
    <authorgroup>
      <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Írta: </contrib></author>
    </authorgroup>
  </info>

  

  <sect1 xml:id="filesystems-synopsis">
    <title>Áttekintés</title>

    <indexterm><primary>állományrendszerek</primary></indexterm>
    <indexterm>
      <primary>támogatott
	állományrendszerek</primary>
      <see>állományrendszerek</see>
    </indexterm>

    <para>Az állományrendszerek szerves
      részét képezik napjaink operációs
      rendszereinek.  Segítségükkel a
      felhasználók adatokat tölthetnek fel és
      tárolhatnak a számítógépen,
      szabályozhatják a
      hozzáférésüket, és
      természetesen mûködtethetik a merevlemezeiket.  A
      különféle operációs rendszerekben
      általában azért annyi közös, hogy
      mindannyiukhoz tartozik egy natív, vagyis általuk
      alapból ismert állományrendszer.  A &os;
      esetében ezt konkrétan a Fast File System vagy
      röviden <acronym>FFS</acronym>, amely az eredeti Unix&trade;
      File System, vagy más néven <acronym>UFS</acronym>
      megoldásain alapszik.  A &os; tehát a merevlemezeken
      ebben a natív állományrendszerben
      tárol adatokat.</para>

    <para>A &os; természetesen ezen kívül még
      ismer számos egyéb állományrendszert,
      ezáltal képes adatokat olvasni más
      operációs rendszerek részérõl is
      kezelhetõ partíciókról,
      például helyi
      <acronym>USB</acronym>-eszközökrõl,
      flashkártyákról és
      merevlemezekrõl.  Továbbá ismeri
      néhány más operációs rendszer
      natív állományrendszerét, mint
      például a &linux; Extended File System
      (<acronym>EXT</acronym>) vagy éppen a &sun; Z File System
      (<acronym>ZFS</acronym>).</para>

    <para>&os; alatt az egyes állományrendszerek ismerete
      változó.  Bizonyos esetekben elegendõ
      csupán egy megfelelõ modul betöltése,
      máskor viszont egy komplett eszközkészlet
      segítségével tudunk velük dolgozni.  Ez
      a fejezet igyekszik a &sun;-féle Z
      állományrendszerrel kezdõdõen bemutatni a
      &os; felhasználói számára más
      állományrendszerek használatát.</para>

    <para>A fejezet elolvasása során
      megismerjük:</para>

    <itemizedlist>
      <listitem>
	<para>a natív és támogatott
	  állományrendszerek közti
	  különbségeket;</para>
      </listitem>

      <listitem>
	<para>a &os; által ismert
	  állományrendszereket;</para>
      </listitem>

      <listitem>
	<para>hogyan engedélyezzünk, állítsunk
	  be és érjünk el nem natív
	  állományrendszereket.</para>
      </listitem>
    </itemizedlist>

    <para>A fejezet elolvasásához ajánlott:</para>

    <itemizedlist>
      <listitem>
	<para>a &unix; és &os; alapjainak ismerete (<xref linkend="basics"/>);</para>
      </listitem>

      <listitem>
	<para>a rendszermag konfigurációjának
	  és fordításának alapvetõ
	  fogásainak ismerete (<xref linkend="kernelconfig"/>);</para>
      </listitem>

      <listitem>
	<para>a különbözõ külsõ
	  fejlesztésû szoftverek
	  telepítésének ismerete (<xref linkend="ports"/>);</para>
      </listitem>

      <listitem>
	<para>a lemezek és egyéb
	   tárolóeszközök, valamint a &os; alatt az
	   eszközök elnevezésének
	   minimális ismerete (<xref linkend="disks"/>).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="filesystems-zfs">
    <title>A Z állományrendszer (ZFS)</title>

    <para>A &sun; Z állományrendszere egy új,
      közös tárolási módszeren
      nyugvó technológia.  Ez annyit jelent a
      gyakorlatban, hogy mindig csak annyi helyet foglal, amennyire az
      adatoknak közvetlenül szüksége van.
      Emellett úgy alakították ki, hogy az adatok
      épségét minél inkább
      védje, ezért például
      megtalálhatjuk benne a pillanatképek
      készítését, a másolatok
      létrehozását és az adatok
      sértetlenségének
      ellenõrzését.  Továbbá egy
      <acronym>RAID</acronym>-Z néven bemutatott új
      replikációs modellt is támogat.  A
      <acronym>RAID</acronym>-Z alapvetõen a
      <acronym>RAID</acronym>-5 megoldásához
      hasonlít, azonban írás során
      keletkezõ hibák ellen igyekszik védelmet
      nyújtani.</para>

    <sect2>
      <title>A ZFS finomhangolása</title>

      <para>A <acronym>ZFS</acronym> funkcióit
	megvalósító alrendszer
	alapértelmezés szerint meglehetõsen sok
	erõforrást kíván, ezért nem
	árt a legjobb hatékonyságra behangolnunk a
	mindennapokban felmerülõ igények mentén.
	Mivel ez még egy fejlesztés és
	tesztelés alatt álló része a
	&os;-nek, elképzelhetõ, hogy ez a jövõben
	változik, viszont jelen pillanatban a következõ
	lépéseket javasoljuk.</para>

      <sect3>
	<title>Memória</title>

	<para>Hasznos, ha a rendszerünkben legalább
	  1&nbsp;GB memória található, de
	  inkább 2 vagy több az ajánlott.  Az itt
	  szereplõ példákban ehelyett azonban
	  mindenhol csupán 1&nbsp;GB-ot
	  feltételezünk.</para>

	<para>Néhányaknak sikerült
	  1&nbsp;GB-nál kevesebb központi
	  memóriával is használni ezt az
	  állományrendszert, azonban ilyenkor nagyon
	  könnyen elõfordulhat, hogy komolyabb terhelés
	  esetén a &os; a memória elfogyása miatt
	  egyszerûen összeomlik.</para>
      </sect3>

      <sect3>
	<title>A rendszermag beállításai</title>

	<para>A rendszermag konfigurációs
	  állományából javasolt
	  eltávolítani az összes nem használt
	  meghajtót és funkciót.  A legtöbb
	  meghajtó egyébként is
	  elérhetõ modul formájában, és
	  a <filename>/boot/loader.conf</filename>
	  állományon keresztül minden gond
	  nélkül betölthetõek.</para>

	<para>Az &i386; architektúránál
	  szükségünk lesz az alábbi
	  konfigurációs beállítás
	  megadására, majd a rendszermag
	  újrafordítására, végül
	  a rendszer újraindítására:</para>

	<programlisting>options 	KVA_PAGES=512</programlisting>

	<para>Ezzel az opcióval a rendszermag
	  címterét növeljük meg, aminek
	  eredményeképpen a <varname>vm.kvm_size</varname>
	  változót immáron az eredetileg
	  1&nbsp;GB-os (<acronym>PAE</acronym> használata
	  esetén pedig 2&nbsp;GB-os) határ felé
	  tudjuk állítani.  Az itt megadandó
	  értéket úgy tudjuk meghatározni,
	  ha a beállítani kívánt
	  méret MB-okban számolt
	  értékét elosztjuk néggyel.  A
	  példában tehát az <literal>512</literal>
	  egy 2&nbsp;GB nagyságú címteret ad
	  meg.</para>
      </sect3>

      <sect3>
	<title>A rendszertöltõ
	  beállításai</title>

	<para>A <filename>kmem</filename> címterét az
	  összes &os; által ismert architektúra
	  esetében érdemes megnövelnünk.  A
	  teszteléshez használt rendszeren 1&nbsp;GB
	  fizikai memória állt rendelkezésre, itt a
	  <filename>/boot/loader.conf</filename>
	  állományban a következõ
	  értékek megadásával minden
	  remekül mûködött:</para>

	<programlisting>vm.kmem_size="330M"
vm.kmem_size_max="330M"
vfs.zfs.arc_max="40M"
vfs.zfs.vdev.cache.size="5M"</programlisting>

	<para>A ZFS finomhangolásával kapcsolatos
	  további javasolatokat a <uri xlink:href="http://wiki.freebsd.org/ZFSTuningGuide">http://wiki.freebsd.org/ZFSTuningGuide</uri>
	  címen olvashatunk.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>A <acronym>ZFS</acronym> használata</title>

      <para>A Z állományrendszerhez létezik egy
	olyan mechanizmus, amelyen keresztül már a &os;
	indítása során el tudjuk végezni a
	közös tárolók
	csatlakoztatását:</para>

	<screen>&prompt.root; <userinput>echo 'zfs_enable="YES"' &gt;&gt; /etc/rc.conf</userinput>
&prompt.root; <userinput>/etc/rc.d/zfs start</userinput></screen>

	<para>A leírás fennmaradó
	  részében feltételezzük, hogy
	  három <acronym>SCSI</acronym>-lemezünk van,
	  amelyeket rendre a
	  <filename>da0</filename>,
	  <filename>da1</filename>
	  és
	  <filename>da2</filename>
	  eszközök formájában tudunk
	  elérni.  Az <acronym>IDE</acronym> lemezek
	  tulajdonosainak értelemszerûen itt majd az
	  <filename>ad</filename>
	  eszközneveket kell használniuk a
	  <acronym>SCSI</acronym>-eszközök hivatkozásai
	  helyett.</para>

      <sect3>
	<title>Egyetlen közös tároló
	  használata</title>

	<para>A <command>zpool</command> kiadásával
	  egyetlen lemezen is létre tudunk hozni egy
	  egyszerû, nem redundáns <acronym>ZFS</acronym>
	  partíciót:</para>

	<screen>&prompt.root; <userinput>zpool create minta /dev/da0</userinput></screen>

	<para>Az új közös tárterület a
	  <command>df</command> parancs
	  felhasználásával rögtön
	  láthatóvá válik:</para>

	<screen>&prompt.root; <userinput>df</userinput>
Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235230  1628718    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032846 48737598     2%    /usr
minta        17547136       0 17547136     0%    /minta</screen>

	<para>A parancs kimenetében tisztán
	  láthatjuk, hogy a <literal>minta</literal> nevû
	  tároló nem csak egyszerûen
	  elkészült, hanem egyúttal
	  <emphasis>csatolódott</emphasis>.  Innentõl
	  már a többi állományrendszerhez
	  hasonlóan tetszõlegesen elérhetõ, az
	  alábbi példához hasonlóan
	  állományok hozhatóak rajta létre
	  vagy listázható a tartalma:</para>

	<screen>&prompt.root; <userinput>cd /minta</userinput>
&prompt.root; <userinput>ls</userinput>
&prompt.root; <userinput>touch proba</userinput>
&prompt.root; <userinput>ls -al</userinput>
total 4
drwxr-xr-x   2 root  wheel    3 Aug 29 23:15 .
drwxr-xr-x  21 root  wheel  512 Aug 29 23:12 ..
-rw-r--r--   1 root  wheel    0 Aug 29 23:15 proba</screen>

	<para>Sajnos azonban ez a tároló még ki sem
	  használja a <acronym>ZFS</acronym> által
	  felkínált lehetõségeket.
	  Ezért most hozzunk létre egy
	  állományrendszert ezen a tárolón
	  belül és engedélyezzük rajta a
	  tömörítést:</para>

	<screen>&prompt.root; <userinput>zfs create minta/tomoritett</userinput>
&prompt.root; <userinput>zfs set compression=gzip minta/tomoritett</userinput></screen>

	<para>A <literal>minta/tomoritett</literal> most már egy
	  tömörített Z állományrendszer.
	  Próbáljuk ki mit tud, és másoljunk
	  néhány nagyobb méretû
	  állományt a <filename>/minta/tomoritett</filename>
	  könyvtárba.</para>

	<para>Ezután a tömörítés
	  akár ki is kapcsolható:</para>

	<screen>&prompt.root; <userinput>zfs set compression=off minta/tomoritett</userinput></screen>

	<para>Az állományrendszer
	  leválasztásához adjuk ki a lenti parancsot,
	  majd ellenõrizzük az eredményét a
	  <command>df</command> használatával:</para>

	<screen>&prompt.root; <userinput>zfs umount minta/tomoritett</userinput>
&prompt.root; <userinput>df</userinput>
Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235232  1628716    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032864 48737580     2%    /usr
minta        17547008       0 17547008     0%    /minta</screen>

	<para>Tegyük ismét elérhetõvé
	  és csatlakoztassuk újra az
	  állományrendszert, majd nézzük meg
	  az eredményt a <command>df</command> paranccsal:</para>

	<screen>&prompt.root; <userinput>zfs mount minta/tomoritett</userinput>
&prompt.root; <userinput>df</userinput>
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
minta               17547008       0 17547008     0%    /minta
minta/tomoritett    17547008       0 17547008     0%    /minta/tomoritett</screen>

	<para>A közös terület és az
	  állományrendszer mellesleg a
	  <command>mount</command> parancs kimenetébõl is
	  megfigyelhetõ:</para>

	<screen>&prompt.root; <userinput>mount</userinput>
/dev/ad0s1a on / (ufs, local)
devfs on /dev (devfs, local)
/dev/ad0s1d on /usr (ufs, local, soft-updates)
minta on /minta (zfs, local)
minta/tomoritett on /minta/tomoritett (zfs, local)</screen>

	<para>Látható, hogy a létrehozásuk
	  után a Z állományrendszerek teljesen
	  hétköznapi módon viselkednek, de
	  természetesen további lehetõségek is
	  elérhetõek hozzájuk.  A következõ
	  példában <literal>adat</literal> néven
	  készítünk egy új
	  állományrendszert.  Mivel ide majd nagyon fontos
	  állományokat akarunk elhelyezni,
	  állítsuk be, hogy minden adatblokkból
	  két példány legyen:</para>

	<screen>&prompt.root; <userinput>zfs create minta/adat</userinput>
&prompt.root; <userinput>zfs set copies=2 minta/adat</userinput></screen>

	<para>A <command>df</command> újbóli
	  kiadásával most már látható
	  is ez az állományrendszer és annak
	  tárfoglalása:</para>

	<screen>&prompt.root; <userinput>df</userinput>
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
minta               17547008       0 17547008     0%    /minta
minta/tomoritett    17547008       0 17547008     0%    /minta/tomoritett
minta/adat          17547008       0 17547008     0%    /minta/adat</screen>

	<para>Vegyük észre, hogy a közös
	  területen levõ állományrendszerek
	  mindegyikén ugyanannyi szabad terület van.  A
	  <command>df</command> segítségével a
	  késõbbiekben remekül megfigyelhetõ lesz,
	  hogy az egyes állományrendszerek mindig csak
	  annyi területet foglalnak el a közös
	  területbõl, amennyire abban a pillanatban
	  ténylegesen szükségünk van.  A Z
	  állományrendszerek esetén megszûnik
	  a partíciók és kötetek fogalma,
	  és több állományrendszer
	  tárolódik egyazon közös
	  területen.  Ha már nem akarjuk használni,
	  egyszerûen csak töröljük le az
	  állományrendszereket és ezt a
	  közös tárolót:</para>

	<screen>&prompt.root; <userinput>zfs destroy minta/tomoritett</userinput>
&prompt.root; <userinput>zfs destroy minta/adat</userinput>
&prompt.root; <userinput>zpool destroy minta</userinput></screen>

	<para>Nyilván tapasztalhattunk már, hogy a
	  lemezeink olykor menthetetlenül meghibásodnak.
	  Amikor egy lemezes meghajtó tönkremegy, a rajta
	  tárolt adatok általában elvesznek.  Az
	  ilyen jellegû kellemetlenségek
	  elkerülésének egyik módja az
	  ún.  <acronym>RAID</acronym>-tömbök
	  építése.  A következõ
	  szakaszban bemutatjuk, hogy a Z
	  állományrendszerek esetén hogyan tudunk
	  ilyen tömböket készíteni.</para>
      </sect3>

      <sect3>
	<title><acronym>RAID</acronym>-Z tömbök</title>

	<para>Korábban már utaltunk rá, hogy ebben
	  a szakaszban három <acronym>SCSI</acronym>-lemez,
	  vagyis a <filename>da0</filename>,
	  <filename>da1</filename> és
	  <filename>da2</filename> eszközök
	  használatát feltételezzük (vagy
	  természetesen <filename>ad0</filename> és
	  így tovább, ha IDE-lemezeket használunk).
	  Egy <acronym>RAID</acronym>-Z formátumú
	  közös tároló
	  készítéséhez a következõ
	  parancsot kell kiadni:</para>

	<screen>&prompt.root; <userinput>zpool create tarolo raidz da0 da1 da2</userinput></screen>

	<note>
	  <para>A &sun; ajánlása szerint egy
	    <acronym>RAID</acronym>-Z konfigurációban
	    legalább három, legfeljebb kilenc lemezt
	    javasolt alkalmazni.  Ha egyetlen közös
	    tárolóban esetleg tíznél
	    több lemezt szeretnénk felhasználni,
	    akkor érdemes inkább kisebb
	    <acronym>RAID</acronym>-Z csoportokra felosztani ezeket.  Ha
	    viszont csak két lemezünk van, de
	    továbbra is redundanciára lenne
	    szükségünk, hozzunk helyette létre
	    egy <acronym>ZFS</acronym> tükrözést.
	    Ezzel kapcsolatban részletesebben a &man.zpool.8; man
	    oldalon keresztül
	    tájékozódhatunk.</para>
	</note>

	<para>Ennek hatására tehát keletkezik egy
	  <literal>tarolo</literal> nevû Z-tároló.
	  Ez a korábbiakhoz hasonló módon
	  ellenõrizhetõ is a &man.mount.8; és
	  &man.df.1; parancsokon keresztül.  Természetesen
	  az iménti listába további
	  lemezeszközök tetszõlegesen felvehetõek.
	  Most hozzunk létre ezen a közös
	  területen egy <literal>felhasznalok</literal> nevû
	  állományrendszert, ahová majd a
	  felhasználók adatait fogjuk tenni:</para>

	<screen>&prompt.root; <userinput>zfs create tarolo/felhasznalok</userinput></screen>

	<para>Miután ezzel megvagyunk, az imént
	  létrehozott állományrendszerre nyugodtan
	  beállíthatunk tömörítést
	  és biztonsági másolatokat.  Ebben az
	  alábbi parancsok lesznek a
	  segítségünkre:</para>

	<screen>&prompt.root; <userinput>zfs set copies=2 tarolo/felhasznalok</userinput>
&prompt.root; <userinput>zfs set compression=gzip tarolo/felhasznalok</userinput></screen>

	<para>Ezt követõen költöztessük
	  át a felhasználókat, vagyis másoljuk
	  át az adataikat ide és hozzuk létre a
	  megfelelõ szimbolikus linkeket:</para>

	<screen>&prompt.root; <userinput>cp -rp /home/* /tarolo/felhasznalok</userinput>
&prompt.root; <userinput>rm -rf /home /usr/home</userinput>
&prompt.root; <userinput>ln -s /tarolo/felhasznalok /home</userinput>
&prompt.root; <userinput>ln -s /tarolo/felhasznalok /usr/home</userinput></screen>

	<para>A felhasználók adatai immáron a
	  frissen létrehozott <filename>/tarolo/felhasznalok</filename>
	  állományrendszeren tárolódnak.
	  Próbáljuk ki, hozzunk létre egy új
	  felhasználót és jelentkezzünk be
	  vele.</para>

	<para>Készítsünk most egy
	  pillanatképet is, amelyet aztán késõbb
	  szükség esetén vissza tudunk
	  állítani:</para>

	<screen>&prompt.root; <userinput>zfs snapshot tarolo/felhasznalok@08-08-30</userinput></screen>

	<para>A <literal>snapshot</literal> csak valós
	  állományrendszerekkel mûködik,
	  könyvtárakra vagy állományokra nem.
	  A nevében a <literal>@</literal> karakter
	  választja el egymástól a
	  hozzá tartozó címkét az
	  állományrendszer vagy kötet
	  nevétõl.  Ha netalán a
	  felhasználói könyvtárak
	  valamiért megsérültek volna, a
	  következõ paranccsal
	  állíthatóak vissza:</para>

	<screen>&prompt.root; <userinput>zfs rollback tarolo/felhasznalok@08-08-30</userinput></screen>

	<para>Az adott idõpontban aktív
	  pillanatképeket az adott állományrendszer
	  <filename>.zfs/snapshot</filename>
	  könyvtárában találhatjuk meg.
	  Például az elõbb készített
	  pillanatkép az alábbi paranccsal
	  nézhetõ meg:</para>

	<screen>&prompt.root; <userinput>ls /tarolo/felhasznalok/.zfs/snapshot</userinput></screen>

	<para>Ha ebbõl elindulunk, akkor pillanatok alatt
	  írható egy olyan szkript, amely a
	  felhasználók adatairól havonta
	  készít egy pillanatképet.  Ilyenkor
	  azonban fontos számításba vennünk,
	  hogy az idõvel felgyülemlõ pillanatképek
	  rengeteg helyet el tudnak foglalni.  A korábbi
	  pillanatkép így távolítható
	  el:</para>

	<screen>&prompt.root; <userinput>zfs destroy tarolo/felhasznalok@08-08-30</userinput></screen>

	<para>Miután alaposan kipróbáltuk a
	  <filename>/tarolo/felhasznalok</filename>
	  néven létrehozott
	  állományrendszerünket,
	  állítsuk be véglegesen ez eddigi
	  <filename>/home</filename>
	  állományrendszer helyére:</para>

	<screen>&prompt.root; <userinput>zfs set mountpoint=/home tarolo/felhasznalok</userinput></screen>

	<para>Ekkor a <command>df</command> és
	  <command>mount</command> parancsok használatával
	  meggyõzõdhetünk róla, hogy ezt az
	  állományrendszert innentõl már
	  valóban a <filename>/home</filename>
	  könyvtárnak tekintjük:</para>

	<screen>&prompt.root; <userinput>mount</userinput>
/dev/ad0s1a on / (ufs, local)
devfs on /dev (devfs, local)
/dev/ad0s1d on /usr (ufs, local, soft-updates)
tarolo on /tarolo (zfs, local)
tarolo/felhasznalok on /home (zfs, local)
&prompt.root; <userinput>df</userinput>
Filesystem          1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a           2026030  235240  1628708    13%    /
devfs                       1       1        0   100%    /dev
/dev/ad0s1d          54098308 1032826 48737618     2%    /usr
tarolo               26320512       0 26320512     0%    /tarolo
tarolo/felhasznalok  26320512       0 26320512     0%    /home</screen>

	<para>Ezzel lényegében befejeztük a
	  <acronym>RAID</acronym>-Z tömb
	  konfigurációját.  Az
	  állományrendszerek állapotára
	  vonatkozóan a &man.periodic.8;
	  alkalmazásával akár naponta
	  kérhetünk ellenõrzést:</para>

	<screen>&prompt.root; <userinput>echo 'daily_status_zfs_enable="YES"' &gt;&gt; /etc/periodic.conf</userinput></screen>
      </sect3>

      <sect3>
	<title>A <acronym>RAID</acronym>-Z
	  helyreállítása</title>

	<para>Minden szoftveres <acronym>RAID</acronym>
	  implementáció kínál valamilyen
	  megoldást az állapotának
	  ellenõrzésére, ez alól
	  tulajdonképpen a <acronym>ZFS</acronym> sem
	  kivétel.  A <acronym>RAID</acronym>-Z
	  eszközök állapota a következõ
	  paranccsal kérdezhetõ le:</para>

	<screen>&prompt.root; <userinput>zpool status -x</userinput></screen>

	<para>Ezt az üzenetet láthatjuk, amikor minden
	  tároló kifogástalanul mûködik
	  és semmilyen probléma sincs:</para>

	<screen>all pools are healthy</screen>

	<para>Ha viszont valamilyen gond lenne valamelyik lemezzel,
	  például leállt, akkor az elõbbi
	  parancs eredménye ehhez lesz hasonló:</para>

	<screen>  pool: tarolo
 state: DEGRADED
status: One or more devices has been taken offline by the administrator.
	Sufficient replicas exist for the pool to continue functioning in a
	degraded state.
action: Online the device using 'zpool online' or replace the device with
	'zpool replace'.
 scrub: none requested
config:

	NAME        STATE     READ WRITE CKSUM
	tarolo      DEGRADED     0     0     0
	  raidz1    DEGRADED     0     0     0
	    da0     ONLINE       0     0     0
	    da1     OFFLINE      0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</screen>

	<para>A válasz szerint az eszközt az
	  adminisztrátor állította le.  Ez
	  ennél a példánál valóban
	  igaz.  Lemezeket a következõ módon lehet
	  leállítani:</para>

	<screen>&prompt.root; <userinput>zpool offline tarolo da1</userinput></screen>

	<para>Így miután leállítottuk a
	  rendszert, a <filename>da1</filename> eszköz
	  cserélhetõ.  A rendszer soron következõ
	  indításakor ezzel a paranccsal tudjuk jelezni
	  logikailag is a lemez cseréjét:</para>

	<screen>&prompt.root; <userinput>zpool replace tarolo da1</userinput></screen>

	<para>Nézzük meg újra a tömb
	  állapotát, de ezúttal a <option>-x</option>
	  kapcsoló megadása nélkül, mivel csak
	  így fogjuk látni:</para>

	<screen>&prompt.root; <userinput>zpool status tarolo</userinput>
 pool: tarolo
 state: ONLINE
 scrub: resilver completed with 0 errors on Sat Aug 30 19:44:11 2008
config:

	NAME        STATE     READ WRITE CKSUM
	tarolo      ONLINE       0     0     0
	  raidz1    ONLINE       0     0     0
	    da0     ONLINE       0     0     0
	    da1     ONLINE       0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</screen>

	<para>A példa szerint minden megfelelõen
	  mûködik.</para>
      </sect3>

      <sect3>
	<title>Az adatok ellenõrzése</title>

	<para>Elõzetesen már szó esett róla,
	  hogy a <acronym>ZFS</acronym> képes a tárolt
	  adatok sértetlenségének
	  ellenõrzésére.  Az új
	  állományrendszerek
	  létrehozásánál ez a
	  lehetõség automatikusan aktiválódik,
	  de tetszés szerint letiltható:</para>

	<screen>&prompt.root; <userinput>zfs set checksum=off tarolo/felhasznalok</userinput></screen>

	<para>Ez a lépés viszont nem
	  feltétlenül jó döntés, mivel az
	  adatintegritás megtartásához
	  felhasznált ellenõrzõ összegek nagyon
	  kevés helyet foglalnak és meglehetõsen
	  hasznosak.  Emellett semmilyen észlelhetõ
	  lassulást nem okoznak az állományrendszer
	  használata során.  Ha engedélyezzük,
	  a <acronym>ZFS</acronym> ilyen ellenõrzõ
	  összegek segítségével folyamatosan
	  figyelni tudja az adatok épségét.  Ezt az
	  ellenõrzést a <literal>scrub</literal> paranccsal
	  válthatjuk ki.  Nézzük meg
	  például a <literal>tarolo</literal>
	  esetében:</para>

	<screen>&prompt.root; <userinput>zpool scrub tarolo</userinput></screen>

	<para>Ez a vizsgálat a tárolt adatok
	  mennyiségétõl függõen nagyon
	  sokáig is eltarthat, illetve rengeteg
	  lemezmûveletet foglal magában, ezért
	  egyszerre csak egy ilyen futtatása javasolt.
	  Miután befejezõdött, a tároló
	  állapota az eredményének megfelelõen
	  frissül, amelyet közvetlenül utána le is
	  kérdezhetünk:</para>

	<screen>&prompt.root; <userinput>zpool status tarolo</userinput>
 pool: tarolo
 state: ONLINE
 scrub: scrub completed with 0 errors on Sat Aug 30 19:57:37 2008
config:

	NAME        STATE     READ WRITE CKSUM
	tarolo      ONLINE       0     0     0
	  raidz1    ONLINE       0     0     0
	    da0     ONLINE       0     0     0
	    da1     ONLINE       0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</screen>

	<para>A példában látható az
	  utolsó ellenõrzés ideje.  Ezen
	  lehetõség használatával
	  hosszú idõn keresztül szavatolni tudjuk az
	  adataink épségét.</para>

	<para>A Z állományrendszerrel kapcsolatos
	  további beállítási
	  lehetõségekrõl a &man.zfs.8; és
	  &man.zpool.8; man oldalakon olvashatunk.</para>
      </sect3>
    </sect2>
  </sect1>
</chapter>
