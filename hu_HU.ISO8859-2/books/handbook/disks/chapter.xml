<?xml version="1.0" encoding="iso-8859-2"?>
<!--
     The FreeBSD Documentation Project

     $FreeBSD$
-->
<!-- The FreeBSD Hungarian Documentation Project
     Translated by: PALI, Gabor <pgj@FreeBSD.org>
     %SOURCE%	en_US.ISO8859-1/books/handbook/disks/chapter.xml
     %SRCID%	1.298
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="disks" xml:lang="hu">
  <title>Háttértárak</title>

  <sect1 xml:id="disks-synopsis">
    <title>Áttekintés</title>

    <para>Ez a fejezet arról szól, hogy miként
      használjuk a lemezeinket a &os;-vel.  Itt többek
      közt szó esik a memória (alapú)
      lemezekrõl, a hálózaton keresztül
      csatlakoztatott meghajtókról, a szabványos
      SCSI/IDE tárolóeszközökrõl és
      az USB felületet használó
      eszközökrõl.</para>

    <para>A fejezet elolvasása során
      megismerjük:</para>

    <itemizedlist>
      <listitem>
	<para>a &os; által alkalmazott
	  terminológiát, amivel a fizikai lemezeken
	  elhelyezkedõ adatokat írja le
	  (partíciók és slice-ok);</para>
      </listitem>
      <listitem>
	<para>hogyan bõvítsük rendszerünket
	  további merevlemezekkel;</para>
      </listitem>
      <listitem>
	<para>hogyan állítsuk be a &os;-t USB
	  tárolóeszközök
	  használatára;</para>
      </listitem>
      <listitem>
	<para>hogyan állítsunk be virtuális
	  állományrendszereket, például
	  memórialemezeket;</para>
      </listitem>
      <listitem>
	<para>hogyan használjuk a kvótákat a
	  lemezterület használatának
	  korlátozására;</para>
      </listitem>
      <listitem>
	<para>hogyan védjüket meg lemezeinket
	  titkosítással az
	  illetéktelenektõl;</para>
      </listitem>
      <listitem>
	<para>&os; alatt hogyan készítsünk és
	  írjuk CD-ket, DVD-ket;</para>
      </listitem>
      <listitem>
	<para>a biztonsági mentések
	  készítésének
	  különbözõ lehetõségeit;</para>
      </listitem>
      <listitem>
	<para>hogyan használjuk a &os; alatt
	  rendelkezésünkre álló,
	  biztonsági mentést készítõ
	  programokat;</para>
      </listitem>
      <listitem>
	<para>hogyan mentsünk floppy lemezekre;</para>
      </listitem>
      <listitem>
	<para>mik az állományrendszerek
	  pillanatképei és hogyan kell ezeket
	  hatékonyan használni.</para>
      </listitem>
    </itemizedlist>

    <para>A fejezet elolvasásához ajánlott:</para>

    <itemizedlist>
      <listitem>
	<para>a &os; rendszermag
	  beállításának és
	  telepítésének ismerete (<xref linkend="kernelconfig"/>)</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 xml:id="disks-naming">
    <title>Az eszközök elnevezései</title>

    <para>A most következõ listában felsoroljuk a &os;
      által ismert fizikai
      tárolóeszközöket és a
      hozzájuk tartozó elnevezéseket.</para>

    <table xml:id="disk-naming-physical-table" frame="none">
      <title>A fizikai lemezek elnevezésének
	szabályai</title>

      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>A meghajtó típusa</entry>
	    <entry>A meghajtóeszköz neve</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>IDE merevlemezek</entry>
	    <entry><literal>ad</literal></entry>
	  </row>
	  <row>
	    <entry>IDE CD-meghajtók</entry>
	    <entry><literal>acd</literal></entry>
	  </row>
	  <row>
	    <entry>SCSI merevlemezek és USB
	      tárolóeszközök</entry>
	    <entry><literal>da</literal></entry>
	  </row>
	  <row>
	    <entry>SCSI CD-meghajtók</entry>
	    <entry><literal>cd</literal></entry>
	  </row>
	  <row>
	    <entry>Különbözõ nem szabványos
	      CD-meghajtók</entry>
	    <entry><literal>mcd</literal> (Mitsumi CD-ROM) és
	      <literal>scd</literal> (Sony CD-ROM)
	    </entry>
	  </row>
	  <row>
	    <entry>Floppy meghajtók</entry>
	    <entry><literal>fd</literal></entry>
	  </row>
	  <row>
	    <entry>SCSI szalagos meghajtók</entry>
	    <entry><literal>sa</literal></entry>
	  </row>
	  <row>
	    <entry>IDE szalagos meghajtók</entry>
	    <entry><literal>ast</literal></entry>
	  </row>
	  <row>
	    <entry>Flash meghajtó</entry>
	    <entry><literal>fla</literal> (&diskonchip; Flash
	      eszköz)</entry>
	  </row>
	  <row>
	    <entry>RAID meghajtók</entry>
	    <entry><literal>aacd</literal> (&adaptec; AdvancedRAID),
	      <literal>mlxd</literal> és <literal>mlyd</literal>
	      (&mylex;), <literal>amrd</literal> (AMI &megaraid;),
	      <literal>idad</literal> (Compaq Smart RAID),
	      <literal>twed</literal> (&tm.3ware; RAID).</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

  </sect1>

  <sect1 xml:id="disks-adding">
    <info><title>Lemezek hozzáadása</title>
      <authorgroup>
	<author><personname><firstname>David</firstname><surname>O'Brien</surname></personname><contrib>Eredetileg írta: </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>lemezek</primary>
      <secondary>hozzáadás</secondary>
    </indexterm>

    <para>Ebben a szakaszban arról lesz szó, hogy a
      jelenleg egyetlen meghajtót tartalmazó
      rendszerünket hogyan tudjuk bõvíteni egy
      új SCSI-lemez hozzáadásával.  Ehhez
      elsõként kapcsoljuk ki a
      számítógépünket és
      szereljük be a helyére az új meghajtót a
      számítógép, a lemezvezérlõ
      és a meghajtó gyártójának
      utasításai alapján.  Mivel ezt a
      mûveletet rengeteg módon lehet elvégezni,
      ezért ennek pontos részleteivel ez a
      leírás most nem foglalkozik.</para>

    <para>Jelentkezzünk be <systemitem class="username">root</systemitem>
      felhasználóként.  Miután
      beszereltük a meghajtót, a
      <filename>/var/run/dmesg.boot</filename> állomány
      végignézésével bizonyosodjuk meg
      róla, hogy a rendszer valóban megtalálta a
      lemezt.  A példánk szerint ez a meghajtó
      tehát a <filename>da1</filename> nevet fogja viselni,
      amelyet a <filename>/1</filename> könyvtárba akarunk
      csatlakoztatni (ha IDE-meghajtót telepítünk,
      akkor a hozzá tartozó eszköz neve
      <filename>ad1</filename> lesz).</para>

    <indexterm><primary>partíciók</primary></indexterm>
    <indexterm><primary>slice-ok</primary></indexterm>
    <indexterm><primary><command>fdisk</command></primary></indexterm>

    <para>Mivel a &os; IBM PC kompatibilis
      számítógépeken fut, ezért nem
      szabad figyelmen kívül hagynunk a PC BIOS
      partícióit is.  Ezek eltérnek a
      hagyományos BSD partícióktól.  Egy
      PC-s lemeznek négy BIOS-os
      partícióbejegyzése lehet.  Ha egy lemezt
      tényleg csak a &os;-nek szánunk, akkor
      használhatjuk az ún.
      <emphasis>dedikált</emphasis> módot.  Minden
      más esetben a &os;-nek egy PC BIOS
      partícióban kell elhelyezkednie.  A &os; a PC BIOS
      partícióit <emphasis>slice</emphasis>-nak nevezi,
      ezzel különbözteti ezeket a hagyományos BSD
      partícióktól.  Dedikált esetekben is
      használhatjuk, de elsõsorban akkor kap fontosabb
      szerepet, amikor a &os;-nek más operációs
      rendszerekkel kell megosztani a helyet.  Ezzel el tudjuk
      kerülni, hogy a más operációs
      rendszerekben megtalálható, nem &os; alapú
      <command>fdisk</command> parancs megzavarodjon.</para>

    <para>A slice-ok használatakor a meghajtó
      <filename>/dev/da1s1e</filename> néven kerül
      hozzáadásra.  Így kell olvasni: egyes SCSI
      lemezes egység (második SCSI lemez), elsõ slice
      (elsõ PC BIOS partíció) és
      <filename>e</filename> BSD partíció.  A
      dedikált esetben a meghajtó neve viszont
      egyszerûen csak <filename>/dev/da1e</filename>.</para>

    <para>Mivel a &man.bsdlabel.8; 32 bites egész számokat
      használ a szektorok számának
      tárolására, ezért lemezenként
      csak 2^32-1 szektort tud ábrázolni, ami az esetek
      többségében 2&nbsp;TB méretû
      címezhetõ területet jelent.  Az &man.fdisk.8;
      formátuma szerint sem a kezdõszektor, sem a hossz nem
      lehet 2^32-1-nél több, amivel így a
      partíciókat 2&nbsp;TB, a lemezeket pedig 4&nbsp;TB
      méretûre korlátozza.  A &man.sunlabel.8;
      formátuma partíciónként 2^32-1
      szektort enged meg és összesen 8
      partíciót, amely ezáltal 16&nbsp;TB
      terület lefedését teszi lehetõvé.
      Nagyobb lemezekhez &man.gpt.8; partíciók
      használatosak.</para>

    <sect2>
      <title>A &man.sysinstall.8; használatával</title>

      <indexterm>
	<primary><application>sysinstall</application></primary>
	<secondary>lemezek hozzáadása</secondary>
      </indexterm>
      <indexterm><primary>su</primary></indexterm>

      <procedure>
	<step>
	  <title>Közlekedés a
	    <application>sysinstall</application> programban</title>

	  <para>A <command>sysinstall</command> könnyen
	    használható menüinek
	    segítségével az új lemezen
	    pillanatok alatt létre tudunk hozni
	    partíciókat és
	    megcímkézni ezeket.  Ehhez vagy
	    <systemitem class="username">root</systemitem>
	    felhasználóként jelentkezzünk be a
	    rendszerbe, vagy adjuk ki a <command>su</command> parancsot.
	    A <command>sysinstall</command> parancs kiadása
	    után lépjünk be a
	    <literal>Configure</literal>
	    (Beállítások) menübe.  A
	    <literal>&os; Configuration Menu</literal> menüben
	    ezután keressük meg és válasszuk
	    ki az <literal>Fdisk</literal> menüpontot.</para>
	</step>

	<step>
	  <title>Az <application>fdisk</application>
	    partíciószerkesztõ</title>

	  <para>Miután eljutottunk az
	    <application>fdisk</application> alkalmazáshoz, az
	    <keycap>A</keycap> lenyomásával
	    felajánlhatjuk az egész lemezt a &os;
	    számára.  Amikor elõkerül a
	    kérdés, hogy <quote>remain cooperative with
	    any future possible operating systems</quote>
	    (<quote>mûködõképes maradjon-e a
	    késõbbiekben telepítendõ
	    operációs rendszerekkel</quote>), akkor
	    válaszoljuk rá <literal>YES</literal>-szel
	    (tehát igen).  A <keycap>W</keycap> gomb
	    lenyomásával írjuk a lemezre a most
	    elvégzett változtatásokat.
	    Ezután már a <keycap>Q</keycap>
	    használatával ki is léphetünk az
	    FDISK szerkesztõbõl.  A következõ
	    lépésben a <quote>Master Boot
	    Record</quote>-ról fognak minket megkérdezni.
	    Mivel most egy már mûködõ rendszert
	    bõvítünk, ezért a válaszunk
	    erre <literal>None</literal> lesz.</para>
	</step>

	<step>
	  <title>A lemezcímkék szerkesztése</title>

	  <indexterm><primary>BSD
	    partíciók</primary></indexterm>

	  <para>Most lépjünk ki a
	    <application>sysinstall</application>
	    alkalmazásból és indítsuk el
	    újra.  Kövessük az iménti
	    útmutatásokat, de ezúttal a
	    <literal>Label</literal> menüpontot válasszuk
	    ki.  Ezzel a <literal>Disk Label Editor</literal>-ba vagyis
	    a lemezcímkék szerkesztõjéhez
	    jutunk.  Itt fogjuk létrehozni a hagyományos
	    BSD partíciókat.  Egy lemezen nyolc ilyen
	    partíció lehet,
	    <literal>a</literal>-tól <literal>h</literal>-ig.
	    Közülük néhány
	    partíció címkéjét
	    megkülönböztetjük.  Az
	    <literal>a</literal> partíció jelöli a
	    rendszer indításához használt
	    partíciót, a
	    gyökérpartíciót
	    (<filename>/</filename>).  Tehát <literal>a</literal>
	    partíció csak a rendszerlemezünkön
	    szerepelhet (tehát ahonnan indul a rendszer).  A
	    <literal>b</literal> partíció a
	    lapozáshoz használt partíciókat
	    jelöli és több lemezen is szerepelhet.  A
	    <literal>c</literal> partíción keresztül
	    lehet elérni az egészt lemezt dedikált
	    módban vagy az egész &os; slice-ot slice
	    módban.  A többi partíció
	    tetszõlegesen felhasználható.</para>

	  <para>A <application>sysinstall</application>
	    címkeszerkesztõje az <literal>e</literal>
	    betûvel szereti megjelölni a sem nem
	    rendszerindító, sem nem lapozó
	    partíciókat.  A címkeszerkesztõben
	    egyetlen állományrendszert a
	    <keycap>C</keycap> lenyomásával lehet
	    készíteni.  Amikor erre válaszul
	    megkérdezi a típusát (FS
	    (állományrendszer) vagy swap
	    (lapozóterület) legyen), akkor válasszuk
	    az <literal>FS</literal> beállítást
	    és adjuk meg a csatlakozási pontját
	    (például <filename>/mnt</filename>).  Amikor a
	    lemezt telepítés után (post-install)
	    adjuk hozzá, akkor a
	    <application>sysinstall</application>
	    valójában nem hoz létre hozzá
	    bejegyzéseket az <filename>/etc/fstab</filename>
	    állományban, ezért a
	    csatlakozási pont megadása nem is
	    feltétlenül fontos.</para>

	  <para>Most már készen állunk arra, hogy
	    rögzítsük az új címkét
	    a lemezre és létrehozzunk vele egy
	    állományrendszert.  Ehhez nyomjuk le a
	    <keycap>W</keycap> gombot.  Ne foglalkozzunk vele, ha a
	    <application>sysinstall</application> nem képes
	    csatlakoztatni az új partíciót.  Ha
	    ezzel megvagyunk, akkor lépjünk ki a
	    címkeszerkesztõbõl és a
	    <application>sysinstall</application>ból is.</para>
	</step>

	<step>
	  <title>Befejezés</title>

	  <para>Most már csak annyi teendõnk maradt, hogy
	    felvegyük az <filename>/etc/fstab</filename>
	    állományba az új lemezhez
	    tartozó bejegyzést.</para>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title>Parancssoros eszközök
	használatával</title>

      <sect3>
	<title>Slice módban</title>

	<para>Ezzel a beállítással a
	  lemezünkre késõbb más
	  operációs rendszereket is
	  telepíthetünk, és nem okoz gondot a
	  saját <command>fdisk</command> segédprogramjaik
	  mûködésében.  Az új lemezek
	  telepítésénél ezt a módszer
	  ajánlatos követni.  A dedikált módot
	  viszont csak abban az esetben használjuk, ha erre
	  nyomós okunk van!</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 bs=1k count=1</userinput>
&prompt.root; <userinput>fdisk -BI da1</userinput> # inicializáljuk az új lemezt
&prompt.root; <userinput>bsdlabel -B -w da1s1 auto</userinput> # címkézzük meg
&prompt.root; <userinput>bsdlabel -e da1s1</userinput> # szerkeszzük át a frissen létrehozott címkét és vegyünk fel egy új partíciót
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>newfs /dev/da1s1e</userinput> # ismételjük meg minden létrehozott partícióhoz
&prompt.root; <userinput>mount /dev/da1s1e /1</userinput> # csatlakoztassuk a partíció(ka)t
&prompt.root; <userinput>vi /etc/fstab</userinput> # vegyük fel a megfelelõ bejegyzés(eke)t az <filename>/etc/fstab</filename> állományba</screen>

	<para>IDE-lemezek esetén az<filename>ad</filename>
	  eszközt a <filename>da</filename> eszközzel
	  helyettesítsük.</para>

      </sect3>

      <sect3>
	<title>Dedikált módban</title>

	<indexterm><primary>OS/2</primary></indexterm>

	<para>Amennyiben az új meghajtót nem akarjuk
	  megosztani egyetlen más operációs
	  rendszerrel sem, használhatjuk a
	  <literal>dedicated</literal> (dedikált) módot.
	  Ne felejtsük el azonban, hogy ez képes
	  összezavarni a Microsoft operációs
	  rendszereit, habár ebbõl semmilyen kárunk
	  nem fog származni.  Az IBM &os2;
	  operációs rendszere azonban
	  <quote>kisajátít</quote> minden olyan
	  partíciót, amelyet nem tud olvasni.</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 bs=1k count=1</userinput>
&prompt.root; <userinput>bsdlabel -Bw da1 auto</userinput>
&prompt.root; <userinput>bsdlabel -e da1</userinput>				# létrehozzuk az `e' partíciót
&prompt.root; <userinput>newfs /dev/da1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput>				# felvesszük a /dev/da1e partíciót
&prompt.root; <userinput>mount /1</userinput></screen>

	<para>Egy másik megoldás:</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 count=2</userinput>
&prompt.root; <userinput>bsdlabel /dev/da1 | bsdlabel -BR da1 /dev/stdin</userinput>
&prompt.root; <userinput>newfs /dev/da1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput>					# felvesszük a /dev/da1e partíciót
&prompt.root; <userinput>mount /1</userinput></screen>

      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="raid">
    <title>RAID</title>

    <sect2 xml:id="raid-soft">
      <title>Szoftveres RAID</title>

      <sect3 xml:id="ccd">
	<info><title>Összefûzött lemezek
	  beállítása</title>
	  <authorgroup>
	    <author><personname><firstname>Christopher</firstname><surname>Shumway</surname></personname><contrib>Eredetileg készítette: </contrib></author>
	  </authorgroup>
	  <authorgroup>
	    <author><personname><firstname>Jim</firstname><surname>Brown</surname></personname><contrib>Ellenõrizte: </contrib></author>
	  </authorgroup>
	</info>

	

	<indexterm><primary>RAID</primary><secondary>szoftveres</secondary></indexterm>
	<indexterm><primary>RAID</primary><secondary>CCD</secondary></indexterm>

	<para>A nagyobb méretû
	  háttértárolók
	  kiválasztásánál a legfontosabb
	  tényezõk a sebesség,
	  megbízhatóság és a
	  költség.  Nagyon ritkán lehet csak ezt a
	  hármat egyensúlyba hozni:
	  általában a gyors és
	  megbízható
	  tárolóeszközök sok pénzbe
	  kerülnek, valamint a költségek
	  megtakarításához vagy a sebességet
	  vagy pedig a megbízhatóságot kell
	  feláldoznunk.</para>

	<para>A továbbiakban egy olyan rendszert mutatunk be,
	  ahol a elsõsorban a költségek, majd csak
	  ezután a sebesség és
	  megbízhatóság kerültek
	  elõtérben.  A rendszer adatátviteli
	  sebességét a hálózat
	  korlátozza.  Habár emellett a
	  megbízhatóság is nagyon fontos, a
	  tárgyalt összefûzött meghajtó
	  (Concenated Disk, CCD) csak adatokat szolgáltat
	  és a teljes tartalma bármikor
	  visszaállítható, mivel
	  rendelkezésre áll CD-n.</para>

	<para>A feladat elvégzésére alkalmas
	  háttértároló
	  kiválasztásában elsõként a
	  saját elvárásainkat kell tudnunk
	  megfogalmazni.  Ha nekünk jobban számít az
	  árnál a sebesség vagy a
	  megbízhatóság, akkor a
	  mostaniaktól némileg eltérõ
	  konfigurációt kell majd
	  építenünk.</para>

	<sect4 xml:id="ccd-installhw">
	  <title>A hardver telepítése</title>

	  <para>A rendszert tartalmazó IDE-lemez mellett
	    három darab, egyenként 30&nbsp;GB-os 5400-as
	    percenkénti fordulatszámú Western
	    Digital gyártmányú merevlemez alkotja
	    majd a létrehozni kívánt, kb.
	    90&nbsp;GB összméretû
	    összefûzött lemezt.  Ideális esetben
	    minden IDE-lemez saját külön
	    vezérlõn és kábelen van, de a
	    költségek csökkentése miatt nem
	    használtunk további
	    IDE-vezérlõket.  Ehelyett inkább
	    jumperekkel úgy állítottuk be a
	    lemezeket, hogy minden vezérlõre egy mester
	    (master) és egy szolga (slave) módú
	    merevlemez kapcsolódjon.</para>

	  <para>A beszerelés után
	    beállítottuk a rendszer BIOS-át, hogy
	    automatikusan felismerje a csatlakoztatott lemezeket.  De
	    ami még fontosabb, hogy a &os; is észlelte
	    ezeket az indítás során:</para>

	  <programlisting>ad0: 19574MB &lt;WDC WD205BA&gt; [39770/16/63] at ata0-master UDMA33
ad1: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata0-slave UDMA33
ad2: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata1-master UDMA33
ad3: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata1-slave UDMA33</programlisting>

	  <note>
	    <para>Ha a &os; nem látná az összes
	      lemezt, akkor ellenõrizzük a jumperek helyes
	      beállítását.  Napjainkban a
	      legtöbb IDE-meghajtón találunk egy
	      <quote>Cable Select</quote> jumpert is.  Ezzel
	      <emphasis>nem</emphasis> a mester/szolga módot
	      állítjuk be!  A megfelelõ jumper
	      beazonosításához olvassuk el a
	      meghajtóhoz tartozó
	      dokumentációt.</para>
	  </note>

	  <para>A következõ lépésben azt
	    vesszük nagyító alá, hogyan lehet
	    ezeket az állományrendszer
	    részévé tenni.  Ezzel kapcsolatban a
	    &man.vinum.8; (<xref linkend="vinum-vinum"/>) és a
	    &man.ccd.4; elolvasása ajánlatos.  Erre a
	    célra itt most a &man.ccd.4;
	    használatát választottuk.</para>

	</sect4>

	<sect4 xml:id="ccd-setup">
	  <title>A CCD beállítása</title>

	  <para>A &man.ccd.4; meghajtó
	    segítségével több ugyanolyan
	    lemezt tudunk összefûzni egyetlen logikai
	    állományrendszerré.  A &man.ccd.4;
	    használatához arra is
	    szükségünk van, hogy a &man.ccd.4;
	    támogatása jelen legyen a rendszermagban.  A
	    következõ sor tegyük bele a rendszermag
	    konfigurációs
	    állományába, fordítsuk
	    újra és telepítsük a
	    rendszermagot:</para>

	  <programlisting>device   ccd</programlisting>

	  <para>A &man.ccd.4; támogatása modulként
	    is betölthetõ.</para>

	  <para>A &man.ccd.4; beállításához
	    elõször a &man.bsdlabel.8; programmal meg fel kell
	    címkéznünk a lemezeket:</para>

	  <programlisting>bsdlabel -w ad1 auto
bsdlabel -w ad2 auto
bsdlabel -w ad3 auto</programlisting>

	  <para>Így létrejön egy-egy BSD
	    típusú címke a
	    <filename>ad1c</filename>, <filename>ad2c</filename>
	    és <filename>ad3c</filename>
	    eszközökre, amely így lefedi a lemez
	    egész területét.</para>

	  <para>Most pedig változtassuk meg a lemezcímke
	    típusát.  Ehhez használjuk ismét
	    a &man.bsdlabel.8; programot:</para>

	  <programlisting>bsdlabel -e ad1
bsdlabel -e ad2
bsdlabel -e ad3</programlisting>

	  <para>Az <envar>EDITOR</envar> környezeti
	    változóban megadott
	    szövegszerkesztõvel (ez általában a
	    &man.vi.1;) megnyílik minden egyes lemezhez a
	    jelenlegi lemezcímke.</para>

	  <para>Egy módosítatlan lemezcímke
	    valahogy így néz ki:</para>

	  <programlisting>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)</programlisting>

	  <para>A &man.ccd.4; számára hozzunk létre
	    egy új <literal>e</literal> partíciót.
	    Ezt lényegében a <literal>c</literal>
	    partíció lemásolásával
	    keletkezik, de nála az <option>fstype</option> (az
	    állományrendszer típusa) oszlopban
	    mindenképpen <userinput>4.2BSD</userinput>
	    szerepeljen!  A lemezcímke most már valahogy
	    így fog kinézni:</para>

	  <programlisting>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)
  e: 60074784        0    4.2BSD        0     0     0   # (Cyl.    0 - 59597)</programlisting>

	</sect4>

	<sect4 xml:id="ccd-buildingfs">
	  <title>Az állományrendszer
	    kiépítése</title>

	  <para>Most, miután felcímkéztük az
	    összes lemezünket, lássunk neki a
	    &man.ccd.4; kiépítésének.  Ezt a
	    &man.ccdconfig.8; meghívásával
	    és az alábbihoz hasonló
	    paraméterek átadásával
	    tehetjük meg:</para>

	  <programlisting>ccdconfig ccd0<co xml:id="co-ccd-dev"/> 32<co xml:id="co-ccd-interleave"/> 0<co xml:id="co-ccd-flags"/> /dev/ad1e<co xml:id="co-ccd-devs"/> /dev/ad2e /dev/ad3e</programlisting>

	  <para>A paraméterek rövid leírása
	    és használata:</para>

	  <calloutlist>
	    <callout arearefs="co-ccd-dev">
	      <para>Az elsõ paraméter a
		létrehozandó eszköz, ami jelen
		esetünkben a <filename>/dev/ccd0c</filename>.  A
		<filename>/dev/</filename> részt nem
		kötelezõ megadni.</para>
	    </callout>

	    <callout arearefs="co-ccd-interleave">
	      <para>A kihagyás nagysága az
	állományrendszerben.  A kihagyás
	határozza meg a lemezblokkban alkalmazott
	csíkozás (striping) vastagságát, ami
	általában 512 byte.  Ennek megfelelõen a
	32-es kihagyás 16&nbsp;384 byte-os csíkokat ad
	meg.</para>
	    </callout>

	    <callout arearefs="co-ccd-flags">
	      <para>A &man.ccdconfig.8;
	beállításai.  Ha engedélyezni
	akarjuk a lemezek tükrözését, akkor itt
	megadhatjuk.  Mivel ez a konfiguráció most nem
	nyújt tükrözést a &man.ccd.4;
	számára, ezért állítsuk
	nullára (0).</para>
	    </callout>

	    <callout arearefs="co-ccd-devs">
	      <para>A &man.ccdconfig.8; parancsnak
	utolsóként azokat az eszközöket
	kell felsorolni, amelyeket tömbbe akarunk fûzni.
	Minden eszközt teljes elérési úttal
	adjuk meg.</para>
	    </callout>
	  </calloutlist>

	  <para>A &man.ccdconfig.8; futtatása után a
	    &man.ccd.4; beállítódik.  Most
	    már állományrendszert is rakhatunk
	    rá.  A &man.newfs.8; man oldalról szedjük
	    össze a szükséges
	    paraméterezést, vagy egyszerûen csak
	    gépeljünk be ennyit:</para>

	  <programlisting>newfs /dev/ccd0c</programlisting>

	</sect4>

	<sect4 xml:id="ccd-auto">
	  <title>Az egész önmûködõvé
	    tétele</title>

	  <para>A &man.ccd.4; eszközt általában
	    minden egyes indítás után
	    használni akarjuk.  Ennek
	    eléréséhez elõször ezt be
	    kell állítanunk.  Az alábbi parancs
	    kiadásával írassuk be a jelenlegi
	    beállítasainkat tükrözõ
	    <filename>/etc/ccd.conf</filename>
	    állományt:</para>

	  <programlisting>ccdconfig -g &gt; /etc/ccd.conf</programlisting>

	  <para>Az újraindítás során az
	    <command>/etc/rc</command> parancs futtatja le a
	    <command>ccdconfig -C</command> parancsot, ha az
	    <filename>/etc/ccd.conf</filename> állomány
	    létezik.  Ez automatikusan beállítja a
	    &man.ccd.4; eszközöket, így ilyenkor tudjuk
	    csatlakoztatni is ezeket.</para>

	  <note>
	    <para>Ha egyfelhasználós módban
	      indítjuk a rendszert, mielõtt még a
	      &man.mount.8; paranccsal csatlakoztatni tudnánk a
	      &man.ccd.4; eszközt, a tömb
	      beállításához meg kell
	      hívnunk a következõ parancsot:</para>

	    <programlisting>ccdconfig -C</programlisting>
	  </note>

	  <para>Ha a rendszerindításkor automatikusan
	    csatlakoztatni akarjuk a &man.ccd.4; eszközt, akkor az
	    <filename>/etc/fstab</filename> állományba
	    helyezzünk el egy hozzá tartozó
	    bejegyzést:</para>

	  <programlisting>/dev/ccd0c              /media       ufs     rw      2       2</programlisting>

	</sect4>
      </sect3>

      <sect3 xml:id="vinum">
	<title>A Vinum kötetkezelõ</title>

	<indexterm>
	  <primary>RAID</primary>
	  <secondary>szoftveres</secondary>
	</indexterm>
	<indexterm>
	  <primary>RAID</primary>
	   <secondary>Vinum</secondary>
	</indexterm>

	<para>A Vinum kötetkezelõ egy blokkos
	  eszközmeghajtó, ami virtuális lemezes
	  meghajtókat valósít meg.
	  Elkülöníti a lemezes
	  hardvereszközöket a blokkos
	  eszközmeghajtók felületétõl
	  és a kettõ között úgy
	  képezi le az adatokat, hogy a hagyományos
	  lemezes tárolással szemben megnövekedett
	  rugalmasságot, teljesítményt és
	  megbízhatóságot kapunk.  A &man.vinum.8;
	  ismeri a RAID-0, RAID-1 és RAID-5 modelleket
	  egyaránt, melyeket önmagukban és
	  együttesen kombinálva is
	  használhatunk.</para>

	<para>A <xref linkend="vinum-vinum"/> bõvebben ismerteti a
	  &man.vinum.8; rendszerét.</para>

      </sect3>
    </sect2>

    <sect2 xml:id="raid-hard">
      <title>Hardveres RAID</title>

      <indexterm>
	<primary>RAID</primary>
	<secondary>hardveres</secondary>
      </indexterm>

      <para>A &os; rengeteg különbözõ
	típusú hardveres
	<acronym>RAID</acronym>-vezérlõt ismer.  Ezek az
	eszközök a &os; külön erre a célra
	szánt támogatása nélkül
	képesek vezérelni a
	<acronym>RAID</acronym>-alrendszert.</para>

      <para>A rajta levõ <acronym>BIOS</acronym>
	segítségével a kártya a legtöbb
	lemezmûveletet egyedül kezeli.  A
	következõkben egy Promise <acronym>IDE</acronym>
	<acronym>RAID</acronym> vezérlõt alkalmazó
	rendszert fogunk beállítani.  Miután
	telepítettük a kártyát és
	indítjuk a rendszert, bekéri a
	szükséges információkat.
	Kövessük az utasításokat és
	lépjünk be a kártya
	beállító képernyõjére.
	Itt tudjuk kombinálni az összes csatlakoztatott
	meghajtónkat.  Amikor ezzel a végeztünk, a
	lemezek egyetlen lemezként fognak a &os;
	számára viselkedni.  A többi
	<acronym>RAID</acronym>-szint is ehhez hasonlóan
	állítható be.</para>

    </sect2>

    <sect2>
      <title>Az ATA RAID-1 tömbök
	újraszervezése</title>

      <para>A &os; lehetõséget a tömbben levõ
	meghibásodott eszközök menet közben
	elvégezhetõ cseréjére.  Ehhez arra van
	szükségünk, hogy még
	újraindítás elõtt
	elcsípjük a hibát.</para>

      <para>Hiba esetén valami hasonlót fogunk
	látni a <filename>/var/log/messages</filename>
	állományban vagy a &man.dmesg.8;
	kimenetében:</para>

      <programlisting>ad6 on monster1 suffered a hard error.
ad6: READ command timeout tag=0 serv=0 - resetting
ad6: trying fallback to PIO mode
ata3: resetting devices .. done
ad6: hard error reading fsbn 1116119 of 0-7 (ad6 bn 1116119; cn 1107 tn 4 sn 11)\\
status=59 error=40
ar0: WARNING - mirror lost</programlisting>

      <para>További információkat az
	&man.atacontrol.8; programtól szerezhetünk:</para>

      <screen>&prompt.root; <userinput>atacontrol list</userinput>
ATA channel 0:
	Master:      no device present
	Slave:   acd0 &lt;HL-DT-ST CD-ROM GCR-8520B/1.00&gt; ATA/ATAPI rev 0

ATA channel 1:
	Master:      no device present
	Slave:       no device present

ATA channel 2:
	Master:  ad4 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

ATA channel 3:
	Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

&prompt.root; <userinput>atacontrol status ar0</userinput>
ar0: ATA RAID1 subdisks: ad4 ad6 status: DEGRADED</screen>

      <procedure>
	<step>
	  <para>A lemez biztonságos
	    eltávolításához
	    elõször válasszuk le (detach) a
	    meghibásodott lemezhez tartozó
	    csatornát:</para>

	  <screen>&prompt.root; <userinput>atacontrol detach ata3</userinput></screen>
	</step>

	<step>
	  <para>Cseréljük ki a lemezt.</para>
	</step>

	<step>
	  <para>Csatlakoztassuk újra (attach) az ATA
	    csatornát:</para>

	  <screen>&prompt.root; <userinput>atacontrol attach ata3</userinput>
Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
Slave:   no device present</screen>
	</step>

	<step>
	  <para>Tartalékként (spare) adjuk hozzá az
	    új lemezt a tömbhöz:</para>

	  <screen>&prompt.root; <userinput>atacontrol addspare ar0 ad6</userinput></screen>
	</step>

	<step>
	  <para>Szervezzük újra (rebuild) a
	    tömböt:</para>

	  <screen>&prompt.root; <userinput>atacontrol rebuild ar0</userinput></screen>
	</step>

	<step>
	  <para>A folyamat elõrehaladását a
	    következõ parancs
	    begépelésével tudjuk figyelni:</para>

	  <screen>&prompt.root; <userinput>dmesg | tail -10</userinput>
[a kimenet többi része]
ad6: removed from configuration
ad6: deleted from ar0 disk1
ad6: inserted into ar0 disk1 as spare

&prompt.root; <userinput>atacontrol status ar0</userinput>
ar0: ATA RAID1 subdisks: ad4 ad6 status: REBUILDING 0% completed</screen>
	</step>

	<step>
	  <para>Várjunk a mûvelet
	    befejezõdéséig.</para>
	</step>
      </procedure>

    </sect2>
  </sect1>

  <sect1 xml:id="usb-disks">
    <info><title>USB tárolóeszközök</title>
      <authorgroup>
	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Írta: </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>USB</primary>
      <secondary>lemezek</secondary>
    </indexterm>

    <para>Manapság már számos külsõ
      tárolóeszköz az USB (Universal Serial Bus)
      közvetítésével csatlakozik a
      számítógéphez: merevlemezek, pen
      drive-ok, CD-írók stb.  A &os; ezeket az
      eszközöket is ismeri.</para>

    <sect2>
      <title>Beállítás</title>

      <para>A USB tárolóeszközöket kezelõ
	meghajtó, az &man.umass.4; felelõs az USB
	alapú tárolóeszközök
	támogatásáért.  Ha a
	<filename>GENERIC</filename> rendszermagot használjuk,
	akkor semmit sem kell változtatnunk.  Ha saját
	rendszermagunk van, akkor gondoskodjunk róla, hogy a
	következõ sorokat beraktuk a rendszermag
	beállításait tartalmazó
	állományba:</para>

      <programlisting>device scbus
device da
device pass
device uhci
device ehci
device usb
device umass</programlisting>

      <para>Az &man.umass.4; meghajtó a SCSI alrendszeren
	keresztül éri el az USB
	tárolóeszközöket, tehát az USB
	eszközeinket a rendszer SCSI eszközként
	látja.  Az alaplapon található USB
	chipkészlet típusától
	függõen vagy csak a <literal>device uhci</literal>,
	vagy USB&nbsp;1.<replaceable>X</replaceable> esetén pedig a
	<literal>device ohci</literal> bejegyzésre lesz
	szükségünk.  De abból sem
	származik kárunk, ha mind a kettõt
	meghagyjuk.  Az USB&nbsp;2.0 szabványú
	vezérlõket a &man.ehci.4; meghajtó
	(<literal>device ehci</literal>) támogatja.  Ha
	módosítani kellett a konfigurációs
	állományt, akkor ne felejtsük el
	újrafordítani és telepíteni sem a
	rendszermagot.</para>

      <note>
	<para>Ha az USB eszközünk egy CD- vagy
	  DVD-író, akkor a következõ sorral a
	  SCSI CD-meghajtók meghajtóját, a
	  &man.cd.4; eszközt kell beépítenünk a
	  rendszermagba:</para>

	<programlisting>device cd</programlisting>

	<para>Mivel az író is SCSI eszközként
	  látszik, ezért az &man.atapicam.4; nem
	  szerepelhet a rendszermag beállításai
	  között.</para>
      </note>
    </sect2>

    <sect2>
      <title>A beállítások
	kipróbálása</title>

      <para>A beállításaink készen
	állnak a kipróbálásra:
	csatlakoztassuk a számítógéphez az
	USB eszközünket és a rendszerüzeneteket
	tároló pufferben (&man.dmesg.8;) hamarosan meg is
	jelenik a hozzá tartozó meghajtó:</para>

      <screen>umass0: USB Solid state disk, rev 1.10/1.00, addr 2
GEOM: create disk da0 dp=0xc2d74850
da0 at umass-sim0 bus 0 target 0 lun 0
da0: &lt;Generic Traveling Disk 1.11&gt; Removable Direct Access SCSI-2 device
da0: 1.000MB/s transfers
da0: 126MB (258048 512 byte sectors: 64H 32S/T 126C)</screen>

      <para>Természetesen a gyártóra,
	márkára, az eszköz
	leírójára (<filename>da0</filename>)
	és egyebekre vonatkozó részletek
	eltérhetnek.</para>

      <para>Mivel az USB eszköz SCSI eszközként
	látszik, ezért a <command>camcontrol</command>
	parancs használható a rendszerhez csatlakoztatott
	USB tárolóeszközök
	listázásához:</para>

      <screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;Generic Traveling Disk 1.11&gt;      at scbus0 target 0 lun 0 (da0,pass0)</screen>

      <para>Ha a meghajtón állományrendszer is
	található, akkor képesek vagyunk
	csatlakoztatni.  A <xref linkend="disks-adding"/>
	elolvasása segíthet az USB meghajtón
	partíciókat kialakítani és
	formázni, amennyiben szükséges.</para>

      <warning>
	<para>A rendszer biztonsága szempontjából
	  nem tekinthetõ megbízhatónak, ha olyan
	  felhasználók számára is
	  engedélyezzük tetszõleges meghajtók
	  csatlakoztatását (például a
	  <literal>vfs.usermount</literal>
	  engedelyézesével), amelyekben nem bízunk
	  meg.  A &os; által támogatott
	  állományrendszerek döntõ
	  többsége nem nyújt védelmet a
	  káros szándékkal telepített
	  eszközök ellen.</para>
      </warning>

      <para>Ha az eszközt normál
	felhasználókkal is
	csatlakoztathatóvá akarjuk tenni, akkor
	további lépések megtételére
	is szükségünk lesz.  Elõször is a
	felhasználóknak valahogy el kell tudniuk
	érniük az USB tárolóeszköz
	csatlakoztatásakor keletkezõ eszközöket.
	Ezt úgy tudjuk megoldani, ha az érintett
	felhasználókat felvesszük az
	<systemitem class="groupname">operator</systemitem> csoportba.  Ebben a &man.pw.8;
	lehet a segítségünkre.  Másodsorban
	amikor ezek az eszközök létrejönnek, az
	<systemitem class="groupname">operator</systemitem> csoportnak tudniuk kell ezeket
	olvasniuk és írniuk.  Ezt úgy tudjuk
	megvalósítani, ha felvesszük a
	következõ sorokat az
	<filename>/etc/devfs.rules</filename>
	állományba:</para>

      <programlisting>[localrules=5]
add path 'da*' mode 0660 group operator</programlisting>

      <note>
	<para>Ha viszont vannak SCSI lemezeink is rendszerben, akkor a
	  helyzet egy kicsit megváltozik.  Tehát
	  például a rendszerben már eleve vannak
	  <filename>da0</filename>, <filename>da1</filename>
	  és <filename>da2</filename> néven lemezek,
	  akkor a második sort ennek megfelelõen
	  változtassuk meg:</para>

	<programlisting>add path 'da[3-9]*' mode 0660 group operator</programlisting>

	<para>Ezzel kizárunk minden, korábban már
	  létezõ lemezt az <systemitem class="groupname">operator</systemitem>
	  csoportból.</para>
      </note>

      <para>Emellett még az <filename>/etc/rc.conf</filename>
	állományban engedélyeznünk kell a
	saját &man.devfs.rules.5;
	szabályrendszerünket is:</para>

      <programlisting>devfs_system_ruleset="usb_rules"</programlisting>

      <para>Ezt követõen be kell állítanunk a
	rendszermagban, hogy a hagyományos
	felhasználók képesek legyenek
	állományrendszereket csatlakoztatni.  Ezt a
	legkönnyebb úgy tudjuk megtenni, ha az
	<filename>/etc/sysctl.conf</filename> állományba
	felvesszük a következõ sort:</para>

      <programlisting>vfs.usermount=1</programlisting>

      <para>Azonban ne felejtsük el, hogy ez csak a rendszer
	következõ indításától
	él.  De a &man.sysctl.8; parancs
	használatával is beállíthatjuk ezt
	az értéket.</para>

      <para>Az utolsó lépésben hozzunk létre
	egy könyvtárat az állományrendszer
	csatlakoztatásához.  Ezt a könyvtárat
	az a felhasználó fogja birtokolni, aki az
	állományrendszert csatlakoztatnia akarja.  Ez
	például <systemitem class="username">root</systemitem>
	felhasználóként úgy tudjuk megtenni,
	ha a felhasználónak létrehozunk egy
	könyvtárat
	<filename>/mnt/felhasználó</filename>
	néven (ahol a
	<replaceable>felhasználó</replaceable> nevet
	cseréljük a tényleges
	felhasználó nevére, a
	<replaceable>csoport</replaceable> nevet pedig a
	felhasználóhoz tartozó elsõdleges
	csoport nevére):</para>

      <screen>&prompt.root; <userinput>mkdir /mnt/felhasználó</userinput>
&prompt.root; <userinput>chown felhasználó:csoport /mnt/felhasználó</userinput></screen>

      <para>Most tegyük fel, hogy csatlakoztatnuk egy USB pen
	drive-ot és ennek megfelelõen megjelenik a
	<filename>/dev/da0s1</filename> eszköz.  Mivel az ilyen
	eszközökre általában gyárilag FAT
	állományrendszert tesznek, ezért így
	kell ezeket csatlakoztatni a &man.mount.8; paranccsal:</para>

      <screen>&prompt.user; <userinput>mount -t msdosfs -o -m=644,-M=755 /dev/da0s1 /mnt/felhasználó</userinput></screen>

      <para>Ha leválasztjuk az eszközt (miután
	kiadtuk a &man.umount.8; parancsot), akkor a
	rendszerüzenetek között valami ilyesmit fogunk
	látni:</para>

      <screen>umass0: at uhub0 port 1 (addr 2) disconnected
(da0:umass-sim0:0:0:0): lost device
(da0:umass-sim0:0:0:0): removing device entry
GEOM: destroy disk da0 dp=0xc2d74850
umass0: detached</screen>

    </sect2>

    <sect2>
      <title>A témáról bõvebben</title>

      <para>A <link linkend="disks-adding">Lemezek
	hozzáadása</link> és az <link linkend="mount-unmount">Állományrendszerek
	  csatlakoztatása és
	  leválasztása</link> címû szakaszok
	elolvasása mellett a következõ man oldalakat is
	ajánljuk: &man.umass.4;, &man.camcontrol.8; és
	&man.usbconfig.8; &os;&nbsp;8.<replaceable>X</replaceable>
	esetében, vagy &man.usbdevs.8; a &os; korábbi
	változatainál.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="creating-cds">
    <info><title>Lézeres tárolóeszközök (CD-k)
      létrehozása és használata</title>
      <authorgroup>
	<author><personname><firstname>Mike</firstname><surname>Meyer</surname></personname><contrib>Írta: </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>CD-k</primary>
      <secondary>létrehozása</secondary>
    </indexterm>

    <sect2>
      <title>Bevezetés</title>

      <para>A CD-k számos lehetõségünkben
	eltérnek a hagyományos lemezektõl.  Kezdetben
	a felhasználók nem is voltak képesek
	írni ezeket.  Olyannak tervezték, hogy a fejek
	sávok közti mozgásából
	fakadó késleltetés nélkül
	lehessen folyamatosan olvasni.  A
	szállítása a maga idejében sokkal
	könnyebb volt minden vele egyforma méretû
	eszköznél.</para>

      <para>A CD-ken is találhatunk sávokat, azonban ez
	csak a folyamatosan olvasható adat egy szakaszát
	jelenti, nem pedig a lemez fizikai tulajdonságát.
	Ha &os;-n akarunk CD-t készíteni, akkor ehhez
	elõször össze kell állítanunk a CD
	egyes sávjaira kerülõ adatokat és
	ezután rögzíteni ezeket a sávokat a
	CD-n.</para>

      <indexterm><primary>ISO 9660</primary></indexterm>
      <indexterm>
	<primary>állományrendszerek</primary>
	<secondary>ISO 9660</secondary>
      </indexterm>

      <para>Az ISO 9660 állományrendszert úgy
	tervezték, hogy megbirkózzon ezekkel az
	eltérésekkel.  Sajnos ezzel együtt kõbe
	vésték az állományrendszerek
	akkoriban érvényes korlátozásait is.
	Szerencsére lehetõséget ad
	bõvítésre, ezáltal a helyesen
	megírt CD-k képesek úgy
	átlépni ezeket a határokat, hogy
	közben az általuk alkalmazott
	kiterjesztéseket nem ismerõ rendszerekkel is
	együtt tudnak mûködni.</para>

      <indexterm><primary><package>sysutils/cdrtools</package></primary></indexterm>

      <para>A <package>sysutils/cdrtools</package> port
	tartalmaz egy &man.mkisofs.8; nevû programot, amellyel
	létre tudunk hozni ISO 9660 típusú
	állományrendszert tartalmazó
	adatállományt.  Többféle
	kiterjesztést is ismer, amit majd a lentebb ismertett
	opciókkal érhetünk el.</para>

      <indexterm>
	<primary>CD-író</primary>
	<secondary>ATAPI</secondary>
      </indexterm>

      <para>A CD írásához használt
	konkrét segédeszköz attól függ,
	hogy ATAPI vagy esetleg másmilyen írónk
	van.  Az ATAPI CD-írók az alaprendszer
	részeként elérhetõ <command>burncd</command> programon
	keresztül használhatóak.  A SCSI és
	USB CD-írók esetén pedig a <package>sysutils/cdrtools</package> portban
	megtalálható <command>cdrecord</command> programot
	használhatjuk.  Az <link linkend="atapicam">ATAPI/CAM
	modul</link> segítségével a <command>cdrecord</command> és
	más SCSI-írókra készült
	programokat is tudunk használni ATAPI hardvereken.</para>

      <para>Ha a CD-író szoftverünket grafikus
	felhasználói felületen keresztül
	szeretnénk használni, akkor az
	<application>X-CD-Roast</application> vagy a
	<application>K3b</application> alkalmazásokat
	érdemes szemügyre vennünk.  Ezek az
	eszközök elérhetõek csomagként vagy
	a <package>sysutils/xcdroast</package>
	és <package>sysutils/k3b</package>
	portokból.  ATAPI hardver esetén az
	<application>X-CD-Roast</application> és a
	<application>K3b</application> alkalmazások
	használatához szükségünk lesz az
	<link linkend="atapicam">ATAPI/CAM modul</link>ra.</para>

    </sect2>

    <sect2 xml:id="mkisofs">
      <title>mkisofs</title>

      <para>A <package>sysutils/cdrtools</package> port
	részeként elérhetõ &man.mkisofs.8;
	program képes a &unix; típusú
	állományrendszer könyvtárszerkezete
	alapján egy ISO 9660 típusú
	állományrendszert tartalmazó image-et
	készíteni.  Legegyszerûbb módon
	így használhatjuk:</para>

      <screen>&prompt.root; <userinput>mkisofs -o image.iso /az/elérési/út</userinput></screen>

      <indexterm>
	<primary>állományrendszerek</primary>
	<secondary>ISO 9660</secondary>
      </indexterm>

      <para>Ezzel a paranccsal egy olyan
	<replaceable>image.iso</replaceable> nevû
	állományt hozunk létre, amely
	<replaceable>/az/elérési/út</replaceable>
	által megadott helyen található
	könyvtárszerkezetet mintázza ISO 9660
	állományrendszer formájában.  A
	folyamat során minden olyan állományt
	leképez szabványos ISO 9660
	állományrendszerbeli névre, amely megfelel
	a szabvány elvárásainak, és kihagy
	minden olyan állományt, amely nem jellemzõ az
	ISO állományrendszerekre.</para>

      <indexterm>
	<primary>állományrendszerek</primary>
	<secondary>HFS</secondary>
      </indexterm>

      <indexterm>
	<primary>állományrendszerek</primary>
	<secondary>Joliet</secondary>
      </indexterm>

      <para>Számos opció lehet
	segítségünkre az ilyenkor felbukkanó
	akadályok leküzdésében.  Ezek
	közül különösen fontos az
	<option>-R</option>, amely a &unix; rendszerek
	számára megszokott Rock Ridge
	kiterjesztéseket, valamint a <option>-J</option>, amely a
	Microsoft rendszerekben használt Joliet
	kiterjesztéseit, és végül a
	<option>-hfs</option>, amely a &macos; alatt létrehozott
	HFS állományrendszerek kiterjesztéseit
	engedélyezi.</para>

      <para>A kizárólag csak &os; rendszereken
	használt CD-k esetében a <option>-U</option>
	megadásával kapcsolhatjuk ki az
	állománynevek mindenféle
	korlátozását.  Az <option>-R</option>
	beállítás használatával olyan
	állományrendszer képét hozzuk
	létre, amely teljesen megegyezik a parancsban megadott
	könyvtárból induló fa
	tartalmával, habár több módon is
	sérti az ISO 9660 szabvány
	elõírásait.</para>

      <indexterm>
	<primary>CD-k</primary>
	<secondary>rendszerindításhoz</secondary>
      </indexterm>

      <para>Az utolsó általános jelleggel
	használható beállítás a
	<option>-b</option>.  Ezzel lehet megadni az <quote>El
	Torito</quote> szabványnak megfelelõ
	rendszerindító CD
	készítéséhez szükséges
	rendszerindító image
	elérését.  Ennél a
	beállításnál tehát meg kell
	adni a rendszerindításhoz használt lemez
	image-ét, amely a CD tartalmát magában
	foglaló könyvtárszerkezetben
	található valahol.  A &man.mkisofs.8;
	alapértelmezés szerint egy ún.
	<quote>floppy emulációs</quote> módban
	hozza létre az ISO image-et, ezért a
	rendszerindításhoz használatos lemez
	image-ének pontosan 1200, 1440 vagy 2880&nbsp;KB
	méretûnek kell lennie.  Egyes
	rendszerbetöltõk, mint amilyen például a
	&os; terjesztéséhez használt lemezeken
	található, nem használják ezt az
	emulációt.  Ilyen helyzetekben a
	<option>-no-emul-boot</option> kapcsolót kell megadni.
	Tehát ha a
	<filename>/tmp/sajátboot</filename>
	könyvtárban van egy indítható &os;
	rendszerünk, amelyben a
	<filename>/tmp/sajátboot/boot/cdboot</filename>
	a rendszerindító lemez image-e, akkor egy
	<filename>/tmp/indítható.iso</filename>
	nevû ISO 9660 formátumú
	állományrendszert tartalmazó image-et
	például így tudunk
	elkészíteni:</para>

      <screen>&prompt.root; <userinput>mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/indítható.iso /tmp/sajátboot</userinput></screen>

      <para>Miután ezt megtettük, és a
	rendszermagunkban benne van az <filename>md</filename>
	eszköz támogatása, csatlakoztathatjuk is az
	állományrendszert:</para>

      <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /tmp/indítható.iso -u 0</userinput>
&prompt.root; <userinput>mount -t cd9660 /dev/md0 /mnt</userinput></screen>

      <para>Ezután már össze tudjuk vetni az
	<filename>/mnt</filename> és
	<filename>/tmp/sajátboot</filename>
	könyvtárak egyezõségét.</para>

      <para>A &man.mkisofs.8; viselkedését több
	más opcióval tudjuk finomhangolni, mint
	például az ISO 9660 kiosztás
	módosítása vagy a Joliet és HFS
	lemezek készítése.  A &man.mkisofs.8; man
	oldalon mindezekrõl bõvebben olvashatunk.</para>

    </sect2>

    <sect2 xml:id="burncd">
      <title>burncd</title>

      <indexterm>
	<primary>CD-k</primary>
	<secondary>írása</secondary>
      </indexterm>

      <para>Ha ATAPI CD-írónk van, akkor a
	<command>burncd</command> paranccsal írhatjuk az ISO
	image-et a lemezre.  A <command>burncd</command> az alaprendszer
	része, és <filename>/usr/sbin/burncd</filename>
	néven érhetõ el.  A használata igen
	egyszerû, csupán pár paramétere
	van:</para>

      <screen>&prompt.root; <userinput>burncd -f eszköz data image.iso fixate</userinput></screen>

      <para>Ezzel a paranccsal rámásoljuk az
	<replaceable>image.iso</replaceable> állományt az
	<replaceable>eszköz</replaceable> eszközre.  Az
	alapértelmezett eszköz a
	<filename>/dev/acd0</filename>.  A &man.burncd.8; man
	oldalán találjuk meg az írási
	sebességgel, a CD írás utáni
	kiadásával és az audio lemezek
	írásával kapcsolatos
	beállításokat.</para>

    </sect2>

    <sect2 xml:id="cdrecord">
      <title>cdrecord</title>

      <para>Ha nincs ATAPI CD-írónk, akkor az
	íráshoz a <command>cdrecord</command> parancsot
	kell használnunk.  A <command>cdrecord</command> nem az
	alaprendszer része: vagy a <package>sysutils/cdrtools</package> portból vagy
	a neki megfelelõ csomagból kell
	telepítenünk.  Az alaprendszerben
	végbemenõ változások miatt a program
	bináris változatai hibázhatnak, aminek
	következtében csak
	<quote>poháralátéteket</quote> fogunk tudni
	gyártani.  Ezért a rendszerrel együtt
	érdemes frissíteni ezt a portot is.  Vagy ha a
	<link linkend="stable">-STABLE verziót
	használjuk</link>, akkor mindig érdemes a port
	elérhetõ legújabb verziójára
	frissíteni.</para>

      <para>Miközben a <command>cdrecord</command> számos
	paraméterrel rendelkezik, az alapvetõ
	használata mégis egyszerûbb a
	<command>burncd</command> parancsénál.  Egy ISO
	9660 formátumú image-et ugyanis a
	következõ módon tudunk felírni
	lemezre:</para>

      <screen>&prompt.root; <userinput>cdrecord dev=eszköz image.iso</userinput></screen>

      <para>A <command>cdrecord</command> használatának
	trükkös része a megfelelõ eszköz
	megtalálása, tehát a <option>dev</option>
	beállítás helyes megadása.  Ehhez
	használjuk a <command>cdrecord</command>
	<option>-scanbus</option> paraméterét, amely az
	alábbihoz hasonló eredményt fog
	produkálni:</para>

      <indexterm>
	<primary>CD-k</primary>
	<secondary>írása</secondary>
      </indexterm>

      <screen>&prompt.root; <userinput>cdrecord -scanbus</userinput>
Cdrecord-Clone 2.01 (i386-unknown-freebsd7.0) Copyright (C) 1995-2004 Jörg Schilling
Using libscg version 'schily-0.1'
scsibus0:
        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk
        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk
        0,2,0     2) *
        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk
        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM
        0,5,0     5) *
        0,6,0     6) *
        0,7,0     7) *
scsibus1:
        1,0,0   100) *
        1,1,0   101) *
        1,2,0   102) *
        1,3,0   103) *
        1,4,0   104) *
        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM
        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner
        1,7,0   107) *</screen>

      <para>Itt felsorolásra kerülnek a <option>dev</option>
	beállítás értékeként
	felhasználható eszközök.  Keressük
	meg köztük a CD írónkat és a
	<option>dev</option> értékének a
	három vesszõvel elválasztott számot
	adjuk meg.  Ebben az esetben a CD-író eszköz
	most az 1,5,0 lesz, tehát itt a helyes
	paraméterezés <option>dev=1,5,0</option>.  Ezt az
	értékét könnyebben is meg lehet adni.
	Ennek részleteirõl a &man.cdrecord.1; man
	oldalán olvashatunk.  Abban az esetben is érdemes
	fellapoznunk, ha az audio sávok
	írásáról, az írási
	sebesség korlátozásáról vagy
	más hasonló dolgokról akarunk
	olvasni.</para>

    </sect2>

    <sect2 xml:id="duplicating-audiocds">
      <title>Audio CD-k másolása</title>

      <para>Audio CD-t úgy tudunk másolni, ha
	elõször állományok sorozatába
	mentjük a lemez tartalmát, majd ezeket az
	állományokat egy üres CD-re írjuk.
	Ennek konkrét folyamata azonban némileg
	eltér az ATAPI- és SCSI-meghajtók
	használata során.</para>

      <procedure>
	<title>SCSI-meghajtók esetén</title>

	<step>
	  <para>A <command>cdda2wav</command> programmal mentsük le
	    a lemez tartalmát.</para>

	  <screen>&prompt.user; <userinput>cdda2wav -vall -D2,0 -B -Owav</userinput></screen>
	</step>

	<step>
	  <para>A <command>cdrecord</command> paranccsal írjuk
	    fel a <filename>.wav</filename> kiterjesztésû
	    állományokat.</para>

	  <screen>&prompt.user; <userinput>cdrecord -v dev=2,0 -dao -useinfo  *.wav</userinput></screen>

	  <para>Gondoskodjunk róla, hogy a
	    <replaceable>2,0</replaceable> értéket a <xref linkend="cdrecord"/>nak megfelelõen helyesen
	    állítottuk be.</para>
	</step>
      </procedure>

      <procedure>
	<title>ATAPI-meghajtók esetén</title>

	<note>
	  <para>Az <link linkend="atapicam">ATAPI/CAM modul</link>
	    segítségével a
	    <command>cdda2wav</command> parancs ATAPI
	    meghajtókkal is használható.  Ez a
	    megoldás általában kedvezõbb (a
	    hibák és bytesorrend ügyesebb
	    kezelése, stb.) a legtöbb
	    felhasználó számára, mint az itt
	    ismertetett.</para>
	</note>

	<step>
	  <para>Az ATAPI CD meghajtója az egyes sávokat
	  <filename>/dev/acddtnn
	    </filename> néven teszi
	    elérhetõvé, ahol a
	    <replaceable>d</replaceable> a meghajtó
	    sorszáma, a <replaceable>nn</replaceable> a
	    sáv két számjeggyel kiírt
	    sorszáma, amelyet szükség szerint
	    balról nullával egészítenek ki.
	    Így tehát az elsõ meghajtó
	    elsõ sávja a <filename>/dev/acd0t01</filename>,
	    a második a <filename>/dev/acd0t02</filename>, a
	    harmadik a <filename>/dev/acd0t03</filename> és
	    így tovább.</para>

	  <para>Ellenõrizzük, hogy ezek az eszközök
	    jelen vannak a <filename>/dev</filename>
	    könyvtárban.  Amennyiben
	    hiányoznának, kényszerítsük
	    ki a lemez újbóli
	    beolvasását:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/acd0 of=/dev/null count=1</userinput></screen>
	</step>

	<step>
	  <para>Szedjük le az egyes sávokat a &man.dd.1;
	    használatával.  A parancs kiadásakor
	    meg kell adnunk egy blokkméretet is:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/acd0t01 of=track1.cdr bs=2352</userinput>
&prompt.root; <userinput>dd if=/dev/acd0t02 of=track2.cdr bs=2352</userinput>
...
</screen>
	</step>

	<step>
	  <para>A <command>burncd</command> használatával
	    írjuk fel a lemezre az imént lementett
	    állományokat.  Meg kell adnunk, hogy ezek
	    audio állományok, és hogy a
	    <command>burncd</command> a munka befejeztével
	    zárja le (fixate) a lemezt.</para>

	  <screen>&prompt.root; <userinput>burncd -f /dev/acd0 audio track1.cdr track2.cdr ... fixate</userinput></screen>
	</step>
      </procedure>

    </sect2>

    <sect2 xml:id="imaging-cd">
      <title>Adat CD-k másolása</title>

      <para>Az adatot tartalmazó CD-ket le tudjuk másolni
	egy olyan image-be, amely funkcionálisan megegyezik egy
	&man.mkisofs.8; által létrehozott image-dzsel
	és amivel le tudunk másolni bármilyen adat
	CD-t.  Az itt megadott példa azt feltételezi, hogy
	a CD-meghajtónk neve <filename>acd0</filename>.
	Helyére a saját CD-meghajtónk nevét
	kell behelyettesíteni.</para>

      <screen>&prompt.root; <userinput>dd if=/dev/acd0 of=állomány.iso bs=2048</userinput></screen>

      <para>Most miután lementettük az image-et,
	írjuk fel CD-re a fentiek szerint.</para>

    </sect2>

    <sect2 xml:id="mounting-cd">
      <title>Adat CD-k használata</title>

      <para>Most, hogy már készítettünk egy
	szabványos adat CD-t, valószínûleg
	szeretnénk is valamilyen csatlakoztatni és
	elérni a rajta levõ adatokat.
	Alapértelmezés szerint a &man.mount.8; mindig azt
	feltételezi, hogy az állományrendszerek
	<literal>ufs</literal> típusúak.  Ezért ha
	valami ilyesmivel próbálkozunk:</para>

      <screen>&prompt.root; <userinput>mount /dev/cd0 /mnt</userinput></screen>

      <para>akkor egy <errorname>Incorrect super block</errorname>
	szövegû hibaüzenetet lesz a jutalmunk, és
	természetesen nem tudjuk csatlakoztatni a CD-t.  Mivel a
	CD nem <literal>UFS</literal> állományrendszert
	tartalmaz, ezért az ilyen jellegû
	kísérleteink mind kudarcba fognak fulladni.
	Valahogy fel kell világosítanunk a &man.mount.8;
	parancsot arról, hogy itt most egy
	<literal>ISO9660</literal> típusú
	állományrendszert akarunk csatlakoztatni,
	és akkor minden a helyére kerül.  Ezt
	úgy tudjuk megtenni, ha a &man.mount.8; parancsnak
	megadjuk a <option>-t cd9660</option> paramétert.
	Például, ha a <filename>/dev/acd0</filename>
	néven elérhetõ CD-meghajtóban
	levõ lemezt akarjuk a <filename>/mnt</filename>
	könyvtárba csatlakoztatni, akkor ezt kell
	begépelnünk:</para>

      <screen>&prompt.root; <userinput>mount -t cd9660 /dev/cd0 /mnt</userinput></screen>

      <para>Vegyük észre, hogy az eszköz neve (ez ebben
	a példában most <filename>/dev/cd0</filename>)
	lehet más is attól függõen, hogy milyen
	csatolófelületet használ a
	CD-meghajtónk.  Sõt, a <option>-t cd9660</option>
	valójában csak a &man.mount.cd9660.8; parancsot
	indítja el.  Ennek tükrében tehát az
	elõbbi példát így
	rövidíthetjük le:</para>

      <screen>&prompt.root; <userinput>mount_cd9660 /dev/cd0 /mnt</userinput></screen>

      <para>Ezen a módon bármilyen
	gyártmányú adat CD-t képesek vagyunk
	csatlakoztatni.  Egyes ISO 9660 kiterjesztéseket
	használó lemezek azonban esetleg furcsán
	mûködhetnek.  Például Joliet lemezek az
	összes állomány nevét
	kétbyte-os Unicode karakterben tárolják.  A
	&os; rendszermagja ugyan nem beszéli a Unicode-ot, de a
	&os; CD9660 meghajtója képes menetközben
	átkonvertálni a Unicode karaktereket.  Ha bizonyos
	nem angol karakterek kérdõjelekként
	jelennének meg, akkor a <option>-C</option>
	beállítás használatával
	még egy helyi kódlapot is meg kell adnunk.  Ezzel
	kapcsolatban bõvebb
	tájékoztatásért forduljunk a
	&man.mount.cd9660.8; man oldalhoz.</para>

      <note>
	<para>A <option>-C</option> beállítás
	  segítségével csak akkor lesz képes
	  a rendszermag elvégezni ezt az
	  átalakítást, ha elõtte
	  betöltjük a <filename>cd9660_iconv.ko</filename>
	  modult.  Ezt megtehetjük úgy, hogy ha
	  felvesszük a következõ sort a
	  <filename>loader.conf</filename>
	  állományba:</para>

	<programlisting>cd9660_iconv_load="YES"</programlisting>

	<para>Indítsuk újra a
	  számítógépünket, vagy
	  közvetlenül töltsük be a modult a
	  &man.kldload.8; használatával.</para>
      </note>

      <para>Estenként elõfordulhat, hogy kapunk egy
	<errorname>Device not configured</errorname> hibaüzenetet a
	CD-k csatlakoztatásakor.  Ez általában arra
	utal, hogy a CD-meghajtó nem érzékeli a
	berakott lemezt, vagy éppen a meghajtó nem
	látható a buszon.  A CD-meghajtók
	esetében pár másodpercig eltarthat,
	amíg felismeri a berakott lemezt, ilyenkor mindig
	legyünk türelemmel.</para>

      <para>Néha a SCSI CD-meghajtó nem
	látható, mert nem volt elég ideje
	válaszolni busz újraindítása
	elõtt.  Ha SCSI CD-meghajtónk van, akkor a
	következõ beállítást tegyük
	hozzá a rendszermagunk
	konfigurációjához és <link linkend="kernelconfig-building"> fordítsuk újra a
	rendszermagukat</link>.</para>

      <programlisting>options SCSI_DELAY=15000</programlisting>

      <para>Ezzel utasítjuk a SCSI buszunkat egy 15
	másodperces várakozásra a rendszer
	indítása során, és így ezzel
	elég esélyt adunk arra, hogy a CD-meghajtó
	válaszolni tudjon a busz
	újraindítása elõtt.</para>

    </sect2>

    <sect2 xml:id="rawdata-cd">
      <title>Nyers adat CD-k írása</title>

      <para>Írhatunk közvetlenül is
	állományokat a CD-re, ISO 9660
	formátumú állományrendszer
	használata nélkül.  Sokan így
	oldják meg a mentést.  Ezt sokkal gyorsabban
	lebonyolítható egy szabványos
	CD esetében:</para>

      <screen>&prompt.root; <userinput>burncd -f /dev/acd1 -s 12 data archive.tar.gz fixate</userinput></screen>

      <para>Az ezen a módon megírt CD-ket szintén
	nyers módon kell olvasnunk:</para>

      <screen>&prompt.root; <userinput>tar xzvf /dev/acd1</userinput></screen>

      <para>Az ilyen lemezeket nem tudjuk a normális CD-khez
	hasonlóan csatlakoztatni.  Sõt, az ilyen CD-ket csak
	&os; alatt tudjuk olvasni.  Ha csatlakoztathatóvá
	akarjuk tenni a lemezt, vagy más operációs
	rendszerek alól is szeretnénk olvasni, akkor erre
	a célra a fentebb bemutatott &man.mkisofs.8; parancsot
	kell használnunk.</para>

    </sect2>

    <sect2 xml:id="atapicam">
      <info><title>Az ATAPI/CAM meghajtó használata</title>
	<authorgroup>
	  <author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Írta: </contrib></author>
	</authorgroup>
      </info>

      

      <indexterm>
	<primary>CD-írók</primary>
	<secondary>ATAPI/CAM meghajtó</secondary>
      </indexterm>

      <para>Ez a meghajtó lehetõvé teszi az ATAPI
	eszközök (CD-ROM, CD-RW, DVD meghajtók stb...)
	számára, hogy a SCSI alrendszeren keresztül
	legyenek elérhetõek, így esetünkben is
	használhatóvá válnak olyan
	alkalmazások, mint például <package>sysutils/cdrdao</package> vagy a
	&man.cdrecord.1;.</para>

      <para>A meghajtó használatához a
	következõ sort kell a
	<filename>/boot/loader.conf</filename> állományba
	illeszteni:</para>

      <programlisting>atapicam_load="YES"</programlisting>

      <para>Indítsuk újra a
	számítógépet.</para>

      <note>
	<para>Amennyiben a rendszermagban az &man.atapicam.4; statikus
	  támogatását szeretnénk
	  használni, úgy a következõ sort kell a
	  rendszermag konfigurációs
	  állományába felvenni:</para>

	<programlisting>device atapicam</programlisting>

	<para>Továbbá a következõ sorokra lesz
	  még szükségünk:</para>

	<programlisting>device ata
device scbus
device cd
device pass</programlisting>

	<para>Ezeknek már eleve ott kell szerepelnie.
	  Ezután fordítsuk újra és
	  telepítsük a rendszermagot, majd indítsuk
	  újra a számítógépet.</para>
      </note>

      <para>A rendszer indulásakor az írónak ehhez
	hasonló módon kell megjelennie:</para>

      <screen>acd0: CD-RW &lt;MATSHITA CD-RW/DVD-ROM UJDA740&gt; at ata1-master PIO4
cd0 at ata1 bus 0 target 0 lun 0
cd0: &lt;MATSHITA CDRW/DVD UJDA740 1.00&gt; Removable CD-ROM SCSI-0 device
cd0: 16.000MB/s transfers
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed</screen>

      <para>A meghajtó most már elérhetõ a
	<filename>/dev/cd0</filename> eszközön keresztül,
	és például ennyi
	begépelésével csatlakoztatni tudunk
	róla egy CD-t a <filename>/mnt</filename>
	könyvtárba:</para>

      <screen>&prompt.root; <userinput>mount -t cd9660 /dev/cd0 /mnt</userinput></screen>

      <para><systemitem class="username">root</systemitem>
	felhasználóként a következõ
	paranccsal tudjuk lekérdezi az író SCSI
	címét:</para>

      <screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;MATSHITA CDRW/DVD UJDA740 1.00&gt;   at scbus1 target 0 lun 0 (pass0,cd0)</screen>

      <para>Eszerint a <literal>1,0,0</literal> lesz az eszköz SCSI
	címe, amelyet a &man.cdrecord.1; és más
	SCSI alkalmazások esetén adunk meg.</para>

      <para>Az ATAPI/CAM és SCSI rendszerek tekintetében
	olvassuk el az &man.atapicam.4; és &man.cam.4; man
	oldalakat.</para>

    </sect2>
  </sect1>

  <sect1 xml:id="creating-dvds">
    <info><title>Lézeres tárolóeszközök (DVD-k)
      létrehozása és használata</title>
      <authorgroup>
	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Írta: </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Andy</firstname><surname>Polyakov</surname></personname><contrib>Segítséget nyújtott benne:
	    </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>DVD</primary>
      <secondary>írása</secondary>
    </indexterm>

    <sect2>
      <title>Bevezetés</title>

      <para>A DVD a CD-hez képest a lézeres
	tárolóeszközök
	technológiájának újabb
	generációját képviseli.  A DVD
	bármelyik CD-nél több adatot képes
	tárolni és napjaink ez a videók
	kiadásának szabványa.</para>

      <para>Öt fizikailag írható formátummal
	határozhatjuk meg az írható DVD
	fogalmát:</para>

      <itemizedlist>
	<listitem>
	  <para>DVD-R: Ez volt az elsõ elérhetõ
	    írható DVD formátum.  A DVD-R
	    szabványát a <link xlink:href="http://www.dvdforum.com/forum.shtml"> DVD
	    Fórum</link> fektette le.  Ez a formátum csak
	    egyszer írható.</para>
	</listitem>

	<listitem>
	  <para>DVD-RW: Ez a DVD-R szabvány
	    újraírható változata.  A DVD-RW
	    körülbelül 1000 alkalommal
	    írható újra.</para>
	</listitem>

	<listitem>
	  <para>DVD-RAM: Ez is a DVD Fórum által
	    támogatott újraírható
	    formátum.  A DVD-RAM cserélhetõ
	    merevlemeznek látzsik.  Azonban ez
	    típusú adathordozó nem kompatibilis
	    legtöbb DVD-ROM hajtóval és DVD-Video
	    lejátszóval.  Csupán csak
	    néhány DVD-író ismeri a DVD-RAM
	    formátumot.  A DVD-RAM
	    használatáról a <xref linkend="creating-dvd-ram"/>ban találunk bõvebben
	    információkat.</para>
	</listitem>

	<listitem>
	  <para>DVD+RW: Ezt az újraírható
	    formátumot a <link xlink:href="http://www.dvdrw.com/">DVD+RW
	    szövetség</link> alkotta meg.  A DVD+RW lemezek
	    nagyjából 1000 alkalommal
	    írhatóak újra.</para>
	</listitem>

	<listitem>
	  <para>DVD+R: Ez a formátum a DVD+RW formátum
	    egyszer írható változata.</para>
	</listitem>
      </itemizedlist>

      <para>Az egyrétegû írható DVD-k
	összesen 4&nbsp;700&nbsp;000&nbsp;000&nbsp;byte-ot
	képesek rögzíteni, ami 4,38&nbsp;GB vagy
	4&nbsp;485&nbsp;MB (1&nbsp;kilobyte itt 1024 byte).</para>

      <note>
	<para>Meg kell különböztetnünk fizikai
	  tárolóeszközt és az
	  alkalmazást.  Például a DVD-Video
	  állományok olyan jellegû
	  elrendezését írja elõ, ami
	  bármelyik írható fizikai DVD
	  eszközön megjelenhet: DVD-R, DVD+R, DVD-RW stb.
	  Mielõtt kiválasztanánk az eszköz
	  típusát, biztosnak kell lennünk benne, hogy
	  az író és a DVD-Video
	  lejátszó (ez lehet egy önálló
	  lejátszó vagy egy
	  számítógép DVD-ROM
	  meghajtója) kompatibilis a szóbanforgó
	  lemezzel.</para>
      </note>

    </sect2>

    <sect2>
      <title>Beállítás</title>

      <para>A &man.growisofs.1; programot fogjuk a DVD
	rögzítésére használni.  Ez a
	program a <application>dvd+rw-tools</application>
	segédprogramok (<package>sysutils/dvd+rw-tools</package>)
	gyûjteményének része.  A
	<application>dvd+rw-tools</application> az összes DVD
	médium típusát ismeri.</para>

      <para>Ezek a segédprogramok a SCSI alrendszeren
	keresztül érik az eszközöket, ezért
	a használhatukhoz a rendszermagban
	szükségünk lesz az <link linkend="atapicam">ATAPI/CAM támogatásra</link>.
	Ha az írónk USB felületen csatlakozik, akkor
	mindez szükségtelen, és ehelyett a <xref linkend="usb-disks"/>t kell elolvasnunk az USB eszközök
	beállításához.</para>

      <para>Engedélyeznünk kell az ATAPI eszközök
	DMA hozzáférését is, amit a
	<filename>/boot/loader.conf</filename> állományban
	a következõ sor hozzáadásával
	tudunk megtenni:</para>

      <programlisting>hw.ata.atapi_dma="1"</programlisting>

      <para>A <application>dvd+rw-tools</application>
	használatának megkezdése elõtt a
	DVD-írónkkal kapcsolatban érdemes
	átolvasnunk a <link xlink:href="http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html">
	dvd+rw-tools hardverkompatibilitási jegyzeteit
	(angolul)</link>.</para>

      <note>
	<para>Ha grafikus felületet szeretnénk
	  használni, akkor érdemes egy pillanatást
	  vetnünk a <application>K3b</application>re (<package>sysutils/k3b</package>), amely egy
	  felhasználóbarát felületet ad a
	  &man.growisofs.1; és sok más
	  íróprogram felé.</para>
      </note>

    </sect2>

    <sect2>
      <title>Adat DVD-k írása</title>

      <para>A &man.growisofs.1; a <link linkend="mkisofs">mkisofs</link>
	parancs elõlapja, tehát az
	állományrendszer
	létrehozásához a &man.mkisofs.8; programot
	fogja meghívni és ezt írja fel a DVD-re.
	Ez azt jelenti, hogy az írási folyamat
	megkezdése elõtt nem kell semmilyen image-et
	létrehoznunk.</para>

      <para>A <filename>/az/elérési/út</filename>
	könyvtárból a következõ paranccsal
	tudjuk kiírni az adatokat DVD+R vagy DVD-R
	lemezre:</para>

      <screen>&prompt.root; <userinput>growisofs -dvd-compat -Z /dev/cd0 -J -R /az/elérési/út</userinput></screen>

      <para>A <option>-J -R</option> beállítások a
	&man.mkisofs.8; programhoz kerülnek át az
	állományrendszer létrehozásakor (itt
	most egy ISO 9660 állományrendszert hozunk
	létre, Joliet és Rock Ridge
	kiterjesztésekkel), használatának
	részleteit lásd &man.mkisofs.8;.</para>

      <para>A <option>-Z</option> beállítást a
	kezdõmenetek létrehozásakor
	használjuk: több menetben akarjuk írni a
	lemezt vagy sem.  A DVD eszközt, amely itt most a
	<replaceable>/dev/cd0</replaceable>, a saját
	konfigurációnknak megfelelõen kell megadni.
	A <option>-dvd-compat</option> paraméterrel
	lezárjuk a lemezt, így ezután
	további írás már nem
	lehetséges.  Ezért cserébe jobb
	kompatibilitást kapunk a DVD-ROM
	meghajtókkal.</para>

      <para>Elõre legyártott image-dzsel is dolgozhatunk,
	tehát például, ha az
	<replaceable>image.iso</replaceable> állományt
	akarjuk kiírni, akkor ezt kell lefuttatnunk:</para>

      <screen>&prompt.root; <userinput>growisofs -dvd-compat -Z /dev/cd0=image.iso</userinput></screen>

      <para>Az írási sebességet
	magától beállítja a lemez és
	meghajtó képességeinek megfelelõen.
	Az írási sebesség
	felülbírálásához
	használjuk a <option>-speed=</option> paramétert.
	A paraméterek lehetõségeirõl a
	&man.growisofs.1; man oldaláról tudhatunk meg
	többet.</para>

      <note>
	<para>4,38&nbsp;GB-nál több adat
	  írásához egy hibrid UDF/ISO-9660
	  típusú állományrendszert kell
	  létrehoznunk.  Ezt úgy tudjuk elérni, ha
	  &man.mkisofs.8; és a többi hasonló program
	  (például &man.growisofs.1;)
	  hívásakor még hozzátesszük az
	  <option>-udf -iso-level 3</option> paramétereket.
	  Ezekre csak lemezképek
	  készítésekor vagy az
	  állományok közvetlen lemezre
	  írásakor van szükségünk.  Az
	  így létrehozott lemezeket a &man.mount.udf.8;
	  segédprogram segítségével UDF
	  állományrendszerként tudjuk
	  csatlakoztatni.  Ezért csak olyan
	  operációs rendszereken
	  használható, amelyek ismerik ezt a
	  formátumot, ellenkezõ esetben csak hibás
	  állományokat fogunk látni a
	  lemezen.</para>

	<para>Példa ilyen lemezkép
	  létrehozására:</para>

	<screen>&prompt.root; <userinput>growisofs -dvd-compat -udf -iso-level 3 -Z /dev/cd0 -J -R /az/új/adat/helye</userinput></screen>

	<para>Ha a lemezkép már eleve nagyobb
	  méretû állományokat tartalmaz, a lemez
	  írásakor a &man.growisofs.1; programnak
	  már nem kell további paramétereket
	  átadnunk.</para>

	<para>Lehetõleg mindig a <package>sysutils/cdrtools</package> legfrissebb
	  verzióját használjuk (amely a
	  &man.mkisofs.8; programot is tartalmazza), mivel a
	  régebbi verziók nem támogatják a
	  nagyobb méretû állományokat.  Ha
	  problémák adódnak a programok
	  használata során, akkor
	  próbálkozzunk a fejlesztõi
	  változattal (<package>sysutils/cdrtools-devel</package>) és
	  olvassuk el a &man.mkisofs.8; man oldalát.</para>
      </note>
    </sect2>

    <sect2>
      <title>DVD-Video írása</title>

    <indexterm>
      <primary>DVD</primary>
      <secondary>DVD-Video</secondary>
    </indexterm>

      <para>A DVD-Video az állományok speciális
	szervezésére utal, amely az ISO 9660 és az
	mikró UDF (M-UDF) specifikációkon alapszik.
	A DVD-Video emellett egy adott adatszerkezeti hierarchiát
	is takar, ezért kell egy külön programmal,
	például a <package>multimedia/dvdauthor</package>
	segítségével
	összeállítani egy DVD-t.</para>

      <para>Ha már a birtokunkban van egy DVD-Video
	állományrendszer képe, akkor az eddigiek
	szerint egyszerûen csak írjuk fel egy lemezre, ahogy
	azt az elõzõ szakaszban is láthattuk.  Ha
	összeállítottuk a DVD anyagát
	és például a <filename>/a/videó/elérési/útja</filename>
	könyvtárba raktuk, akkor a következõ
	paranccsal írathatjuk ki a DVD-Video
	formátumú lemezt:</para>

      <screen>&prompt.root; <userinput>growisofs -Z /dev/cd0 -dvd-video /a/videó/elérési/útja</userinput></screen>

      <para>A <option>-dvd-video</option> paramétert kell
	átadni a &man.mkisofs.8; programnak, amelynek
	hatására létrehoz egy DVD-Video
	formátumú állományrendszert.
	Emellett a <option>-dvd-video</option>
	beállítás maga után vonja a
	&man.growisofs.1; <option>-dvd-compat</option>
	beállítását is.</para>

    </sect2>

    <sect2>
      <title>A DVD+RW használata</title>

    <indexterm>
      <primary>DVD</primary>
      <secondary>DVD+RW</secondary>
    </indexterm>

      <para>Eltérõen a CD-RW-tõl, egy érintetlen
	DVD+RW-t az elsõ használat elõtt meg kell
	formázni.  A &man.growisofs.1; program errõl az
	elsõ adandó alkalommal gondoskodik, és ez az
	<emphasis>ajánlott</emphasis>.  Azonban a DVD+RW
	formázására használhatjuk a
	<command>dvd+rw-format</command> parancsot is:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format /dev/cd0</userinput></screen>

      <para>Ezt a mûveletet csak egyszer kell elvégezni,
	hiszen ne feledjük, hogy csak a szûz DVD+RW lemezeket
	kell megformázni.  Ezután a DVD+RW-t a
	korábbi szakaszoknak megfelelõen tudjuk
	írni.</para>

      <para>Ha a DVD+RW-re új adatot akarunk írni (egy
	teljesen új állományrendszert, nem pedig
	adatokat hozzáfûzni), akkor nem kell
	üressé tenni a lemezt, egyszerûen csak
	elegendõ felülírni az elõzõeket (egy
	új kezdõmenet létrehozásával)
	valahogy így:</para>

      <screen>&prompt.root; <userinput>growisofs -Z /dev/cd0 -J -R /az/új/adat/helye</userinput></screen>

      <para>A DVD+RW formátum felajánlja annak
	lehetõségét is, hogy könnyedén
	hozzá lehessen fûzni adatokat az elõzõ
	íráshoz.  A mûvelet során az új
	menetet összefûzi a meglévõvel,
	tehát ez nem egy többmenetes írás,
	hanem a &man.growisofs.1; <emphasis>megnöveli</emphasis> a
	lemezen található ISO 9660
	állományrendszert.</para>

      <para>Például, ha egy korábban megírt
	DVD+RW lemezen levõ adatokhoz akarunk
	hozzáírni, akkor a következõ parancsot
	kell kiadnunk:</para>

      <screen>&prompt.root; <userinput>growisofs -M /dev/cd0 -J -R /az/új/adat/helye</userinput></screen>

      <para>A &man.mkisofs.8; beállításainál
	a kezõmenetnél megadottakat érdemes
	ismét megadni.</para>

      <note>
	<para>Ha kompatibilisek akarunk maradni a többi
	  DVD-meghajtóval, akkor adjuk meg
	  <option>-dvd-compat</option> paramétert.  Ez a DVD+RW
	  esetében annyit jelent, hogy nem tudunk további
	  adatokat hozzáfûzni.</para>
      </note>

      <para>Ha valamilyen okból mégis üressé
	szeretnénk tenni a lemez, akkor ír
	járhatunk el:</para>

      <screen>&prompt.root; <userinput>growisofs -Z /dev/cd0=/dev/zero</userinput></screen>

    </sect2>

    <sect2>
      <title>A DVD-RW használata</title>

    <indexterm>
      <primary>DVD</primary>
      <secondary>DVD-RW</secondary>
    </indexterm>

      <para>A DVD-RW két lemezformátumot fogad el: a
	inkrementális soros hozzáférést
	és a korlátozott felülírást.
	Alapértelmezés szerint a DVD-RW lemezek soros
	elérésûek.</para>

      <para>A még fel nem használt DVD-RW lemezek
	közvetlenül írhatóak külön
	formázás nélkül, habár a
	korábban már soros formátumban
	használt DVD-RW lemezeket egy új kezdõmenet
	létrehozása elõtt üressé kell
	tenni.</para>

      <para>Soros módban így kell letörölni egy
	DVD-RW lemezt:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format -blank=full /dev/cd0</userinput></screen>

      <note>
	<para>A teljes törlés (<option>-blank=full</option>)
	  egy 1x média esetén körülbelül
	  egy órát vesz igénybe.  A
	  <option>-blank</option> beállítással egy
	  gyorsított törlés zajlik le, amennyiben a
	  DVD-RW lemezt Disk-At-Once (DAO) módban írjuk.
	  A DVD-RW lemezeket az alábbi paranccsal tudjuk DAO
	  módban írni:</para>

	<screen>&prompt.root; <userinput>growisofs -use-the-force-luke=dao -Z /dev/cd0=image.iso</userinput></screen>

	<para>A <option>-use-the-force-luke=dao</option>
	  beállítást nem kötelezõ
	  megadni, mivel a &man.growisofs.1; igyekszik a lehetõ
	  leggyorsabban törölni a lemezt és megkezdeni
	  a DAO módú írást.</para>

	<para>A DVD-RW esetében valójában a
	  korlátozott felülírást lenne
	  érdemes használnunk, mivel ez a formátum
	  sokkal rugalmasabb az alapértelmezés szerint
	  felkínált inkrementális soros
	  elérésnél.</para>
      </note>

      <para>A soros DVD-RW lemezekre ugyanúgy tudunk adatokat
	rögzíteni, mint az összes többi
	formátum esetében:</para>

      <screen>&prompt.root; <userinput>growisofs -Z /dev/cd0 -J -R /az/adat/helye</userinput></screen>
      <para>Ha az elõzõ íráshoz akarunk
	még hozzáfûzni adatokat, akkor ehhez a
	&man.growisofs.1; <option>-M</option>
	beállítását kell használnunk.
	Azonban ha a DVD-RW lemezhet inkrementális soros
	módban adunk hozzá adatot, akkor ezzel egy
	új menetet hozunk létre a lemezen és
	így egy többmenetes lemezt kapunk.</para>

      <para>A korlátozott felülírású
	DVD-RW formátum használata esetén nem kell
	mindegyik kezdõmenet elõtt törölni a lemezt,
	egyszerûen csak felül kell írni a
	<option>-Z</option> beállítással,
	hasonlóan a DVD+RW esetéhez.  A DVD+RW
	<option>-M</option> beállításához
	hasonlóan lehetõségünk van a lemezen
	található ISO 9660 formátumú
	állományrendszer növelésére.
	Ennek az eredménye egy egymenetes DVD.</para>

      <para>A következõ paranccsal tudjuk a DVD-RW lemezt
	korlátozott felülírású
	módba tenni:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format /dev/cd0</userinput></screen>

      <para>Így tudunk visszaváltani a soros
	formátum használatára:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format -blank=full /dev/cd0</userinput></screen>

    </sect2>

    <sect2>
      <title>Több menet használata</title>

      <para>Nagyon kevés DVD-ROM meghajtó ismeri a
	többmenetes DVD-ket, és legtöbbször is
	csak általában az elsõ menetet
	olvassák.  A DVD+R, DVD-R és DVD-RW
	formátumok soros formátumban képesek
	több mentetet is befogadni, viszont a DVD+RW és
	DVD-RW korlátozott felülírású
	formátuma esetén nem létezik több
	menet.</para>

      <para>Az alábbi parancs egy újabb menetet ad
	hozzá egy megkezdett (le nem zárt) DVD+R, DVD-R
	vagy DVD-RW soros formátumú lemezhez:</para>

      <screen>&prompt.root; <userinput>growisofs -M /dev/cd0 -J -R /az/új/adat/helye</userinput></screen>

      <para>Ha ezt a parancsot egy korlátozott
	felülírású DVD+RW vagy DVD-RW lemez
	esetén adjuk ki, akkor az új adatokat úgy
	fûzi hozzá, hogy egy új menetet
	összefésüli a meglévõvel.  Ezzel
	egy egymenetes lemez keletkezik.  Ilyenkor így
	bõvítik a megkezdett lemezeket.</para>

      <note>
	<para>A menetek kezdése és befejezése
	  általában felhasznál valamennyi helyet a
	  lemezen.  Ezért úgy tudjuk optimalizálni
	  a lemez helykihasználtságát, hogy
	  kevés menetben sok adatot viszünk fel rá.
	  A DVD+R esetén 154, a DVD-R-nél
	  körülbelül 2000, és a dupla
	  rétegû DVD+R lemezeknél 127 menetet tudunk
	  létrehozni.</para>
      </note>

    </sect2>

    <sect2>
      <title>További olvasnivalók</title>

      <para>A DVD lemezrõl részletesebb
	információkat a <command>dvd+rw-mediainfo
	/dev/cd0</command> parancs
	kiadásával tudunk lekérdezni.</para>

      <para>A <application>dvd+rw-tools</application>
	használatáról a &man.growisofs.1; man
	oldalon találunk információt, valamint a
	<link xlink:href="http://fy.chalmers.se/~appro/linux/DVD+RW/">dvd+rw-tools
	honlapján (angolul)</link> és a <link xlink:href="http://lists.debian.org/cdwrite/">cdwrite levelezési
	lista</link> archívumaiban (angolul).</para>

      <note>
	<para>Futassuk <command>dvd+rw-mediainfo</command> parancsot
	  minden olyan esetben, amikor gondunk akad valamilyen lemez
	  írásával.  A kimenete nélkül
	  szinte lehetetlen segítenünk bárkinek
	  is.</para>
      </note>

    </sect2>

    <sect2 xml:id="creating-dvd-ram">
      <title>A DVD-RAM használata</title>

      <indexterm>
	<primary>DVD</primary>
	<secondary>DVD-RAM</secondary>
      </indexterm>

      <sect3>
	<title>Beállítás</title>

	<para>A DVD-RAM írók SCSI vagy ATAPI
	  csatolófelülettel rendelkeznek.  Az ATAPI
	  eszközök esetén engedélyezni kell a
	  DMA elérését, amit a
	  <filename>/boot/loader.conf</filename>
	  állományban az alábbi sor
	  hozzáadásával tudunk megtenni:</para>

	<programlisting>hw.ata.atapi_dma="1"</programlisting>

      </sect3>

      <sect3>
	<title>A lemez elõkészítése</title>

	<para>Ahogy arra már korábban utaltunk a fejezet
	  bevezetésében, a DVD-RAM úgy
	  látható, mint egy cserélhetõ
	  merevlemez.  A hagyományos merevlemezekhez
	  hasonlóan a DVD-RAM-ot is <quote>elõ kell
	  készíteni</quote> az elsõ
	  használatához.  Ebben a példában a
	  lemez teljes területét egy szabványos UFS2
	  állományrendszerrel töltjük
	  fel:</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/acd0 bs=2k count=1</userinput>
&prompt.root; <userinput>bsdlabel -Bw acd0</userinput>
&prompt.root; <userinput>newfs /dev/acd0</userinput></screen>

	<para>A DVD eszköz nevét, vagyis az
	  <filename>acd0</filename> eszközt a saját
	  rendszerünknek megfelelõen kell
	  módosítani.</para>

      </sect3>

      <sect3>
	<title>A lemez használata</title>

	<para>Miután az elõbbi mûveletet
	  elvégeztük a DVD-RAM lemezen, már tudjuk is
	  normális merevlemezként csatlakoztatni:</para>

	<screen>&prompt.root; <userinput>mount /dev/acd0 /mnt</userinput></screen>

	<para>Ezt követõen a DVD-RAM egyaránt
	  olvasható és írható.</para>

      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="floppies">
    <info><title>Hajlékonylemezek létrehozása és
      használata</title>
      <authorgroup>
	<author><personname><firstname>Julio</firstname><surname>Merino</surname></personname><contrib>Eredetileg készítette: </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Martin</firstname><surname>Karlsson</surname></personname><contrib>Átdolgozta: </contrib></author>
      </authorgroup>
    </info>

    

    <para>Néha hasznos lehet, ha az adatokat floppy lemezeken
      tároljuk, például olyankor, amikor más
      cserélhetõ tárolóeszköz már
      nem jöhet számításba, vagy amikor kis
      mennyiségû adatot kell átvinnünk az egyik
      számítógéprõl a
      másikra.</para>

    <para>Ebben a szakaszban bemutatjuk hogyan kell &os; alatt floppy
      lemezeket használni.  Elsõsorban a 3,5 colos DOS
      lemezek formázásával és
      használatával foglalkozik, de ezek fogalmak a
      többi hajlékonylemezes formátum esetében
      is hasonlóak.</para>

    <sect2>
      <title>A hajlékonylemezek formázása</title>

      <sect3>
	<title>Az eszköz</title>

	<para>A floppy lemezek a többi eszközhöz
	  hasonlóan a <filename>/dev</filename>
	  könyvtárban érhetõek el.  A nyers
	  floppy lemezek eléréséhez egyszerûen
	  csak használjuk a
	  <filename>/dev/fdN</filename>
	  hivatkozást.</para>

      </sect3>

      <sect3>
	<title>A formázás</title>

	<para>Használat elõtt a floppy lemezeket alacsony
	  szinten meg kell formázni.  Ezt általában
	  maga a gyártó végzi el, de a
	  formázás gyakran hasznos lehet a lemez
	  sértetlenségének
	  ellenõrzésére.  A legtöbb floppy lemez
	  hivatalos kapacitása 1440&nbsp;KB, de
	  használhatjuk nagyobb (és kisebb)
	  méretekben is.</para>

	<para>A floppy lemezek alacsony szintû
	  formázására az &man.fdformat.1; parancsot
	  használhatjuk.  Ez a segédprogram
	  paraméterként az eszköz nevét
	  várja.</para>

	<para>Figyeljünk a menetközben megjelenõ
	  hibaüzenetekre, mivel ezek segítik eldönteni,
	  hogy a lemez használható vagy sem.</para>

	<sect4>
	  <title>A hajlékonylemezek
	    formázása</title>

	  <para>A
	    <filename>/dev/fdN</filename>
	    eszközök segítségével tudunk
	    megformázni egy floppy lemezt.  Tegyünk be egy
	    3,5&nbsp;colos floppy lemezt a meghajtóba, majd adjuk
	    ki a következõ parancsot:</para>

	  <screen>&prompt.root; <userinput>/usr/sbin/fdformat -f 1440 /dev/fd0</userinput></screen>

	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>A lemez címkézése</title>

      <para>Miután alacsony szinten formáztuk a lemezt,
	tennünk kell rá egy lemezcímkét is.
	Ez a lemezcímke késõbb meg fog
	semmisülni, de a rendszernek szüksége van
	rá, hogy pontosan meg tudja állapítani a
	lemez méretét és
	geometriáját.</para>

      <para>Az új lemezcímke lefedi az egész
	lemezt, és tartalmazni fogja az összes
	információt a floppy
	geometriájáról.  A
	lemezcímkék geometriaértékeit az
	<filename>/etc/disktab</filename> állományban
	találjuk meg felsorolva.</para>

      <para>Most már futtathatjuk is a &man.bsdlabel.8;
	parancsot:</para>

      <screen>&prompt.root; <userinput>/sbin/bsdlabel -B -w /dev/fd0 fd1440</userinput></screen>

    </sect2>

    <sect2>
      <title>Az állományrendszer</title>

      <para>A hajlékonylemez most már készen
	áll a magas szintû formázásra.  Ennek
	során egy új állományrendszert
	teszünk rá, amelyet a &os; képes írni
	és olvasni.  Miután létrejött ez az
	új állományrendszer, a lemezcímke
	megsemmisül, így tehát ha újra meg
	akarjuk formázni a lemezt, akkor újra létre
	kell majd hoznunk a lemezcímkét.</para>

      <para>A floppy állományrendszere lehet UFS vagy FAT.
	A FAT általánosságban véve jobb
	választás a floppy lemezek
	számára.</para>

      <para>Az alábbi módon tudunk új
	állományrendszert tenni a floppyra:</para>

      <screen>&prompt.root; <userinput>/sbin/newfs_msdos /dev/fd0</userinput></screen>

      <para>A lemez most már készen áll a
	használatra.</para>

    </sect2>

    <sect2>
      <title>A hajlékonylemezek használata</title>

      <para>A floppy lemezt használatához a
	&man.mount.msdosfs.8; paranccsal kell csatlakoztatnunk.
	Ugyanerre a célra használhatjuk a
	Portgyûjteménybõl elérhetõ
	<package>emulators/mtools</package> portot
	is.</para>

    </sect2>
  </sect1>

  <sect1 xml:id="backups-tapebackups">
    <title>Szalagok létrehozása és
      használata</title>

    <indexterm><primary>szalagos
      adathordozó</primary></indexterm>

    <para>A legfontosabb szalagos adathordozók a 4&nbsp;mm-es,
      8&nbsp;mm-es, QIC, a minikazettás és a DLT.</para>

    <sect2 xml:id="backups-tapebackups-4mm">
      <title>4&nbsp;mm-es (Digitális adattároló,
	avagy DDS: Digital Data Storage)</title>

      <indexterm>
	<primary>szalagos adathordozó</primary>
	<secondary>(4&nbsp;mm-es) DDS-szalagok</secondary>
      </indexterm>
      <indexterm>
	<primary>szalagos adathordozó</primary>
	<secondary>QIC-szalagok</secondary>
      </indexterm>

      <para>A 4&nbsp;mm-es szalagok a QIC-szalagokat
	váltják fel a munkaállomások
	biztonsági mentésének
	eszközeként.  Ez a tendencia csak tovább
	növekedett, ahogy a Conner felvásárolta az
	Archive-ot, a QIC típusú meghajtók
	legnagyobb gyártóját, majd
	leállított a QIC-meghajtók
	gyártását.  A 4&nbsp;mm-es meghajtók
	mérete kicsi és csendben is dolgoznak, de a
	megbízhatóság terén nem
	tudhatják maguknak mindazt a sikert, amit a 8&nbsp;mm-es
	társaiknál könyvelhettünk el.  A
	kazetták is sokkal olcsóbbak és kisebbek
	(3&nbsp;x 2&nbsp;x 0,5&nbsp;col, ami 76&nbsp;x 51&nbsp;x
	12&nbsp;mm) a 8&nbsp;mm-es kiadásénál.  A
	4&nbsp;mm-es feje, hasonlóan a 8&nbsp;mm-eséhez,
	valamilyen okból szintén viszonylag rövid
	ideig bírja, és mind a kettõ spirális
	pásztázást használ.</para>

      <para>Ezeknél a meghajtóknál az
	adatátvitel nagyjából
	150&nbsp;KB/mp-nél kezdõdik és
	500&nbsp;KB/mp-nél végzõdik.  Az
	adattárolási képességük
	1,3&nbsp;GB-tól indul és 2,0&nbsp;GB-ig tart.  A
	hardveres tömörítés, ami a legtöbb
	ilyen típusú meghajtónál
	elérhetõ, közel megduplázza a
	kapacitást.  A többmeghajtós szalagos
	könyvtár egységek egyetlen szekrényben
	6 meghajtót képes befogadni, a szalagok
	automatikus cserélgetésével.  Az ilyen
	könyvtárak kapacitása a 240&nbsp;GB-ot is
	elérheti.</para>

      <para>A DDS-3 szabvány most már akár
	12&nbsp;GB (vagy tömörítve 24&nbsp;GB)
	kapacitást is elérhetõvé tesz.</para>

      <para>A 4&nbsp;mm-es meghajtók, hasonlóan a
	8&nbsp;mm-es meghajtókhoz, spirális
	pásztázást alkalmaznak.  A spirális
	pásztázás összes elõnye és
	hátránya ezért egyaránt él a
	4&nbsp;mm-es és 8&nbsp;mm-es meghajtók
	esetén.</para>

      <para>A szalagok 2&nbsp;000 menet vagy 100 teljes mentes
	után kopnak el.</para>

    </sect2>

    <sect2 xml:id="backups-tapebackups-8mm">
      <title>8&nbsp;mm-es (Exabyte)</title>

      <indexterm>
	<primary>szalagos adathordozó</primary>
	<secondary>(8&nbsp;mm-es) Exabyte szalagok</secondary>
      </indexterm>

      <para>A 8&nbsp;mm-es szalagok a legelterjedtebb szalagos
	SCSI-meghajtók.  A szalagok használatára ez
	a legjobb választás.  Szinte mindegyik rendszerben
	egy 2&nbsp;GB-os 8&nbsp;mm-es Exabyte szalagos meghajtót
	használnak.  A 8&nbsp;mm-es meghajtók
	megbízhatóak, kényelmesek és
	csendesek.  A kazetták olcsók és kicsik
	(4,8&nbsp;x 3,3&nbsp;x 0,6&nbsp;col, azaz 122&nbsp;x 84&nbsp;x
	15&nbsp;mm).  A 8&nbsp;mm-es szalagok feje viszonylag csak
	rövid ideig bírja a szalag nagy
	mértékû oda-vissza mozgása
	miatt.</para>

      <para>Az adatátvitel sebessége
	250&nbsp;KB/mp-tõl 500&nbsp;KB/mp-ig terjed, valamint a
	300&nbsp;MB-tól egészen 7&nbsp;GB-os
	méretig találkozhatunk velük.  A
	meghajtókban elérhetõ hardveres
	tömörítés képes közel
	megduplázni a kapacitást.  Ezek a meghajtók
	önálló egységként is
	beszerezhetõek vagy egy 6 egységbõl
	álló és 120 szalagos szalagos
	könyvtár részeként.  Ezek az
	egységek önállóan
	váltják a szalagokat.  Az ilyen
	könyvtárak kapacitása eléri a
	közel 840&nbsp;GB-ot.</para>

      <para>Az Exabyte <quote>Mammoth</quote> modellje
	szalagonként 12&nbsp;GB
	(tömörítéssel pedig 24&nbsp;GB) adatot
	képes tárolni, viszont a hagyományos
	szalagos meghajtóknál nagyjából
	kétszer többe kerül.</para>

      <para>Az adatok spirális pásztázással
	kerülnek a szalagra, és a fejek adott
	(nagyjából 6 fokos) szögben állnak a
	szalag felett.  A szalag a fejeket tartó orsó
	köré tekeredik, körülbelül 270
	fokban.  Ennek eredményképpen nagyobb
	adatsûrûség és szorosan zárt
	sávok jönnek létre, ahogy ebben a
	szögben a fej eljut a szalag egyik
	élérõl a másikra.</para>

    </sect2>

    <sect2 xml:id="backups-tapebackups-qic">
      <title>QIC</title>

      <indexterm>
	<primary>szalagos adathordozó</primary>
	<secondary>QIC-150</secondary>
      </indexterm>

      <para>A QIC-150 meghajtók és szalagok talán a
	legelterjedtebb szalagos egységek és
	adathordozók.  A QIC szalagos meghajtók a
	legolcsóbb <quote>komolynak tekinthetõ</quote>
	biztonsági mentésre alkalmas meghajtók.  Az
	olcsóság azonban megköveteli a maga
	árát.  A QIC-szalagok a 4 és 8&nbsp;mm-es
	szalagokkal szemben akár ötször is
	drágábbak lehetnek gigabyte-onként.  De ha
	megelégszünk csupán féltucat szalaggal
	is, akkor a QIC jó vásárnak tûnhet.  A
	QIC a <emphasis>leginkább</emphasis> elterjedtebb
	szalagos meghajtó.  Minden rendszerben biztonsan
	találunk valamilyen minõségben
	QIC-meghajtót.  A QIC fizikailag hasonló
	(és gyakran azonos) felépítésû
	szalagokat gyárt rengeteg különbözõ
	adatsûrûséggel.  Az ilyenkor keletkezõ
	súrlódások miatt a QIC-meghajtók
	egyáltalán nem nevezhetõek csendesnek.  Az
	ilyen típusú meghajtók az adatok
	rögzítése elõtt külön
	hangjelenség kíséretében keresik meg
	a megfelelõ pozíciót és tisztán
	hallható, ahogy olvasnak, írnak és
	keresnek.  A QIC-szalagok mérete 6&nbsp;x 4&nbsp;x
	0,7&nbsp;col (avagy 152&nbsp;x 102&nbsp;x 17&nbsp;mm).</para>

      <para>Az adatátviteli sebesség
	nagyjából 150&nbsp;KB/mp-tõl
	500&nbsp;KB/mp-ig terjedhet.  A kapacitás
	szalagonként 40&nbsp;MB és 15&nbsp;GB
	között változhat.  A legtöbb újabb
	QIC-meghajtó támogatja a hardveres
	tömörítést.  QIC-meghajtókat
	azonban egyre kevésbé találhatunk,
	helyüket szépen lassan mindenhol átveszik a
	DAT-meghajtók.</para>

      <para>A szalagokra sávokban rögzítik az
	adatokat.  Ezek a sávok szalag felületének
	hosszanti tengelyén futnak az egyik
	végétõl a másikig.  A sávok
	száma valamint a sávok vastagsága a
	szalagok kapacitásától függõen
	változnak.  Ha nem is összes legújabb, de a
	legtöbb meghajtó legalább olvasás
	szintjén kompatibilis a régebbi típusokkal
	(de gyakran írásban is).  A QIC híresen
	megbízható az adatbiztonság
	tekintetében (a mechanikája sokkal egyszerûbb
	és strapabíróbb a spirális
	pásztázással mûködõ
	meghajtókénál).</para>

      <para>A szalagokat 5000 mentés után érdemes
	lecserélni.</para>

    </sect2>

    <sect2 xml:id="backups-tapebackups-dlt">
      <title>DLT</title>

      <indexterm>
	<primary>szalagos adathordozó</primary>
	<secondary>DLT</secondary>
      </indexterm>

      <para>A DLT rendelkezik a legnagyobb adatátviteli
	sebességgel az itt összefoglalt mezõnyben.  A
	1/2&nbsp;colos (12,5&nbsp;mm-es) szalag egy egyorsós
	tokban foglal helyet (mérete 4&nbsp;x 4&nbsp;x
	1&nbsp;col, azaz 100&nbsp;x 100&nbsp;x 25&nbsp;mm).  A tok egyik
	oldalán végig egy csúszó kapu
	található.  A meghajtó ezt a kaput nyitja
	ki és ezen keresztül húzza be a szalagot.  A
	szalag elején található egy ovális
	lyuk, amibe a meghajtó <quote>bele tud
	akaszkodni</quote>.  A feszítõ orsó a
	szalagos meghajtóban foglal helyet.  Az összes
	többi szalag esetén (kivéve egyedül a 9
	sávos szalagokat) mind a segéd- és
	feszítõ orsók magában a
	kazettában találhatóak.</para>

      <para>Az adatátviteli sebessége
	megközelítõleg 1,5&nbsp;MB/mp, tehát
	háromszor nagyobb bármelyik 4&nbsp;mm-es,
	8&nbsp;mm-es vagy QIC-szalagos egységénél.
	Az adattároló képessége
	kazettánként 10&nbsp;GB-tól 20&nbsp;GB-ig
	terjedhet.  A meghajtók egyaránt
	elérhetõek többkazettás,
	cserélgetõs és többkazettás,
	többmeghajtós könyvtárakban is, melyek 5
	kazettától egészen 900 kazettáig,
	illetve 1 meghajtótól 20 meghajtóig
	képesek befogadni, így teljes
	tárterületük 50&nbsp;GB-tól 9&nbsp;TB-ig
	terjed.</para>

      <para>A DLT Type V formátum
	tömörítéssel közel 70&nbsp;GB-os
	kapacitást képes elérni.</para>

      <para>A szalagra az adatok a haladási iránnyal
	párhuzamosan kerülnek fel (akárcsak a
	QIC-szalagok esetében).  Egyszerre két
	sávot rögzít.  A
	író/olvasó fejek élettartama
	viszonylag nagy.  Ahogy a szalag megáll, a fej és
	a szalag között nincs szükség
	további relatív mozgásra.</para>

    </sect2>

    <sect2>
      <title xml:id="backups-tapebackups-ait">AIT</title>

      <indexterm>
	<primary>szalagos adathordozó</primary>
	<secondary>AIT</secondary>
      </indexterm>

      <para>Az AIT a Sony új formátuma, ami egészen
	50&nbsp;GB mennyiségû adatot képes
	tárolni (tömörítéssel) egyetlen
	szalagon.  A szalagokat memóriachipekkel
	látják el, melyek a szalag tartalmát
	indexelik.  Az indexek felhasználásával
	aztán a szalagos meghajtó villámgyorsan
	képes meghatározni a szalagon
	található állományok helyét,
	szemben az ilyenkor megszokott többperces mûvelettel.
	A <application>SAMS:Alexandria</application> és a
	hozzá hasonló szoftverek negyven vagy több
	AIT-szalagos könyvtárral is képesek egyszerre
	dolgozni, és közvetlenül a szalagok
	memóriájával veszik fel a kapcsolatot a
	tartalmuk megjelenítéséhez, a mentett
	állományok rendszerezéséhez, a
	helyes szalag megkereséséhez,
	betöltéséhez és
	visszatöltéséhez.</para>

      <para>Az ilyen könyvtárak a 20&nbsp;000
	dolláros (kb.  3,5&nbsp;millió forintos)
	árkategóriába tartoznak, ami miatt csak egy
	kicsivel csúsznak ki a hobbi
	kategóriából.</para>

    </sect2>

    <sect2>
      <title>Az új szalagok elsõ használata</title>

      <para>Amikor az elsõ alkalommal akarunk beolvasni vagy
	írni egy új, teljesen üres szalagot,
	hibára fogunk futni.  Egy ehhez hasonló
	konzolüzenet fog megjelenni:</para>

      <screen>sa0(ncr1:4:0): NOT READY asc:4,1
sa0(ncr1:4:0):  Logical unit is in process of becoming ready</screen>

      <para>A szalag nem tartalmaz azonosító blokkot
	(Identifier Block) a nulladik blokkban.  A QIC-525
	szabvány átvétele óta mindegyik QIC
	szalagos meghajtó létrehozza ezt az
	azonosító blokkot.  Tehát két
	megoldás létezik:</para>

      <itemizedlist>
	<listitem>
	  <para>Az <command>mt fsf 1</command> paranccsal
	    felírunk egy ilyen azonosító blokkot a
	    szalagra.</para>
	</listitem>

	<listitem>
	  <para>A meghajtó elõlapján
	    található gomb
	    segítségével dobassuk ki a
	    szalagot.</para>

	  <para>Rakjuk vissza a szalagot és hajtsunk végre
	    rajta egy <command>dump</command> parancsot.</para>

	  <para>A <command>dump</command> parancs erre egy
	    <errorname>DUMP: End of tape detected</errorname>
	    (<quote>szalag vége</quote>) hibaüzenetet ad,
	    majd a következõ jelenik meg a konzolon:
	    <errorname>HARDWARE FAILURE info:280
	    asc:80,96</errorname>.</para>

	  <para>Tekertessük vissza a szalagot az <command>mt
	    rewind</command> paranccsal.</para>

	  <para>A szalag következõ mûvelete most
	    már sikeres lesz.</para>
	</listitem>
      </itemizedlist>

    </sect2>
  </sect1>

  <sect1 xml:id="backups-floppybackups">
    <title>Biztonsági mentés
      hajlékonylemezekre</title>

    <sect2 xml:id="floppies-using">
      <title>Hajlékonylemezre is lehet biztonsági
	mentést készíteni?</title>

      <indexterm><primary>biztonsági
	floppyk</primary></indexterm>
      <indexterm><primary>floppy lemezek</primary></indexterm>

      <para>A floppy lemezek nem igazán felelnek meg
	biztonsági mentés
	készítésére, mivel:</para>

      <itemizedlist>
	<listitem>
	  <para>Nem megbízható adathordozók,
	    különösen hosszabb idõre.</para>
	</listitem>

	<listitem>
	  <para>Esetükben a mentés és
	    visszaállítás nagyon
	    lassú.</para>
	</listitem>

	<listitem>
	  <para>Kapacitásuk erõsen korlátozott (annak
	    már régen elmúlt az ideje, amikor
	    egész merevlemezeket tudtunk lementeni egy tucat
	    floppyra).</para>
	</listitem>
      </itemizedlist>

      <para>Habár ha máshogy nem tudunk biztonsági
	mentést készíteni, akkor a floppy
	lemezekkel még mindig jobban járunk, mint
	nélkülük.</para>

      <para>Ha már mindenképpen floppy lemezeket kell
	használnunk, akkor igyekezzünk minél jobb
	minõségûeket beszerezni.  Tehát az olyan
	floppyk, amik már évek óta kavarognak az
	irodában, erre a célra nem éppen
	bizonyulnak a legjobb választásnak.
	Ideális esetben egy megbízható
	gyártótól származó új
	floppykat használunk.</para>

    </sect2>

    <sect2 xml:id="floppies-creating">
      <title>Tehát akkor hogyan mentsük az adatokat
	hajlékonylemezre?</title>

      <para>Legegyszerûbban a &man.tar.1; <option>-M</option>
	(többkötetes) opciójával tudunk floppy
	lemezre menteni, aminek használatával több
	floppyra kiterjedõ mentéseket is
	készíthetünk.</para>

      <para>Az aktuális könyvtár és a benne
	levõ alkönyvtárak tartalmát
	(<systemitem class="username">root</systemitem>) felhasználóként
	a következõ paranccsal tudjuk lementeni:</para>

      <screen>&prompt.root; <userinput>tar Mcvf /dev/fd0 *</userinput></screen>

      <para>Amikor az elsõ floppy megtelik, a &man.tar.1;
	kérni fogja a következõ kötetet (volume)
	(mivel a &man.tar.1; adathordozótól független
	módon hivatkozik a kötetekre, tehát ebben a
	környezetben a kötet egy floppy lemezt jelent):</para>

      <screen>Prepare volume #2 for /dev/fd0 and hit return:</screen>

      <para>Az üzenet fordítása:</para>

      <screen>Készítse elõ a 2. kötetet a /dev/fd0 eszközön és nyomja le a
return billentyût</screen>

      <para>A folyamat egészen addig ismétlõdik (a
	kötetek számának
	növekedésével), amíg az összes
	állomány lementésre nem kerül.</para>

    </sect2>

    <sect2 xml:id="floppies-compress">
      <title>Lehet tömöríteni a
	mentéseket?</title>

      <indexterm><primary><command>tar</command></primary></indexterm>
      <indexterm><primary><command>gzip</command></primary></indexterm>
      <indexterm><primary>tömörítés</primary></indexterm>

      <para>Sajnos a &man.tar.1; többkötetes mentések
	esetén nem engedi a <option>-z</option>
	beállítás használatát.
	Természetesen ettõl függetlenül a
	&man.gzip.1; segítségével még be
	tudjuk tömöríteni az összes
	állományt, a &man.tar.1; paranccsal floppyra
	menteni ezeket, majd a &man.gunzip.1; paranccsal
	kitömöríteni.</para>

    </sect2>

    <sect2 xml:id="floppies-restoring">
      <title>Hogyan állítsuk vissza a biztonsági
	mentéseket?</title>

      <para>Az egész mentés
	visszaállításához adjuk ki a
	következõ parancsot:</para>

      <screen>&prompt.root; <userinput>tar Mxvf /dev/fd0</userinput></screen>

      <para>Két módon tudunk csak bizonyos
	állományokat visszaállítani.
	Elõször is, tegyük be a mentés elsõ
	lemezét és adjuk ki a következõ
	parancsot:</para>

      <screen>&prompt.root; <userinput>tar Mxvf /dev/fd0 állomány</userinput></screen>

      <para>A &man.tar.1; segédprogram ezután sorban
	kérni fogja a többi lemezt egészen addig,
	amíg meg nem találja a keresett
	állományt.</para>

      <para>Vagy ha pontosan tudjuk, hogy melyik lemezen
	található a keresett állomány, akkor
	az iménti parancs használatát azzal a
	lemezzel kezdjük.  Vigyázzunk, mert ha a lemezen
	található elsõ állomány az
	elõzõ lemezen kezdõdik, akkor a &man.tar.1;
	figyelmeztetni fog minket, hogy nem állítja vissza
	még akkor sem, ha erre nem is kértük!</para>

    </sect2>
  </sect1>

  <sect1 xml:id="backup-strategies">
    <info><title>Mentési stratégiák</title>
      <authorgroup>
	<author><personname><firstname>Lowell</firstname><surname>Gilbert</surname></personname><contrib>Eredetileg készítette: </contrib></author>
      </authorgroup>
    </info>

    

    <para>Egy biztonsági mentés kidolgozása
      során az elsõ követelmény gondoskodnunk az
      alábbi problémákról:</para>

    <itemizedlist>
      <listitem>
	<para>Lemezhiba</para>
      </listitem>
      <listitem>
	<para>Az állományok véletlen
	  törlése</para>
      </listitem>
      <listitem>
	<para>Az állományok véletlenszerû
	  károsodása</para>
      </listitem>
      <listitem>
	<para>Számítógépek teljes
	  megsemmisülése (például tûz
	  által), belértve a közelében
	  tárolt összes biztonsági
	  mentést</para>
      </listitem>
    </itemizedlist>

    <para>Tökéletesen megoldható, hogy egyes
      rendszerek a fentebb felsorolt problémák
      mindegyikét teljesen eltérõ technikával
      oldják meg.  A nagyon személyes rendszerektõl
      és a nagyon értéktelen adatoktól
      eltekintve szinte egyértelmûen kizárt, hogy
      egyetlen technika képes lefedni az összes
      problémát.</para>

    <para>Kelléktárunk néhány alapvetõ
      eszköze:</para>

    <itemizedlist>
      <listitem>
	<para>Az egész rendszer mentése, amit egy
	  megbízható helyre elzárt, tartós
	  adattárolóra készítünk.  Ez
	  tulajdonképpen védelmet biztosít a
	  fentebb megemlített összes probléma
	  esetében, de lassú és kényelmetlen
	  róla visszaállítani az adatokat.  A
	  közelben és/vagy neten is tarthatunk errõl
	  másolatokat, de még így is
	  kényelmetlen az állományok
	  visszaállítása, különösen
	  az egyszerû felhasználók
	  számára.</para>
      </listitem>

      <listitem>
	<para>Pillanatképek készítése az
	  állományrendszerrõl.  Ez
	  valójában csak olyan esetekben lehet a
	  segítségünkre, amikor
	  véletlenül töröltünk
	  állományokat, ám ilyenkor
	  <emphasis>határozottan</emphasis> jól jön,
	  mivel igen gyorsan és könnyen lehet vele
	  dolgozni.</para>
      </listitem>

      <listitem>
	<para>Az egész állományrendszer
	  és/vagy az összes lemez másolata
	  (például az &man.rsync.1; idõszakos
	  alkalmazása a komplett gépre).  Az
	  általában az egyedi igényekkel
	  bíró hálózatok esetében
	  eshet a kezünkre.  A lemezhiba ellen védelemben ez
	  a megoldás általában a
	  <acronym>RAID</acronym> alatt áll.  A
	  véletlenül törölt
	  állományok
	  visszaállításának
	  tekintetében az <acronym>UFS</acronym>
	  pillanatképeivel mérhetõ össze, de ez
	  leginkább a saját igényeinktõl
	  függ.</para>
      </listitem>

      <listitem>
	<para><acronym>RAID</acronym> alkalmazása.  A lemezek
	  meghibásodása esetén segíti
	  minimalizálni vagy elkerülni a kiesést,
	  ugyan gyakori lemezhibák árán (mivel
	  ilyenkor több lemezt használunk) de kisebb
	  sürgõsséggel.</para>
      </listitem>

      <listitem>
	<para>Az állományok ujjlenyomatának
	  ellenõrzése.  Az &man.mtree.8; segédprogram
	  nagyon hasznos tud lenni ebben az esetben.  Habár ez
	  nem egy mentési technika, mégis segít
	  megállapítani, hogy mikor kell nyugdíjba
	  küldenünk a biztonsági mentéseinket.
	  Ez különösen az aktív nem
	  használt mentésekre vonatkozik, ezeket bizonyos
	  idõ elteltével mindig érdemes
	  ellenõrizni.</para>
      </listitem>
    </itemizedlist>

    <para>Nagyon könnyû lenne további
	technikákat is felsorolni, melyek legtöbbje az
	iméntiek valamilyen kombinációja lenne.  A
	speciális igények általában
	speciális technikákat eredményeznek
	(például egy éles adatbázis
	biztonsági mentése általában az
	adott adatbáziskezelõ rendszer
	közremûködését is elvárja).
	Mindig fontos tudni, hogy milyen veszélyek ellen
	védekezünk és hogyan kezeljük le
	ezeket.</para>

  </sect1>

  <sect1 xml:id="backup-basics">
    <title>Alapvetõ tudnivalók a biztonsági
      mentésrõl</title>

    <para>A &man.dump.8;, &man.tar.1; és &man.cpio.1; a
      három legfontosabb biztonsági mentésekkel
      kapcsolatos program.</para>

    <sect2>
      <title>Mentés és
	helyreállítás</title>

      <indexterm>
	<primary>biztonsági mentést végzõ
	  szoftverek</primary>
	<secondary>mentés /
	  helyreállítás</secondary>
      </indexterm>
      <indexterm><primary><command>dump</command></primary></indexterm>
      <indexterm><primary><command>restore</command></primary></indexterm>

      <para>A &unix; típusú rendszerekben a
	biztonsági mentést hagyományosan a
	<command>dump</command> és <command>restore</command>
	programok végzik.  A meghajtókat lemezblokkok
	összeségeként kezelik, az
	állományrendszerek által létrehozott
	állományok, linkek és
	könyvtárak szintje alatt.  Eltérõen
	más, biztonsági mentést végzõ
	szoftverektõl, a <command>dump</command> az adott
	eszközön egy egész
	állományrendszert képes lementeni.  Nem
	képes csak az állományrendszer vagy egy
	több állományrendszerre kiterjedõ
	könyvtárszerkezet egy részét
	lementeni.  A <command>dump</command> nem
	állományokat és könyvtárakat
	ír a szalagra, hanem nyers adatblokkokat, amelyek
	állományokat és könyvtárakat
	formáznak.  A <command>restore</command> parancs az
	adatokat alapértelmezés szerint a <filename>/tmp</filename> könyvtárba
	tömöríti ki.  Ha nem lenne elegendõ
	helyünk a <filename>/tmp</filename>
	könyvtárban, akkor a <envar>TMPDIR</envar>
	környezeti változó
	átállításával ehelyett
	megadhatunk egy olyat, ahol már kellõ
	mennyiségû terület áll
	rendelkezésre a <command>restore</command>
	akadálytalan lefutásához.</para>

      <note>
	<para>Ha a <command>dump</command> parancsot a
	  gyökér könyvtárban adjuk ki, akkor nem
	  fogja lementeni a <filename>/home</filename> vagy
	  <filename>/usr</filename> vagy bármilyen más
	  könyvtárat, mivel ezek jellemzõ módon
	  más állományrendszerek
	  csatlakozási pontja vagy más
	  állományrendszerekre mutató szimbolikus
	  linkek.</para>
      </note>

      <para>A <command>dump</command> parancsnak vannak olyan
	rigolyái, amelyek még az AT&amp;T UNIX 6.
	verziójából (1975
	környékérõl) maradtak vissza.  Az
	alapértelmezett paraméterezése 9
	sávos szalagokat feltételezi (6250 bpi), nem pedig
	a napjainkban elterjedt nagy
	írássûrûsségû
	(egészen 62&nbsp;182 ftpi-s) adathordozókat.  Ezek
	az alapértelmezések természetesen
	paranccsorból felülbírálhatóak,
	és így a manapság alkalmazott szalagos
	meghajtók teljes kapacitása is
	kihasználható vele.</para>

      <indexterm><primary><filename>.rhosts</filename></primary></indexterm>

      <para>Emellett az <command>rdump</command> és
	<command>rrestore</command> programok
	segítségével hálózaton
	keresztül is le tudjuk menteni az adatainkat egy
	másik számítógépre
	csatlakoztatott szalagos egységre.  Mind a két
	program az &man.rcmd.3; és a &man.ruserok.3; parancsokat
	használja a távoli szalagos meghajtó
	eléréséhez.  Az <command>rdump</command>
	és <command>rrestore</command> paramétereinek a
	távoli számítógép
	használatához kell illeszkedniük.  Amikor egy
	&os; rendszerû számítógépet az
	<command>rdump</command> paranccsal egy Sun rendszerû,
	<systemitem>komodo</systemitem> nevû
	számítógépre mentünk, amelyhez
	egy Exabyte szalagos meghajtó csatlakozik, akkor ezt a
	írjuk be:</para>

      <screen>&prompt.root; <userinput>/sbin/rdump 0dsbfu 54000 13000 126 komodo:/dev/nsa8 /dev/da0a 2&gt;&amp;1</userinput></screen>

      <para>Figyelem: az <filename>.rhosts</filename>
	állományon keresztül
	hitelesítésnek megvannak a maga biztonsági
	kockázatai.  Ne felejtsük el felmérni ezt a
	saját környezetünkben sem.</para>

      <para>A <command>dump</command> és
	<command>restore</command> parancsokat az <command>ssh</command>
	használatával még
	biztonságosabbá tehetjük.</para>

      <example>
	<title>A <command>dump</command> használata az
	  <application>ssh</application> alkalmazással</title>

	<screen>&prompt.root; <userinput>/sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \
          célfelhasználó@cél.gép.hu dd of=/nagyállományok/dump-usr-l0.gz</userinput></screen>

      </example>

      <para>Vagy az <envar>RSH</envar> környezeti
	változó megfelelõ
	beállításával használhatjuk a
	<command>dump</command> beépített
	módszerét:</para>

      <example>
	<title>A <command>dump</command> használata az
	  <application>ssh</application> alkalmazással, az
	  <envar>RSH</envar> környezeti változó
	  beállításával</title>

	<screen>&prompt.root; <userinput>RSH=/usr/bin/ssh /sbin/dump -0uan -f célfelhasználó@cél.gép.hu:/dev/sa0 /usr</userinput></screen>

      </example>

    </sect2>

    <sect2>
      <title><command>tar</command></title>

      <indexterm>
	<primary>biztonsági mentést végzõ
	  szoftverek</primary>
	<secondary><command>tar</command></secondary>
      </indexterm>

      <para>A &man.tar.1; is az AT&amp;T UNIX 6.
	verziójáig nyúlik vissza (tehát
	nagyjából 1975-ig).  A <command>tar</command> az
	állományrendszerrel szoros
	együttmûködésben dolgozik,
	állományokat és könyvtárakat
	ír a szalagra.  A <command>tar</command> ugyan nem ismeri
	a &man.cpio.1; által felkínált összes
	lehetõséget, de nincs is szüksége olyan
	szokatlan paranccsoros összekapcsolásokra, mint a
	<command>cpio</command> parancsnak.</para>

      <indexterm><primary><command>tar</command></primary></indexterm>

      <para>A &os;&nbsp;5.3 vagy késõbbi
	változataiban a GNU <command>tar</command> és az
	alapértelmezés szerinti <command>bsdtar</command>
	egyaránt elérhetõ.  A GNU változat a
	<command>gtar</command> paranccsal hívható meg.
	Az <command>rdump</command> parancshoz hasonló
	felírásban képes kezelni a távoli
	eszközöket.  Tehát így tudjuk
	használni a <command>tar</command> parancsot a
	<systemitem>komodo</systemitem> nevû Sun
	számítógép Exabíte szalagos
	meghajtójának
	elérésére:</para>

      <screen>&prompt.root; <userinput>/usr/bin/gtar cf komodo:/dev/nsa8 . 2&gt;&amp;1</userinput></screen>

      <para>Ugyanez eltérhetõ a <command>bsdtar</command>
	használatával is, amikor az <command>rsh</command>
	programmal összekapcsolva küldünk át a
	távoli szalagos egységre.</para>

      <screen>&prompt.root; <userinput>tar cf - . | rsh hálózati-név dd of=szalagos-eszköz obs=20b</userinput></screen>

      <para>Ha a hálózaton keresztül mentés
	során fontos számunkra a biztonság, akkor
	az <command>rsh</command> parancs helyett az
	<command>ssh</command> parancsot használjuk.</para>

    </sect2>

    <sect2>
      <title><command>cpio</command></title>

      <indexterm>
	<primary>biztonsági mentést végzõ
	  szoftverek</primary>
	<secondary><command>cpio</command></secondary>
      </indexterm>

      <para>A &man.cpio.1; eredetileg a &unix; szalagos programjai
	és szalagos egységei között
	közvetített.  A <command>cpio</command> parancs
	(többek közt) képes a byte-ok
	sorrendjének felcserélésére,
	több különbözõ archívum
	formátuma szerint írni és adatokat
	közvetíteni más programok felé.  Ez
	utóbbi lehetõsége miatt a
	<command>cpio</command> kíválóan alkalmas a
	telepítõeszközök számára.  A
	<command>cpio</command> nem képes bejárni a
	könyvtárszerkezetet, és az
	állományok listáját a
	szabványos bemeneten keresztül kell megadni
	neki.</para>

      <indexterm><primary><command>cpio</command></primary></indexterm>

      <para>A <command>cpio</command> nem támogatja a
	biztonsági mentés
	átküldését a hálózaton.
	Programok összekapcsolásával és az
	<command>rsh</command> használatával tudunk
	adatokat küldeni távoli szalagos
	meghajtókra.</para>

      <screen>&prompt.root; <userinput>for f in könyvtár_lista; do</userinput>
<userinput>find $f &gt;&gt; mentési.lista</userinput>
<userinput>done</userinput>
&prompt.root; <userinput>cpio -v -o --format=newc &lt; backup.list | ssh felhasználó@gép "cat &gt; mentõeszköz"</userinput></screen>

      <para>Ahol a <replaceable>könyvtár_lista</replaceable>
	a menteni kívánt könyvtárak
	listája, a
	<replaceable>felhasználó</replaceable>@<replaceable>gép</replaceable>
	a mentést végzõ gép
	felhasználójának és
	hálózati nevének együttese, valamint a
	<replaceable>mentõeszköz</replaceable>, ahova a
	mentés kerül (például
	<filename>/dev/nsa0</filename>).</para>

    </sect2>

    <sect2>
      <title><command>pax</command></title>

      <indexterm>
	<primary>biztonsági mentést végzõ
	  szoftverek</primary>
	<secondary><command>pax</command></secondary>
      </indexterm>
      <indexterm><primary><command>pax</command></primary></indexterm>
      <indexterm><primary>POSIX</primary></indexterm>
      <indexterm><primary>IEEE</primary></indexterm>

      <para>A &man.pax.1; az IEEE/&posix; válasza a
	<command>tar</command> és <command>cpio</command>
	programokra.  Az évek során a
	<command>tar</command> és a <command>cpio</command>
	különbözõ változatai egy kissé
	inkompatibilissé váltak.  Ezért a
	szabványosításuk kiharcolása helyett
	inkább a &posix; létrehozott egy új
	archiváló segédprogramot.  A
	<command>pax</command> megpróbálja írni
	és olvasni a <command>cpio</command> és
	<command>tar</command> formátumok legtöbb
	változatát, valamint emellett további
	saját formátumokat is kezel.  A
	parancskészlete inkább a <command>cpio</command>
	parancséra emlékeztet, mintsem a
	<command>tar</command> parancséra.</para>

    </sect2>

    <sect2 xml:id="backups-programs-amanda">
      <title><application>Amanda</application></title>

      <indexterm>
	<primary>biztonsági mentést végzõ
	  szoftverek</primary>
	<secondary><application>Amanda</application></secondary>
      </indexterm>
      <indexterm><primary><application>Amanda</application></primary></indexterm>

      <para>Az <application>Amanda</application> (Advanced Maryland
	Network Disk Archiver) egy kliens-szerver alapú
	mentési rendszer, nem pedig egy önálló
	program.  Az <application>Amanda</application> szerver menti
	tetszõleges számú
	számítógép adatát egyetlen
	szalagra, melyek az <application>Amanda</application> klienst
	futtatják és hálózaton
	keresztül hozzá csatlakoznak.  A nagy
	mennyiségû és nagy kapacitású
	lemezekkel rendelkezõ rendszerekben közvetlenül a
	mentéshez szükséges idõ nem áll
	rendelkezésre a feladat
	elvégzéséhez.  Az
	<application>Amanda</application> viszont képes megoldani
	ezt a problémát.  Az
	<application>Amanda</application> képes egy
	<quote>saját lemez</quote> használatával
	egyszerre több állományrendszerrõl is
	biztonsági mentést készíteni.  Az
	<application>Amanda</application>
	<quote>archívumkészleteket</quote> hoz
	létre: az <application>Amanda</application>
	konfigurációs állományában
	megadott állományrendszerekrõl
	készít teljes mentést egy adott idõ
	alatt egy adott mennyiségû szalagra.  Az
	<quote>archívumkészlet</quote>
	ezenkívül még tartalmaz egy napi
	inkrementális (vagy különbözeti)
	mentést is minden egyes
	állományrendszerrõl.  A sérült
	állományrendszerek
	visszaállításához mindig a
	legújabb teljes biztonsági mentésre
	és a hozzá tartozó inkrementális
	mentésekre van szükségünk.</para>

      <para>A konfigurációs állomány
	segítségével precíz
	irányítást gyakorolhatunk a
	létrehozott mentések és az
	<application>Amanda</application> által keltett
	hálózati forgalom felett.  Az
	<application>Amanda</application> a fentiek közül
	bármelyik programmal képes az adatokat szalagra
	rögzíteni.  Az <application>Amanda</application>
	portként vagy csomagként is elérhetõ,
	alapértelmezés szerint nem települ.</para>

      </sect2>

    <sect2>
      <title>Ne csináljunk semmit</title>

      <para>A <quote>Ne csináljunk semmit</quote> nem egy
	újabb számítógépes program,
	hanem egy igen gyakran alkalmazott mentési
	stratégia.  Nem kell beruházni.  Nem kell
	semmilyen biztonsági mentési rendet követni.
	Egyszerûen semmit se csinálunk.  Ha
	véletlenül valami történne az
	adatainkkal, akkor csak mosolyogjunk és
	törõdjünk bele!</para>

      <para>Amennyiben az idõnk és adataink keveset vagy
	éppen semmit se érnek, akkor a <quote>Ne
	csináljunk semmit</quote> az elérhetõ legjobb
	biztonsági mentési megoldás
	számítógépünk
	számára.  De legyünk óvatosak, mert a
	&unix; egy igen hasznos eszköz, és fél
	éven belül könnyen úgy
	találhatjuk magunkat, hogy mégis csak vannak
	értékes adataink.</para>

      <para>A <quote>Ne csináljunk semmit</quote>
	tökéletesen megfelelõ mentési
	módszer a <filename>/usr/obj</filename> és a
	hozzá hasonló módon a
	számítógépen automatikusan
	generált könyvtárak és
	állományok esetében.  Ugyanilyen
	példa lehetne a kézikönyv HTML vagy
	&postscript; változata.  Ezek a formátumok ugyanis
	az SGML források alapján keletkeznek, így a
	HTML vagy &postscript; állományok mentése
	nem életbevágó.  Az SGML
	állományokat viszont már annál
	inkább mentsük!</para>

    </sect2>

    <sect2>
      <title>Melyik a legjobb?</title>

      <indexterm><primary>LISA</primary></indexterm>

      <para>&man.dump.8; <emphasis>Pont.</emphasis> Elizabeth D.  Zwicky
	komolyan letesztelte az itt felsorolt összes programot.  A
	&unix; állományrendszerek
	jellegzetességeinek és rajtuk az összes
	adatunk megõrzésének egyértelmûen
	a <command>dump</command> felel meg a legjobban.  Elizabeth a
	minden egyes program tesztjéhez olyan
	állományrendszereket hozott létre, amelyek
	rengeteg különféle szokatlan helyzetet
	tartalmaztak (valamint néhány nem annyira
	szokatlant).  Az érintett jellegzetességek: lyukas
	állományok, lyukas állományok
	és egy halom nulla, állományok
	érdekes karakterekkel a nevükben, olvashatatlan
	és írhatatlan állományok,
	eszközök, a mentés közben
	méretüket változtató
	állományok, a mentés közben
	keletkezõ és megszûnõ
	állományok és még sok minden
	más.  Az eredményeit a LISA V-ben jelentette meg
	1991 októberében.  Lásd <link xlink:href="http://www.coredumps.de/doc/dump/zwicky/testdump.doc.html"> A
	biztonsági mentéshez és
	archiváláshoz használt programok tesztje
	(angolul)</link>.</para>
    </sect2>

    <sect2>
      <title>Az adatok helyreállítása
	vészhelyzetben</title>

      <sect3>
	<title>A katasztrófa elõtt</title>

	<para>Csupán négy lépést kell
	  megtennünk az esetleges katasztrófák
	  bekövetkezésének esetére.</para>

	<indexterm><primary><command>bsdlabel</command></primary></indexterm>

	<para>Elõször is két példányban
	  nyomtassuk ki az egyes lemezek
	  lemezcímkéjét (például a
	  <command>bsdlabel da0 | lpr</command> paranccsal) valamint az
	  állományrendszerek
	  táblázatát (az
	  <filename>/etc/fstab</filename> állományt)
	  és az összes rendszerindításkor
	  megjelenõ üzenetet.</para>

	<indexterm><primary>helyreállító
	  lemezek</primary></indexterm>

	<para>A második lépésben
	  készítenünk kell egy
	  <quote>élõ</quote> rendszerrel rendelkezõ
	  CD-lemezt.  Ezen a lemezen megtalálható minden,
	  ami el tudunk indítani egy
	  helyreállításhoz elegendõ rendszert.
	  Ekkor a felhasználó futtatni tudja
	  például a &man.dump.8;, &man.restore.8;,
	  &man.fdisk.8;, &man.bsdlabel.8;, &man.newfs.8;, &man.mount.8;
	  és a többi segédprogramot.  Ez az image a
	  &os;/&arch.i386;&nbsp;&rel.current;-RELEASE kiadáshoz
	  az <uri xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/&arch.i386;/ISO-IMAGES/&rel.current;/&os;-&rel.current;-RELEASE-&arch.i386;-livefs.iso">ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/&arch.i386;/ISO-IMAGES/&rel.current;/&os;-&rel.current;-RELEASE-&arch.i386;-livefs.iso</uri>
	  címrõl tölthetõ le.</para>

	<para>A harmadik lépésben igyekezzünk
	  minél gyakrabban szalagra menteni.  Mindig gondoljuk
	  arra, hogy a legutolsó mentés óta
	  létrehozott változatásaink teljesen el
	  fognak veszni.  A mentéseket tartalmazó
	  szalagokat tegyük
	  írásvédetté.</para>

	<para>A negyedik lépésben ellenõrizzük a
	  a második lépésben
	  készített helyreállító
	  lemezünket és a biztonsági
	  mentéseket tartalmazó szalagokat.
	  Jegyezzük le az eljárást.  Ezeket a
	  jegyzeteket is rakjuk el rendszerindító
	  lemezzel, a kinyomtatott adatokkal és a
	  mentéseket tartalmazó szalagokkal együtt.
	  Ezek a jegyzetek megvédenek minket attól, hogy a
	  helyreállítás közbeni
	  kétségbeesésünkben nehogy
	  véletlenül tönkretegyük a
	  biztonsági mentéseinket.  (Hogy miként
	  is?  Például ha a <command>tar xvf
	    /dev/sa0</command> parancs helyett izgalmunkban a
	  <command>tar cvf /dev/sa0</command> parancsot
	  gépeljük be, akkor azzal felülírjuk a
	  biztonsági mentéseinket).</para>

	<para>A fokozott biztonság kedvéért minden
	  alkalommal készítsünk
	  rendszerindító lemezt és
	  legalább két mentést.  Az egyiket
	  valamilyen távoli helyen tároljuk.  Ez a
	  távoli hely NE ugyanannak az épületnek az
	  alagsora legyen!  Számos cég alaposan megtanulta
	  ezt a szabályt a Világkereskedelmi központ
	  tragédiája kapcsán.  Ez a távoli
	  hely számítógépeinkbõl
	  és merevlemezes meghajtóinkól is
	  fizikailag jól elkülöníthetõ,
	  jelentõs távolságban legyen.</para>
      </sect3>

      <sect3>
	<title>A katasztrófa után</title>

	<para>Az alapvetõ kérdés: a hardver
	  túlélte?  Ha rendszeresen
	  készítettünk biztonsági
	  mentéseket, akkor a szoftverek miatt
	  egyáltalán nem kell aggódnunk.</para>

	<para>Ha a hardver megsérült, akkor a
	  számítógép
	  használatának újból
	  megkezdése elõtt javasolt cserélni a
	  meghibásodott alkatrészeket.</para>

	<para>Ha a hardverrel minden rendben találtunk, akkor
	  helyzezzük be a helyreállításhoz
	  használatos <quote>élõ</quote> rendszert
	  tartalmazó lemezt a CD-meghajtóba, és
	  indítsuk el vele a
	  számítógépet.  Ezután
	  nemsokára a telepítési menü jelenik
	  meg.  Itt a megfelelõ ország után a
	  <guimenuitem>Fixit -- Repair mode with CDROM/DVD/floppy or
	    start a shell</guimenuitem>
	  (<quote>Helyreállítás CD/DVD/floppy
	  használatával, vagy parancssor
	  indítása</quote>), majd a <guimenuitem>CDROM/DVD
	    -- Use the live filesystem CDROM/DVD</guimenuitem> (<quote>A
	  CD/DVD-n található élõ rendszer
	  használata</quote>) menüpontokat válasszuk.
	  A <command>restore</command> és a többi
	  segédprogram a <filename>/mnt2/rescue</filename>
	  könyvtárban lesznek elérhetõek.</para>

	<para>Egyenként állítsuk vissza az egyes
	  állományrendszereket.</para>

	<indexterm><primary><command>mount</command></primary></indexterm>
	<indexterm><primary>gyökér
	  partíció</primary></indexterm>
	<indexterm><primary><command>bsdlabel</command></primary></indexterm>
	<indexterm><primary><command>newfs</command></primary></indexterm>

	<para>A <command>mount</command> paranccsal
	  próbáljuk meg csatlakoztatni az elsõ
	  lemezünk rendszerindító
	  partícióját (például
	  <command>mount /dev/da0a /mt</command>).  Ha a
	  lemezcímke megsérült, akkor
	  <command>bsdlabel</command> alkalmazásával
	  partícionáljuk újra a lemezt és
	  címkézzük meg a korábban
	  kinyomtatott címke adatainak megfelelõen.  A
	  <command>newfs</command> segítségével
	  újra hozzuk létre az
	  állományrendszereket.
	  Írható-olvasható módban
	  csatlakoztassuk újra a lemez
	  rendszerinító partícióját
	  (<command>mount -u -o rw /mnt</command>).  A biztonság
	  mentést végzõ program és a
	  biztonsági mentést tartalmazó szalagok
	  használatával állítsuk helyre az
	  állományrendszer tartalmát
	  (például <command>restore vrf
	    /dev/sa0</command>).  Válasszuk le az
	  állományrendszert (például
	  <command>umount /mnt</command>).  Mindegyik sérült
	  állományrendszerre ismételjük a
	  folyamatot.</para>

	<para>Ahogy mûködõképessé
	  vált a rendszerünk, mentsük az adatainkat
	  új szalagokra.  Akármi is okozta a rendszer
	  összeomlását vagy az adatvesztést,
	  ismét lecsaphat.  Ha most áldozunk erre
	  még egy órát, akkor azzal a
	  késõbbiekben számos
	  kellemetlenségtõl óvhatjuk meg
	  magunkat.</para>

      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="disks-virtual">
    <info><title>Hálózat, memória és
      állomány alapú
      állományrendszerek</title>
      <authorgroup>
	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Átdolgozta és feljavította:
	    </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>virtuális lemezek</primary></indexterm>
    <indexterm>
      <primary>lemezek</primary>
      <secondary>virtuális</secondary>
    </indexterm>

    <para>A számítógépünkben
      létezõ fizikai lemezek, például floppyk,
      CD-k, merevlemezek és egyebek mellett a lemezek egy
      másik formáját is képes
      megérteni a &os; &mdash; a <firstterm>virtuális
      lemezeket</firstterm>.</para>

    <indexterm><primary>NFS</primary></indexterm>
    <indexterm><primary>Coda</primary></indexterm>
    <indexterm>
      <primary>lemezek</primary>
      <secondary>memória</secondary>
    </indexterm>

    <para>A virtuális lemeznek tekinthetõek többek
      közt az olyan hálózati
      állományrendszerek, mint például a
      <link linkend="network-nfs"> Hálózati
      állományrendszer</link> (Network File System, NFS)
      és a Coda, valamint a memóriában és
      állományokban létrehozott
      állományrendszerek.</para>

    <para>Attól függõen, hogy a &os; melyik
      változatát használjuk, az
      állomány és memória alapú
      állományrendszerek
      létrehozásához, illetve
      használatához különbözõ
      segédprogramokra lesz szükségünk.</para>

    <note>
      <para>A &man.devfs.5; a felhasználó
	számára láthatatlan módon hozza
	létre az eszközök leíróit.</para>
    </note>

    <sect2 xml:id="disks-mdconfig">
      <title>Állomány alapú
	állományrendszerek</title>

      <indexterm>
	<primary>lemezek</primary>
	<secondary>állomány alapú</secondary>
      </indexterm>

      <para>&os; alatt az &man.mdconfig.8; segédprogram
	segítségével tudunk memórialemezeket
	(&man.md.4;) beállítani és
	engedélyezni.  Az &man.mdconfig.8;
	használatához be kell töltenünk az
	&man.md.4; modult vagy hozzá kell tennünk a
	rendszermagunk beállításait
	tartalmazó állományhoz:</para>

      <programlisting>device md</programlisting>

      <para>Az &man.mdconfig.8; parancs háromféle
	memória alapú virtuális lemezt ismer: a
	&man.malloc.9;, állományok vagy
	lapozóterület használatával
	létrehozott memórialemezeket.  Így lehet
	például csatlakoztatni a floppyk vagy CD-k
	állományokban tárolt image-eit.</para>

      <para>Egy meglevõ állományrendszer
	image-ének csatlakoztatása:</para>

      <example>
	<title>Egy meglevõ állományrendszer
	  image-ének csatlakoztatása az
	  <command>mdconfig</command> paranccsal</title>

	<screen>&prompt.root; <userinput>mdconfig -a -t vnode -f image -u 0</userinput>
&prompt.root; <userinput>mount /dev/md0 /mnt</userinput></screen>
      </example>

	<para>Új állományrendszer
	  létrehozása az &man.mdconfig.8;
	  használatával:</para>

      <example>
	<title>Új állomány alapú lemez
	  létrehozása az <command>mdconfig</command>
	  paranccsal</title>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=új-image bs=1k count=5k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mdconfig -a -t vnode -f új-image -u 0</userinput>
&prompt.root; <userinput>bsdlabel -w md0 auto</userinput>
&prompt.root; <userinput>newfs md0a</userinput>
/dev/md0a: 5.0MB (10224 sectors) block size 16384, fragment size 2048
        using 4 cylinder groups of 1.25MB, 80 blks, 192 inodes.
super-block backups (for fsck -b #) at:
 160, 2720, 5280, 7840
&prompt.root; <userinput>mount /dev/md0a /mnt</userinput>
&prompt.root; <userinput>df /mnt</userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0a       4710    4  4330     0%    /mnt</screen>
      </example>

      <para>Ha az <option>-u</option> beállítással
	nem adjuk meg az egység számát, akkor az
	&man.mdconfig.8; az &man.md.4; automatikus
	kiosztásán keresztül fog egy
	használatban még nem levõ eszközt
	kiválasztani.  Az így kiosztott egység neve
	az <filename>md4</filename> névhez hasonlóan
	jelenik meg a szabványos kimeneten.  Az &man.mdconfig.8;
	használatának részleteirõl olvassuk el
	a hozzá tartozó man oldalt.</para>

      <para>Az &man.mdconfig.8; egy nagyon sokoldalú
	segédeszköz, habár használatakor
	viszonylag sok parancsot kell kiadni egy állomány
	alapú állományrendszer
	létrehozásához.  A &os; azonban
	alapból tartalmaz még egy &man.mdmfs.8; nevû
	segédprogramot is, ami az &man.md.4; lemezeket az
	&man.mdconfig.8; segítségével
	állítja be, létrehoz rajtuk egy UFS
	típusú állományrendszert a
	&man.newfs.8; segítségével és
	csatlakoztatja a &man.mount.8; paranccsal.  Így
	például, ha az iménti
	állományrendszert akarjuk létrehozni
	és csatlakoztatni, akkor egyszerûen csak
	gépeljünk be ennyit:</para>

      <example>
	<title>Állomány alapú lemezek
	  beállítása és
	  csatlakoztatása az <command>mdmfs</command>
	  paranccsal</title>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=új-image bs=1k count=5k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mdmfs -F új-image -s 5m md0 /mnt</userinput>
&prompt.root; <userinput>df /mnt</userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0        4718    4  4338     0%    /mnt</screen>
      </example>

      <para>Ha az <option>md</option> paramétert az egység
	száma nélkül adjuk meg, akkor &man.mdmfs.8;
	az &man.md.4; automatikus kiosztására
	támaszkodva fog egy addig még nem használt
	eszközt kiválasztani.  A &man.mdmfs.8;
	használatának pontos részleteivel
	kapcsolatban lásd a hozzá tartozó man
	oldalt.</para>

    </sect2>

    <sect2 xml:id="disks-md-freebsd5">
      <title>Memória alapú
	állományrendszerek</title>

      <indexterm>
	<primary>lemezek</primary>
	<secondary>memória
	  állományrendszer</secondary>
      </indexterm>

      <para>A memória alapú
	állományrendszerek esetében
	általában a
	<quote>lapozóállomány alapú</quote>
	megközelítést alkalmazzák.  A
	lapozóállomány alapúság nem
	arra utal, hogy a memórialemezt alapból
	kilapozzák lemezre, hanem inkább arra, hogy a
	memórialemez olyan területen jön létre,
	amelyet szükség esetén lemezre lehet lapozni.
	Memória alapú lemezeket a (rendszermag
	szintû) &man.malloc.9; használatával is
	létre lehet hozni, de a malloc alapú
	memórialemezeknél, különösen a
	nagyon nagyok esetében, a rendszer könnyen
	össze tud omlani, ha kifut a rendelkezésére
	álló memóriából.</para>

      <example>
	<title>Új memória alapú lemez
	  létrehozása az <command>mdconfig</command>
	  paranccsal</title>

	<screen>&prompt.root; <userinput>mdconfig -a -t swap -s 5m -u 1</userinput>
&prompt.root; <userinput>newfs -U md1</userinput>
/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048
        using 4 cylinder groups of 1.27MB, 81 blks, 192 inodes.
        with soft updates
super-block backups (for fsck -b #) at:
 160, 2752, 5344, 7936
&prompt.root; <userinput>mount /dev/md1 /mnt</userinput>
&prompt.root; <userinput>df /mnt</userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4718    4  4338     0%    /mnt</screen>
      </example>

      <example>
	<title>Új memória alapú lemez
	  létrehozása az <command>mdmfs</command>
	  paranccsal</title>

	<screen>&prompt.root; <userinput>mdmfs -s 5m md2 /mnt</userinput>
&prompt.root; <userinput>df /mnt</userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md2        4846    2  4458     0%    /mnt</screen>
      </example>

    </sect2>

    <sect2>
      <title>Memórialemezek leválasztása a
	rendszerrõl</title>

      <indexterm>
	<primary>lemezek</primary>
	<secondary>egy memórialemez
	  leválasztása</secondary>
      </indexterm>

      <para>Amikor már nem akarunk tovább használni
	egy memória vagy állomány alapú
	állományrendszert, érdemes visszaadnunk az
	általuk felhasznált erõforrásokat a
	rendszernek.  Elsõként válasszuk le
	magát az állományrendszert, majd az
	&man.mdconfig.8; segítségével kapcsoljuk le
	a lemezt a rendszerrõl és szabadítsuk fel az
	általa felhasznált
	erõforrásokat.</para>

      <para>Például az <filename>/dev/md4</filename>
	eszközt így lehet lekapcsolni és
	felszabadítani:</para>

      <screen>&prompt.root; <userinput>mdconfig -d -u 4</userinput></screen>

      <para>A beállított &man.md.4; eszközökkel
	kapcsolatos többi információt az
	<command>mdconfig -l</command> paranccsal tudjuk
	lekérdezni.</para>

    </sect2>
  </sect1>

  <sect1 xml:id="snapshots">
    <info><title>Az állományrendszerek
      pillanatképei</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Írta: </contrib></author>
      </authorgroup>
    </info>

    

      <indexterm>
	<primary>állományrendszerek</primary>
	<secondary>pillanatképek</secondary>
      </indexterm>

      <para>A &os; a <link linkend="soft-updates">Soft Updates</link>
	mellett felkínál egy másik
	lehetõséget: az
	állományrendszerekrõl
	készíthetõ
	pillanatfelvételeket.</para>

      <para>Ezek a pillanatképek lehetõvé teszik a
	felhasználók számára, hogy adott
	állományrendszerekrõl képeket hozzanak
	létre és azt állományként
	kezeljék.  A pillanatképeket az adott
	állományrendszerben kell létrehozni,
	és a felhasználók
	állományrendszerenként
	húsznál többet nem hozhatnak
	belõlük létre.  Az aktív
	pillanatképek a szuperblokkban kerülnek
	rögzítésre, ezért az
	állományrendszerek leválasztása
	és újracsatlakoztatása esetén is
	megmaradnak, még újraindítás
	után is.  Amikor egy pillanatképre már
	nincs tovább szükségünk, egy szimpla
	&man.rm.1; paranccsal eltávolítható.  A
	pillanatképek tetszõleges sorrendben
	eltávolíthatóak, habár ilyenkor az
	összes általuk lefoglalt hely nem szabadul fel,
	mivel más pillanatképeknek még
	szüksége lehet bizonyos blokkjaira.</para>

      <para>Miután az &man.mksnap.ffs.8; paranccsal
	létrehoztunk egy pillanatképet tartalmazó
	állományt, beállítódik
	rá a módosíthatatlanságot
	jelentõ <option>snapshot</option>
	állományjelzõ.  Egyedül az
	&man.unlink.1; parancs képez ez alól
	kivételt, mivel segítségével a
	pillanatképek
	eltávolíthatóak.</para>

      <para>A pillanatképek a &man.mount.8; paranccsal
	hozhatóak létre.  A következõ
	módon tudjuk a <filename>/var</filename> egy
	pillanatképét elkészíteni a
	<filename>/var/snapshot/snap</filename>
	állományban:</para>

      <screen>&prompt.root; <userinput>mount -u -o snapshot /var/snapshot/snap /var</userinput></screen>

      <para>Vagy a &man.mksnap.ffs.8; meghívásával
	is készíthetünk
	pillanatképeket:</para>

      <screen>&prompt.root; <userinput>mksnap_ffs /var /var/snapshot/snap</userinput></screen>

      <para>Az állományrendszeren (például
	<filename>/var</filename>) a pillanatképeket
	tartalmazó állományokat a &man.find.1;
	paranccsal kereshetjük meg:</para>

      <screen>&prompt.root; <userinput>find /var -flags snapshot</userinput></screen>

      <para>Ahogy elkészítettünk egy
	pillanatképet, több mindenre is
	felhasználhatjuk:</para>

      <itemizedlist>
	<listitem>
	  <para>Egyes rendszergazdák a pillanatképeket
	    biztonsági mentésekhez
	    használják, mivel ezek gond nélkül
	    áttehetõek CD-re vagy szalagra.</para>
	</listitem>

	<listitem>
	  <para>Az állományrendszerek
	    sértetlenségét ellenõrzõ
	    program, az &man.fsck.8; is lefuttatható egy ilyen
	    pillanatképen.  Feltéve, hogy az
	    állományrendszer csatlakoztatásakor
	    tiszta volt, mindig egy tiszta (és
	    változásokat nem tartalmazó)
	    eredményt kell kapnunk.  Ennek megléte
	    elengedhetetlen a háttérben futtatható
	    &man.fsck.8; mûködéséhez.</para>
	</listitem>

	<listitem>
	  <para>Futassuk le a &man.dump.8; segédprogramot a
	    pillanatképen.  Az így létrehozott
	    mentés megegyezik az állományrendszer
	    adott pillanatban felvett állapotával.  Az
	    <option>-L</option> beállítás
	    megadásával maga a &man.dump.8; is
	    képes egyetlen parancsban pillanatfelvételt
	    készíteni, ebbõl létrehozni a
	    mentést, majd eltávolítani.</para>
	</listitem>

	<listitem>
	  <para>A pillanatképet képesek vagyunk a
	    &man.mount.8; paranccsal az állományrendszer
	    befagyasztott változataként
	    csatlakoztatni:</para>

	  <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /var/snapshot/snap -u 4</userinput>
&prompt.root; <userinput>mount -r /dev/md4 /mnt</userinput></screen>
	</listitem>
      </itemizedlist>

      <para>Így már a <filename>/mnt</filename>
	könyvtárba csatlakoztatva be tudjuk járni a
	befagyasztott <filename>/var</filename>
	állományrendszert.  Minden a
	pillanatfelvétel készítésének
	idõpontjának megfelelõ állapotban fog
	maradni.  Az egyetlen kivétel talán annyi, hogy
	korábbi pillanatképek nulla méretû
	állományként fognak megjelenni.  Mikor
	befejeztük a pillanatképek
	használatát, a &man.umount.8; paranccsal le tudjuk
	választani:</para>

      <screen>&prompt.root; <userinput>umount /mnt</userinput>
&prompt.root; <userinput>mdconfig -d -u 4</userinput></screen>

      <para>A <option>softupdates</option> és az
	állományrendszerek pillanatképeinek
	használatával, illetve mûszaki
	leírásukkal kapcsolatban látogassuk meg
	Marshall Kirk McKusick honlapját a <uri xlink:href="http://www.mckusick.com/">http://www.mckusick.com/</uri> címen
	(angolul).</para>

  </sect1>

  <sect1 xml:id="quotas">
    <title>Az állományrendszerek
      kvótái</title>

    <indexterm>
      <primary>nyilvántartás</primary>
      <secondary>lemezterület</secondary>
    </indexterm>
    <indexterm><primary>lemezkvóták</primary></indexterm>

    <para>A kvóták használata az
      operációs rendszerben egy olyan
      választható lehetõség, aminek
      segítségével
      állományrendszerenként korlátozni
      tudjuk az egyes felhasználók vagy csoporttagok
      által elhasznált lemezterület és/vagy
      állományok mennyiségét.  Ezt
      leggyakrabban olyan idõosztásos rendszerekben
      használják ki, ahol szükség lehet az
      egyes felhasználókra vagy csoportokra esõ
      erõforrások mennyiségének
      szabályozására.  Ezzel tudjuk
      megakadályozni, hogy a felhasználók vagy
      csoportok elfogyasszák az összes rendelkezésre
      álló lemezterületet.</para>

    <sect2>
      <title>A kvóták használatának
	beállítása</title>

      <para>Mielõtt nekilátnánk a
	kvóták használatának, meg kell
	gyõzõdnünk róla, hogy a rendszermagunkban
	megvan hozzá a szükséges
	támogatás.  A kvótákat a
	következõ sorral lehet engedélyezni a
	rendszermag beállításait tartalmazó
	állományban:</para>

      <programlisting>options QUOTA</programlisting>

      <para>A gyári <filename>GENERIC</filename> rendszermag ezt
	alapból nem engedélyezi, ezért ehhez
	mindenképpen be kell állítani, le kell
	fordítani és telepíteni egy kell
	saját rendszermagot.  A saját rendszermag
	létrehozásához kövessük a <xref linkend="kernelconfig"/> utasításait.</para>

      <para>Ha ezzel megvagyunk, akkor a következõ sorral
	bõvítsük ki az
	<filename>/etc/rc.conf</filename>
	állományt:</para>

      <programlisting>enable_quotas="YES"</programlisting>

      <indexterm>
	<primary>lemezkvóták</primary>
	<secondary>ellenõrzése</secondary>
      </indexterm>

      <para>A kvótákat kezelõ rendszer
	indításának finomabb
	szabályozására létezik még
	egy további beállítási
	lehetõség is.  A rendszer indítása
	során általában az egyes
	állományrendszerek kvótáját a
	&man.quotacheck.8; program ellenõrzi.  A &man.quotacheck.8;
	gondoskodik róla, hogy a kvótákat
	tároló adatbázis ténylegesen az
	állományrendszeren található
	adatokat tükrözi.  Ez egy nagyon
	idõigényes folyamat, ami rányomja
	bélyegét a rendszer elindulásához
	szükséges idõ mennyiségére is.
	Amennyiben szeretnénk megtakarítani ezt a
	lépést, tegyük bele az
	<filename>/etc/rc.conf</filename> állományba a
	direkt erre a célra kialakított
	beállítást:</para>

      <programlisting>check_quotas="NO"</programlisting>

      <para>Végezetül az állományrendszereken
	az <filename>/etc/fstab</filename> megfelelõ
	módosításával tudjuk
	egyenként engedélyezni a lemezkvóták
	használatát.  Itt lehet bekapcsolni az
	állományrendszerek felhasználókra
	vagy csoportokra, esetleg mind a kettõjükre
	vonatkozó kvótáikat.</para>

      <para>Ha felhasználói szintû
	kvótákat akarunk engedélyezni egy
	állományrendszeren, akkor az
	<filename>/etc/fstab</filename> állományban az
	állományrendszer beállításai
	közé vegyük fel a <option>userquota</option>
	opciót.  Például így:</para>

      <programlisting>/dev/da1s2g   /home    ufs rw,userquota 1 2</programlisting>

      <para>Ehhez hasonlóan tudjuk engedélyezni a
	<option>userquota</option> helyett a <option>groupquota</option>
	opció használatával a csoportszintû
	kvótákat is.  A felhasználói-
	és csoportszintû kvóták együttes
	engedélyezéséhez így kell
	átírni az állományrendszer
	bejegyzését:</para>

      <programlisting>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</programlisting>

      <para>Alapértelmezés szerint az
	állományrendszerekhez tartozó
	kvóták a gyökerükben
	található <filename>quota.user</filename> valamint
	<filename>quota.group</filename> állományokban
	tárolódnak.  Errõl részletesebben az
	&man.fstab.5; man oldalon olvashatunk.  Noha még az
	&man.fstab.5; man oldala szerint is megadható más
	elérési út a kvótákat
	tároló állományokhoz,
	semmiképpen sem javasoljuk ezt, mert úgy
	tûnik, hogy a kvótákat kezelõ
	különbözõ segédprogramok ezzel nem
	képesek rendesen megbirkózni.</para>

      <para>Most kell újraindítani a rendszerünket az
	új rendszermaggal.  Az <filename>/etc/rc</filename>
	magától le fogja futtatni a kezdeti
	kvótaállományok
	létrehozásához szükséges
	parancsokat az <filename>/etc/fstab</filename>
	állományban megadott
	állományrendszereken.  Ennek megfelelõen
	tehát nem nekünk kell kézzel
	létrehoznunk ezeket az állományokat.</para>

      <para>Hétköznapi esetben egyáltalán nem
	kell manuális futtatnunk a &man.quotacheck.8;,
	&man.quotaon.8; vagy &man.quotaoff.8; parancsokat.  Habár
	ha tisztában szeretnénk lenni a pontos
	mûködésükkel, akkor mindenképpen
	lapozzuk fel a hozzájuk tartozó man
	oldalakat.</para>

    </sect2>

    <sect2>
      <title>A kvóták
	beállítása</title>

      <indexterm>
	<primary>lemezkvóták</primary>
	<secondary>korlátok</secondary>
      </indexterm>

      <para>Ahogy sikerült beállítani a
	kvóták használatát, egybõl
	ellenõrizzük is a
	mûködõképességüket.  Ezt
	legegyszerûbben a következõ paranccsal
	tehetjük meg:</para>

      <screen>&prompt.root; <userinput>quota -v</userinput></screen>

      <para>Itt egy sorban összefoglalva láthatjuk a
	jelenlegi lemezhasználatot és az egyes
	állományrendszereken engedélyezett
	kvóták korlátait.</para>

      <para>Most már készenállunk arra, hogy az
	&man.edquota.8; paranccsal végre korlátokat is
	beállítsunk a kvótákhoz.</para>

      <para>Számos beállítás áll
	rendelkezésünkre a felhasználók vagy
	csoportok által lefoglalható lemezterület
	vagy a létrehozható állományok
	számának korlátozását
	illetõen.  A helyfoglalást szabályozhatjuk
	lemezterület alapján (blokk kvóta) vagy az
	állományok száma szerint
	(állományleíró kvóta),
	esetleg a kettõ kombinációjával.  A
	korlátok további két
	kategóriára bonthatóak: erõsre
	és gyengére.</para>

      <indexterm><primary>erõs korlát</primary></indexterm>

      <para>Az erõs korlátot (hard limit) nem lehet
	túllépni.  Ahogy a felhasználó
	eléri a számára kiszabott erõs
	korlátot, semmilyen további területet nem
	használhat fel a kérdéses
	állományrendszeren.  Például, ha a
	felhasználónak az állományrendszeren
	500 kilobyte-os erõs korlátot
	állítottunk be, és éppen 490
	kilobyte-nál tart, akkor a felhasználó
	innen már csak 10 kilobyte-nyi helyet foglalhat le.  11
	kilobyte lefoglalása már nem fog sikerrel
	járni.</para>

      <indexterm><primary>gyenge korlát</primary></indexterm>

      <para>Ezzel szemben a gyenge korlátok (soft limit) egy
	adott ideig átléphetõek.  Ezt az idõt
	türelmi idõnek (grace period) nevezik, ami
	alapértelmezés szerint egy hét.  Ha a
	felhasználó a gyenge korláton felül
	marad a türelmi idõ után is, akkor ezt a gyenge
	korlát erõssé válik és
	semmilyen további helyfoglalásra nem lesz
	lehetõsége.  Amikor a felhasználók
	újra a gyenge korlát alá kerül, a
	türelmi idõ is visszaáll a
	beállított értékére.</para>

      <para>A most következõ példában az
	&man.edquota.8; parancsot mutatjuk be.  Amikor meghívjuk
	az &man.edquota.8; parancsot, akkor elindul az
	<envar>EDITOR</envar> környezeti változónak
	megfelelõ szövegszerkesztõ, illetve ennek
	hiányában a <application>vi</application>,
	és lehetõségünk nyílik a
	kvóta korlátainak
	módosítására.</para>

      <screen>&prompt.root; <userinput>edquota -u teszt</userinput></screen>

      <programlisting>Quotas for user <replaceable>teszt</replaceable>:
/usr: kbytes in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)</programlisting>

      <para>Normális esetben minden kvótával
	rendelkezõ állományrendszerhez két
	sort kapunk.  Közülük az egyik sorban szerepelnek
	a blokkok korlátai, a másikban az
	állományleírók korlátai.  Ha
	valamelyiküket meg akarjuk változtatni, akkor
	egyszerûen csak át kell írnunk az adott
	korlát értékét.
	Például növeljük meg a
	felhasználók 50-es gyenge és 75-ös
	erõs blokk korlátját 500-as gyenge és
	600-as erõs korlátra.  Ehhez szerkesszük
	át a</para>

      <programlisting>/usr: kbytes in use: 65, limits (soft = 50, hard = 75)</programlisting>

      <para>sort erre:</para>

      <programlisting>/usr: kbytes in use: 65, limits (soft = 500, hard = 600)</programlisting>

      <para>Az új korlátok akkor fognak
	érvénybe lépni, miután
	kiléptünk a
	szövegszerkesztõbõl.</para>

      <para>Néha hasznos lehet a korlátokat adott
	felhasználói azonosítókhoz
	beállítani.  Ezt az &man.edquota.8; parancs
	<option>-p</option> paraméterével tudjuk
	elvégezni.  Elõször is állítsuk
	be egy felhasználónak a beállítani
	kívánt korlátokat, majd futtassuk le az
	<command>edquota -p teszt
	kezdõuid-véguid</command>
	parancsot.  Például ha a
	<systemitem class="username">teszt</systemitem> nevû
	felhasználónak állítottuk be a
	számunkra megfelelõ korlátokat, akkor a
	következõ paranccsal lehet a rá
	vonatkozó korlátokat kiterjeszteni a 10&nbsp;000
	és 19&nbsp;999 közötti
	azonosítójú
	felhasználókra:</para>

      <screen>&prompt.root; <userinput>edquota -p teszt 10000-19999</userinput></screen>

      <para>Errõl bõvebben az &man.edquota.8; man
	oldalán kaphatunk
	felvilágosítást.</para>

    </sect2>

    <sect2>
      <title>A kvóták korlátainak és a
	lemezhasználat ellenõrzése</title>

      <indexterm>
	<primary>lemezkvóták</primary>
	<secondary>ellenõrzése</secondary>
      </indexterm>

      <para>A kvóták korlátait és a lemez
	jelenlegi kihasználtságát a &man.quota.1;
	vagy &man.repquota.8; parancsokkal is ellenõrizhetjük.
	A &man.quota.1; parancs segítségével
	ellenõrizhetõ az egyes felhasználók vagy
	csoportok kvótája és
	lemezhasználata.  A felhasználók csak a
	saját adataikhoz férhetnek hozzá, illetve
	mindazon csoportokéhoz, aminek tagjai.  Egyedül a
	rendszeradminisztrátor képes látni az
	összes felhasználó és csoport
	kvótáját.  A &man.repquota.8; paranccsal
	kérdezhetõ le az összes kvóta és
	lemezhasználat rövid kimutatása minden olyan
	állományrendszeren, ahol azok
	engedélyezettek.</para>

      <para>A következõ kimenet a <command>quota -v</command>
	parancstól származik, ahol a
	felhasználónak két
	állományrendszeren is vannak
	kvótái:</para>

      <programlisting>Disk quotas for user <replaceable>teszt</replaceable> (uid 1002):
     Filesystem  usage    quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</programlisting>

      <indexterm><primary>türelmi idõ</primary></indexterm>

      <para>A fenti példában látható, hogy a
	felhasználó a <filename>/usr</filename>
	állományrendszeren pillanatnyilag 15 kilobyte-tal
	van az 50&nbsp;kilobyte-os gyenge korlátja felett
	és 5 napja van hátra a türelmi
	idõbõl.  Vegyük észre a szám
	mellett levõ csillagot (<literal>*</literal>), amivel a
	rendszer jelzi, hogy a felhasználó
	túllépte a korlátját.</para>

      <para>A &man.quota.1; parancs kimenetében
	általában nem jelennek meg azok az
	állományrendszerek, amelyeken a
	felhasználónak ugyan vannak kvótái,
	de nem foglal rajtuk lemezterületet.  A <option>-v</option>
	beállítás megadásával ezek az
	állományrendszerek is
	láthatóvá válnak, mint ahogy azt a
	fenti példában is megfigyelhettük a
	<filename>/usr/var</filename> esetében.</para>

    </sect2>

    <sect2>
      <title>Kvóták NFS-en keresztül</title>

      <indexterm><primary>NFS</primary></indexterm>

      <para>A kvóták az NFS szerver
	kvótákért felelõs
	alrendszerében is engedélyezhetõek.  Az
	&man.rpc.rquotad.8; démon teszi az NFS klienseken
	futtatott &man.quota.1; parancsok számára
	elérhetõvé a kvótákkal
	kapcsolatos információkat, aminek
	köszönhetõen a felhasználók
	távolról is képesek lekérdezni a
	kvótáikat.</para>

      <para>Az <command>rpc.rquotad</command>
	aktivilásához a következõt kell
	beállítani az <filename>/etc/inetd.conf</filename>
	állományban:</para>

      <programlisting>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</programlisting>

      <para>Majd ne felejtsük el újraindítani az
	<command>inetd</command> démont sem:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/inetd restart</userinput></screen>

    </sect2>
  </sect1>


  <sect1 xml:id="disks-encrypting">
    <info><title>A lemezpartíciók
      titkosítása</title>
      <authorgroup>
	<author><personname><firstname>Lucky</firstname><surname>Green</surname></personname><contrib>Írta: </contrib><affiliation>
	    <address><email>shamrock@cypherpunks.to</email></address>
	  </affiliation></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>lemezek</primary>
      <secondary>titkosítása</secondary>
    </indexterm>

    <para>A &os; kitûnõ futásközbeni
      védelmet ajánl fel az adatok illetéktelen
      hozzáférése ellen.  Az
      állományok engedélyei és a
      kötelezõ
      hozzáférés-vezérlés (Mandatory
      Access Control, MAC, lásd <xref linkend="mac"/>)
      segítenek megvédeni érzékeny
      adatainkat az illéktelenek ellen az operációs
      rendszer futása és a
      számítógép mûködése
      során.  Azonban az operációs rendszerben
      kezelt engedélyek teljesen hatástalanok abban az
      esetben, ha a támadó fizikailag is képes
      hozzáférni a
      számítógépünkhöz,
      eltávolítani a merevlemezt és egy
      másik operációs rendszer
      segítségével kielemezni a rajta
      található fontos adatainkat.</para>

    <para>Függetlenül attól, hogy a
      támadó valójában miként is
      férkõzött hozzá a
      merevlemezünkhöz, vagy miként kapcsolta le a
      számítógépünket, a &os;
      megtalálható <application>GEOM alapú
      lemeztitkosítás (gbde)</application> és a
      <command>geli</command> titkosítási alrendszer
      egyaránt képes védelmet nyújtani a
      számítógépen található
      állományrendszerek számára az
      értékes adatok után kutató igen
      motivált betörõk ellen.  A csupán egyes
      állományokra kiterjedõ körmönfont
      titkosítási módszerekkel szemben a
      <command>gbde</command> és a <command>geli</command> az
      egész állományrendszert
      észrevétlen módon titkosítja.
      Titkosítatlan adat nem is kerül a merevlemezre.</para>

    <sect2>
      <title>A lemez titkosítása a
	<application>gbde</application>
	használatával</title>

      <procedure>
	<step>
	  <title>Váljunk <systemitem class="username">root</systemitem>
	    felhasználóvá</title>

	  <para>A <application>gbde</application>
	    beállításához
	    rendszeradminisztrátori jogosultságokra lesz
	    szükségünk.</para>

	  <screen>&prompt.user; <userinput>su -</userinput>
Password:</screen>
	</step>

	<step>
	  <title>Adjuk hozzá a &man.gbde.4;
	    támogatását a rendszermag
	    konfigurációs
	    állományához</title>

	  <para>Tegyük a következõ sort a rendszermag
	    beállításait tartalmazó
	    állományba:</para>

	  <para><literal>options GEOM_BDE</literal></para>

	  <para>Fordítsuk újra a rendszermagot a <xref linkend="kernelconfig"/>ben leírtak szerint.</para>

	  <para>Indítsuk el a
	    számítógépet az új
	    rendszermaggal.</para>
	</step>

	<step>
	  <para>A rendszermag újrafordítása helyett
	    a <command>kldload</command> paranccsal is
	    betölthetjük a &man.gbde.4;
	    modulját:</para>

	  <screen>&prompt.root; <userinput>kldload geom_bde</userinput></screen>
	</step>
      </procedure>

    <sect3>
      <title>A titkosított merevlemez
	elõkészítése</title>

      <para>A következõ példa azt feltételezi,
	hogy a rendszerünkhöz egy új merevlemezt adunk
	hozzá, amin egyetlen titkosított
	partíció foglal helyet.  Ezt a
	partíciót a <filename>/private</filename>
	könyvtárba fogjuk csatlakoztatni.  A
	<application>gbde</application> használható a
	<filename>/home</filename> és a
	<filename>/var/mail</filename>
	titkosítására is, de ennek
	megvalósítása olyan bonyolult
	utasításokat igényel, amelyek
	meghaladják ennek a bevezetésnek a
	kereteit.</para>

      <procedure>
	<step>
	  <title>Az új merevlemez
	    hozzáadása</title>

	  <para>A <xref linkend="disks-adding"/>ban bemutatottak szerint
	    adjuk hozzá a rendszerünkhöz az új
	    merevlemezt.  A példában az új lemez
	    partícióját a
	    <filename>/dev/ad4s1c</filename> néven fogjuk
	    tudni elérni.  A
	    <filename>/dev/ad0s1*</filename>
	    eszközök a példában szereplõ
	    &os; rendszer szabványos partícióit
	    jelölik.</para>

	  <screen>&prompt.root; <userinput>ls /dev/ad*</userinput>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4</screen>
	</step>

	<step>
	  <title>Hozzunk létre egy könyvtárat a gbde
	    zárolásainak
	    tárolásához</title>

	  <screen>&prompt.root; <userinput>mkdir /etc/gbde</userinput></screen>

	  <para>A <application>gbde</application>nek azért van
	    szüksége a zárolásokat
	    rögzítõ állományokra, hogy
	    hozzá tudjon férni a titkosított
	    partíciókhoz.  Amennyiben ezt nem tudja
	    megtenni, a <application>gbde</application>
	    anélkül nem lesz képes visszafejteni a
	    titkosított partíciókon tárolt
	    adatokat, hogy az ezeket elérni akaró
	    szoftvereknek ne kelljen jelentõsebb
	    mértékben manuálisan beavatkoznia.
	    Mindegyik titkosított partíció
	    külön zároló állományt
	    használ.</para>
	</step>

	<step>
	  <title>A gbde partíció
	    inicializálása</title>

	  <para>A <application>gbde</application> által
	    használt partíciókat használatuk
	    elõtt inicializálni kell.  Ezt a mûveletet
	    azonban csak egyszer kell elvégezni:</para>

	  <screen>&prompt.root; <userinput>gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock</userinput></screen>

	  <para>A &man.gbde.8; ekkor elindít egy
	    szövegszerkesztõt és benne egy sablon
	    segítségével be tudjuk
	    állítani a különbözõ
	    konfigurációs értékeket.  Az
	    UFS1 vagy UFS2 használata esetén
	    állítsuk a szektorméretet
	    2048-ra:</para>

	  <programlisting>$<!-- anti-pre-commit-check -->FreeBSD: src/sbin/gbde/template.txt,v 1.1 2002/10/20 11:16:13 phk Exp $
#
# Sector size is the smallest unit of data which can be read or written.
# Making it too small decreases performance and decreases available space.
# Making it too large may prevent filesystems from working.  512 is the
# minimum and always safe.  For UFS, use the fragment size
#
sector_size     =       2048
[...]
</programlisting>

	  <para>A megjegyzés fordítása:</para>

	  <programlisting>A szektorméret az adatok írásának és olvasásának legkisebb egysége.  Ha
túlságosan kicsire választjuk meg, akkor csökken a teljesítmény és csökken a
rendelkezésre álló hely.  Ha viszont túlságosan nagyra hagyjuk, akkor azzal
akadályozzuk az állományrendszerek munkáját.  512 a legkisebb érték, amely mindig
megbízható.  Az UFS esetén használjuk a fragmensek méretét.</programlisting>

	  <para>A &man.gbde.8; kétszer is rá fog
	    kérdeni az adatok titkosítására
	    használt jelmondatra.  A jelmondatnak
	    természetesen mind a kétszer ugyanannak kell
	    lennie.  A <application>gbde</application>
	    védelmének hatékonysága teljesen
	    mértékben az általunk választott
	    jelmondat minõségétõl függ
	    <footnote>
	      <para>A könnyen megjegyezhetõ ám
		mégis biztonságos jelmondatok
		megválasztásához a <link xlink:href="http://world.std.com/~reinhold/diceware.html">Diceware
		Passphrase</link> honlapján találunk egy
		kis segítséget
		(angolul).</para>
	    </footnote>.</para>

	  <para>A <command>gbde init</command> parancs létrehoz
	    egy zároló állományt a
	    <application>gbde</application> partícióhoz,
	    amely ebben a példában az
	    <filename>/etc/gbde/ad4s1c.lock</filename> néven
	    keletkezett.  A <application>gbde</application>
	    zároló állományainak
	    <quote>.lock</quote> névre kell
	    végzõdniük, mivel az
	    <filename>/etc/rc.d/gbde</filename>
	    indítószkript csak ebben az esetben
	    észleli rendesen.</para>

	  <caution>
	    <para>A <application>gbde</application> zároló
	      állományait a titkosított
	      partíciók tartalmával együtt
	      <emphasis>kell</emphasis> lementeni.  Miközben a
	      zároló állomány
	      törlése nem tudja megakadályozni, hogy
	      az elszánt támadó visszafejtse a
	      <application>gbde</application> által
	      titkosított partíciót, addig a
	      zároló állomány
	      nélkül a jogos tulajdonos órási
	      mennyiségû munka befektetése
	      nélkül képtelen lesz
	      hozzáférni a rajta levõ adatokhoz.  Ez
	      utóbbitól egyébként a
	      &man.gbde.8; és a rendszer tervezõje is
	      totálisan elhatárolja magát.</para>
	  </caution>
	</step>

	<step>
	  <title>A titkosított partíció
	    illesztése a rendszermaghoz</title>

	  <screen>&prompt.root; <userinput>gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock</userinput></screen>

	  <para>Ekkor a titkosított partíció
	    illesztéséhez a rendszer kérni fogja az
	    inicializálás során választott
	    jelmondatot.  Ezután az új titkosított
	    eszköz megjelenik a <filename>/dev</filename>
	    könyvtárban
	    <filename>/dev/eszköznév.bde</filename>
	    néven:</para>

	  <screen>&prompt.root; <userinput>ls /dev/ad*</userinput>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde</screen>
	</step>

	<step>
	  <title>Állományrendszer
	    kialakítása egy titkosított
	    eszközön</title>

	  <para>Ahogy sikerült a titkosított eszközt
	    illeszteni a rendszermaghoz, létre is tudunk hozni
	    egy állományrendszert rajta.  Erre a
	    célra a &man.newfs.8; remekül
	    használható.  Mivel egy új UFS2
	    állományrendszerek
	    inicializálása sokkal gyorsabb a régi
	    UFS1 állományrendszerek
	    inicializálásánál, ezért
	    a &man.newfs.8; használata esetén az
	    <option>-O2</option> beállítás
	    megadása ajánlott.</para>

	  <screen>&prompt.root; <userinput>newfs -U -O2 /dev/ad4s1c.bde</userinput></screen>

	  <note>
	    <para>A &man.newfs.8; parancsot egy illesztett
	      <application>gbde</application> partíción
	      kell végrehajtani, amit onnan ismerhetünk meg,
	      hogy az eszköz nevében szerepel a
	      <filename>*.bde</filename>
	      kiterjesztés.</para>
	  </note>
	</step>

	<step>
	  <title>A titkosított partíció
	    csatlakoztatása</title>

	  <para>Hozzunk létre egy csatlakozási pontot a
	    titkosított állományrendszer
	    számára.</para>

	  <screen>&prompt.root; <userinput>mkdir /privát</userinput></screen>

	  <para>Csatlakoztassuk a titkosított
	    állományrendszert.</para>

	  <screen>&prompt.root; <userinput>mount /dev/ad4s1c.bde /privát</userinput></screen>
	</step>

	<step>
	  <title>Ellenõrizzük a titkosított
	    állományrendszer
	    mûködõképességét</title>

	  <para>A titkosított állományrendszert
	    most már látja a &man.df.1; program és
	    készen áll a használatra.</para>

	  <screen>&prompt.user; <userinput>df -H</userinput>
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private</screen>
	</step>
      </procedure>

    </sect3>

    <sect3>
      <title>Létezõ titkosított
	állományrendszerek csatlakoztatása</title>

      <para>A rendszer minden egyes indítása után
	az összes titkosított
	állományrendszert tényleges
	használata elõtt újra illeszteni kell a
	rendszermaghoz, ellenõrizni az épségét
	és csatlakoztatni.  Az ehhez szükséges
	parancsokat <systemitem class="username">root</systemitem>
	felhasználóként kell kiadni.</para>

      <procedure>
	<step>
	  <title>A gbde partíció illesztése a
	    rendszermaghoz</title>

	  <screen>&prompt.root; <userinput>gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock</userinput></screen>

	  <para>A <application>gbde</application> partíció
	    inicializálása során megadott
	    jelmondatot kell megadnunk a mûvelet
	    elvégzéséhez.</para>
	</step>

	<step>
	  <title>Az állományrendszer
	    épségének
	    ellenõrzése</title>

	  <para>Mivel a titkosított
	    állományrendszerek az automatikus
	    csatlakoztatáshoz még nem
	    szerepeltethetõek az <filename>/etc/fstab</filename>
	    állományban, ezért az ilyen
	    állományrendszereket csatlakoztatásuk
	    elõtt manuálisan ellenõriztetni kell a
	    &man.fsck.8; lefuttatásával.</para>

	  <screen>&prompt.root; <userinput>fsck -p -t ffs /dev/ad4s1c.bde</userinput></screen>
	</step>

	<step>
	  <title>A titkosított állományrendszer
	    csatlakoztatása</title>

	  <screen>&prompt.root; <userinput>mount /dev/ad4s1c.bde /privát</userinput></screen>

	  <para>A titkosított állományrendszer most
	    már készen áll a
	    használatra.</para>
	</step>
      </procedure>

	<sect4>
	  <title>A titkosított partíciók
	    önálló csatlakoztatása</title>

	  <para>Lehet írni olyan szkriptet, amely a
	    titkosított partíciókat
	    magától illeszti, ellenõrzi és
	    csatlakoztatja, de biztonsági
	    megfontolásokból semmi esetben sem szabad
	    tartalmaznia a &man.gbde.8; jelszavát.  Ehelyett azt
	    javasoljuk, hogy az ilyen szkripteknek külön meg
	    kelljen adni a jelszót konzolon vagy az &man.ssh.1;
	    használatán keresztül.</para>

	  <para>De használhatjuk a mellékelt
	    <filename>rc.d</filename> szkriptet is.  A szkript
	    paramétereit az &man.rc.conf.5;
	    állományon keresztül adhatjuk meg,
	    például:</para>

	  <programlisting>gbde_autoattach_all="YES"
gbde_devices="ad4s1c"
gbde_lockdir="/etc/gbde"</programlisting>

	  <para>Ilyenkor a <application>gbde</application> által
	    használt jelmondatot a rendszer
	    indításakor kell megadni.  Miután
	    begépeltük a megfelelõ jelmondatot, a
	    titkosított <application>gbde</application>
	    partíció magától
	    csatlakoztatásra kerül.  Ez akkor lehet hasznos,
	    ha a <application>gbde</application>
	    megoldását hordozható
	    számítógépeken
	    alkalmazzuk.</para>

	</sect4>
      </sect3>

      <sect3>
	<title>A gbde által alkalmazott titkosítási
	  módszerek</title>

	<para>A &man.gbde.8; a szektorok tartalmát 128&nbsp;bites
	  AES használatával CBC módban
	  titkosítja.  A lemezen található minden
	  egyes szektort eltérõ AES kulccsal kódolja.
	  A <application>gbde</application> kriptográfiai
	  felépítését, valamint mindazt,
	  hogy az egyes szektorok kulcsai miként
	  származtathatóak a felhasználó
	  által megadott jelmondatból, a &man.gbde.4; man
	  oldalán olvashatjuk.</para>

      </sect3>

      <sect3>
	<title>Kompatibilitási problémák</title>

	<para>A &man.sysinstall.8; nem kompatibilis a
	  <application>gbde</application> által
	  titkosított eszközökkel.  A
	  &man.sysinstall.8; indítása elõtt minden
	  <filename>*.bde</filename>
	  eszközt ki kell iktatni a rendszermagból,
	  különben az eszközök keresése
	  során össze fog omlani.  A
	  példánkban használt titkosított
	  eszközt a következõ paranccsal kell
	  lekapcsolni:</para>

	<screen>&prompt.root; <userinput>gbde detach /dev/ad4s1c</userinput></screen>

	<para>Továbbá megjegyezzük azt is, hogy a
	  &man.vinum.4; nem használja a &man.geom.4; alrendszert,
	  ezért a <application>gbde</application>
	  alkalmazása során nem használhatunk
	  <application>Vinum</application>-köteteket.</para>

      </sect3>
    </sect2>

    <sect2>
      <info><title>A lemezek titkosítása a
	<command>geli</command> használatával</title>
	<authorgroup>
	  <author><personname><firstname>Daniel</firstname><surname>Gerzo</surname></personname><contrib>Írta: </contrib></author>
	</authorgroup>
      </info>

      

      <para>A &os; 6.0&nbsp;változatától kezdve egy
	új kriptográfiai GEOM osztály is a
	rendelkezésünkre áll, melyet pillanatnyilag
	&a.pjd; fejleszt.  A <command>geli</command> segédprogram
	némileg különbözõ a
	<command>gbde</command> megoldásától
	&mdash; más lehetõségeket kínál
	fel és a titkosítást is egy
	eltérõ séma mentén
	valósítja meg.</para>

      <para>A &man.geli.8; legfontosabb jellemzõi a
	következõk:</para>

      <itemizedlist>
	<listitem>
	  <para>A &man.crypto.9; keretrendszerét használja
	    &mdash; tehát ha rendelkezünk
	    kriptográfiai hardverrel, akkor a
	    <command>geli</command> automatikusan használni
	    fogja.</para>
	</listitem>
	<listitem>
	  <para>Több kriptográfiai algoritmust is ismer
	    (melyek jelenleg az AES, Blowfish és a 3DES).</para>
	</listitem>
	<listitem>
	  <para>Segítségével a
	    rendszerindításhoz használt
	    (gyökér) partíció is
	    titkosítható.  Ilyenkor a
	    szükséges jelmondatot a rendszer
	    indításakor kell megadni.</para>
	</listitem>
	<listitem>
	  <para>Két független kulcsot (például
	    egy <quote>kulcsot</quote> és egy <quote>céges
	    kulcsot</quote>) is használhatunk vele.</para>
	</listitem>
	<listitem>
	  <para>A <command>geli</command> gyors &mdash; egyszerûen
	    csak szektorról szektorra titkosít.</para>
	</listitem>
	<listitem>
	  <para>Lehetõvé teszi a mesterkulcsok
	    mentését is
	    visszaállítását.  Ha a
	    felhasználó véletlenül
	    megsemmisítené a kulcsát, akkor a
	    biztonsági mentésbõl
	    helyreállított kulcsok
	    segítségével vissza tudjuk szerezni az
	    adatainkat is.</para>
	</listitem>
	<listitem>
	  <para>Segítségével a lemezeket
	    véletlenszerû, egyszeri jelszavakkal is
	    illeszthetjük &mdash; ez különösen
	    fontos lapozóterületek és ideiglenes
	    állományrendszerek esetében.</para>
	</listitem>
      </itemizedlist>

      <para>A <command>geli</command> által
	felkínált lehetõségekrõl a
	&man.geli.8; man oldalán találhatunk
	többet.</para>

      <para>A következõ lépések
	bemutatják, hogyan lehet a &os; rendszermagjában
	engedélyezni a <command>geli</command>
	támogatását, és hogyan lehet
	létrehozni és használni egy
	<command>geli</command> titkosítással
	rendelkezõ adathordozót.</para>

      <para>A <command>geli</command> alkalmazásához
	legalább a &os; 6.0-RELEASE vagy késõbbi
	változatára van szükségünk.
	Mivel a rendszermagot is módosítanunk kell,
	ezért rendszeradminisztrátori jogosultságok
	kellenek a mûveletek
	elvégzéséhez.</para>

      <procedure>
	<step>
	  <title>A <command>geli</command>
	    támogatásának hozzáadása
	    a rendszermaghoz</title>

	  <para>Vegyük hozzá a következõ sorokat a
	    rendszermag beállításait
	    tartalmazó állományhoz:</para>

	  <programlisting>options GEOM_ELI
device crypto</programlisting>

	  <para>Fordítsuk újra a rendszermagot a <xref linkend="kernelconfig"/>ben leírtak szerint.</para>

	  <para>Betölthetjük a <command>geli</command>
	    modulját is a rendszer indításakor.
	    Ehhez a következõ sort kell betenni a
	    <filename>/boot/loader.conf</filename>
	    állományba:</para>

	  <programlisting>geom_eli_load="YES"</programlisting>

	  <para>A &man.geli.8; most már használható
	    a rendszermagban.</para>
	</step>

	<step>
	  <title>A mesterkulcs legenerálása</title>

	  <para>A most következõ példában egy
	    kulcsot tartalmazó állomány
	    létrehozását illusztráljuk, amit
	    a <filename>/privát</filename>
	    könyvtárba csatlakoztatott titkosított
	    adathordozó mesterkulcsához fogunk
	    használni.  A kulcs állomány a
	    mesterkulcs titkosításához
	    felhasznált véletlenszerû adatot fogja
	    tartalmazni, valamint rajta kívül még a
	    mesterkulcsot egy jelmondattal is védjük.  Az
	    adathordozó szektormérete 4&nbsp;kilobyte-os
	    lesz.  Emellett még bemutatjuk, hogyan kell
	    illeszteni egy <command>geli</command>-adathordozót,
	    állományrendszert létrehozni rajta,
	    csatlakoztatni, dolgozni vele és lekapcsolni.</para>

	  <para>A nagyobb teljesítmény
	    érdekében javasolt nagyobb
	    szektorméretet választani (mint
	    például 4&nbsp;kilobyte).</para>

	  <para>A mesterkulcsot egy jelmondattal fogjuk védeni
	    és a kulcsok készítéséhez
	    használt adatforrás a
	    <filename>/dev/random</filename> lesz.  A
	    <filename>/dev/da2.eli</filename>, amelyet mit csak
	    adathordozónak fogunk csak hívni, szektorainak
	    mérete 4&nbsp;kilobyte lesz.</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/random of=/root/da2.key bs=64 count=1</userinput>
&prompt.root; <userinput>geli init -s 4096 -K /root/da2.key /dev/da2</userinput>
Enter new passphrase:
Reenter new passphrase:</screen>

	  <para>Nem kötelezõ egyszerre használni a
	    jelmondatot és a kulcs állományt.  A
	    mesterkulcs elzárásának
	    bebiztosítására bármelyik
	    módszer alkalmas.</para>

	  <para>Ha a kulcs állomány a <quote>-</quote>
	    paraméterrel adjuk meg, akkor a szabványos
	    bemenetrõl olvassa be a program.  Ez a példa
	    több kulcs használatát mutatja be.</para>

	  <screen>&prompt.root; <userinput>cat kulcs1 kulcs2 kulcs3 | geli init -K - /dev/da2</userinput></screen>
	</step>

	<step>
	  <title>Az adathordozó illesztése a
	    generált kulccsal</title>

	  <screen>&prompt.root; <userinput>geli attach -k /root/da2.key /dev/da2</userinput>
Enter passphrase:</screen>

	  <para>Az új titkosítatlan eszköz neve
	  <filename>/dev/da2.eli</filename>
	    lesz.</para>

	  <screen>&prompt.root; <userinput>ls /dev/da2*</userinput>
/dev/da2  /dev/da2.eli</screen>
	</step>

	<step>
	  <title>Az új állományrendszer
	    kialakítása</title>

	  <screen>&prompt.root; <userinput>dd if=/dev/random of=/dev/da2.eli bs=1m</userinput>
&prompt.root; <userinput>newfs /dev/da2.eli</userinput>
&prompt.root; <userinput>mount /dev/da2.eli /privát</userinput></screen>

	  <para>A titkosított állományrendszer most
	    már &man.df.1; számára is
	    látszik és használható:</para>

	  <screen>&prompt.root; <userinput>df -H</userinput>
Filesystem     Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a    248M    89M   139M    38%    /
/devfs         1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr
/dev/ad0s1d    989M   1.5M   909M     0%    /tmp
/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var
/dev/da2.eli   150G   4.1K   138G     0%    /private</screen>

	</step>

	<step>
	  <title>Az adathordozó leválasztása
	    és lekapcsolása</title>

	  <para>Miután befejeztük a munkát a
	    titkosított partíción, és a
	    <filename>/privát</filename>
	    partícióra már nincs tovább
	    szükségünk, érdemes
	    leválasztanunk és kiiktatnunk a
	    <command>geli</command> titkosítású
	    partíciót a rendszermagból.</para>

	  <screen>&prompt.root; <userinput>umount /privát</userinput>
&prompt.root; <userinput>geli detach da2.eli</userinput></screen>
	</step>
      </procedure>

      <para>A &man.geli.8; használatáról
	bõvebben a saját man oldalán
	tájékozódhatunk.</para>

      <sect3>
	<title>A <filename>geli</filename> <filename>rc.d</filename>
	  szkriptjének használata</title>

	<para>A <command>geli</command> mellett találhatunk egy
	  saját <filename>rc.d</filename> szkriptet, amely
	  jelentõsen leegyszerûsíti a
	  <command>geli</command> használatát.  A
	  <command>geli</command> például így
	  paraméterezhetõ az &man.rc.conf.5;
	  állományon keresztül:</para>

	<programlisting>geli_devices="da2"
geli_da2_flags="-p -k /root/da2.key"</programlisting>

	<para>Ennek segítségével a
	  <filename>/dev/da2</filename> eszközt
	  <command>geli</command> adathordozóként
	  állítjuk be a <filename>/root/da2.key</filename>
	  állományban található mesterkulcs
	  felhasználásával, de az
	  illesztéskor a <command>geli</command> nem kér
	  jelmondatot (ezt csak akkor fogja tenni, ha a <literal>geli
	  init</literal> parancs kiadásához
	  hozzátesszük a <option>-P</option>
	  beállítást).  A rendszer
	  leállítása elõtt pedig a
	  <command>geli</command> adathordozó így
	  automatikusan leválasztásra kerül.</para>

	<para>Az <filename>rc.d</filename>
	  beállításával kapcsolatos
	  tudnivalókat a kézikönyv <link linkend="configtuning-rcd">rc.d</link> szkriptekrõl
	  szóló szakaszában ismerhetjük
	  meg.</para>

      </sect3>
    </sect2>
  </sect1>


  <sect1 xml:id="swap-encrypting">
    <info><title>A lapozóterület titkosítása</title>
      <authorgroup>
	<author><personname><firstname>Christian</firstname><surname>Brüffer</surname></personname><contrib>Írta: </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>lapozóterület</primary>
      <secondary>titkosítása</secondary>
    </indexterm>

    <para>A &os;-ben a lapozóterület
      titkosítása nagyon könnyen
      beállítható és már a
      &os;&nbsp;5.3-RELEASE változata óta
      elérhetõ.  Attól függõen, hogy
      konkrétan a &os; melyik verzióját
      használjuk, a konfigurációhoz
      kapcsolódó beállítások
      némileg eltérhetnek.  A &os;&nbsp;6.0-RELEASE
      változatától kezdõdõen a
      &man.gbde.8; és a &man.geli.8; alrendszerek is
      használhatóak a lapozóterület
      titkosítására.  A korábbi
      verziókban egyedül csak a &man.gbde.8;
      érhetõ el.  Mind a két rendszer az
      <filename>encswap</filename> <link linkend="configtuning-rcd">rc.d</link> szkriptet
      használja.</para>

    <para>Az elõzõ szakaszban, vagyis a <link linkend="disks-encrypting"> A lemezpartíciók
      titkosításá</link>ban már röviden
      összefoglaltuk a különbözõ
      titkosítással foglalkozó
      alrendszereket.</para>

    <sect2>
      <title>Miért kellene titkosítanunk a
	lapozóterületet?</title>

      <para>Hasonlóan a lemezpartíciók
	titkosításához, a lapozóterület
	titkosításának is az a célja, hogy
	védjük az érzékeny
	információkat.  Képzeljük el, hogy egy
	olyan alkalmazással dolgozunk, amely jelszavakat kezel.
	Amíg ezek a jelszavak a memóriában
	maradnak, addig minden a legnagyobb rendben van.  Azonban amikor
	az operációs rendszer nekilát a fizikai
	memória felszabadításához kilapozni
	ezeket az adatokat, a jelszavak titkosítatlanul
	kerülnek a lemez felületére és egy
	támadó számára könnyû
	prédává válnak.  Ilyen helyzetekben
	csak lapozóterület titkosítása
	jelenthet megoldást.</para>

    </sect2>

    <sect2>
      <title>Elõkészületek</title>

      <note>
	<para>A szakasz további részében a
	  <filename>ad0s1b</filename> lesz a lapozásra
	  használt partíció.</para>
      </note>

      <para>Egészen mostanáig nem titkosítottuk a
	lapozóterületet.  Így
	elképzelhetõ, hogy a lemezre már
	titkosítatlanul kikerültek jelszavak vagy
	bármilyen más érzékeny adatok.  A
	csorba kiköszörülésére a
	lapozóterületen található összes
	adatot írjuk felül véletlenszerûen
	generált szeméttel:</para>

      <screen>&prompt.root; <userinput>dd if=/dev/random of=/dev/ad0s1b bs=1m</userinput></screen>

    </sect2>

    <sect2>
      <title>A lapozóterület titkosítása a
	&man.gbde.8; használatával</title>

      <para>Ha a &os; 6.0-RELEASE vagy újabb
	változatát használjuk, akkor az
	<filename>/etc/fstab</filename> állományban
	tegyük hozzá a <literal>.bde</literal>
	utótagot az a lapozóterülethez tartozó
	eszköz nevéhez.</para>

      <programlisting>
# Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ad0s1b.bde         none            swap    sw              0       0
      </programlisting>

      <para>A &os;&nbsp;6.0-RELEASE elõtti kiadások
	esetében a következõ sort is hozzá kell
	tennünk az <filename>/etc/rc.conf</filename>
	állományhoz:</para>

      <programlisting>gbde_swap_enable="YES"</programlisting>

    </sect2>

    <sect2>
      <title>A lapozóterület titkosítása a
	&man.geli.8; használatával</title>

      <para>A &man.gbde.8; használatához hasonlóan
	a &man.geli.8; által felajánlott
	titkosítást is alkalmazhatjuk a
	lapozóterület védelmére.  Ilyenkor az
	<filename>/etc/fstab</filename> állományban az
	<literal>.eli</literal> utótagot kell hozzátenni a
	lapozóterülethez tartozó eszköz
	névhez.</para>

      <programlisting>
# Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ad0s1b.eli         none            swap    sw              0       0
      </programlisting>

      <para>Az &man.geli.8; az AES algoritmust
	alapértelmezés szerint 256&nbsp;bites kulccsal
	használja.</para>

      <para>Ezek az alapértelmezések
	megváltoztathatóak az
	<filename>/etc/rc.conf</filename> állományban a
	<literal>geli_swap_flags</literal>
	beállítás használatával.  A
	következõ sor arra utasítja az
	<filename>encswap</filename> rc.d szkriptet, hogy a &man.geli.8;
	és a Blowfish algoritmus használatával
	hozzon létre egy lapozópartíciót
	128&nbsp;bites kulccsal, 4&nbsp;kilobyte-os
	szektormérettel és a <quote>detach on last
	close</quote> (<quote>lekapcsolás használat
	után</quote>) beállítással:</para>

      <programlisting>geli_swap_flags="-e blowfish -l 128 -s 4096 -d"</programlisting>

      <para>A &os;&nbsp;6.2-RELEASE verzió elõtti
	rendszerekben a következõ sort kell
	használni:</para>

      <programlisting>geli_swap_flags="-a blowfish -l 128 -s 4096 -d"</programlisting>

      <para>A többi beállításhoz a
	&man.geli.8; man oldalán a <command>onetime</command>
	parancs leírását érdemes
	áttanulmányozni.</para>

    </sect2>

    <sect2>
      <title>Ellenõrizzük a
	mûködését</title>

      <para>Miután újraindítottuk a rendszert, a
	titkosított lapozóterület helyes
	mûködését a <command>swapinfo</command>
	paranccsal ellenõrizhetjük le.</para>

      <para>A &man.gbde.8; esetében:</para>

      <screen>&prompt.user; <userinput>swapinfo</userinput>
Device          1K-blocks     Used    Avail Capacity
/dev/ad0s1b.bde    542720        0   542720     0%
      </screen>

      <para>Valamint a &man.geli.8; esetében:</para>

      <screen>&prompt.user; <userinput>swapinfo</userinput>
Device          1K-blocks     Used    Avail Capacity
/dev/ad0s1b.eli    542720        0   542720     0%
      </screen>

    </sect2>
  </sect1>
</chapter>
