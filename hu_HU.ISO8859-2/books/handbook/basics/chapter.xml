<?xml version="1.0" encoding="iso-8859-2"?>
<!--
     The FreeBSD Documentation Project

     $FreeBSD$
-->
<!-- The FreeBSD Hungarian Documentation Project
     Translated by: PALI, Gabor <pgj@FreeBSD.org>
     %SOURCE%	en_US.ISO8859-1/books/handbook/basics/chapter.xml
     %SRCID%	1.157
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="basics" xml:lang="hu">
  <info><title>A UNIX alapjai</title>
    <authorgroup>
      <author><personname><firstname>Chris</firstname><surname>Shumway</surname></personname><contrib>Átdolgozta: </contrib></author>
    </authorgroup>
  </info>

  

  <sect1 xml:id="basics-synopsis">
    <title>Áttekintés</title>

    <para>Ez a fejezet a &os; operációs rendszer
      alapvetõ funkcióit és parancsait mutatja be.
      Az itt tárgyalásra kerülõ anyag nagy
      része érvényes bármelyik más
      &unix;-szerû operációs rendszer esetén
      is.  Ezért, ha már ismerjük az
      említésre kerülõ ismereteket, minden
      további gond nélkül átugorhatjuk ezt a
      fejezetet.  Azonban ha még teljesen ismeretlen
      számunkra a &os;, minden bizonnyal ez lesz az, amit
      alaposan át kell majd olvasnunk.</para>

    <para>A fejezet elolvasása során
      megismerjük:</para>

    <itemizedlist>
      <listitem>
	<para>az ún.  <quote>virtuális konzolok</quote>
	  használatát &os; alatt;</para>
      </listitem>
      <listitem>
	<para>hogyan mûködnek együtt a &unix;
	  állományokra vonatkozó engedélyei
	  a &os; saját
	  kiegészítéseivel;</para>
      </listitem>
      <listitem>
	<para>egy &os; állományrendszer
	  alapértelmezett
	  kialakítását;</para>
      </listitem>
      <listitem>
	<para>a &os; lemezszervezését;</para>
      </listitem>
      <listitem>
	<para>hogyan csatlakoztassunk és válasszunk le
	  állományrendszereket;</para>
      </listitem>
      <listitem>
	<para>mik azok a folyamatok, démonok és
	  jelzések;</para>
      </listitem>
      <listitem>
	<para>mik azok a parancsértelmezõk, és
	  miként tudjuk megváltoztatni az
	  alapértelmezett bejelentkezési
	  környezetünket;</para>
      </listitem>
      <listitem>
	<para>hogyan használjuk az alapvetõ
	  szövegszerkesztõket;</para>
      </listitem>
      <listitem>
	<para>mik az eszközök és az
	  eszközleírók;</para>
      </listitem>
      <listitem>
	<para>&os; alatt milyen bináris formátumokat
	  használhatunk;</para>
      </listitem>
      <listitem>
	<para>szükség esetén hogyan olvassuk el a
	  megfelelõ man oldalakat.</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 xml:id="consoles">
    <title>Virtuális konzolok és terminálok</title>

    <indexterm><primary>virtuális konzolok</primary></indexterm>
    <indexterm><primary>terminálok</primary></indexterm>

    <para>A &os; számos módon használható.
      Ezek közül az egyik az, ha parancsokat
      gépelünk be a szöveges terminálon.
      Így érhetõ el egyszerûen a &unix;
      operációs rendszer rugalmasságának
      és erejének jelentõs része.  Ebben a
      szakaszban megtudhatjuk, mik azok a
      <quote>terminálok</quote> és <quote>konzolok</quote>
      és miként tudjuk ezeket &os; alatt
      használni.</para>

    <sect2 xml:id="consoles-intro">
      <title>A konzol</title>

      <indexterm><primary>konzol</primary></indexterm>

      <para>Ha nem állítottuk volna be, hogy a &os;
	indulása során automatikusan induljon el a
	grafikus felület is, akkor a rendszer egy bejelentkezõ
	képernyõt fog mutatni közvetlenül a
	rendszerindítás befejezõdése
	után.  Ekkor valami ilyesmit kell majd
	látnunk:</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:</screen>

      <para>Egyes rendszereken ugyan némileg eltérhetnek
	az üzenetek, de hasonlót kell látnunk.
	Minket most az utolsó két sor érdekel.  Az
	utolsó elõtti sorban ez olvasható:</para>

      <programlisting>FreeBSD/i386 (pc3.example.org) (ttyv0)</programlisting>

      <para>Ez a sor arról értesít minket, hogy a
	rendszerünk éppen most indult el: egy
	<quote>&os;</quote> konzolt látunk, amely egy &intel; x86
	architektúrájú processzoron fut
	<footnote>
	  <para>Erre utal pontosan az <literal>i386</literal>
	    jelzés.  Még abban az esetben is az
	    <literal>i386</literal> kiírást fogjuk
	    látni, ha a &os;-t konkrétan nem is az &intel;
	    386-os processzorán futtatjuk.  Itt ugyanis nem a
	    processzorunk típusát, hanem annak
	    <quote>architektúráját</quote>
	    láthatjuk.</para>
	</footnote>.  A gépünk neve (mivel minden &unix;-os
	  gép rendelkezik egy névvel)
	  <systemitem>pc3.example.org</systemitem>, és ennek a
	  rendszerkonzolját látjuk most éppen
	  &mdash; a <filename>ttyv0</filename>
	  terminált.</para>

      <para>Végezetül az utolsó sor mindig:</para>

      <programlisting>login:</programlisting>

      <para>Ez az a rész, ahova a &os;-be
	történõ bejelentkezéshez meg kell adnunk
	a <quote>felhasználói nevünket</quote> (user
	name).  A következõ szakaszban errõl
	olvashatunk.</para>

    </sect2>

    <sect2 xml:id="consoles-login">
      <title>Bejelentkezés a &os;-be</title>

      <para>A &os; egy többfelhasználós,
	többfeladatos rendszer.  Így hívják
	hivatalosan azokat a rendszereket, amelyeket többen tudnak
	használni és egyetlen
	számítógépen egyszerre rengeteg
	programot képesek futtatni.</para>

      <para>Minden többfelhasználós rendszernek
	valamilyen módon meg kell tudnia
	különböztetnie egy
	<quote>felhasználóját</quote> a
	többitõl.  A &os;-ben (és minden más
	&unix;-szerû operációs rendszerben) ezt
	úgy érik el, hogy a programok futtatása
	elõtt minden felhasználónak <quote>be kell
	jelentkeznie</quote> a rendszerbe.  Minden
	felhasználó rendelkezik egy egyedi névvel
	(ez a <quote>felhasználói név</quote>)
	és ehhez egy titkos kulcssal (ez a
	<quote>jelszó</quote>).  A &os; a programok
	futtatásához ezt a kettõt fogja
	elkérni a felhasználótól.</para>

      <indexterm><primary>rendszerindító szkriptek</primary></indexterm>

      <para>Egybõl miután a &os; elindult és
	befejezte a rendszerindításhoz használt
	szkriptjeinek lefuttatását
	<footnote>
	  <para>A rendszerindító szkriptek olyan
	    programok, amelyek a &os; indulása során
	    maguktól lefutnak.  Legfontosabb feladatuk
	    elvégezni a többi program
	    futtatásához szükséges
	    beállításokat, valamint
	    elindítani a háttérben
	    futtatandó, hasznos munkát végzõ
	    szolgáltatásokat.</para>
	</footnote>, ez a kijelzés (vagy más néven
	<quote>prompt</quote>) fog megjelenni és kér egy
	érvényes felhasználói
	nevet:</para>

      <screen>login:</screen>

      <para>A példa kedvéért most tegyük fel,
	hogy a felhasználói nevünk
	<systemitem class="username">pgj</systemitem>.  Az iménti prompthoz
	írjuk be, hogy <literal>pgj</literal> és nyomjuk
	le az <keycap>Enter</keycap> billentyût.  Ezt
	követõen meg kell jelennie egy másik promptnak
	is, amely egy <quote>jelszót</quote> (password)
	kér:</para>

      <screen>login: <userinput>pgj</userinput>
Password:</screen>

      <para>Most pedig gépeljük be <systemitem class="username">pgj</systemitem>
	jelszavát és nyomjunk utána egy
	<keycap>Enter</keycap> billentyût.  Vigyázzunk, hogy
	a jelszót <emphasis>nem látjuk</emphasis> a
	beírás során!  Emiatt most ne
	aggódjunk.  Ezzel kapcsolatban elegendõ csak annyit
	tudni, hogy mindez biztonsági
	megfontolásokból történik.</para>

      <para>Amennyiben jól adtuk meg a jelszavunkat, sikeresen
	bejelentkezünk a &os; rendszerébe és
	készen állunk az összes elérhetõ
	parancs kipróbálására.</para>

      <para>Bejelentkezés után a <acronym>MOTD</acronym>
	(message of the day) vagy más néven <quote>a nap
	üzenete</quote> jelenik meg, amelyet a parancssor
	követ (egy <literal>#</literal>, <literal>$</literal> vagy
	<literal>%</literal> jel).  Innen tudhatjuk meg, hogy
	sikerült bejelentkeznünk.</para>

    </sect2>

    <sect2 xml:id="consoles-virtual">
      <title>Több konzol használata</title>

      <para>A &unix; parancsokat egy konzolon is szépen ki tudjuk
	adni, de a &os; egyszerre ugyebár több programot is
	tud futtatni.  A parancsok megadásához viszont
	egyetlen konzol használata elég nagy
	pazarlás lenne, hiszen egy olyan operációs
	rendszer mint a &os;, tucatnyi programot képes futtatni
	egy idõben.  Ebben az esetben jelenthetnek számunkra
	segítséget a <quote>virtuális
	konzolok</quote>.</para>

      <para>A &os; beállítható úgy, hogy
	sok-sok különféle virtuális konzolt
	ajánljon fel számunkra.  A virtuális
	konzolok között a billentyûzeten a megfelelõ
	gombok lenyomásával tudunk váltani.
	Mindegyik konzolnak megvan a saját kimeneti
	csatornája, és a virtuális konzolok
	közti váltás folyamán a &os;
	gondoskodik a billentyûzetrõl érkezõ
	bemenet, valamint a monitorra irányított kimenet
	megfelelõ kezelésérõl.</para>

      <para>A konzolok közti váltásra a &os;
	külön billentyûkombinációkat tart
	fenn
	<footnote>
	  <para>A &os; konzol- és
	    billentyûzetmeghajtóinak teljes, pusztán
	    mûszaki és precíz leírása a
	    &man.syscons.4;, &man.atkbd.4;, &man.vidcontrol.1; és
	    &man.kbdcontrol.1; man oldalakon olvasható.  Itt most
	    nem bocsátkozunk részletekbe, azonban a
	    téma iránt érdeklõdõ
	    olvasóknak mindig érdemes fellapozniuk a
	    kapcsolódó man oldalakat, ahol
	    megtalálhatják az említett
	    eszközök részletesebb és bõvebb
	    leírását.</para>
	</footnote>.  A &os;-ben a különbözõ
	virtuális konzolok közti váltásra az
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo>
	billentyûket, az
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo>
	billentyûkombinációval
	bezárólag használhatjuk.</para>

      <para>A konzolok közti váltogatás során
	a &os; ügyel a képernyõ tartalmának
	elmentésére és
	visszaállítására.  Ennek
	eredményeképpen <quote>úgy
	látszik</quote>, mintha több
	<quote>virtuális</quote> képernyõn és
	billentyûzeten adnánk parancsokat a &os;-nek.</para>

    </sect2>

    <sect2 xml:id="consoles-ttys">
      <title>Az <filename>/etc/ttys</filename>
	állomány</title>

      <para>A &os; alapértelmezés szerint nyolc
	virtuális konzollal indul.  Ez azonban nem egy elõre
	rögzített érték, hiszen
	könnyedén testreszabhatjuk úgy a
	telepített rendszerünket, hogy több vagy
	esetleg kevesebb virtuális konzollal induljon el.  A
	virtuális konzolok száma és azok pontos
	beállítása az
	<filename>/etc/ttys</filename> állományon
	keresztül adható meg.</para>

      <para>A &os; virtuális konzoljait tehát az
	<filename>/etc/ttys</filename> állomány
	megfelelõ módosításával tudjuk
	behangolni.  Itt minden egyes olyan sor, amely nem
	megjegyzés (vagyis azok a sorok, amelyek nem a
	<literal>#</literal> karakterrel kezdõdnek), tartalmazza az
	egyes terminálok vagy virtuális konzolok
	beállításait.  Az állomány a
	&os; telepítésében szereplõ,
	alapértelmezett változata kilenc virtuális
	konzol konfigurációját tartalmazza, amelyek
	közül nyolc aktív.  Ezek a
	<literal>ttyv</literal> résszel kezdõdõ
	sorok:</para>

      <programlisting># name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>Az állományban található
	oszlopok kimerítõ magyarázatát,
	illetve a virtuális konzolok
	beállításához
	használható kapcsolókat a &man.ttys.5; man
	oldalon olvashatjuk.</para>

    </sect2>

    <sect2 xml:id="consoles-singleuser">
      <title>Az egyfelhasználós mód
	konzolja</title>

      <para>Az <quote>egyfelhasználós mód</quote>
	részletes leírása a <xref linkend="boot-singleuser"/>ban található.  Fontos
	tudni, hogy amikor a &os;-t egyfelhasználós
	módban futtatjuk, csupán egyetlen konzolunk van,
	és a virtuális konzolok nem érhetõek
	el.  Egyébként az egyfelhasználós
	mód erre vonatkozó
	beállításai is megtalálhatóak
	az <filename>/etc/ttys</filename> állományban.
	Ehhez keressük meg a <literal>console</literal>
	kezdetû sort:</para>

      <programlisting># name  getty                           type    status          comments
#
# Ha a konzolt "insecure" (nem biztonságos) típusúnak választjuk meg,
# akkor a használatához az egyfelhasználós mód aktivilásá elõtt a rendszer
# kérni fogja a rendszeradminisztrátori jelszót.
console none                            unknown off secure</programlisting>

      <note>
	<para>A <literal>console</literal> felett látható
	  megjegyzés jelzi, hogy át tudjuk írni
	  ebben a sorban a <literal>secure</literal>
	  (biztonságos) értékû
	  paramétert <literal>insecure</literal> (nem
	  biztonságos) értékûre.  Ilyenkor,
	  hogy ha a &os; egyfelhasználós módban
	  indul, kérni fogja a <systemitem class="username">root</systemitem>
	  felhasználó (a rendszeradminisztrátor)
	  jelszavát.</para>

	<para><emphasis>Vigyázzunk, amikor ezt az
	  értéket <literal>insecure</literal>-ra
	  állítjuk!</emphasis> Ha ugyanis
	  véletlenül elfeledkeznénk a
	  <systemitem class="username">root</systemitem> jelszaváról, akkor
	  azzal az egyfelhasználós mód
	  használata is veszélybe kerülhet.
	  Habár ettõl függetlenül is
	  lehetséges, azokra számára mégis
	  nehéz helyzetnek bizonyulhat, akik nem mozognak
	  elég otthonosan a &os; rendszerindítási
	  folyamatának és a
	  hozzákapcsolódó programok
	  ismeretében.</para>
      </note>

    </sect2>

    <sect2 xml:id="consoles-vidcontrol">
      <title>A videomód váltása konzolban</title>

      <para>A &os; konzol alapértelmezett videomódja
	átállítható 1024x768-ra,
	1280x1024-re, vagy bármilyen olyan más
	méretre, amit a videokártyánk
	és monitorunk képes megjeleníteni.  Az
	eltérõ videomódok használatához
	elõször újra kell fordítanunk a
	rendszermagunkat az alábbi két
	beállítás
	hozzáadásával:</para>

      <programlisting>options VESA
options SC_PIXEL_MODE</programlisting>

      <para>Miután a rendszermagot sikeresen
	újrafordítottuk a fenti
	beállításokkal, a &man.vidcontrol.1;
	segédprogrammal tudjuk megállapítani, hogy
	a hardverünk milyen videomódokat enged
	használni.  Az összes támogatott
	videomódot a következõképpen tudjuk
	lekérdezni:</para>

      <screen>&prompt.root; <userinput>vidcontrol -i mode</userinput></screen>

      <para>A parancs eredményeképpen tehát
	megkapjuk a hardverünk által ismert
	videomódokat.  Ezek közül tudjuk
	kiválasztani valamelyikõjüket és
	<systemitem class="username">root</systemitem> felhasználóként a
	&man.vidcontrol.1; segítségével
	beállítani:</para>

      <screen>&prompt.root; <userinput>vidcontrol MODE_279</userinput></screen>

      <para>Ha az új videomód megfelel számunkra,
	akkor ezt a beállítást az
	<filename>/etc/rc.conf</filename> állományon
	keresztül véglegesíthetjük is:</para>

      <programlisting>allscreens_flags="MODE_279"</programlisting>

    </sect2>
  </sect1>

  <sect1 xml:id="permissions">
    <title>Engedélyek</title>

    <indexterm><primary>UNIX</primary></indexterm>

    <para>A &os;, mivel a BSD &unix; egyik közvetlen
      leszármazottja, számos &unix;-os alapötletre
      épül.  Ezek közül az elsõ és
      talán a leginkább kihangsúlyozott, hogy a
      &os; egy többfelhasználós
      operációs rendszer.  Egy olyan rendszer, amely
      egyszerre több, egymástól független
      feladattal foglalkozó felhasználót
      képes kiszolgálni.  A rendszer felelõs a
      hardveres eszközök, a különféle
      perifériák, a memória és a processzor
      idejének minden egyes felhasználó
      számára szabályos és pártatlan
      megosztásáért és a feléjük
      irányuló kérések
      szervezéséért.</para>

    <para>Mivel a rendszer több felhasználót is
      képes támogatni, az általa kezelt
      erõforrások rendelkeznek engedélyek egy adott
      halmazával, amelyek eldöntik, ki tudja ezeket olvasni,
      írni és végrehajtani.  Az engedélyek
      háromszor három bit formájában
      jelennek meg, amelyek közül az elsõ bitcsoport az
      állomány tulajdonosára, a második az
      állomány csoportjára, végül az
      utolsó pedig a mindenki másra vonatkozó
      engedélyeket tárolja.</para>

    <indexterm><primary>engedélyek</primary></indexterm>
    <indexterm><primary>állományok
      engedélyei</primary></indexterm>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Érték</entry>
	    <entry>Engedély</entry>
	    <entry>Könyvtárlistában</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>Nem olvasható, nem írható, nem
	      hajtható végre</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>Nem olvasható, nem írható,
	      végrehajtható</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>Nem olvasható, írható, nem
	      hajtható végre</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>Nem olvasható, írható,
	      végrehajtható</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Olvasható, nem írható, nem
	      hajtható végre</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Olvasható, nem írható,
	      végrehajtható</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Olvasható, írható, nem
	      hajtható végre</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Olvasható, írható,
	      végrehajtható</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary><command>ls</command></primary></indexterm>
    <indexterm><primary>könyvtárak</primary></indexterm>

    <para>A &man.ls.1; <option>-l</option> kapcsolójának
      segítségével megnézhetjük a
      könyvtárak tartalmának részletes
      listáját, amiben megjelennek az
      állományok tulajdonosaira, csoportjára
      és a mindenki másra vonatkozó
      engedélyek is.  Például ezt láthatjuk,
      ha kiadjuk az <command>ls -l</command> parancsot egy
      tetszõleges könyvtárban:</para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 egyik
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 masik
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 e-mail.txt
...</screen>

    <para>A példabeli <command>ls -l</command> parancs
      kimenetének elsõ oszlopa így bomlik fel:</para>

    <screen>-rw-r--r--</screen>

    <para>Az elsõ (bal szélsõ) karakter mondja meg,
      hogy ez egy hagyományos állomány,
      könyvtár, speciális karakteres eszköz,
      socket vagy bármilyen más különleges
      pszeudoállomány.  Ebben az esetben a
      <literal>-</literal> jelzi, hogy egy hagyományos
      állományról van szó.  A
      következõ három karakter, ami ebben a
      példában az <literal>rw-</literal>, adja meg az
      állomány tulajdonosának engedélyeit.
      Az ezután következõ három karakter, az
      <literal>r--</literal> mutatja az állomány
      csoportjának engedélyeit.  Az utolsó
      három karakter, vagyis itt az <literal>r--</literal> adja
      meg a többiek engedélyeit.  A kötõjel arra
      utal, hogy az adott engedélyû
      tevékenység nem engedélyezett.  Tehát
      ennél az állománynál az
      engedélyek a következõek: a tulajdonosa tudja
      olvasni és írni, a csoportja csak olvasni tudja,
      ugyanígy bárki más.  A fenti
      táblázatnak megfelelõen az
      állomány engedélyének kódja
      <literal>644</literal> lesz, ahol az egyes számjegyek
      jelentik az állomány engedélyeinek
      három elemét.</para>

    <para>Ez mind szép és jó, de vajon a rendszer
      milyen módon kezeli az állományok
      engedélyeit?  A &os; a legtöbb hardveres eszközt
      állománynak tekinti, amelyeket a programok meg
      tudnak nyitni, tudnak róluk olvasni és adatokat
      tudnak kiírni rájuk pontosan úgy, mint
      bármilyen más állomány esetén.
      Ezeket a speciális állományokat a
      <filename>/dev</filename> könyvtárban
      találjuk.</para>

    <para>A könyvtárakat is
      állományokként kezeli, ezért azok is
      rendelkeznek olvasási, írási és
      végrehajtási engedélyekkel.  Azonban a
      könyvtárak végrehajtását
      engedélyezõ bit némileg más
      jelentéssel bír, mint az állományok
      esetén.  Amikor ugyanis egy könyvtárat
      végrehajthatónak jelölünk meg, az arra fog
      utalni, hogy bele tudunk lépni, vagyis hogy ki tudjuk
      rá adni a
      <quote>könyvtárváltás</quote> (cd,
      change directory) parancsát.  Ez továbbá arra
      is utal, hogy az ismert nevû állományokhoz
      hozzá tudunk férni (természetesen az egyes
      állományok engedélyeinek
      megfelelõen).</para>

    <para>A könyvtárak tartalmát ennek
      megfelelõen viszont csak úgy láthatjuk, ha
      olvasási engedéllyel rendelkezünk a
      könyvtárra, míg egy általunk ismert
      állomány törléséhez a
      tartalmazó könyvtárhoz kell írási
      <emphasis>és</emphasis> végrehajtási
      engedélyekkel rendelkeznünk.</para>

    <para>Ezeken kívül még léteznek
      további engedélyek is, de ezeket csak olyan
      különleges esetekben használják, mint
      például a
      felhasználóváltó programok (setuid
      program) vagy a ragadós könyvtárak (sticky
      directory) létrehozása.  Az állományok
      engedélyeinek behatóbb megismeréséhez
      és beállításához
      mindenképpen nézzük át a &man.chmod.1;
      man oldalt.</para>

    <sect2>
      <info><title>Szimbolikus engedélyek</title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Írta: </contrib></author>
	</authorgroup>
      </info>

      

      <indexterm>
	<primary>engedélyek</primary>
	<secondary>szimbolikus</secondary>
      </indexterm>

      <para>A szimbolikus engedélyek (gyakran csak szimbolikus
	kifejezések) az állományok és
	könyvtárak engedélyeinek megadása
	során a számok helyett karaktereket
	használnak.  A szimbolikus kifejezések (ki)
	(hogyan) (milyen engedélyt) alakúak, ahol az
	alábbi értékek adhatóak meg:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Elem</entry>
	      <entry>Betû</entry>
	      <entry>Jelentése</entry>
	    </row>
	  </thead>

	<tbody>
	  <row>
	    <entry>(ki)</entry>
	    <entry>u</entry>
	    <entry>tulajdonos</entry>
	  </row>

	  <row>
	    <entry>(ki)</entry>
	    <entry>g</entry>
	    <entry>csoport tulajdonos</entry>
	  </row>

	  <row>
	    <entry>(ki)</entry>
	    <entry>o</entry>
	    <entry>egyéb</entry>
	  </row>

	  <row>
	    <entry>(ki)</entry>
	    <entry>a</entry>
	    <entry>mindenki (a <quote>világ</quote>)</entry>
	  </row>

	  <row>
	    <entry>(hogyan)</entry>
	    <entry>+</entry>
	    <entry>engedély megadása</entry>
	  </row>

	  <row>
	    <entry>(hogyan)</entry>
	    <entry>-</entry>
	    <entry>engedély visszavonása</entry>
	  </row>

	  <row>
	    <entry>(hogyan)</entry>
	    <entry>=</entry>
	    <entry>engedély explicit
	      beállítása</entry>
	  </row>

	  <row>
	    <entry>(milyen engedély)</entry>
	    <entry>r</entry>
	    <entry>olvasás</entry>
	  </row>

	  <row>
	    <entry>(milyen engedély)</entry>
	    <entry>w</entry>
	    <entry>írás</entry>
	  </row>

	  <row>
	    <entry>(milyen engedély)</entry>
	    <entry>x</entry>
	    <entry>végrehajtás</entry>
	  </row>

	  <row>
	    <entry>(milyen engedély)</entry>
	    <entry>t</entry>
	    <entry>ragadós (sticky bit)</entry>
	  </row>

	  <row>
	    <entry>(milyen engedély)</entry>
	    <entry>s</entry>
	    <entry>UID vagy GID állítása</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

      <para>Ezek az értékek a &man.chmod.1; paranccsal az
	eddigiekhez hasonló módon
	használhatóak, csak itt betûket kell
	megadnunk.  Például az alábbi paranccsal
	akadályozhatjuk meg, hogy a tulajdonosán
	kívül bárki hozzáférhessen az
	<replaceable>ÁLLOMÁNY</replaceable> nevû
	állományhoz:</para>

      <screen>&prompt.user; <userinput>chmod go= ÁLLOMÁNY</userinput></screen>

      <para>Amennyiben egy állománnyal kapcsolatban
	több változtatást is el
	kívánunk végezni, össze tudjuk ezeket
	fûzni egy vesszõkkel elhatárolt
	felsorolásban:</para>

      <screen>&prompt.user; <userinput>chmod go-w,a+x ÁLLOMÁNY</userinput></screen>

   </sect2>

    <sect2>
      <info><title>A &os; állományjelzõi</title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Írta: </contrib></author>
	</authorgroup>
      </info>

      

      <para>A korábban tárgyalt engedélyek mellett
	még a &os; ismeri az ún.
	<quote>állományjelzõk</quote> (file flags)
	beállítását is.  Ezek a
	jelzõbitek egy további biztonsági és
	irányítási szintet nyújtanak az
	állományok felett, viszont a
	könyvtárakra nem vonatkoznak.</para>

      <para>Ezek az állományjelzõk az
	állományok felett további
	vezérlést adnak a kezünkbe, aminek
	révén gondoskodhatunk róla, hogy
	akár még a <systemitem class="username">root</systemitem>
	felhasználó (a rendszer adminisztrátora) se
	legyen képes állományokat
	eltávolítani vagy módosítani.</para>

      <para>Az állományjelzõk értékei
	egy egyszerû felületen keresztül, a
	&man.chflags.1; segédprogrammal
	változtathatóak meg.  Például a
	következõ paranccsal állíthatjuk a
	rendszer törölhetetlen (undeletable)
	jelzését az <filename>allomany1</filename>
	állományon:</para>

      <screen>&prompt.root; <userinput>chflags sunlink allomany1</userinput></screen>

      <para>A törölhetetlen jelzés
	eltávolításához egyszerûen csak
	írjuk be az elõzõ parancsot úgy, hogy a
	<quote>sunlink</quote> paraméter elejére
	még beszúrunk egy <quote>no</quote>
	szövegrészt.  Így:</para>

      <screen>&prompt.root; <userinput>chflags nosunlink allomany1</userinput></screen>

      <para>Az állományokra éppen
	érvényes jelzéseket az &man.ls.1; parancs
	<option>-lo</option> kapcsolójának
	segítségével jeleníthetjük
	meg:</para>

      <screen>&prompt.root; <userinput>ls -lo file1
	</userinput></screen>

      <para>Ennek megfelelõen az eredménynek valahogy
	így kellene kinéznie:</para>

      <programlisting>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 allomany1</programlisting>

      <para>Sok jelzés csak a <systemitem class="username">root</systemitem>
	felhasználón keresztül vehetõ fel vagy
	távolítható el.  Más esetekben
	viszont az állomány tulajdonosa
	állíthatja ezeket.  A rendszergazdáknak
	javasoljuk, hogy ezzel kapcsolatban a &man.chflags.1; és
	&man.chflags.2; man oldalakat tanulmányozzák
	át.</para>
    </sect2>

    <sect2>
      <info><title>A setuid, setgid és sticky engedélyek</title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Készítette: </contrib></author>
	</authorgroup>
      </info>

      

      <para>A korábban említett engedélyeken
	kívül létezik még további
	három, amelyekkel minden rendszergazdának illik
	tisztában lennie.  Ezek név szerint a
	<literal>setuid</literal>, <literal>setgid</literal> és
	<literal>sticky</literal> típusú
	engedélyek.</para>

      <para>Ezek a beállítások bizonyos &unix;
	mûveletek esetén nagyon fontosak, mivel az
	átlagos felhasználók számára
	általában el nem érhetõ
	funkciók használatát
	támogatják.  A
	megértésükhöz elsõként a
	felhasználók valódi és
	effektív azonosítója közti
	különbségeket kell tisztáznunk.</para>

      <para>A valódi azonosító
	tulajdonképpen az a felhasználói
	azonosító, amellyel a programot indítjuk el
	vagy futás elõtt birtokoljuk.  A program
	futása közben azonban az effektív
	felhasználói azonosítóval fut.
	Például a &man.passwd.1; segédprogram a
	jelszavát megváltoztatni
	kívánó felhasználó
	valódi azonosítójával indul,
	miközben a jelszavakat tároló
	adatbázis elérésékor már a
	<systemitem class="username">root</systemitem> felhasználó
	effektív azonosítójával fut.
	Ezáltal a privilégiumokkal nem rendelkezõ
	felhasználók is meg tudják
	anélkül változtatni a jelszavaikat, hogy a
	<errorname>Permission Denied</errorname> hibaüzenettel
	találkoznának.</para>

      <note>
	<para>A &man.mount.8; <literal>nosuid</literal>
	  beállításával azonban az ilyen
	  típusú binárisok minden
	  különösebb jel nélkül
	  csõdöt fognak mondani.  Mellesleg a &man.mount.8;
	  man oldala szerint ez az opció nem is teljesen
	  megbízható, mivel <literal>nosuid</literal>
	  wrapperek segítségével meg lehet
	  kerülni.</para>
      </note>

      <para>Ahogy azt az alábbi példa is
	szemlélteti, a setuid engedélyt a többi
	elé egy négyes (4)
	beszúrásával tudjuk
	beállítani:</para>

      <screen>&prompt.root; <userinput>chmod 4755 suidexample.sh</userinput></screen>

      <para>A
	<filename>suidexample.sh</filename>
	állomány engedélyei ezt követõen
	már így fognak megjelenni:</para>

      <screen>-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh</screen>

      <para>Most már jól látható, hogy az
	állomány tulajdonosához tartozó
	engedélyek között a
	végrehajthatóságot szabályozó
	bit lecserélõdött egy <literal>s</literal>
	bitre.  Ennek köszönhetõen a
	<command>passwd</command> parancshoz hasonló módon
	kibõvített engedélyekkel leszünk
	képesek futtatni programokat.</para>

      <para>Két terminál megnyitásával
	mindezt valós idõben is megvizsgálhatjuk.  Az
	egyiken indítsuk el normál
	felhasználóként a <command>passwd</command>
	programot.  Miközben a program várakozik az
	új jelszó megadására, a másik
	terminálon kérdezzük le a programhoz
	tartozó felhasználói
	információkat.</para>

      <para>Tehát az egyik terminálon a
	következõt látjuk:</para>

      <screen>&prompt.user; <userinput>passwd</userinput>
Changing local password for trhodes
Old Password:</screen>

      <para>Eközben pedig a másikon:</para>

      <screen>&prompt.root; <userinput>ps aux | grep passwd</userinput>
trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd</screen>

      <para>A <command>passwd</command> parancsot egyszerû
	felhasználóként adtunk ki, azonban
	jól látható, hogy valójában a
	<systemitem class="username">root</systemitem> felhasználó
	azonosítójával fut.</para>

      <para>A <literal>setgid</literal> a <literal>setuid</literal>
	engedélyhez hasonlóan mûködik,
	egyedül annyiban tér el, hogy a csoportra
	vonatkozó beállításokat
	módosítja.  Amikor egy alkalmazást vagy
	segédprogramot ilyen engedéllyel futtatunk, akkor
	az adott programot birtokló csoport engedélyeit
	kapjuk meg.</para>

      <para>Úgy tudjuk állományokon
	beállítani a <literal>setgid</literal>
	típusú engedélyt, ha az iménti
	példához hasonlóan a
	<command>chmod</command> parancs hívásakor
	még egy kettest (2) írunk az engedélyek
	elé:</para>

      <screen>&prompt.root; <userinput>chmod 2755 sgidexample.sh</userinput></screen>
      <para>Az így beállított engedélyek az
	elõbbihöz hasonló módon
	szemlélhetõek meg, azonban ebben az esetben a
	csoporthoz tartozó engedélyeknél jelenik
	meg az <literal>s</literal> bit:</para>

      <screen>-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh</screen>

      <note>
	<para>Az elõbb tárgyalt példákkal
	  kapcsolatban fontos megemlítenünk, hogy habár
	  a szkriptek is végrehajtható
	  állományok, nem fognak a valóditól
	  eltérõ effektív felhasználói
	  azonosítóval futni.  Ennek oka abban
	  keresendõ, hogy a parancssori szkriptek nem
	  hívhatják a &man.setuid.2;
	  rendszerhívást.</para>
      </note>

      <para>Ez a két speciális engedély (a
	<literal>setuid</literal> és a <literal>setgid</literal>) a
	programhoz tartozó engedélyek
	kiterjesztésével csökkentheti
	rendszerünk biztonságát.  Ezzel szemben
	viszont a harmadik bemutatandó speciális
	engedély rendszerünk védelmének
	erõsítésére szolgál: ez az
	ún.  <literal>sticky</literal> bit.</para>

      <para>Ha a <literal>sticky</literal> típusú
	engedélyt könyvtárra adjuk meg, akkor a benne
	levõ állományok törlését
	kizárólag azok tulajdonosainak engedi.  Ezzel az
	engedéllyel lényegében a <filename>/tmp</filename> könyvtárhoz
	hasonló nyilvános, bárki által
	elérhetõ könyvtárakban
	akadályozhatjuk meg az állományok idegen
	felhasználók általi
	törlését.  Az engedély
	beállításához egy egyest (1) kell a
	többi elé fûznünk, mint
	például:</para>

      <screen>&prompt.root; <userinput>chmod 1777 /tmp</userinput></screen>

      <para>Most már az <command>ls</command> parancs
	segítségével láthatjuk ennek a
	hatását:</para>

      <screen>&prompt.root; <userinput>ls -al / | grep tmp</userinput>
drwxrwxrwt  10 root  wheel          512 Aug 31 01:49 tmp</screen>

      <para>A <literal>sticky</literal> bit a
	beállítások végén
	felbukkanó <literal>t</literal> révén
	azonosítható be.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="dirstructure">
    <title>A könyvtárak elrendezése</title>

    <indexterm><primary>könyvtárhierarchia</primary></indexterm>

    <para>A &os; könyvtárszerkezetének ismerete
      alapvetõ jelentõségû a rendszer
      egészének megértése
      szempontjából.  Ezen belül is a legfontosabb a
      gyökérkönyvtár, a <quote>/</quote>.  Ez az
      elsõ könyvtár, amelyet a rendszer a
      rendszerindítás során csatlakoztat és
      a többfelhasználós mód
      elõkészítéséhez
      elegendhetlenül szükséges alaprendszert
      tartalmazza.  A gyökérkönyvtár emellett
      csatlakozási pontokat szolgáltat a
      többfelhasználós mûködésre
      váltás során csatlakoztatandó
      további állományrendszerek
      számára.</para>

    <para>A csatlakozási pont egy olyan könyvtár,
      ahová a szülõ állományrendszeren
      (ami gyakran maga a
      gyökér-állományrendszer) belül
      további állományrendszereket tudunk beoltani.
      Errõl bõvebben a <xref linkend="disk-organization"/>ban
      olvashatunk.  A szabványos csatlakozási pontok:
      <filename>/usr</filename>, <filename>/var</filename>,
      <filename>/tmp</filename>, <filename>/mnt</filename> és
      <filename>/cdrom</filename>.  Ezekre a könyvtárakra
      általában az <filename>/etc/fstab</filename>
      állományban találunk hivatkozásokat.
      Az <filename>/etc/fstab</filename> állomány a
      rendszer számára a különbözõ
      állományrendszerek és a hozzájuk
      tartozó csatlakozási pontok
      táblázatát tartalmazza.  Az
      <filename>/etc/fstab</filename> állományban
      szereplõ legtöbb állományrendszer a
      rendszerindítás során automatikusan
      csatlakoztatásra kerül az &man.rc.8; szkriptbõl,
      hacsak nem tartalmazzák a <option>noauto</option>
      beállítást.  Ennek részleteit a <xref linkend="disks-fstab"/>ban találhatjuk meg.</para>

    <para>Az állományrendszerek
      hierarchiájának teljes leírását
      a &man.hier.7; man oldalon olvashatjuk.  Mi egyelõre most
      megelégszünk a leggyakrabban megjelenõ
      könyvtárak rövid
      áttekintésével.</para>

    <para>
      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Könyvtár</entry>
	      <entry>Mi található itt</entry>
	    </row>
	  </thead>
	  <tbody valign="top">
	    <row>
	      <entry><filename>/</filename></entry>
	      <entry>Az állományrendszer
		gyökere.</entry>
	    </row>
	    <row>
	      <entry><filename>/bin/</filename></entry>
	      <entry>Az egy- és
		többfelhasználós környezetekben
		is egyaránt alapvetõ
		felhasználói
		segédprogramok.</entry>
	    </row>
	    <row>
	      <entry><filename>/boot/</filename></entry>
	      <entry>Az operációs rendszer
		indítása során használt
		programok és konfigurációs
		állományok.</entry>
	    </row>
	    <row>
	      <entry><filename>/boot/defaults/</filename></entry>
	      <entry>A rendszerindítás
		alapértelmezett konfigurációs
		állományai.  Lásd
		&man.loader.conf.5;</entry>
	    </row>
	    <row>
	      <entry><filename>/dev/</filename></entry>
	      <entry>Eszközleírók, lásd
		&man.intro.4;.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/</filename></entry>
	      <entry>Rendszerkonfigurációs
		állományok és szkriptek.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/defaults/</filename></entry>
	      <entry>Az alapértelmezett
		rendszerkonfigurációs
		állományok, lásd
		&man.rc.8;.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/mail/</filename></entry>
	      <entry>A &man.sendmail.8; programhoz hasonló
		levélküldõ rendszerek
		konfigurációs
		állományai.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/namedb/</filename></entry>
	      <entry>A <command>named</command> program
		konfigurációs állományai,
		lásd &man.named.8;.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/periodic/</filename></entry>
	      <entry>A &man.cron.8; által naponta, hetente
		és havonta lefuttatandó szkriptek,
		lásd &man.periodic.8;.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/ppp/</filename></entry>
	      <entry>A <command>ppp</command> program
		konfigurációs állományai,
		lásd &man.ppp.8;.</entry>
	    </row>
	    <row>
	      <entry><filename>/mnt/</filename></entry>
	      <entry>Egy üres könyvtár, amelyet a
		rendszergazdák általában ideiglenes
		csatlakozási pontként
		használnak.</entry>
	    </row>
	    <row>
	      <entry><filename>/proc/</filename></entry>
	      <entry>A futó programokat tartalmazó
		állományrendszer, lásd
		&man.procfs.5;, illetve &man.mount.procfs.8;.</entry>
	    </row>
	    <row>
	      <entry><filename>/rescue/</filename></entry>
	      <entry>Statikusan linkelt programok vészhelyzet
		esetére, lásd &man.rescue.8;.</entry>
	    </row>
	    <row>
	      <entry><filename>/root/</filename></entry>
	      <entry>A <systemitem class="username">root</systemitem>
		felhasználó könyvtára.</entry>
	    </row>
	    <row>
	      <entry><filename>/sbin/</filename></entry>
	      <entry>Az egy- és
		többfelhasználós környezetekben
		fontos rendszerprogramok és
		rendszerfelügyeleti eszközök.</entry>
	    </row>
	    <row>
	      <entry><filename>/tmp/</filename></entry>
	      <entry>Átmeneti állományok.  A
		<filename>/tmp</filename>
		könyvtár tartalma általában
		NEM marad meg az újraindítás
		után.  Erre a célra gyakran
		memóriában létrehozott
		állományrendszert szoktak csatlakoztatni a
		<filename>/tmp</filename>
		könyvtárba.  Ez utóbbit az
		&man.rc.conf.5; tmpmfs-re vonatkozó
		változóinak
		beállításával lehet
		automatikussá tenni (vagy a
		<filename>/etc/fstab</filename> megfelelõ
		módosításával, lásd
		&man.mdmfs.8;).</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/</filename></entry>
	      <entry>A felhasználói programok és
		alkalmazások többsége.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/bin/</filename></entry>
	      <entry>Általános segédprogramok,
		programozási eszközök és
		alkalmazások.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/include/</filename></entry>
	      <entry>Szabványos C
		include-állományok.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/lib/</filename></entry>
	      <entry>Függvénykönyvtárak.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/libdata/</filename></entry>
	      <entry>Egyéb hasznos
		adatállományok.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/libexec/</filename></entry>
	      <entry>(Más programok által használt)
		Rendszerdémonok és
		rendszereszközök.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/local/</filename></entry>
	      <entry>A helyi rendszeren telepített programok,
		függvénykönyvtárak stb.  A &os;
		portrendszere is ezt használja
		alapértelmezés szerint.  A
		<filename>/usr/local</filename> könyvtáron
		belül a &man.hier.7; man oldalon
		található <filename>/usr</filename>
		könyvtár általános
		felépítése használatos.  Ez
		alól kivételt képez a man
		alkönyvtár, amely közvetlenül a
		<filename>/usr/local</filename> alatt
		található, nem pedig a
		<filename>/usr/local/share</filename>
		könyvtáron belül, valamint a portok
		dokumentációja a
		<filename>share/doc/port</filename>
		könyvtárban található.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/obj/</filename></entry>
	      <entry>A <filename>/usr/src</filename>
		könyvtárfában található
		források fordítása során
		keletkezõ architektúrafüggõ
		objektumok.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/ports/</filename></entry>
	      <entry>A &os; Portgyûjtemény
		(választható).</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/sbin/</filename></entry>
	      <entry>(A felhasználók által
		használt) Rendszerdémonok és
		rendszereszközök.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/share/</filename></entry>
	      <entry>Architektúrafüggõ
		állományok.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/src/</filename></entry>
	      <entry>BSD és/vagy helyi források.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/X11R6/</filename></entry>
	      <entry>Az X11R6 rendszer programjai,
		függvénykönyvtárai stb.
		(választható)</entry>
	    </row>
	    <row>
	      <entry><filename>/var/</filename></entry>
	      <entry>Különféle napló,
		átmeneti, ideiglenes és pufferben
		tárolt állományok.  A
		memóriában létrehozott
		állományrendszereket is olykor a <filename>/var</filename>
		könyvtárban találjuk.  Ezt az
		&man.rc.conf.5; állományban
		található varmfs-változók
		beállításával tehetjük
		automatikussá (vagy a
		<filename>/etc/fstab</filename> megfelelõ
		módosításával, lásd
		&man.mdmfs.8;).</entry>
	    </row>
	    <row>
	      <entry><filename>/var/log/</filename></entry>
	      <entry>Mindenféle rendszernaplók.</entry>
	    </row>
	    <row>
	      <entry><filename>/var/mail/</filename></entry>
	      <entry>A felhasználók postafiókjait
		tároló állományok.</entry>
	    </row>
	    <row>
	      <entry><filename>/var/spool/</filename></entry>
	      <entry>A nyomtatók és a levelezés
		puffereléséhez használt
		könyvtárak.</entry>
	    </row>
	    <row>
	      <entry><filename>/var/tmp/</filename></entry>
	      <entry>Átmeneti állományok.  Az itt
		található állományok
		általában megmaradnak a
		következõ rendszerindítás
		alkalmával is, hacsak a <filename>/var</filename> nem egy
		memóriában létezõ
		állományrendszer.</entry>
	    </row>
	    <row>
	      <entry><filename>/var/yp</filename></entry>
	      <entry>A NIS állományai.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </para>

  </sect1>

  <sect1 xml:id="disk-organization">
    <title>A lemezek szervezése</title>

    <para>Az állománynév a legkisebb
      szervezési egység, amin keresztül a &os;
      képes megtalálni az állományokat.  Az
      állományok neveiben a kis- és nagybetût
      megkülönböztetjük, tehát a
      <filename>readme.txt</filename> és a
      <filename>README.TXT</filename> elnevezés két
      különbözõ állományra utal.  A
      &os; nem az állományok kiterjesztése (ami a
      konkrét példánkban a
      <filename>.txt</filename> volt) alapján dönti el, hogy
      az adott állomány vajon program, dokumentum vagy
      valamilyen más fajtájú adat.</para>

    <para>Az állományok könyvtárakban
      tárolódnak.  Egy könyvtár lehet
      akár üres (nincs benne egyetlen állomány
      sem), vagy többszáz állományt is
      tartalmazhat.  Egy könyvtár ráadásul
      további könyvtárakat is tárolhat,
      és így az egymásban elhelyezkedõ
      könyvtárak segítségével
      könyvtárak egy hierarchiáját tudjuk
      felépíteni.  Ezzel sokkalta könnyebben
      szervezhetõvé válnak az adataink.</para>

    <para>Az állományokat és
      könyvtárakat úgy tudjuk elérni, ha
      megadjuk az állomány vagy a könyvtárt
      tároló könyvtár nevét, amit egy
      perjel, a <literal>/</literal> követ, valamint így
      összefûzve az eléréshez
      szükséges további könyvtárak
      felsorolása.  Tehát, ha van egy
      <filename>ize</filename> nevû könyvtárunk,
      amelyben található egy <filename>mize</filename>
      könyvtár, amelyen belül pedig egy
      <filename>readme.txt</filename>, akkor ennek az
      állománynak a teljes neve, vagy
      másképpen szólva az
      <firstterm>elérési útja</firstterm>
      <filename>ize/mize/readme.txt</filename> lesz.</para>

    <para>A könyvtárak és az állományok
      egy állományrendszerben tárolódnak.
      Minden állományrendszer pontosan egy
      könyvtárat tartalmaz a legfelsõ szintjén,
      amelyet az adott állományrendszer
      <firstterm>gyökérkönyvtárának</firstterm>
      nevezünk.  Ez a gyökérkönyvtár
      tartalmazhat aztán további
      könyvtárakat.</para>

    <para>Eddig még valószínûleg minden nagyon
      hasonló a más operációs rendszerekben
      tapasztalható fogalmakhoz.  Azonban adónak
      különbségek: például az &ms-dos; a
      <literal>\</literal> jellel választja el az
      állományok és könyvtárak neveit,
      miközben a &macos; erre a <literal>:</literal> jelet
      használja.</para>

    <para>A &os; az elérési utakban sem betûkkel, sem
      pedig semmilyen más névvel nem jelöli meg a
      meghajtókat.  Tehát a &os;-ben nem írhatjuk,
      hogy a <filename>c:/ize/mize/readme.txt</filename>.</para>

    <para>Helyette az egyik állományrendszert
      kijelölik
      <firstterm>gyökér-állományrendszernek</firstterm>.
      A gyökér-állományrendszer
      gyökérkönyvtárára hivatkoznak
      késõbb <literal>/</literal>
      könyvtárként.  Ezután minden más
      állományrendszert a
      gyökér-állományrendszerhez
      <firstterm>csatlakoztatunk</firstterm>.  Ennek
      értelmében nem számít, hogy mennyi
      lemezünk is van a &os; rendszerünkben, hiszen minden
      könyvtár egyazon lemez részeként jelenik
      meg.</para>

    <para>Tegyük fel, hogy van három
      állományrendszerünk, hívjuk ezeket
      <literal>A</literal>-nak, <literal>B</literal>-nek és
      <literal>C</literal>-nek.  Minden állományrendszer
      rendelkezik egy gyökérkönyvtárral, amely
      két további könyvtárat tartalmaz:
      <literal>A1</literal>-et és <literal>A2</literal>-t
      (és ennek megfelelõen a többi
      <literal>B1</literal>-et és <literal>B2</literal>-t,
      valamint <literal>C1</literal> és
      <literal>C2</literal>-t).</para>

    <para>Nevezzük <literal>A</literal>-t a
      gyökér-állományrendszernek.  Ha a
      könyvtár tartalmának
      megjelenítéséhez most kiadnánk az
      <command>ls</command> parancsot, két
      alkönyvtárat látnánk, az
      <literal>A1</literal>-et és <literal>A2</literal>-t.  A
      létrejött könyvtárfa valahogy így
      nézne ki:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir1"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
      </textobject>
    </mediaobject>

    <para>Egy állományrendszert csak egy másik
      állományrendszer valamelyik
      könyvtárába tudunk csatlakoztatni.
      Ezért most tételezzük fel, hogy a
      <literal>B</literal> állományrendszert az
      <literal>A1</literal> könyvtárba csatlakoztatjuk.
      Ezután a <literal>B</literal>
      gyökérkönyvtára átveszi a
      <literal>A1</literal> helyét az
      állományrendszerben, és ennek
      megfelelõen megjelennek a <literal>B</literal>
      könyvtárai is:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir2"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
      </textobject>
    </mediaobject>

    <para>A <literal>B1</literal> vagy <literal>B2</literal>
      könyvtárakban található
      állományok bármelyike innentõl kezdve a
      <filename>/A1/B1</filename>, illetve a <filename>/A1/B2</filename>
      elérési utakon érhetõek el.  Az
      <filename>A1</filename> könyvtárban
      található állományok erre az
      idõre rejtve maradnak.  Akkor fognak újra felbukkanni,
      ha a <literal>B</literal> állományrendszert
      <firstterm>leválasztjuk</firstterm> az <literal>A</literal>
      állományrendszerrõl.</para>

    <para>Ha a <literal>B</literal> állományrendszert az
      <literal>A2</literal> könyvtárba
      csatlakoztatnánk, az iménti ábra
      nagyjából így nézne ki:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir3"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
      </textobject>
    </mediaobject>

    <para>és ennek megfelelõen az elõbb tárgyalt
      elérési utak <filename>/A2/B1</filename> és
      <filename>/A2/B2</filename> lennének.</para>

    <para>Az állományrendszerek egymáshoz is
      csatlakoztathatóak.  A példát ennek
      megfelelõen úgy is folytathatjuk, hogy a
      <literal>C</literal> állományrendszert
      csatlakoztatjuk <literal>B</literal>
      állományrendszerben található
      <literal>B1</literal> könyvtárhoz.  Ennek
      eredménye a következõ elrendezés
      lesz:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir4"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
      </textobject>
    </mediaobject>

    <para>Vagy a <literal>C</literal> állományrendszer az
      <literal>A1</literal> könyvtáron keresztül
      csatlakoztatható akár közvetlenül az
      <literal>A</literal> állományrendszerhez is:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir5"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
      </textobject>
    </mediaobject>

    <para>Az &ms-dos; operációs rendszert ismerõk
      számára ez hasonló lehet a
      <command>join</command> parancshoz (habár teljesen nem
      egyezik meg vele).</para>

    <para>Általában azonban ezzel nem kell
      törõdnünk, hiszen többnyire csak a &os;
      telepítése során hozunk létre
      állományrendszereket és választjuk meg
      a csatlakozási pontjukat.  A késõbbiekben
      ez legfeljebb akkor kerül elõ ismét, amikor
      újabb lemezeket adunk hozzá a rendszerhez.</para>

    <para>Teljességgel megengedhetõ, hogy elhagyjuk a
      többit és csak egyetlen óriási
      gyökér-állományrendszert
      használjunk.  Ennek viszont megvannak a maga
      hátrányai és az egyetlen elõnye.</para>

    <itemizedlist>
      <title>Több állományrendszer
	használatának elõnyei</title>

      <listitem>
	<para>A különbözõ
	  állományrendszereknek
	  különbözõ
	  <firstterm>csatlakoztatási
	  beállításai</firstterm> (mount options)
	  lehetnek.  Például, ha kellõen
	  elõvigyázatosak akarunk lenni, a
	  gyökér-állományrendszer
	  írásvédett módon is
	  csatlakoztatható, aminek köszönhetõen
	  lehetetlenné válik a rendszer
	  számára fontos állományok
	  véletlen törlése vagy
	  felülírása.  Ha
	  elkülönítjük a
	  felhasználók számára
	  írható állományrendszereket
	  (például a <filename>/home</filename>
	  könyvtárakat) a többi
	  állományrendszertõl, lehetõvé
	  válik számunkra, hogy
	  <firstterm>nosuid</firstterm>
	  beállítással csatlakoztassuk ezeket.  Ez
	  a beállítás megakadályozza, hogy
	  ezekben a
	  <firstterm>suid</firstterm>/<firstterm>guid</firstterm>
	  bitekkel rendelkezõ végrehajtható
	  állományok használhatóak legyenek,
	  ezáltal növeli a rendszer
	  biztonságosságát.</para>
      </listitem>

      <listitem>
	<para>A &os; az állományrendszer
	  használatától függõen
	  magától határoz a benne
	  található állományok
	  optimális kiosztását illetõen.
	  Így tehát a gyakorta módosított,
	  kisebb állományokat tartalmazó
	  állományrendszerek esetén teljesen
	  más technikákat alkalmaz, mint
	  például a nagyobb, kevésbé
	  változó állományok esetén.
	  Azonban egyetlen állományrendszer
	  használatával ez a gyorsítási
	  módszer odavész.</para>
      </listitem>

      <listitem>
	<para>Noha a &os; állományrendszerei nagyon
	  jól tûrik a hirtelen
	  áramkimaradásokat, egy döntõ ponton
	  bekövetkezõ váratlan leállás
	  mégis kárt okozhat a szerkezetükben.  Ha
	  azonban több állományrendszerre osztjuk a
	  tárolandó adatainkat, sokkal
	  valószínûbbé válik, hogy egy
	  ilyen eset után a rendszerünk talpra tud
	  állni, és szükség esetén
	  nekünk is könnyebb lesz a biztonsági
	  mentéseinkbõl helyreállítani a
	  sérült állományokat.</para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
	<title>Egyetlen állományrendszer
	  használatának elõnyei</title>

	<listitem>
	  <para>Az állományrendszerek mérete
	    rögzített.  Miután a &os;
	    telepítése során létrehoztunk
	    egy adott méretû
	    állományrendszert, elõfordulhat, hogy
	    késõbb szükségünk lesz a
	    méretének növelésére.
	    Ilyenkor nehezen kerülhetjük el az ilyenkor
	    szokásos teendõket: biztonsági
	    mentés készítése, az új
	    méretnek megfelelõ
	    állományrendszer létrehozása,
	    majd ezután a lementett adataink
	    visszaállítása.</para>

	  <important>
	    <para>A &os;-ben azonban megtalálható a
	      &man.growfs.8; parancs, amelynek
	      segítségével az
	      állományrendszerek mérete
	      használat közben növelhetõ,
	      és ezzel megszûnik a méretre
	      vonatkozó korlátozás.</para>
	  </important>
	</listitem>
    </itemizedlist>

    <para>Az állományrendszerek partíciókban
      tárolódnak.  A &os; &unix;-os eredete miatt azonban
      ez a kifejezés nem a hétköznapi
      <quote>partíció</quote> jelentését
      takarja (mint például egy &ms-dos;
      partíció).  Minden partíciót egy
      betû azonosít <literal>a</literal>-tól
      <literal>h</literal>-ig.  Mindegyik partíció csak
      egyetlen állományrendszert tartalmazhat, aminek
      révén az állományrendszereket vagy az
      állományrendszerek hierarchiájában
      található csatlakozási pontjukkal vagy pedig
      az ezeket tartalmazó partíció
      betûjével azonosíthatjuk.</para>

    <para>A &os; ezeken felül külön lemezterülen
      tárolja a
      <firstterm>lapozóállomány</firstterm>t (swap
      space).  A lapozóállományt használja a
      &os; <firstterm>virtuális memória</firstterm>
      (virtual memory) megvalósításához.
      Ennek köszönhetõen a
      számítógép képes úgy
      viselkedni, mintha jóval több memóriával
      rendelkezne, mint valójában.  Így, amikor a
      &os; kifogy a memóriából, egyszerûen
      kirakja a memóriából a
      lapozóállományba az éppen nem
      használt adatokat, majd amikor ismét
      szüksége lesz rájuk, visszatölti ezeket
      (és ilyenkor megint kirak valami mást).</para>

    <para>Némely partícióhoz kötõdnek
      bizonyos megszokások.</para>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<colspec colwidth="1*"/>
	<colspec colwidth="5*"/>
	<thead>
	  <row>
	    <entry>Partíció</entry>
	    <entry>Megszokás</entry>
	  </row>
	</thead>
	<tbody valign="top">
	  <row>
	    <entry><literal>a</literal></entry>
	    <entry>Általában ez tartalmazza a
	      gyökér-állományrendszert.</entry>
	  </row>
	  <row>
	    <entry><literal>b</literal></entry>
	    <entry>Általában ez tartalmazza a
	      lapozóállományt.</entry>
	  </row>
	  <row>
	    <entry><literal>c</literal></entry>
	    <entry>Mérete általában a
	      tartalmazó slice méretével egyezik
	      meg.  Ennek köszönhetõen a
	      segédprogramok (például egy
	      hibás szektorokat keresõ program) a
	      <literal>c</literal> partíción
	      keresztül képesek akár az egész
	      slice-szal dolgozni.  Normális esetben ezen a
	      partíción nem hozunk létre
	      állományrendszert.</entry>
	  </row>
	  <row>
	    <entry><literal>d</literal></entry>
	    <entry>A <literal>d</literal> partícióhoz
	      egykoron kapcsolódott különleges
	      jelentés, azonban mostanra ez már
	      megszûnt, és a <literal>d</literal> egy
	      teljesen átlagos partíciónak
	      tekinthetõ.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Minden állományrendszert tartalmazó
      partíciót a &os; egy ún.
      <firstterm>slice</firstterm>-ban tárol.  A &os;
      számára a slice elnevezés utal mindarra, amit
      általában partíciónak neveznek,
      és ismét megemlítjük, mindez a &unix;-os
      eredet miatt.  A slice-okat 1-tõl 4-ig
      sorszámozzák.</para>

    <indexterm><primary>slice-ok</primary></indexterm>
    <indexterm><primary>partíciók</primary></indexterm>
    <indexterm><primary>veszélyesen dedikált</primary></indexterm>

    <para>A slice-ok sorszáma 1-tõl indulva az
      eszközök neve után egy <literal>s</literal>
      betûvel elválasztva következik.  Így
      tehát a <quote>da0<emphasis>s1</emphasis></quote>
      jelentése az elsõ slice lesz az elsõ
      SCSI-meghajtón.  Lemezenként négy fizikai
      slice hozható létre, de ezeken belül
      tetszõleges típusú logikai slice-ok
      helyezhetõek el.  Ezen további slice-ok
      sorszámozása 5-tõl kezdõdik, így
      ennek megfelelõen a <quote>ad0<emphasis>s5</emphasis></quote>
      lesz az elsõ IDE-lemezen található elsõ
      kiterjesztett slice.  Ezeket az eszközöket
      foglalják el a különbözõ
      állományrendszerek.</para>

    <para>A slice-ok, a <quote>veszélyesen
      dedikált</quote> (Dangerously Dedicated) fizikai
      meghajtók, és minden más olyan
      meghajtó, amely
      <firstterm>partíciókat</firstterm> tartalmaz,
      <literal>a</literal>-tól <literal>h</literal>-ig
      jelölõdnek.  Ez a betû az eszköz neve
      után következik, így ennek megfelelõen a
      <quote>da0<emphasis>a</emphasis></quote> lesz az elsõ
      <quote>da</quote> meghajtó <quote>a</quote>, vagyis a
      <quote>veszélyesen dedikált</quote>
      partíciója.  Az
      <quote>ad1s3<emphasis>e</emphasis></quote> lesz a második
      IDE-lemezmeghajtón a harmadik slice-ban szereplõ
      ötödik partíció.</para>

    <para>Végezetül, a rendszerben minden lemezt
      azonosítunk.  A lemez neve a típusára
      utaló kóddal kezdõdik, amely után
      aztán egy sorszám jelzi, hogy melyik lemezrõl
      is van szó.  Azonban eltérõen a
      slice-okétól, a lemezek sorszámozása
      0-tól indul.  Az általánosan elterjedt
      kódolások a <xref linkend="basics-dev-codes"/>ban
      találhatóak.</para>

    <para>Amikor hivatkozunk egy partícióra, a &os;
      elvárja tõlünk, hogy nevezzük meg az adott
      partíciót tartalmazó slice-ot és
      lemezt is.  Emiatt egy partícióra mindig úgy
      hivatkozunk, hogy elõször megadjuk a tartalmazó
      lemez nevét, ettõl <literal>s</literal>-sel
      elválasztva a tartalmazó slice
      sorszámát, majd ezt a partíció
      betûjelével zárjuk.  Erre
      példákat a <xref linkend="basics-disk-slice-part"/>ban láthatunk.</para>

    <para>Az érhetõség kedvéért a <xref linkend="basics-concept-disk-model"/> bemutatja egy lemez
      kiosztásának fogalmi sablonját.</para>

    <para>A &os; telepítéséhez elõször be
      kell állítani a lemezen található
      slice-okat, majd létrehozni benne a &os;-hez
      használni kívánt partíciókat,
      kialakítani rajtuk az állományrendszereket
      (vagy a lapozóállományt) és
      eldönteni, melyik állományrendszert
      kívánjuk csatlakoztatni.</para>

    <table frame="none" pgwide="1" xml:id="basics-dev-codes">
      <title>Lemezes eszközök kódjai</title>

      <tgroup cols="2">
	<colspec colwidth="1*"/>
	<colspec colwidth="5*"/>
	<thead>
	  <row>
	    <entry>Kód</entry>
	    <entry>Jelentés</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><filename>ad</filename></entry>
	    <entry>ATAPI (IDE) lemez</entry>
	  </row>
	  <row>
	    <entry><filename>da</filename></entry>
	    <entry>közvetlen hozzáférésû
	SCSI lemez</entry>
	  </row>
	  <row>
	    <entry><filename>acd</filename></entry>
	    <entry>ATAPI (IDE) CDROM</entry>
	  </row>
	  <row>
	    <entry><filename>cd</filename></entry>
	    <entry>SCSI CDROM</entry>
	  </row>
	  <row>
	    <entry><filename>fd</filename></entry>
	    <entry>Floppylemez</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <example xml:id="basics-disk-slice-part">
      <title>Példák lemezek, slice-ok és
	partíciók neveire</title>

    <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*"/>
	  <colspec colwidth="5*"/>
	  <thead>
	    <row>
	      <entry>Név</entry>
	      <entry>Jelentés</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><literal>ad0s1a</literal></entry>
	      <entry>Az elsõ IDE lemezen (<literal>ad0</literal>)
		levõ elsõ slice (<literal>s1</literal>)
		elsõ partíciója
		(<literal>a</literal>).</entry>
	    </row>

	    <row>
	      <entry><literal>da1s2e</literal></entry>
	      <entry>A második SCSI-lemzen
		(<literal>da1</literal>) levõ második slice
		(<literal>s2</literal>) ötödik
		partíciója (<literal>e</literal>).</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </example>

    <example xml:id="basics-concept-disk-model">
      <title>Egy lemez kialakításának
	sablonja</title>

    <para>Az ábrán a rendszerhez csatlakoztatott elsõ
	IDE-lemez látható a &os;
	szemszögébõl.  Tegyük fel, hogy ez a lemez
	4&nbsp;GB méretû és két,
	egyenként 2&nbsp;GB méretû slice-ot (avagy
	&ms-dos; partíciót) tartalmaz.  Az elsõ slice
	egy &ms-dos; formátumú lemezt foglal
	magában, a <filename>C:</filename> meghajtót,
	illetve a második slice egy telepített &os;-t
	tartalmaz.  Ebben a példában a &os; három
	adatot és egy lapozóállományt
	tároló partícióval
	rendelkezik.</para>

    <para>A három partíció mindegyikén
	találhatunk egy-egy állományrendszert.  Az
	<literal>a</literal> partíció lesz a
	gyökér-állományrendszer, az
	<literal>e</literal> lesz a rendszerünkben a
	<filename>/var</filename> és az <literal>f</literal>
	pedig a <filename>/usr</filename> könyvtár.</para>

    <mediaobject>
	<imageobject>
	  <imagedata fileref="install/disk-layout"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced">.-----------------.  --.
|                 |    |
|  DOS / Windows  |    |
:                 :     &gt;  Elsõ slice, ad0s1
:                 :    |
|                 |    |
:=================:  ==:                               --.
|                 |    |  a partíció, /      |
|                 |     &gt; ad0s2a néven hivatkozzuk         |
|                 |    |                                 |
:-----------------:  ==:                                 |
|                 |    |  b partíció, lapozóállomány      |
|                 |     &gt; ad0s2b néven hivatkozzuk          |
|                 |    |                                 |
:-----------------:  ==:                                 |  c partíció, nincs
|                 |    |  e partíció, /var       &gt; állományrendszer, az egész
|                 |     &gt; ad0s2e néven hivatkozzuk          |  &os; slice,
|                 |    |                                 |  ad0s2c
:-----------------:  ==:                                 |
|                 |    |                                 |
:                 :    |  f partíció, /usr      |
:                 :     &gt; ad0s2f néven hivatkozzuk          |
:                 :    |                                 |
|                 |    |                                 |
|                 |  --'                                 |
`-----------------'                                    --'</literallayout>
	</textobject>
      </mediaobject>
    </example>

  </sect1>

  <sect1 xml:id="mount-unmount">
    <title>Állományrendszerek csatlakoztatása
      és leválasztása</title>

    <para>Az állományrendszereket legkönnyebben
      egy-egy faként tudjuk magunk elõtt elképzelni,
      amelyek a <filename>/</filename> könyvtárból
      nõnek ki.  A <filename>/dev</filename>,
      <filename>/usr</filename> és mellettük szereplõ,
      hozzájuk hasonló összes többi
      könyvtár csupán egy-egy ág, amelyeknek
      saját ágaik is lehetnek, mint például
      a <filename>/usr/local</filename> és így
      tovább.</para>

    <indexterm><primary>gyökér-állományrendszer</primary></indexterm>

    <para>Különféle okai vannak annak, hogy egyes
      könyvtárakat különálló
      állományrendszereken tárolunk.  A
      <filename>/var</filename> könyvtár tartalmazza a
      <filename>log/</filename>, <filename>spool/</filename>
      könyvtárakat és különféle
      átmeneti állományokat, azonban az ilyen
      állományok könnyen megszaporodhatnak és
      megtölthetik az állományrendszert.  Mivel a
      gyökér-állományrendszert nem
      tanácsos elárasztani mindenféle
      állománnyal, ezért gyakran a hasznunkra
      válhat, ha a <filename>/var</filename>
      könyvtárat leválasztjuk a
      <filename>/</filename> könyvtárból.</para>

    <para>A másik gyakori ok, ami az imént említett
      fa egyes ágainak különbözõ
      állományrendszereken történõ
      tárolását indokolja, hogy ezek gyakran
      más fizikai vagy virtuális lemezeken,
      például a rendszerhez csatlakoztatott <link linkend="network-nfs">Hálózati
      állományrendszer</link>eken vagy éppen
      CD-meghajtókon találhatóak.</para>

    <sect2 xml:id="disks-fstab">
      <title>Az <filename>fstab</filename>
	állomány</title>

      <indexterm>
	<primary>állományrendszerek</primary>
	<secondary>csatlakoztatás az fstab
	  állománnyal</secondary>
      </indexterm>

      <para>A <link linkend="boot">rendszerindítás
	folyamata</link> során az <filename>/etc/fstab</filename>
	állományban felsorolt
	állományrendszerek maguktól kerülnek
	csatlakoztatásra (kivéve amikor a
	<option>noauto</option> beállítással
	szerepelnek).</para>

      <para>Az <filename>/etc/fstab</filename> állományban
	található sorok az alábbi
	szerkezetûek:</para>

      <programlisting><replaceable>eszköz</replaceable>       <replaceable>/csatlakozási-pont</replaceable> <replaceable>típus</replaceable>     <replaceable>beállítások</replaceable>      <replaceable>mentésigyak</replaceable>     <replaceable>ellszám</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>eszköz</literal></term>
	  <listitem>
	    <para>A <xref linkend="disks-naming"/>ban leírtak
	      szerint megnevezett (létezõ)
	      eszköz.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>csatlakozási-pont</literal></term>
	  <listitem>
	    <para>Egy (létezõ) könyvtár, ahova
	      az állományrendszer csatlakozik.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>típus</literal></term>
	  <listitem>
	    <para>Az állományrendszer &man.mount.8;
	      parancs szerint ismert típusa.  A &os;
	      alapértelmezett állományrendszere az
	      <literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>beállítások</literal></term>
	  <listitem>
	    <para>Az írható-olvasható
	      állományrendszerek esetén
	      <option>rw</option>, az írásvédettek
	      esetén pedig <option>ro</option>, amelyet
	      igény szerint további
	      beállítások követhetnek.  A
	      rendszerindítás során automatikusan
	      nem csatlakoztatandó
	      állományrendszerek esetén gyakran
	      alkalmazott beállítás itt még
	      a <option>noauto</option>.  Egyéb
	      lehetõségeket a &man.mount.8; man oldalon
	      láthatunk.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>mentésigyak</literal></term>
	  <listitem>
	    <para>Ezt általában a &man.dump.8; parancs
	      használja a menteni szükséges
	      állományrendszerek
	      megállapításához.  Amennyiben
	      hiányzik ez a mezõ, az automatikusan a nulla
	      értéket jelöli.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>ellszám</literal></term>
	  <listitem>
	    <para>Megadja, hogy mely állományrendszereket
	      kell ellenõrizni.  A nullás
	      <literal>pass</literal> értékkel
	      rendelkezõ állományrendszerek nem
	      kerülnek ellenõrzésre.  A
	      gyökér-állományrendszer (melyet
	      minden más elõtt kell ellenõrizni)
	      <literal>passno</literal> értéke egy,
	      míg az összes többi
	      állományrendszer <literal>passno</literal>
	      értéke általában egytõl
	      különbözõ.  Ha egynél több
	      állományrendszer is ugyanazt a
	      <literal>passno</literal> értéket kapta,
	      akkor az &man.fsck.8; a lehetõségei szerint
	      megpróbálja ezeket egyszerre
	      ellenõrizni.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Az <filename>/etc/fstab</filename>
	felépítésérõl és a benne
	használható
	beállításokról bõvebben a
	&man.fstab.5; man oldalon olvashatunk.</para>

    </sect2>

    <sect2 xml:id="disks-mount">
      <title>A <command>mount</command> parancs</title>

     <indexterm>
	<primary>állományrendszerek</primary>
	<secondary>csatlakoztatás</secondary>
      </indexterm>

      <para>Az állományrendszerek tényleges
	csatlakoztatására avagy
	<quote>mountolására</quote> a &man.mount.8;
	parancs használható.</para>

      <para>Legegyszerûbb formája:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount eszköz csatlakozási-pont</userinput></screen>
      </informalexample>

      <para>Ahogy a &man.mount.8; man oldalán is olvashatjuk, itt
	rengeteg opció is megadható, de ezek
	közül a leggyakoribbak:</para>

      <variablelist>
	<title>Csatlakoztatási opciók</title>

	<varlistentry>
	  <term><option>-a</option></term>
	  <listitem>
	    <para>Csatlakoztatja az <filename>/etc/fstab</filename>
	      állományban felsorolt összes
	      állományrendszert, kivéve azokat,
	      amelyek a <quote>noauto</quote>
	      beállítást tartalmazzák, vagy
	      kizártuk a <option>-t</option> kapcsolóval,
	      esetleg korábban már csatlakoztattuk.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>
	  <listitem>
	    <para>A tényleges csatlakoztatás
	      elvégzése nélkül
	      végrehajt minden mást.  Ez az opció
	      leginkább <option>-v</option> opcióval
	      együtt használható annak
	      megállapítására, hogy a
	      &man.mount.8; valójában mit is akar
	      csinálni.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>
	  <listitem>
	    <para>Egy nem tiszta állományrendszer
	      csatlakoztatásának
	      kényszerítése (veszélyes!)
	      vagy egy korábban már csatlakoztatott
	      állományrendszer írható
	      állapotának
	      felfüggesztése.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-r</option></term>
	  <listitem>
	    <para>Az állományrendszer
	      írásvédett csatlakoztatása.
	      Megegyezik a <option>-o</option> opciónál
	      megadható <option>ro</option> (vagy a &os;
	      5.2-nél régebbi verziója
	      esetén a <option>rdonly</option>)
	      beállítás
	      használatával.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>típus</replaceable></term>
	  <listitem>
	    <para>Az adott állományrendszert az adott
	      típusnak megfelelõen csatlakoztatja, vagy az
	      <option>-a</option> használata esetén csak
	      az adott típusú
	      állományrendszereket.</para>

	    <para>Az <quote>ufs</quote> az
	      állományrendszerek alapértelmezett
	      típusa.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>
	  <listitem>
	    <para>Frissíti az állományrendszerre
	      vonatkozó csatlakoztatási
	      beállításokat.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>
	  <listitem>
	    <para>Részletesebb kijelzés.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>
	  <listitem>
	    <para>Az állományrendszer
	      csatlakoztatása írásra és
	      olvasásra.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Az <option>-o</option> opció után
	vesszõvel elválasztott
	beállításokat adhatunk meg, többek
	közt az alábbiakat:</para>

      <variablelist>
	<varlistentry>
	  <term>noexec</term>
	  <listitem>
	    <para>Az állományrendszeren
	      található állományok
	      végrehajtásának tiltása.  Ez
	      egy nagyon hasznos biztonsági
	      beállítás.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>nosuid</term>
	  <listitem>
	    <para>Az állományrendszeren nem
	      használhatóak a felhasználó-
	      (setuid) vagy csoportváltásra (setgid)
	      vonatkozó engedélyek.  Nagyon hasznos
	      biztonsági beállítás.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

    </sect2>

    <sect2 xml:id="disks-umount">
      <title>Az <command>umount</command> parancs</title>

      <indexterm>
	<primary>állományrendszerek</primary>
	<secondary>leválasztás</secondary>
      </indexterm>

      <para>Az &man.umount.8; parancs paraméterként egy
	csatlakozási pontot, egy eszköznevet vagy a
	<option>-a</option>, illetve az <option>-A</option>
	opciókat várja.</para>

      <para>A leválasztás
	kényszerítéséhez mindegyik alakban
	szerepelhet az <option>-f</option> opció, valamint a
	részletesebb kijelzést a <option>-v</option>
	opcióval kapcsolhatjuk be.  Azonban szeretnénk
	mindenkit figyelmeztetni, hogy a <option>-f</option>
	használata alapvetõen nem ajánlott.  Az
	erõszakkal leválasztott
	állományrendszerek összeomlaszthatják
	a számítógépet vagy kárt
	okozhatnak az állományrendszereken
	található adatokban.</para>

      <para>Az <option>-a</option> és <option>-A</option>
	opciók használatosak az összes
	csatlakoztatott állományrendszer
	leválasztására, amelyek típusait a
	<option>-t</option> opció megadása után
	sorolhatjuk fel.  Fontos különbség azonban,
	hogy az <option>-A</option> opció a gyökér
	állományrendszert nem próbálja meg
	leválasztani.</para>

    </sect2>
  </sect1>

  <sect1 xml:id="basics-processes">
    <title>Folyamatok</title>

    <para>A &os; egy többfeladatos operációs
      rendszer.  Ez azt jelenti, hogy képes
      látszólag egyszerre több programot is futtatni.
      Az így egyszerre futó programokat egyenként
      <firstterm>folyamat</firstterm>oknak (process) nevezzük.
      Minden kiadott parancsunk elindít legalább egy ilyen
      folyamatot, és a rendszerünk mozgásban
      tartásához bizonyos rendszerszintû folyamatok
      állandóan futnak a háttérben.</para>

    <para>Minden folyamatot egy
      <firstterm>folyamatazonosító</firstterm>nak (process
      ID vagy <firstterm>PID</firstterm>) nevezett szám
      azonosít egyértelmûen, és az
      állományokhoz hasonlóan, minden folyamatnak
      van tulajdonosa és csoportja is.  A tulajdonos és a
      csoport ismeretében állapítja meg a rendszer,
      hogy az adott folyamat a korábban említett
      engedélyek szerint milyen állományokhoz
      és eszközökhöz férhet hozzá.
      Ezenkívül a legtöbb folyamatnak van még
      egy szülõfolyamata is.  A szülõfolyamat az a
      folyamat, amely az adott folyamatot elindította.
      Például amikor parancsokat adunk egy
      parancsértelmezõn keresztül, akkor maga a
      parancsértelmezõ is egy ilyen folyamat lesz
      ugyanúgy, ahogy a benne kiadott parancsok által
      elindított programok.  Ennek megfelelõen az így
      létrehozott összes folyamat szülõje maga a
      parancsértelmezõ folyamata lesz.  Az említettek
      alól egyik kivétel az &man.init.8; nevû
      speciális folyamat.  Az <command>init</command> lesz a
      rendszerben mindig az elsõ folyamat, ezért a PID-je is
      mindig 1.  Az <command>init</command> programot a &os;
      indulásakor a rendszermag fogja automatikusan
      elindítani.</para>

    <para>A rendszerben futó programok
      vizsgálatához két, különösen
      hasznos parancsot találhatunk: ezek a &man.ps.1; és
      a &man.top.1;.  A <command>ps</command> parancs használatos
      a pillanatnyilag futó programok statikus
      listájának megjelenítésére.
      Ebben olvashatjuk a futó programok
      azonosítóit, mennyi memóriát
      használnak éppen, milyen paranccsal
      indították ezeket stb.  A <command>top</command>
      parancs mutatja az összes aktívan futó
      programot, majd néhány másodpercenként
      automatikusan frissíti ezt a listát, aminek
      révén folyamatosan láthatjuk, miként
      viselkednek a futó programok.</para>

    <para>A <command>ps</command> alapértelmezés szerint
      csupán az általunk futtatott programokat mutatja.
      Például:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Ahogy az a fenti példában is látszik, a
      &man.ps.1; kimenete oszlopokra tagolható.  Ezek
      közül a <literal>PID</literal> tartalmazza a
      korábban már ismertetett
      folyamatazonosítókat.  Az azonosítók
      1-tõl indulva egészen 99999-ig
      sorszámozódhatnak, illetve ha kifutnánk
      belõlük, akkor a számozás kezdõdik
      elölrõl (azonban a használatban levõ
      azonosítók sosem kerülnek újra
      kiosztásra).  A <literal>TT</literal> oszlopban
      láthatjuk azt a terminált, amelyen az adott program
      éppen fut, de ezt pillanatnyilag akár nyugodtan
      figyelmen kívül is hagyhatjuk.  A
      <literal>STAT</literal> oszlopban a program
      állapotát kapjuk meg, de szintén
      átugorható.  A <literal>TIME</literal> a program
      processzoron eltöltött idejét mutatja &mdash; ez
      általában nem arra utal, hogy mennyi ideje fut maga
      a program, hiszen a legtöbb program sok idõt tölt
      tétlenül, mielõtt egyáltalán
      szüksége lenne processzora.  Végezetül a
      <literal>COMMAND</literal> oszlopban olvashatjuk azt a parancsot,
      amellyel a programot elindították.</para>

    <para>A &man.ps.1; számos különféle
      beállítást ismer az általa
      megjelenített információk
      megválasztásához.  Az egyik ilyen
      leghasznosabb beállítás az
      <literal>auxww</literal>: az <option>a</option>
      segítségével az összes futó
      programot láthatjuk, nem csak a sajátjainkat; az
      <option>u</option> megadásával
      láthatóvá válik a folyamat
      tulajdonosának a felhasználói neve, valamint
      a memóriahasználata is; az <option>x</option>
      megmutatja a démon (avagy háttér)folyamatok
      adatait is és a <option>ww</option> hatására
      pedig a &man.ps.1; az összes folyamathoz a teljes parancssort
      kiírja, még akkor is, ha nem férne ki a
      képernyõre.</para>

    <para>A &man.top.1; kimenete is hasonló.  Ha
      elindítjuk, általában ezt
      láthatjuk:</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>A kimenet két részre osztható.  A
      fejlécben (vagyis az elsõ öt sorban)
      látható az utoljára futtatott program
      azonosítója (PID), a rendszer átlagos
      terhelése (load average, amellyel mérjük, hogy
      a rendszerünk mennyire lefoglalt), a rendszer
      indítása óta eltelt idõ (up mint uptime)
      és a jelenlegi idõ.  A fejlécben még
      megtalálhatjuk azt is, mennyi program fut (esetünkben
      ez most 47), mennyi memóriát és
      lapozóállományt használnak, és
      mennyi idõt tölt a rendszer a processzor
      különbözõ állapotaiban.</para>

    <para>A fejléc alatt a &man.ps.1; kimenetéhez
      hasonló módon oszlopokba rendezve találhatjuk
      meg a folyamatok adatait: az azonosítóikat, a
      tulajdonosaik nevét, a felhasznált
      processzoridõt, a futtatott parancsot.  A &man.top.1;
      alapértelmezés szerint mutatja a futó
      programok által használt memória
      mennyiségét is: ez további két
      oszlopra oszlik, ahol az egyikben a teljes
      memóriafoglalást (SIZE), a másikban pedig a
      jelen pillanatban aktívan használt
      memóriát (RES) láthatjuk.  A
      példában látható is, hogy a
      <application>&netscape;</application> (navigator-linu)
      alkalmazásnak majdnem 30&nbsp;MB-nyi
      memóriára van szüksége, de ebbõl
      aktívan csak 9&nbsp;MB-ot használ.</para>

    <para>A &man.top.1; a kijelzést minden második
      másodpercben magától frissíti, de ez
      az <option>s</option> kapcsolóval
      állítható.</para>

  </sect1>

  <sect1 xml:id="basics-daemons">
    <title>Démonok, jelzések és a futó
      programok leállítása</title>

    <para>Amikor elindítunk egy szövegszerkesztõt, nem
      sok gondunk akad az irányításával,
      könnyen utasíthatjuk az állományok
      betöltésére és így tovább.
      Mindezt azért tehetjük meg, mert a
      szövegszerkesztõ erre lehetõséget
      biztosít és mivel a szövegszerkesztõ egy
      <firstterm>terminál</firstterm>hoz kapcsolódik.
      Egyes programok azonban nem úgy lettek kialakítva,
      hogy állandóan a felhasználó
      utasításaira támaszkodjanak, ezért az
      elsõ adandó alkalommal lekapcsolódnak a
      terminálról.  Például egy webszerver
      egész nap csak webes kéréseket
      válaszol meg, és általában semmi
      szüksége nincs a felhasználók
      utasításaira.  A szerverek között
      leveleket közvetítõ programok is ugyanezen
      osztályba tartoznak.</para>

    <para>Ezeket a programokat
      <firstterm>démon</firstterm>onoknak hívjuk.  A
      démonok a görög mitológiában
      jelentek meg: sem a jót, sem pedig a gonoszt nem
      képviselték, egyszerû apró
      szellemecskék voltak, akik az emberiség javát
      szolgálták, pontosan úgy, ahogy ma teszik azt
      a különféle web- és levelezõ
      szerverek.  Ezért is ábrázolták
      sokáig a BSD kabalafiguráját is egy
      tornacipõs, vasvillás vidám
      démonként.</para>

    <para>A démonként futó programok nevéhez
      a hagyományok szerint hozzá szokták
      fûzni a <quote>d</quote> betût.  A
      <application>BIND</application> a Berkeley Internet Name Domain
      (névfeloldó) szolgáltatása, azonban a
      hozzá tartozó program neve <command>named</command>,
      az <application>Apache</application> webszerver programját
      <command>httpd</command>-nek nevezik, a sornyomtató
      kezeléséért felelõs démon pedig
      az <command>lpd</command> és így tovább.  Ez
      csupán egy hagyomány, megszokás, nem pedig
      egy kõbe vésett szabály: például
      a <application>Sendmail</application> levelezõ
      démonának neve <command>sendmail</command> és
      nem pedig <command>maild</command>.</para>

    <para>Néha azért szükségünk lehet
      arra, hogy felvegyük valahogy a kapcsolatot a
      démonként futó programokkal is.  Ennek egyik
      lehetséges módja a
      <firstterm>jelzés</firstterm>ek (signal)
      küldése (de alapvetõen bármilyen
      futó programnak küldhetünk).  Több
      különféle jelzés küldhetõ
      &mdash; egyeseknek közülük
      megkülönböztetett jelentése van,
      másokat magukat az alkalmazások értelmeznek,
      amelyrõl a dokumentációjukban
      tájékozódhatunk.  A &man.kill.1; vagy
      &man.kill.2; paranccsal más tulajdonában levõ
      futó programoknak nem tudunk jelzéseket
      küldeni, ami alól egyedüli kivétel a
      <systemitem class="username">root</systemitem> felhasználó.</para>

    <para>Bizonyos esetekben a &os; maga is küld néha
      jelzéseket.  Amikor egy alkalmazást rosszul
      programoznak le és megpróbál egy
      számára tiltott memóriaterülethez
      hozzáférni, a &os; küld neki egy
      <firstterm>Segmentation Violation</firstterm>
      (<literal>SIGSEGV</literal>, szegmentálási hiba)
      jelzést.  Ha egy alkalmazás az &man.alarm.3;
      rendszerhíváson keresztül kér egy adott
      idõ utáni bekövetkezõ
      értesítést, akkor kap errõl egy Alarm
      (<literal>SIGALRM</literal>) jelzést és így
      tovább.</para>

    <para>A folyamatok leállítására
      két jelzés használható: a
      <literal>SIGTERM</literal> (befejeztetés) és a
      <literal>SIGKILL</literal> (leállítás).  A
      <literal>SIGTERM</literal> a folyamatok
      leállításának illedelmes módja,
      mivel ekkor a futó program képes
      <emphasis>elkapni</emphasis> ezt a jelzést és
      észrevenni, hogy le akarjuk állítani.
      Ilyenkor a leállítás elõtt
      lehetõsége van szabályosan lezárni a
      naplóit és általánosságban
      véve befejezni mindent, amit éppen csinál.
      Elõfordulhat azonban, hogy a folyamatok figyelmen
      kívül hagyják a <literal>SIGTERM</literal>
      jelzést, ha például éppen egy
      félbeszakíthatatlan feladat közepén
      tartanak.</para>

    <para>A <literal>SIGKILL</literal> jelzést azonban egyetlen
      futó program sem hagyhatja figyelmen kívül.  Ez
      lenne a <quote>Nem érdekel, mivel foglalkozol, azonnal
      hagyd abba!</quote> jelzés.  Amikor
      <literal>SIGKILL</literal> jelzést küldünk egy
      folyamatnak, a &os; leállítja a folyamatot ott
      és ahol tart
      <footnote>
	<para>Ez azért nem teljesen igaz.  Van
	  néhány olyan tevékenység, ami nem
	  szakítható meg.  Ilyen például az,
	  amikor a program egy másik
	  számítógépen
	  található állományt
	  próbál olvasni, miközben valamilyen ok
	  (kikapcsolás, hálózati hiba)
	  folytán elveszti vele a kapcsolatot.  Ekkor a program
	  futása <quote>megszakíthatatlan</quote>.  Majd
	  amikor a program feladja a próbálkozást
	  (általában két perc után), akkor
	  következik be a tényleges
	  leállítása.</para>
      </footnote>.</para>

    <para>További használható jelzések:
      <literal>SIGHUP</literal>, <literal>SIGUSR1</literal> és
      <literal>SIGUSR2</literal>.  Ezek általános
      célú jelzések, amelyeket az
      alkalmazások eltérõ módokon
      kezelnek.</para>

    <para>Tegyük fel, hogy megváltoztattuk a
      webszerverünk beállításait
      tartalmazó állományt &mdash; valamilyen
      módon szeretnénk tudatni a szerverrel, hogy olvassa
      be újra a beállításait.  Ezt
      megtehetjük úgy, hogy leállítjuk
      és újraindítjuk a <command>httpd</command>
      démont, de ezzel kiesést okozhatunk a szerver
      mûködésében, amit viszont nem
      engedhetünk meg.  A legtöbb démont úgy
      készítették el, hogy a
      <literal>SIGHUP</literal> jelzés hatására
      olvassa be újra a beállításait
      tartalmazó állományt.  Így a
      <command>httpd</command> leállítása és
      újraindítása helyett egyszerûen
      elegendõ egy <literal>SIGHUP</literal> jelzés
      küldése.  Mivel azonban ez nem
      szabványosított, a különbözõ
      démonok ezt a jelzést
      többféleképpen is értelmezhetik.
      Ezért a használata elõtt ennek
      mindenképpen járjunk utána a
      kérdéses démon
      dokumentációjában.</para>

    <para>A jelzéseket a &man.kill.1; paranccsal tudjuk
      elküldeni, ahogy ezt a következõ
      példában is láthatjuk.</para>

    <procedure>
      <title>Jelzés küldése egy futó
	programnak</title>

      <para>Ebben a példában megmutatjuk, hogyan lehet
	jelzést küldeni az &man.inetd.8; démonnak.
	Az <command>inetd</command> a beállításait
	az <filename>/etc/inetd.conf</filename>
	állományban tárolja, és az
	<command>inetd</command> a <literal>SIGHUP</literal>
	jelzés hatására képes
	újraolvasni ezt.</para>

      <step>
	<para>Keressük meg annak a folyamatnak az
	  azonosítóját, amelynek a jelzést
	  kívánjuk küldeni.  Ezt a &man.ps.1;
	  és a &man.grep.1; használatával
	  tehetjük meg.  A &man.grep.1; parancs
	  segítségével más parancsok
	  kimenetében tudunk megkeresni egy általunk
	  megadott szöveget.  Ezt a parancsot átlagos
	  felhasználóként futtatjuk, azonban az
	  &man.inetd.8; démont a <systemitem class="username">root</systemitem>
	  birtokolja, ezért az &man.ps.1; használata
	  során meg kell adnunk az <option>ax</option>
	  kapcsolókat is.</para>

	<screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

	<para>Innen kiderül, hogy az &man.inetd.8;
	  azonosítója 198.  Elõfordulhat, hogy az
	  eredményben maga a <literal>grep inetd</literal>
	  parancs is megjelenik.  Ez a &man.ps.1;
	  listázási módszere miatt következhet
	  be.</para>
      </step>

      <step>
	<para>A jelzés elküldésére
	  használjuk a &man.kill.1; parancsot.  Mivel az
	  &man.inetd.8; démont a <systemitem class="username">root</systemitem>
	  felhasználó futtatja, ehhez elõször a
	  &man.su.1; parancs kiadásával nekünk is
	  <systemitem class="username">root</systemitem> felhasználóvá
	  (rendszeradminisztrátorrá) kell
	  válnunk.</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>Ahogy az a legtöbb &unix; esetén elfogadott, a
	  sikeres végrehajtás esetén a &man.kill.1;
	  sem válaszol semmit.  Amikor viszont nem egy
	  saját programunknak akarunk jelzést
	  küldeni, akkor a <errorname>kill:
	  <replaceable>PID</replaceable>: Operation not
	  permitted</errorname> (a mûvelet nem
	  engedélyezett) hibaüzenetet látunk.  Ha
	  véletlenül elgépeltük volna a
	  futó program azonosítóját, akkor a
	  küldendõ jelzés nem a megfelelõ
	  folyamatnál fog kikötni (ami nem éppen
	  jó), vagy ha szerencsénk van, akkor a
	  jelzést egy éppen használaton
	  kívüli azonosítóra
	  küldtük.  Az utóbbi esetben a
	  következõ láthatjuk: <errorname>kill:
	  <replaceable>PID</replaceable>: No such process</errorname>
	  (nincs ilyen folyamat).</para>

	<note>
	  <title>Miért <command>/bin/kill</command>?</title>

	  <para>A legtöbb parancsértelmezõ
	    beépítetten tartalmazza a saját
	    <command>kill</command> parancsát, tehát
	    ilyenkor közvetlenül maga a
	    parancsértelmezõ küldi a jelzést,
	    nem pedig a <filename>/bin/kill</filename> programon
	    keresztül.  Ez gyakran a javunkra válhat,
	    azonban a küldhetõ jelzések megadása
	    parancsértelmezõnként eltérhet.
	    Így, ahelyett, hogy egyenként ismernünk
	    kellene mindegyiket, sokkal egyszerûbb
	    közvetlenül a <command>/bin/kill
	    ...</command> parancsot
	    használni.</para>
	</note>
      </step>
    </procedure>

    <para>A többi jelzés küldése is nagyon
      hasonló módon történik, hiszen
      elegendõ csupán a <literal>TERM</literal> vagy a
      <literal>KILL</literal> behelyettesítése a parancs
      megfelelõ helyére.</para>

    <important>
      <para>A rendszerünkben óvatosan bánjunk a
	futó programok
	leállítgatásával, és
	legyünk különös tekintettel az 1-es
	azonosítóval rendelkezõ, speciális
	feladattal bíró &man.init.8; folyamatra.  A
	<command>/bin/kill -s KILL 1</command> parancs
	kiadásával ugyanis gyorsan le tudjuk
	állítani a rendszerünket.
	<emphasis>Mielõtt</emphasis> egy &man.kill.1; parancsot
	lezárnánk az <keycap>Enter</keycap>
	billentyûvel, <emphasis>mindig</emphasis>
	gyõzõdjünk meg róla, hogy valóban
	tényleg a jó paramétereket adtuk
	meg.</para>
    </important>

  </sect1>

  <sect1 xml:id="shells">
    <title>Parancsértelmezõk</title>

    <indexterm><primary>parancsértelmezõk</primary></indexterm>
    <indexterm><primary>parancssor</primary></indexterm>

    <para>A &os;-ben hétköznapi munkánk legnagyobb
      részét a parancsértelmezõknek (shell)
      nevezett parancssoros felületen tudjuk elvégezni.  A
      parancsértelmezõ fõ feladata a
      beérkezõ parancsok elfogadása és
      végrehajtatása.  Sok parancsértelmezõ
      ezenfelül rendelkezik beépített
      funkciókkal is, amelyek olyan hétköznapi
      feladatokban igyekeznek segíteni, mint
      például az állományok kezelése
      és tömeges elérése reguláris
      kifejezések használatával, a parancssor
      szerkesztése, parancsok makrózása és a
      környezeti változók használata.  A &os;
      alapból tartalmaz néhány
      parancsértelmezõt, ilyen például az
      <command>sh</command>, a Bourne Shell, és a
      <command>tcsh</command>, a továbbfejlesztett C-shell.  Sok
      más parancsértelmezõ, mint
      például a <command>zsh</command> és
      <command>bash</command> is elérhetõ a &os;
      Portgyûjteményébõl.</para>

    <para>De melyik parancsértelmezõt is válasszuk?
      Ez igazából ízlés kérdése.
      Ha inkább C programozók vagyunk, akkor
      valószínûleg egy olyan C-szerû shelllel
      tudunk kényelmesen dolgozni, amilyen például
      a <command>tcsh</command>.  Ha viszont egy linuxos rendszert
      használtunk korábban vagy éppen még
      soha nem használtunk volna a &unix; parancssorát,
      érdemes a <command>bash</command>-sel
      megpróbálkoznunk.  A lényeg az, hogy minden
      parancsértelmezõnek vannak olyan egyedi
      jellemezõi, amiért használatóak vagy
      éppen nem használatóak a munkánkban,
      ezért magunknak kell kiválasztani a nekünk
      megfelelõt.</para>

    <para>A shellek egyik legáltalánosabb jellemzõje
      az állományok neveinek
      kiegészítése.  Miután
      begépeljük egy parancs vagy
      állománynév elsõ néhány
      karakterét, a <keycap>Tab</keycap> billentyû
      lenyomásával megkérhetjük a
      parancsértelmezõt, hogy magától
      egészítse ki (<quote>találja ki</quote>) a
      fennmaradó részt.  Nézzük erre egy
      példát.  Tegyük fel, hogy van két
      állományunk, <filename>izemize</filename> és
      <filename>ize.mize</filename>, és szeretnénk
      letörölni az <filename>ize.mize</filename> nevût.
      Ehhez a következõt kell begépelnünk:
      <command>rm
      iz[Tab].[Tab]</command>.</para>

    <para>Erre a parancsértelmezõ a következõ
      parancsot írja ki: <command>rm
      ize[SIPOLÁS].mize</command>.</para>

    <para>A [SIPOLÁS] itt a konzol sípjára
      vonatkozik, amellyel jelzi, hogy nem tudta teljesen
      kiegészíteni az állomány nevét,
      mivel egynél több is megfelel a megadott alaknak.  Az
      <filename>izemize</filename> és az
      <filename>ize.mize</filename> is egyaránt az
      <literal>iz</literal> elõtaggal kezdõdik, azonban
      ebbõl a parancsértelmezõ csak az
      <literal>ize</literal> elõtagot tudta kikövetkeztetni.
      Ha most begépelünk még egy <literal>.</literal>
      karaktert és újra megnyomjuk a <keycap>Tab</keycap>
      billentyût, a parancsértelmezõ ezúttal
      képes lesz az állomány teljes nevét
      megállapítani.</para>

    <indexterm><primary>környezeti
      változók</primary></indexterm>

    <para>A parancsértelmezõk másik
      általános jellemzõje a környezeti
      változók használata.  A környezeti
      változók lényegében a
      parancsértelmezõ környezetéhez
      tárolt név-érték párok.  Ezt a
      környezetet látja minden olyan program, amit a
      parancsértelmezõbõl meghívunk, és
      ezért tartalmazni is szokott sok ilyen
      beállítást.  Íme a leggyakoribb
      környezeti változók felsorolása
      és rövid leírása:</para>

    <indexterm><primary>környezeti
      változók</primary></indexterm>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Változó</entry>
	    <entry>Leírás</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>A bejelentkezett felhasználó
	      neve.</entry>
	  </row>
	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>Vesszõvel elválasztott
	      könyvtárak, ahol a parancsértelmezõ
	      a végrehajtható állományokat
	      keresi.</entry>
	  </row>
	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>Az aktuálisan használt X11
	      megjelenítõ hálózati neve,
	      amennyiben létezik ilyen.</entry>
	  </row>
	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>A használt
	      parancsértelmezõ.</entry>
	  </row>
	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>A felhasználó által
	      használt terminál típusa.  Ebbõl
	      a terminál képességeit lehet
	      megállapítani.</entry>
	  </row>
	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>A terminálok
	      adatbázisából származó,
	      különbözõ
	      terminálfunkciókhoz tartozó
	      helyettesítõ (escape) kódok.</entry>
	  </row>
	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>Az operációs rendszer típusa,
	      például &os;.</entry>
	  </row>
	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>A rendszer alatt futó gép
	      architektúrája.</entry>
	  </row>
	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>A felhasználó által
	      használt szövegszerkesztõ.</entry>
	  </row>
	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>A felhasználó által
	      lapozásra használt program.</entry>
	  </row>
	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>Vesszõvel elválasztott könyvtárak,
	      ahol a parancsértelmezõ a man
	      oldalakat keresi.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>Bourne-féle
      parancsértelmezõk</primary></indexterm>

    <para>A környezeti változók
      beállítása
      parancsértelmezõnként valamennyire eltér.
      Például egy C stílusú
      parancsértelmezõ, mint például a
      <command>tcsh</command> vagy a <command>csh</command>, a
      <command>setenv</command> paranccsal állítja a
      környezeti változókat.  A Bourne-féle
      parancsértelmezõk, mint például az
      <command>sh</command> vagy a <command>bash</command>, az
      <command>export</command> parancsot használják a
      környezeti változók
      beállítására.  Például a
      <command>csh</command> vagy a <command>tcsh</command>
      használata során a következõképpen
      tudjuk be- vagy átállítani az
      <envar>EDITOR</envar> környezeti változó
      értékét
      <filename>/usr/local/bin/emacs</filename>-re:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Ugyanez a Bourne-féle
      parancsértelmezõkben:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>A legtöbb parancsértelmezõben a nevük
      elõtt szerepeltetett <literal>$</literal> jel
      segítségével kérhetjük a
      környezeti változók
      értékének
      behelyettesítését a parancssorba.  Ennek
      megfelelõen az <command>echo $TERM</command> parancs
      kiíratja a <envar>TERM</envar> változó
      aktuális értékét, mivel ebbe a
      parancsértelmezõ már az <command>echo</command>
      meghívása elõtt behelyettesíti a
      <envar>TERM</envar> értékét.</para>

    <para>A parancsértelmezõk számos speciális
      karaktert, ún.  metakaraktert az adatok különleges
      reprezentációjaként kezelnek.
      Köztük a leggyakrabban használt a
      <literal>*</literal>, amely tetszõleges számú
      karaktert helyettesít egy állomány
      nevében.  Az ilyen metakarakterek
      segítségével tudunk egyszerre több
      állományt is megnevezni.  Például ha
      begépeljük az <command>echo *</command> parancsot,
      akkor majdnem ugyanazt kapjuk eredményül, mintha az
      <command>ls</command> parancsot adtuk volna ki, hiszen a
      parancsértelmezõ ilyenkor veszi az összes
      <literal>*</literal> metakarakterre illeszkedõ
      állományt, és a kiíratásukhoz
      pedig rendre behelyettesíti ezeket a parancssorba az
      <command>echo</command> paramétereként.</para>

    <para>Ha nem szeretnénk, hogy a parancsértelmezõ
      értelmezze a speciális karaktereket, akkor egy
      <quote>backslash</quote> (visszaper) (<literal>\</literal>)
      karaktert eléjük téve mindezt
      megakadályozhatjuk.  Az <command>echo $TERM</command>
      parancs ugyebár kiíratja a terminálra
      vonatkozó környezeti változó
      beállítását, azonban a <command>echo
      \$TERM</command> változatlanul kiírja a
      <envar>$TERM</envar> szöveget.</para>

    <sect2 xml:id="changing-shells">
      <title>A parancsértelmezõnk
	megváltoztatása</title>

      <para>A parancsértelmezõnk legegyszerûbben a
	<command>chsh</command> parancs használatával
	változtatható meg.  A <command>chsh</command>
	kiadása után elindítja az
	<envar>EDITOR</envar> környezeti változónak
	megfelelõ szövegszerkesztõt, ha nem lenne ilyen,
	akkor alapértelmezés szerint a
	<command>vi</command> hívódik meg.  Az így
	megnyitott állományban változtassuk meg
	kedvünk szerint a <quote>Shell: </quote> kezdetû
	sort.</para>

      <para>A <command>chsh</command> parancsnak megadhatjuk az
	<option>-s</option> opciót is, amin keresztül
	szövegszerkesztõ használata nélkül
	be tudjuk állítani a
	parancsértelmezõt.  Például ha a
	parancsértelmezõnket a <command>bash</command>-re
	akarjuk lecserélni, akkor ezt írjuk be:</para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <note>
	<para>A használni kívánt
	  parancsértelmezõnek szerepelnie
	  <emphasis>kell</emphasis> az <filename>/etc/shells</filename>
	  állományban.  Ha a kiválasztott
	  parancsértelmezõt a <link linkend="ports">Portgyûjtemény</link>bõl
	  telepítettük fel, akkor az már minden
	  bizonnyal bekerült oda.  Ha viszont saját magunk
	  raktuk volna fel, akkor ide is fel kell vennünk.</para>

	<para>Például ha a <command>bash</command>-t
	  manuálisan telepítettük és
	  másoltuk a <filename>/usr/local/bin</filename>
	  könyvtárba, akkor így kell
	  eljárnunk:</para>

	<screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

	<para>Majd próbálkozzunk újra a
	  <command>chsh</command> paranccsal.</para>
     </note>

   </sect2>
  </sect1>

  <sect1 xml:id="editors">
    <title>Szövegszerkesztõk</title>

    <indexterm><primary>szövegszerkesztõk</primary></indexterm>
    <indexterm><primary>szerkesztõk</primary></indexterm>

    <para>A &os; beállításának nagy
      része szöveges állományok
      szerkesztésével történik.  Emiatt sosem
      árt legalább egy szövegszerkesztõt
      ismernünk.  A &os; alaprendszerében, valamint a
      Portgyûjteményben is találhatunk
      néhányat belõlük.</para>

    <indexterm><primary><command>ee</command></primary></indexterm>
    <indexterm>
      <primary>szerkesztõk</primary>
      <secondary><command>ee</command></secondary>
    </indexterm>

    <para>A legegyszerûbben megtanulható és
      legkönnyedebb szövegszerkesztõt
      <application>ee</application>-nek, avagy <quote>easy
      editornak</quote> hívják.  Az
      <application>ee</application> indításához
      írjuk be az <command>ee
      állománynév</command>
      parancsot, ahol az
      <replaceable>állománynév</replaceable> lesz a
      szerkesztendõ állomány neve.  Így
      például az <filename>/etc/rc.conf</filename>
      állomány szerkesztéséhez
      gépeljük be az <command>ee /etc/rc.conf</command>
      parancsot.  Miután elindult az <command>ee</command>, az
      összes szerkesztéshez használható
      parancsa megjelenik a képernyõ felsõ
      részében.  Itt a <quote>kalap</quote>
      (<literal>^</literal>) karakter a <keycap>Ctrl</keycap>
      billentyû lenyomására utal, így
      tehát a <literal>^e</literal> jelölés a
      <keycombo action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>
      billentyûkombinációt jelenti.  Ha ki akarunk
      lépni az <application>ee</application>-bõl, nyomjuk le
      az <keycap>Esc</keycap> billentyût, majd a felbukkanó
      menübõl válasszuk a szerkesztõ
      elhagyását (leave editor).  Ha az
      állományt módosítottuk,
      kilépés elõtt még a
      szövegszerkesztõ rákérdez, hogy mentse-e a
      változtatásainkat.</para>

    <indexterm><primary><command>vi</command></primary></indexterm>
    <indexterm>
      <primary>szerkesztõk</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm><primary><command>emacs</command></primary></indexterm>
    <indexterm>
      <primary>szerkesztõk</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>

    <para>A &os; nagyobb tudású
      szövegszerkesztõket, mint például a
      <application>vi</application>-t, is tartalmaz az alaprendszer
      részeként, miközben a többi, mint
      például az <application>Emacs</application> vagy a
      <application>vim</application> a Portgyûjtemény
      részeként (<package>editors/emacs</package> és <package>editors/vim</package>) érhetõ el.
      Ezek a szerkesztõk sokkal több lehetõséget
      és erõt képviselnek, amiért
      cserébe viszont valamivel nehezebb megtanulni a
      használatukat.  Ha viszont rengeteg szöveget akarunk
      majd szerkeszteni, akkor egy <application>vim</application> vagy
      <application>Emacs</application> használatának
      megismerésével sok idõt
      megspórolhatunk.</para>

    <para>Számos alkalmazás, amely
      állományokat akar módosítani vagy
      szöveges bemenetre van szüksége, automatikusan
      szövegszerkesztõt nyit meg.  Ezt az
      <envar>EDITOR</envar> környezeti változó
      beállításával tudjuk
      meghatározni.  Errõl részletesebben a <link linkend="shells">parancsértelmezõknél</link>
      olvashatunk.</para>
  </sect1>

  <sect1 xml:id="basics-devices">
    <title>Eszközök és
      eszközleírók</title>

    <para>Az eszköz elnevezést leginkább a
      rendszerben folyó, hardverrel kapcsolatos
      tevékenységek kapcsán
      használják lemezekre, nyomtatókra, grafikus
      kártyákra és billentyûzetekre.  A &os;
      indulása során többnyire azt láthatjuk,
      hogy milyen eszközöket sikerült felismernie.
      Ezeket a rendszerindításkor megjelenõ
      üzeneteket a <filename>/var/run/dmesg.boot</filename>
      állományban nézhetjük meg
      újra.</para>

    <para>Például az <filename>acd0</filename> az
      elsõ IDE CD-meghajtót, míg a
      <filename>kbd0</filename> a billentyûzetet
      képviseli.</para>

    <para>A &unix; operációs rendszerben a legtöbb
      eszközt a <filename>/dev</filename> könyvtárban
      található, eszközleíróknak
      (device node) nevezett speciális állományokon
      keresztül érhetjük el.</para>

    <sect2>
      <title>Eszközleírók
	létrehozása</title>

      <para>Amikor egy újfajta eszközt adunk hozzá a
	rendszerhez vagy csak annak egy új
	példányát, mindig létre kell hoznunk
	hozzá egy új
	eszközleírót.</para>

      <sect3>
	<title><literal>DEVFS</literal> (DEVice File System,
	  Eszköz-állományrendszer)</title>

	<para>Az eszközöket tartalmazó
	  állományrendszer, avagy
	  <literal>DEVFS</literal>, ad hozzáférést
	  a rendszermag által ismert eszközök neveihez
	  a globális állományrendszer nevein
	  keresztül.  Így ahelyett, hogy magunknak kellene
	  létrehoznunk és módosítanunk az
	  eszközleírókat, a <literal>DEVFS</literal>
	  erre a célra fenntart egy külön
	  állományrendszert.</para>

	<para>A &man.devfs.5; man oldalon olvashatunk bõvebben
	  errõl.</para>

      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="binary-formats">
    <title>Bináris formátumok</title>

    <para>Annak megértéséhez, hogy a &os;
      miért az &man.elf.5; formátumot használja,
      elõször is tisztában kell lennünk a &unix;
      típusú rendszerekben használt
      végrehajtható állományok három
      <quote>uralkodó</quote> formátumával:</para>

    <itemizedlist>
      <listitem>
	<para>&man.a.out.5;</para>
	<para>A legõsibb és egyben a
	  <quote>klasszikus</quote> &unix;-os
	  tárgykódformátum.  Egy tömör
	  és rövidke fejlécet használ, aminek
	  az elején a formátum
	  leírására szolgáló
	  <quote>bûvös szám</quote>
	  található (errõl bõvebben lásd
	  &man.a.out.5;).  Három betöltött szegmenst
	  tartalmaz: .text, .data és .bss, valamint egy
	  szimbólumokat és karakterláncokat
	  tároló táblát.</para>
      </listitem>

      <listitem>
	<para><acronym>COFF</acronym></para>
	<para>Az SVR3 tárgykódformátuma.  A
	  fejléc itt már tartalmaz egy table nevû
	  szegmenst is, tehát a .text, .data és .bss
	  szegmensekhez hasonlóan ebbõl is többet tud
	  tárolni.</para>
      </listitem>

      <listitem>
	<para>&man.elf.5;</para>
	<para>A <acronym>COFF</acronym> után következõ
	  formátum, amelyben több szegmens is
	  megtalálható, valamint létezik 32 bites
	  és 64 bites változatban is.  Egyetlen
	  hátránya van: az <acronym>ELF</acronym>
	  tervezése során
	  rendszerarchitektúránként csupán
	  egyetlen ABI-t (bináris alkalmazói
	  felületet) feltételeztek.  Ez azonban
	  meglehetõsen helytelen, mivel még a kereskedelmi
	  SYSV világában (ahol már legalább
	  három ABI található: SVR4, Solaris
	  és SCO) sem állja meg a helyét.</para>

	<para>A &os; ezt a problémát a
	  <emphasis>megbélyegzés</emphasis> (branding)
	  segítségével próbálja
	  megoldani, aminek révén el tudunk látni
	  egy ismert <acronym>ELF</acronym> állományt a
	  futtatásához megfelelõ ABI-ra
	  vonatkozó információkkal.  Errõl
	  részletesebben a &man.brandelf.1; oldalán
	  tájékozódhatunk.</para>
      </listitem>
    </itemizedlist>

    <para>A &os; a <quote>klasszikusok</quote>
      táborából indult, ezért kezdetben az
      &man.a.out.5; formátumot használta, mivel ez a
      technológia a BSD kiadások számos
      generációjában megmérettetett
      és bevált, egészen a 3.X ág
      elindulásáig.  Habár már jóval
      elõtte lehetett fordítani és futtatni
      natív <acronym>ELF</acronym> binárisokat (és
      rendszermagokat) a &os; rendszereken, a &os; kezdetben
      ódzkodott váltani az alapértelmezés
      szerinti <acronym>ELF</acronym> formátumra.  De vajon
      miért?  Nos, amikor a Linux-tábor megtette a maga
      fájdalmas váltását az
      <acronym>ELF</acronym>-re, az nem annyira azért volt, hogy
      megszabaduljanak az <filename>a.out</filename>
      végrehajtható formátumtól, hanem mert
      a rugalmatlan, ugrótáblákon alapuló
      oszottkönyvtár-kezelési mechanizmusaik nagyon
      megnehezítették a gyártók és
      fejlesztõk számára az osztott
      függvénykönyvtárak
      létrehozását.  Mivel az
      <acronym>ELF</acronym> formátumhoz rendelkezésre
      álló eszközök megoldást
      kínáltak az osztott könyvtárak
      gondjaira, és mivel általánosan
      elfogadták <quote>a jövõbe vezetõ
      útként</quote>, a &os; is felvállalta az
      átállással kapcsolatos
      költségeket és végrehajtotta azt.  A
      &os; az osztott könyvtárakat leginkább a Sun
      &sunos; rendszeréhez hasonlóan kezeli, ami egy
      nagyon könnyen használható
      megoldás.</para>

    <para>De miért van ilyen sok különbözõ
      formátum?</para>

    <para>A ködös és sötét múltban
      egyszerûbb hardverek voltak.  Ezek az egyszerû hardverek
      egyszerû, kicsi rendszereket támogattak.  Az
      <filename>a.out</filename> tökéletesen megfelelõ
      volt egy ilyen egyszerû rendszer (egy PDP-11)
      binárisainak tárolására.  Ahogy az
      emberek nekiláttak átültetni errõl az
      egyszerû rendszerrõl a &unix;-ot más
      rendszerekre, az <filename>a.out</filename> formátumot
      továbbra is megtartották, mivel a &unix; kezdeti,
      Motorola&nbsp;68k-ra, VAXenre készített
      átírataihoz is elegendõ volt.</para>

    <para>Ezután néhány éles
      elméjû hardvermérnök kitalálta,
      ha rá tudnák kényszeríteni a
      programokat egy-két ügyetlen trükkre, akkor a
      terveken meg tudnának spórolni néhány
      logikai kaput és ezzel a processzor is gyorsabban tudna
      futni.  Miközben az <filename>a.out</filename>
      formátumot ilyen hardverre (amit manapság
      <acronym>RISC</acronym>-nek hívnak) is szerették
      volna áthozni, kiderült, hogy ebben az esetben szinte
      használhatatlan.  Ezért az
      <filename>a.out</filename> formátum által
      felkínáltnál nagyobb
      teljesítmény elérése
      érdekében nekiláttak számos más
      formátumot is kidolgozni.  Ekkor jöttek létre a
      <acronym>COFF</acronym>, <acronym>ECOFF</acronym> és
      más hasonló formátumok, amelyek
      elõbb-utóbb korlátokba ütköztek,
      még mielõtt a történelem
      megállapodott volna az <acronym>ELF</acronym>
      formátumnál.</para>

    <para>Ráadásul a programok méretei egyre
      inkább kezdtek nõni, miközben a lemezek (valamint
      a fizikai memória) továbbra is viszonylag kicsik
      maradtak, ezért megszületett az osztott
      könyvtár ötlete, és a virtuális
      memóriát kezelõ alrendszer is sokat finomodott.
      Mivel ezek a különbözõ fejlesztések az
      <filename>a.out</filename> formátumra épültek,
      annak használatósága a beletömött
      módosítások számával
      együtt romlott.  Emellett az emberek még szerettek
      volna betölteni különféle dolgokat
      futási idõben dinamikusan, vagy éppen a
      memória és a lapozóállomány
      megspórolásához kipucolni a programjaik egyes
      részeit az inicializáló
      kódrészletek lefutása után.  A
      programozási nyelvek is fejlõdtek, és az
      emberek a fõprogram futása elõtt is akartak
      kódot futtatni.  Az <filename>a.out</filename>
      formátum rengeteg apró foltozáson esett
      keresztül, amelyek egy ideig még tudták is
      tartani magukat.  Azonban egy idõ után már az
      <filename>a.out</filename> formátum egyre növekvõ
      teljesítménycsökkenés nélkül
      már nem volt képes állni a sarat.
      Habár az <acronym>ELF</acronym> megszüntette a
      fennálló problémák jelentõs
      részét, egyúttal megnehezítette egy
      alapvetõen mûködõ rendszer
      leváltását.  Ezért az
      <acronym>ELF</acronym> formátumnak meg kellett
      várnia azt a pillanatot, amikorra az
      <filename>a.out</filename> használata már
      kényelmetlenné vált.</para>

    <para>Azonban ahogy múlt az idõ, az
      eszközökbõl, amelyekbõl a &os; a
      fordításához szükséges
      eszközöket származtatta (különösen
      az assembler és a betöltõ),létrejött
      két párhuzamos fejlesztési fa.  A &os;-fa
      kiegészült az osztott könyvtárak
      támogatásával és hibákat
      javított, miközben a GNU-fa alkotói, akik
      eredetileg készítették ezeket a programokat,
      újraírták az eszközeiket és a
      keresztfordításhoz egyszerûbb
      támogatást készítettek,
      cserélhetõvé tették a
      különbözõ formátumokat és
      így tovább.  Sokan akartak &os;-re
      keresztfordítani, azonban nem volt
      szerencséjük, mert a &os; régebbi
      forrásait az <application>as</application> és
      <application>ld</application> már nem emésztette
      meg.  Az új GNU eszköztár (a
      <application>binutils</application>) viszont ismeri már a
      keresztfordítást, az <acronym>ELF</acronym>
      formátumot, az osztott könyvtárakat, a C++
      kiterjesztéseit stb.  Idõközben egyre több
      gyártó <acronym>ELF</acronym>
      formátumú binárisokat adott ki, és
      jó érzés volt ezeket &os;-n is
      futtatni.</para>

    <para>Az <acronym>ELF</acronym> sokkal kifejezõbb az
      <filename>a.out</filename> formátumnál, és
      jóval több bõvítési
      lehetõséget enged az alaprendszerben.  Az
      <acronym>ELF</acronym> formátumhoz tartozó
      eszközöket jobban karbantartják és
      támogatja a keresztfordítást, ami viszont
      sokaknak fontos.  Az <acronym>ELF</acronym> talán
      némileg lassabb, mint az <filename>a.out</filename>,
      azonban ez nehezen mérhetõ le.  Számos
      részletben eltérnek ugyan, például
      hogyan képeznek le lapokat, hogyan kezelik az
      inicializáló kódot stb., de ezek egyike sem
      igazán fontos.  Idõvel az <filename>a.out</filename>
      támogatása ki fog kerülni a
      <filename>GENERIC</filename> rendszermagból, és
      végül majd teljesen eltávolításra
      kerül, ahogy a régi <filename>a.out</filename>
      formátumú programok szépen lassan
      kifutnak.</para>

  </sect1>

  <sect1 xml:id="basics-more-information">
    <title>Bõvebben olvashatunk...</title>

    <sect2 xml:id="basics-man">
      <title>Man oldalak</title>

      <indexterm><primary>man oldalak</primary></indexterm>

      <para>A &os; legátfogóbb
	dokumentációja a benne található man
	oldalak összessége.  A rendszerben
	található szinte majdnem mindegyik programhoz
	létezik egy rövid használati
	útmutató, amely bemutatja az adott program
	alapvetõ mûködését és a
	különbözõ beállításait.
	Ezek a leírások a <command>man</command> parancs
	segítségével jeleníthetõek meg.
	A <command>man</command> parancs használata
	egyszerû:</para>

      <screen>&prompt.user; <userinput>man parancs</userinput></screen>

      <para>ahol a <literal>parancs</literal> a megismerni
	kívánt parancsra utal.  Például ha
	az <command>ls</command> parancsról szeretnénk
	többet megtudni, írjuk be:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>Az elérhetõ használati
	útmutatókat a következõ számozott
	szakaszokra osztották:</para>

      <orderedlist>
	<listitem>
	  <para>Felhasználói parancsok</para>
	</listitem>

	<listitem>
	  <para>Rendszerhívások és
	    hibakódok</para>
	</listitem>

	<listitem>
	  <para>A C függvénykönyvtár
	    függvényei</para>
	</listitem>

	<listitem>
	  <para>Eszközmeghajtók</para>
	</listitem>

	<listitem>
	  <para>Állományformátumok</para>
	</listitem>

	<listitem>
	  <para>Játékok és egyéb
	    szórakoztató alkalmazások</para>
	</listitem>

	<listitem>
	  <para>Egyéb információk</para>
	</listitem>

	<listitem>
	  <para>Rendszerkarbantartási és
	    -mûködtetési parancsok</para>
	</listitem>

	<listitem>
	  <para>Rendszermagfejlesztõk számára</para>
	</listitem>
      </orderedlist>

      <para>Bizonyos esetekben ugyanaz a téma az
	útmutatók több szakaszában is
	elérhetõ.  Például létezik
	<command>chmod</command> felhasználói parancs
	és a <function>chmod()</function>
	rendszerhívás.  Ilyenkor a <command>man</command>
	parancsnak meg tudjuk adni pontosan, melyik szakaszra is vagyunk
	kíváncsiak:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>Ennek hatására a <command>chmod</command>
	felhasználói parancshoz tartozó oldal
	jelenik meg.  Írott formában a használati
	útmutatók különbözõ
	szakaszaira hagyományosan a név után
	zárójelbe tett számmal hivatkoznak,
	így a &man.chmod.1; a <command>chmod</command>
	felhasználói parancs és a &man.chmod.2; a
	rendszerhívás.</para>

      <para>Ez a módszer remekül mûködik abban az
	esetben, amikor ismerjük a parancs nevét, azonban
	mit tegyünk akkor, ha nem is emlékszünk a
	nevére?  A <command>man</command> parancs a
	<option>-k</option> segítségével
	paraméterezhetõ úgy is, hogy a parancsok
	leírásai között keressen valamilyen
	kulcsszó mentén:</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>Ezzel a paranccsal megkapjuk azon parancsok
	listáját, amelyek leírásában
	szerepel a <quote>mail</quote> kulcsszó.  Ez
	egyébként mûködésében
	teljesen megegyezik a <command>apropos</command>
	paranccsal.</para>

      <para>Szóval szeretnénk megtudni, hogy a
	<filename>/usr/bin</filename> könyvtárban levõ
	parancsok pontosan mit is csinálnak?  Ehhez írjuk
	be:</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

	<para>vagy</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

	<para>ami ugyanezt teszi.</para>

    </sect2>

    <sect2 xml:id="basics-info">
      <title>A GNU info állományok</title>

      <indexterm><primary>Szabad Szoftver
	Alapítvány</primary></indexterm>

      <para>A &os;-ben megtalálható a Szabad Szoftver
	Alapítvány (Free Software Foundation, FSF)
	által készített számos
	alkalmazás.  Ezek a programok a szokványos man
	oldalakon kívül még általában
	tartalmaznak egy <literal>info</literal>nak nevezett, sokkal
	részletesebb hipertext alapú leírást
	is, amelyeket az <command>info</command> paranccsal, vagy ha van
	fenn <application>emacs</application>, akkor annak az info
	módjában tudjuk megjeleníteni.</para>

      <para>Az &man.info.1; parancs használatához ennyit
	kell beírnunk:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>Itt a <literal>h</literal> lenyomásával kapunk
	egy rövid bemutatkozást.  A parancsok rövid
	listáját a <literal>?</literal> billentyû
	hozza elõ.</para>

    </sect2>
  </sect1>
</chapter>
