<?xml version="1.0" encoding="iso-8859-2"?>
<!--
     The FreeBSD Documentation Project

     $FreeBSD$
-->
<!-- The FreeBSD Hungarian Documentation Project
     Translated by: PALI, Gabor <pgj@FreeBSD.org>
     %SOURCE%	en_US.ISO8859-1/books/handbook/cutting-edge/chapter.xml
     %SRCID%	1.249
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="updating-upgrading" xml:lang="hu">
  <info><title>A &os; frissítése és frissen
    tartása</title>
    <authorgroup>
      <author><personname><firstname>Jim</firstname><surname>Mock</surname></personname><contrib>Átdolgozta, átrendezte és egyes
	  részeit aktualizálta: </contrib></author>
    </authorgroup>
    <authorgroup>
      <author><personname><firstname>Jordan</firstname><surname>Hubbard</surname></personname><contrib>Eredetileg írta: </contrib></author>
      <author><personname><firstname>Poul-Henning</firstname><surname>Kamp</surname></personname></author>
      <author><personname><firstname>John</firstname><surname>Polstra</surname></personname></author>
      <author><personname><firstname>Nik</firstname><surname>Clayton</surname></personname></author>
    </authorgroup>
  </info>

  

  <sect1 xml:id="updating-upgrading-synopsis">
    <title>Áttekintés</title>

    <para>A &os; a kiadások közt is állandó
      fejlõdésben van.  Vannak felhasználók,
      akik a hivatalosan kiadott változatokat
      használják, és vannak, akik szeretik
      folyamatosan nyomonkövetni a fejlesztéseket.  Emellett
      viszont a hivatalos kiadások esetében
      szükség lehet bizonyos biztonsági
      frissítések és kritikus
      javítások alkalmazására.
      Függetlenül a pillanatnyilag használt
      változattól, a &os; alaprendszerében
      megtalálható minden olyan eszköz, amellyel
      könnyedén frissíteni tudunk a
      különbözõ verziók között.
      Ebben a fejezetben segítünk dönteni a
      fejlesztõi változat és a kiadások
      használata között.  Továbbá
      megismerhetjük a rendszer frissítéséhez
      használható alapvetõ
      eszközöket.</para>

    <para>A fejezet elolvasása során
      megismerjük:</para>

    <itemizedlist>
      <listitem>
	<para>milyen segédprogramokkal tudjuk frissíteni
	  az alaprendszert és a Portgyûjteményt;</para>
      </listitem>

      <listitem>
	<para>hogyan tartsuk naprakészen rendszerünket a
	  <application>freebsd-update</application>,
	  <application>CVSup</application>,
	  <application>CVS</application> vagy
	  <application>CTM</application>
	  használatával;</para>
      </listitem>

      <listitem>
	<para>hogyan vessük össze a telepített
	  rendszerünk aktuális állapotát egy
	  ismert eredeti változattal;</para>
      </listitem>

      <listitem>
	<para>hogyan frissítsük a
	  dokumentációt <application>CVSup</application>
	  vagy dokumentációs portok<!-- és
	  <application>Docsnap</application>-->
	  segítségével.</para>
      </listitem>

      <listitem>
	<para>a két fejlesztõi ág, a &os.stable;
	  és a &os.current; közti
	  különbséget;</para>
      </listitem>

      <listitem>
	<para>a <command>make buildworld</command> (stb.)
	  segítségével hogyan fordítsuk
	  és telepítsük újra az egész
	  alaprendszert.</para>
      </listitem>
    </itemizedlist>

    <para>A fejezet elolvasásához ajánlott:</para>

    <itemizedlist>
      <listitem>
	<para>a hálózati kapcsolatunk helyes
	  beállítása (<xref linkend="advanced-networking"/>);</para>
      </listitem>
      <listitem>
	<para>a külsõ szoftverek
	  telepítésének ismerete (<xref linkend="ports"/>).</para>
	    </listitem>
    </itemizedlist>

    <note>
      <para>A fejezetben a &os; forrásainak
	frissítését a <command>cvsup</command>
	parancs segítségével fogjuk
	elvégezni.  Ehhez telepítsük a <package>net/cvsup</package> portot vagy csomagot (ha a
	<command>cvsup</command> parancsot nem akarjuk grafikus
	felületen keresztül használni, akkor
	elegendõ csak a <filename>net/cvsup-without-gui</filename>
	portot).  Ha a &os; 6.2-RELEASE vagy késõbbi
	változatával rendelkezünk, akkor
	elegendõ csak az alaprendszer részeként
	elérhetõ &man.csup.1; programot
	használnunk.</para>
    </note>
  </sect1>

  <sect1 xml:id="updating-upgrading-freebsdupdate">
    <info><title>A &os; frissítése</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Írta: </contrib></author>
      </authorgroup>

      <authorgroup>
	<author><personname><firstname>Colin</firstname><surname>Percival</surname></personname><contrib>A megíráshoz felhasznált
	    jegyzeteket készítette: </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>frissítés és frissen tartás</primary></indexterm>

    <indexterm>
      <primary>freebsd-update</primary>
      <see>frissítés és frissen tartás</see>
    </indexterm>

    <para>A biztonsági javítások
      telepítése minden
      számítógépes szoftver,
      különösen az operációs rendszerek
      számára lényeges mozzanat.  Nagyon
      hosszú ideig ez a &os; esetében nem volt
      könnyen megoldható: a javításokat
      közvetlenül a forráskódon kellett
      elvégezni, ezekbõl újrafordítani a
      rendszert, majd telepíteni.</para>

    <para>Ez a nehézség mostanra viszont már
      elhárult, mivel a &os; legfrissebb verziói már
      tartalmaznak egy <command>freebsd-update</command> nevû
      segédprogramot, amellyel mindez leegyszerûsödik.
      Ez a program két külön funkciót lát
      el.  Elõször is, lehetõvé teszi, hogy a &os;
      alaprendszer újrafordítása és
      -telepítése nélkül javítsunk
      biztonsági és egyéb apró
      hibákat, valamint másodsorban támogatja a
      kisebb és nagyobb verziójú kiadások
      közti váltást.</para>

    <note>
      <para>Ezek a bináris frissítések azonban csak
	a &os; biztonsági csapata által is felügyelt
	architektúrák és kiadások
	esetén érhetõek el.  Emellett bizonyos
	lehetõségek használatához,
	például a &os; verziói közti
	átállás támogatásához
	a &man.freebsd-update.8; legújabb változata
	szükségeltetik.  Ezért ne felejtsük el
	alaposan átolvasni a legújabb
	kiadásokról szóló
	bejelentéseket mielõtt frissítenénk
	rájuk, mivel ezzel kapcsolatban fontos
	információkat tartalmazhatnak.  Az említett
	bejelentések a <uri xlink:href="http://www.FreeBSD.org/releases/">http://www.FreeBSD.org/releases/</uri> címen
	érhetõek el.</para>
    </note>

    <para>Ha a <command>crontab</command> már hivatkozik a
      <command>freebsd-update</command> programra, akkor a most
      következõ mûvelet elkezdése elõtt
      tiltsuk le.</para>

    <sect2 xml:id="freebsdupdate-config-file">
      <title>A konfigurációs állományok</title>

      <para>Ha változtatnénk szeretnénk a
	frissítési folyamaton, ekkor a programhoz
	tartozó, <filename>/etc/freebsd-update.conf</filename>
	nevû konfigurációs állományt
	kell módosítanunk.  Az opciók
	részletes ismertetéssel rendelkeznek, habár
	némelyiknél még további
	magyarázat kellhet:</para>

      <programlisting># Az alaprendszerben frissíteni kívánt komponensek
Components src world kernel</programlisting>

      <para>Ezzel a paraméterrel határozhatjuk meg, hogy a
	&os; mely részei kerüljenek frissítésre.
	Alapértelmezés szerint a program frissíti a
	forrásokat, a teljes alaprendszert és a
	rendszermagot.  Komponensként a
	telepítésnél választható
	elemeket adhatjuk meg, például "world/games"
	hozzáadásakor a games kategória elemei is
	folyamatosan frissülni fognak.  Az "src/bin"
	megadásakor pedig az <filename>src/bin</filename> könyvtár
	tartalma frissül.</para>

      <para>Ezt a beállítást a legjobb meghagyni az
	alapértelmezett értéken, mivel a
	további elemek megadásánál
	egyenként fel kell sorolni a frissítendõ
	komponenseket.  Ha itt viszont kifelejtünk valamit, akkor
	könnyen megeshet, hogy a források és a
	binárisok verziója elcsúszik
	egymástól.</para>

      <programlisting># Az IgnorePaths beállítás után megadott szövegre illeszkedõ összes
# bejegyzés frissítése kimarad
IgnorePaths</programlisting>

      <para>Ennél a beállításnál
	azokat a könyvtárakat kell megadnunk, amelyeket
	(és tartalmukat) ki szeretnénk hagyni a
	frissítés során.  Ezek lehetnek
	például a <filename>/bin</filename> vagy az <filename>/sbin</filename>.  Így meg tudjuk
	akadályozni, hogy <command>freebsd-update</command>
	esetleg felülírjon valamilyen helyi
	változtatást a rendszerünkben.</para>

      <programlisting># Az UpdateIfUnmodified beállítás után megadott elérési útvonalakon csak
# a felhasználó által még nem módosított állományok fognak frissülni
# (hacsak a módosításokat össze nem fésüljük, lásd lentebb)
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</programlisting>

      <para>A megadott könyvtárakban csak azokat a
	konfigurációs állományokat fogja
	frissíteni, amelyeket nem változtattuk meg.
	Amennyiben bármelyikük eltér az eredetileg
	frissítendõ változattól, azt a program
	nem módosítja.  Létezik egy másik
	hasonló beállítás, a
	<literal>KeepModifiedMetadata</literal>, amely
	hatására a <command>freebsd-update</command> az
	összefésülés során elmenti a
	változtatásokat.</para>

      <programlisting># A MergeChanges beállításnál szereplõ állományok helyi módosításait
# automatikusan összefésüljük a &os; újabb verziójára frissítése közben
MergeChanges /etc/ /var/named/etc/</programlisting>

      <para>Itt azokat a könyvtárakat adhatjuk meg,
	amelyekben a <command>freebsd-update</command>
	számára engedélyezzük a
	konfigurációs állományok új
	verziójának
	összefésülését a jelenlegi
	állapottal.  Az összefésülés
	lényegében a &man.mergemaster.8;
	használatánál már megszokott
	módon, &man.diff.1; formátumban érkezõ
	módosítások sorozata alapján
	történik.  Ekkor egy szövegszerkesztõ
	segítségével felügyelhetjük az
	összefésülés menetét vagy
	megállíthatjuk a <command>freebsd-update</command>
	futását.  Ha kétségeink
	adódnak, akkor egyszerûen mentsük le az
	<filename>/etc</filename>
	könyvtárat és fogadjuk el mindegyik
	összefésülés eredményét.
	A <command>mergemaster</command>
	mûködésérõl a <xref linkend="mergemaster"/> ad részletesebb
	tájékoztatást.</para>

      <programlisting># A &os; frissítésekor ezt a könyvtárat fogja a program használni a
# letöltött módosítások és az egyéb ideiglenes állományok tárolására
# WorkDir /var/db/freebsd-update</programlisting>

      <para>Az itt megadott könyvtárba fognak kerülni
	az elvégzendõ módosítások
	és az egyéb ideiglenesen keletkezõ
	állományok.  A verziók közti
	váltás során ebben a
	könyvtárban ajánlott legalább
	1&nbsp;GB szabad tárterületnek lennie.</para>

      <programlisting># A kiadások közti váltás során a Components beállításnál megadott
# elemek kerüljenek csak frissítésre (StrictComponents yes), vagy a
# program próbálja meg magától kitalálni, hogy milyen komponesek
# *lehetnek* fenn a rendszeren és azokat frissítse (StrictComponents
# no)?
# StrictComponents no</programlisting>

      <para>Ha ennél a beállításnál a
	<literal>yes</literal> értéket adjuk meg, akkor a
	<command>freebsd-update</command> feltételezni fogja,
	hogy a <literal>Components</literal> opciónál
	felsoroltunk minden frissítendõ komponenst és
	nem próbál meg mást is
	megváltoztatni.  Ilyenkor tehát a
	<command>freebsd-update</command> tulajdonképpen
	egyedül csak a <literal>Components</literal> által
	meghatározott elemekhez tartozó
	állományokat fogja frissíteni.</para>
    </sect2>

    <sect2 xml:id="freebsdupdate-security-patches">
      <title>Biztonsági javítások</title>

      <para>A biztonsági javítások mindig egy
	távoli gépen tárolódnak, a
	következõ parancsok használatával
	tölthetõek le és
	telepíthetõek:</para>

      <screen>&prompt.root; <userinput>freebsd-update fetch</userinput>
&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Amennyiben a rendszermagot is érintik
	javítások, úgy a rendszert a mûvelet
	befejezõdésével újra kell
	indítanunk.  Ha minden a megfelelõ módon
	történt, akkor a rendszerünk már
	tartalmazni fogja a korábban letöltött
	és telepített javításokat, és
	a <command>freebsd-update</command> akár
	beállítható egy naponta
	végrehajtandó &man.cron.8; feladatnak.  Ehhez
	mindössze a következõ bejegyzést kell
	elhelyeznünk az <filename>/etc/crontab</filename>
	állományban:</para>

      <programlisting>@daily                                  root    freebsd-update cron</programlisting>

      <para>A bejegyzés szerint naponta egyszer le fog futni a
	<command>freebsd-update</command>.  Ilyenkor, vagyis a
	<option>cron</option> paraméter megadásakor a
	<command>freebsd-update</command> csak ellenõrzi, hogy
	vannak-e telepítendõ frissítések.  Ha
	talál, akkor automatikusan letölti ezeket a lemezre,
	de nem telepíti.  Helyette levélben
	értesíti a <systemitem class="username">root</systemitem>
	felhasználót, aki ezután bármikor
	manuálisan kérheti a
	telepítést.</para>

      <para>Probléma esetén az alábbi paranccsal
	megkérhetjük a <command>freebsd-update</command>
	programot a legutóbb telepített
	módosítások
	visszavonására:</para>

      <screen>&prompt.root; <userinput>freebsd-update rollback</userinput></screen>

      <para>Ha ez a visszavonás a rendszermagra vagy annak
	moduljaira is vonatkozott, akkor a rendszert újra kell
	indítanunk a parancs futásának
	befejezõdésével.  A &os; csak ilyenkor
	képes betölteni az új binárisokat
	betölteni a memóriába.</para>

      <para>A <command>freebsd-update</command>
	önmagától csak a <literal>GENERIC</literal>
	típusú rendszermagokat képes
	frissíteni.  Ha saját rendszermagot
	használunk, akkor azt a rendszer többi
	komponensének frissítését
	követõen újra kell fordítanunk és
	telepítenünk.  A <command>freebsd-update</command>
	azonban még akkor is érzekelni és
	frissíteni fogja a <literal>GENERIC</literal>
	rendszermagot (amennyiben az létezik), ha az éppen
	nem az aktuális(an futó) rendszermag.</para>

      <note>
	<para>Mindig érdemes tartani egy másolatot a
	  <literal>GENERIC</literal> rendszermagról a <filename>/boot/GENERIC</filename>
	  könyvtárban.  Rengeteg
	  különbözõ probléma
	  felderítésében tud segíteni,
	  illetve ez a <xref linkend="freebsdupdate-upgrade"/> szakaszban
	  leírt <command>freebsd-update</command> programmal
	  végzett frissítéseknél is hasznos
	  lehet.</para>
      </note>

      <para>Hacsak nem változtatjuk meg az
	<filename>/etc/freebsd-update.conf</filename>
	állományt, a <command>freebsd-update</command> a
	rendszermag forrásait is frissíti a többivel
	együtt.  A saját rendszermag
	újrafordítása és
	telepítése ezután a már a megszokott
	módon elvégezhetõ.</para>

      <note>
	<para>A <command>freebsd-update</command> által
	  terjesztett frissítések nem mindig érintik
	  a rendszermagot.  Ha a rendszermag forrásai nem
	  változnak egy <command>freebsd-update
	    install</command> parancs kiadása során, akkor
	  nem kötelezõ újrafordítani a
	  saját rendszermagot.  A
	  <command>freebsd-update</command> viszont mindig
	  módosítani fogja a
	  <filename>/usr/src/sys/conf/newvers.sh</filename>
	  állományt.  Itt az aktuális
	  hibajavítás sorszáma szerepel (amelyet a
	  <literal>-p</literal> (mint <quote>patch
	    level</quote> elõtaggal kapcsolnak a rendszer
	  verziójához, és a <command>uname
	    -r</command> paranccsal lehet lekérdezni).  Ennek
	  megfelelõen tehát a saját rendszermag
	  újrafordítása után, még ha
	  semmi más nem is változott, a &man.uname.1;
	  képes pontosan jelezni a rendszerhez
	  készült hibajavítás
	  sorszámát.  Ez különösen fontos
	  több rendszer karbantartása során, mivel
	  így könnyen és gyorsan
	  tájékozódhatunk azok
	  naprakészségérõl.</para>
      </note>
    </sect2>

    <sect2 xml:id="freebsdupdate-upgrade">
      <title>Váltás kisebb és nagyobb
	verziók között</title>

      <para>Verziók közti váltás során
	a külsõ alkalmazások
	mûkõdését akadályozó
	régi tárgykódok és
	függvénykönyvtárak törlõdni
	fognak.  Ezért javasoljuk, hogy vagy
	töröljük le az összes portot és
	telepítsük újra, vagy az alaprendszer
	frissítése után hozzuk ezeket is
	naprakész állapotba a <package>ports-mgmt/portupgrade</package>
	segédprogram segítségével.
	Elõször minden bizonnyal szeretnék
	kipróbálni a frissítést, ezt a
	következõ paranccsal tehetjük meg:</para>

      <screen>&prompt.root; <userinput>portupgrade -af</userinput></screen>

      <para>Ezzel gondoskodunk róla, hogy a minden a
	megfelelõen telepítõdjön újra.  Ha a
	<envar>BATCH</envar> környezeti változót a
	<literal>yes</literal> értékre
	állítjuk, akkor a folyamat során
	megjelenõ összes kérdésre automatikusan
	a <literal>yes</literal> választ adjuk, ezáltal
	önállósítani tudjuk.</para>

      <para>Ha saját rendszermagot használunk, akkor
	ennél valamivel azért több feladatunk van.
	Szükségünk lesz a <literal>GENERIC</literal>
	rendszermagot egy példányára, amelyet
	másoljunk a <filename>/boot/GENERIC</filename>
	könyvtárba.  Amennyiben nincs
	<literal>GENERIC</literal> típusú rendszermag a
	rendszerünkön, a következõ módok
	valamelyikén keresztül tudunk szerezni:</para>

      <itemizedlist>
	<listitem>
	  <para>Ha a saját rendszermagot még csak egyszer
	    fordítottuk, akkor a <filename>/boot/kernel.old</filename>
	    könyvtárban még
	    megtalálható a <literal>GENERIC</literal>.
	    Ezt nevezzük át egyszerûen <filename>/boot/GENERIC</filename>
	    könyvtárra.</para>
	</listitem>

	<listitem>
	  <para>Ha fizikailag hozzá tudunk férni az
	    érintett géphez, akkor a
	    <literal>GENERIC</literal> egy
	    példányát akár CD-rõl is
	    átmásolhatjuk.  Helyezzük be a
	    telepítõlemezt és adjuk ki a
	    következõ parancsokat:</para>

	  <screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>cd /cdrom/X.Y-RELEASE/kernels</userinput>
&prompt.root; <userinput>./install.sh GENERIC</userinput></screen>

	  <para>Itt a <filename>X.Y-RELEASE</filename>
	    könyvtár nevében
	    értelemszerûen helyettesítsük be az
	    általunk használt változatot.  A
	    <literal>GENERIC</literal> rendszermag ekkor
	    alapértelmezés szerint a <filename>/boot/GENERIC</filename>
	    könyvtárba kerül.</para>
	</listitem>

	<listitem>
	  <para>Ha az elõbbiek közül egyik sem
	    lehetséges, akkor a <literal>GENERIC</literal>
	    rendszermagot közvetlenül akár
	    forrásból is lefordíthatjuk és
	    telepíthetjük:</para>

	  <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>env DESTDIR=/boot/GENERIC make kernel</userinput>
&prompt.root; <userinput>mv /boot/GENERIC/boot/kernel/* /boot/GENERIC</userinput>
&prompt.root; <userinput>rm -rf /boot/GENERIC/boot</userinput></screen>

	  <para>A <command>freebsd-update</command> akkor fogja ezt
	    <literal>GENERIC</literal> rendszermagként
	    felismerni, ha a hozzá tartozó
	    konfigurációs állományt nem
	    módosítjuk.  Továbbá javasoljuk,
	    hogy semmilyen speciális
	    beállítást ne alkalmazzunk a
	    fordítás során (érdemes
	    üresen hagyni ehhez az
	    <filename>/etc/make.conf</filename>
	    állományt).</para>
	</listitem>
      </itemizedlist>

      <para>Nem kötelezõ újraindítani a
	rendszert a <literal>GENERIC</literal> rendszermaggal.</para>

      <para>A <command>freebsd-update</command> képes
	frissíteni rendszerünket egy adott kiadásra.
	Például a következõ paraméterek
	megadásával válthatunk a &os;&nbsp;6.4
	használatára:</para>

      <screen>&prompt.root; <userinput>freebsd-update -r 6.4-RELEASE upgrade</userinput></screen>

      <para>A parancs elindulása után nem sokkal, a
	váltáshoz szükséges
	információk
	összegyûjtéséhez a
	<command>freebsd-update</command> elemzi a
	konfigurációs állományában
	megadott beállításokat és a rendszer
	jelenleg használt verzióját.  A
	képernyõn ekkor sorban megjelennek a program
	részérõl érzékelt és nem
	érzékelt komponensek.  Mint például
	ahogy itt látható:</para>

      <screen>Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature for 6.3-RELEASE from update1.FreeBSD.org... done.
Fetching metadata index... done.
Inspecting system... done.

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD do not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable (y/n)? y</screen>

      <para>Ekkor a <command>freebsd-update</command>
	megpróbálja letölteni a verziók
	közti váltáshoz szükséges
	összes állományt.  Bizonyos esetekben
	kérdésekkel fordul a felhasználó
	felé arra vonatkozóan, hogy miket
	telepítsen fel vagy mit csináljon.</para>

      <para>A saját rendszermag használatakor az
	iménti lépés valamilyen ehhez hasonló
	figyelmeztetést fog adni:</para>

      <screen>WARNING: This system is running a "<replaceable>SAJÁT RENDSZERMAG</replaceable>" kernel, which is not a
kernel configuration distributed as part of FreeBSD 6.3-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running "/usr/sbin/freebsd-update install"</screen>

      <para>Ez a figyelmeztetés most nyugodtan figyelmen
	kívül hagyható.  A folyamat során a
	frissített <literal>GENERIC</literal> rendszermagot
	fogjuk használni.</para>

      <para>A javítások letöltését
	követõen megkezdõdik a
	telepítésük.  A váltás ezen
	lépése az adott gép aktuális
	terhelésétõl és
	sebességétõl függõen
	változó hosszúságú lehet.
	Ezután a konfigurációs
	állományok összefésülése
	zajlik le &mdash; itt általában a emberi
	felügyeletre is szükség van az
	állományok
	összefésülésének
	irányításához, amelynek folyamatosan
	láthatóak az eredményei.  A
	meghiúsult vagy kihagyott
	összefésülések a teljes
	frissítési folyamat leállását
	vonják maguk után.  Az <filename>/etc</filename> könyvtárban
	tárolt fontosabb állományokról, mint
	például a <filename>master.passwd</filename> vagy
	<filename>group</filename> javasolt elõzetesen
	biztonsági mentést készíteni
	és késõbb kézzel hozzájuk adni
	a változtatásaikat.</para>

      <note>
	<para>A rendszerben ekkor még nem lesz jelen semmilyen
	  konkrét változás, az összes
	  említett javítás és
	  összefésülés egy külön
	  könyvtárban történik.  A
	  telepített javításokat és az
	  összefésült konfigurációs
	  állományokat a folyamat végén
	  magának a felhasználónak kell
	  véglegesíteni.</para>
      </note>

      <para>A frissítési eljárás
	végén a következõ parancs
	kiadásával tudjuk ténylegesen
	érvényesíteni az eddig elvégzett
	módosításokat:</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Elõször mindig a rendszermag és a
	hozzá tartozó modulok cserélõdnek le.
	Ahogy ez végrehajtódott, újra kell
	indítanunk a rendszert.  Ha saját rendszermagot
	használunk, akkor a &man.nextboot.8; parancs
	segítségével állítsuk be a
	következõ rendszerindítás során
	betöltendõ rendszermagot a <filename>/boot/GENERIC</filename>
	könyvtárban levõre (ezt
	frissítettük):</para>

      <screen>&prompt.root; <userinput>nextboot -k GENERIC</userinput></screen>

      <warning>
	<para>Mielõtt újraindítanánk a
	  gépünket a <literal>GENERIC</literal>
	  rendszermaggal, gyõzõdjünk meg róla,
	  hogy szerepel benne minden olyan meghajtó, amely
	  elengedhetetlen a rendszer hiánytalan
	  indításához (és képes lesz
	  újra csatlakozni a hálózathoz, ha
	  éppen távolról adminisztráljuk).
	  Ez különösen olyan esetben fontos, amikor a
	  saját rendszermagunkban beépítetten
	  szerepeltek bizonyos modulok.  Ilyenkor a
	  <literal>GENERIC</literal> rendszermag használatakor
	  ezeket a <filename>/boot/loader.conf</filename>
	  állományon keresztül töltethetjük
	  be ideiglenesen.  A frissítés
	  befejezéséig érdemes viszont minden nem
	  létfontosságú szolgáltatást
	  leállítani, leválasztani lemezeket
	  és hálózati megosztásokat
	  stb.</para>
      </warning>

      <para>A rendszerünk most már
	újraindítható a frissített
	rendszermaggal:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <para>A rendszer sikeres újraindulása után
	ismét el kell indítanunk a
	<command>freebsd-update</command> programot, amely
	korábban már elmentette a frissítés
	állapotát, emiatt a legutóbbi
	pontról fog folytatódni, illetve törli az
	osztott könyvtárak és
	tárgykódok régebbi változatait.
	Innen az alábbi paranccsal léphetünk
	tovább:</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <note>
	<para>A függvénykönyvtárak
	  verziói közti eltérések
	  mértékétõl függõen
	  elképzelhetõ, hogy a telepítés az
	  említett három fázis helyett
	  kettõben történik.</para>
      </note>

      <para>Most pedig újra kell fordítanunk vagy
	telepítenünk az összes általunk
	korábban használt külsõ
	alkalmazást.  Erre azért van
	szükségünk, mert bizonyos alkalmazások a
	verziók közti váltás során
	törölt programkönyvtáraktól
	függtek.  Ennek automatizálásában a
	<package>ports-mgmt/portupgrade</package> lesz
	segítségünkre.  Az alkalmazások
	frissítésének
	elindításához a következõ
	parancsokat használjuk:</para>

      <screen>&prompt.root; <userinput>portupgrade -f ruby</userinput>
&prompt.root; <userinput>rm /var/db/pkg/pkgdb.db</userinput>
&prompt.root; <userinput>portupgrade -f ruby18-bdb</userinput>
&prompt.root; <userinput>rm /var/db/pkg/pkgdb.db /usr/ports/INDEX-*.db</userinput>
&prompt.root; <userinput>portupgrade -af</userinput></screen>

      <para>A parancsok lefutását követõen a
	<command>freebsd-update</command> utolsó
	hívásával zárjuk le a
	frissítést.  Ezzel a paranccsal tudunk
	tehát pontot tenni a frissítési
	procedúra végére:</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Ha a <literal>GENERIC</literal> rendszermagot csak
	átmenetileg használtuk, akkor most már a
	megszokott módon fordíthatunk és
	telepíthetünk magunk egy saját
	rendszermagot.</para>

      <para>Indítsuk újra a rendszert a &os;
	frissített változatával.  A folyamat ezzel
	véget ért.</para>
    </sect2>

    <sect2 xml:id="freebsdupdate-system-comparison">
      <title>Rendszerek állapotainak
	összehasonlítása</title>

      <para>A <command>freebsd-update</command> ragyogóan
	felhasználható a &os; egy telepített
	változatának és egy általunk
	garantáltan megbízható
	példányának
	összevetésére.  Ilyenkor a rendszerhez
	tartozó segédprogramokat,
	programkönyvtárakat és
	konfigurációs állományokat
	ellenõriztethetjük le.  Az
	összehasonlítást ezzel a paranccsal
	kezdhetjük meg:</para>

      <screen>&prompt.root; <userinput>freebsd-update IDS &gt;&gt; eredmeny.idk</userinput></screen>

      <warning>
	<para>Habár a parancs neve <acronym>IDS</acronym>
	  (intrusion detection system), nem helyettesít semmilyen
	  olyan behatolásjelzõ megoldást, mint
	  amilyen például a <package>security/snort</package>.  Mivel a
	  <command>freebsd-update</command> adatokat tárol a
	  lemezen, teljesen kézenfekvõ a
	  hamisítás lehetõsége.  Míg
	  ennek eshetõsége adott mértékben
	  visszaszorítható a
	  <varname>kern.securelevel</varname>
	  csökkentésével és a
	  <command>freebsd-update</command> által használt
	  adatok írásvédett
	  állományrendszerre helyezésével,
	  erre a problémára az ideális
	  megoldást mégis egy teljes biztonságban
	  tudható referencia rendszer jelentheti.  Ennek
	  tárolására alkalmas lehet
	  például egy <acronym>DVD</acronym> vagy egy
	  külsõ <acronym>USB</acronym>-egység.</para>
      </warning>

      <para>A parancs kiadása után megkezdõdik a
	rendszer vizsgálata, és az ellenõrzés
	során folyamatosan jelennek meg az
	átvizsgált állományok a
	hozzájuk tartozó ismert és
	kiszámított &man.sha256.1;-kódjukkal
	együtt.  Mivel a képernyõn
	túlságosan gyorsan elúsznának az
	eredmények, ezért ezeket egy
	<filename>eredmeny.idk</filename> nevû
	állományba mentjük a késõbbi
	elemzésekhez.</para>

      <para>Az így keletkezõ állomány sorai
	ugyan meglehetõsen hosszúak, de szerencsére
	viszonylag könnyen értelmezhetõek.
	Például az adott kiadásban szereplõ
	állományoktól eltérõeket ezzel
	a paranccsal kérdezhetjük le:</para>

      <screen>&prompt.root; <userinput>cat eredmeny.idk | awk '{ print $1 }' | more</userinput>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</screen>

      <para>A példában most csak az elsõ
	néhány állományt hagytuk meg, gyakran
	tapasztalhatunk viszont ennél többet.  Ezek
	közül bizonyos állományok
	értelemszerûen eltérnek, mint itt
	például az <filename>/etc/passwd</filename>, mert
	idõközben új felhasználókat
	adtunk a rendszerhez.  Máskor egyéb
	állományok, például modulok nevei is
	felbukkanhatnak, mert tegyük fel, hogy a
	<command>freebsd-update</command> már frissítette
	ezeket.  Ha ki szeretnénk zárni valamilyen
	állományokat vagy könyvtárakat az
	ellenõrzésbõl, egyszerûen csak soroljuk
	fel ezeket az <filename>/etc/freebsd-update.conf</filename>
	állományban megjelenõ
	<literal>IDSIgnorePaths</literal>
	beállításnál.</para>

      <para>A korábban tárgyaltaktól
	függetlenül ez a rendszer alkalmas bonyolultabb
	frissítési folyamatok
	kisegítésére is.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="updating-upgrading-portsnap">
    <info><title>A Portgyûjtemény frissítése a
      Portsnap használatával</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Írta: </contrib></author>
      </authorgroup>

      <authorgroup>
	<author><personname><firstname>Colin</firstname><surname>Percival</surname></personname><contrib>A megíráshoz felhasznált
	    jegyzeteket készítette: </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>frissítés és frissen tartás</primary></indexterm>

    <indexterm>
      <primary>Portsnap</primary>
      <see>frissítés és frissen tartás</see>
    </indexterm>

    <para>A &os; alaprendszer a Portgyûjtemény
      frissítéséhez is tartalmaz egy &man.portsnap.8;
      elnevezésû segédprogramot.  Ez a program
      elindítása után csatlakozik egy távoli
      géphez, ellenõrzi a biztonsági kulcsát
      és letölti a portok legfrissebb változatait.  A
      biztonsági kulcs feladata a frissítés
      közben letöltött állományok
      sértetlenségének szavatolása, ezzel
      gondoskodik róla, hogy az adatok átvitelük
      közben nem változtak meg.  A
      Portgyûjtemény legújabb
      változatát így érhetjük
      el:</para>

    <screen>&prompt.root; <userinput>portsnap fetch</userinput>
Looking up portsnap.FreeBSD.org mirrors... 3 mirrors found.
Fetching snapshot tag from portsnap1.FreeBSD.org... done.
Fetching snapshot metadata... done.
Updating from Wed Aug  6 18:00:22 EDT 2008 to Sat Aug 30 20:24:11 EDT 2008.
Fetching 3 metadata patches.. done.
Applying metadata patches... done.
Fetching 3 metadata files... done.
Fetching 90 patches.....10....20....30....40....50....60....70....80....90. done.
Applying patches... done.
Fetching 133 new ports or files... done.</screen>

    <para>A példában látható, hogy a
      &man.portsnap.8; eltéréseket talált a helyi
      és a távoli rendszerekben fellelhetõ portok
      között, majd azokat ellenõrizte.  Emellett az is
      megfigyelhetõ, hogy korábban már futtatuk a
      programot, mivel ha most indítottuk volna az elsõ
      alkalommal, akkor egyszerûen letöltötte volna a
      teljes Portgyûjteményt.</para>

    <para>Ahogy a &man.portsnap.8; sikeresen befejezi az imént
      kiadott <command>fetch</command> mûvelet
      végrehajtását, a helyi rendszeren már
      telepítésre készen fognak várakozni a
      Portgyûjtemény és az hozzá tartozó
      ellenõrzött módosítások.  A
      <command>portsnap</command> elsõ használatakor az
      <literal>extract</literal> parancs
      segítségével telepíthetjük a
      frissített állományokat:</para>

    <screen>&prompt.root; <userinput>portsnap extract</userinput>
/usr/ports/.cvsignore
/usr/ports/CHANGES
/usr/ports/COPYRIGHT
/usr/ports/GIDs
/usr/ports/KNOBS
/usr/ports/LEGAL
/usr/ports/MOVED
/usr/ports/Makefile
/usr/ports/Mk/bsd.apache.mk
/usr/ports/Mk/bsd.autotools.mk
/usr/ports/Mk/bsd.cmake.mk
<replaceable>...</replaceable></screen>

    <para>Egy korábban már telepített
      Portgyûjteményt a <command>portsnap update</command>
      paranccsal tudunk frissíteni:</para>

    <screen>&prompt.root; <userinput>portsnap update</userinput></screen>

    <para>Ezzel lezárult a portok frissítése,
      innentõl már az aktualizált
      Portgyûjtemény felhasználásával
      tetszõlegesen telepíthetõek vagy
      frissíthetõek az alkalmazások.</para>

    <para>A <literal>fetch</literal>, <literal>extract</literal> vagy
      <literal>update</literal> mûveletek egyetlen parancsba is
      összefûzhetõek, ahogy ezt az alábbi
      példában is láthatjuk:</para>

    <screen>&prompt.root; <userinput>portsnap fetch update</userinput></screen>

    <para>Ez a parancs letölti a Portgyûjtemény
      legfrissebb változatát, majd
      kitömöríti azt a helyi <filename>/usr/ports</filename>
      könyvtárba.</para>
  </sect1>

  <sect1 xml:id="updating-upgrading-documentation">
    <title>A dokumentáció frissítése</title>

    <indexterm><primary>frissítés és frissen
      tartás</primary></indexterm>

    <indexterm>
      <primary>dokumentáció</primary>
      <see>frissítés és frissen tartás</see>
    </indexterm>

    <para>Az alaprendszer és a Portgyûjtemény mellett
      a dokumentáció is a &os; operációs
      rendszer szerves részét képezi.  Noha a &os;
      dokumentációjának legfrissebb
      változata folyamatosan elérhetõ a <link xlink:href="http://www.freebsd.org/doc">&os;
      honlapjáról</link>, egyes
      felhasználók ezt csak lassan vagy nem képesek
      folyamatosan elérni.  Szerencsére egy helyi
      másolat megfelelõ karbantartásával az
      egyes kiadásokhoz tartozó dokumentáció
      is frissíthetõ.</para>

    <sect2 xml:id="csup-doc">
      <title>A dokumentáció frissítése CVSup
	használatával</title>

      <para>A &os; telepített
	dokumentációjának forrásai az
	alaprendszeréhez hasonlóan (lásd <xref linkend="makeworld"/>) a <application>CVSup</application>
	segítségével frissíthetõek.
	Ebben a szakaszban megismerhetjük:</para>

      <itemizedlist>
	<listitem>
	  <para>hogyan telepítsük a
	    dokumentáció
	    elõállításához
	    szükséges eszközöket, amelyekkel a
	    forrásokból újra tudjuk
	    generálni a &os;
	    dokumentációját;</para>
	</listitem>

	<listitem>
	  <para>hogyan töltsük le a dokumentáció
	    forrását <application>CVSup</application>
	    segítségével a <filename>/usr/doc</filename>
	    könyvtárba;</para>
	</listitem>

	<listitem>
	  <para>a dokumentáció
	    elõállításához alkalmazott
	    rendszer milyen beállításokkal
	    rendelkezik, vagyis hogyan korlátozzuk a
	    generálást bizonyos nyelvekre vagy
	    formátumokra.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2 xml:id="installing-documentation-toolchain">
      <title>A CVSup és a dokumentációs
	eszközök telepítése</title>

      <para>Viszonylag sokféle eszközre lesz
	szükségünk, ha a &os;
	dokumentációját a forrásokból
	akarjuk elõállítani.  Ezek az
	segédprogramok nem részei a &os;
	alaprendszerének, mivel alapvetõen nagyon sok helyet
	foglalnak el, és leginkább olyan &os;
	felhasználók számára fontosak, akik
	folyamatosan a dokumentációval dolgoznak vagy
	gyakran frissítik azt forrásból.</para>

      <para>A feladathoz szükséges összes eszköz
	elérhetõ a Portgyûjteménybõl.  Ebben
	a &os; Dokumentációs Projekt
	összeállított egy <package>textproc/docproj</package> nevû portot,
	amellyel az említett programok
	telepítését és
	frissítését igyekezték
	megkönnyíteni.</para>

      <note>
	<para>Ha nem tartunk igényt a dokumentáció
	  &postscript; vagy PDF változatára, akkor ehelyett
	  inkább érdemes megfontolnunk a <package>textproc/docproj-nojadetex</package> port
	  telepítését.  Ebben a változatban
	  a <application>teTeX</application> betûszedõ
	  rendszer kivételével az összes
	  segédprogram megtalálható.  Mivel a
	  <application>teTeX</application> önmagában nagyon
	  sok segédeszköz telepítését
	  jelenti, ezért amennyiben a PDF változat
	  ténylegesen nem szükséges, érdemes
	  eltekinteni a telepítésétõl.</para>
      </note>

      <para>A <application>CVSup</application>
	telepítésével kapcsolatban pedig
	részletesebb információkat a <link linkend="cvsup">CVSup használatával</link>
	foglalkozó szakaszban olvashatunk.</para>
    </sect2>

    <sect2 xml:id="updating-documentation-sources">
      <title>A dokumentáció forrásának
	frissítése</title>

      <para>A <filename>/usr/share/examples/cvsup/doc-supfile</filename>
	konfigurációs állomány
	segítségével a
	<application>CVSup</application> képes letölteni a
	dokumentáció
	forrásállományainak legfrissebb
	példányait.  Itt a frissítést
	alapértelmezés szerint egy nem létezõ
	géptõl fogjuk kérni (mivel ezt
	kötelezõ kitölteni), azonban a &man.cvsup.1;
	programnak egy parancssori paraméter
	segítségével megadhatjuk melyik
	<application>CVSup</application> szerverrõl töltse le
	a forrásokat:</para>

      <screen>&prompt.root; <userinput>cvsup -h cvsup.FreeBSD.org -g -L 2 /usr/share/examples/cvsup/doc-supfile</userinput></screen>

      <para>Ne felejtsük el a
	<replaceable>cvsup.FreeBSD.org</replaceable> helyére
	beírni a hozzánk földrajzilag
	legközelebb elhelyezkedõ
	<application>CVSup</application> szervert.  Ezek teljes
	listáját a <xref linkend="cvsup-mirrors"/>
	tartalmazza.</para>

      <para>Egy ideig eltarthat, amíg elõször
	letöltjük a forrásokat.  Várjuk meg
	türelmesen, amíg befejezõdik a
	mûvelet.</para>

      <para>Késõbb a forrásokat ugyanezzel a
	paranccsal tudjuk frissíteni.  A
	<application>CVSup</application> ugyanis mindig csak a
	legutóbbi futtatása óta történt
	változásokat tölti le, ezért
	késõbb már ez a lépés
	jelentõsen felgyorsulhat.</para>

      <para>A források letöltése után a
	dokumentációt például az ekkor
	keletkezett <filename>/usr/doc</filename>
	könyvtárban található
	<filename>Makefile</filename> használatával
	állíthatjuk elõ.  Tehát miután
	az <filename>/etc/make.conf</filename> állományban
	beállítottuk a <varname>SUP_UPDATE</varname>,
	<varname>SUPHOST</varname> és
	<varname>DOCSUPFILE</varname> változókat, le
	tudjuk futtatni a következõ parancsot:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make update</userinput></screen>

      <para>Az elõbb említett &man.make.1; változók jellemzõ értékei:</para>

      <programlisting>SUP_UPDATE= yes
SUPHOST?= cvsup.freebsd.org
DOCSUPFILE?= /usr/share/examples/cvsup/doc-supfile</programlisting>

      <note>
	<para>Mivel a <varname>SUPHOST</varname> és a
	  <varname>DOCSUPFILE</varname> változók
	  értékét a <literal>?=</literal>
	  szimbólummal állítottuk be,
	  lehetõségünk van a parancssorból
	  ezeknek más értékeket adni.  Az
	  <filename>/etc/make.conf</filename> állományba
	  általában így érdemes felvenni a
	  változókat, így nem kell minden
	  alkalommal módosítani, amikor valamilyen
	  új beállítást akarunk
	  kipróbálni.</para>
      </note>
    </sect2>

    <sect2 xml:id="updating-documentation-options">
      <title>A dokumentáció különbözõ
	beállításai</title>

      <para>A &os; dokumentációjához
	tartozó, frissítést és
	elõállítást végzõ
	rendszernek van néhány olyan
	beállítása, amelyekkel
	kérhetjük kizárólag csak a
	dokumentáció egyes részeinek
	frissítését vagy bizonyos kimeneti
	formátumok használatát.  Ezek vagy
	globálisan az <filename>/etc/make.conf</filename>
	állományban, vagy pedig a parancssorból, a
	&man.make.1; program paramétereként
	adhatóak meg.</para>

      <para>Ízelítõül néhány
	közülük:</para>

      <variablelist>
	<varlistentry>
	  <term><varname>DOC_LANG</varname></term>

	  <listitem>
	    <para>Az elõállítandó és
	      telepítendõ nyelvû
	      dokumentáció felsorolása, tehát
	      például csak az angol
	      dokumentáció esetén ez
	      <literal>en_US.ISO8859-1</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>FORMATS</varname></term>

	  <listitem>
	    <para>Az elõállítandó
	      dokumentáció kimeneti formátumainak
	      felsorolása.  Itt pillanatnyilag
	      értékként a <literal>html</literal>,
	      <literal>html-split</literal>, <literal>txt</literal>,
	      <literal>ps</literal>, <literal>pdf</literal> és
	      <literal>rtf</literal> jelenhet meg.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>SUPHOST</varname></term>

	  <listitem>
	    <para>A frissítéshez használt
	      <application>CVSup</application> szerver
	      hálózati neve.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>DOCDIR</varname></term>

	  <listitem>
	    <para>Az elkészült dokumentáció
	      telepítésének helye.  Ez
	      alapértelmezés szerint a <filename>/usr/share/doc</filename>.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>A folyamathoz kapcsolódóan további
	rendszerszintû &man.make.1; változókról
	a &man.make.conf.5; man oldalon olvashatunk.</para>

      <para>A &os; dokumentációjának
	elõállításáért
	felelõs rendszerben használható &man.make.1;
	további változók
	bemutatásával kapcsolatban pedig olvassuk el az
	<link xlink:href="&url.doc.langbase;/books/fdp-primer">A &os;
	  Dokumentációs Projekt irányelvei
	  kezdõknek</link> címû könyvet.</para>
    </sect2>

    <sect2 xml:id="updating-installed-documentation">
      <title>A &os; dokumentációjának
	telepítése forrásból</title>

      <para>Miután sikerült letöltenünk a
	<filename>/usr/doc</filename>
	könyvtárba a dokumentáció legfrissebb
	forrásait, készen állunk a
	rendszerünkön telepített példány
	frissítésére.</para>

      <para>A <varname>DOCLANG</varname> értékeként
	megadott nyelven készült dokumentációkat
	a következõ paranccsal tudjuk
	frissíteni:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>Ha a <filename>make.conf</filename>
	állományban korábban már megadtuk a
	<varname>DOCSUPFILE</varname>, <varname>SUPHOST</varname>
	és <varname>SUP_UPDATE</varname> változók
	értékeit, akkor a telepítés
	fázisa könnyedén össze is
	vonatható a források
	frissítésével:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make update install clean</userinput></screen>

      <para>Ha pedig csak bizonyos nyelvekhez tartozó
	dokumentációt szeretnénk frissíteni,
	akkor a &man.make.1; akár a <filename>/usr/doc</filename> könyvtáron
	belül az egyes nyelvekhez tartozó
	alkönyvtárakon belül is
	meghívható, például:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc/en_US.ISO8859-1</userinput>
&prompt.root; <userinput>make update install clean</userinput></screen>

      <para>A dokumentáció formátumát a
	<varname>FORMATS</varname> változó
	felhasználásával tudjuk
	meghatározni:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make FORMATS='html html-split' install clean</userinput></screen>
    </sect2>

    <sect2 xml:id="doc-ports">
      <info><title>A dokumentációs portok
	használata</title>
	<authorgroup>
	  <author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>A szóbanforgó megoldást
	      fejlesztette: </contrib></author>
	</authorgroup>
      </info>

      

      <indexterm><primary>frissítés és frissen
	tartás</primary></indexterm>

      <indexterm>
	<primary>dokumentáció</primary>
	<see>frissítés és frissen tartás</see>
      </indexterm>

      <para>Ez elõzõ szakaszban megmutattuk hogyan lehet a
	&os; dokumentációját a források
	felhasználásával frissíteni.  A
	források használatával végzett
	frissítés azonban nem minden &os; rendszer
	esetében lehetséges vagy hatékony.  Ha
	ugyanis a dokumentációs forrásból
	akarjuk elõállítani, viszonylag sok
	eszköz és segédprogram, az ún.
	<emphasis>dokumentációs
	eszközök</emphasis> használatával kell
	tisztában lennünk, valamint bizonyos
	mértékig ismernünk kell a
	<application>CVS</application> használatát, tudunk
	kell kikérni a legfrissebb változatot és
	elõállítatattnunk belõle a
	végleges változatot.  Ezért ebben a
	szakaszban most szót ejtünk egy olyan
	módszerrõl, ahol a &os;
	dokumentációját a
	Portgyûjteményen keresztül tudjuk
	frissíteni, ezáltal:</para>

      <itemizedlist>
	<listitem>
	  <para>anélkül le tudjuk tölteni és
	    telepíteni a dokumentáció adott
	    pillanatban generált változatát, hogy a
	    rendszerünkön bármi további
	    teendõre szükség lenne (ennek
	    köszönhetõen nem kell
	    telepítenünk a dokumentációs
	    eszközöket);</para>
	</listitem>

	<listitem>
	  <para>letölthetjük a dokumentáció
	    forrását és a Portgyûjtemény
	    eszközeivel elõállíthatjuk
	    belõle a megfelelõ változatot (ez a
	    források beszerzésében és
	    feldolgozásában segít
	    valamelyest).</para>
	</listitem>
      </itemizedlist>

      <para>A &os; dokumentáció
	frissítésének fentebb említett
	módjait támogatják tehát a
	<emphasis>dokumentációs portok</emphasis>,
	amelyeket a &a.doceng; havi rendszerességgel tart karban.
	Ezek a portok a &os; Portgyûjteményén
	belül a <link xlink:href="http://www.freshports.org/docs/">docs</link> nevû
	virtuális kategóriában
	találhatóak meg.</para>

      <sect3 xml:id="doc-ports-install-make">
	<title>A dokumentációs portok
	  fordítása és
	  telepítése</title>

	<para>A dokumentáció könnyebb
	  elõállításához a
	  dokumentációs portok a Portgyûjtemény
	  lehetõségeit veszik igénybe.
	  Segítségükkel automatikussá teszik a
	  dokumentáció forrásának
	  letöltését, a &man.make.1; parancs
	  meghívását a megfelelõ
	  környezetben, beállításokkal
	  és parancssori paraméterekkel.  Rajtuk
	  keresztül a dokumentáció
	  eltávolítása ugyanolyan egyszerûen
	  megtehetõ, mint akármelyik másik &os; port
	  vagy csomag esetében.</para>

	<note>
	  <para>Továbbá, amikor a
	    dokumentációs portokat a saját
	    rendszerünkön fordítjuk, a
	    <emphasis>dokumentációs
	    eszközök</emphasis>
	    függõségként automatikusan
	    települni fognak.</para>
	</note>

	<para>A dokumentációs portok a következõ
	  módon szervezõdnek:</para>

	<itemizedlist>
	  <listitem>
	    <para>Létezik egy ún.
	      <quote>fõport</quote>, a <package>misc/freebsd-doc-en</package>, ahol az
	      összes fontosabb állomány
	      megtalálható.  Ez lényegében a
	      dokumentációs portok közös
	      õse.  Alapértelmezés szerint
	      kizárólag csak az angol nyelvû
	      dokumentációt állítja
	      elõ.</para>
	  </listitem>

	  <listitem>
	    <para>Létezik egy <quote>mindenes port</quote>, a
	      <package>misc/freebsd-doc-all</package>,
	      amely az összes elérhetõ nyelven
	      és formátumban elõállítja
	      a dokumentációt.</para>
	  </listitem>

	  <listitem>
	    <para>Végezetül minden nyelvhez létezik
	      egy-egy <quote>alport</quote>, ilyen például a
	      magyar dokumentáció esetén a
	      <package>misc/freebsd-doc-hu</package>
	      port.  Mindegyikük a fõporttól függ
	      és az adott nyelvû dokumentációt
	      telepítik.</para>
	  </listitem>
	</itemizedlist>

	<para>Az eddigi összefoglaltaknak megfelelõen a
	  dokumentációs portokat forrásból a
	  következõ paranccsal lehet telepíteni
	  (<systemitem class="username">root</systemitem>
	  felhasználóként):</para>

	<screen>&prompt.root; <userinput>cd /usr/ports/misc/freebsd-doc-en</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

	<para>Ennek hatására elõáll és
	  telepítõdik a <filename>/usr/local/share/doc/freebsd</filename>
	  könyvtárba az angol nyelvû
	  dokumentáció állományokra bontott
	  <acronym>HTML</acronym> formátumban (hasonlóan a
	  <uri xlink:href="http://www.FreeBSD.org">http://www.FreeBSD.org</uri>
	  tartalmához).</para>

	<sect4 xml:id="doc-ports-options">
	  <title>Gyakori beállítások</title>

	  <para>A dokumentációs portok
	    alapértelmezett viselkedése több
	    különbözõ opció
	    segítségével is
	    befolyásolható.  Ezek közül most
	    összefoglalunk néhányat:</para>

	  <variablelist>
	    <varlistentry>
	      <term><varname>WITH_HTML</varname></term>

	      <listitem>
		<para>Minden dokumentum egyetlen HTML
		  állományba kerüljön.  A
		  végeredmény ekkor az adott dokumentum
		  típusának megfelelõen
		  <filename>article.html</filename> (cikk) vagy
		  <filename>book.html</filename> (könyv)
		  néven keletkezik (képekkel
		  együtt).</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><varname>WITH_PDF</varname></term>

	      <listitem>
		<para>Minden dokumentum &adobe; Portable Document Format
		  típusú állományban
		  jön létre.  Ezek az
		  állományok a
		  <application>Ghostscript</application> vagy más
		  egyéb PDF nézegetõkkel
		  nyithatóak meg.  Ekkor a
		  dokumentáció konkrét
		  típusától függõen az
		  állományok
		  <filename>article.pdf</filename> (cikk) vagy
		  <filename>book.pdf</filename> (könyv)
		  néven állítódnak
		  elõ.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><varname>DOCBASE</varname></term>

	      <listitem>
		<para>A dokumentáció
		  telepítésének helye.
		  Alapértelmezés szerint ez a <filename>/usr/local/share/doc/freebsd</filename>
		  könyvtár.</para>

		<note>
		  <para>Ügyeljünk arra, hogy a
		    telepítés alapértelmezett
		    célkönyvtára eltér a
		    <application>CVSup</application>
		    módszerétõl.  Ugyanis mivel
		    ilyenkor egy portot telepítünk, a
		    tartalma alapértelmezés szerint a
		    <filename>/usr/local</filename>
		    könyvtáron belülre kerül.
		    Ez azonban a <varname>PREFIX</varname>
		    változó
		    átállításával
		    tetszõleges
		    megváltoztatható.</para>
		</note>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Az elõbbieket most egy rövid
	    példán keresztül összefoglaljuk.  A
	    következõ paranccsal tudjuk tehát a magyar
	    nyelvû dokumentáció Portable Document
	    Format változatát telepíteni:</para>

	  <screen>&prompt.root; cd /usr/ports/misc/freebsd-doc-hu
&prompt.root; make -DWITH_PDF DOCBASE=share/doc/freebsd/hu install clean</screen>
	</sect4>
      </sect3>

      <sect3 xml:id="doc-ports-install-package">
	<title>A dokumentációs csomagok
	  használata</title>

	<para>A dokumentációs portok elõzõ
	  szakaszban bemutatott forrásból
	  telepítésével kapcsolatban már
	  említettük, hogy szükséges
	  hozzá a dokumentációs eszközök
	  telepítése, valamint némi szabad
	  tárterület.  Ha a dokumentációs
	  eszközök telepítéséhez nem
	  elengedõek a rendelkezésre álló
	  erõforrásaink vagy a források
	  feldolgozása túlságosan sokat foglalna a
	  rendszerünkön, akkor lehetõségünk
	  van a dokumentációs portok elõre
	  lefordított, csomagolt változatát
	  használni.</para>

	<para>A &a.doceng; minden hónapban
	  elõkészíti a &os; dokumentációs
	  csomagok legfrissebb változatát.  Az így
	  karbantartott bináris csomagok azután
	  tetszõlegesen használhatóak a
	  szabványos csomagkezelõ eszközökkel,
	  mint amilyen például a &man.pkg.add.1;,
	  &man.pkg.delete.1; és így tovább.</para>

	<note>
	  <para>A bináris csomagok használata
	    esetén a &os; dokumentációja az adott
	    nyelvhez az <emphasis>összes</emphasis>
	    elérhetõ formátumban
	    telepítésre kerül.</para>
	</note>

	<para>Például az alábbi paranccsal a magyar
	  nyelvû dokumentációhoz tartozó
	  legfrissebb bináris csomagot tudjuk
	  telepíteni:</para>

	<screen>&prompt.root; <userinput>pkg_add -r hu-freebsd-doc</userinput></screen>

	<note>
	  <para>A csomagok elnevezése eltér a
	    hozzá tartozó port nevétõl.  Alakja a
	    következõ:
	    <literal>nyelv-freebsd-doc</literal>,
	    ahol a <replaceable>nyelv</replaceable> az adott nyelv
	    rövid kódja, vagyis a magyar esetén a
	    <literal>hu</literal>, illetve az egyszerûsített
	    kínai esetén a
	    <literal>zh_ch</literal>.</para>
	</note>
      </sect3>

      <sect3 xml:id="doc-ports-update">
	<title>A dokumentációs portok
	  frissítése</title>

	<para>Az elõzetesen telepített
	  dokumentációs portok bármilyen portok
	  frissítésére alkalmas eszközzel
	  frissíthetõek.  Például a
	  telepített magyar nyelvû
	  dokumentáció a <package>ports-mgmt/portupgrade</package>
	  eszközön keresztül így
	  frissíthetõ csomagok
	  használatával:</para>

	<screen>&prompt.root; <userinput>portupgrade -PP hu-freebsd-doc</userinput></screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="current-stable">
    <title>A fejlesztõi ág követése</title>

    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>A &os;-nek két fejlesztési ága van: a
      &os;.current és a &os.stable;.  Ebben a szakaszban
      mindegyikükrõl monduk pár szót, és
      megmutatjuk, miként lehet az adott ághoz
      igazítani a rendszerünk
      frissítését.  Elõször a
      &os.current;, majd a &os.stable; változata kerül
      tárgyalásra.</para>

    <sect2 xml:id="current">
      <title>A &os; friss változatának
	használata</title>

      <para>Ahogy arról már az imént is szó
	esett, nem szabad elfelejtenünk, hogy a &os.current; a &os;
	fejlesztésének <quote>frontvonala</quote>.  Emiatt
	a &os.current; használóinak szakmailag
	jólképzetteknek kell lenniük, és sosem
	szabad visszariadniuk a használat közben
	felmerülõ rendszerszintû problémák
	önálló megoldásától.  Ha
	korábban még nem foglalkoztunk &os;-vel,
	kétszer is gondoljuk meg a
	telepítését!</para>

      <sect3>
	<title>Mi a &os.current;?</title>

	<indexterm><primary>pillanatkép</primary></indexterm>

	<para>A &os.current; a &os; mögött álló
	  legfrissebb forráskódot képviseli.  Itt
	  találkozhatunk különféle olyan
	  fejlesztés alatt álló részekkel,
	  kísérletezésekkel és
	  átmeneti megoldásokkal, amelyek nem
	  feltétlenül kerülnek bele a szoftver
	  következõ hivatalos kiadásába.  Noha a
	  &os; fejlesztõi a &os.current;
	  forráskódját naponta
	  fordítják, adódhatnak olyan
	  idõszakok, amikor a források mégsem
	  használhatóak maradéktalanul.  Az ilyen
	  gondokat általában a lehetõ leggyorsabban
	  igyekeznek megoldani, azonban attól függõen,
	  hogy éppen a forráskód melyik
	  verzióját sikerült kifogni, a &os.current;
	  használata kész katasztrófa vagy
	  akár a fejlõdésben igazi
	  továbblépés is lehet.</para>

      </sect3>

      <sect3>
	<title>Kinek van szüksége a &os.current;-re?</title>

	<para>A &os.current; használata elsõsorban az
	  alábbi 3 csoportot érinti:</para>

	<orderedlist>
	  <listitem>
	    <para>A &os; közösség azon tagjait, akik
	      aktívan dolgoznak a forrásfa valamelyik
	      részén, és mindazokat, akik
	      számára a <quote>legfrissebb</quote>
	      verzió használata feltétlen
	      elvárás.</para>
	  </listitem>

	  <listitem>
	    <para>A &os; közösség azon tagjait, akik
	      aktívan tesztelnek, és a &os.current;
	      kordában tartásához hajlandóak
	      idõt áldozni a menet közben
	      felbukkanó problémák
	      megoldására.  Vannak olyanok is, akik a &os;
	      változásaival és fejlesztési
	      irányával kapcsolatban
	      kívánnak javaslatokat tenni, melyeket
	      javítások és
	      módosítások formájában
	      tesznek közzé.</para>
	  </listitem>

	  <listitem>
	    <para>Mindazokat, akik pusztán
	      kíváncsiak a fejlesztésben
	      zajló eseményekre, vagy hivatkozási
	      szándékkal töltik le a legfrissebb
	      forrásokat (például csak
	      <emphasis>nézegetik</emphasis>, de nem
	      futtatják).  Az ilyen emberek esetenként
	      megjegyzéseket fûznek a fejlesztéshez
	      vagy kódot küldenek be.</para>
	  </listitem>
	</orderedlist>

      </sect3>

      <sect3>
	<title>Mi <emphasis>nem</emphasis> a &os.current;?</title>

	<orderedlist>
	  <listitem>
	    <para>Az olyan kiadás elõtt álló
	      funkciók kipróbálásának
	      egyszerû módja, amelyekrõl hallottunk,
	      hogy milyen remek újdonságokat hoznak
	      és mi akarunk lenni az elsõk, akik ezt
	      használni is fogják.  Ne feledjük
	      azonban, hogy amikor mindenki elõtt kezdünk el
	      használni egy újítást, mi
	      leszünk egyben az elsõk is, akik
	      szembesülnek a benne rejlõ
	      hibákkal.</para>
	  </listitem>

	  <listitem>
	    <para>A gyors hibajavítások eszköze.  A
	      &os.current; szinte bármelyik változata
	      pontosan ugyanakkora
	      valószínûséggel hoz
	      magával új hibákat, mint ahogy
	      eltünteti a régieket.</para>
	  </listitem>

	  <listitem>
	    <para>Akármilyen értelemben is
	      <quote>hivatalosan támogatott</quote>.
	      Képességeinktõl függõen
	      õszintén igyekszünk a lehetõ
	      legtöbbet megtenni a 3
	      <quote>törvényes</quote> &os.current;
	      csoportba tartozó emberekért, azonban
	      egyszerûen <emphasis>nincs idõnk</emphasis>
	      komolyabb segítségnyújtást
	      adni.  Ez viszont nem azt jelenti, hogy komisz és
	      fukar emberek vagyunk, akik utálnak segíteni
	      a másiknak (de máskülönben nem
	      tudna fejlõdni a &os;).  Csupán a &os;
	      fejlesztése <emphasis>közben</emphasis>
	      fizikailag képtelenek vagyunk a naponta
	      érkezõ ezernyi üzenetet rendre
	      megválaszolni!  A &os;
	      elõremozdítása és a
	      kísérleti stádiumban
	      álló kóddal kapcsolatos
	      kérdések megválaszolása
	      közül a fejlesztõk általában
	      az elsõt részesítik
	      elõnyben.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>A &os.current; használata</title>

	<indexterm>
	  <primary>-CURRENT</primary>
	  <secondary>használata</secondary>
	</indexterm>

	<orderedlist>
	  <listitem>
	    <para>Iratkozzunk fel az &a.current.name; és
	      &a.svn-src-head.name; listákra.  Ez nem
	      egyszerûen hasznos, hanem
	      <emphasis>elengedhetetlen</emphasis>.  Ha nem vagyunk a
	      <emphasis>&a.current.name;</emphasis> listán, akkor
	      nem fogjuk látni a rendszer aktuális
	      állapotára vonatkozó
	      megjegyzéseket, és így esetleg
	      feleslegesen öljük az idõnket olyan
	      problémák megoldásába,
	      amelyeket mások már korábban
	      megoldottak.  Ami viszont ennél is fontosabb, hogy
	      így elszalasztjuk a rendszerünk folyamatos
	      életbentartására vonatkozó
	      létfontosságú
	      bejelentéseket.</para>

	    <para>Az &a.svn-src-head.name; listán
	      láthatjuk az a forráskód egyes
	      változtatásaihoz tartozó
	      naplóbejegyzéseket, a hozzájuk
	      tartozó esetleges mellékhatások
	      ismertetésével együtt.</para>

	    <para>A listákra vagy a &a.mailman.lists.link;
	      oldalon található többi lista
	      valamelyikére úgy tudunk feliratkozni, ha
	      rákattintunk a nevére.  A további
	      lépésekrõl ezt követõen itt
	      kapunk értesítést.  Amennyiben a
	      teljes forrásfa változásai
	      érdekelnek minket, javasoljuk az
	      &a.svn-src-all.name; lista olvasását.</para>
	  </listitem>

	  <listitem>
	    <para>A <link linkend="mirrors">tükrözések</link>
	      egyikérõl töltsük le a &os;
	      forrását.  Erre két mód is
	      kínálkozik:</para>

	    <orderedlist>
	      <listitem>
	      <indexterm><primary><command>cvsup</command></primary></indexterm>
	      <indexterm><primary><command>cron</command></primary></indexterm>
	      <indexterm>
		<primary>-CURRENT</primary>
		<secondary>frissítés
		  <application>CVSup</application>pal</secondary>
	      </indexterm>

		<para>Használjuk a <link linkend="cvsup">cvsup</link> programot a
		  <filename>/usr/share/examples/cvsup</filename>
		  könyvtárban található
		  <filename>standard-supfile</filename>
		  állománnyal.  Ez a leginkább
		  ajánlott módszer, hiszen így csak
		  egyszer kell letölteni az egész
		  gyûjteményt, majd ezután már
		  csak a változásokat.  Sokan a
		  <command>cvsup</command> parancsot a
		  <command>cron</command> parancson keresztül
		  adják ki, és ezzel mindig automatikusan
		  frissítik a forrásaikat.  A <link linkend="cvsup">cvsup</link>
		  mûködését a fentebb
		  említett minta <filename>supfile</filename>
		  állomány megfelelõ
		  módosításával tudjuk a
		  saját környezetünkhöz
		  igazítani.</para>

		<note>
		  <para>Az említett
		    <filename>standard-supfile</filename>
		    állomány eredetileg nem a
		    &os.current;, hanem inkább a &os;
		    biztonsági problémáit
		    érintõ javítások
		    követésére használatos.  A
		    &os.current; forrásainak
		    eléréséhez a
		    következõ sort kell
		    kicserélnünk ebben az
		    állományban:</para>

		  <programlisting>*default release=cvs tag=RELENG_<replaceable>X</replaceable>_<replaceable>Y</replaceable></programlisting>

		  <para>Erre:</para>

		  <programlisting>*default release=cvs tag=.</programlisting>

		  <para>A <literal>tag</literal>
		    paramétereként megadható
		    egyéb címkékrõl a
		    kézikönyv <link linkend="cvs-tags">CVS
		    címkék</link> szakaszában
		    olvashatunk.</para>
		</note>
	      </listitem>

	      <listitem>
		<indexterm>
		  <primary>-CURRENT</primary>
		  <secondary>frissítés CTM-mel</secondary>
		</indexterm>

		<para>Használjuk a <application>CTM</application>
		  alkalmazás nyújtotta
		  lehetõségeket.  Amennyiben nagyon rossz
		  netkapcsolattal rendelkezünk (drága vagy
		  csak levelezésre használható) a
		  <application>CTM</application> megoldást
		  jelenthet számunkra.  Legyünk azonban
		  tekintettel arra, hogy helyenként
		  zûrös lehet a használata és
		  néha hibás állományokat
		  gyárt.  Emiatt viszont csak ritkán
		  használják, így
		  elõfordulhat, hogy hosszabb ideig nem is
		  mûködik.  A 9600&nbsp;bps vagy annál
		  nagyobb sebességû kapcsolatok
		  esetén ezért inkább a
		  <application>CVSup</application>
		  használatát javasoljuk.</para>
	      </listitem>
	    </orderedlist>
	  </listitem>

	  <listitem>
	    <para>Ha nem csak böngészésre, hanem
	      fordításra is szedjük a
	      forrásokat, mindig töltsük le a
	      &os.current; <emphasis>egészét</emphasis>,
	      ne csak egyes részeit.  Ez azzal
	      magyarázandó, hogy a forráskód
	      bizonyos részei más helyeken
	      található részektõl is
	      függenek, és ezért az
	      önálló fordításuk szinte
	      garantáltan gondot fog okozni.</para>

	    <indexterm>
	      <primary>-CURRENT</primary>
	      <secondary>fordítása</secondary>
	    </indexterm>

	    <para>A &os.current; lefordítása elõtt
	      figyelmesen olvassuk át a
	      <filename>/usr/src</filename> könyvtárban
	      található <filename>Makefile</filename>
	      állományt.  A frissítési
	      folyamat részeként elõször
	      mindenképpen érdemes <link linkend="makeworld">telepíteni egy új
	      rendszermagot és újrafordítani az
	      alaprendszert</link>.  Olvassuk el a &a.current;
	      üzeneteit és a
	      <filename>/usr/src/UPDATING</filename>
	      állományt, ahol megtalálhatjuk az
	      ezzel kapcsolatos legújabb
	      információkat, melyek egy-egy újabb
	      kiadás közeledtével egyre
	      fontosabbá válnak.</para>
	  </listitem>

	  <listitem>
	    <para>Foglalkozzunk vele!  Ha már a &os.current;
	      változatát használjuk, ne
	      legyünk restek véleményt
	      formálni róla, különösen
	      abban az esetben, ha
	      továbbfejlesztésekrõl vagy
	      hibákra van szó.  Leginkább a
	      forráskóddal együtt érkezõ
	      javaslatoknak szoktak örülni a
	      fejlesztõk!</para>
	  </listitem>
	</orderedlist>

      </sect3>
    </sect2>

    <sect2 xml:id="stable">
      <title>A &os; stabil változatának
	használata</title>

      <sect3>
	<title>Mi a &os.stable;?</title>

	<indexterm><primary>-STABLE</primary></indexterm>

	<para>A &os.stable; az a fejlesztési ág, ahonnan
	  az egyes kiadások származnak.  Ebbe az
	  ágba már más ütemben kerülnek a
	  változások, mivel általánosan
	  elfogadott, hogy ide a korábban már
	  kipróbált módosítások
	  vándorolnak át a &os.current;
	  ágból.  Ez azonban <emphasis>még
	  mindig</emphasis> csak egy fejlesztési ág, ami
	  arra utal, hogy a &os.stable; által adott pillanatban
	  képviselt források nem feltétlenül
	  felelnek meg bizonyos célokra.  Ez csupán egy
	  újabb fejlesztési nyomvonal, nem pedig a
	  végfelhasználók kenyere.</para>

      </sect3>

      <sect3>
	<title>Kinek van szüksége a &os.stable;-re?</title>

	<para>Ha szeretnénk figyelemmel kísérni
	  vagy valamilyen módon kiegészíteni a &os;
	  fejlesztési folyamatát, különösen
	  a &os; következõ <quote>nagyobb</quote>
	  kiadását illetõen, akkor érdemes
	  követnünk a &os.stable; forrásait.</para>

	<para>Habár a &os.stable; ágba is bekerülnek
	  a biztonsági jellegû javítások,
	  ettõl még nem kell feltétlenül ezt
	  követnünk.  A &os;-hez kiadott biztonsági
	  figyelmeztetések mindig leírják, hogyan
	  kell javítani a hibát az érintett
	  kiadásokban
	  <footnote>
	    <para>Ez azért nem teljesen igaz.  A régebbi
	      &os; kiadásokat ugyan nem támogathatjuk a
	      végtelenségig, de általában
	      így is több évig foglalkozunk
	      velük.  A &os; régebbi kiadásaival
	      kapcsolatos jelenleg érvényes
	      biztonsági házirend részletes
	      bemutatása a <link xlink:href="&url.base;/security/">http://www.FreeBSD.org/security/</link>
	      oldalon olvasható (angolul).</para>
	  </footnote>
	  , azonban az egész fejlesztési ágat
	  felesleges csak biztonsági okból
	  kifolyólag követni, mivel így olyan
	  változások is kerülhetnek a rendszerbe,
	  amire nincs szükségünk.</para>

	<para>Habár igyekszünk gondoskodni a &os.stable;
	  ágban található források
	  lefordíthatóságáról
	  és
	  mûködõképességérõl,
	  nem minden esetben szavatolható.
	  Ráadásul mivel a &os.stable; ágba
	  kerülõ kódokat elõször a
	  &os.current; ágban fejlesztik ki, és mivel a
	  &os.stable; felhasználói többen vannak a
	  &os.current; változaténál, ezért
	  szinte elkerülhetetlen, hogy ilyenkor a &os.stable;
	  változatban bizonyos hibák és
	  szélsõséges esetek be ne
	  következzenek, amelyek a &os.current; használata
	  során még nem buktak ki.</para>

	<para>Ezért a &os.stable; ág vakon
	  követését senkinek <emphasis>sem</emphasis>
	  ajánljuk, és különösen fontos,
	  hogy éles szervereken elõzetes
	  kimerítõ tesztelések nélkül ne
	  futassunk &os.stable; rendszert.</para>

	<para>Ha ehhez nem rendelkezünk elegendõ
	  erõforrással, akkor egyszerûen
	  használjuk a &os; legfrissebb kiadását,
	  és az egyes kiadások között pedig
	  bináris frissítéssel
	  közlekedjünk.</para>

      </sect3>

      <sect3>
	<title>A &os.stable; használata</title>

	<indexterm>
	  <primary>-STABLE</primary>
	  <secondary>használata</secondary>
	</indexterm>

	<orderedlist>
	  <listitem>
	    <para>Iratkozzunk fel a &a.stable.name; listára.
	      Ezen keresztül értesülhetünk a
	      &os.stable; használata során
	      felmerülõ fordítási
	      függõségekrõl vagy más,
	      külön figyelmet igénylõ
	      problémákról.  Gyakran ezen a
	      levelezési listán elmélkednek a
	      fejlesztõk a vitatott
	      javításokról vagy
	      frissítésekrõl, amibe a
	      felhasználók is beleszólhatnak, ha a
	      szóbanforgó változtatással
	      kapcsolatban bármilyen problémájuk
	      vagy ötletünk van.</para>

	    <para>Iratkozzunk fel a követni kívánt
	      ághoz tartozó <application>SVN</application>
	      levelezési listára.  Például
	      ha a 7-STABLE ág változásait
	      követjük, akkor az &a.svn-src-stable-7.name;
	      listára érdemes feliratkoznunk.  Ennek
	      segítségével elolvashatjuk az egyes
	      változtatásokhoz tartozó
	      naplóbejegyzéseket, a rájuk
	      vonatkozó esetleges mellékhatások
	      ismertetésével együtt.</para>

	    <para>Ezekre, valamint a &a.mailman.lists.link; címen
	      elérhetõ listák valamelyikére
	      úgy tudunk feliratkozni, ha a nevükre
	      kattintunk.  A további teendõk ezután
	      itt jelennek meg.</para>
	  </listitem>

	  <listitem>
	    <para>Amennyiben egy új rendszert akarunk
	      telepíteni és a &os.stable; havonta
	      készült pillanatképeit akarjuk rajta
	      futtatni, akkor errõl bõvebb
	      felvilágosítást a <link xlink:href="&url.base;/snapshots/">Pillanatképek</link>
	      honlapján találhatunk (angolul).  Emellett a
	      legfrissebb &os.stable; kiadást
	      telepíthetjük a <link linkend="mirrors">tükrözések</link>
	      valamelyikérõl is, majd innen a lentebb
	      található utasítások szerint
	      tudunk hozzáférni a &os.stable;
	      forráskódjának legfrissebb
	      változatához.</para>

	    <para>Ha már fut a gépünkön a &os;
	      egy korábbi kiadása, és ezt akarjuk
	      forráson keresztül frissíteni, akkor
	      ezt a &os; <link linkend="mirrors">tükrözéseivel</link>
	      könnyedén megtehetjük.  Két
	      módon is:</para>

	    <orderedlist>
	      <listitem>
	      <indexterm><primary><command>cvsup</command></primary></indexterm>
	      <indexterm><primary><command>cron</command></primary></indexterm>
	      <indexterm>
		<primary>-STABLE</primary>
		<secondary>frissítés
		  <application>CVSup</application>pal</secondary>
	      </indexterm>

		<para>Használjuk a <link linkend="cvsup">cvsup</link> programot a
		  <filename>/usr/share/examples/cvsup</filename>
		  könyvtárból származó
		  <filename>stable-supfile</filename>
		  állománnyal.  Ez a leginkább
		  ajánlott módszer, mivel így csak
		  egyszer kell letölteni a teljes
		  gyûjteményt, utána már csak
		  a hozzá tartozó
		  változtatásokra van
		  szükségünk.  A
		  <command>cvsup</command> parancsot sokan a
		  <command>cron</command>
		  segítségével futtatják,
		  és ezzel automatikusan frissülnek a
		  forrásainak.  A <link linkend="cvsup">cvsup</link>
		  mûködését
		  környezetünkhöz az elõbb
		  említett minta <filename>supfile</filename>
		  megfelelõ
		  módosításával tudjuk
		  behangolni.</para>
	      </listitem>

	      <listitem>
		<indexterm>
		  <primary>-STABLE</primary>
		  <secondary>frissítés CTM-mel</secondary>
		</indexterm>

		<para>Használjuk a <application>CTM</application> programot.  Ha
		  nincs olcsó vagy gyors internetkapcsolatunk,
		  akkor érdemes ezt a módszert
		  választani.</para>
	      </listitem>
	   </orderedlist>
	 </listitem>

	  <listitem>
	    <para>Alapvetõen azonban ha gyorsan szeretnénk
	      hozzájutni a forrásokhoz és a
	      sávszélesség nem
	      meghatározó tényezõ, akkor
	      helyette válasszuk a <command>cvsup</command> vagy
	      az <command>ftp</command> használatát,
	      és csak minden más esetben
	      <application>CTM</application>-et.</para>
	  </listitem>

	  <listitem>
	    <indexterm>
	      <primary>-STABLE</primary>
	      <secondary>fordítása</secondary>
	    </indexterm>

	    <para>Mielõtt lefordítanánk a &os.stable;
	      változatát, figyelmesen olvassuk át a
	      <filename>/usr/src</filename> könyvtárban
	      levõ <filename>Makefile</filename>
	      állományt.  Az átállási
	      folyamat részeként elõször minden
	      bizonnyal <link linkend="makeworld">telepítenünk kell egy
	      új rendszermagot és újra kell
	      fordítanunk az alaprendszert</link>.  A &a.stable;
	      valamint a <filename>/usr/src/UPDATING</filename>
	      elolvasásából
	      értesülhetünk azokról az
	      egyéb, gyakran nagyon fontos
	      változásokról, melyek
	      elengedhetetlenek lesznek a következõ
	      kiadás használatához.</para>
	  </listitem>
	</orderedlist>

      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="synching">
    <title>A forrás szinkronizálása</title>

    <para>Az internet (vagy elektronikus levelek)
      használatán keresztül számos mód
      kínálkozik az &os; Projekthez tartozó
      források frissen tartásához egy adott, vagy
      éppen az összes területen attól
      függõen, hogy mik érdekelnek minket.  Ehhez
      elsõsorban az <link linkend="anoncvs">Anonim CVS</link>,
      <link linkend="cvsup">CVSup</link> és <link linkend="ctm">CTM</link> szolgáltatásokat
      ajánljuk fel.</para>

    <warning>
      <para>Habár lehetséges csupán a
	forrásfa egyes részeit letölteni, a
	támogatott frissítési eljárás
	során azonban szükségünk lesz az
	egész fa szinkronizálására és
	a rendszerhez tartozó felhasználói
	programok (vagyis minden olyan program, amely a
	felhasználói térben fut, ilyeneket
	találhatunk többek közt a
	<filename>/bin</filename> és <filename>/sbin</filename>
	könyvtárakban) valamint rendszermag
	újrafordítására is.  Ha csak a
	felhasználói programok forrásait, vagy csak
	a rendszermagot, esetleg csupán a forrásfa egyes
	részeit frissítjük, akkor az gondokat
	okozhat.  Az itt elõforduló problémák
	fordítási hibáktól kezdve
	rendszerösszeomlásokon keresztül akár
	adatvesztésbe is torkollhatnak.</para>
    </warning>

    <indexterm>
      <primary>CVS</primary>
      <secondary>anonim</secondary>
    </indexterm>

    <para>Az <application>Anonim CVS</application> és a
      <application>CVSup</application> alkalmazások ún.
      <emphasis>lehúzással</emphasis> frissítik a
      forrásokat.  A <application>CVSup</application>
      használatakor a felhasználó (vagy a
      <command>cron</command> szkript) meghívja a
      <command>cvsup</command> programot, amely az
      állományok aktualizálásához
      felveszi a kapcsolatot egy máshol
      megtalálható <command>cvsupd</command> szerverrel.
      Az így nyert frissítések az adott pillanatig
      visszemenõleg érkeznek meg, de csak akkor, ha
      igényeljük ezeket.  A frissítést
      könnyedén le tudjuk szabályozni a
      számunkra érdekes egyes állományokra
      és könyvtárakra.  A frissítéseket
      a szerver hozza létre menet közben annak
      megfelelõen, hogy milyen verziókkal rendelkezünk,
      és mihez akarunk szinkronizálni.  Az
      <application>Anonim CVS</application> a
      <application>CVSup</application>nál valamivel
      egyszerûbb abban a tekintetben, hogy ez a
      <application>CVS</application>-nek egy olyan kiterjesztése,
      amely lehetõvé teszi a változtatások
      közvetlen lehúzását egy távoli
      CVS tárházból.  Miközben a
      <application>CVSup</application> mindezt sokkal
      hatékonnyabb valósítja meg, addig az
      <application>Anonim CVS</application> jóval könnyebben
      használható.</para>

    <indexterm><primary><application>CTM</application></primary></indexterm>

    <para>Velük szemben a <application>CTM</application> nem
      hasonlítja össze interaktívan a saját
      és a központi szerveren tárolt
      forrásokat és nem is húzza át ezeket.
      Ehelyett egy olyan szkriptõl van szó, amely naponta
      többször megvizsgálja a központi CTM
      szerveren tárolt állományok a
      legutóbbi futtatás óta keletkezett
      változtatásait, majd az észlelt
      módosulásokat betömöríti,
      felcímkézi egy sorozatszámmal és
      (nyomtatható ASCII formátumban)
      elõkészíti ezeket az e-mailen keresztüli
      küldésre.  Az így létrehozott <quote>CTM
      delták</quote> megérkezésük után
      a &man.ctm.rmail.1; segédprogrammal kerülnek
      feldolgozásra, amely magától
      visszaalakítja, ellenõrzi és alkalmazza a
      változtatásokat a forrásfa
      felhasználó birtokában levõ
      másolatára.  Ez a megoldás hatékonyabb
      a <application>CVSup</application>
      használatánál, mert kisebb terhelést
      jelent a szerverek számára, hiszen a
      frissítéshez nem a
      <emphasis>lehúzást</emphasis>, hanem a
      <emphasis>küldést</emphasis>
      alkalmazzák.</para>

    <para>Természetesen minden említett
      eljárásnak megvannak a maga kompromisszumai.  Ha
      véletlenül kitöröljük a
      forrásfánk egyes részeit, a
      <application>CVSup</application> képes ezt
      észrevenni és helyreállítani a
      sérült részeket.  A
      <application>CTM</application> ezzel szemben ezt nem végzi
      el, szóval ha (biztonsági mentés
      nélkül) letöröljük a
      forrásainkat, akkor az egész
      szinkronizálást az elejérõl kell
      kezdenünk (pontosabban a legfrissebb CVS-es
      <quote>alapdeltától</quote>) és a
      <application>CTM</application>-mel
      újraépíteni az egészet, esetleg a
      <application>Anonim CVS</application>-sel letörölni a
      hibás adatokat és
      újraszinkronizálni.</para>

  </sect1>

  <sect1 xml:id="makeworld">
    <title>Az alaprendszer újrafordítása</title>

    <indexterm><primary>az alaprendszer
      újrafordítása</primary></indexterm>

    <para>Miután sikerült a helyi forrásfánkat
      a &os; egy nekünk szimpatikus (&os.stable;, &os.current;
      és így tovább) változatához
      igazítanunk, elérkezett az idõ, hogy a
      segítségével újrafordítsuk az
      egész rendszert.</para>

    <warning>
      <title>Készítsünk biztonsági
	mentést</title>

      <para>Nem tudjuk eléggé
	nyomatékosítani, hogy
	<emphasis>mielõtt</emphasis> nekikezdenénk,
	készítsünk egy biztonsági
	mentést a rendszerünkrõl.  Míg az
	alaprendszer újrafordítása nem
	túlságosan bonyolult feladat (egészen
	addig, amíg a megadott utasításokat
	követjük), saját magunk vagy mások
	hibájából fakadóan kialakulhatnak
	olyan helyzetek, amikor a rendszer nem lesz képes
	elindulni.</para>

      <para>Mindenképpen gyõzödjünk meg
	róla, hogy tisztességesen elvégeztük a
	mentést és akad a kezünk ügyében
	egy javításra felhasználható
	rendszerindító floppy vagy CD.
	Valószínûleg soha nem lesz ténylegesen
	szükségünk rájuk, azonban jobb
	félni, mint megijedni!</para>
    </warning>

    <warning>
      <title>Iratkozzunk fel a megfelelõ levelezési
	listákra</title>

      <indexterm><primary>levelezési lista</primary></indexterm>

      <para>A &os.stable; és &os.current; ágak
	természetüknél fogva
	<emphasis>fejlesztés alatt állnak</emphasis>.  A
	&os; fejlesztését is emberek végzik,
	ezért elõfordulhatnak benne
	tévedések.</para>

      <para>Ezek a tévedések gyakran csak
	ártalmatlan apróságok, amelyek
	hatására kapunk például egy
	ismeretlen diagnosztikai hibát.  De ezzel szemben
	létrejöhetnek pusztító erejû
	hibák is, amelyek hatására a
	rendszerünk nem lesz képes elindulni,
	károsodnak az állományrendszerek (vagy
	még rosszabb).</para>

      <para>Ha ilyen történik, akkor egy
	<quote>felszólítást</quote> (egy
	<quote>heads up</quote> témájú
	üzenetet) küldenek az érintett
	változatokhoz tartozó listákra, amelyben
	igyekeznek kifejteni a probléma természetét
	és a rendszerre mért hatását.
	Miután <quote>minden rendbejött</quote>, a
	probléma megoldásáról is
	küldenek egy értesítést.</para>

      <para>Ha a &a.stable; vagy a &a.current; olvasása
	nélkül próbáljuk meg használni
	a &os.stable; és &os.current; verziókat, akkor
	csak magunknak keressük a bajt.</para>
    </warning>

    <warning>
      <title>Ne használjuk a <command>make world</command>
	parancsot</title>

      <para>Rengeteg régebben készült
	dokumentáció erre a feladatra a <command>make
	world</command> parancs kiadását javasolja.  Ennek
	használatával azonban átlépünk
	olyan fontos lépéseket, amelyek
	valójában csak akkor lennének
	kihagyhatóak, ha pontosan tudjuk mit csinálunk.
	Ezért az esetek döntõ
	többségében nem a <command>make
	world</command> használatára van
	szükségünk, hanem a most bemutatandó
	eljárásra.</para>
    </warning>

    <sect2 xml:id="canonical-build">
      <title>A rendszer frissítése
	dióhéjban</title>

      <para>A frissítés megkezdése elõtt
	érdemes elolvasnunk a
	<filename>/usr/src/UPDATING</filename> állományt,
	ahol a letöltött források
	használatához elvégzendõ elõzetes
	intézkedésekrõl kaphatunk hírt.
	Ezután kövessük az alábbiakban
	körvonalazott módszer egyes
	lépéseit.</para>

      <para>Ezek a lépések feltételezik, hogy egy
	korábbi &os; verziót használunk, tehát
	a fordító, a rendszermag, az alaprendszer
	és a konfigurációs állományok
	valamelyik régebbi változatát.
	Alaprendszer alatt, amelyet sokszor csak a <quote>world</quote>
	néven hivatkozunk, a rendszer számára
	alapvetõ fontosságú binárisokat,
	programkönyvtárakat és
	programfejlesztéshez szükséges egyéb
	állományokat értjük.  Maga a
	fordítóprogram is része ennek, azonban
	tartalmaz néhány speciális
	megszorítást.</para>

      <para>Mindezek mellett továbbá
	feltételezzük, hogy elõzetesen már
	valamilyen módon letöltöttük a friss
	forrásokat.  Ha rendszerünkön ezt még
	nem tettük volna meg, akkor a <xref linkend="synching"/>
	segítségével
	tájékozódhatunk részletesen
	arról, hogyan tölthetjük le a legfrissebb
	verziót.</para>

      <para>A rendszer forráskódon keresztüli
	frissítése egy kicsivel
	körülményesebb, mint amennyire elsõre
	látszik.  A &os; fejlesztõk az évek
	során fontosnak találták, hogy a
	folyamatosan felszínre bukkanó,
	elkerülhetetlen függõségek
	tükrében meglehetõsen drámai
	módon megváltoztassák az erre javasolt
	módszert.  Ezért a szakasz további
	részében a pillanatnyilag javasolt
	frissítési megoldás nyomán fogunk
	haladni.</para>

      <para>A sikeres frissítések során az
	alábbi akadályokkal kell mindenképpen
	szembenéznünk:</para>

      <itemizedlist>
	<listitem>
	  <para>A fordító régebbi változata
	    nem feltétlenül lesz képes
	    lefordítani az új rendszermagot.  (Illetve a
	    régebbi fordítóprogramok
	    tartalmazhatnak hibákat.) Ezért az új
	    rendszermagot már a fordító új
	    változatával kell
	    elõállítanunk.  Ebbõl
	    következik, hogy az új rendszermag
	    elkészítéséhez elõször
	    a fordítóprogram újabb
	    változatát kell lefordítanunk.  Ez
	    viszont nem feltétlenül jelenti azt, hogy az
	    új rendszermag fordítása elõtt az
	    új fordítóprogramot
	    <emphasis>telepítenünk</emphasis> is
	    kellene.</para>
	</listitem>

	<listitem>
	  <para>Az új alaprendszer esetenként bizonyos
	    új funkciókat igényelhet a
	    rendszermagtól.  Ezért a frissebb alaprendszer
	    telepítése elõtt telepítenünk
	    kell a frissebb rendszermagot.</para>
	</listitem>

	<listitem>
	  <para>Ez az elõbb említett két
	    akadály képzi az okát a
	    következõ bekezdésekben bemutatott
	    <buildtarget>buildworld</buildtarget>,
	    <buildtarget>buildkernel</buildtarget>,
	    <buildtarget>installkernel</buildtarget>,
	    <buildtarget>installworld</buildtarget> sorozatnak.
	    Természetesen léteznek további
	    egyéb indokok is, amiért még
	    érdemes az itt leírtak szerint
	    frissíteni a rendszerünket.  Ezek
	    közül most vegyünk néhány
	    kevésbé nyilvánvalóbbat:</para>

	  <itemizedlist>
	    <listitem>
	      <para>A régebbi alaprendszer nem minden esetben fog
		problémamentesen együttmûködni az
		új rendszermaggal, ezért az alaprendszer
		újabb változatát szinte azonnal az
		új rendszermagot követõen kell
		telepítenünk.</para>
	    </listitem>

	    <listitem>
	      <para>Vannak olyan konfigurációs
		változtatások, amelyeket még az
		új alaprendszer telepítése
		elõtt el kell végeznünk, a többi
		viszont veszélyes lehet a korábbi
		alaprendszerre.  Ezért a
		konfigurációs állományokat
		általában két külön
		lépésben kell frissíteni.</para>
	    </listitem>

	    <listitem>
	      <para>A frissítés során
		nagyrészt csak állományok
		cserélõdnek el és újabbak
		érkeznek, a korábbiak nem
		törlõdnek.  Ez bizonyos esetekben azonban
		gondokat okozhat.  Ennek eredményeképpen a
		frissítés során
		idõnként elõfordulhat, hogy magunknak
		kell manuálisan némely megadott
		állományokat törölnünk.
		Elképzelhetõ, hogy ezt a jövõben
		még majd automatizálni
		fogják.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Ezek a megfontolások vezettek tehát az
	    ismertetendõ eljárás
	    kialakításához.  Ettõl
	    függetlenül adódhatnak olyan helyzetek,
	    amikor további lépéseket is be kell
	    iktatnunk, viszont az itt bemutatott folyamat egy ideje
	    már viszonylag elfogadottnak tekinthetõ:</para>

	  <orderedlist>
	    <listitem>
	      <para><command>make buildworld</command></para>

	      <para>Elõször lefordítja az új
	      fordítóprogramot és
		néhány hozzá tartozó
		eszközt, majd ennek
		felhasználásával
		elkészíti az alaprendszer többi
		részét.  Az eredmény a <filename>/usr/obj</filename>
		könyvtárban keletkezik.</para>
	    </listitem>

	    <listitem>
	      <para><command>make buildkernel</command></para>

	      <para>Eltérõen a &man.config.8; és
		&man.make.1; programok korábban javasolt
		alkalmazásától, ezzel a paranccsal
		már a <filename>/usr/obj</filename>
		könyvtárban létrehozott
		<emphasis>új</emphasis> fordítót
		használjuk.  Ez védelmet nyújt a
		fordító és rendszermag
		változatai közti
		eltérésekbõl fakadó
		problémák ellen.</para>
	    </listitem>

	    <listitem>
	      <para><command>make installkernel</command></para>

	      <para>Telepíti a lemezre az új rendszermagot
		és a hozzá tartozó modulokat,
		ezáltal lehetõvé válik a
		frissített rendszermag
		betöltése.</para>
	    </listitem>

	    <listitem>
	      <para>Átváltás
		egyfelhasználós módba.</para>

	      <para>Egyfelhasználós módban a
		minimálisra csökkenthetjük a futó
		szoftverek frissítésébõl
		adódó bonyodalmakat.  Ezzel együtt
		minimálissá válik a régi
		alaprendszer és az új rendszermag
		eltéréseibõl eredõ
		problémák elõfordulása
		is.</para>
	    </listitem>

	    <listitem>
	      <para><command>mergemaster -p</command></para>

	      <para>Az új alaprendszer
		telepítéséhez elvégzi a
		konfigurációs állományok
		részérõl szükséges
		frissítéseket.  Például
		felvesz még nem létezõ csoportokat
		vagy felhasználókat.  Ez gyakran
		elengedhetetlennek bizonyulhat, mivel ha a rendszer
		legutóbbi frissítése óta
		újabb csoportok vagy felhasználók
		kerültek be az alaprendszerbe, a
		<buildtarget>installworld</buildtarget> csak akkor tud
		hibamentesen lefutni, ha ezek már a
		futásakor is elérhetõek.</para>
	    </listitem>

	    <listitem>
	      <para><command>make installworld</command></para>

	      <para>Átmásolja a <filename>/usr/obj</filename>
		könyvtárból a korábban
		elkészített új alaprendszert.
		Lefutása után már mind az új
		rendszermag és az új alaprendszer a
		megfelelõ helyén
		található.</para>
	    </listitem>

	    <listitem>
	      <para><command>mergemaster</command></para>

	      <para>Feldolgozzuk a korábbi fázisból
		fennmaradó konfigurációs
		állományok
		frissítését, mivel most már
		elérhetõ az új alaprendszer.</para>
	    </listitem>

	    <listitem>
	      <para>A rendszer újraindítása.</para>

	      <para>Az új rendszermag és az új
		konfigurációs állományokkal
		futó alaprendszer használatához
		teljesen újra kell indítanunk a
		számítógépünket.</para>
	    </listitem>
	  </orderedlist>

	  <para>Ha a &os; ugyanazon fejlesztési
	    ágán belül frissítjük a
	    rendszerünket, például a 7.0
	    kiadásról a 7.1 kiadásra, akkor
	    értelemszerûen nem kell az iménti
	    eljárás minden lépését
	    szorosan követni, hiszen nagyon
	    valószínûtlen, hogy komoly
	    eltérések lennének a
	    fordítóprogram, a rendszermag, az alaprendszer
	    és a konfigurációs
	    állományok között.  Ilyenkor
	    akár nyugodtan kiadhatjuk a <command>make
	    world</command> parancsot, majd kérhetjük a
	    rendszermag fordítását és
	    telepítését.</para>

	  <para>A fejlesztési ágak közti
	    váltás során azonban könnyen
	    érhetnek minket meglepetések, ha nem a
	    megadottak szerint járunk el.</para>

	  <para>Egyes váltásokhoz (például
	    4.<replaceable>X</replaceable> és 5.0
	    között) további lépések
	    megtétele is szükséges lehet
	    (például adott állományok
	    törlése vagy átnevezése még
	    az <buildtarget>installworld</buildtarget> elõtt).
	    Ilyenkor mindig figyelmesen olvassuk át a
	    <filename>/usr/src/UPDATING</filename>
	    állományt, különös tekintettel
	    a végére, mivel gyakran ott adják meg a
	    konkrét verzióváltáshoz
	    szükséges teendõket.</para>

	  <para>A szakaszban összefoglalt lépések
	    egyfajta evolúciós folyamat eredményei,
	    melynek során a fejlesztõk felismerték,
	    hogy nem tökéletesen kivédeni az
	    összes frissítéssel járó
	    problémát.  A javasolt eljárás
	    remélhetõleg viszont még sokáig
	    érvényes marad.</para>

	  <note>
	    <para>A &os; 3.<replaceable>X</replaceable> vagy
	      annál is korábbi változatok
	      frissítése még ennél is
	      több ügyességet kíván.  Ha
	      ilyen verziót akarunk frissíteni, akkor
	      feltétlenül olvassuk el az
	      <filename>UPDATING</filename>
	      állományt!</para>
	  </note>

	  <para>Röviden tehát a &os;
	    forráskódon keresztüli
	    frissítését így foglalhatjuk
	    össze:</para>
	</listitem>
      </itemizedlist>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput>
&prompt.root; <userinput>make installkernel</userinput>
&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <note>
	<para>Néhány ritka esetben a
	  <buildtarget>buildworld</buildtarget> lépés
	  elõtt szükségünk lehet a
	  <command>mergemaster -p</command> parancs
	  lefuttatására is.  Errõl az
	  <filename>UPDATING</filename> állományból
	  tudakozódhatunk.  Általában azonban
	  nyugodt szívvel kihagyhatjuk ezt a
	  lépést, kivéve, ha nem egy vagy több
	  fõbb &os; változatot átívelõ
	  frissítést végzünk.</para>
      </note>

      <para>Miután az <buildtarget>installkernel</buildtarget>
	sikeresen befejezte a munkáját, indítsuk
	újra a számítógépet
	egyfelhasználós módban (a betöltõ
	parancssorában adjuk ki <command>boot -s</command>
	parancsot).  Itt futtassuk a következõket:</para>

      <screen>&prompt.root; <userinput>adjkerntz -i</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>mergemaster -p</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput>
&prompt.root; <userinput>mergemaster</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <warning>
	<title>Olvassuk el a magyarázatokat</title>

	<para>Az iménti leírt folyamat csupán
	  rövid összefoglalás, amivel némi
	  gyorstalpalást igyekeztünk adni.  Az egyes
	  lépések megértéséhez
	  azonban javasolt átolvasni a most következõ
	  szakaszokat is, különösen abban az esetben, ha
	  saját rendszermagot akarunk használni.</para>
      </warning>
    </sect2>

    <sect2 xml:id="src-updating">
      <title>Nézzük meg a
	<filename>/usr/src/UPDATING</filename>
	állományt</title>

      <para>Mielõtt bármihez is nekifognánk,
	keressük meg a <filename>/usr/src/UPDATING</filename> (vagy
	hasonló, a forráskód másolatunk
	tényleges helyétõl függõ)
	állományt.  Ebben adják hírül
	az esetlegesen felmerülõ problémákra
	vonatkozó fontosabb információkat, vagy
	határozzák meg az egyes lefuttatandó
	parancsok pontos sorrendjét.  Amennyiben az
	<filename>UPDATING</filename> ellentmondana az itt
	olvasottaknak, az <filename>UPDATING</filename> tartalma a
	mérvadó.</para>

      <important>
	<para>A korábban tárgyaltak szerint az
	  <filename>UPDATING</filename> elolvasása nem
	  helyettesíti a megfelelõ levelezési
	  listák figyelemmel
	  kísérését.  Ez a két
	  elvárás nem kizárja, hanem
	  kiegészíti egymást.</para>
      </important>
    </sect2>

    <sect2 xml:id="make-conf">
      <title>Ellenõrizzük az
	<filename>/etc/make.conf</filename>
	állományt</title>

      <indexterm><primary><filename>make.conf</filename></primary></indexterm>

      <para>Vizsgáljuk át a
	<filename>/usr/share/examples/etc/make.conf</filename> és
	az <filename>/etc/make.conf</filename>
	állományokat.  Az elõbbi tartalmaz
	néhány alapértelmezett
	beállítást &ndash; ezek
	javarészét megjegyzésbe rakták.  Ha
	használni akarjuk a rendszer lefordítása
	során, tegyük bele ezeket az
	<filename>/etc/make.conf</filename> állományba.
	Ne felejtsük el azonban, hogy minden, amit megadunk az
	<filename>/etc/make.conf</filename> állományba, a
	<command>make</command> minden egyes elindításakor
	felhasználásra kerül.  Éppen
	ezért olyanokat érdemes itt
	beállítani, amik az egész
	rendszerünket érintik.</para>

      <para>A legtöbb felhasználó
	számára az <filename>/etc/make.conf</filename>
	állományhoz a
	<filename>/usr/share/examples/etc/make.conf</filename>
	állományban található
	<varname>CFLAGS</varname> és
	<varname>NO_PROFILE</varname> sorokra lesz szüksége,
	melyeket kivehetünk a megjegyzésbõl.</para>

      <para>A többi definíció
	(<varname>COPTFLAGS</varname>, <varname>NOPORTDOCS</varname>
	és így tovább)
	használatáról már mindenki maga
	dönt.</para>
    </sect2>

    <sect2 xml:id="updating-etc">
      <title>Frissítsük az <filename>/etc</filename>
	tartalmát</title>

      <para>Az <filename>/etc</filename> könyvtár
	tartalmazza a rendszer beállításaival
	kapcsolatos információk jelentõs
	részét, valamint a rendszer indítása
	során lefutó szkripteket.  Egyes szkriptek a &os;
	verzióiról verzióira
	változnak.</para>

      <para>Némely konfigurációs
	állományok a rendszer hétköznapi
	mûködésében is szerepet
	játszanak.  Ilyen például az
	<filename>/etc/group</filename>.</para>

      <para>Alkalmanként a <command>make installworld</command>
	parancs futása során igényt tart adott
	nevû felhasználókra és csoportokra.  A
	frissítéskor azonban ezek a
	felhasználók vagy csoportok nem
	feltétlenül állnak rendelkezésre, ami
	gondokat okozhat.  Ezért bizonyos esetekben a
	<command>make buildworld</command> elõzetesen
	ellenõrzi az igényelt felhasználók
	és csoportok meglétét.</para>

      <para>Erre például szolgálhat a
	<systemitem class="username">smmsp</systemitem> felhasználó esete.
	Nélküle a felhasználók nem
	tudták telepíteni az új rendszert, mert
	hiányában az &man.mtree.8; nem volt képes
	létrehozni a <filename>/var/spool/clientmqueue</filename>
	könyvtárat.</para>

      <para>Ezt úgy lehetett megoldani, hogy még az
	alaprendszer lefordítása (a
	<buildtarget>buildworld</buildtarget>) elõtt meg kellett
	hívni a &man.mergemaster.8; parancsot a
	<option>-p</option> paraméterrel.  Így csak azokat
	az állományokat fogja
	összehasonlítani, amelyek feltétlenül
	szükségesek a <buildtarget>buildworld</buildtarget>
	vagy az <buildtarget>installworld</buildtarget> sikeres
	mûködéséhez.  Amennyiben a
	<command>mergemaster</command> egy olyan
	verziójával rendelkezünk, amely nem ismeri a
	<option>-p</option> paramétert, akkor az elsõ
	indításakor használjuk a
	forrásfában található újabb
	verzióját:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/usr.sbin/mergemaster</userinput>
&prompt.root; <userinput>./mergemaster.sh -p</userinput></screen>

      <tip>
	<para>Ha különösen paranoiásak vagyunk,
	  akkor a csoport törlése vagy
	  átnevezése elõtt az alábbi
	  paranccsal ellenõrizni tudjuk az általa birtokolt
	  állományokat:</para>

	<screen>&prompt.root; <userinput>find / -group GID -print</userinput></screen>

	<para>Ez megmutatja <replaceable>GID</replaceable> (mely
	  megadható numerikus vagy név
	  formájában is) jelzésû csoporthoz
	  tartozó összes állományt a
	  rendszerünkben.</para>
      </tip>
    </sect2>

    <sect2 xml:id="makeworld-singleuser">
      <title>Váltsunk egyfelhasználós
	módba</title>

      <indexterm><primary>egyfelhasználós
	mód</primary></indexterm>

      <para>A rendszert egyfelhasználós módban
	érdemes lefordítani.  A
	nyilvánvalóan érezhetõ
	gyorsaság elõnyei mellett azért is jobban
	járunk, mert az új rendszer
	telepítése során számos
	rendszerszintû állomány is
	módosításra kerül, beleértve a
	szabványos rendszerszintû binárisokat,
	függvénykönyvtárakat, include
	állományokat és így tovább.
	Ha üzemelõ rendszeren végezzük el mindezen
	változtatásokat (különösen amikor
	rajtunk kívül még további
	felhasználók is tartózkodnak a
	rendszerben), az csak a bajt hozza ránk.</para>

      <indexterm><primary>többfelhasználós
	mód</primary></indexterm>

      <para>Másik lehetõség gyanánt a
	rendszert magát lefordíthatjuk
	többfelhasználós módban is, majd
	ezután csak a telepítést hajtjuk
	végre egyfelhasználós
	üzemmódban.  Ha eszerint cselekszünk,
	egyszerûen várjunk addig, amíg az összes
	fordítás be nem fejezõdik, és az
	egyfelhasználósra váltást halasszuk
	a <buildtarget>installkernel</buildtarget> vagy
	<buildtarget>installworld</buildtarget> idejére.</para>

      <para>Egy mûködõ rendszerben
	rendszeradminisztrátorként az alábbi parancs
	kiadásával válthatunk át
	egyfelhasználós módba:</para>

      <screen>&prompt.root; <userinput>shutdown now</userinput></screen>

      <para>Ezt elérhetjük úgy is, ha
	újraindítjuk a rendszert és a rendszer
	indításakor a <quote>single user</quote> pontot
	választjuk a menübõl.  Ekkor a rendszer
	egyfelhasználós módban indul el.
	Miután ez megtörtént, adjuk ki a
	következõ parancsokat:</para>

      <screen>&prompt.root; <userinput>fsck -p</userinput>
&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

      <para>Ezekkel a parancsokkal elõször
	ellenõrizzük az állományrendszereket,
	ezután újracsatlakoztatjuk a
	<filename>/</filename> állományrendszert
	írható módban, csatlakoztatjuk az
	<filename>/etc/fstab</filename> állományban
	megadott összes többi UFS típusú
	állományrendszert, majd bekapcsoljuk a
	lapozóállomány
	használatát.</para>

      <note>
	<para>Ha a gépünk óráját nem a
	  greenwich-i, hanem a helyi idõ szerint
	  állítottuk be (ez akkor áll fenn, ha a
	  &man.date.1; parancs nem a helyes idõt és
	  idõzónát jelzi ki), akkor még erre
	  is szükségünk lehet:</para>

	<screen>&prompt.root; <userinput>adjkerntz -i</userinput></screen>

	<para>Ezzel a helyi idõzóna
	  beállításait tudjuk jól
	  beállítani &mdash; nélküle
	  késõbb még gondjaink akadhatnak.</para>
      </note>
    </sect2>

    <sect2 xml:id="cleaning-usr-obj">
      <title>Töröljük a <filename>/usr/obj</filename>
	könyvtárat</title>

      <para>A rendszer egyes részei fordításuk
	során a <filename>/usr/obj</filename>
	könyvtáron belülre kerülnek
	(alapértelmezés szerint).  Az itt
	található könyvtárak a
	<filename>/usr/src</filename>
	könyvtárszerkezetét követik.</para>

      <para>Ha mindenestõl töröljük ezt a
	könyvtárat, akkor növeli tudjuk a <command>make
	buildworld</command> folyamat sebességét és
	megmenekülünk néhány
	függõségekkel kapcsolatos
	fejfájástól is.</para>

      <para>Egyes <filename>/usr/obj</filename> könyvtáron
	belüli állományoknál szerepelhet a
	<quote>megváltoztathatatlan</quote> (immutable)
	állományjelzõ (lásd &man.chflags.1;),
	amelyet a mûvelet elvégzéséhez
	elõször el kell távolítanunk.</para>

      <screen>&prompt.root; <userinput>cd /usr/obj</userinput>
&prompt.root; <userinput>chflags -R noschg *</userinput>
&prompt.root; <userinput>rm -rf *</userinput></screen>
    </sect2>

    <sect2 xml:id="updating-upgrading-compilebase">
      <title>Fordítsuk újra az alaprendszert</title>

      <sect3>
	<title>A kimenet elmentése</title>

	<para>Jól járunk azzal, ha a &man.make.1;
	  futásának kimenetét elmentjük egy
	  állományba, mivel így a hibák
	  esetén lesz egy másolatunk a
	  hibaüzenetrõl.  Ha konkrétan nekünk nem
	  is feltétlenül segít megtalálni a
	  hiba tényleges okát, mások viszont
	  többet tudnak róla mondani, ha beküldjük
	  ezt a &os; egyik levelezési
	  listájára.</para>

	<para>Ezt egyébként a legegyszerûbben a
	  &man.script.1; parancs segítségével
	  oldhatjuk meg, amelynek paraméteréül azt az
	  állományt kell megadni, ahova menteni akarjuk a
	  kimenetet.  Ezt közvetlenül a rendszer
	  újrafordítása elõtt kell kiadnunk,
	  majd miután megállt, a
	  <userinput>exit</userinput> paranccsal kiléphetünk
	  belõle.</para>

	<screen>&prompt.root; <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out
&prompt.root; <userinput>make TARGET</userinput>
<emphasis>&hellip; fordít, fordít, fordít &hellip;</emphasis>
&prompt.root; <userinput>exit</userinput>
Script done, &hellip;</screen>

	<para>Ilyenkor <emphasis>soha ne</emphasis> a
	  <filename>/tmp</filename> könyvtárba mentsük
	  a kimenetet, mert ennek a tartalma a következõ
	  indítás során magától
	  törlõdik.  Sokkal jobban tesszük, ha a
	  <filename>/var/tmp</filename> könyvtárba (ahogy
	  tettük azt az elõbbi példában is) vagy
	  a <systemitem class="username">root</systemitem> felhasználó
	  könyvtárába mentünk.</para>
      </sect3>

      <sect3 xml:id="make-buildworld">
	<title>Az alaprendszer fordítása</title>

	<para>A <filename>/usr/src</filename> könyvtárban
	  kell állnunk:</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>

	<para>(kivéve természetesen, ha máshol van
	  a forráskód, akkor abba a könyvtárba
	  menjünk).</para>

	<indexterm><primary><command>make</command></primary></indexterm>

	<para>Az alaprendszert a &man.make.1; paranccsal
	  fordíthatjuk újra.  Ez a
	  <filename>Makefile</filename> nevû
	  állományból olvassa be a &os;
	  programjainak újrafordítását
	  leíró utasításokat, a
	  fordításuk sorrendjét és
	  így tovább.</para>

	<para>A begépelendõ paranccsor
	  általános alakja tehát a
	  következõképpen néz ki:</para>

	<screen>&prompt.root; <userinput>make -x -DVÁLTOZÓ target</userinput></screen>

	<para>A fenti példában a
	  <option>-<replaceable>x</replaceable></option> egy olyan a
	  paraméter, amelyet a &man.make.1; programnak adunk
	  át.  A &man.make.1; man oldalán
	  megtalálhatjuk az összes neki
	  átadható ilyen
	  beállítást.</para>

	<para>A
	<option>-D<replaceable>VÁLTOZÓ</replaceable></option>
	  alakú paraméterek közvetlenül a
	  <filename>Makefile</filename> állománynak adnak
	  át olyan változókat, amelyek
	  segítségével vezérelhetõ a
	  viselkedése.  Ezek ugyanazok a változók,
	  mint amelyek az <filename>/etc/make.conf</filename>
	  állományban is szerepelnek, és itt a
	  beállításuk egy másik
	  módját kapjuk.  Így a</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE target</userinput></screen>

	<para>paranccsal is megadhatjuk, hogy ne profilozott
	  függkönyvtárak jöjjenek létre,
	  ami pontosan megfelel a</para>

	<programlisting>NO_PROFILE=    true 	#    Avoid compiling profiled libraries</programlisting>

	<para>sornak az <filename>/etc/make.conf</filename>
	  állományban.</para>

	<para>A <replaceable>target</replaceable> árulja el a
	  &man.make.1; programnak, hogy mi a teendõje.  Minden
	  egyes <filename>Makefile</filename>
	  különbözõ <quote>targeteket</quote>
	  definiál, és a kiválasztott target mondja
	  meg, pontosan mi is fog történni.</para>

	<para>Egyes targetek ugyan megjelennek a
	  <filename>Makefile</filename> állományban,
	  azonban nem feltétlenül hivatkozhatunk
	  rájuk közvetlenül.  Ehelyett csupán
	  arra valók, hogy a fordítás
	  folyamatának lépéseit felbontsák
	  még kisebb allépésekre.</para>

	<para>A legtöbb esetben azonban semmilyen paramétert
	  nem kell átadnunk a &man.make.1; parancsnak,
	  ezért a teljes formája így fog
	  kinézni:</para>

	<screen>&prompt.root; <userinput>make target</userinput></screen>

	<para>ahol a <replaceable>target</replaceable> az egyik
	  fordítási lehetõséget
	  képviseli.  Az elsõ ilyen targetnek mindig a
	  <buildtarget>buildworld</buildtarget>-nek kell lennie.</para>

	<para>Ahogy a neve is mutatja, a
	  <buildtarget>buildworld</buildtarget> lefordítja az
	  összes forrást a <filename>/usr/obj</filename>
	  könyvtárba, majd a
	  <buildtarget>installworld</buildtarget> mint másik
	  target, telepíti az így létrehozott
	  elemeket a számítógépre.</para>

	<para>A targetek szétválasztása két
	  okból is elõnyös.  Elõször is
	  lehetõvé teszi, hogy az új rendszert
	  biztonságban lefordíthassuk, miközben az a
	  jelenleg futó rendszert nem zavarja.  A rendszer
	  tehát képes <quote>saját magát
	  újrafordítani</quote>.  Emiatt a
	  <buildtarget>buildworld</buildtarget> target akár
	  többfelhasználós módban is
	  mindenféle nem kívánatos hatás
	  nélkül használható.  Ennek
	  ellenére azonban továbbra is azt javasoljuk,
	  hogy a <buildtarget>installworld</buildtarget> részt
	  egyfelhasználós módban futtassuk
	  le.</para>

	<para>Másodrészt ezzel
	  lehetõségünk nyílik NFS
	  állományrendszer alkalmazásával
	  több számítógépre is
	  telepíteni hálózaton keresztül.  Ha
	  például három frissítendõ
	  számítógépünk van, az
	  <systemitem>A</systemitem>, <systemitem>B</systemitem> és
	  <systemitem>C</systemitem>, akkor az <systemitem>A</systemitem> gépen
	  elõször adjuk ki a <command>make
	  buildworld</command>, majd a <command>make
	  installworld</command> parancsot.  A <systemitem>B</systemitem>
	  és <systemitem>C</systemitem> gépek ezután NFS
	  segítségével csatlakoztatják az
	  <systemitem>A</systemitem> <filename>/usr/src</filename> és
	  <filename>/usr/obj</filename> könyvtárait, amelyet
	  követõen a <command>make installworld</command>
	  paranccsal telepíteni tudjuk a fordítás
	  eredményét a <systemitem>B</systemitem> és
	  <systemitem>C</systemitem> gépekre.</para>

	<para>Noha a <buildtarget>world</buildtarget> mint target
	  még mindig létezik, használata
	  határozottan ellenjavalt.</para>

	<para>A</para>

	<screen>&prompt.root; <userinput>make buildworld</userinput></screen>

	<para>parancs kiadásakor a <command>make</command>
	  parancsnak megadható egy <option>-j</option>
	  paraméter is, amellyel párhuzamosíthatjuk
	  a folyamat egyes részeit.  Ez általában
	  többprocesszoros
	  számítógépeken nyer
	  értelmet, azonban mivel a fordítás
	  folyamatának haladását inkább az
	  állománymûveletek mintsem a processzor
	  sebessége korlátozza, ezért
	  alkalmazható akár egyprocesszoros gépeken
	  is.</para>

	<para>Tehát egy átlagos egyprocesszoros
	  gépen így adható ki a parancs:</para>

	<screen>&prompt.root; <userinput>make -j4 buildworld</userinput></screen>

	<para>Ennek hatására &man.make.1; egyszerre 4
	  szálon igyekszik mûködni.  A
	  levelezési listákra beküldött
	  tapasztalati jellegû bizonyítékok azt
	  igazolják, hogy általában ez a
	  beállítás adja a legjobb
	  teljesítményt.</para>

	<para>Ha többprocesszoros géppel rendelkezünk
	  és rajta SMP támogatású
	  rendszermagot indítottunk el, akkor érdemes 6
	  és 10 közötti értékekkel
	  kísérleteznünk.</para>
      </sect3>

      <sect3>
	<title>Idõigény</title>

	<indexterm>
	  <primary>az alaprendszer
	    újrafordítása</primary>
	  <secondary>idõigény</secondary>
	</indexterm>

	<para>Számos tényezõ befolyásolja a
	  fordítás tényleges idõbeli
	  hosszát, de a &os.stable; fa lefordítása
	  mindenféle trükkök és
	  rövidítések nélkül a
	  legtöbb számítógépen olyan
	  egy vagy két órára
	  taksálható.  A &os.current; fához
	  ennél valamivel több idõre lesz
	  szükségünk.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="new-kernel">
      <title>Fordítsunk és telepítsünk egy
	új rendszermagot</title>

      <indexterm>
	<primary>rendszermagot</primary>
	<secondary>fordítása</secondary>
      </indexterm>

      <para>Az újdonsült rendszerünket csak akkor
	tudjuk igazán kihasználni, ha egy új
	rendszermagot is készítünk hozzá.  Ez
	gyakorlati szinten tulajdonképpen elvárás,
	mivel könnyen elõfordulhat, hogy bizonyos
	memóriabeli adatszerkezetek
	felépítése megváltozott,
	ezért némely programok, mint például
	a &man.ps.1; és &man.top.1;, egészen addig nem
	lesznek képesek normálisan mûködni,
	amíg a rendszer és a rendszermag
	forráskódja nem illeszkedik
	egymáshoz.</para>

      <para>Ennek legegyszerûbb és egyben
	legbiztonságosabb módja, ha a
	<filename>GENERIC</filename> beállításai
	alapján gyártunk és telepítünk
	egy rendszermagot.  Még ha a <filename>GENERIC</filename>
	beállításai nem is tartalmazzák a
	rendszerünkben fellelhetõ összes eszközt,
	minden megtalálható bennük ahhoz, hogy a
	rendszert sikeresen elindíthassuk legalább
	egyfelhasználós módban.  Ez mellesleg remek
	próbája az új rendszer
	életképességének.  Miután
	elindítottuk a rendszert a <filename>GENERIC</filename>
	típusú rendszermaggal és
	meggyõzõdtünk róla, hogy a rendszer
	tényleg mûködõképes, a megszokott
	rendszermagunk konfigurációs
	állománya alapján nyugodtan
	elkészíthetjük ezután azt is.</para>

      <para>&os; alatt egy új rendszermag
	építése elõtt fontos <link linkend="make-buildworld">újrafordítani az
	alaprendszert</link>.</para>

      <note>
	<para>Ha saját beállításaink szerint
	  akarunk rendszermagot létrehozni és már
	  van is ehhez egy konfigurációs
	  állományunk, akkor erre használhatjuk a
	  <literal>KERNCONF=SAJÁTMAG</literal>
	  paramétert is, valahogy így:</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildkernel KERNCONF=SAJÁTMAG</userinput>
&prompt.root; <userinput>make installkernel KERNCONF=SAJÁTMAG</userinput></screen>
      </note>

      <para>Hozzátennénk, hogy ha a
	<varname>kern.securelevel</varname>
	rendszerváltozó értékét 1
	felé állítottuk
	<emphasis>és</emphasis> a rendszermag
	állományának beállítottunk
	<literal>noschg</literal> vagy hozzá hasonló
	állományjelzõt, akkor az
	<buildtarget>installkernel</buildtarget>
	lefuttatásához mindenképpen
	egyfelhasználós módba kell
	váltanunk.  Minden más esetben további
	bonyodalmak nélkül ki tudjuk adni az említett
	parancsokat.  A <varname>kern.securelevel</varname>
	részleteirõl az &man.init.8; oldalán, a
	különbözõ
	állományjelzõkrõl pedig a
	&man.chflags.1; oldalán olvashatunk.</para>
    </sect2>

    <sect2 xml:id="new-kernel-singleuser">
      <title>Indítsuk újra a rendszert
	egyfelhasználós módban</title>

      <indexterm><primary>egyfelhasználós
	mód</primary></indexterm>

      <para>Az új rendszermag mûködésének
	leteszteléséhez indítsuk újra a
	rendszert egyfelhasználós módban.  Ennek
	pontos részleteit lásd <xref linkend="makeworld-singleuser"/>.</para>
    </sect2>

    <sect2 xml:id="make-installworld">
      <title>Telepítsük az új rendszer
	binárisait</title>

      <para>Ha a &os; friss változatát nemrég
	fordítottuk le a <command>make buildworld</command>
	paranccsal, akkor utána az
	<buildtarget>installworld</buildtarget>
	segítségével tudjuk telepíteni a
	keletkezett programokat.</para>

      <para>Tehát írjuk be ezeket:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput></screen>

      <note>
	<para>Amennyiben a paranccsorban a <command>make
	  buildworld</command> használata során adtunk meg
	  változókat, akkor ne felejtsük el
	  ugyanazokat megadni a <command>make installworld</command>
	  kiadása során sem.  Ez viszont a többi
	  paraméterre már nem feltétlenül
	  érvényes.  Például a
	  <option>-j</option> beállítást
	  szigorúan tilos az
	  <buildtarget>installworld</buildtarget> targettel együtt
	  használni.</para>

	<para>Ennek megfelelõen tehát ha korábban ezt
	  írtuk be:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE buildworld</userinput></screen>

	<para>akkor így telepítsünk:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE installworld</userinput></screen>

	<para>Máskülönben azokat a profilozott
	  függvénykönyvtárakat
	  próbáljuk meg telepíteni, amelyek a
	  <command>make buildworld</command> futása során
	  nem jöttek létre.</para>
      </note>
    </sect2>

    <sect2 xml:id="post-installworld-updates">
      <title>Frissítsük a <command>make
	installworld</command> által kihagyott
	állományokat</title>

      <para>Az alaprendszer újrafordítása nem
	regisztrálja az új vagy megváltozott
	állományokat bizonyos könyvtárakban
	(különösen értendõ ez az
	<filename>/etc</filename>, <filename>/var</filename> és
	<filename>/usr</filename> esetén).</para>

      <para>Az ilyen állományokat a legegyszerûbben a
	&man.mergemaster.8; használatával tarthatjuk
	karban, de igény szerint akár kézzel is
	elvégezhetjük a szükséges
	aktualizálásokat.  Függetlenül
	attól, hogy mit is választunk, mindenképpen
	készítsünk biztonsági mentést
	az <filename>/etc</filename> könyvtárról arra
	az esetre, ha bármilyen szörnyûség
	történne.</para>

    <sect3 xml:id="mergemaster">
      <info><title>A <command>mergemaster</command></title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Írta: </contrib></author>
	</authorgroup>
      </info>

      

      <indexterm><primary><command>mergemaster</command></primary></indexterm>

      <para>A &man.mergemaster.8; segédprogram
	valójában egy Bourne szkript, amely segít
	az <filename>/etc</filename> könyvtárunkban
	és a forrásfában levõ
	<filename>/usr/src/etc</filename> könyvtárban
	elhelyezkedõ konfigurációs
	állományok közti eltérések
	megállapításában.  Ezt a
	módszert ajánljuk arra, hogy összevessük
	a konfigurációs állományainkat a
	forrásfában található
	változataikkal.</para>

      <para>A használatának megkezdéséhez
	egyszerûen írjuk be, hogy
	<command>mergemaster</command>, majd várjunk egy kicsit,
	amíg a <command>mergemaster</command> létrehoz
	magának egy átmeneti környezetet a
	<filename>/</filename> könyvtárból elindulva
	és megtölti azt a különbözõ
	rendszerszintû beállításokat
	tartalmazó állományokkal.  Ezeket az
	állományokat aztán
	összehasonlítja a jelenleg érvényben
	levõ változataikkal.  Ilyenkor a köztük
	talált eltéréseket a &man.diff.1;
	formátumának megfelelõen módon mutatja
	meg, ahol a <option>+</option> jelöli a hozzáadott
	vagy módosított sorokat, a <option>-</option>
	pedig a teljesen eltávolítandó vagy
	cserélendõ sorokat.  Errõl a
	formátumról bõvebben a &man.diff.1; man
	oldalán találhatunk
	felvilágosítást.</para>

      <para>A &man.mergemaster.8; ezt követõen megmutatja az
	összes olyan állományt, ahol
	eltérést tapasztalt, és ezen a ponton van
	lehetõségünk letörölni (delete) az
	új állományokat (amelyekre itt most
	ideiglenes állományként hivatkozik),
	telepíteni (install) a módosítatlan
	ideiglenes (új) állományt, valamint
	összefésülni (merge) az ideiglenes (új)
	és a jelenlegi állományokat, vagy
	ismét átnézni (view) a &man.diff.1;
	által jelzett különbségeket.</para>

      <para>Ha az ideiglenes állomány
	törlését választjuk, akkor a
	&man.mergemaster.8; ezt úgy értelmezi, hogy
	változatlanul meg akarjuk tartani a jelenlegi
	változatot és törölni az újat.
	Ezt alapvetõen nem javasoljuk, hacsak tényleg nem
	látunk valamilyen okot erre.  A &man.mergemaster.8;
	parancssorában a <keycap>?</keycap>
	begépelésével bármikor
	kérhetünk segítséget.  Ha az
	állomány kihagyását (skip)
	választjuk, akkor majd ismét felajánlja,
	amikor végeztünk az összes
	többivel.</para>

      <para>A módosítatlan ideiglenes
	állomány telepítésének
	választásával lecseréljük a
	jelenleg verziót az újra.  Ha az aktuális
	verziót sem változtattuk meg, akkor
	számunkra ez a legjobb megoldás.</para>

      <para>Az állományok
	összefésülésének
	kiválasztásakor kapunk egy
	szövegszerkesztõt, benne a két
	állomány tartalmával.  Ilyenkor tudjuk a
	képernyõn soronként egyeztetni a két
	állományt, majd a belõlük a
	megfelelõ részek
	összeválogatásával kialakítani
	az eredményt.  Ebben a feldolgozási módban
	az <keycap>l</keycap> (mint left, vagyis bal) billentyû
	lenyomására a bal oldalon látható
	részt, az <keycap>r</keycap> (mint right, vagyis jobb)
	lenyomására pedig a jobb oldalon
	látható részt választjuk ki.  Az
	így keletkezõ eredményt ezután egy
	állományba kerül, amelyet telepíteni
	tudunk.  Ez a megoldás olyan állományok
	esetében használható, amikor a
	felhasználó módosított az
	alapértelmezett
	beállításokat.</para>

      <para>Ha a &man.diff.1; szerinti alakban akarjuk
	átnézni a különbségeket, akkor a
	&man.mergemaster.8; ugyanúgy megmutatja ezeket, mint a
	paranccsor megjelenítése elõtt.</para>

      <para>Miután a &man.mergemaster.8; végigment a
	rendszerszintû állományokon, további
	opciókat mutat.  Megkérdezheti, hogy újra
	létre akarjuk-e hozni a jelszavakat tároló
	állományt (rebuild), illetve a folyamat
	végén a megmaradt ideiglenes
	állományok törlésére (remove)
	vár választ.</para>
      </sect3>

      <sect3>
	<title>Az állományok aktualizálása
	  kézzel</title>

	<para>Ha inkább manuálisan szeretnénk
	  frissíteni, akkor nem másolhatjuk csak
	  egyszerûen át az állományokat a
	  <filename>/usr/src/etc</filename>
	  könyvtárból a <filename>/etc</filename>
	  könyvtárba és nem hagyhatjuk ezeket
	  sorsukra.  Egyes állományokat elõször
	  <quote>telepíteni</quote> kell.  Ez azért van
	  így, mert a <filename>/usr/src/etc</filename>
	  könyvtár <emphasis>nem pusztán</emphasis>
	  az <filename>/etc</filename> könyvtár
	  egyszerû másolata.  Ráadásul az
	  <filename>/etc</filename> könyvtárban vannak olyan
	  állományok, amelyek a
	  <filename>/usr/src/etc</filename> könyvtárban nem
	  is találhatóak meg.</para>

	<para>Ha (az ajánlottak szerint) a &man.mergemaster.8;
	  segítségével dolgozunk, nyugodtan
	  átléphetünk a <link linkend="updating-upgrading-rebooting">következõ
	  szakaszra</link>.</para>

	<para>Saját magunk a legegyszerûbben ezt úgy
	  tudjuk megoldani, ha telepítjük az
	  állományokat egy új
	  könyvtárba és ezután
	  nekiállunk változásokat keresni.</para>

	<warning>
	  <title>Az <filename>/etc</filename> meglevõ
	    tartalmának mentése</title>

	  <para>Habár elméletileg magától
	    semmi sem fogja bántani ezt a könyvtárat,
	    azért ettõl függetlenül mindig
	    érdemes biztosra menni.  Ezért másoljuk
	    az <filename>/etc</filename> könyvtár
	    tartalmát egy megbízható helyre.
	    Például:</para>

	  <screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

	  <para>Az <option>-R</option> itt a rekurzív
	    másolást jelenti, a <option>-p</option> pedig
	    a dátumok, az állományok és
	    egyebek tulajdoni viszonyainak
	    megõrzését.</para>
	</warning>

	<para>Az <filename>/etc</filename> új
	  változatának telepítéséhez
	  szükségünk lesz még további
	  könyvtárakra is.  Erre a feladatra a
	  <filename>/var/tmp/root</filename> tökéletesen
	  megfelel, ahol még létre kell hoznunk
	  néhány alkönyvtárat.</para>

	<screen>&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>

	<para>Ezzel létrejön a szükséges
	  könyvtárszerkezet és települnek az
	  állományok.  Sok üres
	  alkönyvtár is keletkezik a
	  <filename>/var/tmp/root</filename> könyvtáron
	  belül, ezeket töröljük.  Ezt a
	  legkönnyebben így tehetjük meg:</para>

	<screen>&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d . -type d | xargs rmdir 2&gt;/dev/null</userinput></screen>

	<para>Ezzel törlõdnek az üres
	  könyvtárak.  (A szabvány hibakimenetet
	  átirányítottuk a
	  <filename>/dev/null</filename> eszközre, és ezzel
	  elnyomtuk a nem üres könyvtárak esetén
	  keletkezõ hibaüzeneteket.)</para>

	<para>A <filename>/var/tmp/root</filename> most már
	  tartalmazza az összes olyan állományt,
	  amelyek normális esetben a <filename>/</filename>
	  könyvtáron belül foglalnak helyet.  Ezt
	  követõen nincs más dolgunk, csak
	  végigmenni az itt található
	  állományokon és
	  megállapítani, miben térnek a
	  meglévõektõl.</para>

	<para>Vegyük észre, hogy a
	  <filename>/var/tmp/root</filename> könyvtárba
	  telepített állományok
	  némelyikének neve <quote>.</quote>-tal
	  kezdõdik.  Az írás pillanatában ezek
	  csak a <filename>/var/tmp/root/</filename> és
	  <filename>/var/tmp/root/root/</filename>
	  könyvtárakban található
	  parancsértelmezõhöz tartozó
	  indító állományok lehetnek,
	  habár adódhatnak még ilyenek
	  (attól függõen, mikor olvassuk ezt).
	  Ezért a feldolgozásukhoz ne felejtsük el a
	  <command>ls -a</command> parancsot használni.</para>

	<para>A &man.diff.1; alkalmazásával
	  legegyszerûbben így tudunk
	  összehasonlítani két
	  állományt:</para>

	<screen>&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>

	<para>Ennek hatására megjelennek az
	  <filename>/etc/shells</filename> és az új
	  <filename>/var/tmp/root/etc/shells</filename>
	  állományok közti
	  különbségek.  A
	  segítségével gyorsan el tudjuk
	  dönteni, hogy összefésüljük-e a
	  két állományt, vagy csak egyszerûen
	  írjuk felül a régebbi verziót az
	  újjal.</para>

	<tip>
	  <title>Az új könyvtár
	    (<filename>/var/tmp/root</filename>) nevébe
	    írjuk bele a dátumot is, így
	    könnyedén össze tudunk hasonlítani
	    több verziót is</title>

	  <para>A rendszer gyakori újrafordítása az
	    <filename>/etc</filename> szintén gyakori
	    aktualizálását is maga után
	    vonja, ami viszont fárasztó lehet.</para>

	  <para>Az iménti folyamatot fel tudjuk
	    gyorsítani, hogy ha az <filename>/etc</filename>
	    legutoljára összefésült
	    változatát megtartjuk.  A most
	    következõ eljárás ennek
	    mikéntjét vázolja fel.</para>

	  <procedure>
	    <step>
	      <para>A megszokottak szerint fordítsuk le a
		rendszert.  Majd amikor az <filename>/etc</filename>
		könyvtárat és a többit is
		frissíteni akarjuk, a célként
		megadott könyvtár nevében adjuk meg a
		dátumot.  Ha tehát például
		1998.  február 14.  van, akkor írjuk
		ezt:</para>

	      <screen>&prompt.root; <userinput>mkdir /var/tmp/root-19980214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-19980214 \
    distrib-dirs distribution</userinput></screen>
	    </step>

	    <step>
	      <para>Fésüljük össze a
		könyvtárban található az
		állományokat a fentiekben
		körvonalazottak szerint.</para>

	      <para>Befejezés után
		<emphasis>õrizzük meg</emphasis> a
		<filename>/var/tmp/root-19980214</filename>
		könyvtárat.</para>
	    </step>

	    <step>
	      <para>Mikor újra letöltjük a legfrissebb
		forrásokat és megismételjük az
		elõbbi lépéseket, haladjunk megint az
		elsõ lépés szerint.  Ekkor
		tehát létrejön egy újabb
		könyvtár, amelynek a neve ezúttal
		már <filename>/var/tmp/root-19980221</filename>
		lesz (ha például hetente
		frissítünk).</para>
	    </step>

	    <step>
	      <para>Most már meg tudjuk vizsgálni a
		közbeesõ héten született
		eltéréseket, ha a két
		könyvtárra kiadunk egy rekurzív
		&man.diff.1; hívást:</para>

	      <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-19980214 root-19980221</userinput></screen>

	      <para>Általában így kevesebb
		eltérést kapunk, mint amennyi
		például a
		<filename>/var/tmp/root-19980221/etc/</filename>
		és az <filename>/etc</filename>
		összehasonlítása során
		elkerült volna.  Mivel kisebb a keletkezett
		különbségek száma, ezért
		könnyebb lesz átvinnünk az
		<filename>/etc</filename> könyvtárunkba is a
		módosításokat.</para>
	    </step>

	    <step>
	      <para>Ezután törölhetjük a
		régebbi <filename>/var/tmp/root-*</filename>
		könyvtárat:</para>

	      <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-19980214</userinput></screen>
	    </step>

	    <step>
	      <para>Az <filename>/etc</filename>
		összefésülésekor mindig
		ismételjük meg ezeket a
		lépéseket.</para>
	    </step>
	  </procedure>

	  <para>A &man.date.1; meghívásával
	    akár automatikussá is tehetjük a
	    könyvtárak névadását:</para>

	  <screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
	</tip>
      </sect3>
    </sect2>

    <sect2 xml:id="updating-upgrading-rebooting">
      <title>Újraindítás</title>

      <para>Ezzel készen is vagyunk.  Miután
	ellenõriztük, hogy minden a megfelelõ
	helyére került, indítsuk újra a
	rendszert.  Ehhez egy egyszerû &man.shutdown.8; is
	elegendõ:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>
    </sect2>

    <sect2>
      <title>Befejeztük!</title>

      <para>Gratulálunk, sikerült frissítenünk a
	&os; rendszerünket.</para>

      <para>Ha mégis valami balul ütne ki, könnyen
	újra tudjuk fordítani a rendszer egyes
	részeit.  Például, ha
	véletlenül letöröltük az
	<filename>/etc/magic</filename> állományt az
	<filename>/etc</filename> frissítése vagy
	összefésülése során, a
	&man.file.1; parancs nem fog tudni rendesen mûködni.
	Ilyenkor a következõket kell tennünk a hiba
	kijavításához:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2 xml:id="updating-questions">
      <title>Kérdések</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>Minden egyes változtatásnál
	      újra kell fordítani a rendszert?</para>
	  </question>

	  <answer>
	    <para>Nem könnyû választ adni erre a
	      kérdésre, mivel ez alapvetõen a
	      változtatás jellegétõl
	      függ.  Például, ha elindítjuk a
	      <application>CVSup</application> programot és csak
	      az alábbi állományok
	      frissülnek:</para>

	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

	    <para>Ekkor valószínûleg nem éri
	      meg újrafordítani a teljes rendszert.
	      Elegendõ csupán belépni az
	      érintett állományokat
	      tartalmazó alkönyvtárakba és ott
	      rendre kiadni a <command>make all install</command>
	      parancsot.  Ha viszont már valami komolyabb,
	      például az
	      <filename>src/lib/libc/stdlib</filename> változott
	      meg, akkor vagy az egész rendszert, vagy
	      legalább azon részeit fordítsuk
	      újra, amely statikusan linkeltek (és minden
	      más idõközben még
	      hozzáadott statikusan linkelt dolgot).</para>

	    <para>Hogy melyik megoldást választjuk,
	      teljesen rajtunk áll.
	      Újrafordíthatjuk az egész rendszert
	      kéthetente, mondván, hadd gyüljenek fel
	      szépen a módosítások, vagy a
	      függõségek pontos
	      kielemzésével csak azokat az elemeket
	      fordítjuk újra, amelyek tényleg meg
	      is változtak.</para>

	    <para>Természetesen az egész attól
	      függ, hogy milyen gyakran és melyik rendszert,
	      a &os.stable;-t vagy a &os.current;-et
	      frissítjük.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>A fordító rengeteg 11-es jelzést
	      (signal 11)<indexterm><primary>signal 11</primary>
	      </indexterm> (vagy másfajta jelzéseket) dob
	      hibával.  Mi történhetett?</para>
	  </question>

	  <answer>
	    <para>Ez általában hardveres
	      meghibásodásra utal.  A rendszer
	      újrafordítása alapjaiban véve
	      egy remek módszer
	      számítógépünk
	      alkatrészeinek terhelésére,
	      ezért gyakorta elõhozza a memória
	      már meglevõ hibáit.  Ezek
	      többnyire abban fogalmazódnak meg, hogy a
	      fordító rejtélyes módon
	      leáll mindenféle furcsa jelzések
	      hatására.</para>

	    <para>Errõl biztosan úgy tudunk
	      meggyõzõdni, ha újraindítjuk a
	      make programot és az a folyamat egy teljesen
	      másik pontján vérzik el.</para>

	    <para>Ilyenkor nem tudunk mást tenni, mint
	      egymás után kicserélgetjük,
	      kivesszük az alkatrészeket és
	      így próbáljuk
	      megállapítani, pontosan melyikük is
	      okozza a gondokat.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>A fordítása befejezése
	      után törölhetem a
	      <filename>/usr/obj</filename>
	      könyvtárat?</para>
	  </question>

	  <answer>
	    <para>Röviden: Igen.</para>

	    <para>A <filename>/usr/obj</filename> tartalmazza a
	      fordítás folyamata során
	      keletkezõ összes tárgykódot.
	      Ennek törlése általában a
	      <command>make buildworld</command> elsõ
	      lépései között szerepel.
	      Ezért tulajdonképpen a
	      <filename>/usr/obj</filename> megtartásának
	      nincs túlságosan sok értelme, viszont
	      elég sok (jelenleg úgy kb.  340&nbsp;MB)
	      helyet fel tudunk így szabadítani.</para>

	    <para>Ha azonban értjük a dolgunkat, akkor
	      megadhatjuk a <command>make buildworld</command>
	      parancsnak, hogy hagyja ki ezt a lépést.
	      Ennek hatására a fordítás
	      sokkal hamarabb véget ér, mivel a
	      legtöbb forrást így nem kell
	      újrafordítani.  Üröm az
	      örömben, hogy ha netalán aprócska
	      függõségi problémák
	      merülnének fel, akkor az egész
	      fordítás megfeneklik mindenfelé
	      különös módokon.  Emiatt gyakran
	      írnak feleslegesen leveleket a &os;
	      levelezési listáira, melyek a rendszer
	      sikertelen
	      újrafordításáról
	      panaszkodnak, miközben kiderül, hogy az maguk az
	      érintettek akarták lerövidíteni
	      a folyamatot.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Lehetséges a megszakadt fordítás
	      folytatása?</para>
	  </question>

	  <answer>
	    <para>Ez attól függ, hogy a probléma
	      bekövetkezése elõtt mennyire
	      sikerült eljutni a fordításban.</para>

	    <para><emphasis>Általában</emphasis>
	      (tehát nem feltétlenül minden esetben)
	      a <command>make buildworld</command> lefordítja a
	      fordításhoz szükséges
	      eszközök (például a &man.gcc.1;
	      és &man.make.1;) újabb változatait
	      és a rendszer
	      függvénykönyvtárait, majd ezeket
	      telepíti.  Ezután ezekkel az új
	      eszközökkel lefordítattja saját
	      magukat és ismét telepíti.  Ezt
	      követõen fordítja újra az
	      új rendszerállományokkal az
	      egész rendszert (így ezúttal
	      már az olyan szokásos
	      felhasználói programokat is, mint
	      például az &man.ls.1; és a
	      &man.grep.1;).</para>

	    <para>Ha tudjuk, hogy az utolsó fázisban
	      álltunk le (mivel megnéztük a
	      fordításhoz tartozó kimenetet), akkor
	      (minden további nélkül) elég
	      ennyi:</para>

	    <screen><emphasis>&hellip; kijavítjuk a hibát &hellip;</emphasis>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNO_CLEAN all</userinput></screen>

	    <para>Ezzel megmarad a korábbi <command>make
	      buildworld</command> munkájának
	      eredménye.</para>

	    <para>Ha ezt az üzenetet látjuk a <command>make
	      buildworld</command> kimenetében:</para>

	      <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

	    <para>akkor különösebb gond
	      nélkül megcsinálhatjuk.</para>

	    <para>Amennyiben viszont nem látunk ilyen
	      üzenetet, vagy nem vagyunk benne biztosak, akkor
	      még mindig jobb elõvigyázatosnak lenni,
	      ezért kénytelenek leszünk teljesen
	      elölrõl kezdeni a
	      fordítást.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Hogyan tudjuk felgyorsítani a
	      fordítást?</para>
	  </question>

	  <answer>
	    <itemizedlist>
	      <listitem>
		<para>Futtassuk egyfelhasználós
		  módban.</para>
	      </listitem>

	      <listitem>
		<para>Tegyük a <filename>/usr/src</filename>
		  és <filename>/usr/obj</filename>
		  könyvtárakat külön
		  állományrendszerekre, külön
		  lemezekre.  Sõt, ha lehetséges, akkor
		  ezeket a lemezeket tegyük külön
		  lemezvezérlõkre.</para>
	      </listitem>

	      <listitem>
		<para>Még mindig jobb, ha ezeket az
		  állományrendszereket a &man.ccd.4;
		  (lemezek összefûzését
		  vezérlõ meghajtó)
		  segítségével kiterjesztjük
		  több lemezes eszközre.</para>
	      </listitem>

	      <listitem>
		<para>Kapcsoljuk ki a profilozást (az
		  <filename>/etc/make.conf</filename>
		  állományban a
		  <quote>NO_PROFILE=true</quote>
		  megadásával).  Többnyire úgy
		  sem lesz rá szükségünk.</para>
	      </listitem>

	      <listitem>
		<para>Az <filename>/etc/make.conf</filename>
		  állományban a <varname>CFLAGS</varname>
		  változót állítsuk az
		  <option>-O -pipe</option> értékre.  Az
		  <option>-O2</option> gyakran sokkal lassabb, az
		  <option>-O</option> és <option>-O2</option>
		  alig tér el az optimalizálás
		  mértékében.  A
		  <option>-pipe</option> paraméter
		  hatására pedig a
		  fordítóprogram átmeneti
		  állományok helyett csöveket
		  használ a kommunikációra,
		  és így megtakarít némi
		  lemezhasználatot (a
		  memóriahasználat terhére).</para>
	      </listitem>

	      <listitem>
		<para>Ha a &man.make.1; parancsnak átadjuk a
		  <option>-j<replaceable>n</replaceable></option>
		  paramétert, akkor képes több
		  mindent párhuzamosan futtatni.  Ez sok esetben
		  segít attól függetlenül, hogy
		  egy- vagy többprocesszoros gépünk
		  van.</para>
	      </listitem>

	      <listitem>
		<para>A <filename>/usr/src</filename>
		  könyvtárat tartalmazó
		  állományrendszert csatlakoztathatjuk
		  (vagy újracsatlakoztathatjuk) a
		  <option>noatime</option>
		  beállítással.  Ilyenkor az
		  állományrendszer nem rögzíti
		  a hozzáférés idejét.  Erre
		  az információra sincs
		  igazából
		  szükségünk.</para>

		<screen>&prompt.root; <userinput>mount -u -o noatime /usr/src</userinput></screen>

		<warning>
		  <para>A fenti példa azt feltételezi,
		    hogy a <filename>/usr/src</filename>
		    könyvtárnak saját
		    állományrendszere van.  Ha ez nem
		    így lenne (tehát például
		    a <filename>/usr</filename> része), akkor itt
		    azt kell megadnunk, nem pedig a
		    <filename>/usr/src</filename> nevét.</para>
		</warning>
	      </listitem>

	      <listitem>
		<para>A <filename>/usr/obj</filename>
		  könyvtárat tartalmazó
		  állományrendszert csatlakoztathatjuk
		  (vagy újracsatlakoztathatjuk) az
		  <option>async</option>
		  beállítással.  Ennek
		  hatására a lemez írása
		  aszinkron módon történik.  Magyarul
		  az írási mûveletek azonnal
		  befejezõdnek, miközben az adat
		  ténylegesen csak pár másodperccel
		  késõbb kerül ki a lemezre.  Ezzel az
		  írási kérelmek
		  gyönyörûen
		  összegyûjthetõek, ami
		  nagymértékû növekedést
		  eredményez a
		  teljesítményben.</para>

		<warning>
		  <para>Ne felejtsük el azonban, hogy ezzel
		    együtt az
		    állományrendszerünk is
		    sérülékenyebbé
		    válik.  Ezen beállítás
		    használatával megnõ annak az
		    esélye, hogy egy áramkimaradást
		    követõ indításnál az
		    állományrendszer
		    helyreállíthatatlan állapotba
		    kerül.</para>

		  <para>Ha egyedül csak a
		    <filename>/usr/obj</filename>
		    található ezen az
		    állományrendszeren, akkor ez nem
		    jelent akkora veszélyt.  Amikor viszont rajta
		    kívül még értékes
		    adat is található az
		    állományrendszeren, a
		    beállítás
		    érvényesítése elõtt
		    mindenképpen készítsünk
		    róla friss mentéseket.</para>
		</warning>

		<screen>&prompt.root; <userinput>mount -u -o async /usr/obj</userinput></screen>

		<warning>
		  <para>Ahogy arról az elõbb is szó
		    esett, ha a <filename>/usr/obj</filename> nem egy
		    különálló
		    állományrendszeren
		    található, akkor a
		    példában szereplõ
		    csatlakozási pontot cseréljük ki
		    a megfelelõre.</para>
		</warning>
	      </listitem>
	    </itemizedlist>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Mi tegyünk, ha valami nem megy rendesen?</para>
	  </question>

	  <answer>
	    <para>Egyértelmûen bizonyosodjunk meg
	      róla, hogy a korábbi
	      fordításokból nem maradtak vissza
	      semmiféle kóbor állományok.
	      Ennyi sokszor pontosan elég.</para>

	    <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root; <userinput>rm -rf /usr/obj/usr</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

	    <para>Igen, a <command>make cleandir</command> parancsot
	      tényleg kétszer kell kiadni.</para>

	    <para>Ezután a <command>make buildworld</command>
	      parancstól indulva kezdjük újra a
	      fordítást.</para>

	    <para>Ha még ezek után is fennáll a
	      probléma, küldjük el a hibát
	      tartalmazó kimenetet és a <command>uname
	      -a</command> parancs eredményét a
	      &a.questions; címére.  Ne
	      lepõdjünk meg, ha a
	      beállításainkra vonatkozóan
	      még kapunk további kérdéseket
	      is!</para>
	  </answer>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 xml:id="small-lan">
    <info><title>A források követése több
      géppel</title>
      <authorgroup>
	<author><personname><firstname>Mike</firstname><surname>Meyer</surname></personname><contrib>Írta: </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>NFS</primary>
      <secondary>több gép
	telepítése</secondary>
    </indexterm>

    <para>Ha egyszerre több
      számítógéppel is szeretnénk
      követni ugyanannak a forrásfának a
      változásait és ezért mindegyikre
      letöltjük a forrásokat majd
      újrafordítjuk ezeket, akkor sok
      erõforrást, de leginkább lemezterületet,
      hálózati sávszélességet
      és processzoridõt, feleslegesen használunk.
      Ezekkel úgy tudunk spórolni, ha
      valójában csak egyetlen géppel
      végeztetjük el a munka legtöbb
      részét, miközben a többi NFS
      használatával dolgozik.  Ez a szakasz ezt a
      módszert foglalja össze.</para>

    <sect2 xml:id="small-lan-preliminaries">
      <title>Elõkészületek</title>

      <para>Elõször is szedjük össze az egyezõ
	binárisokat futtató gépeket, melyekre a
	továbbiakban csak <emphasis>fordítási
	csoport</emphasis> néven hivatkozunk.  Minden
	gépnek lehet saját rendszermagja, viszont a
	felhasználói programok mindegyikõjük
	esetében ugyanazok.  Ebbõl a csoportból
	válasszuk ki egy <emphasis>fordító
	gépet</emphasis>.  Ez lesz az a gép, amelyen a
	rendszer és a rendszermag lefordításra
	kerül.  Ideális esetben ez a leggyorsabb gép,
	amelynek elegendõ a processzorkapacitása arra, hogy
	lefuttassa a <command>make buildworld</command> és
	<command>make buildkernel</command> parancsokat.  Érdemes
	még rajta kívül kiválasztanunk egy
	<emphasis>tesztelõ gépet</emphasis> is, ahol a
	véglegesítés elõtt
	kipróbálhatjuk a
	szoftverfrissítéseket.  Ennek egy olyan
	gépnek <emphasis>kell</emphasis> lennie, amely
	akár hosszabb ideig is nélkülözhetõ
	a csoportból.  Lehet akár maga a
	fordítást végzõ gép is, de nem
	elvárás.</para>

      <para>A fordítási csoportban levõ összes
	gépnek ugyanarról a géprõl és
	ugyanarra a pontra kell csatlakoztatnia a
	<filename>/usr/obj</filename> és
	<filename>/usr/src</filename> könyvtárakat.  Ezek
	optimális esetben a fordítással
	foglalkozó gép két külön
	lemezmeghajtóján vannak, melyek egyaránt
	elérhetõek NFS-en keresztül.  Ha több
	fordítási csoportunk is van, akkor az
	<filename>/usr/src</filename> könyvtárnak
	elegendõ csak egyetlen fordító gépen
	meglennie, a többi pedig csatlakoztassa NFS-en
	keresztül.</para>

      <para>Végül gyõzödjünk meg róla,
	hogy az <filename>/etc/make.conf</filename> és a
	<filename>/etc/src.conf</filename> állományok
	tartalma a fordítási csoport mindegyik
	gépénél megegyezik a fordító
	gépével.  Ez azt jelenti, hogy a
	fordító gépnek az alaprendszer ugyanazon
	részeit és ugyanúgy kell létrehozni,
	mint amelyet a fordítási csoport akármelyik
	gépére telepíteni is akarunk.
	Ezenkívül még a fordítási
	csoportban levõ minden egyes gép
	<filename>/etc/make.conf</filename>
	állományában a <varname>KERNCONF</varname>
	értékének a saját
	rendszermagjára vonatkozó
	konfigurációt kell megadni, illetve a
	fordítással foglakozó gép
	<varname>KERNCONF</varname>
	változójánál pedig az együtt
	összeset, a sajátjával kezdve.  Ennek
	megfelelõen a fordító gépnek a
	rendszermagok lefordításához rendelkeznie
	kell az egyes gépek
	<filename>/usr/src/sys/arch/conf</filename>
	könyvtárában meglevõ
	állományaival.</para>
    </sect2>

    <sect2 xml:id="small-lan-base-system">
      <title>Az alaprendszer</title>

      <para>Most, miután mindent megfelelõen
	elõkészítettünk, készen
	állunk a munkára.  A <xref linkend="make-buildworld"/>ban leírtak szerint
	fordítsuk le a rendszermagokat és az alaprendszert
	a fordító gépen, de utána még
	nem telepítsünk semmit se.  Ha
	befejezõdött a fordítás,
	lépjünk be a tesztelõ gépre és
	telepítsük a frissen fordított rendszermagot.
	Ha ez a gép NFS-en keresztül éri a
	<filename>/usr/src</filename> és
	<filename>/usr/obj</filename> könyvtárakat, akkor az
	egyfelhasználós módban aktiválni
	kell a hálózatot, majd csatlakoztatni ezeket.  Ezt
	legkönnyebben úgy tudjuk megcsinálni, ha a
	gépet elõször elindítjuk
	többfelhasználós módban, majd a
	<command>shutdown now</command> paranccsal
	egyfelhasználós módba váltunk.  Ha
	eljuttunk ide, telepítsünk az új
	rendszermagot és rendszert, illetve a megszokott
	módon futtassuk a <command>mergemaster</command>
	parancsot.  Amikor ezt befejeztük, ezen a gépen
	térjünk vissza a hétköznapi
	többfelhasználós mûködési
	módba.</para>

      <para>Miután a tesztelésre szánt gépen
	ellenõriztük, hogy minden a megfelelõ
	módon mûködik, az elõbb tárgyalt
	eljárással telepítsük fel a
	fordítási csoportban levõ összes
	többi gépre is az új szoftvereket.</para>
    </sect2>

    <sect2 xml:id="small-lan-ports">
      <title>Portok</title>

      <para>Ugyanezt a gondolatmenet alkalmazható a portfa
	esetében is.  Az elsõ és egyben legfontosabb
	lépés a <filename>/usr/ports</filename>
	csatlakoztatása ugyanarról a géprõl a
	fordítási csoport minden gépére.  Az
	<filename>/etc/make.conf</filename> megfelelõ
	beállításával még a
	terjesztési állományokat is meg tudjuk
	osztani.  A <varname>DISTDIR</varname>
	értékét egy olyan közösen
	használt könyvtárra állítsuk,
	amely írható az NFS-en keresztül megosztott
	állományrendszerünkben a
	<systemitem class="username">root</systemitem> felhasználóként
	tevékenykedõk számára.  A
	<varname>WRKDIRPREFIX</varname> változót minden
	gépen egy helyi fordítási
	könyvtárra állítsuk.
	Zárásképpen még
	hozzátesszük, hogy ha csomagokat akarunk
	készíteni és mások
	számára is elérhetõvé tenni,
	akkor ne felejtsük el a <varname>PACKAGES</varname>
	változót a <varname>DISTDIR</varname>
	változóhoz hasonlóan
	beállítani.</para>
    </sect2>
  </sect1>
</chapter>
