<?xml version="1.0" encoding="iso-8859-2"?>
<!DOCTYPE book PUBLIC "-//FreeBSD//DTD DocBook XML V5.0-Based Extension//EN"
	"http://www.FreeBSD.org/XML/share/xml/freebsd50.dtd" [
<!ENTITY enbase "http://www.FreeBSD.org">
<!ENTITY bibliography SYSTEM "../../share/xml/bibliography.xml">
<!ENTITY url.base.hu "{{{enbase}}}/hu">
]>
<!-- The FreeBSD Hungarian Documentation Project
     Translated by: PALI, Gabor <pgj@FreeBSD.org>
     %SOURCE%	en_US.ISO8859-1/books/faq/book.xml
     %SRCID%	1.1131
-->
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="hu">
  <info><title>Gyakran Ismételt Kérdések a &os;
      6.<replaceable>X</replaceable>, 7.<replaceable>X</replaceable>
      és 8.<replaceable>X</replaceable>
      változatairól</title>
    

    <author><orgname>A &os; Dokumentációs Projekt</orgname></author>

    <copyright>
      <year>1995</year>
      <year>1996</year>
      <year>1997</year>
      <year>1998</year>
      <year>1999</year>
      <year>2000</year>
      <year>2001</year>
      <year>2002</year>
      <year>2003</year>
      <year>2004</year>
      <year>2005</year>
      <year>2006</year>
      <year>2007</year>
      <year>2008</year>
      <year>2009</year>
      <year>2010</year>
      <holder>A &os; Dokumentációs Projekt</holder>
    </copyright>

    &legalnotice;

    <legalnotice xml:id="trademarks" role="trademarks">
      &tm-attrib.freebsd;
      &tm-attrib.3com;
      &tm-attrib.adobe;
      &tm-attrib.creative;
      &tm-attrib.cvsup;
      &tm-attrib.ibm;
      &tm-attrib.ieee;
      &tm-attrib.intel;
      &tm-attrib.iomega;
      &tm-attrib.linux;
      &tm-attrib.microsoft;
      &tm-attrib.mips;
      &tm-attrib.netscape;
      &tm-attrib.opengroup;
      &tm-attrib.oracle;
      &tm-attrib.sgi;
      &tm-attrib.sparc;
      &tm-attrib.sun;
      &tm-attrib.usrobotics;
      &tm-attrib.xfree86;
      &tm-attrib.general;
    </legalnotice>

    <releaseinfo>$FreeBSD$</releaseinfo>

    <abstract>
      <para>Ezek a gyakran ismételt kérdések a &os;
	6.<replaceable>X</replaceable>, 7.<replaceable>X</replaceable>
	és 8.<replaceable>X</replaceable> változataira
	vonatkoznak.  Az összes bejegyzés a &os;
	6.<replaceable>X</replaceable> vagy annál újabb
	változataira vonatkozik, hacsak azt külön nem
	jelezzük.  Ha szeretnénk segíteni a
	projektnek, akkor küldjünk egy levelet a &a.doc;
	címére!  Ennek a dokumentumnak a legfrissebb
	változata mindig elérhetõ a <link xlink:href="&url.books.faq;/index.html">&os; World Wide Web szerverérõl</link>.
	HTTP-n keresztül letölthetõ egyetlen nagy <link xlink:href="book.html">HTML</link> állományként,
	vagy <link xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">a &os;
	FTP szerverérõl</link> szöveges, &postscript;
	PDF stb.  formátumban.  Továbbá <link xlink:href="&url.base;/search/index.html">keresni is tudunk a
	GYIK-ban</link>.</para>

      <para><emphasis>Fordította: Páli Gábor,
	utolsó ellenõrzés:
	2010.11.28.</emphasis></para>
    </abstract>
  </info>

  <chapter xml:id="introduction" xml:lang="hu">
    <title>Bevezetés</title>

    <para>Üdvözöljük a &os;
      6.<replaceable>X</replaceable>-8.<replaceable>X</replaceable>
      Gyakran Ismételt Kérdéseiben!</para>

    <para>Hasonlóan a Usenetes GYIK-okhoz, ennek a dokumentumnak
      is az a célja, hogy a &os; operációs
      rendszerrel kapcsolatban feltegye a legyakrabban ismételt
      kérdéseket (és persze megválaszolja
      ezeket!).  Habár eredetileg azért
      íródott, hogy megspórolja a feleslegesen
      elvesztegetett sávszélességet és hogy
      megelõzze a régóta ismert
      kérdések újbóli
      feltételét, a GYIK idõközben egy
      értékes
      információforrássá is
      vált.</para>

    <para>Igyekeztünk minden megtenni annak
      érdekében, hogy a GYIK a lehetõ legtöbb
      információt szolgáltassa.  Ha
      szeretnénk javaslatokat tenni a
      továbbfejlesztésére, írjunk
      bátran a &a.doc; címére!</para>

    <qandaset>
      <qandaentry>
	<question xml:id="what-is-FreeBSD">
	  <para>Mi az a &os;?</para>
	</question>

	<answer>
	  <para>Ha tömören akarjuk összefoglalni, akkor a
	    &os; egy AMD64, &intel; EM64T, &i386;, PC-98, IA-64, &arm;,
	    &powerpc; és &ultrasparc; platformokra fejlesztett
	    &unix;-szerû operációs rendszer, amely a
	    Kaliforniai Egyetem (Berkeley) rendszerének
	    <quote>4.4BSD-Lite</quote> kiadására
	    épül, valamint a <quote>4.4BSD-Lite2</quote>
	    kiadásból tartalmaz még
	    néhány továbbfejlesztést.
	    Továbbá közvetett módon még
	    felhasználja a Berkeley <quote>Net/2</quote>
	    kiadásának &i386; architektúrára
	    készített portját, a
	    <quote>386BSD</quote> forrásait is, amit annak
	    idején William Jolitz készített, noha
	    ebbõl ténylegesen már csak nagyon
	    kevés található a rendszerben.  A &os;
	    részletesebb bemutatása és annak
	    tulajdonságai a <link xlink:href="&url.base.hu;/index.html">&os; honlapján</link>
	    találhatóak.</para>

	  <para>A &os;-t munkához, oktatáshoz és
	    szórakozáshoz rengeteg cég,
	    internetszolgáltató, kutató,
	    informatikus, diák és otthoni
	    felhasználó használja a világ
	    minden táján.</para>

	  <para>A &os; bõvebb bemutatásához olvassuk
	    el a <link xlink:href="&url.books.handbook;/index.html">&os;
	    kézikönyvet</link>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="FreeBSD-goals">
	  <para>Mi a &os; Projekt célja?</para>
	</question>

	<answer>
	  <para>A &os; Projektnek az a célja, hogy olyan
	    szoftvereket állítson elõ, amelyek
	    tetszõlegesen felhasználhatóak,
	    mindenféle kötöttségek
	    nélkül.  A fejlesztõk közül sokan
	    nagyon sok idõt és munkát fektetnek a
	    forráskódba (és így a
	    Projektbe), ami nyilván megérdemelne
	    némi anyagi ellensúlyozást olykor, de
	    egyáltalán nem ragaszkodunk hozzá.
	    Úgy érezzük, mindenek elõtt az a
	    <quote>küldetésünk</quote>, hogy
	    feltétel nélkül segítsünk
	    mindenkit a munkánkkal, függetlenül annak
	    szándékaitól, így a
	    munkánk a lehetõ legnagyobb körben
	    kerül felhasználására és
	    így nyújtja a lehetõ legtöbb
	    hasznot.  Véleményünk szerint ez az egyik
	    legalapvetõbb célja a szabad szoftvereknek
	    és ezt a hozzáállást
	    támogatjuk a leginkább.</para>

	  <para>A forrásaink között
	    található, <link xlink:href="http://www.FreeBSD.org/copyright/COPYING">GNU General
	    Public License (GPL)</link> vagy a <link xlink:href="http://www.FreeBSD.org/copyright/COPYING.LIB">GNU
	    Library General Public License (LGPL)</link>
	    licencelésû munkák azonban már
	    valamivel több kötöttséggel
	    járnak, habár ezek inkább a
	    közzétételükre vonatkoznak, nem
	    pedig annak ellenkezõjére, ahogy azt
	    általában megszokhattuk.  A GPL licencû
	    szoftverek kereskedelmi célú
	    felhasználásának további
	    esetleges nehézségei miatt azonban
	    lehetõségeink szerint igyekszünk ezeket
	    olyan szoftverekkel felváltani, amelyek a kevésbé
	    szigorúbb <link xlink:href="http://www.FreeBSD.org/copyright/freebsd-license.html">&os; licencet</link>
	    alkalmazzák.</para>
</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="bsd-license-restrictions">
	  <para>A &os; licenc tartalmaz valamilyen
	    megszorítást?</para>
	</question>

	<answer>
	  <para>Igen.  Ezek a megszorítások azonban nem az
	    adott munka felhasználását
	    szabályozzák, hanem csupán azt, hogy
	    miként viszonyuljunk a &os; Projekthez.  Ha komoly
	    kétségeink lennének a
	    licenceléssel kapcsolatban, olvassuk a jelenleg
	    érvényes <link xlink:href="http://www.FreeBSD.org/copyright/freebsd-license.html">
	    licencet</link> (angolul).  Az egyszerû
	    kíváncsiskodók kedvéért
	    nagyjából így tudnánk
	    összefoglalni a licencet:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Ne állítsuk, hogy mi
		készítettük.</para>
	    </listitem>

	    <listitem>
	      <para>Ne pereljük a Projektet, ha nem
		mûködik.</para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="replace-current-OS">
	  <para>A &os; képes kiváltani a jelenleg
	    használt operációs
	    rendszerünket?</para>
	</question>

	<answer>
	  <para>A legtöbb ember számára igen.  A
	    kérdés megválaszolása azonban
	    természetesen nem ennyire
	    egyértelmû.</para>

	  <para>Sokan nem is magát az operációs
	    rendszert, hanem inkább az alkalmazásokat
	    használják.  Valójában pedig
	    maguk az alkalmazások azok, amelyek az
	    operációs rendszert használják.
	    A &os;-t úgy alakították ki, hogy az
	    alkalmazások számára egy szilárd
	    és mindentudó környezetet
	    nyújtson.  Támogatja a
	    böngészõk, irodai programcsomagok,
	    levelezõ programok, grafikus programok,
	    programozási környezetek, hálózati
	    szerverek széles választékát,
	    és szinte minden mást, amire csak
	    szükségünk lehet.  Az ilyen
	    alkalmazások legnagyobb része
	    elérhetõ a <link xlink:href="http://www.FreeBSD.org/ports/">Portgyûjteményen</link>
	    keresztül.</para>

	  <para>Ha viszont olyan alkalmazást
	    kívánunk használni, amely csak bizonyos
	    operációs rendszereken érhetõ el,
	    nem tudjuk magát az operációs rendszert
	    egyszerûen lecserélni alatta.  Bizonyos
	    esetekben azonban elõfordulhat, hogy &os; alatt is
	    találunk hozzá hasonló
	    alkalmazásokat.  Amikor egy stabil irodai vagy
	    internet szerverre van szükségünk, esetleg
	    egy megbízható munkaállomásra,
	    vagy egyszerûen csak megszakítások
	    nélkül szeretnénk végezni a
	    munkánkat, a &os;-ben igényeinkhez
	    mérten szinte minden megtalálhatunk.  A
	    világon rengeteg felhasználó,
	    beleértve a kezdõket és a tapasztalt
	    &unix; rendszergazdákat egyaránt, asztali
	    operációs rendszerként is a &os;-t
	    használja.</para>

	  <para>Ha egy másik &unix; környezetrõl
	    akarunk &os;-re váltani, akkor a legtöbb dolog
	    már ismerõs lehet számunkra.  Amennyiben
	    viszont valamilyen grafikus operációs
	    rendszerrõl, például &windows;-ról
	    vagy a &macos; valamelyik régebbi
	    változatáról szándékozunk
	    átállni, minden bizonnyal idõt kell majd
	    szánnunk a feladatok &unix; stílusú
	    megvalósításának
	    megismerésére.  Ez a GYIK és a <link xlink:href="&url.books.handbook;/index.html">&os;
	    kézikönyv</link> ehhez tökéletes
	    kiindulási alapot biztosít.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="why-called-FreeBSD">
	  <para>Miért hívják &os;-nek?</para>
	</question>

	<answer>
	  <itemizedlist>
	    <listitem>
	      <para>Szabadon (mint <quote>free</quote>)
		felhasználható, akár kereskedelmi
		célokra is.</para>
	    </listitem>

	    <listitem>
	      <para>Az operációs rendszer teljes
		forráskódja bárki által
		szabadon elérhetõ, minimális
		megkötésekkel arra vonatkozóan, hogy
		miként használható és
		más (kereskedelmi vagy nem kereskedelmi)
		munkák részeként miként
		építhetõ be,
		terjeszthetõ.</para>
	    </listitem>

	    <listitem>
	      <para>Bárki, akinek fejlesztési vagy
		hibajavítási javaslata van a rendszerrel
		kapcsolatban, szabadon benyújthatja azt, amely
		aztán bekerül a források
		közé (egy-két
		nyilvánvaló ellenõrzést
		követõen).</para>
	    </listitem>
	  </itemizedlist>

	  <para>Érdemes valamint rámutatni, hogy a
	    <quote>szabad</quote> szót az imént két
	    értelemben is használtuk: az egyik
	    jelentése szerint <quote>költségek
	    nélkül</quote>, míg a másik
	    jelentése szerint <quote>tetszés
	    szerint</quote>.  Egy-két
	    <emphasis>tiltott</emphasis> dologtól,
	    például azt állítjuk, hogy mi
	    írtuk, eltekintve tényleg bármit
	    csinálhatunk vele.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="differences-to-other-bsds">
	  <para>Mi a különbség a &os;, a NetBSD,
	    OpenBSD és a többi nyílt
	    forráskódú BSD operációs
	    rendszerek között?</para>
	</question>

	<answer>
	  <para>James Howard <link xlink:href="http://www.freebsdworld.gr/freebsd/bsd-family-tree.html">The BSD Family Tree</link>
	    címmel (angolul) készített egy alapos
	    leírást a különbözõ
	    projektek közti eltérések
	    bemutatására.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="latest-version">
	  <para>Melyik a &os; legújabb változata?</para>
	</question>

	<answer>
	  <para>Jelen pillanatban a &os; fejlesztése két
	    párhuzamos ágon folyik, és mind a
	    kettõbõl készülnek kiadások.  A
	    7.<replaceable>X</replaceable> sorozat kiadásai a
	    <emphasis>7-STABLE</emphasis> ágból,
	    míg a 8.<replaceable>X</replaceable> sorozat
	    kiadásai a <emphasis>8-STABLE</emphasis>
	    ágból készülnek.</para>

	  <para>A 8.0-s kiadás megjelenéséig a
	    7.<replaceable>X</replaceable> sorozat volt a
	    <emphasis>-STABLE</emphasis>.  A 8.0 kiadás
	    megjelenésével azonban a
	    7.<replaceable>X</replaceable> ág
	    <quote>meghosszabbított
	    támogatást</quote> kapott, és
	    már csak a nagyobb hibákat,
	    például a biztonsági hibákat
	    javítják benne.  Az
	    <emphasis>7-STABLE</emphasis> ágból még
	    várhatóak további kiadások is,
	    azonban ezt jelenleg már
	    <quote>örökségi</quote> ágnak
	    tekintjük, és a legtöbb munka már a
	    <emphasis>8-STABLE</emphasis> részeként
	    jelenik meg.</para>

	  <para>A <link xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/&rel.current;-RELEASE/">&rel.current;</link>
	    változat a <emphasis>8-STABLE</emphasis> ág
	    legfrissebb kiadása, amely &rel.current.date;ban
	    jelent meg.  Az <emphasis>7-STABLE</emphasis>
	    ágból a <link xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/&rel2.current;-RELEASE/">&rel2.current;</link>
	    a legfrissebb kiadás, amely &rel2.current.date;ban
	    jelent meg.</para>

	  <para>Ha röviden össze akarjuk foglalni, akkor a
	    <emphasis>-STABLE</emphasis> változatokat
	    elsõsorban az internet-szolgáltatók,
	    vállalkozások számára
	    ajánljuk, illetve minden olyan
	    felhasználó számára, aki a
	    legújabb (és minden bizonnyal még
	    instabil) <emphasis>-CURRENT</emphasis>
	    pillanatkiadásokhoz viszonyítottan a
	    legkevesebb változtatással
	    kívánnak egy megbízható, stabil
	    verziót használni a rendszerbõl.  Ugyan
	    bármelyik ágból
	    készülhetnek, azonban a
	    <emphasis>-CURRENT</emphasis> esetében
	    meglehetõsen sok változásra kell
	    felkészülnünk (a
	    <emphasis>-STABLE</emphasis> ághoz képest) az
	    egyes kiadások között.</para>

	  <para>A kiadások <link linkend="release-freq">néhány havonta</link>
	    készülnek.  Mivel a legtöbben ennél
	    pontosabban követik a &os; forrásait
	    (lásd a <link linkend="current">&os.current;</link>
	    és <link linkend="stable">&os.stable;</link>
	    változatokra vonatkozó
	    kérdéseket), ennél valamire többre
	    van szükségünk, hiszen a források
	    folyamatosan változnak.</para>

	  <para>A &os; egyes kiadásairól a <link xlink:href="http://www.FreeBSD.org/releng/index.html">Kiadások
	    megjelentetését összefoglaló
	    oldalon</link> tájékozódhatunk a &os;
	    honlapján.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="current">
	  <para>Mi az a <emphasis>&os;-CURRENT</emphasis>?</para>
	</question>

	<answer>
	  <para>A <link xlink:href="&url.books.handbook;/current-stable.html#CURRENT">&os.current;</link>
	    az operációs rendszer aktív
	    fejlesztés alatt álló változata,
	    amely idõvel az új &os.stable;
	    ággá válik.  Ez a változat
	    tulajdonképpen csak a rendszeren dolgozó
	    fejlesztõk és a megátalkodott
	    hobbifelhasználók számára
	    érdekes.  A <link xlink:href="&url.books.handbook;/index.html">kézikönyv</link>
	    <link xlink:href="&url.books.handbook;/current-stable.html#CURRENT">erre vonatkozó szakaszában</link>
	    olvashatunk részletesebben a
	    <emphasis>-CURRENT</emphasis>
	    használatáról.</para>

	  <para>Ha nem mozgunk otthonosan az operációs
	    rendszerek világában, vagy ha nem tudjuk
	    megmondani a különbséget egy valódi
	    és egy ideiglenes probléma között,
	    akkor nem javasoljuk a &os.current;
	    használatát.  Ez a fejlesztési vonal
	    nagyon gyorsan fejlõdik és néha
	    lefordíthatatlan állapotba kerül.  A
	    &os.current; változat
	    használóitól elvárjuk, hogy
	    képesek legyenek felmérni a felbukkanó
	    problémákat, és közülük
	    csak azokat jelenteni, amelyek valóban hibákat
	    takarnak és nem pedig csak apró
	    <quote>bökkenõk</quote>.  Ezért a
	    &a.current; olvasói általában <quote>A
	    make world parancs valami csoportra panaszkodik</quote>
	    típusú kérdéseket
	    általában figyelembe se veszik.</para>

	  <para>A <emphasis>-CURRENT</emphasis> és
	    <emphasis>-STABLE</emphasis> ágak aktuális
	    állapotáról minden hónapban
	    <link xlink:href="&url.base;/snapshots/">pillanatkiadások</link>
	    készülnek.  Célunk ezzel:</para>

	  <itemizedlist>
	    <listitem>
	      <para>A telepítõ legfrissebb
		változatának tesztelése.</para>
	    </listitem>

	    <listitem>
	      <para>Idõt és
		sávszélességet szeretnénk
		megspórolni a <emphasis>-CURRENT</emphasis> vagy
		<emphasis>-STABLE</emphasis> változatok azon
		felhasználóinak, akik az iméntiek
		hiányából fakadóan nem
		tudják naponta frissíteni a
		rendszerüket.</para>
	    </listitem>

	    <listitem>
	      <para>Kiindulási pontokat
		rögzítünk a kód aktuális
		állapota alapján, ha késõbb
		netalán valamilyen szörnyûség
		történne.  (Noha a CVS
		általában védelmet nyújt az
		ilyen rémisztõ dolgok
		bekövetkezése ellen.)</para>
	    </listitem>

	    <listitem>
	      <para>Az összes tesztelendõ
		újítást és
		javítást ezen a módon
		kívánjuk a lehetõ legszélesebb
		körben elérhetõvé tenni.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Egyik <emphasis>-CURRENT</emphasis>
	    pillanatkiadás sem tekinthetõ
	    <quote>hétköznapi felhasználásra
	    alkalmasnak</quote>.  Ha egy megbízható
	    és széles körben tesztelt rendszerre van
	    szükségünk, akkor vagy maradjunk a
	    kiadásoknál vagy használjuk a
	    <emphasis>-STABLE</emphasis> vonalból
	    készült pillanatkiadásokat.</para>

	  <para>A pillanatkiadások <link xlink:href="&url.base;/snapshots/">innen</link>
	    érhetõek el.</para>

	  <para>Minden aktívan fejlesztett ághoz havonta
	    készülnek hivatalos pillanatkiadások.  A
	    népszerûbb &arch.i386; és &arch.amd64;
	    ágakból azonban napi kiadások is
	    elérhetõek a <uri xlink:href="http://snapshots.us.freebsd.org">http://snapshots.us.freebsd.org</uri> a
	    címen.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="stable">
	  <para>Mit takar a <emphasis>&os;-STABLE</emphasis>?</para>
	</question>

	<answer>
	  <para>Amikor a &os;&nbsp;2.0.5 megjelent, a &os;
	    fejlesztése kettévált.  Az egyik
	    ág neve <link xlink:href="&url.books.handbook;/current-stable.html#STABLE">-STABLE</link>,
	    a másiké pedig <link xlink:href="&url.books.handbook;/current-stable.html#CURRENT">-CURRENT</link>
	    lett.  A <emphasis>&os;-STABLE</emphasis> az olyan
	    internet-szolgáltatók és egyéb
	    vállalkozások számára
	    készült, ahol a fejlesztés alatt
	    álló újítások vagy a
	    hirtelen váltások által okozott
	    problémák gyakran nem engedhetõek meg.
	    Ide csak olyan hibajavítások és kisebb
	    módosítások kerülnek, amelyeket
	    alaposan leteszteltek.  A <emphasis>&os;-CURRENT</emphasis>
	    ezzel szemben a 2.0 megjelenése óta egyetlen,
	    szakadásmentes fejlesztési vonalat
	    képvisel, amely a &rel.current;-RELEASE és az
	    azon túli kiadások felé halad.  Ha
	    többet szeretnénk megtudni a jelenlegi
	    ágak állapotáról és a
	    következõ kiadások
	    ütemezésérõl, akkor ezzel
	    kapcsolatban olvassuk el a <link xlink:href="&url.articles.releng.en;/release-proc.html#REL-BRANCH">&os; Release Engineering</link>
	    címû cikk kiadások
	    leágaztatásáról
	    szóló részét (angolul).  Az
	    ágak jelenlegi állapota és a
	    jövõbeni kiadások ütemterve a <link xlink:href="&enbase;/releng">Kiadások információk oldalán</link>
	    található (angolul).</para>

	  <para>A 2.2-STABLE ág a 2.2.8
	    megjelenésével nyugdíjba vonult.  A
	    3-STABLE ág a 3.5.1 mint az utolsó 3.<replaceable>X</replaceable>
	    kiadás megjelenésével ért
	    véget.  A 4-STABLE ág a 4.11 mint az
	    utolsó 4.<replaceable>X</replaceable> kiadással fejezõdött be.
	    Ezekbe az ágakban a legtöbb esetben már
	    csak biztonsági javításokat
	    végeznek.  Az 5-STABLE ág fejlesztése
	    az utolsó 5.<replaceable>X</replaceable>
	    kiadás, az 5.5 megjelenésével
	    lezárult.  A 6-STABLE ág fejlesztése
	    még folytatódik valameddig, de ez alatt
	    leginkább már csak a biztonsági
	    rések és egyéb komoly
	    problémák javításait kell
	    érteni.</para>

	  <para>A &rel.current;-STABLE a jelenleg fejlesztett
	    <emphasis>-STABLE</emphasis> ág.  A
	    &rel.current;-STABLE ágból megjelent
	    legfrissebb kiadás a &rel.current;-RELEASE, amely
	    &rel.current.date;ban jelent meg.</para>

	  <para>A 9-CURRENT a <emphasis>-CURRENT</emphasis> ág
	    legfrissebb változata, és ez a &os;
	    következõ generációja.  Errõl
	    az ágról a <link linkend="current">Mi az a &os;-CURRENT?</link>
	    kérdésnél szolgálunk
	    részletesebb információkkal.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="release-freq">
	  <para>Mikor készülnek &os; kiadások?</para>
	</question>

	<answer>
	  <para>A &a.re; átlagosan a &os; egy újabb
	    nagyobb változatát 18 havonta, míg egy
	    kisebb kiadását 8 havonta jelenteti meg.  A
	    kiadások dátumát elõre kihirdetik,
	    így a rendszeren dolgozó emberek pontosan
	    tudják, hogy mikorra kell befejezniük a
	    munkájukat és letesztelni azt.  Minden
	    kiadást egy tesztelési idõszak elõz
	    meg, ahol megbizonyosodnak róla, hogy az
	    elkészült újítások nem
	    veszélyeztetik az új kiadás
	    megbízhatóságát.  A legtöbb
	    felhasználó pontosan ezt a
	    típusú elõvigyázatosságot
	    szereti legjobban a &os;-ben, még annak
	    árán is, hogy a legújabb
	    finomságok bekerülésére még
	    a <emphasis>-STABLE</emphasis> ág esetén
	    gyakran sokat kell várni.</para>

	  <para>A kiadások szerkesztésérõl
	    (valamint a soronkövetkezõ kiadások
	    ütemezésérõl) a &os;
	    honlapján belül <link xlink:href="http://www.FreeBSD.org/releng/index.html">ezen</link>
	    az oldalon olvashatunk részletesebben
	    (angolul).</para>

	  <para>Akik egy kicsivel több izgalomra vágynak,
	    azok részére az elõbb említett,
	    naponta készített bináris
	    pillanatkiadásokat ajánljuk.</para>
	 </answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="responsible">
	  <para>Ki felel a &os;-ért?</para>
	</question>

	<answer>
	  <para>A &os; Projektre vonatkozó fontosabb
	    döntéseket, mint például a Projekt
	    haladási irányát vagy hogy vehet
	    részt a forráskód
	    fejlesztésében, egy 9 fõs <link xlink:href="&url.base.hu;/administration.html#t-core">irányító
	    csoport</link> hozza.  Rajtuk kívül még
	    egy több mint 350 fõs <link xlink:href="&url.articles.contributors.en;/article.html#STAFF-COMMITTERS">
	    fejlesztõi csapat</link> jogosult
	    közvetlenül módosítani a &os;
	    forrásait.</para>

	  <para>A legtöbb bonyolultabb változtatást
	    általában azonban a megfelelõ <link linkend="mailing">levelezési listákon</link>
	    is megvitatják, amiben bárki
	    különösebb korlátozás
	    nélkül részt vehet.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="where-get">
	  <para>Honnan lehet a &os;-t beszerezni?</para>
	</question>

	<answer>
	  <para>A &os; összes fontosabb kiadása
	    elérhetõ anonim FTP-n keresztül a <link xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/">&os; FTP
	    oldaláról</link>:</para>

	  <itemizedlist>
	    <listitem>
	      <para>A legfrissebb 8-STABLE kiadás, a
		&rel.current;-RELEASE <link xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/&rel.current;-RELEASE/">ebbõl</link>
		a könyvtárból érhetõ
		el.</para>
	    </listitem>

	    <listitem>
	      <para>Havonta készülnek <link xlink:href="&url.base;/snapshots/">pillanatkiadások</link>
		a <link linkend="current">-CURRENT</link> és a
		<link linkend="stable">-STABLE</link>
		ágakból, de ezek leginkább a
		legújabb változatot tesztelõk
		és a fejlesztõk számára
		fontosak.</para>
	    </listitem>

	    <listitem>
	      <para>A legfrissebb 7-STABLE kiadás, a
		&rel2.current;-RELEASE <link xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/&rel2.current;-RELEASE/">ebbõl</link>
		a könyvtárból érhetõ
		el.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Ha a &os;-t CD-n, DVD-n vagy más egyéb
	    telepítõeszközön szeretnénk
	    megkapni, akkor ezzel kapcsolatban nézzük meg
	    <link xlink:href="&url.books.handbook;/mirrors.html">a
	    kézikönyvet</link>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="access-pr">
	  <para>Hogyan lehet elérni a hibajelentések
	    adatbázisát?</para>
	</question>

	<answer>
	  <para>A felhasználók kéréseit
	    tartalmazó hibajelentések
	    adatbázisát a honlap webes
	    hibajelentésekkel foglalkozó <link xlink:href="http://www.FreeBSD.org/cgi/query-pr.cgi?query">felületén</link>
	    keresztül érhetjük el.</para>

	  <para>A &man.send-pr.1; parancs
	    segítségével tudunk e-mailen
	    keresztül hibajelentéseket és
	    egyéb változtatási
	    kéréseket küldeni.  Emellett még
	    böngészõ segítségével
	    is tudunk hibajelentéseket küldeni a honlap
	    <link xlink:href="http://www.freebsd.org/send-pr.html">webes
	    hibabejelentõ felületén</link>.</para>

	  <para>Mielõtt beküldenénk egy
	    hibajelentést, olvassuk el a <link xlink:href="&url.articles.problem-reports.en;/article.html">Writing
	    &os; Problem Reports</link> címû cikket
	    (angolul), amelybõl megtudhatjuk, hogyan
	    készítsünk jól
	    hasznosítható hibajelentéseket.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="other-info-sources">
	  <para>Honnan tudhatunk meg még többet?</para>
	</question>

	<answer>
	  <para>Nézzük meg a <link xlink:href="http://www.FreeBSD.org">&os;</link> Projekt
	    honlapjáról elérhetõ <link xlink:href="http://www.FreeBSD.org/docs.html">dokumentációkat</link>.
	    </para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter xml:id="support" xml:lang="hu">
    <title>Dokumentációs és
      támogatás</title>

    <qandaset>
      <qandaentry>
	<question xml:id="books">
	  <para>Milyen jó könyvek szólnak a
	    &os;-rõl?</para>
	</question>

	<answer>
	  <para>A Projekt igen széles körû
	    dokumentációval rendelkezik, amely a
	    következõ linkrõl érhetõ el:
	    <uri xlink:href="http://www.FreeBSD.org/docs.html">http://www.FreeBSD.org/docs.html</uri>.
	    Emellett a GYIK <link linkend="bibliography">végén szereplõ</link>,
	    valamint a kézikönyvben található
	    <link xlink:href="&url.books.handbook;/bibliography.html">irodalomjegyzék</link>
	    tartalmazza az ajánlott könyveket.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="doc-formats">
	  <para>A dokumentáció elérhetõ
	    más formátumokban is, például
	    szöveges (ASCII) állományban vagy
	    &postscript;-ben?</para>
	</question>

	<answer>
	  <para>Igen.  A dokumentáció több
	  különbözõ állomány-
	    és tömörítési
	    formátumban elérhetõ az &os; FTP
	    oldalán belül a <link xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">/pub/FreeBSD/doc/</link>
	    könyvtárból.</para>

	  <para>A dokumentációt több
	    különbözõ módon
	    osztályozhatjuk.  Többek közt:</para>

	  <itemizedlist>
	    <listitem>
	      <para>A dokumentum neve alapján,
		például <literal>faq</literal> (GYIK), vagy
		<literal>handbook</literal>
		(kézikönyv).</para>
	    </listitem>

	    <listitem>
	      <para>A dokumentum nyelv és
		karakterkódolása alapján.  Ezeket a
		&os; rendszerekben, a
		<filename>/usr/share/locale</filename>
		könyvtárban megtalálható
		nyelvi beállítások nevei szerint
		adjuk meg.  Jelenleg a következõ nyelveken
		és kódolásokban érhetõ
		el a dokumentáció:</para>

	      <informaltable frame="none" pgwide="1">
		<tgroup cols="2">
		  <thead>
		    <row>
		      <entry>Név</entry>
		      <entry>Leírás</entry>
		    </row>
		  </thead>

		  <tbody>
		    <row>
		      <entry><literal>en_US.ISO8859-1</literal></entry>
		      <entry>Angol (Egyesült
			Államok)</entry>
		    </row>

		    <row>
		      <entry><literal>bn_BD.ISO10646-1</literal></entry>
		      <entry>Bengáli vagy bangla
			(Banglades)</entry>
		    </row>

		    <row>
		      <entry><literal>da_DK.ISO8859-1</literal></entry>
		      <entry>Dán (Dánia)</entry>
		    </row>

		    <row>
		      <entry><literal>de_DE.ISO8859-1</literal></entry>
		      <entry>Német
			(Németország)</entry>
		    </row>

		    <row>
		      <entry><literal>el_GR.ISO8859-7</literal></entry>
		      <entry>Görög
			(Görögország)</entry>
		    </row>

		    <row>
		      <entry><literal>es_ES.ISO8859-1</literal></entry>
		      <entry>Spanyol (Spanyolország)</entry>
		    </row>

		    <row>
		      <entry><literal>fr_FR.ISO8859-1</literal></entry>
		      <entry>Francia (Franciaország)</entry>
		    </row>

		    <row>
		      <entry><literal>hu_HU.ISO8859-2</literal></entry>
		      <entry>Magyar (Magyarország)</entry>
		    </row>

		    <row>
		      <entry><literal>it_IT.ISO8859-15</literal></entry>
		      <entry>Olasz (Olaszország)</entry>
		    </row>

		    <row>
		      <entry><literal>ja_JP.eucJP</literal></entry>
		      <entry>Japán (Japán, EUC
			kódolás)</entry>
		    </row>

		    <row>
		      <entry><literal>mn_MN.UTF-8</literal></entry>
		      <entry>Mongol (Mongólia, UTF-8
			kódolás)</entry>
		    </row>

		    <row>
		      <entry><literal>nl_NL.ISO8859-1</literal></entry>
		      <entry>Holland (Hollandia)</entry>
		    </row>

		    <row>
		      <entry><literal>no_NO.ISO8859-1</literal></entry>
		      <entry>Norvég (Norvégia)</entry>
		    </row>

		    <row>
		      <entry><literal>pl_PL.ISO8859-2</literal></entry>
		      <entry>Lengyel (Lengyelország)</entry>
		    </row>

		    <row>
		      <entry><literal>pt_BR.ISO8859-1</literal></entry>
		      <entry>Portugál (Brazília)</entry>
		    </row>

		    <row>
		      <entry><literal>ru_RU.KOI8-R</literal></entry>
		      <entry>Orosz (Oroszország, KOI8-R
			kódolás)</entry>
		    </row>

		    <row>
		      <entry><literal>sr_YU.ISO8859-2</literal></entry>
		      <entry>Szerb (Szerbia)</entry>
		    </row>

		    <row>
		      <entry><literal>tr_TR.ISO8859-9</literal></entry>
		      <entry>Török
			(Törökország)</entry>
		    </row>

		    <row>
		      <entry><literal>zh_CN.GB2312</literal></entry>
		      <entry>Egyszerûsített kínai
			(Kína, GB2312
			kódolás)</entry>
		    </row>

		    <row>
		      <entry><literal>zh_TW.Big5</literal></entry>
		      <entry>Hagyományos kínai (Tajvan,
			Big5 kódolás)</entry>
		    </row>
		  </tbody>
		</tgroup>
	      </informaltable>

	      <note>
		<para>Nem mindegyik dokumentum érthetõ el
		  mindegyik nyelven.</para>
	      </note>
	    </listitem>

	    <listitem>
	      <para>A dokumentum formátuma alapján.  A
		dokumentumok több különbözõ
		formátumban állnak rendelkezésre.
		Mindegyik formátum használatának
		megvannak az elõnyei és
		hátrányai.  Egyes formátumok
		inkább az interneten keresztüli
		olvasgatásra megfelelõek, mások pedig
		nyomtatott formában nyújtanak
		esztétikus hatást.  A több
		különbözõ formátumnak
		köszönhetõen az olvasók
		igényeik szerint el tudják olvasni a
		dokumentáció különbözõ
		részeit akár a képernyõn,
		akár papíron.  Jelenleg a
		következõ formátumokban
		érhetõek el a dokumentumok:</para>

	      <informaltable frame="none" pgwide="1">
		<tgroup cols="2">
		  <thead>
		    <row>
		      <entry>Formátum</entry>
		      <entry>Leírás</entry>
		    </row>
		  </thead>

		  <tbody>
		    <row>
		      <entry><literal>html-split</literal></entry>
		      <entry>Kis méretû,
			hiperhivatkozásokkal ellátott HTML
			állományok
			gyûjteménye</entry>
		    </row>

		    <row>
		      <entry><literal>html</literal></entry>
		      <entry>Egyetlen óriási, az
			egész dokumentumot tartalmazó HTML
			állomány</entry>
		    </row>

		    <row>
		      <entry><literal>pdf</literal></entry>
		      <entry>Az Adobe-féle Portable Document
			Format</entry>
		    </row>

		    <row>
		      <entry><literal>ps</literal></entry>
		      <entry>&postscript;</entry>
		    </row>

		    <row>
		      <entry><literal>rtf</literal></entry>
		      <entry>A Microsoft Rich Text
			formátuma</entry>
		    </row>

		    <row>
		      <entry><literal>txt</literal></entry>
		      <entry>Egyszerû szöveges
			állomány</entry>
		    </row>
		  </tbody>
		</tgroup>
	      </informaltable>

	      <note>
		<para>Amikor egy ilyen dokumentumot betöltünk
		  a Wordbe, akkor az oldalszámok maguktól
		  nem frissülnek.  Ehhez a dokumentum
		  betöltése után nyomjuk le a
		  <keycombo action="simul"><keycap>Ctrl</keycap><keycap>A</keycap></keycombo>,
		  <keycombo action="simul"><keycap>Ctrl</keycap><keycap>End</keycap></keycombo>,
		  <keycap>F9</keycap> billentyûket.</para>
	      </note>
	    </listitem>

	    <listitem>
	      <para>A tömörítés és
		csomagolás típusa alapján.  Ezek
		közül jelenleg hármat
		használunk.</para>

	      <orderedlist>
		<listitem>
		  <para>Ahol a formátum
		    <literal>html-split</literal>, ott az
		    állományokat a &man.tar.1;
		    segítségével csomagoltuk
		    össze.  Az így keletkezõ
		    <filename>.tar</filename> állományt
		    ezek után az alábbi részben
		    szereplõ tömörítési
		    megoldásokkal
		    tömörítettük.</para>
		</listitem>

		<listitem>
		  <para>Az összes többi formátum
		    esetén csak egyetlen állomány
		    keletkezik, amelynek a neve
		    <filename>típus.formátum</filename>
		    (tehát például
		    <filename>article.pdf</filename>,
		    <filename>book.html</filename> és így
		    tovább).</para>

		  <para>Ezeket az állományokat
		    azután két
		    tömörítési
		    eljárással
		    tömörítjük.</para>

		  <informaltable frame="none" pgwide="1">
		    <tgroup cols="2">
		      <thead>
			<row>
			  <entry>Eljárás</entry>
			  <entry>Leírás</entry>
			</row>
		      </thead>

		      <tbody>
			<row>
			  <entry><literal>zip</literal></entry>
			  <entry>A <literal>zip</literal>
			    formátum.  &os; alatt ezt úgy
			    tudjuk kitömöríteni, ha
			    elõször telepítjük a
			    <package>archivers/unzip</package>
			    portot.</entry>
			</row>

			<row>
			  <entry><literal>bz2</literal></entry>
			  <entry>A <literal>bzip2</literal>
			    formátum.  Nem olyan elterjedt, mint a
			    <literal>zip</literal>, de
			    általában kisebb
			    méretû
			    állományokat
			    készít.  Ilyen
			    állományokat akkor tudunk
			    kitömöríteni, ha
			    telepítjük a <package>archivers/bzip2</package>
			    portot.</entry>
			</row>
		      </tbody>
		    </tgroup>
		  </informaltable>

		  <para>Ennek megfelelõen tehát a
		    kézikönyv <literal>bzip2</literal>-vel
		    tömörített &postscript;
		    változata a <filename>handbook/</filename>
		    könyvtáron belül
		    <filename>book.ps.bz2</filename> néven
		    található.</para>
		</listitem>
	      </orderedlist>
	    </listitem>
	  </itemizedlist>

	  <para>Miután kiválasztottuk a számunkra
	    megfelelõ letöltendõ formátumot
	    és tömörítési
	    módszert, magunknak kell letölteni a
	    kiválasztott tömörített
	    állományokat, majd kibontani ezeket és
	    átmásolni a megfelelõ helyre.</para>

	  <para>Például, ha a GYIK fejezetekre darabolt,
	    &man.bzip2.1; segítségével
	    tömörített változata a
	    <filename>doc/en_US.ISO8859-1/books/faq/book.html-split.tar.bz2</filename>
	    állományban található meg.  A
	    letöltéséhez és
	    kibontásához a következõket kell
	    tennünk:</para>

	  <screen>&prompt.root; <userinput>fetch ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/en_US.ISO8859-1/books/faq/book.html-split.tar.bz2</userinput>
&prompt.root; <userinput>bzip2 -d book.html-split.tar.bz2</userinput>
&prompt.root; <userinput>tar xvf book.html-split.tar</userinput></screen>

	  <para>A mûvelet befejezõdésével kapunk
	    néhány <filename>.html</filename>
	    kiterjesztésû állományt.  Ezek
	    közül az egyik neve
	    <filename>index.html</filename>, ebben
	    található a tartalomjegyzék, a
	    bevezetés és a dokumentum többi
	    részére mutató hivatkozások.
	    Ezeket az állományokat kell
	    szükség szerint átmásolnunk vagy
	    átmozgatnunk a megfelelõ helyre.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="mailing">
	  <para>Hol található információ a
	    &os; levelezési listáiról?</para>
	</question>

	<answer>
	  <para>Az összes velük kapcsolatos
	    információt a <link xlink:href="&url.books.handbook;/eresources.html#ERESOURCES-MAIL">kézikönyv
	    levelezési listákról
	    szóló részében</link>
	    találjuk.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="newsgroups">
	  <para>Milyen &os; hírcsoportok léteznek?</para>
	</question>

	<answer>
	  <para>Az összes rájuk vonatkozó
	    információt a <link xlink:href="&url.books.handbook;/eresources-news.html">kézikönyv
	    hírcsoportokról szóló
	    részében</link> találjuk meg.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="irc">
	  <para>Vannak &os;-s IRC (Internet Relay Chat)
	    csatornák?</para>
	</question>

	<answer>
	  <para>Igen, a legtöbb nagyobb IRC hálózaton
	    található &os;-vel foglalkozó
	    csatorna:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Az <link xlink:href="http://www.efnet.org/index.php">EFNet</link>
		hálózaton található
		<literal>#FreeBSD</literal> csatorna
		lényegében egy &os;-vel foglalkozó
		fórum, de itt ne nagyon
		próbálkozzunk segítséget
		kérni a többiektõl, ha netalán
		lusták lennénk elolvasni a man oldalakat
		vagy éppen kutatunk valamit.  Ez a hely
		elsõsorban csevegésre szolgál, ahol
		mindenféle téma felmerül, a
		szextõl kezdve a sportokon keresztül a
		nukleáris fegyverekig éppen úgy,
		ahogy a &os;-rõl is.  Mi szóltunk
		elõre!  A szerver a <systemitem>irc.efnet.org</systemitem>
		címen érhetõ el.</para>
	    </listitem>

	    <listitem>
	      <para>Az <link xlink:href="http://www.efnet.org/index.php">EFNet</link>
		hálózaton található
		<literal>#FreeBSDhelp</literal> csatorna kifejezetten a
		&os; felhasználók
		megsegítését veszi célba.
		Az itt levõk sokkal szívesebben
		válaszolnak a kérdéseinkre, mint a
		<literal>#FreeBSD</literal> csatornán.</para>
	    </listitem>

	    <listitem>
	      <para>A <link xlink:href="http://freenode.net/">Freenode</link>
		hálózaton található
		<literal>##FreeBSD</literal> csatornán mindig
		sokan vannak, itt bármilyen
		témában kérhetünk
		segítséget.  A beszélgetések
		idõnként ugyan kifutnak a szigorú
		szakmai témákból, de a &os;-vel
		kapcsolatos kérdések itt mindig
		elsõbbséget élveznek.
		Szívesen segítünk bárkinek,
		és lehetõség szerint igyekszünk
		a kézikönyv megfelelõ részeire
		hivatkozni, vagy adni valamilyen
		útmutatást arra vonatkozóan, hogy
		merre tájékozódhatunk
		részletesebben a problémánkkal
		kapcsolatban.  Ez alapvetõen egy angol nyelvû
		csatorna, habár a világ minden
		tájáról érkeznek tagjaink.
		Ha az anyanyelvünkön szeretnénk
		inkább csevegni, akkor elõször
		tegyük fel a kérdésünket
		angolul, aztán próbálkozzunk a
		megfelelõ
		<literal>##freebsd-nyelv</literal>
		csatornán.</para>
	    </listitem>

	    <listitem>
	      <para>A <link xlink:href="http://www.dal.net/">DALNET</link>
		hálózaton található
		<literal>#FreeBSD</literal> csatorna az Egyesült
		Államokból a <systemitem>irc.dal.net</systemitem>
		szerveren, Európából pedig az
		<systemitem>irc.eu.dal.net</systemitem> szerveren keresztül
		érhetõ el.</para>
	    </listitem>

	    <listitem>
	      <para>A <link xlink:href="http://www.dal.net/">DALNET</link>
		hálózaton található
		<literal>#FreeBSDHelp</literal> csatorna az
		Egyesült Államokból a
		<systemitem>irc.dal.net</systemitem> szerveren,
		Európából pedig a
		<systemitem>irc.eu.dal.net</systemitem> szerveren keresztül
		érhetõ el.</para>
	    </listitem>

	    <listitem>
	      <para>Az <link xlink:href="http://www.undernet.org/">UNDERNET</link>
		hálózaton található
		<literal>#FreeBSD</literal> csatorna az Egyesült
		Államokból a
		<systemitem>us.undernet.org</systemitem>,
		Európából pedig a
		<systemitem>eu.undernet.org</systemitem> szerveren
		keresztül érhetõ el.  Mivel ez a
		csatornát leginkább
		segítségnyújtásra tartjuk
		fenn, készüljünk fel arra, hogy a
		hivatkozott dokumentumokat is el kell olvasnunk.</para>
	    </listitem>

	    <listitem>
	      <para>A <link xlink:href="http://www.rusnet.org.ru/">RUSNET</link>
		hálózaton található
		<literal>#FreeBSD</literal> csatorna az oroszul
		beszélõ &os; felhasználók
		számára igyekszik segítséget
		nyújtani.  Emellett viszont remek hely a nem
		szakmai jellegû témák
		megvitatásához is.</para>
	    </listitem>

	    <listitem>
	      <para>A <link xlink:href="http://freenode.net/">Freenode</link>
		hálózaton található
		<literal>#bsdchat</literal> csatorna a
		hagyományos kínai (UTF-8
		kódolású) nyelvet
		beszélõ &os; felhasználókat
		igyekszik segíteni.  A nem szakmai jellegû
		témák részére is egy remek
		hely.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Az említett csatornák mindegyike
	    egymástól független, és nem
	    állnak egymással kapcsolatban.  Sõt,
	    még a csevegési stílusuk is
	    eltérõ, ezért érdemes a
	    saját stílusunkhoz leginkább
	    illeszkedõt megkeresni.  Mint ahogy az
	    <emphasis>összes</emphasis> IRC csatorna
	    esetében elõfordul, itt is könnyedén
	    érhetnek bennünket személyes
	    sértések vagy egyszerûen csak sok
	    szóbeli sárdobálást
	    láthatunk (mivel jóval több az ilyen
	    helyeken a balga ifjú, mint a higgadtabb idõs)
	    &mdash; ezekkel ne is törõdjünk!</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="training">
	  <para>Hol kaphatok kereskedelmi szintû &os;
	    tréninget és támogatást?</para>
	</question>

	<answer>
	  <para>A &os; Mall is nyújt keresdelmi
	    támogatást a &os;-hez.  Errõl a <link xlink:href="http://www.freebsdmall.com/cgi-bin/fm">honlapjunkon</link>
	    tudhatunk meg többet.</para>

	  <para>A BSD Certification Group, Inc. DragonFly&nbsp;BSD,
	    &os;, NetBSD és OpenBSD rendszerekhez ad
	    rendszergazdai képesítéseket.
	    Amennyiben érdekel minket, látogassunk el a
	    <link xlink:href="http://www.BSDCertification.org">honlapjukra</link>.
	    </para>

	  <para>Kérünk minden olyan további
	    szervezetet, amely tréninget vagy
	    támogatást kíván nyújtani
	    a Projektnek, hogy jelentkezzenek és felvesszük
	    õket a listánkra!</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter xml:id="install" xml:lang="hu">
    <info><title>Telepítés</title>
      <author><personname><firstname>Nik</firstname><surname>Clayton</surname></personname><affiliation>
	  <address><email>nik@FreeBSD.org</email></address>
	</affiliation></author>
    </info>

    

    <qandaset>
      <qandaentry>
	<question xml:id="floppy-download">
	  <para>Milyen állományokat kell
	    letöltenünk a &os;
	    telepítéséhez?</para>
	</question>

	<answer>
	  <para>Ehhez a következõ három floppy image-re
	    lesz alapvetõen szükségünk:
	    <filename>floppies/boot.flp</filename>,
	    <filename>floppies/kern1.flp</filename> és
	    <filename>floppies/kern2.flp</filename>.  Ezeket az
	    image-eket az <command>fdimage</command> vagy &man.dd.1;
	    segédprogramokkal kell rámásolnunk
	    lemezekre.</para>

	  <para>Ha magukat a terjesztéseket akarjuk
	    letölteni (mert például egy DOS
	    típusú állományrendszerrõl
	    akarunk telepíteni), akkor az alábbi
	    terjesztéseket kell beszereznünk:</para>

	  <itemizedlist>
	    <listitem>
	      <para>base/</para>
	    </listitem>

	    <listitem>
	      <para>manpages/</para>
	    </listitem>

	    <listitem>
	      <para>compat*/</para>
	    </listitem>

	    <listitem>
	      <para>doc/</para>
	    </listitem>

	    <listitem>
	      <para>src/ssys.*</para>
	    </listitem>
	  </itemizedlist>

	  <para>A teljes folyamatot, valamint a
	    telepítéssel kapcsolatos általános
	    tudnivalókat valamivel bõvebben a <link xlink:href="&url.books.handbook;/install.html">kézikönyv
	    &os; telepítésével foglalkozó
	    részébõl</link> ismerhetjük
	    meg.</para>

	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="floppy-image-too-large">
	  <para>Mit tegyünk, ha a floppy image-ek nem férnek
	    rá egyetlen lemezre?</para>
	</question>

	<answer>
	  <para>Egy 3,5&nbsp;colos (1,44&nbsp;MB
	    kapacitású) lemezen
	    1&nbsp;474&nbsp;560&nbsp;byte-nyi adat fér el.  A
	    rendszerindításhoz használt image
	    mérete is pontosan
	    1&nbsp;474&nbsp;560&nbsp;byte.</para>

	  <para>A rendszerindító lemezek
	    elõkészítése során
	    elkövetett hibák általában a
	    következõk:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Amikor az image-eket FTP-n keresztül
		töltjük le, elfelejtünk
		<emphasis>bináris</emphasis> (binary)
		átviteli módot használni.</para>

	      <para>Egyes FTP kliensek alapértelmezés
		szerint <emphasis>szöveges</emphasis> (ascii)
		módban viszik át az
		állományokat, és ennek során
		megpróbálják a sorvége
		karaktereket az adott operációs rendszer
		konvenciói szerint átalakítani.
		Ilyenkor szinte kétségtelen, hogy ezzel
		tönkreteszik az image-et.  Ezért ne
		felejtsük el ellenõrizni a letöltött
		image-eket: ha a méretük nem egyezik meg
		<emphasis>pontosan</emphasis> a szerveren levõ
		változatukéval, akkor
		gyaníthatóan a letöltés
		közben történt velük
		valami.</para>

	      <para>Megoldás: miután csatlakoztunk a
		szerverhez, de még mielõtt elkezdük volna
		a letöltést, az FTP kliens
		parancssorában gépeljük be, hogy
		<emphasis>binary</emphasis>.</para>
	    </listitem>

	    <listitem>
	      <para>Az image lemezre másolása a DOS
		<command>copy</command> parancsának (vagy
		hasonló grafikus eszközök)
		használatával.</para>

	      <para>A <command>copy</command> és a hozzá
		hasonló programok nem használhatóak
		erre a célra, mivel az image-eket
		közvetlenül a rendszeindításhoz
		hozták létre.  Ennek megfelelõen az
		egyes image-ek a lemezek teljes tartalmát
		sávról sávra tartalmazzák,
		és így nem hétköznapi
		állományként kell velük
		bánni.  Ezeket a floppykra alacsonyszintû
		eszközök (például az
		<command>fdimage</command> vagy
		<command>rawrite</command>)
		segítségével, <quote>nyers</quote>
		módban kell felvinni, ahogy azt a <link xlink:href="&url.books.handbook;/install.html">&os;
		telepítését leíró
		útmutatóban</link> is olvashatjuk.</para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="install-instructions-location">
	  <para>Hol található leírás a &os;
	    telepítésérõl?</para>
	</question>

	<answer>
	  <para>A telepítés részletes
	    leírása a <link xlink:href="&url.books.handbook;/install.html">kézikönyv &os; telepítésérõl szóló részében</link>
	    olvasható.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="need-to-run">
	  <para>Mire van szükség a &os;
	    használatához?</para>
	</question>

	<answer>
	  <para>A &os; használatához egy 486-os vagy jobb
	    processzorral rendelkezõ
	    számítógépre, 24&nbsp;MB vagy
	    annál több memóriára, és
	    legalább 150&nbsp;MB tárhelyre lesz
	    szükségünk.</para>

	  <para>A &os; összes változata képes futni
	    szinte bármilyen olcsó MDA típusú
	    grafikus kártyával, de az &xorg;
	    használatához már VGA vagy annál
	    jobb videokártya szükségeltetik.</para>

	  <para>Lásd <xref linkend="hardware"/>.</para>

	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="custom-boot-floppy">
	  <para>Hogyan lehet saját telepítõfloppyt
	    készíteni?</para>
	</question>

	<answer>
	  <para>Jelen pillanatban ennek nincs
	    <emphasis>egyszerû</emphasis> módja.  Minden
	    egyes kiadáshoz tartoznak
	    telepítõfloppyk, használjuk
	    ezeket.</para>

	  <para>Ha egy módosított kiadást akarunk
	    készíteni, kövessük a(z angol
	    nyelvû) <link xlink:href="&url.articles.releng.en;/article.html">Release Engineering</link>
	    cikk útmutatásait.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="windows-coexist">
	  <para>&windows; mellé is telepíhetõ
	    &os;?</para>
	</question>

	<answer>
	  <para>Elõször telepítsük a &windows;t,
	    majd a &os;-t.  A &os; boot managere ekkor képes lesz
	    a &windows; és a &os; indítására
	    is.  Vigyázzunk, mert ha a &windows;t
	    telepítjük fel másodikként, akkor
	    az minden figyelmeztetés nélkül
	    durván felülírja az aktuális boot
	    managert.  Ha ezt tapasztaljuk, akkor olvassuk el a
	    következõ szakaszt.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="win95-damaged-boot-manager">
	  <para>A &windows; letörölte a boot managert!  Hogyan
	    lehet visszaállítani?</para>
	</question>

	<answer>
	  <para>A &os;-hez tartozó boot managert
	    háromféleképpen tudjuk
	    újratelepíteni:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Indítsuk el a DOS-t, lépjünk be a
		&os; terjesztéshez tartozó <filename>tools</filename>
		könyvtárba és keressük meg a
		<filename>bootinst.exe</filename> nevû
		állományt.  Indítsuk el a
		következõ módon:</para>

	      <screen><prompt>...\TOOLS&gt;</prompt> <userinput>bootinst.exe boot.bin</userinput></screen>

	      <para>Ekkor a boot manager visszakerül a
		helyére.</para>
	    </listitem>

	    <listitem>
	      <para>Használjuk a &os;-hez létrehozott
		rendszerindító lemezeket, és a
		telepítõben válasszuk a
		<guimenuitem>Custom</guimenuitem> (Egyéni
		telepítés) menüpontot, majd azon
		belül válasszuk a
		<guimenuitem>Partition</guimenuitem>
		(Partíció) pontot.  Itt válasszuk
		ki azt a meghajtót, ahol korábban a boot
		managerünk volt (ez valószínûleg
		a felsorolásban az elsõ lesz) és
		amikor belépünk a
		partíciószerkesztõbe, akkor
		egybõl válasszuk a <literal>Write</literal>
		(<keycap>W</keycap>) opciót (tehát ne
		változtassunk semmit).  Ez
		megerõsítést fog kérni, amire
		válasszuk a &gui.yes; gombot, és amikor a
		boot manager kiválasztása rész
		jelenik meg, válasszuk a <application>FreeBSD
		Boot Manager</application> pontot.  Ezzel a boot manager
		újra a lemezre íródik.
		Miután ezzel végeztünk,
		lépjünk ki a telepítõbõl
		és indítsuk újra a
		rendszerünket a megszokott módon.</para>
	    </listitem>

	    <listitem>
	      <para>Indítsuk a rendszerünket a &os;
		rendszerindító lemezérõl (vagy
		CD-jérõl), majd válasszuk a
		telepítõben a
		<guimenuitem>Fixit</guimenuitem> (Javítás)
		menüpontot.  Ezután válasszuk a
		javítófloppy vagy a(z
		<quote>élõ</quote>
		állományrendszerrel rendelkezõ) 2.
		CD használatát, majd lépjünk
		be a javításhoz elindított
		parancsértelmezõbe.  Ezt követõen
		adjuk ki az alábbi parancsot:</para>

	      <screen><prompt>Fixit#</prompt> <userinput>fdisk -B -b /boot/boot0 eszköz</userinput></screen>

	      <para>A parancsban az
		<replaceable>eszköz</replaceable> helyére
		annak az eszköznek a nevét adjuk meg,
		amelyrõl a rendszert szoktuk indítani,
		például <filename>ad0</filename> (az
		elsõ IDE-lemez), <filename>ad4</filename> (az
		elsõ IDE-lemez valamelyik vezérlõn),
		<filename>da0</filename> (az elsõ SCSI-lemez)
		stb.</para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="boot-on-thinkpad">
	  <para>Az A, T és X sorozatú IBM Thinkpad
	    laptopok lefagynak a &os; telepítése
	    utáni elsõ indulásuk során.  Hogy
	    lehet ezen segíteni?</para>
	</question>

	<answer>
	  <para>Ezeken a gépeken az IBM BIOS-ának egy
	    korai hibás változata található,
	    amely a &os; által használt
	    partíciókat tévesen
	    <quote>suspend-to-disk</quote> típusú
	    partícióknak tekinti.  Ennek
	    következtében amikor a BIOS
	    megpróbálja értelmezni a &os;
	    által létrehozott partíciót,
	    megakad.</para>

	  <para>Az IBM
	    <footnote>
	      <para>Ahogy Keith Frechette
		(<email>kfrechet@us.ibm.com</email>) írta
		levelében.</para>
	    </footnote> szerint az alábbi típus/BIOS
	    változatokban található meg ez a
	    hiba.</para>

	  <informaltable frame="none" pgwide="1">
	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry>Típus</entry>
		  <entry>BIOS</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>T20</entry>
		  <entry>IYET49WW vagy késõbbi</entry>
		</row>

		<row>
		  <entry>T21</entry>
		  <entry>KZET22WW vagy késõbbi</entry>
		</row>

		<row>
		  <entry>A20p</entry>
		  <entry>IVET62WW vagy késõbbi</entry>
		</row>

		<row>
		  <entry>A20m</entry>
		  <entry>IWET54WW vagy késõbbi</entry>
		</row>

		<row>
		  <entry>A21p</entry>
		  <entry>KYET27WW vagy késõbbi</entry>
		</row>

		<row>
		  <entry>A21m</entry>
		  <entry>KXET24WW vagy késõbbi</entry>
		</row>

		<row>
		  <entry>A21e</entry>
		  <entry>KUET30WW</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>

	  <para>Úgy értesültünk, hogy az IBM
	    BIOS-ok késõbbi változataiban ismét
	    felbukkant ez a típusú hiba.  <link xlink:href="http://docs.FreeBSD.org/cgi/mid.cgi?20010427133759.A71732">
	    Ebben az üzenetben</link> &a.nectar; a &a.mobile;
	    tagjainak egy olyan módszert mutat be, ami
	    segíthet, ha az újabb típusú IBM
	    laptopunk nem tudja elindítani a &os;-t, és
	    így váltani tudunk a BIOS elõzõ vagy
	    következõ verziójára.</para>

	  <para>Ha régebbi típusú BIOS-szal
	    rendelkezünk és a frissítés nem
	    megoldható, akkor a &os;-t telepíthetjük
	    úgy is, hogy megváltoztatjuk a &os;
	    által használt partíció
	    azonosítóját és egy olyan
	    rendszerindító blokkot telepítünk,
	    amelyik képes ezt kezelni.</para>

	  <para>Ehhez elõször is a gépet egy olyan
	    állapotba kell visszahoznunk, ahol már
	    túl tudunk jutni a rendszerindító
	    képernyõn.  Ezt úgy tudjuk elérni,
	    ha nem engedjük, hogy a gép indulása
	    közben észrevegye az elsõdleges lemezen
	    található &os; partíciót.  Erre
	    az egyik lehetséges megoldás, ha a
	    gépbõl ideiglenesen eltávolítjuk a
	    merevlemezt és átrakjuk egy régebbi
	    ThinkPadba (például egy ThinkPad 600-as
	    típusba) vagy a megfelelõ
	    átalakító használatával
	    az asztali számítógépünkbe.
	    Miután ezzel megvagyunk, töröljük le a
	    &os; partícióját és tegyük
	    vissza a lemezt.  Ekkor a ThinkPad újból
	    mûködõképes lesz.</para>

	  <para>Ezt követõen az alábbi
	    utasításokat követve tudjuk
	    telepíteni a &os;-t:</para>

	  <procedure>
	    <step>
	      <para>Töltsük le a <filename>boot1</filename>
		és <filename>boot2</filename>
		állományokat a <uri xlink:href="http://people.FreeBSD.org/~bmah/ThinkPad/">http://people.FreeBSD.org/~bmah/ThinkPad/</uri>
		címrõl.  Olyan helyre tegyük ezeket,
		ahol késõbb is még el tudjuk
		érni.</para>
	    </step>

	    <step>
	      <para>A megszokott módon telepítsük a
		&os;-t a ThinkPadre.  Ilyenkor <emphasis>ne</emphasis>
		használjuk a <literal>Veszélyesen
		dedikált</literal> (Dangerously Dedicated)
		módot.  A telepítés
		befejezése után <emphasis>ne</emphasis>
		indítsuk újra a gépet.</para>
	    </step>

	    <step>
	      <para>Váltsunk át a vészhelyzetekben
		használatos parancsértelmezõre
		(<quote>Emergency Holographic Shell</quote>, <keycombo action="simul"><keycap>Alt</keycap> <keycap>F4</keycap></keycombo>)
		vagy indítsuk el egy javításhoz
		használt (<quote>fixit</quote>)
		parancsértelmezõt.</para>
	    </step>

	    <step>
	      <para>Az &man.fdisk.8; segítségével
		változtassuk meg a &os;-s partíció
		azonosítóját a
		<literal>165</literal> értékrõl a
		<literal>166</literal> értékre (ezt a
		típust az OpenBSD használja).</para>
	    </step>

	    <step>
	      <para>Másoljuk át az imént
		letöltött <filename>boot1</filename> és
		<filename>boot2</filename> állományokat a
		helyi állományrendszerre.</para>
	    </step>

	    <step>
	      <para>A &man.disklabel.8;
	      segítségével
		rögzítsük a <filename>boot1</filename>
		és <filename>boot2</filename> tartalmát a
		&os; slice-unkra.</para>

	      <screen>&prompt.root; <userinput>disklabel -B -b boot1 -s boot2 ad0sn</userinput></screen>

	      <para>ahol az <replaceable>n</replaceable> annak a
		slice-nak a sorszáma, ahová a &os;-t
		telepítettük.</para>
	    </step>

	    <step>
	      <para>Indítsuk újra a gépet.  A
		rendszerindító parancssorban ekkora
		megjelenik az <literal>OpenBSD</literal>
		indításának lehetõsége.
		Ezen keresztül tudjuk a &os;-t
		elindítani.</para>
	    </step>
	  </procedure>

	  <para>A kedves Olvasónak meghagytuk azt az esetet,
	    amikor ugyanezen a konfiguráción OpenBSD
	    és &os; rendszereket akarunk egyszerre
	    használni.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="install-bad-blocks">
	  <para>Lehet telepíteni hibás szektorokat
	    tartalmazó lemezre is?</para>
	</question>

	<answer>
	  <para>Igen, ez lehetséges, de egyáltalán
	    nem ajánlott.</para>

	  <para>Manapság ha egy IDE-meghajtón hibás
	    szektorokat találunk, akkor az arra utal, hogy
	    hamarosan tönkremegy (a meghajtó belsõ
	    átképezõ funkciói már
	    képesek megbirkózni a rossz szektorok
	    növekvõ számával, ami arra enged
	    következtetni, hogy a lemez felülete jelentõs
	    mértékben sérült).  Ezért
	    inkább egy új merevlemezes meghajtó
	    vásárlását javasoljuk.</para>

	  <para>Ha hibás SCSI-meghajtónk van, <link linkend="awre">ezt a választ</link> olvassuk
	    el.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="boot-floppy-strangeness">
	  <para>Furcsa dolgok történnek a
	    telepítõfloppy használata közben!  Mi
	    okozhatja?</para>
	</question>

	<answer>
	  <para>Ha olyan furcsa dolgokkal találkozunk a
	    telepítõfloppy használata során,
	    mint például a lemez állandó
	    darálása vagy a rendszer váratlan
	    újraindulása, akkor a következõ
	    három kérdést érdemes
	    feltennünk magunknak:</para>

	  <orderedlist>
	    <listitem>
	      <para>Biztos, hogy új, frissen formázott,
		teljesen hibamentes floppykat használunk
		(tehát olyanokat, amelyeket egy frissen bontott
		dobozból vettünk ki, és nem
		olyanokat, amelyeket valamelyik magazin
		mellékletébõl szedtük ki vagy
		éppen három évig az ágy
		alatt tároltunk)?</para>
	    </listitem>

	    <listitem>
	      <para>Biztos, hogy bináris (vagy image)
		módban töltöttük le a lemezek
		image-eit?  (Ne szégyelljük, mindenki
		életében legalább egyszer
		töltött már le véletlenül
		bináris állományt szöveges
		formátumban!)</para>
	    </listitem>

	    <listitem>
	      <para>&windows;&nbsp;95 vagy &windows;&nbsp;98 alatt DOS
		módban használtuk az
		<command>fdimage</command> vagy
		<command>rawrite</command> parancsot?  Ezek az
		operációs rendszerek
		általában nem férnek össze az
		olyan programokkal, amelyek közvetlenül a
		hardverrel akarnak kommunikálni, amire a lemezek
		írásához is szükség
		van.  Ez a probléma leginkább akkor
		merülhet fel, amikor a grafikus felületen
		belül egy DOS ablakban futtatjuk ezeket a
		programokat.</para>
	    </listitem>
	  </orderedlist>

	  <para>Kaptunk olyan visszajelzést is, hogy gondjaink
	    lehetnek, ha &netscape;-pel töltjük le a
	    rendszerindító lemezeket, ezért
	    lehetõség szerint igyekezzünk más
	    FTP klienst használni.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="no-install-cdrom">
	  <para>ATAPI CD-meghajtóról indult a rendszer, de
	    a telepítõ szerint nem található
	    semmilyen CD-meghajtó.  Hova tûnt?</para>
	</question>

	<answer>
	  <para>Ezt a problémát általában
	    egy rosszul beállított CD-meghajtó
	    okozza.  A CD-meghajtó rengeteg
	    számítógépben a
	    másodlagos IDE-vezérlõ slave (szolga)
	    portján található, a master (mester)
	    port használata nélkül.  Ez az ATAPI
	    specifikációi szerint nem szabályos, de
	    a &windows; ezzel különösebben nem
	    törõdik, a BIOS pedig egyszerûen figyelmen
	    kívül hagyja a rendszer indítása
	    során.  Ezért képes a BIOS ilyenkor
	    látni a CD-meghajtót, és ezért
	    nem képes a &os; teljes
	    telepítésnél használni.</para>

	  <para>Ezen úgy tudunk segíteni, ha a
	    CD-meghajtónkat az IDE-vezérlõn
	    átállítjuk masterre, vagy arra az
	    IDE-vezérlõre teszünk egy master
	    eszközt.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="install-PLIP">
	  <para>PLIP (Parallel Line IP) használatával
	    lehet laptopra telepíteni?</para>
	</question>

	<answer>
	  <para>Igen.  Ehhez csupán egy szabványos
	    Laplink-kábel kell.  Amennyiben szükséges,
	    a párhuzamos vonali
	    hálózatkezelés
	    beállításához olvassuk el <link xlink:href="&url.books.handbook;/network-plip.html">kézikönyv
	    PLIP-rõl szóló
	    részét</link>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="geometry">
	  <para>A lemezmeghajtók esetében milyen
	    geometriai beállításokat érdemes
	    használni?</para>
	</question>

	<answer>
	    <note>
	      <para>A lemez <quote>geometriája</quote> alatt a
		lemezen található cilinderek, fejek
		és a sávonkénti szektorok
		számát értjük.  Ezt a
		továbbiakban csak CHS-értéknek
		nevezzük (mint Cylinder/Head/Sector).  Ebbõl
		állapítja meg a PC-s BIOS, hogy a lemezen
		honnan kell olvasnia és hova kell
		írnia.</para>
	    </note>

	  <para>Ez rengeteg félreértést okoz az
	    újdonsült rendszergazdák
	    számára.  Elõször is
	    megemlítenénk, hogy egy SCSI-lemez
	    <emphasis>fizikai</emphasis> geometriája ebben az
	    esetben teljesen lényegtelen, mivel a &os;
	    lemezblokkokban gondolkozik.  Igazából nem
	    létezik <quote>a</quote> fizikai geometria fogalma,
	    ugyanis a szektorok sûrûsége a lemezen
	    felületén belül sem állandó.
	    Amit a gyártók általában
	    <quote>fizikai geometriának</quote> hívnak, az
	    általában az a geometria, amely a legkevesebb
	    helyveszteséggel jár.  Az IDE-lemezek
	    esetében a &os; ugyan CHS-értékekkel
	    dolgozik, de ezt minden modernebb meghajtó
	    legbelül blokkhivatkozásokká
	    alakítja.</para>

	  <para>Egyedül tehát a <emphasis>logikai</emphasis>
	    geometria számít.  Ez a válasz, amikor a
	    BIOS megkérdezi a meghajtónkat: <quote>Mik a
	    geometriai beállításaid?</quote>,
	    és ennek felhasználásával
	    kommunikál vele a késõbbiekben.  Mivel a
	    &os; is ezt az értéket használja fel a
	    rendszer indításánál, fontos,
	    hogy jól adjuk meg.  Ez különösen
	    abban az esetben számít, amikor több
	    operációs rendszer is található
	    a lemezen, hiszen mindegyiküknek azonos geometriai
	    beállításokat kell használniuk.
	    Ellenkezõ esetben komoly gondok léphetnek fel a
	    rendszer indítása során!</para>

	  <para>A SCSI-lemezek esetében a
	    beállítandó geometria
	    értéke attól függ, hogy a
	    vezérlõn használjuk-e a
	    bõvített fordítás
	    támogatását (extended translation
	    support, amelyet gyakran csak úgy neveznek, hogy
	    <quote>Support for DOS disks &gt;1GB</quote> vagy ehhez
	    hasonlóan).  Ha ezt letiltottuk, akkor
	    használjuk az <replaceable>N</replaceable> cilinder,
	    64&nbsp;fej és 32&nbsp;szektor
	    sávonkénti felírást, ahol
	    <replaceable>N</replaceable> a lemez MB-okban
	    számított mérete.  Így
	    például egy 2&nbsp;GB méretû lemez
	    geometriai beállítása
	    2048&nbsp;cilinder, 64&nbsp;fej és 32&nbsp;szektor
	    sávonként.</para>

	  <para>Ha viszont
	    <emphasis>engedélyeztük</emphasis> (ami gyakran
	    elõfordul, mivel így lehet az &ms-dos; bizonyos
	    korlátozásait megkerülni) és a
	    lemez kapacitása 1&nbsp;GB-nál több,
	    adjunk meg <replaceable>M</replaceable> cilindert, 255
	    fejet, 63 (és <emphasis>nem</emphasis> 64) szektort
	    sávonként, ahol az
	    <replaceable>M</replaceable> a lemez MB-okban mért
	    kapacitása osztva 7,844238-al (!).  Tehát az
	    iménti példában is említett
	    2&nbsp;GB-os meghajtó esetében 261 cilindert,
	    255 fejet és sávonként 63 szektort
	    kapunk.</para>

	  <para>Ha nem lennénk benne biztosak, vagy a &os;-nek a
	    telepítés közben nem sikerül
	    megállapítania a lemez geometriai
	    beállításait, mi magunk is könnyen
	    meg tudjuk határozni, ha készítünk
	    egy kis méretû DOS partíciót a
	    lemezen.  A BIOS ekkor észlelni fogja a
	    megfelelõ geometriai
	    beállításokat, és ha már
	    nincs rá tovább szükségünk,
	    akkor a partíciószerkesztõben nyugodtan
	    törölhetjük.  Hálózati
	    kártyák és hasonló hardverek
	    programozásához azonban még a
	    késõbbiekben hasznos lehet.</para>

	  <para>Használhatjuk viszont a &os;-hez mellékelt
	    <filename>pfdisk.exe</filename> segédprogramot is.
	    Ezt a &os; CD vagy a &os; FTP oldalainak <filename>tools</filename>
	    könyvtárában találhatjuk meg.
	    Ennek a programnak a segítségével ki
	    tudjuk deríteni, hogy a lemezen levõ többi
	    operációs rendszer milyen geometriai
	    beállításokat használ.  Az
	    így kapott értékeket fel tudjuk
	    használni a
	    partíciószerkesztõben.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="disk-divide-restrictions">
	  <para>Van valamilyen korlátozás a lemezek
	    felosztására vonatkozóan?</para>
	</question>

	<answer>
	  <para>Igen.  A rendszerindításhoz
	    használt (gyökér)partíciónak
	    az 1024.  cilinder alatt kell kezdõdnie, mivel a BIOS
	    csak így képes betölteni onnan a
	    rendszermagot.  (Ez a korlátozás a PC-s
	    BIOS-ok miatt van, nem a &os; miatt.)</para>

	  <para>A SCSI-lemezek esetében ez
	    általában azt jelenti, hogy
	    rendszerindításhoz használt
	    partíciónak az elsõ 1024&nbsp;MB alatt
	    kell kezdõdnie (vagy az elsõ 4096&nbsp;MB alatt,
	    ha a bõvített fordítást is
	    engedélyeztük &mdash; lásd az
	    elõzõ kérdést).  Az IDE-lemezek
	    esetében ez 504&nbsp;MB-nak felel meg.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="disk-manager">
	  <para>A &os; kompatibilis valamilyen disk managerrel?</para>
	</question>

	<answer>
	  <para>A &os; felismeri az <application>Ontrack Disk
	    Managert</application> és figyelembe veszi.  A
	    többi disk managert nem támogatja.</para>

	  <para>Ha egyedül csak a &os;-t akarjuk használni,
	    akkor nincs szükségünk disk managerre.
	    Egyszerûen csak állítsunk be egy akkora
	    méretû lemezt, amivel a BIOS képes
	    még megbirkózni (a határ
	    általában 504&nbsp;MB) és majd a &os;
	    kideríti, hogy valójában mennyi hely
	    áll a rendelkezésére.  Ha
	    régebbi gyártmányú
	    merevlemezünk van MFM-vezérlõvel, akkor a
	    &os;-nek konkrétan meg kell mondanunk, hogy mennyi
	    cilindert használhat.</para>

	  <para>Ha a &os; mellett más operációs
	    rendszereket akarunk használni, akkor ezt disk manager
	    nélkül is megtehetjük.  Egyedül arra
	    kell vigyáznunk, hogy a &os;
	    indításához használt
	    partíció és a másik
	    operációs rendszer slice-a az elsõ 1024
	    cilinder alatt kezdõdjön.  Ha nagyon
	    körültekintõek akarunk lenni, akkor erre a
	    célra egy 20&nbsp;MB méretû
	    rendszerindító partíció
	    tökéletesen megfelel.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="missing-os">
	  <para>Amikor a &os;-t telepítése után
	    elõször elindul, akkor egy
	    <errorname>Hiányzó operációs
	    rendszer</errorname> vagy egy <errorname>Missing Operating
	    System</errorname> hiba jelenik meg.  Mi
	    történt?</para>
	</question>

	<answer>
	  <para>Ez általában akkor fordul elõ, amikor
	    a &os; és a DOS vagy más operációs
	    rendszerek nem értenek egyet a lemez <link linkend="geometry">geometriai
	    beállításaiban</link>.
	    Telepítsük újra a &os;-t és
	    ezúttal figyelmesen kövessük a fentebb
	    adott utasításokat!</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="stop-at-boot-manager">
	  <para>Miért nem lehet továbblépni a boot
	    manager <prompt>F?</prompt>
	    menüjénél?</para>
	</question>

	<answer>
	  <para>Ez az elõbbi kérdéssel kapcsolatos
	    probléma egy másik tünete: a BIOS és
	    a &os; által használt geometriai
	    beállítások nem egyeznek!  Amennyiben a
	    vezérlõ vagy a BIOS támogatja a
	    cilinderek fordítását (amelyet gyakran
	    <quote>&gt;1GB driver support</quote> néven
	    találhatunk meg), akkor próbáljuk meg
	    átállítani és így
	    újratelepíteni a &os;-t.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="need-complete-sources">
	  <para>Az összes forrást telepíteni
	    kell?</para>
	</question>

	<answer>
	  <para>Alapvetõen nem.  Ettõl függetlenül
	    azonban javasoljuk legalább a <literal>base</literal>
	    források telepítését, ahol
	    számos olyan állomány
	    megtalálható, amelyekre a
	    késõbbiekben még hivatkozni fogunk,
	    valamint a <literal>sys</literal> (rendszermag)
	    források telepítését, amelyben a
	    rendszermag forrásai találhatóak.  A
	    rendszeren belül azonban a mûködéshez
	    semmi sem igényli közvetlenül a
	    források jelenlétét, egyedül
	    talán a rendszermag
	    beállítását végzõ
	    &man.config.8; program.  A rendszermag forrásainak
	    kivételével a rendszerben a
	    fordítás menetét úgy
	    építettük fel, hogy akár egy
	    írásvédett módon csatlakoztatott
	    NFS állományrendszerrõl is képes
	    legyen dolgozni (a rendszermag forrásaira
	    vonatkozó megszorítások miatt azonban
	    azt javasoljuk, hogy ezt közvetlenül ne a
	    <filename>/usr/src</filename>
	    könyvtárba csatlakoztassuk, hanem egy
	    másik helyre, ahol aztán szimbolikus linkek
	    segítségével másoljuk le a
	    forráskód
	    könyvtárszerkezetének legfelsõ
	    szintjét).</para>

	  <para>Ha kéznél vannak a források
	    és tisztában vagyunk a
	    rendszerfordítás folyamatával, akkor a
	    késõbbiekben sokkal könnyebben tudjuk a
	    &os; rendszerünket frissíteni.</para>

	  <para>A források egyes részeinek
	    kiválasztásához lépjünk be a
	    telepítõprogram
	    <guimenuitem>Custom</guimenuitem> (Egyéni
	    telepítés), majd a
	    <guimenuitem>Distributions</guimenuitem>
	    (Terjesztések) menübe.  </para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="need-kernel">
	  <para>Kell rendszermagot fordítani?</para>
	</question>

	<answer>
	  <para>Egy új rendszermag fordítása
	    korábban fontos része volt a &os;
	    telepítésének, de a legújabb
	    kiadások már kihasználják a
	    rendszermag beállításának sokkal
	    baratságosabb módszereit is.  A &os;&nbsp;5.X
	    és az azt követõ változatokban
	    már a betöltõbõl könnyen be
	    tudjuk állítani a rendszermagot a
	    beépített <quote>hints</quote>
	    (eszközökre vonatkozó
	    útmutatások) módszere által
	    felkínált rugalmasabb
	    lehetõségeknek
	    köszönhetõen.</para>

	  <para>Egy új rendszermag készítése
	    viszont olyan esetekben még továbbra is hasznos
	    lehet, amikor csak azokat a meghajtókat akarjuk
	    megtartani benne, amelyekre ténylegesen
	    szükségünk van.  Ezzel többnyire
	    memóriát tudunk megspórolni,
	    habár a legtöbb rendszer esetében erre
	    igazából nincs
	    szükségünk.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="password-encryption">
	  <para>A jelszavak tárolására
	    használható-e DES, Blowfish vagy MD5,
	    és ha igen, akkor hogyan lehet megadni?</para>
	</question>

	<answer>
	  <para>A &os; alapértelmezés szerint
	    <emphasis>MD5</emphasis>-alapú jelszavakat
	    használ.  Ezeket a <emphasis>DES</emphasis>
	    algoritmuson alapuló hagyományos &unix;-os
	    jelszavaknál sokkal megbízhatóbbnak
	    tartják.  A DES formátum természetesen
	    továbbra is elérhetõ olyan esetekben,
	    amikor a kevésbé biztonságos
	    jelszavakat használó régi
	    operációs rendszerekkel akarunk
	    együttmûködni.  Emellett a &os;-ben
	    lehetõségünk van a sokkal
	    biztonságosabb Blowfish jelszóformátum
	    használatára is.  Az új jelszavak
	    formátumát az
	    <filename>/etc/login.conf</filename>
	    állományban található
	    <literal>passwd_format</literal> bejelentkezési
	    tulajdonság adja meg, amelynek értéke
	    <literal>des</literal>, <literal>blf</literal> (amennyiben
	    elérhetõ), illetve <literal>md5</literal> lehet.
	    A bejelentkezési tulajdonságokkal kapcsolatban
	    a &man.login.conf.5; man oldalt érdemes
	    elolvasni.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="boot-floppy-hangs">
	  <para>A rendszerindító lemez elõször
	    elindul, de aztán miért akad meg a
	    <literal>Probing Devices...</literal>
	    képernyõn?</para>
	</question>

	<answer>
	  <para>Ha a rendszerünkhöz IDE-s &iomegazip; vagy
	    &jaz; meghajtót csatlakoztattunk, akkor
	    próbálkozzunk újra az
	    eltávolítása után.  A
	    rendszerindító floppy ugyanis hajlamos
	    összekeverni a meghajtókat.  A rendszer
	    telepítése után természetesen
	    újra csatlakoztathatjuk a meghajtót.  Ezt
	    remélhetõleg egy következõ
	    verzióban már kijavítják.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="panic-on-install-reboot">
	  <para>A rendszer telepítését
	    követõ újraindítás után
	    miért jelenik meg a <errorname>panic: can't mount
	    root</errorname> hibaüzenet?</para>
	</question>

	<answer>
	  <para>Ez a hiba a rendszerindító blokk és
	    a rendszermag közti
	    félreértésbõl, a lemezes
	    eszközök helytelen kezelésébõl
	    fakad.  Ilyen hibát általában olyan
	    rendszerekben kapunk, ahol két masternek
	    beállított IDE-lemez található
	    vagy ha az egyes IDE-vezérlõkre csak egy-egy
	    eszközt csatlakoztattunk és a &os;-t a
	    másodlagos IDE-vezérlõre
	    kapcsolódó lemezre telepítettük.
	    Ekkor a rendszerindító blokk szerint a
	    rendszert az <filename>ad0</filename> (de a BIOS-ban a
	    második) lemezre telepítettük,
	    miközben a rendszermag szerint ez a másodlagos
	    IDE-vezérlõn elhelyezkedõ elsõ lemez,
	    az <filename>ad2</filename>.  Az eszközök
	    felkutatása után a rendszermag
	    megpróbálja a rendszerindító
	    blokk által nyilvántartott
	    eszközrõl, az <filename>ad0</filename>
	    lemezrõl csatlakoztatni a rendszerindító
	    partíciót, ami viszont számára a
	    <filename>ad2</filename> eszköz lesz, így ez
	    a próbálkozása meghiúsul.</para>

	  <para>Ezt a félreértést a
	    következõ módokon lehet helyretenni:</para>

	    <orderedlist>
	      <listitem>
		<para>Indítsuk újra a rendszert és
		  nyomjuk le az <keycap>Enter</keycap> billentyût,
		  amikor a <literal>Booting kernel in 10 seconds; hit
		  [Enter] to interrupt</literal> szöveg megjelenik.
		  Ezzel a rendszerbetöltõ parancssorába
		  kerülünk.</para>

		<para>Ezután gépeljük be a
		  <userinput> set
		  root_disk_unit="lemezszám"
		  </userinput> sort.  Itt a
		  <replaceable>lemezszám</replaceable>
		  értéke <literal>0</literal> lesz, ha a
		  &os;-t az elsõdleges IDE-vezérlõ
		  master portján levõ merevlemezre
		  telepítettük, <literal>1</literal>, ha az
		  elsõdleges IDE-vezérlõ slave
		  portjára, <literal>2</literal>, ha a
		  másodlagos IDE-vezérlõ master
		  portjára, és végül
		  <literal>3</literal>, ha a másodlagos
		  IDE-vezérlõ slave portjára.</para>

		<para>Most már begépelhetjük, hogy
		  <userinput>boot</userinput>, és így a
		  rendszernek el is kell indulnia.</para>

		<para>Ha ezt a változtatást
		  véglegesíteni akarjuk (vagyis nem akarjuk
		  ugyanezt eljátszani a &os; minden egyes
		  indítása során), akkor a
		  <filename>/boot/loader.conf.local</filename>
		  állományba vegyünk fel a <literal>
		  root_disk_unit="lemezszám"</literal>
		  sort.</para>
	      </listitem>

	      <listitem>
		<para>Tegyük át a &os;-t tartalmazó
		  lemezt az elsõdleges IDE-vezérlõre,
		  és ezzel megszûnik az iménti
		  félreértés.</para>
	      </listitem>
	    </orderedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="memory-limits">
	  <para>Mennyi memóriát tudunk
	    használni?</para>
	</question>

	<answer>
	  <para>A memóriára vonatkozó
	    korlátozások platformonként
	    változnak.  Egy szabványos &i386;
	    telepítés esetén például
	    ez a határ 4&nbsp;GB, de &man.pae.4;
	    segítségével akár még
	    ennél több is elérhetõ.  Ehhez
	    olvassuk el az &i386; platformon 4&nbsp;GB-nál
	    több memória használatára
	    vonatkozó <link linkend="memory-i386-over-4gb">utasításokat</link>.
	    </para>

	  <para>A &os;/pc98 esetén a korlát szintén
	    4&nbsp;GB, azonban itt a PAE nem használható.
	    A &os; által támogatott összes többi
	    architektúra elméletileg ennél
	    több memóriát képes kezelni
	    (több terabyte-ot).</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ffs-limits">
	  <para>Mik az FFS állományrendszerek
	    korlátai?</para>
	</question>

	<answer>
	  <para>Az FFS állományrendszerek
	    méretének elméleti határa
	    8&nbsp;TB (2&nbsp;milliárd blokk), illetve az
	    alapértelmezett 8&nbsp;KB-os blokkméret
	    esetén 16&nbsp;TB.  A gyakorlatban azonban
	    szoftveresen ebbõl 1&nbsp;TB használható
	    ki, de kisebb módosításokkal
	    akár 4&nbsp;TB-os állományrendszer is
	    használható (és létezik).</para>

	  <para>Egyetlen FFS állományrendszerbeli
	    állomány mérete
	    megközelítõleg legfeljebb
	    1&nbsp;milliárd blokk lehet, ami 4&nbsp;KB-os
	    blokkmérettel számolva 4&nbsp;TB-ot
	    jelent.</para>

	  <table>
	    <title>Az állományok maximális
	      mérete</title>

	    <tgroup cols="3">
	      <thead>
		<row>
		  <entry>Blokkméret</entry>
		  <entry>Gyakorlatban</entry>
		  <entry>Elméletben</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>4&nbsp;KB</entry>
		  <entry>&gt;&nbsp;4&nbsp;GB</entry>
		  <entry>4&nbsp;TB&nbsp;-&nbsp;1</entry>
		</row>

		<row>
		  <entry>8&nbsp;KB</entry>
		  <entry>&gt;&nbsp;32&nbsp;GB</entry>
		  <entry>32&nbsp;TB&nbsp;-&nbsp;1</entry>
		</row>

		<row>
		  <entry>16&nbsp;KB</entry>
		  <entry>&gt;&nbsp;128&nbsp;GB</entry>
		  <entry>32&nbsp;TB&nbsp;-&nbsp;1</entry>
		</row>

		<row>
		  <entry>32&nbsp;KB</entry>
		  <entry>&gt;&nbsp;512&nbsp;GB</entry>
		  <entry>64&nbsp;TB&nbsp;-&nbsp;1</entry>
		</row>

		<row>
		  <entry>64&nbsp;KB</entry>
		  <entry>&gt;&nbsp;2048&nbsp;GB</entry>
		  <entry>128&nbsp;TB&nbsp;-&nbsp;1</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>

	  <para>4&nbsp;KB-os blokkméret esetén a
	    háromszoros indirekcióval származtatott
	    blokkok a gyakorlatban is kihasználhatóak,
	    és az egészet elméletben egyedül
	    csak az állományrendszerben így
	    ábrázolható blokkok maximális
	    száma korlátozná (ami kb.
	    1024<superscript>3</superscript>&nbsp;+&nbsp;1024<superscript>2</superscript>&nbsp;+&nbsp;1024),
	    azonban a gyakorlatban ezt az
	    állományrendszeri blokkokra vonatkozó
	    1&nbsp;GB&nbsp;-&nbsp;1 méretû (rossz) határ
	    korlátozza.  Az állományrendszeri
	    blokkok számát ugyanis ki kellene terjeszteni
	    a 2&nbsp;GB&nbsp;-&nbsp;1 méretig.  2&nbsp;GB&nbsp;-&nbsp;1
	    számú blokk használata körül
	    jelentkezik ugyan néhány hiba, de ezek
	    4&nbsp;KB-os blokkméret esetén nem is
	    érhetõek el.</para>

	  <para>A 8&nbsp;KB-nál nagyobb blokkméretek
	    esetén mindenre a blokkok 2&nbsp;GB&nbsp;-&nbsp;1
	    maximális mennyisége érvényes,
	    de a gyakorlatban ezt a blokkok számának
	    1&nbsp;GB&nbsp;-&nbsp;1 határa korlátozza.  Az
	    eredeti 2&nbsp;GB&nbsp;-&nbsp;1 mennyiségû blokk
	    használata gondokat okozhat.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="archsw-readin-failed-error">
	  <para>Egy új rendszermag fordítása
	    után miért jelenik meg a
	    <errorname>archsw.readin.failed</errorname> hibaüzenet
	    az indítás során?</para>
	</question>

	<answer>
	  <para>Mert a rendszermag és a
	    felhasználói programok verziója
	    eltér.  A rendszermag frissítésekor
	    feltétlenül használjuk a <command>make
	    buildworld</command> és a
	    <command>make buildkernel</command>
	    parancsokat is!</para>

	  <para>A rendszerindítás második
	    fokozatában közvetlenül meg tudjuk adni a
	    betöltendõ rendszermagot, ha a betöltõ
	    indítása elõtt, a <literal>|</literal>
	    jel megjelenésekor lenyomunk egy
	    billentyût.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="boot-acpi">
	  <para>A telepítés megszakad a rendszer
	    indítása közben, mit lehet ezzel
	    kezdeni?</para>
	</question>

	<answer>
	  <para>Próbáljuk meg letiltani az ACPI
	    támogatást.  Ezt úgy tudjuk megtenni,
	    hogy amikor a rendszertöltõ elindul, lenyomjuk a
	    <keycap>Szóköz</keycap> billentyût.  Ekkor
	    a következõt kapjuk:</para>

	  <screen>OK</screen>

	  <para>Itt gépeljük be az alábbi
	    parancsot:</para>

	  <screen><userinput>unset acpi_load</userinput></screen>

	  <para>Majd ezt:</para>

	  <screen><userinput>boot</userinput></screen>
	</answer>
      </qandaentry>

    </qandaset>
  </chapter>

  <chapter xml:id="hardware" xml:lang="hu">
    <title>Hardverkompatibilitás</title>

      <sect1 xml:id="compatibility-general">
	<title>Általános kérdések</title>

    <qandaset>
      <qandaentry>
	<question xml:id="which-hardware-to-get">
	  <para>A &os; rendszerükhöz szeretnénk
	    hardvert vásárolni.  Melyik
	    gyártmány/márka/típus a
	    legjobb?</para>
	</question>

	<answer>
	  <para>Ez állandó téma a &os;
	    levelezési listákon.  Mivel a hardverek gyorsan
	    változnak, nem is számíthatunk
	    másra.  <emphasis>Továbbra</emphasis> is
	    határozottan javasoljuk, hogy olvassuk át
	    figyelmesen a &os; <link xlink:href="&rel.current.hardware;">&rel.current;</link> vagy
	    <link xlink:href="&rel2.current.hardware;">&rel2.current;</link>
	    változatához tartozó
	    hardverjegyzéket (Hardware Notes) és
	    nézzünk után a levelezési
	    listák <link xlink:href="http://www.FreeBSD.org/search/#mailinglists">
	    archívumában</link> mielõtt
	    bármire is rákérdeznéünk a
	    legfrissebb és legjobb hardverek ügyében.
	    Könnyen elõfordulhat, hogy éppen a
	    múlt héten esett szó arról a
	    típusú eszközrõl, amirõl
	    éppen érdeklõdni
	    szeretnénk.</para>

	  <para>Ha laptoppal kapcsolatban lenne
	    kérdésünk, akkor nézzük meg a
	    &a.mobile; archívumát.  Minden más
	    esetben érdemes inkább a &a.questions;
	    archívumait megnézni vagy az adott hardverhez
	    tartozó levelezési listát
	    böngészni.</para>
	</answer>
      </qandaentry>

    </qandaset>
      </sect1>

      <sect1 xml:id="compatibility-memory">
	<title>Memória</title>

	<qandaset>
	  <qandaentry>
	    <question xml:id="memory-upper-limitation">
	      <para>A &os; képes 4&nbsp;GB-nál,
		16&nbsp;GB-nál vagy akár
		48&nbsp;GB-nál több memóriát
		(RAM-ot) támogatni?</para>
	    </question>

	    <answer>
	      <para>Igen.  A &os; operációs
		rendszerként képes az adott platformon
		kihasználni az összes rendelkezésre
		álló fizikai memóriát.  Ne
		felejtsük el azonban, hogy az egyes platformokon
		ennek határa eltér.  Például
		az &i386; platformon a <acronym>PAE</acronym>
		használata nélkül legfeljebb csak
		4&nbsp;GB memóriát tudunk elérni
		(amely azonban a PCI számára fenntartott
		címtér miatt a valóságban
		némileg kevesebb), illetve a
		<acronym>PAE</acronym> használatával
		legfeljebb 64&nbsp;GB memóriát.  Az AMD64
		platformokon viszont már egészen 1&nbsp;TB
		memóriáig is elmehetünk.</para>
	    </answer>
	  </qandaentry>

	  <qandaentry>
	    <question xml:id="memory-i386-over-4gb">
	      <para>A &os; miért jelez 4&nbsp;GB-nál
		kevesebb memóriát &i386;
		architektúrájú
		számítógépeken?</para>
	    </question>

	    <answer>
	      <para>Az &i386; platformon a címtér
		32&nbsp;bites, ami azt jelenti, hogy itt legfeljebb
		4&nbsp;GB memória címezhetõ meg
		(és érhetõ el).
		Ráadásul a címtér bizonyos
		tartományait a hardvereszközök
		számára tartják fenn
		különbözõ célokra,
		például a PCI eszközök
		mûködtetésére és
		vezérlésére, a videomemória
		hozzáférésére stb.
		Ennélfogva az operációs rendszer
		és annak rendszermagja által
		felhasználható teljes memória
		mérete jelentõsen kevesebb, mint 4&nbsp;GB.
		Ezen a típusú
		konfigurációkon általában
		3,2&nbsp;GB és 3,7&nbsp;GB között mozog
		a maximálisan kihasználható fizikai
		memória mérete.</para>

	      <para>Ha mégis 3,2&nbsp; vagy
		3,7&nbsp;GB-nál több memóriát
		szeretnénk elérni (4&nbsp;GB-ot vagy
		akár annál is többet), akkor ahhoz a
		<acronym>PAE</acronym> nevû speciális
		módosításra lesz
		szükségünk.  A <acronym>PAE</acronym> a
		<quote>Physical Address Extension</quote>
		(<quote>Fizikai címkiterjesztés</quote>)
		rövidítése, és egy olyan
		módszerre utal, amellyel a 32&nbsp;bites x86
		típusú processzorokon tudunk
		4&nbsp;GB-nál több memóriát
		címezni.  Lényegében nem
		csinál mást, csak 4&nbsp;GB-os
		határ felé képezi le azokat a
		memóriaterületeket, amelyeket
		egyébként a hardverek
		részére tartanak fenn, ezzel
		kiegészíti a fizikai
		memóriát (&man.pae.4;).  A
		<acronym>PAE</acronym> használatának
		számos hátránya van: ebben a
		módban a megszokottnál (vagyis
		<acronym>PAE</acronym> nélkül)
		némileg lassabb a memória
		elérése, illetve ilyenkor a
		betölthetõ rendszermag-modulok (lásd
		&man.kld.4;) sem támogatottak.  Emiatt az
		összes meghajtót bele kell
		fordítanunk a rendszermagba.</para>

	      <para>A <acronym>PAE</acronym> használatát
		általában a <filename>PAE</filename>
		nevû, a rendszermaghoz gyárilag
		mellékelt konfigurációs
		állománnyal engedélyezhetjük.
		Ezt eleve úgy állították
		össze, hogy gond nélkül
		készíteni tudjuk egy ilyen rendszermagot.
		Érdemes azonban megemlíteni, hogy a
		konfigurációs állomány
		bizonyos tekintetben egy kissé
		konzervatív, mivel egyes <acronym>PAE</acronym>
		esetén használhatatlannak megjelölt
		meghajtók valójában mégis
		minden gond nélkül
		hozzáadhatóak a
		konfigurációhoz.  Ezzel kapcsolatban azt
		javasoljuk, hogy ha az adott meghajtó
		használható valamelyik 64&nbsp;bites
		architektúrán (például
		AMD64-en), akkor nagy
		valószínûséggel
		<acronym>PAE</acronym>-vel is mûködni fog.
		Amennyiben saját magunk szeretnénk egy
		<acronym>PAE</acronym>-rendszermagot
		készíteni, akkor a következõ
		sort tegyük bele a konfigurációs
		állományba:</para>

	      <programlisting>options       PAE</programlisting>

	      <para>A <acronym>PAE</acronym> alkalmazása
		napjainkban annyira már nem jellemzõ, mivel az
		újabb x86 hardverek mindegyike képes
		64&nbsp;bites (AMD64 vagy &intel;&nbsp;64) módban
		futni.  Ebben az esetben már lényegesen
		nagyobb címtér használatára
		nyílik lehetõségünk, így
		nincs szükségünk további
		trükkökre.  A &os; támogatja az AMD64
		architektúrát, így ha
		4&nbsp;GB-nál több memóriát
		szeretnénk elérni, akkor inkább a
		&os; ezen változatát érdemes
		alkalmazni.</para>
	    </answer>
	  </qandaentry>
	</qandaset>
      </sect1>

      <sect1 xml:id="compatibility-processors">
	<title>Architektúrák és
	  processzorok</title>

    <qandaset>
      <qandaentry>
	<question xml:id="architectures">
	  <para>A &os; az x86-on kívül támogat
	    más architektúrájú rendszereket
	    is?</para>
	</question>

	<answer>
	  <para>Igen.  A &os; jelenleg az Intel x86 és az AMD64
	    architektúrákon mûködik.  A Az Intel
	    EM64T, IA-64, &arm;, &powerpc;, sun4v és &sparc64;
	    architektúrák is támogatottak.  A
	    további tervezett platformok között van
	    még a &mips; és az &s390;, a &mips;
	    aktuális állapotáról és
	    &a.mips; segítségével
	    értesülhetünk.  Az újabb
	    architektúrákhoz kapcsolódó
	    általános jellegû
	    megbeszéléseket a &a.platforms; foglalja
	    össze.</para>

	  <para>Amennyiben a
	    számítógépünk
	    architektúrája nem szerepel a jelenleg
	    támogatottak között, és valamilyen
	    gyors megoldásra lenne szükségünk,
	    akkor javasoljuk a <link xlink:href="http://www.netbsd.org/">NetBSD</link> vagy az <link xlink:href="http://www.openbsd.org/">OpenBSD</link>
	    használatát.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="smp-support">
	  <para>A &os; támogatja a szimmetrikus
	    többprocesszoros (SMP) rendszereket?</para>
	</question>

	<answer>
	  <para>A &os; általánosságban véve
	    támogatja a többprocesszoros rendszereket, noha
	    egyes esetekben a BIOS vagy az alaplap
	    hibájából fakadóan
	    problémáink adódhatnak.  A &a.smp;
	    átolvasása segíthet tisztázni
	    ezeket.</para>

	  <para>A &os; képes kihasználni az Intel
	    processzorai által felkínált
	    HyperThreading (HTT) támogatás elõnyeit.
	    Az <literal>options SMP</literal>
	    beállítással fordított
	    rendszermagok alapból maguktól felismerik a
	    rendszerünkben található logikai
	    processzorokat.  A &os; alapértelmezett
	    ütemezõje ezeket a logikai processzorokat a
	    többivel teljesen egyenrangúnak tekinti, vagyis
	    semmilyen ütemezési kérdés
	    eldöntésénél nem fogja
	    figyelembevenni az egy processzoron belül
	    elhelyezkedõ logikai processzorokat.  Ezen naív
	    ütemezési felfogás miatt bizonyos
	    esetekben a rendszerünk teljesítménye nem
	    tökéletesen optimális, ezért
	    adódhatnak olyan helyzetek, amikor a
	    <varname>machdep.hlt_logical_cpus</varname>
	    sysctl-változó
	    segítségével szükséges
	    lehet a logikai processzorok használatának
	    letiltása.  Ezenkívül még a
	    <varname>machdep.hlt_logical_cpus</varname>
	    sysctl-változón keresztül
	    lehetõségünk van leállítani
	    az üresjáratban mûködõ
	    processzorokat.  Ennek részleteirõl
	    bõvebben a &man.smp.4; man oldalon olvashatunk.</para>
	</answer>
      </qandaentry>

        </qandaset>
      </sect1>

      <sect1 xml:id="compatibility-drives">
	<title>Merevlemezes, szalagos, CD- és
	  DVD-meghajtók</title>

	<qandaset>

      <qandaentry>
	<question xml:id="supported-hard-drives">
	  <para>A &os; milyen típusú merevlemezes
	    meghajtókat ismer?</para>
	</question>

	<answer>
	  <para>A &os; ismeri az EIDE-, SATA-, SCSI- és
	    SAS-meghajtókat (és a velük kompatibilis
	    vezérlõket, errõl bõvebben lásd
	    a következõ szakaszt), valamint az összes
	    olyan meghajtót, amely az eredeti <quote>Western
	    Digital</quote> (MFM, RLL, ESDI és
	    természetesen az IDE) interfészt
	    használja.  Néhány egyedi
	    fejlesztésû ESDI vezérlõ nem fog
	    mûködni, ezért lehetõleg maradjunk a
	    WD1002/3/6/7 interfészeknél és azok
	    másolatainál.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="supported-scsi-controllers">
	  <para>Milyen SCSI- vagy SAS-vezérlõket
	    ismer?</para>
	</question>

	<answer>
	  <para>A teljes listát a &os;
	    hardverjegyzékében találhatjuk meg a
	    <link xlink:href="&rel.current.hardware;">&rel.current;</link>
	    vagy <link xlink:href="&rel2.current.hardware;">&rel2.current;</link>
	    kiadásban.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="tape-support">
	  <para>Milyen szalagos meghajtókat ismer?</para>
	</question>

	<answer>
	  <para>A &os; a SCSI és QIC-36 (QIC-02
	    interfésszel) szabványokat ismeri.  Ezek
	    közé értendõek a 8&nbsp;mm-es
	    (más néven Exabyte) és
	    DAT-meghajtók is.</para>

	  <para>Bizonyos régebbi 8&nbsp;mm-es meghajtók
	    nem egészen kompatibilisek a SCSI-2 szabvánnyal,
	    ezért a &os;-vel sem feltétlenül
	    képesek együttmûködni.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="tape-changer-support">
	  <para>A &os; támogatja a szalagok
	    cseréjét?</para>
	</question>

	<answer>
	  <para>A &os; &man.ch.4; eszközön és a
	    &man.chio.1; parancson keresztül támogatja a SCSI
	    szabványú szalagcserélõket.  A
	    használat pontos részleteirõl a
	    &man.chio.1; man oldalán olvashatunk
	    részletesebben.</para>

	  <para>Ha nem az <application>AMANDA</application> vagy a
	    hozzá hasonló programokat használjuk,
	    amelyek alapból ismerik a
	    szalagcserélés lehetõségét,
	    akkor ne feledkezzünk meg arról, hogy a szalagot
	    csak az egyik helyrõl a másikra tudjuk mozgatni,
	    ezért nekünk kell figyelnünk arra, hogy
	    melyik rekeszben vannak szalagok és a
	    meghajtónak ezek közül melyiket kell
	    használnia.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="supported-cdrom-drives">
	  <para>A &os; milyen CD-meghajtókat ismer?</para>
	</question>

	<answer>
	  <para>Bármilyen támogatott
	    SCSI-vezérlõhöz csatlakoztatható
	    SCSI-meghajtót ismer.</para>

	  <para>Ezenkívül még az alábbi
	    CD-interfészek ismertek:</para>

	    <itemizedlist>
	      <listitem>
		<para>Mitsumi LU002 (8&nbsp;bites), LU005
		  (16&nbsp;bites) és FX001D (16&nbsp;bites, dupla
		  sebességû).</para>
	      </listitem>

	      <listitem>
		<para>Sony CDU 31/33A</para>
	      </listitem>

	      <listitem>
		<para>Sound Blaster nem-SCSI CD-meghajtók</para>
	      </listitem>

	      <listitem>
		<para>Matsushita/Panasonic CD-meghajtók</para>
	      </listitem>

	      <listitem>
		<para>ATAPI kompatibilis IDE CD-meghajtók</para>
	      </listitem>
	    </itemizedlist>

	  <para>Az összes ismert nem-SCSI kártya nagyon
	    lassan mûködik a SCSI-meghajtókhoz
	    képest, és bizonyos ATAPI CD-meghajtók
	    nem használhatóak.</para>

	  <para>A Daemon&nbsp;News-tól és a
	    &os;&nbsp;Mall-tól rendelhetõ hivatalos &os;
	    CD-krõl akár közvetlenül el is tudjuk
	    indítani a rendszert.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="supported-cdrw-drives">
	  <para>A &os; milyen CD-RW meghajtókat ismer?</para>
	</question>

	<answer>
	  <para>A &os; bármilyen ATAPI-kompatibilis IDE CD-R vagy
	    CD-RW meghajtót ismer.  Ennek részleteit
	    lásd a &man.burncd.8; man oldalán.</para>

	  <para>A &os; ezeken kívül még
	    tetszõleges SCSI CD-R vagy CD-RW meghajtót
	    támogat.  A használatukhoz
	    telepítsük a <command>cdrecord</command>
	    programot a portok vagy csomagok közül, és
	    gondoskodjunk róla, hogy a
	    <filename>pass</filename> eszköz
	    támogatása benne legyen a
	    rendszermagban.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="zip-support">
	  <para>A &os; ismeri az &iomegazip; meghajtókat?</para>
	</question>

	<answer>
	  <para>A &os; alapból ismeri a SCSI és ATAPI
	    (IDE) interfészen kommunikáló
	    &iomegazip; meghajtókat.  A SCSI ZIP-meghajtók
	    ugyan egyedül az 5 és 6 target ID-krõl
	    hajlandóak mûködni, de ha a
	    SCSI-kártyánk BIOS-a támogatja, akkor
	    még a rendszert is el tudjuk indítani
	    róluk.  Egyelõre nem tisztázott, hogy
	    milyen kártyák képesek a 0 és 1
	    ID-ken kívül máshonnan is rendszert
	    indítani, ezért ennek a
	    hozzá tartozó dokumentációben
	    érdemes utánajárnunk.</para>

	  <para>A &os; ezenkívül még a
	    párhuzamos porton csatlakoztatható
	    ZIP-meghajtókat is ismeri.  Ehhez
	    ellenõrizzük, hogy a rendszermagunkban
	    megtalálhatóak az
	    <filename>scbus0</filename>,
	    <filename>da0</filename>,
	    <filename>ppbus0</filename> és
	    <filename>vp0</filename> meghajtók (a
	    <filename>GENERIC</filename> rendszermagban a
	    <filename>vp0</filename> kivételével
	    mindegyik szerepel).  Segítségükkel a
	    párhuzamos vonalon csatlakozó meghajtó
	    a <filename>da0s4</filename> eszközön
	    keresztül érhetõ el.  Ennek
	    megfelelõen az állományrendszerek a
	    <command>mount /dev/da0s4 /mnt</command>
	    <emphasis>vagy</emphasis> (DOS
	    esetén) a <command>mount -t msdosfs /dev/da0s4
	    /mnt</command> parancs kiadásával
	    csatlakoztathatóak.</para>

	  <para>Emellett még érdemes a GYIK <link linkend="media-change"> cserélhetõ lemezes
	    meghajtókról szóló
	    részét</link> is elolvasnunk ebben a
	    fejezetben, valamint <link linkend="removable-drives">a
	    <quote>formázásról</quote>
	    szóló megjegyzést</link> az
	    adminisztrációról szóló
	    fejezetben.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="jaz-zip-removable-support">
	  <para>A &os; ismeri a &jaz;, EZ és a többi
	    cserélhetõ lemezes meghajtót?</para>
	</question>

	<answer>
	  <para>Használhatóak.  Ezek többsége
	    SCSI eszköz, ezért a &os; SCSI-lemezként
	    látja, az IDE csatolós EZ pedig
	    IDE-meghajtóként érhetõ el.</para>

	  <para>A rendszer indítása elõtt ne
	    felejtsük el bekapcsolni a külsõ
	    egységeket.</para>

	  <para><anchor xml:id="media-change"/>Ha
	    tárolóeszközt akarunk cserélni a
	    rendszer mûködése közben, olvassuk el
	    a &man.mount.8;, &man.umount.8; és (SCSI
	    eszközök esetén) a &man.camcontrol.8; vagy
	    (IDE eszközök esetén) a &man.atacontrol.8;
	    man oldalakat, valamint a GYIK egy késõbbi
	    részében található <link linkend="removable-drives">részt a
	    cserélhetõ lemezes
	    meghajtókról</link>.</para>
	</answer>
      </qandaentry>

	</qandaset>

      </sect1>

      <sect1 xml:id="compatibility-kbd-mice">
	<title>Egér és billentyûzet</title>

	<qandaset>

      <qandaentry>
	<question xml:id="usbkbd">
	  <para>A &os; ismeri az USB billentyûzeket?</para>
	</question>

	<answer>
	  <para>A &os; alapból ismeri az USB billentyûzeket.
	    Miután engedélyeztük rendszerünkben
	    az USB billentyûzet támogatását,
	    az AT billentyûzet <filename>/dev/kbd0</filename>
	    lesz és az USB billentyûzet pedig
	    <filename>/dev/kbd1</filename>, már amennyiben
	    mind a kettõt csatlakoztattuk a
	    számítógépünkhöz.  Ha
	    viszont csak USB billentyûzetünk van, akkor az a
	    <filename>/dev/ukbd0</filename> lesz.</para>

	  <para>Ha az USB billentyûzetet konzolban akarjuk
	    használni, akkor erre figyelmeztetnünk kell a
	    konzolos meghajtót.  Ezt úgy tudjuk megtenni,
	    ha a következõ parancsot lefuttatjuk a rendszer
	    indítása közben:</para>

	  <screen>&prompt.root; <userinput>kbdcontrol -k /dev/kbd1 &lt; /dev/console &gt; /dev/null</userinput></screen>

	  <para>Amikor viszont csak USB billentyûzetünk van,
	    akkor az <filename>/dev/ukbd0</filename>
	    eszközön keresztül tudjuk elérni,
	    ezért a parancsnak ilyenkor így kell
	    kinéznie:</para>

	  <screen>&prompt.root; <userinput>kbdcontrol -k /dev/ukbd0 &lt; /dev/console &gt; /dev/null</userinput></screen>

	  <note>
	    <para>Ha véglegesíteni akarjuk ezt a
	      beállítást, akkor tegyük a
	      <literal>keyboard="/dev/ukbd0"</literal> sort az
	      <filename>/etc/rc.conf</filename>
	      állományba.</para>
	  </note>

	  <para>Miután ezt megcsináltuk, az USB
	    billentyûzet X alatt is mûködni fog minden
	    további beállítás
	    nélkül.</para>

	  <para>Ezzel a paranccsal tudunk visszaváltani az
	    alapértelmezett billentyûzetre:</para>

	  <screen>&prompt.root; <userinput>kbdcontrol -k /dev/kbd0 &gt; /dev/null</userinput></screen>

	  <para>A &man.kbdmux.4; meghajtón keresztül az
	    alábbi parancsok kiadásával
	    engedélyezhetjük az elsõdleges AT
	    billentyûzet és a másodlagos USB
	    billentyûzet párhuzamos
	    használatát a konzolon:</para>

	  <screen>&prompt.root; <userinput>kbdcontrol -K &lt; /dev/console &gt; /dev/null</userinput>
&prompt.root; <userinput>kbdcontrol -a atkbd0 &lt; /dev/kbdmux0 &gt; /dev/null</userinput>
&prompt.root; <userinput>kbdcontrol -a ukbd1 &lt; /dev/kbdmux0 &gt; /dev/null</userinput>
&prompt.root; <userinput>kbdcontrol -k /dev/kbdmux0 &lt; /dev/console &gt; /dev/null</userinput></screen>

	  <para>Részletesebb információkat az
	    &man.ukbd.4;, &man.kbdcontrol.1; és &man.kbdmux.4;
	    man oldalakon találhatunk.</para>

	  <note>
	    <para>Az USB billentyûzet menet közbeni
	      csatlakoztatása és
	      leválasztása nem feltétlenül fog
	      mûködni.  Ezért a problémák
	      elkerülése érdekében azt
	      javasoljuk, hogy a rendszer indítása
	      elõtt mindenképpen csatlakoztassuk a
	      billentyûzetet és hagyjuk egészen
	      úgy, amíg le nem
	      állítottuk.</para>
	  </note>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="busmouse">
	  <para>A nem szabványos buszos egereket hogyan lehet
	    beállítani?</para>
	</question>

	<answer>
	  <para>A &os; ismeri a buszos, illetve a Microsoft, Logitech
	    és az ATI által gyártott InPort buszos
	    egereket.  A <filename>GENERIC</filename> rendszermag azonban
	    ehhez nem tartalmaz meghajtót.  A rendszermag
	    konfigurációs állományába
	    a következõ sort kell megadni, ha egy buszos
	    egereket támogató rendszermagot akarunk
	    készíteni:</para>

	  <programlisting>device mse0 at isa? port 0x23c irq5</programlisting>

	  <para>A buszos egerekhez általában saját
	    interfészkártya is tartozik.  Ezeket a
	    kártyákat a fentitõl eltérõ
	    portcímre és IRQ megszakításra
	    is beállíthatjuk.  Részletesebb
	    információkat az egerünk man
	    oldalán és a &man.mse.4; man oldalon
	    olvashatunk.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ps2mouse">
	  <para>Hogyan lehet PS/2 (<quote>egérportos</quote> vagy
	    <quote>billentyûzetes</quote>) egeret
	    használni?</para>
	</question>

	<answer>
	  <para>Az PS/2 egereket alapból támogatjuk.  Az
	    ehhez szükséges <filename>psm</filename>
	    meghajtó megtalálható a
	    rendszermagban.</para>

	  <para>Ha a saját magunk által
	    összeállított rendszermagunk nem
	    tartalmazza ezt a meghajtót, akkor a
	    következõ sort kell felvennünk a
	    konfigurációs állományba:</para>

	  <programlisting>device psm0 at atkbdc? irq 12</programlisting>

	  <para>Miután a rendszermag a rendszer
	    indítása során helyesen észlelte
	    a <filename>psm0</filename> eszközt,
	    magától létrejön.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="moused">
	  <para>Az egeret az X Window Systemen kívül is
	    lehet valamilyen módon használni?</para>
	</question>

	<answer>
	  <para>Ha az alapértelmezett konzolos &man.syscons.4;
	    meghajtót használjuk, akkor a szöveges
	    felületû konzolokon az egérmutató
	    segítségével tudunk
	    szövegrészeket kijelölni és
	    másolni.  Ehhez nem kell mást tennünk,
	    csupán elindítani a &man.moused.8;
	    egérdémont és engedélyezni az
	    egérmutatót a virtuális
	    konzolokon:</para>

	  <screen>&prompt.root; <userinput>moused -p /dev/xxxx -t yyyy</userinput>
&prompt.root; <userinput>vidcontrol -m on</userinput></screen>

	  <para>Itt az <replaceable>xxxx</replaceable> az egeret
	    leképezõ eszköz neve és az
	    <replaceable>yyyy</replaceable> az egérhez
	    használt protokoll típusa.  Az
	    egérdémon a legtöbb egér
	    esetén képes magától
	    megállapítani az alkalmazott protokoll
	    típusát, kivéve a régebbi soros
	    egereket.  Az <literal>auto</literal> érték
	    megadásával tudjuk aktiválni ezt az
	    automatikus felderítést.  Amennyiben ez nem
	    mûködik, a &man.moused.8; man oldalán
	    nézhetünk után a támogatott
	    protokolloknak.</para>

	  <para>Ha PS/2 egerünk van, akkor egyszerûen csak
	    vegyük fel a <literal>moused_enable="YES"</literal> sor
	    az <filename>/etc/rc.conf</filename>
	    állományba, és az
	    egérdémon elindul a rendszer
	    indítása közben.  Valamint hogy ha az
	    egérdémont a konzol helyett az összes
	    virtuális konzolon is használni akarjuk, akkor
	    az <filename>/etc/rc.conf</filename>
	    állományba tegyük bele a
	    <literal>allscreens_flags="-m on"</literal> sort.</para>

	  <para>Miután az egérdémon elindult,
	    valamilyen módon koordinálni kell az egér
	    hozzáférését az
	    egérdémon és az összes többi
	    program, például az X Window System
	    között.  Errõl a
	    problémáról a GYIK <link linkend="x-and-moused">Miért nem mûködik X
	    alatt az egér?</link> kérdésében
	    olvashatunk részletesebb.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="text-mode-cut-paste">
	  <para>Hogyan lehet szöveget kijelölni és
	    másolni a szöveges konzolban?</para>
	</question>

	<answer>
	  <para>Ahogy sikerült elindítanunk az
	    egérdémont (lásd az <link linkend="moused">elõzõ szakaszt</link>), tartsuk
	    lenyomva az egér elsõ (bal oldali)
	    gombját és az egér
	    mozgatásával jelöljük ki a
	    szöveget.  Ezután nyomjuk le a második
	    (középsõ) gombját, amivel a kurzor
	    mellett megjelenik az imént kijelölt
	    szöveg.  A harmadik (jobb oldali) gomb
	    segítségével a szöveg
	    kijelölését tudjuk
	    <quote>kiterjeszteni</quote>.</para>

	  <para>Amennyiben az egerünkön nem
	    található középsõ gomb, az
	    egérdémon beállításainak
	    segítségével
	    megpróbálkozhatunk emulálni vagy
	    áthelyezni a vele kapcsolatos funkciókat egy
	    másik gombra.  A &man.moused.8; man oldalán
	    olvashatunk errõl részletesebben.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="mouse-wheel-buttons">
	  <para>Az egéren van mindenféle görgõ
	    és gomb.  Ki lehet ezeket valahogy használni
	    &os; alatt is?</para>
	</question>

	<answer>
	  <para>A válaszunk erre sajnos csupán annyi, hogy
	    <quote>Attól függ</quote>.  A
	    különbözõ
	    kiegészítõkkel rendelkezõ egerekhez
	    általában egy külön meghajtó
	    szükségeltetik.  Hacsak az egér
	    meghajtóprogramja vagy a hozzá tartozó
	    felhasználói program nem nyújt
	    valamilyen támogatást, az eszköz
	    egyszerûen csak egy szabványos két- vagy
	    háromgombos egérként fog
	    funkcionálni.</para>

	  <para>Ha az X Window környezetben akarunk
	    görgõket használni, esetleg <link linkend="x-and-wheel">ezt a szakaszt</link> érdemes
	    elolvasnunk.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="laptop-mouse-trackball">
	  <para>A laptopokon megtalálható
	    egér/trackball/touchpad hogyan
	    használható?</para>
	</question>

	<answer>
	  <para>Olvassuk el <link linkend="ps2mouse">az elõzõ
	    kérdésre adott választ</link>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="keyboard-delete-key">
	  <para>A <keycap>Delete</keycap> billentyû hogyan
	    használható a <command>sh</command> és
	    <command>csh</command>
	    parancsértelmezõkben?</para>
	</question>

	<answer>
	  <para>A <application>Bourne Shell</application>
	    esetében az alábbi sorokat kell megadnunk az
	    <filename>.shrc</filename> állományunkban.
	    Lásd &man.sh.1; és &man.editrc.5;.</para>

	  <programlisting>bind ^? ed-delete-next-char # a konzolhoz
bind ^[[3~ ed-delete-next-char # az xtermhez</programlisting>

	  <para>A <application>C Shell</application> esetében a
	    következõ soroknak kell az
	    <filename>.cshrc</filename> állományba
	    kerülnie.  Lásd &man.csh.1;.</para>

	  <programlisting>bindkey ^? delete-char # a konzolhoz
bindkey ^[[3~ delete-char # az xtermhez</programlisting>

	  <para>További információkat <link xlink:href="http://www.ibb.net/~anne/keyboard.html">ezen az
	    oldalon</link> találhatunk.</para>
	</answer>
      </qandaentry>

	</qandaset>
      </sect1>

      <sect1 xml:id="compatibility-networking">
	<title>Hálózati és soros
	  eszközök</title>

	<qandaset>

      <qandaentry>
	<question xml:id="network-cards">
	  <para>A &os; milyen hálózati
	    kártyákat ismer?</para>
	</question>

	<answer>
	  <para>Ezek teljes listáját a &os; egyes
	    kiadásaihoz tartozó hardverjegyzékben
	    találjuk meg.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="support-winmodem">
	  <para>A &os; ismer szoftveres modemeket, például
	    winmodemeket?</para>
	</question>

	<answer>
	  <para>A &os; különbözõ
	    kiegészítõ szoftvereken keresztül
	    több szoftveres modemet is támogat.  A
	    <package>comms/ltmdm</package> port
	    például a szélesebb körben
	    elterjedt Lucent LT chipsetes modemekhez ad
	    támogatást.</para>

	  <para>A &os; azonban nem telepíthetõ szoftveres
	    modemen keresztül.  A hozzá tartozó
	    szoftvert csak az operációs rendszer
	    telepítése után tudjuk
	    telepíteni.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="support-broadcom">
	  <para>Van natív meghajtó a Broadcom 43xx
	    típusú kártyákhoz?</para>
	</question>

	<answer>
	  <para>Nem, és valószínûleg nem is
	    lesz.</para>

	  <para>A Broadcom nem hajlandó nyilvánossá
	    tenni azokat az információkat, amik az
	    általuk gyártott vezeték
	    nélküli chipsetek programozásához
	    lennének szükségesek, mivel szoftveresen
	    vezérelt rádiót használnak.  Az
	    alkatrészeik FCC szintû
	    engedélyeztetéséhez ugyanis valamilyen
	    módon gondoskodniuk kell róla, hogy a
	    felhasználók nem képesek bizonyos
	    dolgokat módosítani vele kapcsolatban,
	    például a mûködési
	    frekvenciát, a modulációs
	    paramétereket vagy a kimenõ
	    teljesítményt.  A chipsetek
	    programozásának ismerete nélkül
	    azonban szinte lehetetlen elkészíteni
	    hozzájuk a megfelelõ meghajtót.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="multiport-serial-support">
	  <para>A &os; milyen többportos soros vonali
	    kártyákat ismer?</para>
	</question>

	<answer>
	  <para>Ezek listáját a kézikönyv
	    <link xlink:href="&url.books.handbook;/serial.html">Soros vonali
	    kommunikációról szóló
	    része</link> tartalmazza.</para>

	  <para>Bizonyos névtelen másolatok is
	    használhatók, különösen azok,
	    amelyek magukat AST-kompatibilisnek nevezik.</para>

	  <para>Az ilyen kártyák
	    beállításáról a &man.sio.4;
	    man oldalon olvashatunk részletesebben.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="serial-console-prompt">
	  <para>Hogyan lehet a <literal>boot:</literal> parancssort
	    elõhozni soros vonali konzolon?</para>
	</question>

	<answer>
	  <para>Olvassuk el a kézikönyvben <link xlink:href="&url.books.handbook;/serialconsole-setup.html">ezt a
	    fejezetet</link>.</para>
	</answer>
      </qandaentry>

	</qandaset>
      </sect1>

      <sect1 xml:id="compatibility-sound">
	<title>Hang</title>

	<qandaset>

      <qandaentry>
	<question xml:id="sound-card-support">
	  <para>A &os; milyen hangkártyákat ismer?</para>
	</question>

	<answer>
	  <para>A &os; rengeteg hangkártyát ismer, (ennek
	    részleteit lásd a <link xlink:href="&url.base;/releases/">&os; kiadásait
	    tartalmazó</link> honlapon és a &man.snd.4;
	    man oldalon).  Korlátozott módon az MPU-401
	    és a vele kompatibilis MIDI-kártyákat
	    is támogatja.  A &microsoft; Sound System
	    specifikációinak megfelelõ
	    kártyákat tudjuk használni.</para>

	    <note>
	      <para>Ez azonban csak a hangra vonatkozik!  Ez a
		meghajtó a &soundblaster; kivételével
		nem támogatja a kártyákon
		található CD-, SCSI- és joystick
		csatlakozásokat.  A &soundblaster; SCSI
		csatlakozása és bizonyos nem-SCSI
		CD-meghajtókat ugyan támogat, de rendszert
		például nem tudunk róluk
		indítani.</para>
	     </note>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="es1370-silent-pcm">
	  <para>Miért nincs hang a &man.pcm.4; által
	    támogatott hangkártyán?</para>
	</question>

	<answer>
	  <para>Egyes hangkártyák esetében a
	    hangerõ minden indításkor nullára
	    állítódik.  Ezért ilyenkor
	    mindig ki kell adni a következõ parancsot:</para>

	  <screen>&prompt.root; <userinput>mixer pcm 100 vol 100 cd 100</userinput></screen>
	</answer>
      </qandaentry>

	</qandaset>
      </sect1>

      <sect1 xml:id="compatibility-other">
	<title>Egyéb eszközök</title>

	<qandaset>
      <qandaentry>
	<question xml:id="power-management-support">
	  <para>Képes a &os; kihasználni az
	    energiagazdálkodási lehetõségeket
	    egy laptopon?</para>
	</question>

	<answer>
	  <para>A &os; bizonyos gépeken képes az
	    <acronym>APM</acronym> használatára.
	    Errõl az &man.apm.4; man oldalon találunk
	    pontosabb leírást.</para>

	  <para>A &os; ezenkívül még a
	    legújabb hardverekben megtalálható
	    <acronym>ACPI</acronym> lehetõségeit is
	    igyekezik kihasználni.  Errõl
	    részletesebben az &man.acpi.4; man oldalon
	    olvashatunk.  Amennyiben a rendszerünk egyaránt
	    tartalmazza az <acronym>APM</acronym> és az
	    <acronym>ACPI</acronym> támogatását,
	    bármelyiket használhatjuk.  Ilyen esetben
	    javasoljuk mind a kettõ
	    kipróbálását és az
	    igényeinkhez leginkább illeszkedõ
	    megoldás kiválasztását.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="disable-acpi">
	  <para>Hogy lehet letiltani az ACPI
	    támogatását?</para>
	</question>

	<answer>
	  <para>Tegyük bele az alábbi sort az
	    <filename>/boot/device.hints</filename>
	    állományba:</para>

	  <screen>hint.acpi.0.disabled="1"</screen>

	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="micron-hang-boot">
	  <para>Miért fagynak le a Micron típusú
	    rendszerek indulás közben?</para>
	</question>

	<answer>
	  <para>Egyes Micron gyártmányú alaplapokon
	    olyan PCI BIOS található, amely nem felel meg az
	    szabványoknak, és ezért a &os; nem tud
	    elindulni, mivel a PCI eszközök nem jelentik le az
	    általuk használt címeket.</para>

	  <para>Ezt a problémát úgy tudjuk
	    megoldani, ha a BIOS-ban kikapcsoljuk
	    (<literal>Disabled</literal> értékûre
	    állítjuk) a <quote>Plug and Play Operating
	    System</quote> beállítást.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="asusk7v-boot-failure">
	  <para>A rendszerindító lemez nem képes az
	    ASUS&nbsp;K7V alaplapokkal mûködni.  Hogyan lehet
	    ezt orvosolni?</para>
	</question>

	<answer>
	  <para>Menjünk be a BIOS-ba és kapcsoljuk ki
	    (állítsuk <literal>Disabled</literal>
	    értékre) a <quote>Boot Virus
	    Protection</quote> beállítást.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="micron-3comnic-failure">
	  <para>Miért nem mûködnek a &tm.3com; PCI
	    hálózati kártyák a Micron
	    típusú
	    számítógépekben?</para>
	</question>

	<answer>
	  <para>Nézzük meg <link linkend="micron-hang-boot">az elõzõ választ</link>.</para>
	</answer>
      </qandaentry>
	</qandaset>
    </sect1>
  </chapter>

  <chapter xml:id="troubleshoot" xml:lang="hu">
    <title>Hibaelhárítás</title>

    <qandaset>
      <qandaentry>
	<question xml:id="pae">
	  <para>Miért állapítja meg rosszul a &os;
	    a memória mennyiségét &i386;
	    hardveren?</para>
	</question>

	<answer>
	  <para>A válasz nagy
	    valószínûséggel a fizikai
	    és virtuális memóriacímek
	    közti különbségben rejlik.</para>

	  <para>A legtöbb PC-s hardvereszköz megegyezés
	    szerint a 3,5&nbsp;GB és 4&nbsp;GB közti
	    memóriaterületet speciális célokra
	    tartja fenn (általában a PCI
	    számára).  Ezen a címterületen
	    keresztül éri a PCI eszközöket.  Ennek
	    egyik következménye, hogy a fizikai
	    memória ezen a részen nem érhetõ
	    el.</para>

	  <para>Hogy pontosan mi történik az itt
	    elhelyezkedõ memóriával, teljesen a
	    hardvertõl függ.  Sajnálatos módon
	    bizonyos eszközök semmilyen megoldást nem
	    nyújtanak a problémára, és
	    így lényegében az utolsó
	    500&nbsp;MB-nyi memória elveszik.</para>

	  <para>Szerencsére a legtöbb eszköz azonban
	    képes ezt a területet egy felsõbb
	    címre leképezni, így ki tudjuk
	    használni.  Ilyenkor azonban tapasztalhatunk
	    némi félreértést, amikor
	    megnézzük a rendszerindítás
	    közben megjelenõ üzeneteket.</para>

	  <para>A &os; 32&nbsp;bites változata esetén ez a
	    memóriaterület elveszik, mivel a címe a
	    4&nbsp;GB-os határ felé kerül, amelyet a
	    32&nbsp;bites módban futó rendszermag
	    már nem képes elérni.  Ezen egy PAE
	    támogatással rendelkezõ rendszermag
	    használatával segíthetünk.  A
	    GYIK-on belül <link linkend="memory-limits">ebben a bejegyzésben</link>
	    olvashatunk bõvebben a
	    memóriakorlátokról, valamint <link linkend="memory-upper-limitation">ebben a részben</link>
	    láthatjuk a különbözõ
	    platformokra vonatkozó
	    memóriakorlátozásokat.</para>

	  <para>A &os; 64&nbsp;bites változata vagy a PAE
	    használata esetén azonban a &os; rendesen
	    felismeri és leképezi a fennmaradó
	    memóriaterületeket, így azok
	    használhatóvá válnak.  A
	    rendszerindítás során azonban az
	    elõbb említett leképezés miatt
	    látszólag úgy fog tûnni, mintha a
	    &os; több memóriát észlelne, mint
	    amennyivel valójában rendelkezünk.  Ez
	    teljesen normálisnak tekinthetõ és a
	    ténylegesen elérhetõ memória
	    mennyisége a folyamat végén be fog
	    állítódni.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="awre">
	  <para>Mit tegyünk, ha meghibásodott szektorokat
	    találunk a merevlemezünkön?</para>
	</question>

	<answer>
	  <para>A SCSI-meghajtók esetében a
	    meghajtó általában képes
	    önmagától átképezni az
	    ilyen szektorokat.  A legtöbb meghajtóban ez a
	    lehetõség viszont alapból nem
	    engedélyezett.</para>

	  <para>A hibás szektorok
	    átképezéséhez az eszköz
	    elsõ lapmódját kell átírnunk,
	    amelyet (<systemitem class="username">root</systemitem>
	    felhasználóként) így
	    tehetünk meg:</para>

	  <screen>&prompt.root; <userinput>camcontrol modepage sd0 -m 1 -e -P 3</userinput></screen>

	  <para>Változtassuk meg az AWRE (az írás
	    automatikus átképzése) és ARRE (az
	    olvasás automatikus átképzése)
	    beállítások értékeit
	    0-ról 1-re:</para>

	  <programlisting>AWRE (Auto Write Reallocation Enbld):  1
ARRE (Auto Read Reallocation Enbld):  1</programlisting>

	  <para>A modernebb IDE-meghajtók is képesek a
	    vezérlõjükkel nyilvántartani az
	    idõközben meghibásodott szektorokat,
	    és ezt általában alapból
	    engdélyezik.</para>

	  <para>Ha rossz szektorokra figyelmeztetõ
	    hibaüzeneteket látunk (akármilyen
	    típusú meghajtónk is legyen), az
	    kétségtelenül arra utal, hogy ideje
	    lecserélnünk a hardvert.  A hibás
	    szektorok használatát esetleg a
	    gyártó saját diagnosztikai
	    programjával le tudjuk tiltani, de hosszabb
	    távon mindenképpen az lesz a legjobb, ha
	    veszünk egy újat.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="hpnetserver-scsi-failure">
	  <para>A &os; miért nem találja meg a
	    HP&nbsp;Netserver SCSI-vezérlõjét?</para>
	</question>

	<answer>
	  <para>Ez tulajdonképpen egy ismert probléma.  A
	    HP&nbsp;Netserver gépekben egy integrált EISA
	    buszos SCSI-vezérlõ található,
	    amely a 11-es EISA bõvítõhelyen
	    található, ezért az összes
	    <quote>valódi</quote> EISA
	    bõvítõhely ez elõtt helyezkedik el.
	    Sajnos a 10 feletti EISA bõvítõhelyek
	    címei ütköznek a PCI eszközök
	    számára kiosztott címekkel,
	    ezért a &os; önmagától nem tudja
	    valami jól kezelni az ilyen helyzeteket.</para>

	  <para>Ezért a legjobban akkor járunk, ha
	    egyszerûen letagadjuk a címterek
	    ütközését :) Ezt úgy tudjuk
	    megtenni, ha a rendszermag <literal>EISA_SLOTS</literal>
	    nevû beállítását a 12
	    értékre állítjuk.  Ezután
	    már csak be kell konfigurálunk és
	    újra kell fordítanunk a rendszermagot, ahogy
	    azt a <link xlink:href="&url.books.handbook;/kernelconfig.html">kézikönyv
	    megfelelõ része is
	    tárgyalja</link>.</para>

	  <para>Természetesen, amikor egy ilyen gépre
	    akarunk telepíteni, a helyzet tovább
	    bonyolódik.  A telepítést úgy
	    tudjuk megoldani, ha a <emphasis>UserConfig</emphasis>
	    programon belül alkalmazunk egy apró
	    trükköt.  Most ne a <quote>vizuális</quote>
	    felületét használjuk, hanem a
	    parancssoros részt.  Gépeljük be, majd a
	    megszokottak szerint telepítsük a
	    rendszert:</para>

	  <programlisting>eisa 12
quit</programlisting>

	  <para>Ettõl függetlenül természetesen
	    továbbra is javasolt egy, az elõbbiek szerint
	    módosított rendszermagot fordítanunk
	    és telepítenünk.</para>

	  <para>A következõ verziókban
	    remélhetõleg már lesz valamilyen
	    megoldás erre a problémára.</para>

	    <note>
	      <para>A HP&nbsp;Netserver esetén nem tudunk a
		lemezeken <literal>Veszélyesen
		dedikált</literal> (<literal>Dangerously
		Dedicated</literal>) módot használni.
		Errõl <link linkend="dedicate">itt</link>
		olvashatunk bõvebben.</para>
	    </note>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ed1-timeout">
	  <para>Állandóan <errorname>ed1:
	    timeout</errorname> és ahhoz hasonló
	    üzenetek jelennek meg.  Mi lehet velük
	    kezdeni?</para>
	</question>

	<answer>
	  <para>Ezt a hibát általában a
	    megszakítások ütközése okozza
	    (például két kártya ugyanazt a
	    megszakítást akarja használni).
	    Indítsuk a rendszerünket a <option>-c</option>
	    beállítás használatával
	    és az
	    <filename>ed0</filename>/<filename>de0</filename>/...
	    bejegyzéseket változtassuk meg a
	    kártyáknak megfelelõen.</para>

	  <para>Ha a hálózati kártyánkon BNC
	    típusú csatlakozó
	    található, akkor még elõfordulhat,
	    hogy azért látunk ilyen hibaüzeneteket,
	    mert nem jól zártuk le a csatlakozást.
	    Ezt úgy tudjuk könnyen ellenõrizni, ha a
	    lezárót közvetlenül a
	    kártyára dugjuk rá (kábel
	    nélkül) és figyeljük, hogy
	    továbbra is jönnek-e a hibaüzenetek.</para>

	  <para>Egyes NE2000-kompatibilis kártyák akkor
	    adják ezt a hibát, ha az UTP portjukon nincs
	    aktív összeköttetés vagy nem dugtuk
	    be a kábelt.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="bad-3c509">
	  <para>Miért állnak le a &tm.3com; 3C509
	    kártyák minden különösebb ok
	    nélkül?</para>
	</question>

	<answer>
	  <para>Az ilyen típusú kártyák
	    néha hajlamosak elfelejteni a
	    beállításaikat.  Frissítsük
	    a kártya beállításait a
	    <command>3c5x9.exe</command> program
	    segítségével.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="printer-slow">
	  <para>A párhuzamos nyomtató nevetségesen
	    lassú.  Mi lehet ezzel kezdeni?</para>
	</question>

	<answer>
	  <para>Ha csupán annyi a problémánk, hogy
	    a nyomtató irdatlanul lassan mûködik, akkor
	    próbáljuk meg a kézikönyv <link xlink:href="&url.books.handbook;/printing-intro-setup.html">nyomtatásról
	    szóló részében</link>
	    leírtakhoz hasonlóan
	    átállítani a <link xlink:href="&url.books.handbook;/printing-intro-setup.html#PRINTING-PARALLEL-PORT-MODE">nyomtató
	    portkezelését</link>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="signal11">
	  <para>A programok miért állnak le
	    idõnként <errorname>Signal 11</errorname>
	    hibákkal?</para>
	</question>

	<answer>
	  <para>Ezek a hibák akkor keletkeznek, amikor a
	    futó programok olyan memóriaterülethez
	    próbálnak meg hozzáférni, amihez
	    eredetileg nem lenne szabad.  Ha valami ehhez hasonló
	    történik a rendszerünkben
	    látszólag teljesen
	    véletlenszerûen, akkor nagyon óvatosan
	    kezdjünk el vizsgálódni.</para>

	  <para>A lehetséges okok az alábbiak
	    lehetnek:</para>

	  <orderedlist>
	    <listitem>
	      <para>Ha csak olyan alkalmazások esetében
		jelentkezik ez a hiba, amelyeket mi magunk
		fejlesztünk, akkor az
		valószínûleg arra utal, hogy
		valamelyik része hibásan
		mûködik.</para>
	    </listitem>

	    <listitem>
	      <para>Ha a &os; alaprendszerének valamelyik
		részében tapasztalunk ilyen hibákat,
		akkor azt szintén okozhatja hibás
		kód, de az ilyen hibákat
		általában hamarabb meg szokták
		találni és ki szokták
		javítani, mint ahogy a GYIK-ot olvasók
		többsége találkozna velük (a
		<literal>-CURRENT</literal> ág pontosan ezt a
		célt szolgálja).</para>
	    </listitem>
	  </orderedlist>

	  <para>Elõfordulhat, hogy ez egy olyan furcsaság
	    eredménye, amely <emphasis>nem</emphasis> a &os;
	    hibája: például ugyanazon program
	    fordításakor mindig mást csinál
	    a fordítóprogram.</para>

	  <para>Például tegyük fel, hogy a
	    <command>make buildworld</command>
	    parancsot futtatjuk, és a fordítás
	    félbeszakad, amikor az <filename>ls.c</filename>
	    állományból el akarja
	    készíteni az <filename>ls.o</filename>
	    állományt.  Ha ezután megint
	    megpróbáljuk kiadni a <command>make
	    buildworld</command> parancsot,
	    akkor a fordítás ugyanazon a helyen
	    újból meghiúsul &mdash;
	    valószínûleg hibás a
	    forráskód, frissítsük a
	    forrásainkat és próbáljuk meg
	    ismét.  Ha viszont a fordítás ilyenkor
	    már egy másik helyen akad el, akkor szinte
	    biztos, hogy hardverhibával akadtunk
	    össze.</para>

	  <para>Amit ilyenkor tenni tudunk:</para>

	  <para>Az elsõ esetben egy nyomkövetõ,
	    például a &man.gdb.1;
	    segítségével keressük meg a program
	    azon pontját, ahol rossz
	    memóriaterülethez próbál meg
	    hozzáférni és javítsuk
	    ki.</para>

	  <para>A második esetben ellenõrizzük, hogy
	    nem a hardver a hibás.</para>

	  <para>Ennek okai többek közt a következõk
	    lehetnek:</para>

	  <orderedlist>
	    <listitem>
	      <para>Túlmelegednek a merevlemezeink:
		ellenõrizzük, hogy a gépben
		található ventillátorok rendesen
		mûködnek-e (persze elõfordulhat, hogy
		más eszközök melegednek
		túl).</para>
	    </listitem>

	    <listitem>
	      <para>A processzor túlmelegedett: lehet, hogy mert
		túlságosan nagy órajelen
		járatjuk, vagy mert egyszerûen leállt
		a hûtése.  Akármelyik eset is
		következett be, legalább a hiba
		felderítéséig
		állítsuk vissza a hivatalos
		sebességére.</para>

	      <para>Ha feltétlenül ragaszkodunk a
		rendszerünk tuningolásához, akkor
		érdemes elgondolkoznunk azon, hogy egy lassabb
		rendszerrel jobban járunk, mint egy
		állandóan cserélendõ,
		ropogósra sült rendszerrel.  Az emberek
		általában nem is nagyon szeretik az ilyen
		rendszereket, független attól, hogy
		szerintünk érdemes-e ilyet csinálni
		vagy sem.</para>
	    </listitem>

	    <listitem>
	      <para>Hibás memóriamodulok: ha több
		SIMM és DIMM modul is található a
		gépünkben, akkor vegyük ki az
		összeset és próbáljuk ki
		mindegyiket egyesével, ezzel is
		leszûkíthetjük a probléma
		felderítését a hibás
		DIMM/SIMM modulokra vagy azok
		kombinációjára.</para>
	    </listitem>

	    <listitem>
	      <para>Az alaplap túlbecslõ
		értékei: a BIOS
		beállításai között vagy
		az alaplapon található jumperekkel
		szabályozni tudjuk a
		különbözõ
		idõzítéseket, ahol
		általában az alapértelmezett
		értékek megfelelnek, de néha
		elõfordulhat, hogy a memóriamodulok
		késleltetését lassúra, vagy
		éppen turbó sebességre
		állítják (<quote>RAM Speed:
		Turbo</quote> vagy ehhez hasonló néven
		keressük a BIOS-ban), ami szintén okozhat
		furcsa viselkedést.  Próbáljuk meg
		visszaállítani az BIOS
		alapértelmezett értékeit, de
		elõtte érdemes lejegyezni az aktuális
		beállításainkat.</para>
	    </listitem>

	    <listitem>
	      <para>Az alaplap zajos vagy kevés áramot
		kap: ha vannak használaton kívüli I/O
		kártyáink, merevlemezeink,
		CD-meghajtóink a rendszerünkben, akkor
		próbáljuk meg ideiglenesen
		eltávolítani ezeket vagy egyszerûen
		csak lehúzni róluk a
		tápkábelt.  Ezzel tudjuk vizsgálni,
		hogy a számítógépünk
		tápegysége képes-e
		megbirkózni a kisebb terheléssel.  Esetleg
		kipróbálhatunk egy másik
		tápegységet is, lehetõleg egy
		kicsivel erõsebbet (például ha a
		jelenlegi tápegységünk
		teljesítménye 250&nbsp;watt, akkor
		használjunk helyette egy
		300&nbsp;wattosat).</para>
	    </listitem>

	  </orderedlist>

	  <para>Továbbá érdemes lehet még
	    elolvasnunk a SIG11 GYIK-ot (lásd lentebb), ahol
	    mindezeket a problémákat részletesen
	    kifejtik, noha a &linux;
	    nézõpontjából.  Arról is
	    olvashatunk benne, hogy egy hibás
	    memóriát miért nem képesek
	    észlelni a szoftveres vagy hardveres
	    tesztelõeszközök.</para>

	  <para>Végezetül, ha az egyik javaslat sem
	    segített a probléma megoldásában,
	    akkor valószínûleg sikerült
	    hibát találnunk a &os; kódjában,
	    amirõl nyugodtan írhatunk a fejlesztõknek
	    egy hibajelentést.</para>

	  <para>A problémáról minden
	    részletre kiterjedõ módon <link xlink:href="http://www.bitwizard.nl/sig11/">A SIG11-es probléma GYIK-ja</link>
	    írásban olvashatunk (angolul).</para>
	  </answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="trap-12-panic">
	  <para>A rendszer összeomlik vagy egy <errorname>Fatal
	    trap 12: page fault in kernel mode</errorname> vagy pedig
	    valamilyen <errorname>panic:</errorname> hibaüzenettel
	    és egy halom számot ír ki.  Mit
	    tegyünk?</para>
	</question>

	<answer>
	  <para>A &os; fejlesztõi nagyon kíváncsiak
	    az ilyen hibákra, de a
	    felderítéséhez sajnos jóval
	    több információra van
	    szükségük, mint amennyit láthattunk.
	    Másoljuk le az összeomláshoz
	    tartozó teljes üzenetet.  Ezután
	    nézzük meg a GYIK-nak azt a
	    részét, amely a <link linkend="kernel-panic-troubleshooting">rendszermag
	    összeomlásáról</link> szól,
	    készítsünk egy nyomkövetési
	    információkkal ellátott rendszermagot
	    és kérjük le a hívási
	    láncot.  Ez elsõre talán bonyolultnak
	    hangzik, de ehhez igazából nem igényel
	    semmilyen programozási tudást, egyszerûen
	    csak a megadott utasításokat kell
	    követnünk.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="screen-loses-sync">
	  <para>A rendszer indulása közben miért
	    sötétül a képernyõ és megy
	    el rajta a kép?</para>
	</question>

	<answer>
	  <para>Ez az ATI&nbsp;Mach&nbsp;64 videokártyák
	    esetében jelentkezõ probléma.  Ilyenkor az
	    a gond, hogy a kártya a <literal>0x2e8</literal>
	    címet használja, akárcsak a negyedik
	    soros port.  A &man.sio.4; meghajtóban levõ hiba
	    (vagy netalán beállítás?) miatt
	    azonban a negyedik soros portot
	    <emphasis>még</emphasis> akkor is használni
	    fogja, ha kikapcsoljuk a <filename>sio3</filename> (a
	    negyedik soros port) eszközt.</para>

	  <para>A hibát kijavításáig
	    így kerülhetjük meg:</para>

	  <orderedlist>
	    <listitem>
	      <para>A betöltõ parancssorában adjuk meg
		a <option>-c</option> paramétert.  (Így
		elõ tudjuk hozni a rendszermag
		konfigurációs
		módját.)</para>
	    </listitem>

	    <listitem>
	      <para>Kapcsoljuk ki a <filename>sio0</filename>,
		<filename>sio1</filename>,
		<filename>sio2</filename> és
		<filename>sio3</filename> eszközöket
		(tehát mindegyiket).  Emiatt a &man.sio.4;
		meghajtó nem indul el, és így nem
		okoz problémát.</para>
	    </listitem>

	    <listitem>
	      <para>Lépjünk ki és folytassuk a
		rendszer indítását.</para>
	    </listitem>
	  </orderedlist>

	  <para>Ha a soros portokat is használni akarjuk, akkor
	    következõ módosításokkal
	    készítsünk egy új rendszermagot: a
	    <filename>/usr/src/sys/dev/sio/sio.c</filename> (vagy pc98
	    esetén a
	    <filename>/usr/src/sys/pc98/cbus/sio.c</filename>)
	    állományban keressük meg a
	    <literal>0x2e8</literal> karakterláncot és az
	    azt megelõzõ vesszõt távolítsuk
	    el (de az utána következõt tartsuk meg).
	    Miután végrehajtottuk ezt a
	    módosítást, a megszokott módon
	    fordítsuk újra a rendszermagot.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="reallybigram">
	  <para>A &os; miért csak 64&nbsp;MB
	    memóriát használ, amikor 128&nbsp;MB van
	    a gépben?</para>
	</question>

	<answer>
	  <para>Mivel &os; a BIOS-tól próbálja
	    megtudni a rendelkezésre álló
	    memória méretét, ezért csak
	    16&nbsp;biten képes lekérdezni a KB-okban
	    (vagyis 65&nbsp;535&nbsp;KByte = 64&nbsp;MB, vagy még
	    ennél is kevesebb, mivel egyes BIOS-ok legfeljebb
	    16&nbsp;MB memóriát engednek látni).
	    Tehát ha 64&nbsp;MB-nál több
	    memóriával rendelkezünk, akkor a &os;
	    ugyan megpróbálja azt felderíteni, de
	    nem feltétlenül fog sikerülni.</para>

	  <para>Ezt úgy tudjuk megoldani, ha a rendszermag
	    alábbi beállítását
	    használjuk.  Alapvetõen ugyanis létezik
	    egy módszer, amivel le lehet kérdezni a
	    memória teljes méretét a
	    BIOS-tól, de a hozzá tartozó rutin nem
	    fért el a rendszerindító blokkban.  Ha
	    egyszer majd sikerül neki helyet csinálni, akkor
	    a rendszer képes lesz kizárólag ezzel a
	    módszerrel dolgozni.  Amíg viszont ez nem
	    így van, addig kénytelenek leszünk a most
	    következõ megoldást
	    választani:</para>

	  <programlisting>options MAXMEM=<replaceable>N</replaceable></programlisting>

	  <para>ahol <replaceable>N</replaceable> a memória
	    Kilobyte-okban megadott mérete.  Tehát egy
	    128&nbsp;MB memóriával rendelkezõ
	    számítógép esetén ez
	    <literal>131072</literal>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="kmem-map-too-small">
	  <para>A számítógépben több
	    mint 1&nbsp;GB memória van, de mégis
	    <errorname>kmem_map too small</errorname> üzenetek
	    jelennek meg.  Mi a gond?</para>
	</question>

	<answer>
	  <para>A &os; általában a rendszermag
	    néhány fontos paraméterét, mint
	    például az egyszerre megnyitható
	    állományok maximális
	    számát a
	    számítógépben
	    található memória
	    méretébõl származtatja.  Az
	    1&nbsp;GB memóriánál több
	    esetén azonban elképzelhetõ, hogy ez az
	    <quote>automatikus méretezés</quote>
	    túlságosan is nagy értékeket
	    választ.  Így a rendszer
	    indításakor a rendszermag olyan nagy
	    méretû táblázatokat és
	    egyéb struktúrákat foglal le, amelyek
	    betöltik a rendelkezésére
	    bocsátott terület nagy részét.
	    Késõbb, a rendszer futása közben
	    pedig a rendszermag szépen lassan kifogy a dinamikus
	    memóriaterületekbõl és
	    összeomlik.</para>

	  <para>Készítsünk egy olyan saját
	    rendszermagot, ahol a <option>VM_KMEM_SIZE_MAX</option>
	    beállítást megnöveljük
	    egészen a maximális 400&nbsp;MB-os
	    értékig (<option>options
	    VM_KMEM_SIZE_MAX=419430400</option>).  400&nbsp;MB
	    használata valószínûleg
	    elég lesz egészen 6&nbsp;GB
	    memóriáig.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="panic-kmemmap-too-small">
	  <para>A számítógépben nincs
	    1&nbsp;GB memória, a &os; mégis
	    <errorname>kmem_map too small</errorname> hibával
	    leáll!</para>
	</question>

	<answer>
	  <para>Ez a hibaüzenet arra utal, hogy a rendszer
	    kifogyott a hálózati pufferek
	    (különösen az mbuf klaszterek)
	    számára kiosztott virtuális
	    memóriából.  Az mbuf klaszterek
	    részére fenntartott virtuális
	    memória méretének
	    beállításáról a
	    kézikönyv <link xlink:href="&url.books.handbook;/configtuning-kernel-limits.html#NMBCLUSTERS">Hálózati
	    korlátozások</link> címû
	    szakaszában olvashatunk.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="proc-table-full">
	  <para>Miért jelenik meg a <errorname>kernel: proc:
	    table is full</errorname> hibaüzenet?</para>
	</question>

	<answer>
	  <para>A &os; rendszermagja egyszerre csak bizonyos
	    számú programot enged futni.  Ezek
	    konkrét száma a
	    <varname>kern.maxusers</varname>
	    &man.sysctl.8;-változótól függ.  A
	    <varname>kern.maxusers</varname> ezenkívül
	    még hatással van más belsõ
	    korlátokra is, például a
	    hálózati pufferekre (lásd <link linkend="panic-kmemmap-too-small">ezt</link> a
	    korábbi kérdést).  Ha a
	    számítógépünk
	    túlságosan leterhelt, akkor érdemes
	    megpróbálkoznunk a
	    <varname>kern.maxusers</varname>
	    értékének
	    növelésével.  Ennek
	    átállítása a rendszerben
	    egyszerre futtatható maximális programok
	    számával együtt sok más
	    rendszerszintû korlátozást is
	    finomít.</para>

	  <para>A <varname>kern.maxusers</varname>
	    értékének
	    beállításához nézzük
	    meg a kézikönyv <link xlink:href="&url.books.handbook;/configtuning-kernel-limits.html#KERN-MAXFILES">Az állományok és futó programok korlátozásairól</link>
	    szóló szakaszát.  (Miközben ez a
	    rész a megnyitható állományok
	    maximális számáról szól,
	    addig ugyanez érvényes a futó
	    programokra is.)</para>

	  <para>Ha viszont a
	    számítógépünk nem éri
	    akkora terhelés, de mégis szeretnénk
	    egyszerre nagyobb számú programot is futtatni
	    rajta, akkor ehhez elegendõ csak
	    <varname>kern.maxproc</varname> változót
	    átállítanunk.  Ezt úgy tudjuk
	    megtenni, ha felvesszük a
	    <filename>/boot/loader.conf</filename>
	    állományba.  Ez az érték
	    természetesen addig nem
	    beállítódni, amíg a
	    rendszerünket újra nem indítjuk.
	    Ezekrõl a változókról a
	    &man.loader.conf.5; és &man.sysctl.conf.5; man
	    oldalakon tájékozódhatunk
	    részletesebben.  Ha az összes programot egyetlen
	    felhasználóval akarjuk futtatni, akkor a
	    <varname>kern.maxprocperuid</varname> változót
	    értékét is át kell
	    állítanunk, méghozzá a
	    <varname>kern.maxproc</varname> új
	    értékénél eggyel kisebbre.
	    (Ezért kell így csinálni, mert egy
	    rendszerprogram, az &man.init.8; mindig fut.)</para>

	  <para>A sysctl változók
	    beállításait úgy is tudjuk
	    véglegesíteni, ha felvesszük ezeket az
	    <filename>/etc/sysctl.conf</filename>
	    állományba.  A kézikönyv <link xlink:href="&url.books.handbook;/configtuning-sysctl.html">A
	    rendszermag korlátainak finomhangolása</link>
	    címû szakaszában részletesebb is
	    olvashatunk róla, hogy miként
	    állítsuk be a rendszerünket.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="cmap-busy-panic">
	  <para>Az új rendszermag indításakor
	    miért keletkezik <errorname>CMAP busy</errorname>
	    hibaüzenet?</para>
	</question>

	<answer>
	  <para>Az elavult <filename>/var/db/kvm_*.db</filename>
	    állományokat összegyûjtõ rutin
	    idõnként nem mûködik megfelelõen,
	    és a nem egyezõ állományok
	    esetén össze is omolhat.</para>

	  <para>Amikor ilyen történik, indítsuk
	    újra a rendszert egyfelhasználós
	    módban és gépeljük be:</para>

	  <screen>&prompt.root; <userinput>rm /var/db/kvm_*.db</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="brkadrint-illegal-host-access">
	  <para>Mit jelent az <errorname>ahc0: brkadrint, Illegal Host
	    Access at seqaddr 0x0</errorname> üzenet?</para>
	</question>

	<answer>
	  <para>Ez az Ultrastor SCSI vezérlõkártya
	    ütközésére utal.</para>

	  <para>A rendszerindítás közben
	    lépjünk be a rendszermag
	    konfigurációs menüjébe és
	    tiltsuk le a gondot okozó
	    <filename>uha0</filename> eszközt.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="aci0-illegal-cable">
	  <para>Amikor elindul a rendszer, egy <errorname>ahc0: illegal
	    cable configuration</errorname> hibaüzenet jelenik meg.
	    A kábelek bekötésével semmilyen
	    gond nincs.  Mégis akkor mi a baj?</para>
	</question>

	<answer>
	  <para>Az alaplapon nem található olyan
	    áramkör, amely támogatja az automatikus
	    lezárást (<quote>automatic
	    termination</quote>).  A SCSI BIOS-ban az automatikus
	    lezárás helyett adjuk meg a megfelelõ
	    lezárást.  Az &man.ahc.4; meghajtója
	    nem képes rendesen érzékelni a
	    kábeleket, ha az alaplapon van ilyen
	    érzékelés (és így
	    automatikus lezárás).  A meghajtó
	    egyszerûen annyit feltételez, hogy ennek
	    támogatása csak akkor érhetõ el,
	    ha az EEPROM-ban megadtuk az <quote>automatic
	    termination</quote> beállítást.  A
	    megfelelõ kábeldetektáló
	    eszköz nélkül a meghajtó gyakran
	    rosszul állapítja meg a
	    lezárást, ami pedig így
	    veszélyezteti a SCSI busz
	    megbízhatóságát.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="mail-loopback">
	  <para>Miért küld a
	    <application>sendmail</application> <errorname>mail loops back
	    to myself</errorname> hibaüzenetet?</para>
	</question>

	<answer>
	  <para>Errõl részletesebben a <link xlink:href="&url.books.handbook;/mail-trouble.html#Q26.5.2.">kézikönyvben</link>
	    olvashatunk.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="remote-fullscreen">
	  <para>A távoli gépeken miért viselkednek
	    olyan furcsán a teljes képernyõs
	    alkalmazások?</para>
	</question>

	<answer>
	  <para>Elõfordulhat, hogy az adott távoli
	    gépen a terminál típusa nem
	    <literal>cons25</literal>, amire viszont a &os; konzolnak a
	    megfelelõ mûködéshez
	    szüksége lenne.</para>

	  <para>Ezt a problémát többféle
	    módon is meg tudjuk kerülni:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Mikor bejelentkezünk a távoli
		gépre, állítsuk a <envar>TERM</envar>
		környezeti változót az
		<literal>ansi</literal> vagy <literal>sco</literal>
		értékre, amibõl kiderül, hogy
		egyáltalán ismeri ezeket a
		termináltípusokat.</para>
	    </listitem>

	    <listitem>
	      <para>A &os; konzolban használjunk VT100
		emulátort, például a
		<application>screen</application> alkalmazást.  A
		<application>screen</application>
		segítségével egyetlen
		terminálról egyszerre több
		munkamenetet is tudunk indítani, de
		egyébként is egy nagyon jó program.
		Minden <application>screen</application> által
		létrehozott ablak VT100-as
		terminálként mûködik,
		ezért a távoli gépen a
		<envar>TERM</envar> környezeti
		változó nyugodtan
		beállítható a
		<literal>vt100</literal> értékre.</para>
	    </listitem>

	    <listitem>
	      <para>Tegyük hozzá a <literal>cons25</literal>
		bejegyzést a távoli gép
		terminálokat tároló
		adatbázisához.  Ez pontos módszere
		jelentõs mértékben függ az adott
		gépen található
		operációs rendszertõl.  Ebben
		leginkább az adott gépen
		található man oldalak tudnak
		segíteni.</para>
	    </listitem>

	    <listitem>
	      <para>Indítsunk el a &os; rendszert futtató
		gépen egy X szervert és a távoli
		géprõl egy X rendszerre
		íródott terminálemulátorral,
		például az <command>xterm</command> vagy
		az <command>rxvt</command> programmal jelentkezzük
		be.  A távoli gépen ekkor a
		<envar>TERM</envar> változó
		értéke vagy <literal>xterm</literal>, vagy
		pedig <literal>vt100</literal> lesz.</para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="pnp-not-found">
	  <para>A Plug and Play kártyákat miért nem
	    találja meg (vagy <literal>unknown</literal>
	    típusúként látja) a
	    &os;?</para>
	</question>

	<answer>
	  <para>Ennek az okait a következõ levélben
	    fejtette ki &a.peter; a &a.questions; tagjainak, amelyben
	    arra válaszolt, hogy egy belsõ modemet
	    miért nem észlel a rendszer miután
	    frissítették
	    &os;&nbsp;4.<replaceable>X</replaceable>-re (az
	    érthetõség kedvéért
	    szögletes zárójelek között
	    hozzáadtunk néhány
	    kiegészítést is).</para>

	  <note>
	    <para>Az eredeti szövegbõl készült
	      idézetet frissítettük.</para>
	  </note>

	  <blockquote>
	    <para>A PNP BIOS beállította [a modemet]
	      és magára hagyta valahol a portok
	      számára fenntartott címtérben,
	      így az ISA eszközök régi
	      típusú [3.<replaceable>X</replaceable>-ben
	      levõ] eszközpróbálgatásai
	      ott <quote>találták</quote> meg.</para>

	    <para>A 4.0 esetében azonban az ISA
	      eszközöket kezelõ kód már
	      sokkal inkább a PnP
	      támogatására koncentrál.
	      Korábban [a 3.X verziókban]
	      elõfordulhatott az is, hogy az ISA eszközök
	      keresése során a rendszer egy
	      <quote>kóbor</quote> eszközt talált,
	      majd ugyanazt megtalálta PnP eszközként
	      és ütköztek az így duplán
	      lefoglalni kívánt erõforrások.
	      Ennek kivédésére elõször
	      tehát letiltjuk a programozható
	      kártyák felderítését,
	      így ez a típusú kettõs
	      detektálás nem történhet meg.
	      Ez továbbá azt is jelenti, hogy a
	      támogatott PnP hardverek azonosítóit
	      elõre ismerni kell.  Ennek
	      hangolhatóságát már
	      tervbevettük.</para>
	  </blockquote>

	  <para>Tehát egy ilyen eszköz
	    mûködtetéséhez
	    szükségünk lesz a PnP
	    azonosítójára, valamint arra, hogy
	    felvegyük a felderítendõ PnP
	    eszközök ISA eszközök közé.
	    Ezt a &man.pnpinfo.8; segítségével
	    kérhetjük le, amely például egy
	    belsõ modem esetén a következõ
	    kimenetet fogja adni:</para>

	  <screen>&prompt.root; <userinput>pnpinfo</userinput>
Checking for Plug-n-Play devices...

Card assigned CSN #1
Vendor ID PMC2430 (0x3024a341), Serial Number 0xffffffff
PnP Version 1.0, Vendor Version 0
Device Description: Pace 56 Voice Internal Plug &amp; Play Modem

Logical Device ID: PMC2430 0x3024a341 #0
        Device supports I/O Range Check
TAG Start DF
    I/O Range 0x3f8 .. 0x3f8, alignment 0x8, len 0x8
        [16-bit addr]
    IRQ: 4  - only one type (true/edge)</screen>

	  <para>[a többi részt kihagytuk]</para>

	  <screen>TAG End DF
End Tag

Successfully got 31 resources, 1 logical fdevs
-- card select # 0x0001

CSN PMC2430 (0x3024a341), Serial Number 0xffffffff

Logical device #0
IO:  0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8
IRQ 5 0
DMA 4 0
IO range check 0x00 activate 0x01</screen>

	  <para>Innen a <literal>Vendor ID</literal> kezdetû sorra
	    lesz szükségünk.  A zárójelek
	    között szereplõ hexadecimális
	    szám (ami a példában a
	    <literal>0x3024a341</literal>) lesz az eszköz PnP
	    azonosítója, valamint a közvetlenül
	    ez elõtt szereplõ karakterlánc az egyedi
	    ASCII azonosítója
	    (<literal>PMC2430</literal>).</para>

	  <para>Ha a &man.pnpinfo.8; lefuttatásának
	    eredményeképpen megjelenõ lista nem
	    tartalmazza a kérdéses eszközt, akkor
	    helyette a &man.pciconf.8; használatával is
	    próbálkozhatunk.  Íme a
	    <command>pciconf -vl</command> parancs kimenete egy
	    integrált hangkártya esetében:</para>

	  <screen>&prompt.root; <userinput>pciconf -vl</userinput>
chip1@pci0:31:5:        class=0x040100 card=0x00931028 chip=0x24158086 rev=0x02 hdr=0x00
    vendor   = 'Intel Corporation'
    device   = '82801AA 8xx Chipset AC'97 Audio Controller'
    class    = multimedia
    subclass = audio</screen>

	  <para>Ebbõl a <varname>chip</varname>
	    változót, vagyis a
	    <literal>0x24158086</literal> értéket kell
	    felhasználnunk.</para>

	  <para>Ezt az információt (a <literal>Vendor
	    ID</literal> vagy a <varname>chip</varname>
	    értékét) ezután a
	    <filename>/usr/src/sys/dev/sio/sio_isa.c</filename>
	    állományba kell felvennünk.</para>

	  <para>Ehhez elõször is készítsünk
	    egy biztonsági másolatát a
	    <filename>sio_isa.c</filename>
	    állományról arra az esetre, ha
	    véletlenül valami rossz történne.
	    Ez azért is hasznunkra fog válni, mert
	    így tudunk egy javítást
	    mellékelni a hibajelentésünk mellé
	    (mert ugye írni fogunk róla
	    hibajelentést, ugye?).  Szóval, keressük
	    meg a <filename>sio_isa.c</filename>
	    állományban a következõ sort:</para>

	  <programlisting>static struct isa_pnp_id sio_ids[] = {</programlisting>

	  <para>Menjük lentebb egészen addig, amíg
	    nem találunk egy helyet, ahova be tudunk szúrni
	    egy bejegyzést az eszközünkhöz.  A
	    bejegyzések megadásának módja
	    lentebb látható, és a jobb oldalt
	    megjegyzésbe tett ASCII Vendor ID szerint
	    rendezettek, amelyek mellett még
	    megtalálható (amennyiben kifér) a
	    &man.pnpinfo.8; <emphasis>Device Description</emphasis>
	    kimenetében kapott érték is:</para>

	  <programlisting>{0x0f804f3f, NULL},     /* OZO800f - Zoom 2812 (56k Modem) */
{0x39804f3f, NULL},     /* OZO8039 - Zoom 56k flex */
{0x3024a341, NULL},     /* PMC2430 - Pace 56 Voice Internal Modem */
{0x1000eb49, NULL},     /* ROK0010 - Rockwell ? */
{0x5002734a, NULL},     /* RSS0250 - 5614Jx3(G) Internal Modem */</programlisting>

	  <para>A megfelelõ helyre ezután vegyük fel az
	    eszközünkhöz tartozó
	    hexadecimális Vendor ID értéket,
	    mentsük el az állományt, fordítsuk
	    újra a rendszermagot és indítsuk
	    újra vele a rendszerünket.  Ha mindent
	    jól csináltunk, akkor az eszköz
	    <filename>sio</filename> eszközként fog
	    megjelenni.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="nlist-failed">
	  <para>Miért keletkezik <errorname>nlist
	    failed</errorname> hiba például a
	    <command>top</command> vagy <command>systat</command>
	    parancsok futtatásakor?</para>
	</question>

	<answer>
	  <para>A gondot alapvetõen az okozza, hogy a
	    kérdéses alkalmazás valamiért egy
	    olyan rendszermagbeli szimbólumot keres, amit nem
	    talál.  Ez a típusú hiba a
	    következõkbõl eredhet:</para>

	  <itemizedlist>
	    <listitem>
	      <para>A rendszermag és a hozzá tartozó
		programok nincsenek szinkronban (vagyis
		fordítottunk egy új rendszermagot, de nem
		volt <buildtarget>installworld</buildtarget> vagy
		fordítva) és emiatt a szimbólumokat
		tároló táblázat nem teljesen
		úgy épül fel, ahogy azt az
		alkalmazás gondolja.  Ha errõl lenne
		szó, akkor egyszerûen nincs más
		teendõnk, mint befejezni a frissítést
		(ennek pontos részleteit lásd a
		<filename>/usr/src/UPDATING</filename>
		állományban).</para>
	    </listitem>

	    <listitem>
	      <para>Nem a <command>/boot/loader</command>, hanem
		közvetlenül a <filename>boot2</filename>
		(lásd &man.boot.8;)
		segítségével töltjük be a
		rendszermagot.  Noha alapvetõen semmilyen
		problémát nem nem okoz a
		<command>/boot/loader</command> kihagyása,
		általánosságban véve
		azért mégis jobban
		elérhetõvé tudja tenni a
		rendszermagban található
		szimbólumokat a felhasználói
		programok felé.</para>
	    </listitem>
	  </itemizedlist>
        </answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="connection-delay">
	  <para>Miért tart olyan sokáig
	    <command>ssh</command> vagy <command>telnet</command>
	    használatával csatlakozni a
	    számítógéphez?</para>
	</question>

	<answer>
	  <para>A tünet: nagyon sok idõ telik
	    aközött, amíg a TCP kapcsolat
	    felépül és a kliens bekéri a
	    jelszót (vagy a &man.telnet.1; esetében
	    amíg a bejelentkezõ képernyõ
	    megjelenik).</para>

	  <para>A betegség: nagyon valószínû,
	    hogy a késlekedést az okozza, amikor a szerver
	    megpróbálja a kliens IP-címét
	    feloldani hálózati névvé.  Sok
	    szerver, köztük a &os;-ben is
	    megtalálható <application>Telnet</application>
	    és <application>SSH</application> szerver is ezt
	    csinálja, többek közt azért, hogy
	    a rendszergazda számára el tudja
	    tárolni egy naplóban ezt a
	    hálózati nevet.</para>

	  <para>Az orvosság: ha az említett
	    jelenség minden olyan esetben jelentkezik, amikor a
	    számítógéprõl (mint
	    kliensrõl) valamilyen szerverhez csatlakozni akarunk,
	    akkor a kliens oldalán lesz a gond.  Ehhez
	    hasonlóan, ha csak egy adott szervernél
	    tapasztaljuk, akkor azzal a
	    számítógéppel
	    történhetett valami.</para>

	  <para>Amennyiben a problémákat a kliens okozza,
	    nem tehetünk mást, a névoldáson kell
	    úgy javítanunk, hogy a szerver
	    normálisan fel tudja oldani.  Ha helyi
	    hálózaton tapasztaljuk mindezt, akkor ez
	    már a szerver problémája és
	    olvassunk tovább.  Ellenkezõ esetben az internet
	    a felelõs, ezért nagyon
	    valószínû, hogy fel kell vennünk a
	    kapcsolatot az internet-szolgáltatónkkal
	    és segítséget kérni
	    tõlük a hiba
	    elhárításában.</para>

	  <para>Ha a problémát viszont a helyi
	    hálózaton található szerver
	    okozza, akkor úgy kell azt
	    beállítanunk, hogy a helyi neveket
	    képes legyen rendesen feloldani.  Ezzel kapcsolatban
	    a &man.hosts.5; és &man.named.8; man oldalakat
	    érdemes elolvasnunk.  Ha a probléma viszont az
	    interneten jelenik meg, akkor valószínû,
	    hogy a szerver névfeloldása nem üzemel
	    rendesen.  Nézzünk meg egy másik
	    gépet &mdash; például a
	    <systemitem>www.yahoo.com</systemitem> címet.  Ha ez sem
	    mûködik, akkor nálunk van a gond.</para>

	  <para>A &os; friss telepítését
	    követõen az is elképzelhetõ, hogy
	    egyszerûen csak hiányoznak a
	    tartományokkal és névszerverekkel
	    kapcsolatos megfelelõ adatok az
	    <filename>/etc/resolv.conf</filename>
	    állományból.  Ez gyakran okoz
	    késlekedést az <application>SSH</application>
	    mûködésében, mivel az <filename>/etc/ssh</filename>
	    könyvtárban található
	    <filename>sshd_config</filename> állományban
	    alapértelmezés szerint a
	    <literal>UseDNS</literal> beállítás
	    értéke <literal>yes</literal> (tehát a
	    névfeloldás használata
	    engedélyezett).  Ha valóban ez okozza a
	    problémát, akkor a pótoljuk az
	    <filename>/etc/resolv.conf</filename>
	    állományból hiányzó
	    adatokat vagy az <filename>sshd_config</filename>
	    állományban a <literal>UseDNS</literal>
	    értéke ideiglenesen legyen
	    <literal>no</literal>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="stray-irq">
	  <para>Mire utal a <errorname>stray IRQ</errorname>
	    (kóbor megszakítási kérés)
	    üzenet?</para>
	</question>

	<answer>
	  <para>A kóbor megszakítási
	    kéréseket jelzõ üzenetek
	    általában a hardveres megszakítási
	    kérések egyenletlenségeire utalnak,
	    ezen belül is leginkább olyan esetekre, amikor
	    az eszköz egy megszakítási
	    kérés nyugtázása
	    közepén eltávolítja az adott
	    kérést.</para>

	  <para>Három dolgot tehetünk ezzel
	    kapcsolatban:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Elviseljük ezeket a figyelmeztetéseket.
		Megszakítási
		kérésenként az elsõ öt
		üzenet után amúgy sem jelez
		többet a rendszer.</para>
	    </listitem>
	    <listitem>
	      <para>Ha platformunkhoz (mint például
		&i386;) tartozó <filename>intr_machdep.c</filename>
		állományban található
		<varname>MAX_STRAY_LOG</varname>
		értékét átírjuk
		<literal>5</literal>-rõl <literal>0</literal>-ra
		és így újrafordítjuk a
		rendszermagot, akkor ezzel teljesen letilthatjuk a
		figyelmeztetéseket.</para>
	    </listitem>
	    <listitem>
	      <para>Megszüntetjük az üzeneteket
		úgy, hogy csatlakoztatunk a rendszerhez egy olyan
		párhuzamos vonali eszközt, amely a 7-es
		IRQ-t használja, és rakunk fel
		hozzá egy PPP meghajtót (a legtöbb
		helyen egyébként ezzel lesz a gond),
		valamint a 15-ös IRQ-ra pedig rakunk egy
		IDE-meghajtót vagy más hasonló
		eszközt és telepítjük
		hozzá a megfelelõ meghajtót.</para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="file-table-full">
	  <para>Miért jelenik meg folyamatosan a <errorname>file:
	    table is full</errorname> üzenet a
	    rendszernaplóban?</para>
	</question>

	<answer>
	  <para>Ha ilyen hibaüzenetet látunk, akkor az arra
	    utal, hogy kifogytunk a rendszerünkben egyszerre
	    használható
	    állományleírókból.  A
	    probléma leírásával és
	    megoldásával kapcsolatban olvassuk el a
	    kézikönyvben a <link xlink:href="&url.books.handbook;/configtuning-kernel-limits.html#KERN-MAXFILES">kern.maxfiles
	    </link> változóról szóló
	    részt <link xlink:href="&url.books.handbook;/configtuning-kernel-limits.html">A
	    rendszermag korlátainak finomhangolása</link>
	    címû szakaszban.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="calcru-negative-runtime">
	  <para>Miért árasztják el
	    <errorname>calcru: negative runtime</errorname> vagy
	    <errorname>calcru: runtime went backwards</errorname>
	    üzenetek a konzolt?</para>
	</question>

	<answer>
	  <para>Ismert egy olyan probléma, hogy a BIOS-ban
	    engedélyezzük az &intel; Enhanced SpeedStep
	    technológiáját, akkor a rendszermag
	    ehhez hasonló <errorname>calcru</errorname>
	    üzeneteket kezd el küldözgetni:</para>

	  <screen>calcru: runtime went backwards from 6 usec to 3 usec for pid 37 (pagezero)
calcru: runtime went backwards from 6 usec to 3 usec for pid 36 (vmdaemon)
calcru: runtime went backwards from 170 usec to 138 usec for pid 35 (pagedaemon)
calcru: runtime went backwards from 553 usec to 291 usec for pid 15 (swi6: task queue)
calcru: runtime went backwards from 15521 usec to 10366 usec for pid 2 (g_event)
calcru: runtime went backwards from 25 usec to 12 usec for pid 11 (swi1: net)
calcru: runtime went backwards from 4417 usec to 3960 usec for pid 1 (init)
calcru: runtime went backwards from 2084385 usec to 1793542 usec for pid 1 (init)
calcru: runtime went backwards from 408 usec to 204 usec for pid 0 (swapper)</screen>

	  <para>Ennek oka, hogy az &intel; SpeedStep (EIST) egyes
	    alaplapokkal nem kompatibilis.</para>

	  <para>Megoldás: Tiltsuk le a BIOS-ban az EIST
	    használatát.  Ekkor még az
	    ACPI-alapú
	    processzorfrekvencia-szabályozás
	    továbbra is elérhetõ a &man.powerd.8;
	    használatán keresztül.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="computer-clock-skew">
	  <para>Miért jár rosszul az óra a
	    számítógépen?</para>
	</question>

	<answer>
	  <para>A számítógépnek kettõ
	    vagy több idõmérõ eszköze van,
	    és a &os; pont a rosszabbikat
	    választotta.</para>

	  <para>Adjuk ki a &man.dmesg.8; parancsot és
	    vizsgáljuk meg a <literal>Timecounter</literal>
	    kezdetû sorokat.  Ezek közül a &os; a
	    legnagyobb <quote>quality</quote> értékkel
	    rendelkezõt választotta.</para>

	  <screen>&prompt.root; <userinput>dmesg | grep Timecounter</userinput>
Timecounter "i8254" frequency 1193182 Hz quality 0
Timecounter "ACPI-fast" frequency 3579545 Hz quality 1000
Timecounter "TSC" frequency 2998570050 Hz quality 800
Timecounters tick every 1.000 msec</screen>

	  <para>Errõl a
	    <varname>kern.timecounter.hardware</varname> &man.sysctl.3;
	    változó lekérdezésével
	    tudunk ténylegesen megbizonyosodni:</para>

	  <screen>&prompt.root; <userinput>sysctl kern.timecounter.hardware</userinput>
kern.timecounter.hardware: ACPI-fast</screen>

	  <para>Elõfordulhat, hogy az ACPI-idõzítõ
	    hibás.  Ilyenkor az a legegyszerûbb, ha az
	    <filename>/etc/loader.conf</filename>
	    állományban letiltjuk az
	    ACPI-idõzítõ
	    használatát:</para>

	  <programlisting>debug.acpi.disabled="timer"</programlisting>

	  <para>Vagy a BIOS is tudja módosítani a TSC
	    idõzítõt &mdash; például
	    azért, hogy csökkentse a processzor
	    sebességét, amikor merül az
	    akkumulátor vagy energiatakarékos módra
	    vált.  A &os; sajnos nem figyel ezekre a
	    változtatásokra és elcsúszik az
	    idõméréssel.</para>

	  <para>Ahogy viszont az iménti példában is
	    látható, itt még az
	    <literal>i8254</literal> idõzítõ is
	    használható, méghozzá
	    úgy, hogy a
	    <varname>kern.timecounter.hardware</varname> &man.sysctl.8;
	    változó értékét
	    átállítjuk erre az
	    értékre:</para>

	  <screen>&prompt.root; <userinput>sysctl -w kern.timecounter.hardware=i8254</userinput>
kern.timecounter.hardware: TSC -&gt; i8254</screen>

	  <para>Innentõl kezdve a
	    számítógépünk már
	    sokkal pontosabban mutatja az idõt.</para>

	  <para>Ezt a változtatást úgy tudjuk
	    minden rendszerindítás során
	    automatikusan megtenni, ha felvesszük a
	    következõ sort az
	    <filename>/etc/sysctl.conf</filename>
	    állományba:</para>

	  <programlisting>kern.timecounter.hardware=i8254</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="null-null">
	  <para>A rendszer laptopon miért nem tudja rendesen
	    megtalálni a PC-kártyákat?</para>
	</question>

	<answer>
	  <para>Ez a probléma gyakran megjelenik olyan
	    laptopokon, amelyek egynél több
	    operációs rendszert is futtatnak, egyes
	    nem-BSD típusú rendszerek ugyanis hajlamosak a
	    hardvert inkonzisztens állapotban hagyni.  Emiatt a
	    &man.pccardd.8; parancs az adott kártyát
	    <errorname>"(null)""(null)"</errorname> néven
	    észleli a valós típusa helyett.</para>

	  <para>A hardvert innen teljesen csak úgy tudjuk
	    alapállapotába hozni, ha a PC-kártya
	    foglalatát áramtalanítjuk.  Ehhez ki
	    kell kapcsolnunk a laptopot.  (Tehát ne tegyük
	    se készenléti, se pedig hibernált
	    állapotba &mdash; teljesen ki kell kapcsolni.) A
	    PC-kártya ezután várhatóan
	    már mûködni fog.</para>

	  <para>Némely laptopok hazudnak arról, hogy
	    rendesen ki vannak-e kapcsolva.  Amennyiben az elõbbi
	    módszer nem válna be, próbáljuk
	    meg úgy, hogy kikapcsoljuk a gépet,
	    kivesszük az akkumulátort, várunk egy
	    keveset, visszarakjuk és újra
	    bekapcsoljuk.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="boot-read-error">
	  <para>Miért ad a &os; rendszertöltõje
	    <errorname>Read error</errorname> hibát és
	    áll meg a BIOS képernyõn?</para>
	</question>

	<answer>
	  <para>A &os; rendszertöltõje rosszul ismerte fel a
	    merevlemez geometriáját.  Ezt a &os; slice-ok
	    létrehozásakor és
	    módosításakor külön meg kell
	    adni az &man.fdisk.8; használatakor.</para>

	  <para>A meghajtóhoz tartozó megfelelõ
	    geometriai beállítások a
	    számítógép BIOS-ában
	    találhatóak.  Keressük meg az adott
	    meghajtó cilinder-fej-szektor (Cylinder/Head/Sector)
	    értékét.</para>

	  <para>A &man.sysinstall.8;
	    partíciószerkesztõjében a
	    <keycap>G</keycap> billentyû lenyomásával
	    tudjuk beállítani ezt.</para>

	  <para>Ekkor egy párbeszédablak jelenik meg, ahol
	    meg tudjuk adni a cilinderek, fejek és a
	    sávonkénti szektorok számát.
	    Ide perjelekkel elválasztva gépeljük e a
	    BIOS-ban talált értékeket.
	    Például ha a merevlemez geometriája
	    5000 cilinder, 250 fej és sávonként 60
	    szektor, akkor a <userinput>5000/250/60</userinput>
	    értéket kell megadnunk.</para>

	  <para>Az <keycap>Enter</keycap> billentyû
	    lenyomására ezek az értékek
	    beállítódnak, és a
	    <keycap>W</keycap> lenyomására pedig az
	    új partíciós tábla
	    kiíródik a lemezre.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="bootmanager-restore">
	  <para>Egy másik operációs rendszer
	    letörölte a boot managert.  Hogyan lehet
	    visszaállítani?</para>
	</question>

	<answer>
	  <para>Indítsuk el a &man.sysinstall.8; programot, majd
	    válasszuk a <guimenuitem>Configure</guimenuitem>
	    és <guimenuitem>Fdisk</guimenuitem>
	    menüpontokat.  A
	    partíciószerkesztõben a
	    <keycap>Space</keycap> billentyûvel tudjuk
	    kiválasztani azt a partíciót, amelyen
	    korábban a boot manager volt.  Ezután az
	    <keycap>W</keycap> billentyû lenyomásával
	    tudjuk a változtatásainkat lemezre menteni.
	    Ekkor egy menü jelenik meg, ahol a telepíteni
	    kívánt rendszertöltõt
	    választhatjuk ki.  Adjuk meg és ekkor
	    visszakerül a helyére.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="indefinite-wait-buffer">
	  <para>Mit jelent a <errorname>swap_pager: indefinite wait
	    buffer:</errorname> hibaüzenet?</para>
	</question>

	<answer>
	  <para>Ez arra utal, hogy egy futó program
	    megpróbált kiírni egy lapot a
	    memóriából a lemezre, azonban 20
	    másodperce már nem tudott
	    hozzáférni a lemezhez.  Ezt okozhatják
	    hibás szektorok a lemezen, a lemez hibás
	    kábelezése vagy esetleg valamilyen
	    lemezmûveletekkel kapcsolatos hardver
	    meghibásodása.  Amennyiben maga a
	    meghajtó a rossz, akkor az ilyen hibaüzenetek
	    mellett még más, a lemez hibás
	    mûködésére utaló
	    üzenetet is látnunk kell a
	    <filename>/var/log/messages</filename>
	    állományban vagy a <command>dmesg</command>
	    kimenetében.  Minden más esetben
	    érdemes a meghajtó csatlakozásait
	    és kábelezését
	    ellenõrizni.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="udma-icrc">
	  <para>Mik azok a <errorname>UDMA ICRC</errorname> hibák
	    és hogyan lehet ellenük tenni valamit?</para>
	</question>

	<answer>
	  <para>A &man.ata.4; meghajtó jelenti ezeket a
	    <errorname>UDMA ICRC</errorname> hibákat olyan esetekben,
	    amikor a merevlemezre vagy a merevlemezrõl
	    érkezõ DMA átvitel hibás.  A
	    meghajtó ilyenkor még párszor
	    megpróbálja megismételni a
	    mûveletet.  Amennyiben ezek a mûveletek is
	    meghiúsulnak, a DMA átvitel helyett a lassabb
	    PIO átviteli módra állítja
	    át a merevlemez felé irányuló
	    kommunikációt.</para>

	  <para>Ezt a problémát több
	    tényezõ is okozhatja, habár ennek a
	    leggyakoribb oka a hibás vagy rossz
	    kábelezés.  Ilyenkor mindig
	    ellenõrizzük, hogy a merevlemezhez
	    csatlakozó ATA-kábelek sértetlenek
	    és a használni kívánt
	    Ultra&nbsp;DMA átviteli módra alkalmasak.  Ha
	    cserélhetõ lemezes meghajtót
	    használunk, akkor kompatibilisnek is kell
	    lenniük.  Ez a gond akkor jelentkezhet, amikor
	    ugyanarra az ATA-csatornára egy
	    Ultra&nbsp;DMA&nbsp;66-os (vagy annál is gyorsabb)
	    és egy régebbi meghajtót
	    csatlakoztatunk.  Végezetül ezek a
	    hibaüzenetek arra is utalhatnak, hogy a meghajtó
	    meghibásodott.  A legtöbb gyártó
	    külön szoftver ajánl fel ennek
	    vizsgálatára, ezért ilyenkor
	    érdemes letesztelnünk az érintett
	    meghajtót, illetve amennyiben szükséges,
	    biztonsági másolatot készíteni
	    az adatainkról és kicserélni az
	    eszközt.</para>

	  <para>Az &man.atacontrol.8; segédprogram
	    használatával ellenõrizni tudjuk, hogy
	    jelenleg az egyes ATA-eszközök milyen DMA vagy PIO
	    módban mûködnek.  Erre a célra
	    különösen az <command>atacontrol mode
	    csatorna</command> parancsot
	    javasoljuk, amivel képesek vagyünk
	    megnézni az adott ATA-csatornára
	    csatlakozó eszközök átviteli
	    módjait.  Itt a <replaceable>csatorna</replaceable>
	    értéke nullától indul.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="lock-order-reversal">
	  <para>Mi az a <errorname>lock order
	    reversal</errorname>?</para>
	</question>

	<answer>
	  <para>Erre a kérdésre a választ a &os;-s
	    szakkifejezések gyûjteményében
	    találjuk meg a <link xlink:href="&url.books.handbook;/freebsd-glossary.html#LOR-GLOSSARY">LOR</link>
	    címszó alatt.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="called-with-non-sleepable-locks-held">
	  <para>Mit jelent a <errorname>Called ...  with the following
	    non-sleepable locks held</errorname> üzenet?</para>
	</question>

	<answer>
	  <para>Ez az üzenet arra utalhat, hogy egy
	    függvény lepihent miközben nála volt
	    egy mutex (vagy más, nem pihentethetõ)
	    típusú zárolás.</para>

	  <para>Azért keletkezik ilyen hiba, mert a mutexeket nem
	    úgy tervezték, hogy hosszabb ideig is meg
	    lehessen tartani, kizárólag csak rövid
	    idõtartamra vonatkozó
	    szinkronizációt lehet velük
	    végezni.  Ez a programozói megegyezés
	    lehetõvé teszi az eszközmeghajtók
	    számára, hogy a megszakítások
	    közben mutexek segítségével
	    képesek legyenek szinkronizálni a rendszermag
	    többi részével.  A
	    megszakítások (&os; alatt) pedig nem
	    pihenhetnek.  Ezért a rendszermagon belül
	    semmilyen olyan alrendszer nem blokkolódhat
	    huzamosabb ideig, amelyik mutexet tart
	    magánál.</para>

	  <para>Ezeket a hibákat úgy tudjuk
	    elcsípni, ha olyan ellenõrzéseket
	    teszünk a rendszermagba, amelyek jeleznek a
	    &man.witness.4; alrendszernek, hogy küldjön
	    figyelmeztetést vagy akár végzetes
	    hibát (a rendszer
	    konfigurációjától
	    függõen) azokban a helyzetekben, amikor egy
	    sejthetõen hosszabb ideig blokkolt hívás
	    tart magánál egy mutexet.</para>

	  <para>Röviden úgy foglalhatnánk össze,
	    hogy ezek a hibák alapvetõen nem
	    végzetesek, de egy kis balszerencsével az
	    egyszerû kis megakadásoktól kezdve a
	    teljes lefagyásig szinte bármilyen
	    hibáért felelõsek lehetnek.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="touch-not-found">
	  <para>A
	    <buildtarget>buildworld</buildtarget>/<buildtarget>installworld</buildtarget>
	    miért áll le <errorname>touch: not
	    found</errorname> hibával?</para>
	</question>

	<answer>
	  <para>Ez a hibaüzenet nem azt jelenti, hogy a
	    &man.touch.1; segédprogram nem található,
	    hanem inkább azt, hogy az érintett
	    állományok dátuma a jövõre
	    állítódott be.  Ha a CMOS
	    óránkat a helyi idõ szerint
	    állítottuk be, akkor
	    egyfelhasználós módban indítsuk
	    újra a rendszert és a
	    <command>adjkerntz&nbsp;-i</command> parancs
	    kiadásával állítsuk be a
	    rendszermag óráját.</para>
	</answer>
      </qandaentry>
    </qandaset>

  </chapter>

  <chapter xml:id="commercial" xml:lang="hu">
    <title>Kereskedelmi alkalmazások</title>

      <note>
	<para>Ez a fejezet még nagyon rövid, de
	  természetesen reméljük, hogy a
	  különbözõ cégek hamarosan
	  bõvíteni fogják!  :) A &os;
	  fejlesztõinek ezzel kapcsolatban semmilyen anyagi
	  érdekük nincs, csupán szeretnék
	  felsorolni a nyilvánosan is elérhetõ
	  szolgáltatásokat (de úgy
	  érezzük, hogy a &os; kereskedelmi
	  irányú megközelítése a &os;
	  fejlõdésére is jó hatással
	  lehet hosszabb távon).  Javasoljuk minden kereskedelmi
	  fejlesztõnek, hogy küldjék be ide is a
	  saját kérdéseiket.  <link xlink:href="&url.base;/commercial/index.html">A gyártók
	  honlapján</link> olvashatjuk a teljes
	  listájukat.</para>
      </note>

    <qandaset>
      <qandaentry>
	<question xml:id="officesuite">
	  <para>Honnan lehet a &os;-hez irodai programcsomagokat
	    szerezni?</para>
	</question>

	<answer>
	  <para>A nyílt forráskódú
	    <application>OpenOffice.org</application>
	    irodai programcsomag &os; alatt natívan is
	    futtatható.  <application>Oracle Open Office</application>
	    linuxos változata, amely az
	    <application>OpenOffice.org</application> zárt
	    forráskódú, továbbfejlesztett
	    változata, szintén mûködik &os;
	    alatt.</para>

	  <para>A &os; ezeken kívül még számos
	    szövegszerkesztõt,
	    táblázatkezelõt és rajzprogramot
	    is tartalmaz a Portgyûjteményében.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="motif">
	  <para>Honnan lehet a <application>&motif;</application>-ot
	    szerezni a &os;-hez?</para>
	</question>

	<answer>
	  <para>A The Open Group kiadta a
	    <application>&motif;&nbsp;2.2.2</application>
	    változatának
	    forráskódját.  Ez az <package>x11-toolkits/open-motif</package>
	    csomagból vagy portból érhetõ el.
	    A telepítésével kapcsolatban olvassuk
	    el a kézikönyv <link xlink:href="&url.books.handbook;/ports.html">portokról szóló részét</link>.
	    </para>

	  <note>
	    <para>Az <application>Open&nbsp;&motif;</application>
	      kizárólag csak <link xlink:href="http://www.opensource.org/">nyílt forráskódú</link>
	      operációs rendszereken
	      terjeszthetõ.</para>
	  </note>

	  <para>Ezenkívül még
	    használhatóak a
	    <application>&motif;</application> kereskedelmi
	    változatai is.  Ezek viszont már nem
	    ingyenesek, de a licencük megengedi azt, hogy
	    zárt forráskódú szoftverekben is
	    felhasználhassuk.  Az <link linkend="apps2go">Apps2go</link>nál
	    érdeklõdjünk a &os;-re elérhetõ
	    legolcsóbb
	    <application>&motif;&nbsp;2.1.20</application> ELF (&i386;)
	    típusú terjesztésekkel kapcsolatban.
	    <anchor xml:id="apps2go"/></para>

	  <para>Kétfajta terjesztés létezik, a
	    <quote>fejlesztõi változat</quote> és a
	    <quote>futásidejû változat</quote>
	    (valamivel olcsóbb).  Az egyes terjesztésekben
	    a következõk találhatóak:</para>

	    <itemizedlist>
	      <listitem>
		<para><application>OSF/&motif; manager</application>,
		  <application>xmbind</application>,
		  <application>panner</application>,
		  <application>wsm</application></para>
	      </listitem>

	      <listitem>
		<para>Fejlesztõi készlet: uil, mrm, xm,
		  xmcxx, include és
		  <application>Imake</application>
		  állományok</para>
	      </listitem>

	      <listitem>
		<para>Statikus és dinamikus ELF
		  könyvtárak</para>
	      </listitem>

	      <listitem>
		<para>Példa alkalmazások</para>
	      </listitem>
	    </itemizedlist>

	  <para>A megrendelés során ne felejtsük el
	    megadni, hogy a <application>&motif;</application> melyik &os;
	    verzióhoz készített
	    változatát kérjük (valamint az
	    architektúrát se)!  Az
	    <emphasis>Apps2go</emphasis> NetBSD és OpenBSD
	    rendszerekkel is foglalkozik, ezeket a változatokat
	    jelenleg csak FTP-n keresztül lehet
	    elérni.</para>

	    <variablelist>
	      <varlistentry>
		<term>További információk</term>
		<listitem>
		  <para><link xlink:href="http://www.apps2go.com/">Az Apps2go honlapja</link></para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term>illetve</term>
		  <listitem>
		    <para>
		      <email>sales@apps2go.com</email> vagy
		      <email>support@apps2go.com</email>
		      </para>
		  </listitem>
		</varlistentry>

		<varlistentry>
		  <term>vagy</term>
		  <listitem>
		    <para>telefonon: (817)&nbsp;431&nbsp;8775 és
		      +1&nbsp;817&nbsp;431-8775</para>
		  </listitem>
		</varlistentry>
	      </variablelist>

	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="cde">
	  <para>Honnan lehet &os;-re <application>CDE</application>-t
	    szerezni?</para>
	</question>

	<answer>
	  <para>A <emphasis>Xi Graphics</emphasis> korábban
	    kínált fel <application>CDE</application>-t
	    &os;-hez, de manapság már nem foglalkoznak
	    ezzel.</para>

	  <para>A <link xlink:href="http://www.kde.org/"><application>KDE</application></link>
	    a <application>CDE</application>-hez nagyon sok tekintetben
	    hasonló nyílt forráskódú
	    X11 munkakörnyezet, de érdemes
	    pillanatást vetnünk az <link xlink:href="http://www.xfce.org"><application>xfce</application></link>-re
	    is.  A <application>KDE</application> és az
	    <application>xfce</application> egyaránt
	    megtalalálható a <link xlink:href="&url.base;/ports/index.html">portok között</link>.
	    </para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="database-systems">
	  <para>Használhatóak adatbázisrendszerek
	    &os; alatt?</para>
	</question>

	<answer>
	  <para>Igen!  A &os; hivatalos honlapján
	    megtaláljuk ezeket a <link xlink:href="&url.base;/commercial/software_bycat.html#CATEGORY_DATABASE">
	    kereskedelmi gyártók</link>
	    között.</para>

	  <para>Érdemes még megnéznünk a
	    Portgyûjteményeben a <link xlink:href="&url.base;/ports/databases.html">adatbázisokat</link>
	    tartalmazó szekciót.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="oracle-support">
	  <para>Az <application>&oracle;</application> fut &os;
	    alatt?</para>
	</question>

	<answer>
	  <para>Igen.  A <uri xlink:href="http://www.shadowcom.net/freebsd-oracle9i/">http://www.shadowcom.net/freebsd-oracle9i/</uri>
	    oldalon találunk arról
	    információt, hogyan telepíthetjük
	    &os;-re az <application>&oracle;</application> &linux;
	    változatát.</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter xml:id="applications" xml:lang="hu">
    <title>Felhasználói alkalmazások</title>

    <qandaset>
      <qandaentry>
	<question xml:id="user-apps">
	  <para>Hol vannak a felhasználói
	    programok?</para>
	</question>

	<answer>
	  <para>Nézzünk szét a <link xlink:href="&url.base;/ports/index.html">portok között</link>
	    és láthatjuk, hogy milyen szoftvereket
	    portoltak eddig &os;-re.  A listában pillanatnyilag
	    &os.numports; port található és naponta
	    növekszik, ezért érdemes folyamatosan
	    figyelni vagy az új portokról úgy is
	    értesülhetünk rendszeresen, ha
	    feliratkozunk a &a.announce; címére.</para>

	  <para>A legtöbb portnak mûködnie kell a
	    6.<replaceable>X</replaceable>,
	    7.<replaceable>X</replaceable> és
	    8.<replaceable>X</replaceable> ágak használata
	    esetén is.  Mindegyik &os; kiadás
	    elkészítésekor készül egy
	    pillanatfelvétel a portokat tartalmazó
	    könyvtárról és bekerül a
	    <filename>ports/</filename>
	    könyvtárba.</para>

	  <para>Ezenkívül még <quote>csomagok</quote>
	    is rendelkezésünkre állnak, amelyek
	    lényegében egy tömörített
	    bináris terjesztési formát takarnak,
	    némi plusz információval
	    kiegészítve az egyéni
	    telepítésekhez
	    elvégzéséhez.  A csomagok könnyen
	    telepíthetõek és
	    eltávolíthatóak anélkül,
	    hogy pontosan ismernénk a benne
	    található állományok összes
	    apró részletét.</para>

	  <para>A különbözõ csomagokat a
	    &man.sysinstall.8; programban (a
	    <guimenuitem>Configure</guimenuitem> menün belül)
	    található <guimenuitem>Packages</guimenuitem>
	    menüpontban tudjuk telepíteni, vagy
	    meghívjuk meg a &man.pkg.add.1; parancsot.  A
	    csomagokat leginkább <filename>.tbz</filename>
	    kiterjesztésükrõl lehet megismerni,
	    valamint a telepítõ CD-ken a <filename>packages/All</filename>
	    könyvtárban találhatóak.  Az
	    interneten keresztül is le tudjuk tölteni ezek
	    közül a &os; különbözõ
	    verzióihoz tartozó változatukat a
	    hozzánk legközelebbi
	    tükrözésekrõl:</para>

	    <variablelist>
	      <varlistentry>
		<term>6.<replaceable>X</replaceable>-RELEASE/6-STABLE
		  esetén:</term>
		<listitem>
		  <para><link xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-6-stable/">
		    ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-6-stable/</link></para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term>7.<replaceable>X</replaceable>-RELEASE/7-STABLE
		  esetén:</term>
		<listitem>
		  <para><link xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-7-stable/">
		    ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-7-stable</link></para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term>8.<replaceable>X</replaceable>-RELEASE/8-STABLE
		  esetén:</term>
		<listitem>
		  <para><link xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-8-stable/">
		    ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-8-stable</link></para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term>9-CURRENT esetén:</term>
		<listitem>
		  <para><link xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-9-current/">
		    ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-9-current</link></para>
		</listitem>
	      </varlistentry>
	    </variablelist>

	  <para>Nem mindegyik port érhetõ el
	    csomagként, mivel folyamatosan készülnek az
	    újabbak.  Ezért mindig érdemes bizonyos
	    idõközönként ellenõrizni a
	    központi <link xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/">ftp.FreeBSD.org</link>
	    oldalon található csomagokat.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="configure-inn">
	  <para>Hogyan tudjuk beállítani az INN (Internet
	    News) szolgáltatást a
	    gépünkön?</para>
	</question>

	<answer>
	  <para>Telepítsük az <package>news/inn</package> csomagot vagy portot
	    és utána kiindulásképpen
	    nézzük meg <link xlink:href="http://www.eyrie.org/~eagle/faqs/INN.html">az INN
	      GYIK-ot</link>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="java">
	  <para>A &os; rendelkezik &java;
	    támogatással?</para>
	</question>

	<answer>
	  <para>Igen.  Látogassunk el a <link xlink:href="&url.base;/java/index.html">http://www.FreeBSD.org/java/</link>
	    oldalra.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ports-4x">
	  <para>Miért nem fordul egy port a
	    6.<replaceable>X</replaceable>-STABLE,
	    7.<replaceable>X</replaceable>-STABLE vagy
	    8.<replaceable>X</replaceable>-STABLE változatot
	    futtató gépeken?</para>
	</question>

	<answer>
	  <para>Ha olyan &os; verziónk van, amely egy kicsit
	    lemaradt az aktuális <emphasis>-CURRENT</emphasis>
	    vagy <emphasis>-STABLE</emphasis> ágak
	    mögött, akkor valószínûleg
	    frissítenünk kell a
	    Portgyûjteményünket.  Ennek
	    részleteirõl a Porterek
	    kézikönyvében, a <link xlink:href="&url.books.porters-handbook.en;/keeping-up.html">Keeping Up</link>
	    címû részben olvashatunk (angolul).  Ha
	    viszont rendszerünkben minden a lehetõ
	    legfrissebb, akkor elõfordulhat, hogy valaki olyan
	    változtatást rakott fel a porthoz, amely a
	    <emphasis>-CURRENT</emphasis> esetén
	    mûködik, de a <emphasis>-STABLE</emphasis>
	    változatban már nem.  Ilyenkor
	    feltétlenül küldjünk egy
	    hibajelentést a &man.send-pr.1; paranccsal, hiszen a
	    Portgyûjteménynek a -CURRENT és -STABLE
	    ágak esetén egyaránt mûködnie
	    kell.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="make-index">
	  <para>A <command>make index</command>
	    paranccsal nem sikerült létrehozni az
	    <filename>INDEX</filename> állomyánt.  Mi a
	    gond?</para>
	</question>

	<answer>
	  <para>Elsõként mindig ellenõrizzük, hogy
	    a Portgyûjteményünk a lehetõ
	    legfrissebb.  A legfrissebb változatnál
	    jelentkezõ <filename>INDEX</filename>
	    készítési hibák mindig szem
	    elõtt vannak, ezért általában
	    gyorsan megjavulnak.</para>

	  <para>Ha viszont egy friss verzióval rendelkezünk,
	    akkor elképzelhetõ, hogy egy másik
	    hibával kerültünk szembe.  A
	    <command>make index</command>
	    parancsnak van egy olyan hibája, amely miatt nem
	    képes a Portgyûjtemény hiányos
	    példányával dolgozni.
	    Feltételezi ugyanis, hogy az összes olyan port
	    megtalálható a rendszerünkben, amely
	    telepítése szükséges az adott
	    porthoz.  Ennek megértéséhez most
	    képzeljük el, hogy megvan az
	    <filename>ize/mize</filename> port a lemezen, amely
	    függ az <filename>aze/maze</filename> porttól,
	    és emiatt az <filename>aze/maze</filename> portnak
	    és függõségeinek is rajta kell
	    lennie a lemezünkön.  Minden más esetben a
	    <command>make index</command> nem
	    tud összegyûjteni elegendõ
	    információt ahhoz, hogy létre tudja
	    hozni a függõségi gráfot.</para>

	  <para>Ez különösen olyan &os;
	    felhasználókkal fordul elõ, akik a
	    &man.cvsup.1; (vagy &man.csup.1;)
	    használatával frissítik a
	    Portgyûjteményüket, de a
	    <filename>refuse</filename> állományokban
	    kizártak néhány
	    kategóriát.  Elméletben
	    természetesen ki lehet zárni akármilyen
	    kategóriát, azonban a gyakorlat azt mutatja,
	    hogy ez szinte lehetetlen, mivel túlságosan
	    sok port függ más kategóriákban
	    található portoktól.  Amíg
	    valaki meg nem oldja ezt a problémát, addig
	    fogadjuk el általános szabálynak, hogy
	    az <filename>INDEX</filename>
	    létrehozásához a teljes
	    Portgyûjteménnyel rendelkeznünk
	    kell.</para>

	  <para>Néhány ritka esetben még
	    elõfordulhat, hogy az <filename>INDEX</filename>
	    azért nem jön létre, mert a
	    <filename>make.conf</filename> állományban
	    megadtunk valamilyen
	    <varname>WITH_<replaceable>*</replaceable></varname> vagy
	    <varname>WITHOUT_<replaceable>*</replaceable></varname>
	    változót.  Ha úgy érezzük,
	    hogy ez okozhatja a problémát, akkor
	    próbáljuk meg elõször ezen
	    változók nélkül
	    létrehozatni az <filename>INDEX</filename>
	    állományt és csak utána
	    jelenteni a hibát a &a.ports;
	    címére.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="cvsup-in-base">
	  <para>A <application>CVSup</application> miért nincs a
	    &os; forrásai között?</para>
	</question>

	<answer>
	  <para>A &os; alaprendszerét úgy
	    állították össze, hogy saját
	    magát legyen képes legyen lefordítani,
	    vagyis az egész operációs rendszer
	    elõállítható legyen
	    néhány alapvetõ eszköz
	    használatával.  Ezért a források
	    között leginkább csak az
	    található meg, ami feltétlenül
	    kell a források lefordításához.
	    Ilyen például a C fordító
	    (&man.gcc.1;), a &man.make.1;, &man.awk.1; és a
	    többi.</para>

	  <para>Mivel a <application>CVSup</application> a Modula-3
	    programozási nyelven íródott, csak
	    úgy tudnánk beletenni a &os; alaprendszerbe,
	    ha hozzávennénk és
	    karbantartanánk egy Modula-3 fordítót
	    is.  Ezzel együtt viszont növekedne a &os;
	    forrása, amelyet aztán karban is kellene
	    tartani.  Ezért mind a fejlesztõk, mind pedig a
	    felhasználók számára
	    egyszerûbb, ha a <application>CVSup</application> egy
	    külön portként érhetõ el a
	    rendszerhez.  Ez viszont gyorsan telepíthetõ a
	    &os; telepítõ CD-ken található
	    csomagokból.</para>

	  <para>Azonban a &os;&nbsp;6.2-RELEASE
	    megjelenésétõl kezdve a &os;
	    felhasználók nem maradnak integrált
	    <application>CVSup</application> kliens nélkül.
	    &a.mux; munkájának köszönhetõen
	    a <application>CVSup</application> alkalmazásnak
	    elkészült a C nyelven újraírt
	    változata, a &man.csup.1;, amely most már az
	    alaprendszer része.  Noha jelenleg nem még nem
	    képes mindarra, amire a
	    <application>CVSup</application>, elegendõ (és
	    nagyon gyors!) ahhoz, hogy a forrásainkat frissen
	    tartsuk.  A 6.2 elõtt kiadott rendszerek
	    esetében ezt portból vagy csomagból is
	    felrakhatjuk (lásd <package>net/csup</package>).</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ports-update">
	  <para>A forrásokon kívül a
	    telepített portokat is lehet valahogy
	    frissíteni?</para>
	</question>

	<answer>
	  <para>A &os; alaprendszere ehhez nem kínál fel
	    semmilyen eszközt, de léteznek olyan
	    segédeszközök, amelyekkel valamennyire meg
	    tudjuk könnyíteni a frissítés
	    folyamatát.  További segédprogramok
	    telepítésével pedig a portok
	    kezelését tudjuk tovább
	    egyszerûsíteni, amirõl a &os;
	    kézikönyv <link xlink:href="&url.books.handbook;/ports-using.html">A portok frissítése</link>
	    címû szakaszában olvashatunk
	    bõvebben.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ports-major-upgrade">
	  <para>Minden nagyobb
	    verziófrissítésnél újra
	    kell fordítani az összes telepített portot
	    a rendszeren?</para>
	</question>

	<answer>
	  <para>Mindenképpen!  Noha látszólag a
	    frissített rendszeren is remekül futnak a
	    korábbi verzióra telepített
	    alkalmazások, könnyen elõfordulhat, hogy az
	    újabb portok telepítésékor vagy
	    a meglevõek frissítésekor
	    véletlenszerû összeomlásokat vagy
	    egyéb hibákat tapasztalunk.</para>

	  <para>Ne felejtsük el, hogy a rendszer
	    frissítésekor a különféle
	    osztott könyvtárak, betölthetõ modulok
	    és a rendszer egyéb komponensei is
	    lecserélõdnek.  Ezért a régebbi
	    változataikhoz fordított alkalmazások
	    egyáltalán nem fognak elindulni vagy nem
	    mûködnek rendesen.</para>

	  <para>Ezzel kapcsolatban olvassuk el a &os;
	    kézikönyvének <link xlink:href="&url.books.handbook;/updating-upgrading-freebsdupdate.html#FREEBSDUPDATE-UPGRADE">frissítérõl
	      szóló szakaszát</link>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ports-minor-upgrade">
	  <para>Minden kisebb
	    verziófrissítésnél újra
	    kell fordítani az összes telepített portot
	    a rendszeren?</para>
	</question>

	<answer>
	  <para>Általánosságban véve nem.  A
	    &os; fejlesztõi ugyanis mindent megtesznek azért,
	    hogy ugyanazon a fõ fejlesztési ágon
	    belüli verziók között megmaradjon a
	    bináris szintû kompatibilitás.  Az
	    esetleges kivételeket pedig dokumentálni
	    szokták a kiadásokhoz tartozó
	    jegyzetekben, ahol többnyire megadják az adott
	    változtatáshoz tartozóan a
	    követendõ tanácsokat.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="minimal-sh">
	  <para>A <command>/bin/sh</command> miért ilyen
	    egyszerû?  A &os;-ben miért nincs
	    <command>bash</command> vagy valamilyen más rendes
	    parancsértelmezõ?</para>
	</question>

	<answer>
	  <para>Mert a &posix; szerint lennie kell egy ilyen
	    parancsértelmezõnek.</para>

	  <para>A valamivel bonyolultabb válasz: sokan
	    szeretnének olyan szkripteket írni, amelyek
	    több rendszer közt is átvihetõek.
	    Ezért a &posix; a parancsértelmezõkre
	    és a segédprogramokra vonatkozó
	    parancsokat igen részletesen tárgyalja.  A
	    legtöbb ilyen szkriptet a Bourne-féle
	    parancsértelmezõben készítik,
	    és több fontos programozói felület
	    (&man.make.1;, &man.system.3;, &man.popen.3; és ezek
	    magasabb szintû, például Perl és
	    Tcl nyelvi megfelelõi) a
	    Bourne-parancsértelmezõ
	    használatán alapszik.  Mivel a
	    Bourne-parancsértelmezõ használata ilyen
	    széles körben elterjedt, fontos, hogy gyorsan
	    induljon, elõre megjósolható legyen a
	    mûködése és ne foglaljon
	    túlságosan sok memóriát.</para>

	  <para>A jelenlegi implementáció igyekszik ezek
	    közül az elvárások közül
	    egyszerre a lehetõ legtöbbet teljesíteni.
	    A <command>/bin/sh</command> programot csak úgy
	    tudjuk a megfelelõ méreten tartani, ha nem
	    tesszük bele az összes többi
	    parancsértelmezõben megtalálható
	    kényelmi funkciót.  Pontosan ezért
	    találhatjuk meg viszont a
	    Portgyûjteményben a többi,
	    például a <command>bash</command>,
	    <command>scsh</command>, <command>tcsh</command> és
	    <command>zsh</command> parancsértelmezõket.
	    (Ezek konkrét memóriahasználatát
	    össze is tudjuk vetni, ha a <command>ps
	    -u</command> parancs kimenetének
	    <quote>VSZ</quote> és <quote>RSS</quote> oszlopait
	    megnézzük.)</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="netscape-slow-startup">
	  <para>A <application>&netscape;</application> és az
	    <application>Opera</application> indítása
	    miért tart olyan sokáig?</para>
	</question>

	<answer>
	  <para>Erre az az általános válasz, hogy a
	    névfeloldás valószínûleg
	    rosszul mûködik a rendszerünkön.  A
	    <application>&netscape;</application> és az
	    <application>Opera</application> is ellenõrzi a
	    névfeloldást az indulásakor.
	    Ezért a böngészõ egészen
	    addig nem jelenik meg az asztalon, amíg
	    választ nem kap vagy rá nem jön, hogy
	    nincs aktív hálózati kapcsolat.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ports-base-update">
	  <para>Ha a <application>CVSup</application>
	    használatával frissítjük a
	    Portgyûjteményt, akkor sok port nem fordul le
	    mindenféle rejtélyes hibaüzenet
	    kíséretében!  Valami nagy baj van a
	    Portgyûjteménnyel?</para>
	</question>

	<answer>
	  <para>Ha úgy korábban úgy
	    frissítettük a <application>CVSup</application>
	    használatával a Portgyûjteményt,
	    hogy nem adtuk meg a <literal>ports-all</literal>
	    <application>CVSup</application> algyûjteményt,
	    akkor a <literal>ports-base</literal>
	    algyûjteményt is <emphasis>mindig</emphasis>
	    frissítenünk kell!  Ennek okairól <link xlink:href="&url.books.handbook;/cvsup.html#CVSUP-COLLEC-PBASE-WARN">a
	    kézikönyvben</link> olvashatunk.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="midi-sound-files">
	  <para>Hogyan lehet MIDI állományokból
	    audio CD-t készíteni?</para>
	</question>

	<answer>
	  <para>Ha MIDI állományokból akarunk audio
	    CD-t készíteni, akkor elõször
	    telepítsük fel a
	    Portgyûjteménybõl a <package>audio/timidity++</package> portot, majd
	    kézzel tegyük hozzá Eric A.  Welsh GUS
	    patch-eit, melyek a <uri xlink:href="http://alleg.sourceforge.net/digmid.html">http://alleg.sourceforge.net/digmid.html</uri>
	    címrõl tölthetõek le.  Miután a
	    <application>TiMidity++</application> sikeresen
	    felkerült a rendszerünkre, a MIDI
	    állományokat a következõ paranccsal
	    tudjuk átkonvertálni WAV
	    állományokra:</para>

	  <screen>&prompt.user; <userinput>timidity -Ow -s 44100 -o /tmp/juke/01.wav 01.mid</userinput></screen>

	  <para>A WAV állományok ezek után
	    tetszõleges formátumba
	    konvertálhatóak tovább vagy
	    készíthetõ belõlük egy audio
	    CD, ahogy azt a <link xlink:href="&url.books.handbook;/creating-cds.html">&os; kézikönyvben</link>
	    is olvashatjuk.</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter xml:id="kernelconfig" xml:lang="hu">
    <title>A rendszermag beállítása</title>

    <qandaset>
      <qandaentry>
	<question xml:id="make-kernel">
	  <para>Nehéz testreszabni a rendszermagot?</para>
	</question>

	<answer>
	  <para>Egyáltalán nem!  Ezzel kapcsolatban
	    olvassuk el <link xlink:href="&url.books.handbook;/kernelconfig.html">a &os;
	    kézikönyv rendszermag
	    beállításairól
	    szóló részét</link>.</para>

	    <note>
	      <para>Az új <filename>kernel</filename>
		állomány a hozzá tartozó
		modulokkal együtt a <filename>/boot/kernel</filename>
		könyvtárba települ, míg a
		rendszermag korábbi változata és a
		moduljai a <filename>/boot/kernel.old</filename>
		könyvtárba kerül át, így
		ha netalán valamit elrontottunk volna, akkor a
		rendszermag korábbi változatának
		betöltésével
		lehetõségünk lesz kijavítani a
		hibát.</para>
	    </note>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="missing-hw-float">
	  <para>A rendszermag nem fordul le, mert a
	    <literal>_hw_float</literal> nem található.
	    Hogyan lehet megoldani ezt a problémát?</para>
	</question>

	<answer>
	  <para>Ez valószínûleg azért
	    következett be, mert eltávolítottuk az
	    <filename>npx0</filename> (lásd &man.npx.4;)
	    támogatást a rendszermag
	    beállításai közül, mert a
	    rendszerünkben nincs matematikai társprocesszor.
	    Az <filename>npx0</filename> eszköz
	    jelenléte azonban
	    <emphasis>kötelezõ</emphasis>.  Valahol a
	    gépünkben lennie kell olyan eszköznek,
	    amely a lebegõpontos számok hardveres
	    kezelését végzi, annak ellenére,
	    hogy nem egy különálló eszköz,
	    ahogy régen a 386-osoknál volt.  A
	    rendszermagban szerepelnie <emphasis>kell</emphasis> az
	    <filename>npx0</filename> eszköznek.  Ha
	    netalán még sikerülne is
	    <filename>npx0</filename> támogatás
	    nélkül fordítanunk egy rendszermagot,
	    akkor sem tud elindulni.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="why-kernel-big">
	  <para>Miért ilyen nagy a rendszermag mérete
	    (közel 10&nbsp;MB)?</para>
	</question>

	<answer>
	  <para>Nagyon valószínû, hogy a
	    rendszermagunk <emphasis>debug módban</emphasis>
	    készült el.  A debug módú
	    rendszermagokban rengeteg olyan szimbólum
	    található, amely hasznos lehet a hibák
	    keresése és a rendszer vizsgálata
	    során, ezért emiatt jelentõs
	    mértékben növekszik a mérete.
	    Emiatt nem kell aggódnunk, mert egy
	    hibakeresésre felkészített rendszermag
	    egyáltalán nem vagy csak egy kicsivel lassabb,
	    mint a hagyományos változat, illetve a
	    rendszer összeomlásakor mindig mindig
	    szükségünk lehet ezekre a debug
	    információkra.</para>

	  <para>Ha viszont kevés a lemezterület vagy
	    egyszerûen csak nem akarunk debug módú
	    rendszermagot akarunk futtatni, akkor a
	    következõkre kell figyelnünk:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Vegyük ki a rendszermag
		konfigurációs
		állományából a
		következõ sort:</para>

	      <programlisting>makeoptions DEBUG=-g</programlisting>
	    </listitem>

	    <listitem>
	      <para>A &man.config.8; használata során ne
		használjuk a <option>-g</option>
		beállítást.</para>
	    </listitem>
	  </itemizedlist>

	  <para>A fentiek közül akármelyiket is
	    választjuk, a rendszermagunk debug módban
	    jön létre.  Ha azonban sikerült betartani a
	    fentebb javasolt lépéseket, akkor egy
	    normál rendszermagot kapunk, amely mérete
	    ilyenkor jelentõs mértékben visszaesik: a
	    legtöbbjük olyan 1,5 és 2&nbsp;MB
	    körül van.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="multiport-serial-interrupts">
	  <para>Miért ütköznek a
	    megszakítások, amikor többportos soros
	    vonali kártyákat akarunk
	    használni?</para>
	</question>

	<answer>
	  <para>Ha a rendszermagot a többportos soros vonali
	    kártyák támogatásával
	    fordítjuk le, akkor a rendszertõl azt az
	    üzenetet kapjuk, hogy csak az elsõ
	    megszakítást fogja használni, a
	    többit pedig ütközés miatt (interrupt
	    conflict) kihagyja.  Hogyan lehet ezen
	    javítani?</para>

	  <para>A gondot alapvetõen az okozza, hogy a &os; a
	    rendszermagban fixen letárolja ezeket, nehogy
	    valamilyen hardveres vagy szoftveres
	    ütközés miatt elkallódjanak.  Ezen
	    úgy tudunk segíteni, ha egyetlen IRQ vonal
	    kivételével az összes többi
	    beállítását szabadon hagyjuk.
	    Íme erre egy példa:</para>

	  <programlisting>#
# Többportos nagysebességû soros vonali eszközök - 16550 UART
#
device sio2 at isa? port 0x2a0 tty irq 5 flags 0x501 vector siointr
device sio3 at isa? port 0x2a8 tty flags 0x501 vector siointr
device sio4 at isa? port 0x2b0 tty flags 0x501 vector siointr
device sio5 at isa? port 0x2b8 tty flags 0x501 vector siointr</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="generic-kernel-build-failure">
	  <para>Miért nem lehet lefordítani a
	    rendszermagot, még a <filename>GENERIC</filename>
	    beállításaival sem?</para>
	</question>

	<answer>
	  <para>Ennek több oka is lehet.  Ezek közül
	    néhány, de nem feltétlenül ebben a
	    sorrendben:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Nem a
		<command>make buildkernel</command>
		és
		<command>make installkernel</command>
		parancsokat használtuk és
		valószínûleg a forrásaink sem
		egyeznek meg a jelenleg futó rendszerével
		(például egy &rel.current;-RELEASE
		rendszert akarunk fordítani egy
		&rel2.current;-RELEASE rendszeren).  Ha
		frissíteni akarunk, akkor olvassuk el a
		<filename>/usr/src/UPDATING</filename>
		állományt, különös
		tekintettel a végén
		található <quote>COMMON ITEMS</quote>
		címû szakaszra.</para>
	    </listitem>

	    <listitem>
	      <para>A
		<command>make buildkernel</command>
		és
		<command>make installkernel</command>
		parancsokat használtuk, de elõtte nem futott
		le rendesen a
		<command>make buildworld</command>
		parancs.  A
		<command>make buildkernel</command>
		parancs ugyanis erõsen támaszkodik a
		<command>make buildworld</command>
		által végzett munkára.</para>
	    </listitem>

	    <listitem>
	      <para>Gyakran a <link linkend="stable">&os;-STABLE</link>
		változat használata esetén is
		elõfordulhat, hogy olyan pillanatban
		töltöttük le a forrásokat, amikor
		módosítás alatt voltak vagy
		valamiért nem mûködtek rendesen.
		Kizárólag a kiadások esetén
		tudjuk szavatolni a hibátlan
		fordítást, noha a <link linkend="stable">&os;-STABLE</link>
		verzióból készült
		változatok is többnyire megfelelõek.
		Próbáljuk meg újra letölteni a
		forrásokat, ha eddig még nem
		próbálkoztunk volna vele, és
		nézzük meg, hogy ez segít-e megoldani
		a problémát.  Keressük másik
		szervert, ha gondjaink vannak a
		frissítéssel.</para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="scheduler-in-use">
	  <para>Honnan tudhatjuk meg milyen ütemezõvel
	    dolgozik a rendszerünk?</para>
	</question>

	<answer>
	  <para>Nézzük meg, hogy a rendszerünkben
	    elérhetõ-e a <varname>kern.sched.quantum</varname>
	    változó.  Ha van ilyenünk, akkor valami
	    ilyesmit kell tapasztalnunk:</para>

	  <screen>&prompt.user; sysctl <replaceable>kern.sched.quantum</replaceable>
kern.sched.quantum: 99960</screen>

	  <para>Ha létezik a
	    <varname>kern.sched.quantum</varname> nevû sysctl
	    változó, akkor a 4BSD ütemezõ fut
	    (lásd &man.sched.4bsd.4;).  Ha nem, akkor egy ilyen
	    hibát kapunk a &man.sysctl.8; parancstól (ezt
	    nyugodtan figyelmen kívül hagyhatjuk):</para>

	  <screen>&prompt.user; sysctl <replaceable>kern.sched.quantum</replaceable>
sysctl: unknown oid 'kern.sched.quantum'</screen>

	  <para>Az aktuálisan használt ütemezõ
	    neve közvetlenül elérhetõ a
	    <varname>kern.sched.name</varname> sysctl
	    változó lekérdezésén
	    keresztül:</para>

	  <screen>&prompt.user; sysctl <replaceable>kern.sched.name</replaceable>
kern.sched.name: 4BSD</screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="scheduler-kern-quantum">
	  <para>Mi az a <varname>kern.sched.quantum</varname>?</para>
	</question>

	<answer>
	  <para>A <varname>kern.sched.quantum</varname>
	    értéke határozza meg, hogy egy
	    futó program legfeljebb mennyi órajelet futhat
	    egyszerre, megszakítás nélkül.
	    Ezt az értéket a 4BSD ütemezõ
	    használja, ezért a
	    jelenlétébõl vagy
	    hiányából következtetni tudunk a
	    pillanatnyilag használatban levõ
	    ütemezõre.</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter xml:id="disks" xml:lang="hu">
    <title>Lemezek, állományrendszerek és
      rendszertöltõk</title>

    <qandaset>
      <qandaentry>
	<question xml:id="adding-disks">
	  <para>Hogyan adjunk lemezeket a &os;
	    rendszerünkhöz?</para>
	</question>

	<answer>
	  <para>Ezzel kapcsolatban olvassuk el a lemezek
	    hozzáadásáról
	    szóló részt a <link xlink:href="&url.books.handbook;/disks-adding.html">&os; kézikönyvben</link>.
	    </para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="new-huge-disk">
	  <para>Hogyan lehet átteni a rendszert egy nagyobb
	    lemezre?</para>
	</question>

	<answer>
	  <para>Ezt legegyszerûbben úgy tudjuk
	    megcsinálni, ha újratelepítjük az
	    operációs rendszert az új lemezre
	    és külön áttesszük a
	    felhasználói adatokat.  Ez
	    különösen ajánlott abban az esetben,
	    ha már több kiadás óta
	    követjük a <emphasis>-STABLE</emphasis>
	    változatot, vagy ha korábban már
	    frissítettük a kiadásunkat.  A
	    &man.boot0cfg.8; segítségével fel
	    tudjuk rakni a booteasyt mind a két lemezre és
	    így egészen addig váltogatni tudjuk a
	    kettõt, amíg teljesen át nem
	    álltunk.  Ugorjuk át a következõ
	    bekezdést, és olvassuk el, hogy rakjuk
	    át az adatokat.</para>

	  <para>Úgy is dönthetünk, hogy nem
	    telepítjük újra a rendszert.  Ekkor vagy a
	    &man.sysinstall.8;, vagy pedig a &man.fdisk.8; és a
	    &man.disklabel.8; használatával osszuk fel
	    és címkézzük meg az új
	    lemezt.  Érdemes még a &man.boot0cfg.8;
	    segítségével felraknunk a booteasyt
	    mind a két lemezre, így miután
	    átmásoltuk a régi rendszerünket az
	    új lemezre, ennek megtartásával ki
	    tudjuk próbálni az új rendszert.</para>

	  <para>Most, miután sikeresen beállítottuk
	    az új lemezt, készen állunk az adatok
	    átmásolására.  Sajnos nem lehet
	    csak úgy vakon átmásolni ezeket egyik
	    lemezrõl a másikra.  Ilyenkor ugyanis bizonyos
	    dolgok (például a <filename>/dev</filename> könyvtárban
	    található eszközleírók, az
	    állományjelzõk és a linkek stb.)
	    hajlamosak elromlani.  Ezért ehhez olyan
	    eszközökre lesz szükségünk,
	    amelyek ismerik ezeket a dolgokat, mint
	    például a &man.dump.8;.  Továbbá
	    javasoljuk, hogy egyfelhasználós módban
	    végezzük el az átvitelt, noha ez nem
	    feltétlenül szükséges.</para>

	  <para>A rendszerindító
	    állományrendszer
	    átmozgatásához egyedül a
	    &man.dump.8; és &man.restore.8;
	    segédprogramokra lesz szükségünk.
	    Esetleg a &man.tar.1; parancs is használható,
	    de nem minden esetben.  A &man.dump.8; és
	    &man.restore.8; páros akkor is remekül
	    használható, ha egy partíció
	    tartalmát egy üres partícióra
	    akarjuk átvinni.  A következõ
	    lépések szükségesek ahhoz, hogy a
	    <command>dump</command> parancs
	    segítségével átvigyük egyik
	    partícióról a másikra az
	    adatokat:</para>

	  <procedure>
	    <step>
	      <para>Hozzunk létre egy új
		partíciót.</para>
	    </step>

	    <step>
	      <para>Ideiglenesen csatlakoztassuk egy
		könyvtárba.</para>
	    </step>

	    <step>
	      <para>Lépjünk be abba a
		könyvtárba.</para>
	    </step>

	    <step>
	      <para>Mentsük le a régi
		partíciót és az eredményt
		küldjük át az újra.</para>
	    </step>
	  </procedure>

	  <para>Például, ha a <filename>/mnt</filename>
	    könyvtárba csatlakoztatott
	    <filename>/dev/ad1s1a</filename>
	    eszközrõl akarjuk átvinni a jelenlegi
	    gyökérpartíciónkat, akkor ezeket a
	    parancsokat kell kiadnunk:</para>

	  <screen>&prompt.root; <userinput>newfs /dev/ad1s1a</userinput>
&prompt.root; <userinput>mount /dev/ad1s1a /mnt</userinput>
&prompt.root; <userinput>cd /mnt</userinput>
&prompt.root; <userinput>dump 0af - / | restore rf -</userinput></screen>

	  <para>További munkát igényel, ha a
	    <command>dump</command> parancs
	    segítségével a
	    partícióinkat is át akarjuk szervezni.
	    Például a <filename>/var</filename> partíciót
	    úgy tudjuk beleolvasztani a tövébe, ha
	    létrehozunk egy olyan partíciót, amely
	    mind a kettõ számára elegendõ nagy,
	    majd a fentebb leírt módszerrel
	    elõször átmozgatjuk a tövét,
	    utána pedig átmozgatjuk az
	    alpartíció tartalmát az elsõ
	    mozgatás során létrejött egyik
	    üres könyvtárba:</para>

	  <screen>&prompt.root; <userinput>newfs /dev/ad1s1a</userinput>
&prompt.root; <userinput>mount /dev/ad1s1a /mnt</userinput>
&prompt.root; <userinput>cd /mnt</userinput>
&prompt.root; <userinput>dump 0af - / | restore rf -</userinput>
&prompt.root; <userinput>cd var</userinput>
&prompt.root; <userinput>dump 0af - /var | restore rf -</userinput></screen>

	  <para>Egy könyvtárat, például
	    <filename>/var</filename> tartalmát
	    pedig úgy tudunk leválasztani a
	    tövérõl, vagyis átrakni egy
	    korábban nem létezõ
	    partícióra, ha elõször
	    létrehozzuk mind a két
	    partíciót, csatlakoztatjuk a leendõ
	    alpartíciót az ideiglenes csatlakozási
	    ponton belül a megfelelõ könyvtárba
	    és mindkettõre átmozgatjuk a régi
	    partíció teljes tartalmát:</para>

	  <screen>&prompt.root; <userinput>newfs /dev/ad1s1a</userinput>
&prompt.root; <userinput>newfs /dev/ad1s1d</userinput>
&prompt.root; <userinput>mount /dev/ad1s1a /mnt</userinput>
&prompt.root; <userinput>mkdir /mnt/var</userinput>
&prompt.root; <userinput>mount /dev/ad1s1d /mnt/var</userinput>
&prompt.root; <userinput>cd /mnt</userinput>
&prompt.root; <userinput>dump 0af - / | restore rf -</userinput></screen>

	  <para>A felhasználói adatok esetén a
	    &man.cpio.1;, &man.pax.1;, &man.tar.1; és &man.dump.8;
	    eszközöket ajánljuk.  Az írás
	    pillanatában még úgy tudjuk, hogy nem
	    tartják meg az állományjelzõkkel
	    kapcsolatos információkat, ezért csak
	    óvatosan használjuk ezeket!</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="dangerously-dedicated">
	  <para>A <quote>Veszélyesen dedikált</quote>
	    (<quote>Dangerously Dedicated</quote>) lemezek
	    veszélyesek a felhasználóra?</para>
	</question>

	<answer>
	  <para><anchor xml:id="dedicate"/>A telepítés
	    során két különbözõ
	    módon tudjuk partícionálni a
	    lemezeinket.  Alapértelmezés szerint a
	    rendszer igyekszik kompatbilis maradni a
	    gépünkön található többi
	    operációs rendszerrel.  Ilyenkor
	    normális partíciós táblabeli
	    bejegyzéseket készít (amelyeket &os;
	    alatt <quote>slice</quote>-oknak hívnak), és
	    egy ilyen slice-ba teszi az összes saját
	    partícióját.  Emellé még
	    telepíteni tudjuk az operációs
	    rendszerek választásának
	    lehetõségét is a rendszer
	    indításakor.  A másik
	    lehetõség választása esetén
	    azonban a &os; teljesen kisajátítja a lemezt
	    és nem is próbál meg kompatibilis
	    maradni a többi operációs
	    rendszerrel.</para>

	  <para>Miért is nevezzük ezt
	    <quote>veszélyesnek</quote>?  A lemez ebben az esetben
	    nem tartalmaz semmi olyat, amelyet a hétköznapi
	    programok partíciós táblaként
	    tudnának beazonosítani.  Attól
	    függõen, hogy mennyire illedelmes, egy ilyen
	    program panaszkodni fog, amikor megpróbálja
	    értelmezni a lemez tartalmát, de rosszabb
	    esetben anélkül felülírja a
	    rendszerbetöltõt, hogy bármit is jelzett
	    volna.  Ráadásul a <quote>veszélyesen
	    dedikált módon</quote> kiosztott lemezek
	    még bizonyos BIOS-okat is képesek megzavarni,
	    többek közt az Award (például
	    amelyek a HP NetServer, Micronics és hasonló
	    rendszerekben találhatóak) vagy Symbios/NCR
	    (népszerû 53C8xx SCSI-vezérlõk)
	    típusúak esetén találkozhatunk
	    ezzel a problémával.  Ez a lista persze nem
	    teljes, más gyártók termékeivel
	    is gondok akadhatnak.  Ennek a hibának jellemzõ
	    tünete a <errorname>read error</errorname>
	    hibaüzenet, amely arra utal, hogy a &os;
	    betöltõje nem találja saját
	    magát a lemezen, vagy éppen az egész
	    rendszer megáll a rendszer indítása
	    közben.</para>

	  <para>Akkor mégis mi értelme van ennek?  Csak
	    néhány kilobyte-tot spórolunk vele,
	    miközben komoly gondokat okozhat egy frissen
	    telepített rendszer esetében.  A
	    <quote>veszélyesen dedikált mód</quote>
	    eredetileg az új &os; telepítõket
	    veszélyeztetõ egyik komoly hibát
	    szeretné kiküszöbölni: a merevlemezek
	    BIOS és lemez önmaga által ismert
	    geometriai beállításainak
	    egyeztetése.</para>

	  <para>A <quote>lemezgeometria</quote> fogalma
	    tulajdonképpen már egy elavult fogalom, de a
	    PC-k BIOS-a legbelül még mind a mai napig
	    így kommunikál a lemezekkel.  Amikor a &os;
	    telepítõjével slice-okat hozunk
	    létre, olyan módon kell
	    rögzítenünk a lemezre ezek
	    pozícióját, hogy a BIOS képes
	    legyen megtalálni.  Ha ez nem sikerül, akkor nem
	    tudjuk elindítani a rendszert.</para>

	  <para>A <quote>veszélyesen dedikált</quote>
	    mód ezt a problémát az
	    egyszerûsítésén keresztül
	    próbálja megoldani, és néha
	    sikerül is neki.  Ezt azonban csak akkor javasoljuk, ha
	    semmi más nem mûködik, hiszen az esetek
	    túlnyomó részében más
	    megoldás is létezik.</para>

	  <para>Hogy tudjuk tehát akkor elkerülni a
	    <quote>veszélyesen dedikált</quote> mód
	    használatát a telepítés
	    során?  Jegyezzük fel, hogy mik a BIOS szerint a
	    merevlemezünk geometriai
	    beállításai.  Ezt a
	    rendszerindítás közben a
	    rendszermagtól is megkérdezhetjük
	    úgy, hogy a <literal>boot:</literal>
	    paranccsorába megadjuk a <option>-v</option>
	    beállítást, vagy a betöltõben
	    a <command>boot -v</command> parancsot használjuk.
	    Így pontosan a telepítõ
	    indítása elõtt a rendszermag ki fogja
	    írni a BIOS által ismert geometriai
	    beállításokat.  Ne essünk
	    pánikba, várjuk meg, amíg a
	    telepítõ elindul, tekerjünk vissza a
	    számokhoz és olvassuk le ezeket.  A lemezek
	    általában a BIOS sorrendjében jelennek
	    meg, tehát elõször az IDE aztán a
	    SCSI típusúak.</para>

	  <para>A lemez partícionálásakor
	    ellenõrizzük, hogy az FDISK
	    képernyõjén megjelenõ geometriai
	    beállítások megfelelõek
	    (tehát egyeznek a BIOS által ismert
	    értékekkel).  Ha eltérést
	    tapasztalunk, akkor a <keycap>G</keycap> billentyû
	    lenyomásával tudjuk átjavítani.
	    Erre leginkább akkor lesz
	    szükségünk, ha a lemez teljesen üres,
	    vagy ha a lemezt egy másik rendszerbõl hoztuk
	    át.  Ez egyébként csak azoknál a
	    lemezeknél okoz gondot, amelyekrõl a rendszert
	    akarjuk indítani, a &os; a többi lemezzel
	    már remekül elboldogul.</para>

	  <para>Miután sikerült egyeztetnünk a BIOS
	    és a &os; geometriai
	    beállításait, szinte biztos, hogy nem
	    kell már emiatt aggódnunk, így a
	    <quote>veszélyesen dedikált</quote>
	    módra sincs szükségünk.  Ha viszont
	    mégis egy <errorname>read error</errorname>
	    hibaüzenetet kapnánk a rendszer
	    indítása közben, akkor tegyünk egy
	    próbát.  Semmit sem
	    veszíthetünk.</para>

	  <para>Ha a <quote>veszélyesen dedikált</quote>
	    mód használatáról
	    szeretnénk visszatérni a megszokottra, akkor
	    két lehetõségünk van.
	    Elõször is teljesen le kell nulláznunk az
	    MBR-t, így biztosra vehetjük, hogy az
	    ezután következõ telepítések
	    során egy teljesen üres lemezt látunk.
	    Ezt például így lehet megtenni:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/rda0 count=15</userinput></screen>

	  <para>A másik módszer egy hivatalosan nem
	    dokumentált DOS-os <quote>lehetõség</quote>
	    használata:</para>

	  <screen><prompt>C:\&gt;</prompt> <userinput>fdisk /mbr</userinput></screen>

	  <para>Ezzel egy új Master Boot Recordot tudunk
	    telepíteni, ami ezzel együtt felülírja
	    a BSD rendszertöltõjét is.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="safe-softupdates">
	  <para>Milyen partíciókon lehet Soft Updatest
	    használni?  A Soft Updates
	    állítólag nem mûködik
	    rendesen a gyökérpartíció
	    esetén.</para>
	</question>

	<answer>
	  <para>A rövid válasz: A Soft Updates
	    bármelyik partíción minden
	    további nélkül
	    használható.</para>

	  <para>A hosszabb válasz: Korábban voltak
	    bizonyos kétségek afelõl, hogy a Soft
	    Updates jól mûködik a
	    rendszerindító partíciókon is.
	    Ez alapvetõen a Soft Updates két
	    jellemzõjére vezethetõ vissza.
	    Elõször is, a Soft Updatest alkalmazó
	    partíciók esetén elõfordulhat,
	    hogy a rendszerösszeomlás során elveszik
	    valamennyi adat (maga a partíció nem lesz
	    hibás, csupán némi adat tûnik el),
	    illetve a Soft Updates ideiglenesen kifogyhat a
	    tárhelybõl.</para>

	  <para>A Soft Updates használata során a
	    rendszermag legfeljebb harminc másodperc múlva
	    írja ki fizikailag a változtatásokat a
	    lemezre.  Tehát amikor egy nagyobb
	    állományt törlünk, akkor ez az
	    állomány egészen addig a lemezen marad,
	    amíg a rendszermag ténylegesen el nem
	    végzi ezt a törlést.  Ezzel viszont
	    nagyon egyszerûen létrehozható egy
	    <quote>ütközés</quote> (race condition) az
	    állományrendszeren.  Tegyük fel, hogy
	    letörlünk egy nagyobb állományt
	    és utána közvetlenül
	    létrehozunk egy másik nagyobb
	    állományt.  Mivel az elsõ
	    állomány ilyenkor még nem
	    törlõdik le valójában a
	    lemezrõl, ezért a második
	    számára már nem lesz elegendõ
	    helyünk.  A rendszer ekkor egy hibaüzenetben fog
	    figyelmeztetni minket, miközben pontosan az
	    imént töröltünk le egy
	    óriási állományt!  Ha
	    néhány másodperccel késõbb
	    újra megpróbáljuk létrehozni ezt
	    az állományt, akkor már minden a
	    megfelelõ módon fog zajlani.  Ezt
	    régebben sok &os; felhasználó nem tudta
	    mire vélni.</para>

	  <para>Ha a rendszerünk olyankor omlik össze, amikor
	    a rendszermag már elkezdte egy nagyobb
	    mennyiségû adat kiírását a
	    lemezre, de még nem fejezõdött be, akkor
	    könnyen elõfordulhat, hogy ez az adat elveszik
	    vagy meghibásodik.  Ennek kockázata nagyon
	    kicsi, és általában kezelhetõ,
	    viszont az IDE-meghajtókban található
	    írási gyorsítótár
	    használata jelentõsen növeli ezt.
	    Ezért a Soft Updates alkalmazása során
	    nem javasoljuk ennek használatát.</para>

	  <para>Ezek a problémák az összes Soft
	    Updates partíciót veszélyeztetik.
	    Mennyiben vonatkoznak viszont ezek a
	    gyökérpartícióra?</para>

	  <para>A gyökérpartíción nagyon
	    ritkán változnak fontos
	    információk.  A
	    <filename>/boot/kernel/kernel</filename> és az
	    <filename>/etc</filename> egyedül a
	    rendszer karbantartása során frissül,
	    vagy például amikor a
	    felhasználók jelszót
	    változtatnak.  Ha a rendszer egy ilyen
	    változtatás harminc másodperces
	    idején belül omlik össze, akkor megvan
	    rá az esélyünk, hogy elvesznek az
	    adataink.  Ez a kockázat a legtöbb
	    alkalmazás számára elfogadható,
	    de semmiképpen sem szabad figyelmen kívül
	    hagynunk.  Ha a rendszerünk nem képes
	    vállalni még ennyi kockázatot sem,
	    akkor a rendszerindító partíción
	    tiltsuk le a Soft Updates használatát!</para>

	  <para>A gyökérpartíció
	    hagyományosan az egyik legkisebb
	    partíció.  Ha viszont az ideiglenes
	    állományok tárolására
	    szánt <filename>/tmp</filename>
	    könyvtárat is ezen belülre tesszük
	    és gyakran használjuk, akkor ebbõl
	    idõszakosan tárhelyproblémáink
	    adódhatnak.  Könnyen megoldhatjuk azonban ezt a
	    problémát, ha a <filename>/tmp</filename> könyvtárhoz
	    létrehoznunk egy szimbolikus linket a <filename>/var/tmp</filename>
	    könyvtárra.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="inappropriate-ccd">
	  <para>Mi történt a &man.ccd.4;
	    eszközzel?</para>
	</question>

	<answer>
	  <para>A hibajelenség:</para>

	  <screen>&prompt.root; <userinput>ccdconfig -C</userinput>
ccdconfig: ioctl (CCDIOCSET): /dev/<replaceable>ccd0c</replaceable>: Inappropriate file type or format</screen>

	  <para>Ez általában olyankor
	    történik, amikor olyan <literal>c</literal>
	    partíciókat próbálunk meg
	    összefûzni, amelyek alapértelmezés
	    szerint <literal>unused</literal> (<quote>nem
	    használt</quote>) típusúak.  A
	    &man.ccd.4; meghajtó azonban megköveteli, hogy
	    az érintett partíciók
	    <literal>FS_BSDFFS</literal> típusúak
	    legyenek.  Szerkesszük át a lemezeken
	    található címkéket és
	    változtassuk meg a partíciók
	    típusát a <literal>4.2BSD</literal>
	    értékre.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ccd-disklabel">
	  <para>Miért nem lehet a &man.ccd.4; eszköz
	    lemezcímkéjét szerkeszteni?</para>
	</question>

	<answer>
	  <para>A hibajelenség:</para>

	  <screen>&prompt.root; <userinput>disklabel ccd0</userinput>
(itt valami gondot ír ki, ezért megpróbáljuk szerkeszteni a címkét)
&prompt.root; <userinput>disklabel -e ccd0</userinput>
(edit, save, quit)
disklabel: ioctl DIOCWDINFO: No disk label on disk;
use "disklabel -r" to install initial label</screen>

	  <para>Ezt általában azért kapjuk, mert a
	    &man.ccd.4; által visszaadott lemezcímke
	    valójában <quote>nem létezik</quote> a
	    lemezen.  Ezen úgy tudunk segíteni, ha
	    explicit módon visszaírjuk, valahogy
	    így:</para>

	  <screen>&prompt.root; <userinput>disklabel ccd0 &gt; /tmp/lemezcimke.tmp</userinput>
&prompt.root; <userinput>disklabel -Rr ccd0 /tmp/lemezcimke.tmp</userinput>
&prompt.root; <userinput>disklabel -e ccd0</userinput>
(most már mûködni fog)</screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="mount-foreign-fs">
	  <para>Lehet más operációs rendszerek
	    állományrendszerét is csatlakoztatni &os;
	    alatt?</para>
	</question>

	<answer>
	  <para>A &os; több más
	    állományrendszert is ismer.</para>

	  <variablelist>
	    <varlistentry>
	      <term>UFS</term>

	      <listitem>
		<para>Az UFS formátumú CD-k &os; alatt
		  közvetlenül csatlakoztathatóak.  A
		  Digital UNIX és más rendszerek UFS
		  partícióit nem már annyira
		  könnyû csatlakoztatni, ez leginkább a
		  kérdéses operációs
		  rendszer partícionálási
		  megoldásaitól függ.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>ext2/ext3</term>

	      <listitem>
		<para>A &os; támogatja az
		  <literal>ext2fs</literal> és <literal>ext3fs</literal>
		  partíciókat.  Errõl bõvebben
		  lásd a &man.mount.ext2fs.8; man oldalt.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>NTFS</term>

	      <listitem>
		<para>A &os; csak olvasni képes az NTFS
		  partíciókat.  Ezzel kapcsolatban a
		  &man.mount.ntfs.8; man oldalán találunk
		  részletesebb információkat.  Az
		  írhatóság
		  használatához az <link xlink:href="http://www.tuxera.com/community/"><application>ntfs-3g</application></link>
		  portolt változatát javasoljuk
		  (lásd <package>sysutils/fusefs-ntfs</package>).
		  </para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>FAT</term>

	      <listitem>
		<para>A &os; egyaránt képes írni
		  és olvasni a FAT típusú
		  partíciókat.  Errõl a
		  &man.mount.msdosfs.8; man oldalán tudhatunk meg
		  többet.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>ReiserFS</term>

	      <listitem>
		<para>A &os; tudja olvasni a ReiserFS
		  partíciókat.  Ezt a &man.mount.reiserfs.8;
		  man oldalon olvashatjuk.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>ZFS</term>

	      <listitem>
		<para>A &os; jelen pillanatban a &sun; ZFS
		  meghajtójának átiratát is
		  tartalmazza.  Jelenleg azonban csak elegendõ
		  memóriával rendelkezõ &arch.amd64;
		  platformokon javasoljuk a használatát.
		  Részletesebb
		  információkért lásd a
		  &man.zfs.8; man oldalt.</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>A &os; hálózati
	    állományrendszereket is támogat,
	    többek közt az NFS-t (lásd
	    &man.mount.nfs.8;), a NetWare-t (lásd
	    &man.mount.nwfs.8;), és Microsoft-féle SMB
	    állományrendszereket (lásd
	    &man.mount.smbfs.8;).  Más egyéb
	    FUSE-alapú állományrendszer (<package>sysutils/fusefs-kmod</package>)
	    támogatását is megtalálhatjuk a
	    portok között.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="mount-dos">
	  <para>Hogyan lehet másodlagos (logikai) DOS
	    partíciókat csatlakoztatni?</para>
	</question>

	<answer>
	  <para>A logikai DOS partíciók az elsõdleges
	    partíciók <emphasis>után</emphasis>
	    találhatóak.  Például, ha van
	    egy <quote>E</quote> betûjelû logikai
	    partíciónk a második
	    SCSI-meghajtónkon, akkor lennie kell egy
	    <quote>ötödik slice-nak</quote> a <filename>/dev</filename> könyvtárban,
	    amelyet majd csatlakoztatni tudunk:</para>

	  <screen>&prompt.root; <userinput>mount -t msdosfs /dev/da1s5 /dos/e</userinput></screen>

	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="crypto-filesystem">
	  <para>Használható titkosított
	    állományrendszer &os; alatt?</para>
	</question>

	<answer>
	  <para>Igen.  Erre a célra a &man.gbde.8; és a
	    &man.geli.8; is tökéletesen alkalmas.  A
	    részleteket lásd a &os; kézikönyv
	    <link xlink:href="&url.books.handbook;/disks-encrypting.html">A lemezpartíciók titkosítása</link>
	    címû fejezetében.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="nt-bootloader">
	  <para>A &windowsnt; rendszertöltõjével is el
	    lehet indítani a &os;-t?</para>
	</question>

	<answer>
	  <para>Ehhez tulajdonképpen csak annyit kell
	    csinálnunk, hogy átmásoljuk a &os;
	    rendszerindító
	    partíciójának az elsõ
	    szektorát egy állományba a
	    DOS/&windowsnt; partíción belül.  Legyen
	    ez például a
	    <filename>C:\BOOTSECT.BSD</filename> állomány
	    (a <filename>C:\BOOTSECT.DOS</filename>
	    mintájára), amelyhez aztán így
	    igazítjuk a <filename>c:\boot.ini</filename>
	    állományt:</para>

	  <programlisting>[boot loader]
timeout=30
default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
[operating systems]
multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Windows NT"
C:\BOOTSECT.BSD="&os;"
C:\="DOS"</programlisting>

	  <para>Ha a &os; ugyanazon a lemezen található,
	    ahonnan a &windowsnt; is indul, akkor egyszerûen csak
	    másoljuk át a <filename>/boot/boot1</filename>
	    állományt <filename>C:\BOOTSECT.BSD</filename>
	    néven.  Ha viszont a &os; egy másik lemezen
	    található, akkor a
	    <filename>/boot/boot1</filename> önmagában
	    már nem elegendõ, hanem helyette a
	    <filename>/boot/boot0</filename> állományra
	    lesz szükségünk.</para>

	  <para>A <filename>/boot/boot0</filename>
	    állományt a &man.sysinstall.8;
	    használatával kell telepíteni
	    abból a menübõl, ahol a &os; boot
	    managerét kell kiválasztani.  Erre
	    azért van szükség, mert a
	    <filename>/boot/boot0</filename> állományon
	    belül a partíciós tábla teljesen
	    üres, azonban a &man.sysinstall.8; át fogja
	    másolni a partíciós
	    táblát mielõtt a
	    <filename>/boot/boot0</filename> állományt az
	    MBR-be tenné.</para>

	    <warning>
	      <para><emphasis>Ne másoljunk át csak
		úgy egyszerûen a
		<filename>/boot/boot0</filename> állományt
		a <filename>/boot/boot1</filename> helyett!  Ezzel
		felülíródik a partíciós
		táblánk és így a
		számítógépet nem tudjuk
		elindítani!</emphasis></para>
	    </warning>

	  <para>Amikor a &os; boot managere lefut, az utoljára
	    indított operációs rendszert a
	    partíciós táblában
	    aktívként jelöli meg (ezzel
	    lényegében megjegyzi), majd ezután
	    beírja magát az MBR-be.  Emiatt, hogy ha csak
	    egyszerûen átmásoljuk a
	    <filename>/boot/boot0</filename> állományt a
	    <filename>C:\BOOTSECT.BSD</filename>
	    állományba, akkor csak egy egyetlen
	    aktív bejegyzést tartalmazó üres
	    partíciós táblát fog
	    visszaírni az MBR-be.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="lilo-bootloader">
	  <para>A LILO-ból hogyan lehet &os;-t és Linuxot
	    is indítani?</para>
	</question>

	<answer>
	  <para>Ha a &os; és a &linux; is ugyanazon a lemezen
	    helyezkedik el, akkor nincs más teendõnk, mint
	    követni a LILO telepítési
	    útmutatójában a nem-&linux;
	    típusú operációs rendszerek
	    indítására vonatkozó
	    utasításokat.  Ezek röviden
	    összefoglalva a következõk:</para>

	  <para>Indítsuk el a Linuxot és vegyük fel a
	    következõ sort az
	    <filename>/etc/lilo.conf</filename>
	    állományba:</para>

	  <programlisting>other=/dev/hda2
        table=/dev/hda
        label=&os;</programlisting>

	  <para>(A fentiekben feltételeztük, hogy a &os;-t
	    tartalmazó slice a &linux; számára
	    <filename>/dev/hda2</filename> néven
	    érhetõ el.  Ez természetesen a
	    saját konfigurációnkhoz kell szabni.)
	    Ezután egyszerûen csak futtassuk le a
	    <command>lilo</command> parancsot <systemitem class="username">root</systemitem>
	    felhasználóként és már
	    készen is vagyunk.</para>

	  <para>Ha a &os; egy másik lemezen
	    található, akkor a
	    <literal>loader=/boot/chain.b</literal>
	    LILO-bejegyzést kell használnunk.
	    Például:</para>

	  <programlisting>other=/dev/dab4
        table=/dev/dab
        loader=/boot/chain.b
        label=&os;</programlisting>

	  <para>Bizonyos helyzetekben elõfordulhat, hogy a &os;
	    rendszertöltõjének át kell adnunk a
	    meghajtó BIOS szerinti sorszámát, mert
	    csak így tudjuk rendesen elindítani a
	    második lemezrõl.  Például, ha a
	    &os; szerint a SCSI-lemezünk a BIOS-ban az 1-es lemez,
	    akkor ezt kell megadnunk a &os;
	    rendszertöltõjének:</para>

	  <screen>Boot: <userinput>1:da(0,a)/boot/kernel/kernel</userinput></screen>

	  <para>A &man.boot.8; beállítható
	    úgy, hogy a rendszer indításakor
	    automatikusan mindig ezt a beállítást
	    használja.</para>

	  <para>A &os; és &linux; együttes
	    használatáról további
	    részleteket a <link xlink:href="http://tldp.org/HOWTO/Linux+FreeBSD.html">&linux;+&os; mini-HOWTO</link>
	    címû írásból tudhatunk
	    meg.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="grub-loader">
	  <para>Hogyan lehet a GRUB használatával &os;-t
	    és Linuxot is indítani?</para>
	</question>

	<answer>
	  <para>A &os;-t nagyon könnyû elindítani a
	    GRUB segítségével.  Ehhez csupán
	    annyit kell tennünk, hogy felvesszük a
	    következõ sorokat a GRUB
	    konfigurációs állományába
	    (<filename>/boot/grub/menu.lst</filename>, vagy bizonyos,
	    például Red Hat-típusú
	    rendszerekben a
	    <filename>/boot/grub/grub.conf</filename>):</para>

	  <programlisting>title &os; 6.1
	root <replaceable>(hd0,a)</replaceable>
	kernel /boot/loader
	  </programlisting>

	  <para>Itt a <replaceable>hd0,a</replaceable> az elsõ
	    lemezen található rendszerindító
	    partícióra mutat.  Ha a lemezen belül a
	    slice számát is szeretnénk megadni,
	    akkor írhatjuk így is:
	    <replaceable>(hd0,2,a)</replaceable>.  Ha ezt nem adjuk meg,
	    akkor a GRUB alapértelmezés szerint a lemezen
	    levõ elsõ <literal>a</literal>
	    partícióval rendelkezõ slice-ot keresi
	    meg.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="booteasy-loader">
	  <para>Hogyan lehet a <application>BootEasy</application>
	    használatával elindítani a &os;-t
	    és a Linuxot?</para>
	</question>

	<answer>
	  <para>A LILO-t ne a Master Boot Recordba, hanem a linuxos
	    partíciónk elejére
	    telepítsük.  Ezután a
	    <application>BootEasy</application>bõl már el
	    tudjuk indítani a LILO-t.</para>

	  <para>Abban az esetben is ezt javasoljuk, ha &windows;
	    és &linux; is van a gépünkön, mivel
	    így szintén egyszerûbb lesz
	    elindítani a Linuxot, ha netalán valamikor
	    újra kellene telepíteni a &windows;-t (ami
	    viszont egy <quote>irigy</quote> operációs
	    rendszer, mert nem tûr meg semmilyen más
	    operációs rendszert maga mellett a Master Boot
	    Recordban).</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="changing-bootprompt">
	  <para>A rendszerindításkor látható
	    <literal>???</literal> hogyan írható át
	    valami értelmesre?</para>
	</question>

	<answer>
	  <para>Ez az szabványos boot managerrel csak úgy
	    lehet megoldani, ha újratelepítjük.  A
	    portok között viszont a <filename>sysutils</filename>
	    kategóriában rengeteg olyan más boot
	    managert találhatunk, amely tud ilyet is.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="removable-drives">
	  <para>Cserélhetõ lemezes meghajtókat hogyan
	    lehet használni?</para>
	</question>

	<answer>
	  <para>Legyen az akár egy &iomegazip;, EZ drive
	    meghajtó (esetleg egy floppy, ha így akarjuk
	    használni), vagy éppen egy új
	    merevlemez, miután már
	    telepítettük és felismerte a rendszert,
	    illetve behelyeztük a lemezt, kártyát
	    vagy akármit, minden esetben szinte ugyanaz a
	    teendõ.</para>

	  <para>(Ez a válasz leginkább Mark Mayo <link xlink:href="http://www.vmunix.com/mark/FreeBSD/ZIP-FAQ.html">ZIP GYIK</link>
	    címû írásán
	    alapszik.)</para>

	  <para>Ha tehát egy ZIP meghajtóról vagy
	    floppylemezrõl beszélünk, amelyen egy DOS-os
	    állományrendszer található,
	    akkor azt parancssorból így
	    érhetjük el, ha floppy:</para>

	  <screen>&prompt.root; <userinput>mount -t msdosfs /dev/fd0c /floppy</userinput></screen>

	  <para>vagy így, ha egy gyári
	    beállításokkal rendelkezõ
	    ZIP-lemez:</para>

	  <screen>&prompt.root; <userinput>mount -t msdosfs /dev/da2s4 /zip</userinput></screen>

	  <para>A többi lemez esetén a &man.fdisk.8; vagy a
	    &man.sysinstall.8; segítségével
	    nézzük meg, hogy milyen partíciók
	    és hogyan találhatóak meg
	    rajtuk.</para>

	  <para>A következõ példákban egy
	    <filename>da2</filename> eszközként, vagyis
	    egy harmadik SCSI-lemezként megjelenõ
	    ZIP-meghajtót fogunk használni.</para>

	  <para>Hacsak nem floppyval van dolgunk, illetve nem
	    tervezzük másoknak is odaadni a
	    cserélhetõ médiumot, akkor érdemes
	    inkább BSD típusú
	    állományrendszert telepíteni rá.
	    Így támogatottak lesznek a hosszú
	    állománynevek, és legalább egy
	    kétszer gyorsabb és egy sokkal
	    megbízhatóbb megoldást kapunk.  Ehhez
	    elõször is le kell szednünk a DOS-szintû
	    partíciókat és
	    állományrendszereket.  Erre a célra
	    egyaránt megfelel a &man.fdisk.8; vagy a
	    &man.sysinstall.8;, illetve kisebb lemezek esetén
	    valószínûleg nem is lesz
	    szükségünk több
	    operációs rendszer
	    támogatására, így aztán
	    közvetlenül is törülhetjük
	    ezeket:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/rda2 count=2</userinput>
&prompt.root; <userinput>disklabel -Brw da2 auto</userinput></screen>

	  <para>A &man.disklabel.8; vagy a &man.sysinstall.8;
	    használatával ezután létre
	    tudunk hozni BSD típusú
	    partíciókat.  Valószínûleg
	    erre lesz szükségünk, ha
	    lapozóállományt is tenni akarunk a
	    lemezre, noha ennek nem sok értelme van
	    például egy ZIP-meghajtó
	    esetén.</para>

	  <para>Végezetül hozzunk létre egy új
	    állományrendszert.  Itt most ez egész
	    ZIP-lemezen egyetlen partíció lesz:</para>

	  <screen>&prompt.root; <userinput>newfs /dev/rda2c</userinput></screen>

	  <para>Csatlakoztassuk:</para>

	  <screen>&prompt.root; <userinput>mount /dev/da2c /zip</userinput></screen>

	  <para>Emellett még hasznos lehet felvenni hozzá
	    egy sort az <filename>/etc/fstab</filename>
	    állományba is (lásd &man.fstab.5;),
	    így a jövõben elegendõ csak a
	    <command>mount /zip</command> parancsot kiadnunk a
	    csatlakoztatásához:</para>

	  <programlisting>/dev/da2c /zip ffs rw,noauto 0 0</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="mount-cd-superblock">
	  <para>Miért ad a rendszer <errorname>Incorrect super
	    block</errorname> hibát CD-k
	    csatlakoztatásánál?</para>
	</question>

	<answer>
	  <para>Fel kell világosítanunk a &man.mount.8;
	    parancsot a csatlakoztatandó eszköz
	    típusáról.  Errõl a <link xlink:href="&url.books.handbook;/creating-cds.html">kézikönyv lézeres tárolóeszközökrõl szóló részében</link>
	    olvashatunk, innen is különösen a
	    <link xlink:href="&url.books.handbook;/creating-cds.html#MOUNTING-CD">Adat CD-k használata</link>
	    címû szakaszt ajánljuk.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="cdrom-not-configured">
	  <para>Miért ad a rendszer <errorname>Device not
	    configured</errorname> hibaüzenetet CD-k
	    csatlakoztatásakor?</para>
	</question>

	<answer>
	  <para>Ez általában arra utal, hogy nincs CD a
	    meghajtóban, vagy a meghajtó nem
	    érhetõ el a buszon.  Ezzel kapcsolatban a
	    kézikönyv <link xlink:href="&url.books.handbook;/creating-cds.html#MOUNTING-CD">Adat CD-k használata</link>
	    címû szakaszát javasoljuk
	    elolvasásra.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="cdrom-unicode-filenames">
	  <para>Miért jelenik meg az összes nemzeti karakter
	    helyén <quote>?</quote>, amikor &os; alatt
	    csatlakoztatunk egy CD-t?</para>
	</question>

	<answer>
	  <para>A CD-n valószínûleg a
	    <quote>Joliet</quote> kiterjesztés
	    használatával tárolják az
	    állományok és könyvtárak
	    adatait.  Erre vonatkozóan a kézikönyvben
	    a <link xlink:href="&url.books.handbook;/creating-cds.html">Lézeres tárolóeszközök (CD-k) létrehozása és használata</link>
	    címû rész elolvasását
	    javasoljuk, különös tekintettel az <link xlink:href="&url.books.handbook;/creating-cds.html#MOUNTING-CD">Adat CD-k használata</link>
	    címû szakaszra.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="burncd-isofs">
	  <para>A &os; alatt készített CD-ket nem lehet
	    más operációs rendszerekkel olvasni.
	    Miért nem?</para>
	</question>

	<answer>
	  <para>Ez minden bizonnyal abból fakad, hogy nem egy
	    ISO&nbsp;9660 állományrendszert vettük
	    fel rá, hanem közvetlenül maguk az
	    állományokat.  Olvassuk el a
	    kézikönyvben a <link xlink:href="&url.books.handbook;/creating-cds.html">Lézeres tárolóeszközök (CD-k) létrehozása és használata</link>
	    címû fejezetet, de különösen a
	    <link xlink:href="&url.books.handbook;/creating-cds.html#RAWDATA-CD">Nyers adat CD-k írása</link>
	    címû részt.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="copy-cd">
	  <para>Hogyan lehet lementeni egy adat CD tartalmát a
	    merevlemezre?</para>
	</question>

	<answer>
	  <para>Errõl a kézikönyvben találunk
	    hasznos információkat, azon belül is az
	    <link xlink:href="&url.books.handbook;/creating-cds.html#IMAGING-CD">Adat CD-k másolása</link>
	    címû szakaszban.  A CD-kkel
	    végezhetõ további mûveletekrõl
	    a kézikönyv <link xlink:href="&url.books.handbook;/creating-cds.html">Lézeres tárolóeszközök (CD-k) létrehozása és használata</link>
	    címû részében találhatunk
	    részletes útmutatásokat.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="mount-audio-CD">
	  <para>Miért nem lehet audio CD-ket csatlakoztatni a
	    <command>mount</command> paranccsal?</para>
	 </question>

	<answer>
	  <para>Ha zenei CD-ket próbálunk meg
	    csatlakoztatni, akkor például egy
	    <errorname>cd9660: /dev/acd0c: Invalid argument</errorname>
	    hibát fogunk kapni a rendszertõl.  Ez
	    azért történik, mert a
	    <command>mount</command> parancs csak
	    állományrendszerekkel
	    használható.  A zenei CD-ken viszont semmilyen
	    állományrendszer nincs, egyszerûen csak
	    maga az adat.  Az olvasásukhoz olyan programra lesz
	    szükségünk, amely képes zenei
	    CD-kkel dolgozni, mint például az <package>audio/xmcd</package> port.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="multi-session-CD">
	  <para>Hogyan lehet többmenetes (multisession) CD-ket
	    csatlakoztatni a <command>mount</command> paranccsal?</para>
	</question>

	<answer>
	  <para>A &man.mount.8; alapértelmezés szerint az
	    CD-n található utolsó adatsávot
	    (menetet, vagy sessiont) próbálja meg olvasni.
	    Ha viszont egy korábbi menetet szeretnénk vele
	    betöltetni, akkor erre használjuk a
	    <option>-s</option> paranccsori paramétert.  Erre a
	    &man.mount.cd9660.8; man oldalon találhatunk
	    különbözõ példákat.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="user-floppymount">
	  <para>Hogyan képesek az egyszerû
	    felhasználók floppykat, CD-ket és
	    más egyéb cserélhetõ lemezes
	    eszközöket használni?</para>
	</question>

	<answer>
	  <para>A normál felhasználók
	    számára engedélyezni tudjuk az
	    eszközök csatlakoztatását.
	    Íme:</para>

	  <procedure>
	    <step>
	      <para><systemitem class="username">root</systemitem>
		felhasználóként
		állítsuk be a
		<varname>vfs.usermount</varname> sysctl
		változót az <literal>1</literal>
		értékre:</para>

	      <screen>&prompt.root; <userinput>sysctl -w vfs.usermount=1</userinput></screen>
	    </step>

	    <step>
	      <para>A cserélhetõ eszközöket
		képviselõ eszközleírókra
		állítsuk be <systemitem class="username">root</systemitem>
		felhasználóként a megfelelõ
		engedélyeket.</para>

	      <para>Például a
		felhasználóknak így tudjuk
		engedélyezni az elsõ floppymeghajtó
		használatát:</para>

	      <screen>&prompt.root; <userinput>chmod 666 /dev/fd0</userinput></screen>

	      <para>Az <systemitem class="groupname">operator</systemitem> csoportban
		levõ felhasználók pedig így
		fognak tudni CD-ket csatlakoztatni:</para>

	      <screen>&prompt.root; <userinput>chgrp operator /dev/acd0c</userinput>
&prompt.root; <userinput>chmod 640 /dev/acd0c</userinput></screen>
	    </step>

	    <step>
	      <para>Fel kell vennünk ezeket a
		módosításokat az
		<filename>/etc/devfs.conf</filename>
		állományba is, mivel csak így
		maradnak meg a következõ
		rendszerindítás után.</para>

	      <para>Ehhez <systemitem class="username">root</systemitem>
		felhasználóként a vegyük fel a
		megfelelõ sorokat az
		<filename>/etc/devfs.conf</filename>
		állományba.  Például, ha a
		felhasználóknak engedélyezni
		akarjuk az elsõ floppymeghajtó
		használatát, akkor:</para>

	      <programlisting># Bármelyik felhasználó képes floppykat csatlakoztatni.
own       /dev/fd0	  root:operator
perm	  /dev/fd0	  0666</programlisting>

	      <para>Így engedélyezhetjük az
		<systemitem class="groupname">operator</systemitem> csoport tagjainak a CD-k
		csatlakoztatását:</para>

	      <programlisting># Az operator csoport tagjai csatlakoztathatnak CD-ket.
own       /dev/acd0	  root:operator
perm	  /dev/acd0	  0660</programlisting>
	    </step>

	    <step>
	      <para>Végezetül tegyük a
		<literal>vfs.usermount=1</literal>
		sort az <filename>/etc/sysctl.conf</filename>
		állományba, így a rendszer
		következõ indításakor is
		megmarad ez a beállítás.</para>
	    </step>
	  </procedure>

	  <para>Most már mindegyik felhasználó
	    képes csatlakoztatni a
	    <filename>/dev/fd0</filename>
	    eszközleírón keresztül
	    elérhetõ lemezt a saját
	    könyvtárába:</para>

	  <screen>&prompt.user; <userinput>mkdir ~/az-én-csatlakozási-pontom</userinput>
&prompt.user; <userinput>mount -t msdosfs /dev/fd0 ~/az-én-csatlakozási-pontom</userinput></screen>

	  <para>A <systemitem class="groupname">operator</systemitem> csoport tagjai is
	    képesek most már az
	    <filename>/dev/acd0c</filename>
	    eszközleírón keresztül
	    elérhetõ CD-ket csatlakoztatni a saját
	    könyvtárukba:</para>

	  <screen>&prompt.user; <userinput>mkdir ~/az-én-csatlakozási-pontom</userinput>
&prompt.user; <userinput>mount -t cd9660 /dev/acd0c ~/az-én-csatlakozási-pontom</userinput></screen>

	  <para>Az eszközök leválasztása is
	    hasonlóan egyszerû:</para>

	  <screen>&prompt.user; <userinput>umount ~/az-én-csatlakozási-pontom</userinput></screen>

	  <para>A <varname>vfs.usermount</varname>
	    engedélyezésével azonban
	    együttjár némi biztonsági
	    kockázat is.  Az &ms-dos; formátumú
	    lemezek csatlakoztatására ezért
	    inkább a Portgyûjteményben
	    található <package>emulators/mtools</package> csomagot
	    javasoljuk.</para>

	  <note>
	    <para>A példákban használt
	      eszközneveket természetesen a
	      konfigurációnknak megfelelõen meg kell
	      változtatnunk.</para>
	  </note>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="du-vs-df">
	  <para>A <command>du</command> és a
	    <command>df</command> parancsok eltérõ
	    mennyiségû szabad helyet mutatnak.  Mi okozza
	    ezt?</para>
	</question>

	<answer>
	  <para>A válaszhoz meg kell értenünk a
	    <command>du</command> és a <command>df</command>
	    mûködését.  A <command>du</command>
	    végigmegy a könyvtárszerkezeten és
	    megnézi, hogy mekkorák az egyes
	    állományok, majd megjeleníti a
	    végösszegüket.  A <command>df</command>
	    ezzel szemben egyszerûen csak lekérdezi az
	    állományrendszertõl, hogy mennyi szabad
	    hely maradt rajta.  Ezek látszólag ugyanazt a
	    módszer fedik, azonban miközben a
	    könyvtár nélkül
	    állományok befolyásolják a
	    <command>df</command> parancsot, addig a
	    <command>du</command> parancsot nem.</para>

	  <para>Amikor egy program használ egy olyan
	    állományt, amelyet eközben
	    letörlünk, egészen addig létezni
	    fog, amíg a program be nem fejezi a
	    használatát.  Ettõl függetlenül
	    viszont az állomány azonnal eltûnik a
	    könyvtárból.  Ezt nagyon könnyen ki
	    is tudjuk próbálni egy olyan programmal, mint
	    például a <command>more</command>.
	    Tegyük fel, hogy van akkora állományunk,
	    amely elég nagy ahhoz, hogy feltûnjön a
	    <command>du</command> és a <command>df</command>
	    kimenetében.  (Mivel manapság már
	    nagyok a tárolóeszközök, ennek egy
	    <emphasis>igen nagy</emphasis> állománynak
	    kell lennie!) Ha letöröljük ezt az
	    állományt, miközben a
	    <command>more</command> paranccsal még
	    használjuk, a <command>more</command> nem fog
	    rögtön leállni és panaszkodni az
	    állomány hiányára.  Egyedül
	    csak az állományhoz tartozó
	    bejegyzés tûnik el a
	    könyvtárból, így más
	    program már nem tud hozzáférni.  A
	    <command>du</command> erre már azt mondja, hogy nem
	    létezik &mdash; bejárta a
	    könyvtárat és nem találta.  A
	    <command>df</command> szerint azonban még mindig ott
	    van, hiszen az állományrendszer tudja, hogy a
	    <command>more</command> parancsnak még
	    szüksége van rá.  Ahogy a
	    <command>more</command> befejezte a dolgát, a
	    <command>du</command> és a <command>df</command>
	    által mutatott értékek ismét
	    egyezni fognak.</para>

	  <para>Azt sem szabad elfelejtenünk, hogy a Soft Updates
	    használata esetén akár 30
	    másodpercet is várnunk kell, hogy a
	    változtatásaink láthatóvá
	    váljanak!</para>

	  <para>Ez a helyzet nagyon gyakori webszerverek esetén.
	    Sokan úgy állítanak be a &os;
	    rendszerükön webszervert, hogy elfelejtik
	    beállítani hozzá a naplók
	    archiválását és
	    váltását.  Ilyenkor a
	    hozzáférések naplózása
	    gyorsan meg tudja tölteni a <filename>/var</filename> könyvtárat.
	    Ekkor a rendszergazda törli az adott
	    állományt, de a rendszer még mindig
	    panaszkodik a szabad hely hiánya miatt.  A webszerver
	    leállítása és
	    újraindítása ekkor segít
	    felszabadítani az állományt, így
	    az állományrendszerrõl is
	    törlõdhet.  Ennek megelõzésére
	    használjuk a &man.newsyslog.8; programot.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="add-swap-space">
	  <para>Hogyan lehet növelni a
	    lapozóterületet?</para>
	</question>

	<answer>
	  <para>A kézikönyv <link xlink:href="&url.books.handbook;/config-tuning.html">Beállítás és finomhangolás</link>
	    címû fejezetében található
	    <link xlink:href="&url.books.handbook;/adding-swap-space.html">egyik szakaszban</link>
	    olvashatunk errõl.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="manufacturer-disk-size">
	  <para>A &os; miért látja kisebbnek a lemezeket
	    mint amekkorának a gyártó mondja
	    ezeket?</para>
	</question>

	<answer>
	  <para>A merevlemezek gyártói
	    általában a gigabyte-okat egy milliárd
	    byte-ként számolják, miközben a
	    &os; pedig 1&nbsp;073&nbsp;741&nbsp;824&nbsp;byte-nak.  Ez
	    remekül megmagyarázza, hogy a &os;
	    rendszerüzenetei között egy
	    elméletileg 80&nbsp;GB méretû lemez
	    miért 76&nbsp;319&nbsp;MB-osnak jelenik meg.</para>

	  <para>Emellett érdemes még tisztában
	    lennünk azzal is, hogy a &os;
	    (alapértelmezés szerint) <link linkend="disk-more-than-full">fenntartja</link> a
	    lemezterület
	    8&nbsp;százalékát.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="disk-more-than-full">
	  <para>Hogyan lehet egy partíció
	    100&nbsp;százaléknál is jobban
	    megtelt?</para>
	</question>

	<answer>
	  <para>Az UFS partíciók egy részét
	    (amely alapértelmezés szerint a teljes
	    kapacitás 8&nbsp;százaléka) az
	    operációs rendszer fenntartja a saját
	    és a <systemitem class="username">root</systemitem>
	    felhasználó számára.  A
	    &man.df.1; ezt a területet nem számolja a
	    <literal>Capacity</literal> oszlopban megjelenõ
	    értékhez, ezért tudja
	    átlépni a 100&nbsp;százalékos
	    arányt.  Sõt még azt is láthatjuk,
	    hogy a blokkok számát jelzõ
	    <literal>Blocks</literal> oszlopban megjelenõ
	    érték mindig, általában pontosan
	    8&nbsp;százalékkal nagyobb, mint a
	    használt blokkokat jelzõ <literal>Used</literal>
	    és a rendelkezésre álló
	    blokkokat jelzõ <literal>Avail</literal> oszlopokban
	    szereplõ értékek összege.</para>

	  <para>A részleteket a &man.tunefs.8; man oldalon
	    belül a <option>-m</option> opció
	    bemutatásánál olvashatjuk.</para>
	</answer>

      </qandaentry>
    </qandaset>
  </chapter>

  <chapter xml:id="admin" xml:lang="hu">
    <title>Rendszeradminisztráció</title>

    <qandaset>
      <qandaentry>
	<question xml:id="startup-config-files">
	  <para>Hol vannak a rendszerindítás
	    beállításáért felelõs
	    állományok?</para>
	</question>

	<answer>
	  <para>Az ezzel kapcsolatos beállítások
	    elsõsorban az
	    <filename>/etc/defaults/rc.conf</filename>
	    állományban találhatóak
	    (lásd &man.rc.conf.5;).  A rendszer
	    indításáért felelõs
	    szkriptek, mint például az <filename>/etc/rc</filename> vagy az <filename>/etc/rc.d</filename> könyvtár
	    tartalma (lásd &man.rc.8;) ezt használja.
	    <emphasis>Ezt az állományt tilos
	    közvetlenül szerkeszteni!</emphasis> Ha valamit
	    meg akarunk változtatni az
	    <filename>/etc/defaults/rc.conf</filename>
	    állományban szereplõ
	    beállítások közül, akkor
	    ehelyett egyszerûen csak másoljuk le az
	    <filename>/etc/rc.conf</filename> állományba
	    és állítsuk be ott az
	    értékét.</para>

	  <para>Például, ha el akarjuk indítani a
	    beépített névfeloldó
	    szolgáltatást, a &man.named.8; démont,
	    akkor ennyit kell tennünk:</para>

	  <screen>&prompt.root; <userinput>echo 'named_enable="YES"' &gt;&gt; /etc/rc.conf</userinput></screen>

	  <para>Ha helyi szolgáltatásokat akarunk
	    futtatni, akkor tegyük a hozzá tartozó
	    szkripteket az <filename>/usr/local/etc/rc.d</filename>
	    könyvtárba.  Ezek a szkriptek legyenek
	    végrehajthatóak és az
	    alapértelmezett állománymóduk
	    legyen <literal>555</literal>.</para>

	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="adding-users">
	  <para>Hogyan lehet felhasználókat
	    egyszerûen létrehozni?</para>
	</question>

	<answer>
	  <para>Használjuk a &man.adduser.8;, vagy bonyolultabb
	    esetekben a &man.pw.8; parancsot.</para>

	  <para>Felhasználókat törölni a
	    &man.rmuser.8;, vagy amennyiben szükséges, a
	    &man.pw.8; paranccsal tudunk.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="root-not-found-cron-errors">
	  <para>A <filename>crontab</filename> szerkesztése
	    után miért jelennek meg a <errorname>root: not
	    found</errorname> és a hozzá hasonló
	    hibaüzenetek?</para>
	</question>

	<answer>
	  <para>Ilyen általában olyankor
	    történik, amikor a rendszerszintû
	    <filename>crontab</filename> állományt
	    módosítjuk
	    (<filename>/etc/crontab</filename>), majd a &man.crontab.1;
	    használatával megpróbáljuk
	    telepíteni:</para>

	  <screen>&prompt.root; <userinput>crontab /etc/crontab</userinput></screen>

	  <para>Ezt nem így kell megoldani.  A
	    rendszerszintû <filename>crontab</filename>
	    felépítése eltér a
	    felhasználókhoz tartozó
	    <filename>crontab</filename>
	    állományokétól (a
	    &man.crontab.5; man oldal szemlélteti
	    részletesebben ezeket az eltéréseket),
	    amelyet a &man.crontab.1; próbál meg ilyenkor
	    telepíteni.</para>

	  <para>Ha így csináltuk, akkor a
	    <filename>crontab</filename> nem lesz több, mint az
	    <filename>/etc/crontab</filename> hibás
	    formátumú változata.
	    Töröljük le:</para>

	  <screen>&prompt.root; <userinput>crontab -r</userinput></screen>

	  <para>Legközelebb, amikor az
	    <filename>/etc/crontab</filename> állományt
	    módosítjuk, nem kell
	    értesítenünk a &man.cron.8;
	    démont, mivel magától észre
	    fogja venni az elvégzett
	    változtatásokat.</para>

	  <para>Ha valamit napi, heti vagy havi rendszerességgel
	    akarunk futtatni, akkor ehelyett inkább másoljuk
	    be az <filename>/usr/local/etc/periodic</filename>
	    könyvtárba, és hagyjuk, hogy a
	    <command>cron</command> hívja meg a &man.periodic.8;
	    parancson keresztül az összes többi
	    rendszeresen elvégzendõ feladattal
	    együtt.</para>

	  <para>Ez a hiba egyébként onnan jön, hogy
	    rendszerszintû <filename>crontab</filename>
	    állomány esetén van még egy
	    további mezõ, amely megadja, hogy az adott
	    parancsot melyik felhasználóval kell futtatni.
	    Az alapértelmezett rendszerszintû
	    <filename>crontab</filename> állomány
	    esetén ez mindenhol a <systemitem class="username">root</systemitem>.
	    Amikor ezt a <filename>crontab</filename>
	    állományt a <systemitem class="username">root</systemitem>
	    <filename>crontab</filename>
	    állományaként használjuk (amely
	    <emphasis>nem</emphasis> ugyanaz, mint a rendszerszintû
	    <filename>crontab</filename>), akkor a &man.cron.8; a
	    <literal>root</literal> szót a
	    végrehajtandó parancs részének
	    fogja tekinteni, amely viszont nem létezik.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="su-wheel-group">
	  <para>Miért jelenik meg a <errorname>you are not in the
	    correct group to su root</errorname> hibaüzenet, amikor a
	    <command>su</command> paranccsal át akarunk
	    váltani a <systemitem class="username">root</systemitem>
	    felhasználóra?</para>
	</question>

	<answer>
	  <para>Ez egy biztonsági megszorítás.
	    Csak úgy tudunk átváltani a
	    <systemitem class="username">root</systemitem> felhasználóra (vagy
	    bármilyen más olyan
	    hozzáférésre, amely
	    rendszeradminisztrátori jogosultságokkal
	    rendelkezik), ha a <systemitem class="groupname">wheel</systemitem> csoport
	    tagjai vagyunk.  Ha nem létezne ez a
	    korlátozás, akkor a rendszerben szinte
	    bárki képes lenne
	    rendszeradminisztrátori jogosultságokat
	    szerezni csupán úgy, hogy ha megszerzi
	    valahogy a <systemitem class="username">root</systemitem> jelszavát.
	    Ennek a korlátozásnak
	    köszönhetõen ez viszont már nem lesz
	    feltétlenül helytálló.  A
	    &man.su.1; még a jelszót sem engedi megadni
	    azoknak, akik nem tagjai a <systemitem class="groupname">wheel</systemitem>
	    csoportnak.</para>

	  <para>Ha engedélyezni akarjuk valakinek a
	    <systemitem class="username">root</systemitem> felhasználóra
	    váltást, akkor nincs más teendõnk,
	    mint egyszerûen a hozzáadni a
	    <systemitem class="groupname">wheel</systemitem> csoporthoz.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="rcconf-readonly">
	  <para>Az <filename>rc.conf</filename>
	    állományban vagy valamelyik másik
	    konfigurációs állományban
	    rosszul adtuk meg a beállításokat,
	    és nem lehet módosítani ezeket, mert
	    így írásvédett lett az
	    állományrendszer.  Mi a
	    megoldás?</para>
	</question>

	<answer>
	  <para>Indítsuk újra a rendszert és a
	    rendszertöltõ parancssorában adjuk ki a
	    <userinput>boot -s</userinput> parancsot, amivel így
	    egyfelhasználós módba váltunk.
	    Amikor meg kell adnunk a használni
	    kívánt parancsértelmezõ
	    nevét, egyszerûen csak nyomjuk le az
	    <keycap>Enter</keycap> billentyût, majd a
	    <command>mount -urw /</command> parancs
	    kiadásával csatlakoztassuk újra
	    írható módban
	    rendszerindító
	    állományrendszert.  Emellett még
	    valószínûleg a <command>mount -a -t
	    ufs</command> paranccsal azokat az
	    állományrendszereket is érdemes lesz
	    csatlakoztatnunk, ahol a kedvenc
	    szövegszerkesztõnk található.
	    Amennyiben az érintett szövegszerkesztõ egy
	    hálózati állományrendszeren
	    található, akkor helyette használjunk
	    egy helyben elérhetõ
	    szövegszerkesztõt, például az
	    &man.ed.1; programot, vagy manuálisan
	    állítsuk be a hálózat
	    elérését a hálózati
	    állományrendszerek
	    csatlakoztatásához.</para>

	  <para>Ha a &man.vi.1; vagy &man.emacs.1; programokhoz
	    hasonló teljes képernyõs
	    szövegszerkesztõt akarunk használni, akkor
	    elõtte nem árt a <command>export
	    TERM=cons25</command> parancsot sem kiadnunk, így a
	    &man.termcap.5; adatbázisból
	    elérhetõvé válnak az ehhez
	    szükséges adatok.</para>

	  <para>Miután megtettük ezeket a
	    lépéseket, már a szokásos
	    módon át tudjuk szerkeszteni az
	    <filename>/etc/rc.conf</filename> állományt.
	    A rendszermag indulása után
	    közvetlenül megjelenõ üzenetekben
	    találhatjuk meg azon sorok számait, amelyeket
	    a rendszer nem tudott értelmezni.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="printer-setup">
	  <para>Miért nem sikerül beállítani a
	    nyomtatót?</para>
	</question>

	<answer>
	  <para>Olvassuk el a kézikönyv <link xlink:href="&url.books.handbook;/printing.html">nyomtatókkal foglalkozó</link>
	    részét, minden bizonnyal választ ad a
	    legtöbb kérdésünkre.</para>

	  <para>Bizonyos nyomtatókat azonban akkor tudunk
	    használni, ha van hozzá meghajtónk.
	    Ezeket gyakran csak <quote>WinPrinter</quote> néven
	    emlegetik, amelyeket viszont a &os; nem támogat.  Ha
	    a nyomtatónk nem használható DOS vagy
	    &windows; alatt, akkor valószínûleg egy
	    ilyen WinPrinterrel van dolgunk.  Ebben az esetben
	    egyedül abban reménykedhetünk, hogy a
	    <package>print/pnm2ppa</package> port
	    támogatja.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="keyboard-mappings">
	  <para>Hogyan lehet módosítani a
	    rendszerünkhöz tartozó
	    billentyûkiosztást?</para>
	</question>

	<answer>
	  <para>Olvassuk el a kézikönyv <link xlink:href="&url.books.handbook;/using-localization.html">honosításssal</link>
	    foglalkozó részét,
	    különös tekintettel a <link xlink:href="&url.books.handbook;/using-localization.html#SETTING-CONSOLE">konzol beállításaira</link>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="pnp-resources">
	  <para>Miért jelenik meg az <errorname>unknown:
	    &lt;PNP0303&gt; can't assign resources</errorname>
	    hibaüzenet a rendszer indulásakor?</para>
	</question>

	<answer>
	  <para>Erre a &a.current; címére postázott
	    egyik levél adja meg a választ:</para>

	  <blockquote>
	    <attribution>&a.wollman;, 2001.  április
	      24.</attribution>

	    <para>A <quote>can't assign resources</quote> üzenetek
	      rendszerünkben olyan ISA eszközök
	      jelenlétére utalnak, amelyekhez a
	      rendszermagban PnP támogatást nem
	      tartalmazó meghajtók tartoznak.  Ilyenek
	      többek közt a
	      billentyûzetvezérlõk, a
	      programozható
	      megszakítás-vezérlõ chip
	      és sok más alapvetõ elem a
	      gépünkben.  Ezek az erõforrások
	      nem oszthatóak ki, mivel már valamelyik
	      meghajtó használatba vette ezeket.</para>
	  </blockquote>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="user-quotas">
	  <para>Miért nem mûködnek rendesen a
	    kvóták?</para>
	</question>

	<answer>
	   <orderedlist>
	      <listitem>
		<para>Elõfordulhat, hogy a rendszermag nem
		  támogatja a kvóták
		  használatát.  Ha errõl lenne
		  szó, akkor vegyük fel az alábbi
		  sort a rendszermag konfigurációs
		  állományába és
		  fordítsuk újra:</para>

		 <programlisting>options QUOTA</programlisting>

		<para>Ennek részleteit a <link xlink:href="&url.books.handbook;/quotas.html">kézikönyv</link>
		  kvótákkal foglalkozó
		  részében találjuk.</para>
	      </listitem>

	      <listitem>
		<para>Az <filename>/</filename>
		  állományrendszeren ne
		  engedélyezzük a kvóták
		  használatát.</para>
	      </listitem>

	      <listitem>
		<para>Tegyünk
		  kvótaállományokat azokra az
		  állományrendszerekre, ahol be akarjuk
		  vezetni a használatukat,
		  például:</para>

		<informaltable frame="none" pgwide="1">
		  <tgroup cols="2">
		    <thead>
		      <row>
			<entry>Állományrendszer</entry>
			<entry>Kvótaállomány</entry>
		      </row>
		    </thead>

		    <tbody>
		      <row>
			<entry><filename>/usr</filename></entry>
			<entry><filename>/usr/admin/quotas</filename></entry>
		      </row>

		      <row>
			<entry><filename>/home</filename></entry>
			<entry><filename>/home/admin/quotas</filename></entry>
		      </row>

		      <row>
			<entry>&hellip;</entry>
			<entry>&hellip;</entry>
		      </row>
		    </tbody>
		  </tgroup>
		</informaltable>
	      </listitem>
	    </orderedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="sysv-ipc">
	  <para>A &os; tartalmazza a System V IPC
	    alapeszközeit?</para>
	</question>

	<answer>
	  <para>Igen, a &os; a <filename>GENERIC</filename>
	    típusú rendszermagban támogatja a System
	    V típusú IPC megoldást,
	    beleértve az osztott memória, az üzenetek
	    és a szemaforok használatát.  Ha
	    saját rendszermagunk van, akkor az alábbi
	    beállítások használatával
	    engedélyezhetjük a használatukat:</para>

	  <programlisting>options    SYSVSHM          # az osztott memória engedélyezése
options    SYSVSEM          # a szemaforok engedélyeze
options    SYSVMSG          # az üzenetek kezelése</programlisting>

	  <para>Fordítsuk és telepítsük
	    újra a rendszermagot.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="sendmail-alternative">
	  <para>A <application>sendmail</application> helyett milyen
	    más levelezõ szerver használható
	    még?</para>
	</question>

	<answer>
	  <para>A <link xlink:href="http://www.sendmail.org/"><application>sendmail</application></link>
	    a &os;-ben található alapértelmezett
	    levelezõ szerver, de könnyen le tudjuk
	    cserélni másikra (például
	    amelyet a portok közül
	    telepítettünk).</para>

	  <para>A Portgyûjteményben több
	    különbözõ levelezõ szerver is
	    megtalálható, amelyek közül a
	    <package>mail/exim</package>, <package>mail/postfix</package>, <package>mail/qmail</package> és a <package>mail/zmailer</package> portok a
	    leginkább népszerûek.</para>

	  <para>Szép dolog, hogy lehet válogatni a
	    különbözõ megoldások
	    között és hogy ilyen sok levelezõ
	    szerver használható.  Ezért
	    lehetõleg a levelezési listákon ne
	    kérdezzünk senkitõl olyat, hogy <quote>De a
	    <application>sendmail</application> akkor most miért
	    jobb, mint a <application>qmail</application>?</quote> Ha
	    ilyen kérdéseink vannak, akkor
	    elõször inkább olvassuk át az
	    archívumokat.  Szinte biztos, hogy már szinte
	    az összes levelezõ szerver elõnyét
	    és hátrányát
	    kivesézték jó
	    néhányszor.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="forgot-root-pw">
	  <para>Elveszett a <systemitem class="username">root</systemitem>
	    felhasználó jelszava!  Mit tegyünk?</para>
	</question><answer>

	  <para>Ne essünk kétségbe!  Indítsuk
	    újra a rendszerünket
	    egyfelhasználós módban.  Ehhez
	    gépeljük be a <userinput>boot -s</userinput>
	    parancsot a rendszertöltõ <literal>Boot:</literal>
	    parancssorában.  Amikor a
	    parancsértelmezõt kell megadnunk,
	    egyszerûen csak nyomjuk le az <keycap>Enter</keycap>
	    billentyût.  Ekkor kapunk egy &prompt.root;
	    parancssort.  A <command>mount -urw /</command> parancs
	    begépelésével csatlakoztassuk
	    újra a rendszerindító
	    partíciónkat írható
	    módban, majd a <command>mount -a</command> paranccsal
	    csatlakoztassuk az összes többi
	    állományrendszert.  Ezt követõen a
	    <command>passwd root</command> parancs
	    kiadásával változtassuk meg a
	    <systemitem class="username">root</systemitem> felhasználó
	    jelszavát és a &man.exit.1;
	    futtatásával folytassuk a rendszer
	    indítását.</para>

	  <note>
	    <para>Ha az egyfelhasználós módra
	      váltás során a rendszer a
	      <systemitem class="username">root</systemitem> felhasználó
	      jelszavát kérné, akkor az arra utal,
	      hogy a konzol (<filename>/dev/console</filename>) az
	      <filename>/etc/ttys</filename> állomány
	      szerint <literal>insecure</literal> (nem
	      biztonságos) típusú.  Ebben az
	      esetben szereznünk kell egy &os;
	      telepítõlemezt, elindítanunk
	      róla a rendszert, majd a &man.sysinstall.8;
	      programban a <guimenuitem>Fixit</guimenuitem>
	      menüponton keresztül indított
	      parancsértelmezõben kiadni az elõbb
	      említett parancsokat.</para>
	  </note>

	  <note>
	    <para>Ha egyfelhasználós módban nem
	      tudjuk csatlakoztatni a rendszerindító
	      partíciót, akkor ennek könnyen az lehet
	      az oka, hogy a partíciókat
	      titkosították, ezért a megfelelõ
	      kulcsok nélkül nem tudjuk elérni
	      ezeket.  Ez leginkább adott
	      implementációtól függ.  A
	      &os;-ben elõforduló
	      lemeztitkosításokkal kapcsolatban a <link xlink:href="&url.books.handbook;/disks-encrypting.html">kézikönyv</link>
	      ad bõvebb útmutatást.</para>
	  </note>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="CAD-reboot">
	  <para>Hogyan akadályozható meg, hogy a <keycombo action="simul"><keycap>Control</keycap><keycap>Alt</keycap><keycap>Delete</keycap></keycombo>
	    billentyûkombináció
	    újraindítsa a rendszert?</para>
	</question>

	<answer>
	  <para>Ha a &man.syscons.4; (vagyis az alapértelmezett)
	    konzolt használjuk, akkor ehhez a következõ
	    beállításokkal kell fordítanunk
	    és telepítenünk egy rendszermagot:</para>

	  <programlisting>options SC_DISABLE_REBOOT</programlisting>

	  <para>Mindezt a rendszermag újrafordítása
	    és a újraindítása
	    nélkül is le tudjuk tiltani, ha
	    beállítjuk az alábbi
	    &man.sysctl.8;-változót:</para>

	  <screen>&prompt.root; <userinput>sysctl hw.syscons.kbd_reboot=0</userinput></screen>

	  <note>
	    <para>Az elõbb említett két
	      módszer kizárja egymást.  A
	      &man.sysctl.8; változó nem létezik,
	      ha a rendszermagot a <literal>SC_DISABLE_REBOOT</literal>
	      beállítással fordítjuk
	      újra.</para>
	  </note>

	  <para>Ha viszont a &man.pcvt.4; konzolt használjuk,
	    akkor a következõ konfigurációs
	    beállítást kell megadnunk a rendszermag
	    újrafordításakor:</para>

	  <programlisting>options PCVT_CTRL_ALT_DEL</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="dos-to-unix-txt">
	  <para>Hogyan lehet szöveges DOS
	    állományokat &unix; formátumúra
	    alakítani?</para>
	</question>

	<answer>
	  <para>Használjuk a következõ &man.perl.1;
	    parancsot:</para>

	  <screen>&prompt.user; <userinput>perl -i.bak -npe 's/\r\n/\n/g' állományok</userinput></screen>

	  <para>ahol az
	    <replaceable>állományok</replaceable> az
	    átalakítandó állományok.
	    A konverzió helyben történik, illetve az
	    eredeti állományokról
	    <filename>.bak</filename> kiterjesztéssel
	    létrejön egy biztonsági
	    mentés.</para>

	  <para>Erre a célra viszont ugyanígy megfelel a
	    &man.tr.1; parancs is:</para>

	  <screen>&prompt.user; <userinput>tr -d '\r' &lt; dos-szöveges-állomány &gt; unix-szöveges-állomány</userinput></screen>

	  <para>Ekkor a
	    <replaceable>dos-szöveges-állomány</replaceable>
	    lesz a DOS formátumú szöveges
	    állomány, miközben a
	    <replaceable>unix-szöveges-állomány</replaceable>
	    fogja az eredményt tartalmazni.  Ez valamivel
	    gyorsabb a <command>perl</command>
	    megoldásánál.</para>

	  <para>Ez említett megoldásokon kívül
	    a DOS szöveges állományait a
	    Portgyûjteményben található
	    <package>converters/dosunix</package> porttal is
	    könnyedén át tudjuk alakítani.
	    Ennek részleteit a hozzá tartozó
	    dokumentációból tudjuk meg.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="kill-by-name">
	  <para>Hogyan lehet futó programokat név szerint
	    leállítani?</para>
	</question>

	<answer>
	  <para>Lásd &man.killall.1;.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="root-acl">
	  <para>A &man.su.1; miért írja folyton, hogy a
	    felhasználó nincs a <systemitem class="username">root</systemitem>
	    ACL-jében?</para>
	</question>

	<answer>
	  <para>Ezt a hibát az elosztott
	    hitelesítést végzõ
	    <application>Kerberos</application> rendszer adja.  Maga a
	    probléma nem végzetes, viszont annál
	    inkább idegesítõ.  Ilyenkor vagy a
	    <option>-K</option> kapcsolóval kell futtatni a
	    &man.su.1; programot, vagy a következõ
	    kérdésben megadottak szerint el kell
	    távolítani a
	    <application>Kerberos</application>
	    alkalmazást.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="uninstall-kerberos">
	  <para>Hogyan távolítható el a
	    <application>Kerberos</application>?</para>
	</question>

	<answer>
	  <para>A <application>Kerberos</application> úgy
	    távolítható el a rendszerbõl, ha
	    újratelepítjük a <literal>base</literal>
	    terjesztés tartalmát.  Ha CD-rõl
	    telepítettük a rendszert, akkor csatlakoztassuk
	    (most tegyük fel, hogy a <filename>/cdrom</filename> könyvtárba)
	    és futassuk a következõ parancsot:</para>

	  <screen>&prompt.root; <userinput>cd /cdrom/base</userinput>
&prompt.root; <userinput>./install.sh</userinput></screen>

	  <para>Másik lehetõség, ha hozzáadjuk
	    a <varname>NO_KERBEROS</varname>
	    beállítást a
	    <filename>/etc/make.conf</filename>
	    állományhoz és
	    újrafordítjuk az alaprendszert.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="where-is-makedev">
	  <para>Mi történt a
	    <filename>/dev/MAKEDEV</filename>
	    állománnyal?</para>
	</question>

	<answer>
	  <para>A &os;&nbsp;5.<replaceable>X</replaceable> és
	    a késõbbi változatok már a
	    &man.devfs.8; által felkínált
	    automatikus megoldást alkalmazzák.  Ilyenkor
	    az eszközmeghajtók igény szerint hoznak
	    létre eszközleírókat, és
	    ezzel lényegében
	    szükségtelenné teszik a
	    <filename>/dev/MAKEDEV</filename>
	    használatát.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="add-pty">
	  <para>Hogyan lehet még több
	    pszeudoterminált létrehozni?</para>
	</question>

	<answer>
	  <para>Ha sok <command>telnet</command>,
	    <command>ssh</command>, X esetleg <command>screen</command>
	    felhasználónk van, akkor könnyen
	    elõfordulhat, hogy kifogyunk a
	    pszeudoterminálokból.  A &os;&nbsp;6.2
	    és az azt megelõzõ változatokban
	    alapértelmezés szerint 256
	    pszeudoterminál, a &os;&nbsp;6.3 és
	    késõbbi változatokban pedig 512
	    pszeudoterminál áll
	    rendelkezésünkre.</para>

	  <tip>
	    <para>Szükség esetén további
	      pszeudoterminálok is hozzáadhatóak a
	      rendszerhez.  Ehhez azonban módosítanunk
	      kell a szabványos C
	      függvénykönyvtárakat, a
	      rendszermagot és az <filename>/etc/ttys</filename>
	      állományt.  Például a <uri xlink:href="http://www.freebsd.org/~jhb/patches/pty_1152.patch">http://www.freebsd.org/~jhb/patches/pty_1152.patch</uri>
	      1152 pszeudoterminál használatát
	      teszi lehetõvé.  Ez a konkrét
	      javítás viszont csak a &os;&nbsp;6.3
	      és késõbbi változatok
	      esetén alkalmazható
	      zökkenõmentesen.</para>
	  </tip>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="reread-rc">
	  <para>Hogyan lehet újraindítás
	    nélkül az <filename>/etc/rc.conf</filename>
	    tartalmát újraolvastatni és
	    újraindítani az <filename>/etc/rc</filename>
	    szkriptet?</para>
	</question>

	<answer>
	  <para>Váltsunk egyfelhasználós
	    módba, majd vissza többfelhasználós
	    módba.</para>

	  <para>Konzolon ez így oldható meg:</para>

	  <screen>&prompt.root; <userinput>shutdown now</userinput>
(Megjegyzés: nincs -r vagy -h!)

&prompt.root; <userinput>return</userinput>
&prompt.root; <userinput>exit</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="release-candidate">
	  <para>A <emphasis>-STABLE</emphasis> rendszer
	    frissítésekor
	    <emphasis>-BETA<replaceable>x</replaceable></emphasis>,
	    <emphasis>-RC</emphasis> vagy
	    <emphasis>-PRERELEASE</emphasis> verzió jelenik meg!
	    Mi történt?</para>
	</question>

	<answer>
	  <para>Röviden: Ez csak egy elnevezés.  Az
	    <emphasis>RC</emphasis> jelentése <quote>Release
	    Candidate</quote>, vagyis <quote>kiadásra
	    jelölt</quote>.  Ez egy küszöbön
	    álló kiadásra utal.  A &os;-ben a
	    <emphasis>-PRERELEASE</emphasis> elnevezés
	    általában egyenlõ a kiadások
	    elõtt bekövetkezõ
	    kódfagyasztással.  (Bizonyos kiadások
	    esetén pedig a <emphasis>-BETA</emphasis>
	    címkét a <emphasis>-PRERELEASE</emphasis>
	    megjelöléshez hasonlóan
	    használják.)</para>

	  <para>Valamivel bõvebben: A &os;
	    fejlesztésében a kiadások
	    általában két helyrõl
	    származnak.  A nagyobb, ún.
	    <quote>nullás</quote> kiadások, mint
	    például 7.0-RELEASE és 8.0-RELEASE, a
	    fejlesztési ág legfrissebb
	    állapotából készülnek,
	    amelyet gyakran csak <link linkend="current">-CURRENT</link>
	    néven emlegetnek.  A kisebb kiadások, mint
	    például a 6.3-RELEASE vagy az 5.2-RELEASE, az
	    aktív <link linkend="stable">-STABLE</link>
	    ágból származnak.  A 4.3-RELEASE
	    kiadástól kezdõdõen mindegyik
	    kiadás saját ággal rendelkezik, amelyet
	    elsõsorban olyanoknak ajánlunk, akiknek csak
	    nagyon visszafogott változtatásokra van
	    szükségük a rendszerben (ezek
	    általában csak különbözõ
	    biztonsági javításokat
	    takarnak).</para>

	  <para>Amikor a fejlesztõk készíteni akarnak
	    egy újabb kiadást, az alapjául
	    szolgáló fejlesztési ágon
	    elvégeznek bizonyos mûveleteket.  Ennek egy
	    része a források
	    <quote>befagyasztása</quote>.  Amikor ez
	    megkezdõdik, az ág neve megváltozik,
	    és ezzel jelzik, hogy hamarosan kiadás
	    készül belõle.  Például, ha
	    egy ág a 6.2-STABLE nevet viseli, akkor a
	    6.3-PRERELEASE névre vált arra az
	    idõszakra, amíg tart a
	    kódfagyasztás és lezajlik a
	    kiadások megjelentetéséhez
	    szükség további tesztelés.
	    Hibajavítások ekkor továbbra is
	    rakhatóak bele.  Ahogy a források
	    elérik a kiadáshoz szükséges
	    szintet, az ág neve 6.3-RC-re vált, és
	    ezzel jelzik, hogy a kiadás
	    elõkészítése hamarosan
	    befejezõdik.  Az <emphasis>RC</emphasis>
	    állapotban csak a legfontosabb hibákat keresik
	    meg és javítják.  Miután a
	    kiadás (jelen esetünkben a 6.3-RELEASE
	    kiadás) és a hozzá tartozó
	    ág elkészült, az ág neve
	    ismét 6.3-STABLE lesz.</para>

	  <para>A verziószámokról és a
	    CVS-ben található különbözõ
	    ágakról a <link xlink:href="&url.articles.releng.en;/article.html">Release
	    Engineering</link> címû cikkben olvashatunk
	    (angolul).</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="kernel-chflag-failure">
	  <para>Az új rendszermag telepítése
	    során a &man.chflags.1; program hibát jelez.
	    Hogyan javítható ez a hiba?</para>
	</question>

	<answer>
	  <para>Rövid válasz: A rendszerünk
	    valószínûleg nullánál nagyobb
	    biztonsági szinten fut.  Indítsuk újra
	    a rendszerünket egyfelhasználós
	    módban és úgy telepítsük a
	    rendszermagot.</para>

	  <para>A hosszabb válasz: A &os; nem engedi
	    megváltoztatni a rendszerszintû
	    állományjelzõket nullától a
	    nagyobb biztonsági szinteken.  A jelenleg
	    érvényben levõ biztonsági szintet
	    a következõ paranccsal lehet
	    lekérdezni:</para>

	  <screen>&prompt.root; <userinput>sysctl kern.securelevel</userinput></screen>

	  <para>A biztonsági szintet nem lehet csökkenteni.
	    A rendszert egyfelhasználós módban kell
	    újraindítani, mert csak úgy tudjuk
	    újratelepíteni a rendszermagot.  Másik
	    lehetõségünk, ha
	    átállítjuk a biztonsági szintet
	    az <filename>/etc/rc.conf</filename>
	    állományban és úgy
	    indítjuk újra a rendszerünket.  Az
	    &man.init.8; man oldalán olvashatunk bõvebben a
	    biztonsági szintek (<literal>securelevel</literal>)
	    beállításáról, az
	    <filename>rc.conf</filename>
	    használatáról pedig az
	    <filename>/etc/defaults/rc.conf</filename>
	    állományból és a &man.rc.conf.5;
	    man oldalon tudhatunk meg többet.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="kernel-securelevel-time">
	  <para>A rendszeren nem lehet egyszerre egy
	    másodpercnél többel megváltoztatni
	    az idõt!  Hogyan lehet megkerülni ezt a
	    korlátozást?</para>
	</question>

	<answer>
	  <para>A rövid válasz: A rendszerünkben a
	    biztonsági szintet (<literal>securelevel</literal>)
	    minden bizonnyal egynél nagyobbra
	    állították.  Indítsuk
	    újra a rendszert egyfelhasználós
	    módban és változtassuk meg a
	    dátumot.</para>

	  <para>Egy hosszabb válasz: A &os; nem engedi egy
	    másodpercnél többel megváltoztatni
	    az idõt, ha az aktuális biztonsági szint
	    értéke egy felett van.  Ezt a
	    következõ parancs kiadásával tudjuk
	    ellenõrizni:</para>

	  <screen>&prompt.root; <userinput>sysctl kern.securelevel</userinput></screen>

	  <para>A biztonsági szint futás közben nem
	    csökkenthetõ.  A dátum
	    megváltoztatásához ezért a
	    rendszert egyfelhasználós módban kell
	    indítanunk, vagy az <filename>/etc/rc.conf</filename>
	    állományban csökkentenünk kell a
	    biztonsági szintet.  Az &man.init.8; man oldalon
	    olvashatunk részletesebben a biztonsági
	    szintek mûködésérõl, illetve az
	    <filename>/etc/defaults/rc.conf</filename>
	    állományból és az
	    &man.rc.conf.5; man oldalról tudhatunk meg
	    többet az <filename>rc.conf</filename>
	    mûködésérõl.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="statd-mem-leak">
	  <para>Az <command>rpc.statd</command> parancsnak miért
	    kell 256&nbsp;MB memória?</para>
	</question>

	<answer>
	  <para>Nem, itt szó sincs semmiféle
	    memóriaszivárgásról, és
	    egyébként sem használ 256&nbsp;MB
	    memóriát.  Az <command>rpc.statd</command>
	    parancs egyszerûen csak kényelmi
	    megfontolásokból iszonyatos
	    mennyiségû memóriát képez
	    le a címterébe.  Ebben technikailag semmi
	    kivetnivaló nincsen, ezzel egyedül a
	    &man.top.1;, &man.ps.1; és a hozzá
	    hasonló programokat zavarja meg egy kicsit.</para>

	  <para>A &man.rpc.statd.8; tehát leképezi az
	    állapotát rögzítõ
	    állományt (amely a <filename>/var</filename> könyvtárban
	    található a címterébe.  Ilyenkor
	    igyekszik egy kicsit elõre gondolkodni és
	    felkészülni a
	    megnövekedésére, ezért viszonylag
	    nagy méretben hozza létre ezt a
	    leképezést.  Ezt nagyon jól
	    megfigyelhetjük a
	    forráskódjából is, ahol
	    látszik, hogy a &man.mmap.2; függvényt a
	    <literal>0x10000000</literal> értékkel
	    hívja meg, tehát az 32&nbsp;bites Intel
	    architektúrán megcímezhetõ
	    memória egytizenhatod részével, ami
	    pontosan 256&nbsp;MB.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="unsetting-schg">
	  <para>Miért nem törölhetõ az
	    <literal>schg</literal>
	    állományjelzõ?</para>
	</question>

	<answer>
	  <para>Rendszerünkben a biztonsági szint
	    (<literal>securelevel</literal>) nagyobb
	    nullánál.  Próbáljuk meg
	    csökkenteni az értékét és
	    próbálkozzunk ismét.  Ezzel
	    kapcsolatban részletesebb információkat
	    a <link linkend="securelevel">a biztonsági
	    szintekrõl szóló
	    kérdésbõl</link> vagy az &man.init.8; man
	    oldalról tudhatunk meg.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ssh-shosts">
	  <para>Az <filename>.shosts</filename> állományon
	    keresztül alapértelmezés szerint
	    miért enged hitelesíteni a legújabb
	    &os; verziókban megtalálható
	    <application>SSH</application>?</para>
	</question>

	<answer>
	  <para>A legújabb &os; verziókban azért
	    nem tudjuk az <filename>.shosts</filename>
	    állományon keresztül hitelesíteni
	    magunkat, mert az &man.ssh.1; alapértelmezés
	    szerint rendszeradminisztrátori jogok
	    nélkül kerül telepítésre.
	    Ezt a <quote>hibát</quote> többféle
	    módon ki tudjuk
	    <quote>javítani</quote>:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Ha tartós megoldásra van
		szükségünk, akkor az
		<filename>/etc/make.conf</filename>
		állományban állítsuk az
		<varname>ENABLE_SUID_SSH</varname>
		változót a <literal>true</literal>
		értékre, majd fordítsuk újra
		az &man.ssh.1; programot (vagy futtassuk le a
		<command>make world</command>
		parancsot).</para>
	    </listitem>

	    <listitem>
	      <para>Ha ideiglenesen akarjuk csak javítani, akkor
		az <filename>/usr/bin/ssh</filename>
		állomány engedélyeit
		<systemitem class="username">root</systemitem>
		felhasználóként
		állítsuk a <literal>4555</literal>
		értékre a <command>chmod 4555
		/usr/bin/ssh</command> parancs kiadásával.
		Ezután vegyük fel az
		<literal>ENABLE_SUID_SSH=
		true</literal> sort az
		<filename>/etc/make.conf</filename>
		állományt, így ez a
		változtatás a <command>make
		world</command>
		következõ futtatásakor is
		megmarad.</para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="vnlru">
	  <para>Mi az a <literal>vnlru</literal>?</para>
	</question>

	<answer>
	  <para>A <literal>vnlru</literal> törli és
	    szabadítja fel a rendszerben keringõ vnode-okat,
	    amikor a rendszermagban elérik a
	    <varname>kern.maxvnodes</varname> változó
	    által beállított határt.  Ez a
	    rendszermagban futó szál többnyire csak
	    tétlenül ül a háttérben,
	    és csak olyankor lép
	    mûködésben, amikor rengeteg
	    memóriát használunk és
	    éppen több tízezernyi apró
	    állományhoz akarunk egyszerre
	    hozzáférni.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="top-memory-states">
	  <para>Mit jelentenek <command>top</command> parancs
	    által megjelenített
	    különbözõ
	    memóriaállapotok?</para>
	</question>

	<answer>
	  <itemizedlist>
	    <listitem>
	      <para><literal>Active</literal> (Aktív): az
		utóbbi idõben használt lapok.</para>
	    </listitem>

	    <listitem>
	      <para><literal>Inactive</literal> (Inaktív): az
		utóbbi idõben nem használt
		lapok.</para>
	    </listitem>

	    <listitem>
	      <para><literal>Cache</literal> (Tárazott):
		(leginkább) azok a lapok, amelyeket még
		használnak, de gyakran azonnal
		újrafelhasználódnak (akár a
		régi, akár egy új
		hozzárendelésben).  Egyes lapok az
		<literal>active</literal> állapotból
		közvetlenül a <literal>cache</literal>
		állapotba váltanak, ha tiszták (nem
		módosították), de ez az
		átmenet függ a házirendtõl,
		vagyis a VM alrendszer karbantartója által
		kiválasztott algoritmustól.</para>
	    </listitem>

	    <listitem>
	      <para><literal>Free</literal> (Szabad): effektív
		tartalom nélküli lapok, amelyek akár
		közvetlenül fel is használhatóak
		olyan esetekben, amikor a tárazott lapok erre nem
		alkalmasak.  A szabad lapokat
		megszakításokban és a futó
		programokban is felhasználhatjuk.</para>
	    </listitem>

	    <listitem>
	      <para><literal>Wired</literal> (Rögzített):
		olyan lapok, amelyek a memória egy
		rögzített pontján foglalnak helyet.
		Ezeket többnyire a rendszermag használja, de
		speciális esetekben a programoknak is
		szükségük lehet rá.</para>
	    </listitem>
	  </itemizedlist>

	  <para>A lapok általában akkor kerülnek ki a
	    lemezre (valamilyen VM alrendszerbeli
	    szinkronizáció során), amikor
	    inaktív állapotban vannak, de akár az
	    aktív lapok is szinkronizálhatóak.  Ez
	    attól függ, hogy a processzor képes-e
	    nyomkövetni a lapok
	    módosítását, és
	    némely helyzetekben elõnyös lehet a
	    rendszer számára, ha annak megfelelõen
	    szinkronizálja a VM lapjait, hogy azok aktívak
	    vagy inaktívak.  A legtöbb esetben itt
	    egyszerûen csak egy olyan sort kell elképzelni,
	    ahol a program számára viszonylag
	    inaktív lapok találhatóak, amelyeket a
	    rendszer tetszõlegesen a lemezre írhat.  A
	    tárazott lapok általában már
	    eleve szinkronizáltak, nem leképzettek,
	    közvetlenül a programok régi és
	    új hozzárendelései
	    használják ezeket.  A szabad lapokat
	    akár a megszakítások szintjén is
	    lehet használni, miközben a tárazott vagy
	    szabad lapokat a futó programokban
	    érthetjük el.  A tárazott lapok
	    zárolása nem megfelelõ ahhoz, hogy
	    megszakításokban is el lehessen érni
	    ezeket.</para>

	  <para>Vannak még bizonyos jelzések
	    (például a foglaltságot vagy
	    foglaltság mértékét jelzõ
	    értékek), amelyek még hatással
	    vannak a fentebb leírt szabályokra.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="free-memory-amount">
	  <para>Mekkora a rendelkezésre álló
	    memória mérete?</para>
	</question>

	<answer>
	  <para>A <quote>rendelkezésre álló
	    memóriának</quote> rengeteg típusa
	    létezik.  Ezek közül egyik az a
	    memória, amely közvetlenül
	    anélkül elérhetõ, hogy bármi
	    mást ki kellene hozzá lapoznunk.  Ennek a
	    mérete nagyjából a tárazott
	    és a szabad lapokat tároló sorok
	    hosszával arányos (amelyet még a
	    rendszer beállításaitól
	    függõ további tényezõk is
	    módosíthatnak).  A <quote>rendelkezésre
	    álló memória</quote> másik
	    típusa a teljes <acronym>VM</acronym> terület
	    mérete.  Ezt nem olyan könnyû
	    meghatározni, de leginkább a
	    lapozóterület és a fizikai memória
	    méretétõl függ.  A
	    <quote>rendelkezésre álló
	    memória</quote> több más
	    lehetséges megfogalmazása is létezik,
	    de szinte teljesen felesleges beszélni róluk.
	    Egyedül az a fontos, hogy a igyekezzünk
	    mérsékelni a lapozást és mindig
	    legyen elegendõ
	    lapozóterületünk.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="var-empty">
	  <para>Mi az a <filename>/var/empty</filename>?  Nem lehet
	    letörölni!</para>
	</question>

	<answer>
	  <para>A <filename>/var/empty</filename>
	    könyvtárat az &man.sshd.8; program
	    használja a privilégiumok
	    elkülönítéséhez.  A <filename>/var/empty</filename>
	    könyvtárnak üresnek kell lennie, legyen a
	    <systemitem class="username">root</systemitem> tulajdonában és
	    legyen rajta a <literal>schg</literal>
	    állományjelzõ.</para>

	  <para>Noha semmiképpen sem javasoljuk a
	    könyvtár törlését, úgy
	    tudjuk elvégezni, ha elõször az
	    <literal>schg</literal> állományjelzõt
	    töröljük róla.  A &man.chflags.1; man
	    oldalán olvashatunk ezzel kapcsolatban
	    részletesebb információkat (azonban ne
	    felejtsük el <link linkend="unsetting-schg">számításba venni az esetleges nehézségeket</link>).
	    </para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter xml:id="x" xml:lang="hu">
    <title>Az X Window System és a virtuális konzolok
      használata</title>

    <qandaset>
      <qandaentry>
	<question xml:id="whatis-X">
	  <para>Mi az X&nbsp;Window&nbsp;System?</para>
	</question>

	<answer>
	  <para>Az X&nbsp;Window&nbsp;System (vagy gyakran csak
	    <literal>X11</literal>) a &unix; és &unix;-szerû
	    operációs rendszereken, így többek
	    közt a &os;-n is az egyik leginkább elterjedt
	    ablakozórendszer.  A <link xlink:href="http://www.x.org/wiki/">The X.Org Foundation</link>
	    felügyeli az <link xlink:href="http://en.wikipedia.org/wiki/X_Window_System_core_protocol">X
	    protokoll szabványait</link>, azok aktuális
	    referencia implementációival együtt.
	    Ezek hivatalos megnevezése <quote>Version 11 Release
	    &xorg.version;</quote>, de ezt gyakran csak
	    <literal>X11</literal> néven
	    rövidítik.</para>

	  <para>Számos implementációja is
	    elérhetõ több különbözõ
	    architektúrára és
	    operációs rendszerre.  A protokoll szerver
	    oldali funkcióit megvalósító
	    programokat hivatalosan <quote>X szervereknek</quote>
	    nevezik.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="which-X">
	  <para>&os; alatt milyen X implementációk
	    használhatóak?</para>
	</question>

	<answer>
	  <para>Kezdetben a &os; alapértelmezett X
	    implementációja az &xfree86; volt, amelyet a
	    <link xlink:href="http://www.xfree86.org">The XFree86 Project,
	    Inc.</link> tartott karban.  Ez a változat volt
	    használatban alapértelmezés szerint
	    egészen a &os; 4.10 és 5.2
	    verziójáig.  Habár eközben az
	    &xorg; maga is karbantartotta a saját
	    változatát, kizárólag csak
	    referencia célokat használt és az
	    évek során teljesen leromlott az
	    állapota.</para>

	  <para>2004 elején azonban az XFree86
	    néhány korábbi fejlesztõje elhagyta
	    a projektjüket, mivel nem értettek egyet
	    bizonyos kérdésekben, például a
	    forráskód ütemét, a
	    jövõbeni irányokat és egyéb
	    személyes konfliktusokat illetõen, és
	    helyette közvetlenül az &xorg;
	    kódját kezdték el fejleszteni.  Ekkor
	    az &xorg; hozzáigazította forrásait az
	    utolsó &xfree86; kiadás forrásaihoz
	    (<application>XFree86&nbsp;4.3.99.903</application>), majd
	    megváltoztatta a licencelését.
	    és beolvasztott több, korábban
	    külön karbantartott változtatást,
	    aminek eredményeképpen végül
	    megszületett az <application>X11R6.7.0</application>.
	    Egy különálló, de velük
	    együttmûködõ projekt, a <link xlink:href="http://www.freedesktop.org/wiki/">freedesktop.org</link>
	    (vagy röviden csak <literal>fd.o</literal>) jelenleg is
	    az eredeti &xfree86; források
	    újraszervezésén dolgozik, aminek
	    célja a napjainkban megjelenõ grafikus
	    kártyák minél nagyobb
	    mértékû kihasználása
	    (és ezáltal a rendszer
	    gyorsítása), a rendszer modularisabbá
	    tétele (ezáltal a rendszer
	    karbantarthatóságának
	    javítása, ami a kiadások gyorsabb
	    elõkészítését és
	    könnyebb
	    beállíthatóságát teszi
	    lehetõvé).  Az &xorg; a jövõben
	    tervezi a <literal>freedesktop.org</literal>
	    fejlesztéseit is átvenni.</para>

	  <para>2004 júliusától kezdõdõen
	    a &os.current; változatban az &xfree86; helyett az
	    &xorg; lett az alapértelmezett X
	    implementáció.  A &os;-ben azóta is
	    alapból az &xorg; X11 implementációja
	    található meg.</para>

	  <para>A témával kapcsolatban a
	    kézikönyv <link xlink:href="&url.books.handbook;/x11.html">X11-rõl
	    szóló</link> fejezetében kaphatunk
	    részletesebb
	    felvilágosítást.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="xfree86-split">
	  <para>Mégis miért vált szét a
	    két X&nbsp;projekt?</para>
	</question>

	<answer>
	  <para>Ezt a kérdést ez a GYIK nem tudja
	    megválaszolni.  Ezzel kapcsolatban viszont
	    érdemes elolvasnunk a különbözõ
	    levelezési listák archívumait szerte az
	    interneten.  Keressünk rá a válaszra a
	    kedvenc keresõnkben, de ezzel a kérdéssel
	    ne a &os; levelezési listáit zavarjuk.  Az is
	    elképzelhetõ, hogy ennek a valós okait
	    csak néhányan ismerik egész
	    teljesen.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="why-choose-xorg">
	  <para>A &os; miért az &xorg; változatát
	    választotta alapértelmezettnek?</para>
	</question>

	<answer>
	  <para>Az &xorg; fejlesztõi azt
	    ígérték, hogy gyorsabban fognak
	    újabb verziókat kiadni, amelyek sokkal
	    több újítást is fognak
	    tartalmazni.  Nos, amennyiben tényleg
	    állják a szavukat, azzal mindenki jól
	    jár.  Emellett az õ változatuk
	    továbbra is a hagyományos X licenc alatt
	    érhetõ el, miközben az &xfree86; licence
	    ettõl némileg eltér.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="running-X">
	  <para>Hogyan lehet használni az X-et?</para>
	</question>

	<answer>
	  <para>Amennyiben már egy meglévõ rendszerre
	    szeretnénk telepíteni az X-et, úgy
	    érdemes a <package>x11/xorg</package> metaportot
	    választanunk, amely magától
	    feltelepíti az összes szükséges
	    komponenst, vagy egyszerûen telepítsük az
	    &xorg; alkalmazást csomagból:</para>

	  <screen><userinput>&prompt.root; pkg_add -r xorg</userinput></screen>

	  <para>Emellett az &xorg; a &man.sysinstall.8;
	    használatával is telepíthetõ:
	    válasszuk a <guimenuitem>Configure</guimenuitem>
	    (Beállítások),
	    <guimenuitem>Distributions</guimenuitem>
	    (Terjesztések), végül a <guimenuitem>The
	    X.Org Distribution</guimenuitem> (Az X.Org
	    terjesztés) menüpontokat.</para>

	  <para>Az &xorg; sikeres telepítése után
	    kövessük a kézikönyv <link xlink:href="&url.books.handbook;/x-config.html">X11
	      beállításával
	    foglalkozó</link> szakaszában
	    leírtakat.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="running-X-securelevels">
	  <para>Az X indításakor egy <errorname>KDENABIO
	    failed (Operation not permitted)</errorname> hiba
	    keletkezik, közvetlenül a
	    <command>startx</command> parancs kiadása
	    után.  Mi lehet ezzel kezdeni?</para>
	</question>

	<answer>
	  <para>A rendszerünkön
	    valószínûleg túlságosan
	    magas a biztonsági szint
	    (<literal>securelevel</literal>) értéke.
	    Ilyenkor az X-et nem tudjuk elindítani, mivel a
	    mûködéséhez szüksége van
	    a &man.io.4; eszköz írására.
	    Ezzel kapcsolatban az &man.init.8; man oldal ad
	    részletesebb útmutatást.</para>

	  <para>A kérdés tehát az, hogy mit kellene
	    ezzel csinálni.  Alapvetõen két
	    lehetõségünk van: vagy
	    visszaállítjuk a biztonsági szintet
	    nullára (ezt általában az
	    <filename>/etc/rc.conf</filename> állományon
	    keresztül lehet megtenni), vagy az &man.xdm.1;
	    programot még a rendszerindítás
	    során elindítjuk (mielõtt a
	    biztonsági szintet magasabbra
	    állítanánk).</para>

	  <para>A <xref linkend="xdm-boot"/> szolgál arról
	    bõvebb információval, hogy miként
	    tudjuk használni az &man.xdm.1; programot a rendszer
	    indítása során.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="x-and-moused">
	  <para>Miért nem mûködik X alatt az
	    egér?</para>
	</question>

	<answer>
	  <para>Ha a &man.syscons.4; (vagyis az alapértelmezett
	    konzol) meghajtót használjuk, akkor be tudjuk
	    úgy állítani a &os;-t, hogy minden
	    virtuális képernyõn látható
	    legyen az egérkurzor.  A &man.syscons.4; egy
	    <filename>/dev/sysmouse</filename> nevû
	    virtuális eszköz
	    támogatásával igyekszik elkerülni
	    azt, hogy összeakadjon az X-szel.  A valós
	    egértõl érkezõ összes
	    eseményt a &man.moused.8; démon írja
	    folyamatosan a &man.sysmouse.4; eszközre.  Amennyiben
	    az egerünket egy vagy több virtuális
	    konzolon is használni akarjuk az X-szel
	    <emphasis>együtt</emphasis>, akkor nézzük
	    meg a <xref linkend="moused" remap="another section"/>
	    válaszát és állítsuk be
	    annak megfelelõen a &man.moused.8;
	    démont.</para>

	  <para>Ezt követõen nyissuk meg az
	    <filename>/etc/X11/xorg.conf</filename>
	    állományt és gondoskodjunk róla,
	    hogy a következõ sorok feltétlenül
	    szerepeljenek benne:</para>

	  <programlisting>Section "InputDevice"
   Option          "Protocol" "SysMouse"
   Option          "Device" "/dev/sysmouse"
.....</programlisting>

	  <para>Az &xorg; 7.4 változatától
	    kezdõdõen az <filename>xorg.conf</filename>
	    állomány <literal>InputDevice</literal>
	    szekciói nem kerülnek feldolgozásra a
	    csatlakoztatott eszközök automatikus
	    érzékelése esetén.  A
	    korábbi viselkedési mód
	    visszaállításához vegyük
	    fel a következõ sort a
	    <literal>ServerLayout</literal> vagy
	    <literal>ServerFlags</literal> szekciók
	    valamelyikébe:</para>

	  <programlisting>Option "AutoAddDevices" "false"</programlisting>

	  <para>Néhányan inkább a
	    <filename>/dev/mouse</filename> eszközt szeretik
	    használni X alatt.  Ha mi is így akarjuk
	    használni, akkor a
	    <filename>/dev/mouse</filename> eszközhöz
	    hozzunk létre egy szimbolikus linket a
	    <filename>/dev/sysmouse</filename> eszközre
	    (lásd &man.sysmouse.4;).  Ezt úgy tudjuk
	    megtenni, ha az <filename>/etc/devfs.conf</filename>
	    állományba (lásd &man.devfs.conf.5;)
	    felvesszük a következõ sort:</para>

	  <programlisting>link    sysmouse    mouse</programlisting>

	  <para>A link maga közvetlenül a &man.devfs.5;
	    újraindításával keletkezik.  Ehhez
	    (<systemitem class="username">root</systemitem>
	    felhasználóként) a következõ
	    parancsot kell kiadnunk:</para>

	  <screen>&prompt.root; <userinput>/etc/rc.d/devfs restart</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="x-and-wheel">
	  <para>X alatt lehet használni görgõs
	    egeret?</para>
	</question>

	<answer>
	  <para>Igen.</para>

	  <para>Jelezni kell az X-nek, hogy ötgombos egerünk
	    van.  Ezt úgy tudjuk megcsinálni, ha az
	    <filename>/etc/X11/xorg.conf</filename>
	    állományba felvesszük a <literal>Buttons
	    5</literal> és <literal>ZAxisMapping 4 5</literal>
	    sorokat az <quote>InputDevice</quote> szakaszba.
	    Vegyük például, hogy az
	    <filename>/etc/X11/xorg.conf</filename>
	    állományunkban a következõ
	    <quote>InputDevice</quote> szakasz
	    található.</para>

	  <example>
	    <title>Egy példa &xorg; konfigurációs
	      állomány <quote>InputDevice</quote> szakasza
	      görgõs egerekhez</title>

	    <programlisting>Section "InputDevice"
   Identifier      "Mouse1"
   Driver          "mouse"
   Option          "Protocol" "auto"
   Option          "Device" "/dev/sysmouse"
   Option          "Buttons" "5"
   Option          "ZAxisMapping" "4 5"
EndSection</programlisting>
	  </example>

	  <example>
	    <title>Egy egyszerû példa <quote>.emacs</quote>
	      állomány görgõs egerek
	      (opcionális) használatához</title>

	    <programlisting>;; görgõs egér
(global-set-key [mouse-4] 'scroll-down)
(global-set-key [mouse-5] 'scroll-up)</programlisting>
	  </example>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="no-remote-x11">
	  <para>Hogyan lehet távoli X szervereket
	    elérni?</para>
	</question>

	<answer>
	  <para>Biztonsági okokból a szerver
	    alapértelmezés szerint nem engedélyezi,
	    hogy egy távoli géprõl ablakot lehessen
	    nyitni rajta.</para>

	  <para>Ha szükségünk lenne erre a
	    lehetõségre, akkor nem kell mást
	    tennünk, mint az <application>X</application>-et a
	    <option>-listen_tcp</option> paraméterrel
	    indítani:</para>

	    <screen>&prompt.user; <userinput>startx -listen_tcp</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="virtual-console">
	  <para>Mi az a virtuális konzol és hogyan lehet
	    belõle többet létrehozni?</para>
	</question>

	<answer>
	  <para>A virtuális konzolok röviden szólva
	    arra alkalmasak, hogy egyetlen gépen is több
	    párhuzamos munkamenetben tudjunk dolgozni,
	    hálózat vagy X beállítása
	    nélkül.</para>

	  <para>Amikor a rendszer elindul, a rendszerüzenetek
	    után általában egy bejelentkezõ
	    képernyõ jelenik meg.  Ekkor az elsõ
	    virtuális konzolon keresztül tudjuk megadni a
	    felhasználói nevünket és
	    jelszavunkat, majd nekilátni a munkának (vagy
	    éppen a játszadozásnak).</para>

	  <para>Késõbb aztán elõfordulhat, hogy
	    egy másik munkamenetet is szeretnénk
	    elindítani, például elõkeresni az
	    éppen használt program
	    dokumentációját vagy elolvasni a
	    leveleinket, amíg FTP-n keresztül
	    letöltünk egy állományt.  Ehhez nem
	    kell mást csinálnunk, csak le kell nyomni az
	    <keycombo action="simul"><keycap>Alt</keycap><keycap>F2</keycap></keycombo>
	    (tartsuk lenyomva az <keycap>Alt</keycap> billentyût
	    miközben megnyomjuk az <keycap>F2</keycap>
	    billentyût) billentyûkombinációt
	    és máris egy másik virtuális
	    konzolon találjuk magunkat!  Ha innen vissza
	    szeretnénk térni az elõzõ
	    munkamenetbe, akkor nyomjuk le az <keycombo action="simul"><keycap>Alt</keycap><keycap>F1</keycap></keycombo>
	    billentyûkombinációt.</para>

	  <para>A frissen telepített &os; rendszerekben
	    alapértelmezés szerint nyolc virtuális
	    konzol engedélyezett.  Az <keycombo action="simul"><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
	    <keycombo action="simul"><keycap>Alt</keycap><keycap>F2</keycap></keycombo>,
	    <keycombo action="simul"><keycap>Alt</keycap><keycap>F3</keycap></keycombo>,
	    stb.  lenyomásával tudunk váltogatni
	    köztük.</para>

	  <para>Ha ennél többet szeretnénk egyszerre
	    használni, akkor nyissuk meg az
	    <filename>/etc/ttys</filename> állományt
	    (lásd &man.ttys.5;) és a <quote>Virtual
	    terminals</quote> részben vegyünk még fel
	    a <filename>ttyv8</filename> eszköz után
	    továbbiakat, egészen a
	    <filename>ttyvc</filename> eszközig:</para>

	  <programlisting># Írjuk át az eredeti ttyv8 bejegyzést az /etc/ttys
# állományban és engedélyezzük.
ttyv8   "/usr/libexec/getty Pc"         cons25  on secure
ttyv9   "/usr/libexec/getty Pc"         cons25  on secure
ttyva   "/usr/libexec/getty Pc"         cons25  on secure
ttyvb   "/usr/libexec/getty Pc"         cons25  on secure</programlisting>

	  <para>Akármennyit használhatunk
	    belõlük.  Ne felejtsük el azonban, hogy
	    minél több virtuális terminálunk
	    van, annál több erõforrásra lesz
	    hozzájuk szükségünk.  Ezt
	    leginkább akkor érdemes megfontolni, ha
	    8&nbsp;MB memóriánál kevesebbel
	    rendelkezünk.  Emellett még érdemes a
	    <literal>secure</literal> értéket is az
	    <literal>insecure</literal> értékre
	    átállítani.</para>

	    <important>
	      <para>Ha X szervert is akarunk futtatni, akkor
		legalább egy virtuális konzolt szabadon
		(vagy kikapcsolva) <emphasis>kell</emphasis> hagynunk a
		számára.  Így tehát, ha mind
		a tizenkét funkcióbillentyûre
		szeretnénk elindítani egy-egy
		virtuális konzolt, nos, akkor nincs
		szerencsénk &mdash; ha X szervert is akarunk
		használni a gépen, akkor legfeljebb csak
		tizenegyet használhatunk
		belõlük.</para>
	    </important>

	  <para>Az egyes konzolokat legegyszerûbben úgy
	    tudjuk letiltani, ha kikapcsoljuk ezeket.
	    Például, ha az elõbb említettek
	    szerint tizenkét terminálunk van, és
	    X-et akarunk futtatni, akkor a tizenkettedik terminál
	    beállításait meg kell
	    változtatnunk errõl:</para>

	  <programlisting>ttyvb   "/usr/libexec/getty Pc"         cons25  on  secure</programlisting>

	  <para>erre:</para>

	  <programlisting>ttyvb   "/usr/libexec/getty Pc"         cons25  off secure</programlisting>

	  <para>Amennyiben a billentyûzetünkön csak
	    tíz funkcióbillentyû
	    található, elengedõ ennyi is:</para>

	  <programlisting>ttyv9   "/usr/libexec/getty Pc"         cons25  off secure
ttyva   "/usr/libexec/getty Pc"         cons25  off secure
ttyvb   "/usr/libexec/getty Pc"         cons25  off secure</programlisting>

	  <para>(Ezeket a sorokat akár ki is
	    törölhetjük.)</para>

	  <para>Ezt követõen a legegyszerûbben (és
	    egyben a legtisztábban) úgy tudjuk
	    aktiválni a virtuális konzolokat, ha
	    újraindítjuk a rendszerünket.  Ha viszont
	    nem akarjuk ezt feltétlenül megtenni, akkor
	    állítsuk le az X szervert, majd
	    (<systemitem class="username">root</systemitem>
	    felhasználóként) adjuk ki az
	    alábbi parancsot:</para>

	  <screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

	  <para>Fontos, hogy a parancs végrehajtás
	    elõtt teljesen leállítsuk az X szervert,
	    amennyiben az fut.  Ha nem tesszük meg, akkor
	    könnyen elõfordulhat, hogy a
	    <command>kill</command> parancs hatására
	    lemerevedik vagy megáll a rendszerünk.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="vty-from-x">
	  <para>Hogyan lehet elérni a virtuális konzolokat
	    X-bõl?</para>
	</question>

	<answer>
	  <para>A virtuális konzolokra a
	    <keycombo action="simul">
	      <keycap>Ctrl</keycap>
	      <keycap>Alt</keycap>
	      <keycap>F<replaceable>N</replaceable></keycap>
	    </keycombo> billentyûkombinációval lehet
	    visszaváltani.  Ennek megfelelõen tehát a
	    <keycombo action="simul">
	      <keycap>Ctrl</keycap>
	      <keycap>Alt</keycap>
	      <keycap>F1</keycap>
	    </keycombo> kombinációval az elsõ
	    virtuális konzolra tudunk
	    visszaváltani.</para>

	  <para>Ahogy visszajutottunk a szöveges konzolra, az
	    <keycombo action="simul">
	      <keycap>Alt</keycap>
	      <keycap>F<replaceable>n</replaceable></keycap>
	    </keycombo> billentyûkombinációval a
	    megszokott módon tudunk váltani
	    köztük.</para>

	  <para>Ha innen az X szerverre akarunk visszaváltani,
	    akkor egyszerûen csak váltsunk arra a
	    virtuális konzolra, ahol az X fut.  Ha az X-et a
	    paranccsorból indítottuk el
	    (például a <command>startx</command>
	    paranccsal), akkor az X nem arra a virtuális konzolra
	    kapcsolódik automatikusan, amelyen a parancsot
	    kiadtuk, hanem az utána következõ,
	    használatban még nem levõ konzolra.  Ha
	    nyolc aktív virtuális terminálunk van,
	    akkor az X a kilencediken fog futni, ezért ide az
	    <keycombo action="simul">
	      <keycap>Alt</keycap>
	      <keycap>F9</keycap>
	    </keycombo> lenyomásával tudunk
	    visszatérni.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="xdm-boot">
	  <para>Hogyan indítható el az
	    <application>XDM</application> a rendszer
	    indításakor?</para>
	</question>

	<answer>
	  <para>Alapvetõen kétféle
	    megközelítés létezik az
	    &man.xdm.1; elindításával kapcsolatban.
	    Az egyik megközelítés szerint az
	    <command>xdm</command> parancsot az
	    <filename>/etc/ttys</filename>
	    állományból (lásd &man.ttys.5;)
	    tudjuk megadni a megadott példa alapján, a
	    másikban pedig egyszerûen az
	    <filename>rc.local</filename>
	    állományból (lásd &man.rc.8;)
	    vagy a <filename>/usr/local/etc/rc.d</filename>
	    könyvtárban megadható
	    <filename>X</filename> szkripttel.  Mind a kettõ
	    ugyanazt képviseli, de vannak bizonyos helyzetek,
	    ahol a kettõ közül csak az egyik
	    mûködik.  Az eredmény mind a két
	    esetben azonos, hatásukra az X egy grafikus
	    bejelentkezõ képernyõvel
	    jelentkezik.</para>

	  <para>A &man.ttys.5; módszernek van egy olyan
	    elõnye, hogy pontosan megadja, melyik virtuális
	    terminálon fog futni az X és a szerver
	    elindítását az &man.init.8; programra
	    bízza.  Az &man.rc.8; használata esetén
	    viszont könnyû leállítani az
	    <command>xdm</command> programot, ha netalán
	    valamilyen gondunk adódna az X szerver
	    indításakor.</para>

	  <para>Ha az &man.rc.8; állományból
	    töltöttük be, akkor az <command>xdm</command>
	    futtatásához semmilyen paramétert nem
	    kell megadni (például, hogy
	    démonként fusson).  Az &man.xdm.1; azonban
	    csak az <emphasis>összes</emphasis> &man.getty.8;
	    elindulása után indítható,
	    máskülönben a két program
	    ütközni fog és a konzol nem tud
	    létrejönni.  Ezt a legkönnyebben úgy
	    lehet megakadályozni, ha az <command>xdm</command>
	    indítása elõtt várunk kb. 10
	    másodpercet a szkriptben.</para>

	  <para>Amennyiben az <filename>/etc/ttys</filename>
	    állományból adjuk ki az
	    <command>xdm</command> parancsot, úgy továbbra
	    is fennáll az &man.xdm.1; és a &man.getty.8;
	    ütközésének veszélye.  Ezt
	    például úgy tudjuk elkerülni, ha
	    felvesszük a megfelelõ virtuális
	    terminál sorszámát a
	    <filename>/usr/local/lib/X11/xdm/Xservers</filename>
	    állományba:</para>

	  <programlisting>:0 local /usr/local/bin/X vt4</programlisting>

	  <para>A fenti példában az X szervert a
	    <filename>/dev/ttyv3</filename> eszközre
	    irányitjuk.  A számozást azonban eggyel
	    el kell tolnunk, mert míg az X szerver egytõl
	    számozza a virtuális konzolokat, addig a &os;
	    rendszermagja nullától.</para>
        </answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="xconsole-failure">
	  <para>Az <command>xconsole</command> indításakor
	    miért jelenik meg a <errorname>Couldn't open
	    console</errorname> hibaüzenet?</para>
	</question>

	<answer>
	  <para>Ha az X-et a <command>startx</command> paranccsal
	    indítottuk el, akkor a
	    <filename>/dev/console</filename> eszközre
	    <emphasis>nem</emphasis> állítódnak be
	    a szükséges engedélyek, ezért az
	    <command>xterm -C</command> és az
	    <command>xconsole</command> parancsok nem fognak
	    mûködni.</para>

	  <para>Ez a konzolok engedélyeinek
	    alapértelmezett beállítási
	    módjától függ.  Egy
	    többfelhasználós rendszer esetén
	    nem feltétlenül van szükségünk
	    arra, hogy bármelyik felhasználó
	    kedvére írhasson a rendszerkonzolra.  Az
	    &man.fbtab.5; állomány
	    segítségével engedélyezni tudjuk
	    azon felhasználók számára, akik
	    a helyi gépen, virtuális konzolon
	    keresztül jelentkeznek be.</para>

	  <para>Dióhéjban az
	    <filename>/etc/fbtab</filename> állományban
	    (lásd &man.fbtab.5;) kell kivennünk a
	    következõ sort a megjegyzésbõl:</para>

	  <programlisting>/dev/ttyv0 0600 /dev/console</programlisting>

	  <para>Ennek köszönhetõen bárki, aki az
	    <filename>/dev/ttyv0</filename> eszközön
	    keresztül jelentkezik be a rendszerbe, el tudja
	    érni a konzolt.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="xfree86-root">
	  <para>Régebben egyszerû
	    felhasználóként is el lehetett
	    indítani az &xfree86; szervert.  Most miért
	    kell <systemitem class="username">root</systemitem>
	    felhasználóként indítani?</para>
	</question>

	<answer>
	  <para>Az X szerverek csak úgy képesek
	    közvetlenül elérni a
	    videokártyát, ha <systemitem class="username">root</systemitem>
	    felhasználóként futtatjuk ezeket.  Az
	    &xfree86; régebbi (3.3.6 elõtti)
	    változatai az összes szervert úgy
	    telepítették fel automatikusan, hogy a
	    <systemitem class="username">root</systemitem> felhasználó jogaival
	    fussanak (setuid bittel).  Ennek viszont megvan a maga
	    nyilvánvaló biztonsági
	    kockázata, hiszen az X szerverek
	    általában nagy és bonyolult programok.
	    Az &xfree86; újabb változatai azonban
	    már pontosan ebbõl kifolyólag nem
	    állítanak be setuid <systemitem class="username">root</systemitem>
	    bitet a szerverekre.</para>

	  <para>Értelemszerûen az a megoldás nem
	    fogadható el és nem is annyira
	    biztonságos, hogy az X szervert
	    <systemitem class="username">root</systemitem>
	    felhasználóként futtassuk.
	    Kétféleképpen tudjuk egyszerû
	    felhasználóként futtatni az X-et.
	    Használhatjuk az <command>xdm</command> vagy
	    más egyéb bejelentkeztetõ
	    képernyõ (mint például a
	    <command>kdm</command>) megoldását, vagy az
	    <command>Xwrapper</command> programot.</para>

	  <para>Az <command>xdm</command> egy grafikus
	    bejelentkeztetésért felelõs démon.
	    Általában a rendszer indításakor
	    aktiválódik, feladata a
	    felhasználók hitelesítése
	    és a hozzájuk tartozó munkamenetek
	    elindítása.  Lényegében a
	    &man.getty.8; és a &man.login.1; grafikus
	    megfelelõje.  Az <command>xdm</command> démonnal
	    kapcsolatban még <link xlink:href="http://www.xfree86.org/sos/resources.html">az &xfree86;
	    dokumentációját</link>, illetve a
	    GYIK-ban <link linkend="xdm-boot">ezt a
	    kérdést</link> érdemes
	    elolvasnunk.</para>

	  <para>Az <command>Xwrapper</command> az X szerverhez
	    tartozó burkolóprogram (wrapper).  Ez egy
	    apró segédprogram, amely lehetõvé
	    teszi az X szerver manuális
	    indítását miközben igyekszik
	    ügyelni a biztonságra is.  Elvégez
	    néhány alapvetõ ellenõrzést a
	    paramétereken, és ha megfelelõnek
	    találja ezeket, akkor elindítja a
	    megfelelõ X szervert.  Ha valamiért nem akarunk
	    bejelentkeztetõ képernyõt indítani,
	    akkor ezt pontosan nekünk találták ki!
	    Ha telepítettük a teljes
	    Portgyûjteményt, akkor a <package>/usr/ports/x11/wrapper</package> portban
	    találjuk meg.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ps2-x">
	  <para>Miért viselkednek furcsán a PS/2-es egerek
	    X alatt?</para>
	</question>

	<answer>
	  <para>Valószínûleg az egér és
	    az egérmeghajtó kiesett a
	    szinkronból.</para>

	  <para>Nagyon ritkán elõfordul, hogy a
	    meghajtó hibásan szinkronizációs
	    hibát jelez, és ekkor a rendszermag a
	    következõ üzenetet küldi:</para>

	  <programlisting>psmintr: out of sync (xxxx != yyyy)</programlisting>

	  <para>Közben természetesen azt tapasztaljuk, hogy
	    az egerünk nem mûködik rendesen.</para>

	  <para>Ha ilyen történne velünk, akkor tiltsuk
	    le a meghajtó szinkronizáció
	    ellenõrzéséért felelõs
	    rutinjait.  Ezt úgy tudjuk megtenni, ha a
	    meghajtónak beállítjuk a
	    <literal>0x100</literal> értéket.  Ehhez a
	    rendszertöltõ parancssorában a
	    <option>-c</option> kapcsolóval tudjuk behozni a
	    <emphasis>UserConfig</emphasis> részt:</para>

	  <screen>boot: <userinput>-c</userinput></screen>

	  <para>Ezután a <emphasis>UserConfig</emphasis>
	    parancssorában gépeljük be a
	    következõt:</para>

	  <screen>UserConfig&gt; <userinput>flags psm0 0x100</userinput>
UserConfig&gt; <userinput>quit</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ps2-mousesystems">
	  <para>Miért nem mûködnek a MouseSystems
	    által gyártott PS/2-es egerek?</para>
	</question>

	<answer>
	  <para>Kaptunk néhány visszajelzést arra
	    vonatkozóan, hogy a MouseSystems által
	    gyártott PS/2-es egerek bizonyos típusai csak
	    abban az esetben mûködnek rendesen, ha <quote>nagy
	    felbontású</quote> módban
	    használjuk ezeket.  Minden más esetben az
	    egér néha fel-felugrik a képernyõ
	    bal felsõ sarkába.</para>

	  <para>Úgy tudjuk nagy felbontású
	    módban használni az egerünket, ha a PS/2-es
	    egérmeghajtónak a <literal>0x04</literal>
	    beállítást adjuk meg.  Ehhez a
	    rendszertöltõ parancssorában
	    gépeljük be a <option>-c</option>
	    kapcsolót:</para>

	  <screen>boot: <userinput>-c</userinput></screen>

	  <para>Ahogy bejön a <emphasis>UserConfig</emphasis>
	    parancssora, gépeljük be a
	    következõt:</para>

	  <screen>UserConfig&gt; <userinput>flags psm0 0x04</userinput>
UserConfig&gt; <userinput>quit</userinput></screen>

	  <para>Az elõzõ részben olvashatunk egy
	    másik hasonló egeres
	    problémáról.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="mouse-button-reverse">
	  <para>Hogyan lehet megcserélni a gombokat az
	    egéren?</para>
	</question>

	<answer>
	  <para>Futtassuk le a <command>xmodmap -e "pointer = 3 2
	    1"</command> parancsot az <filename>.xinitrc</filename> vagy
	    <filename>.xsession</filename>
	    állományunkból.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="install-splash">
	  <para>Hogyan lehet betöltõképet
	    telepíteni és hol találhatóak
	    ilyen képek?</para>
	</question>

	<answer>
	  <para>Erre a kérdésre részletes
	    választ a &os; kézikönyv <link xlink:href="&url.books.handbook;/boot-blocks.html#BOOT-SPLASH">Rendszerbetöltõ
	      képernyõk</link>
	    címû szakaszában kapunk.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="windows-keys">
	  <para>X alatt lehet használni a billentyûzeten
	    található <keycap>Windows</keycap>
	    billentyûket?</para>
	</question>

	<answer>
	  <para>Igen.  Ehhez mindössze az &man.xmodmap.1;
	    használatával meg kell adni a hozzájuk
	    tartozó funkciót.</para>

	  <para>Feltéve, hogy mindegyik <quote>Windows</quote>
	    billentyûzet szabványos, a következõ
	    billentyûkódok tartoznak ehhez a három
	    plusz gombhoz:</para>

	  <itemizedlist>
	    <listitem>
	      <para><keycode>115</keycode> &mdash;
		<keycap>Windows</keycap> billentyû, a bal oldali
		<keycap>Ctrl</keycap> és <keycap>Alt</keycap>
		billentyûk között</para>
	    </listitem>

	    <listitem>
	      <para><keycode>116</keycode> &mdash;
		<keycap>Windows</keycap> billentyû, az
		<keycap>AltGr</keycap> mellett jobbra</para>
	    </listitem>

	    <listitem>
	      <para><keycode>117</keycode> &mdash;
		<keycap>Menü</keycap> gomb, a jobb oldali
		<keycap>Ctrl</keycap> mellett balra</para>
	    </listitem>
	  </itemizedlist>

	  <para>Például így lehet
	    beállítani a bal oldali
	    <keycap>Windows</keycap> billentyût
	    vesszõre:</para>

	  <screen>&prompt.root; <userinput>xmodmap -e "keycode 115 = comma"</userinput></screen>

	  <para>A változatatások
	    valószínûleg csak akkor fognak
	    életbelépni, ha újraindítjuk az
	    ablakkezelõnket.</para>

	  <para>Ha azt szeretnénk, hogy a
	    <keycap>Windows</keycap> billentyûkhöz rendelt
	    funkciók az X indításakor automatikusan
	    beállítódjanak, akkor tegyük az
	    <command>xmodmap</command> parancs
	    hívását az
	    <filename>~/.xinitrc</filename> állományunkba.
	    Sokkal jobban járunk viszont, ha ehelyett
	    inkább az <filename>~/.xmodmaprc</filename>
	    állományunkba vesszük fel az
	    <command>xmodmap</command>
	    beállításait, soronként
	    egyesével, és a következõ sor
	    tesszük az <filename>~/.xinitrc</filename>
	    állományunkba:</para>

	  <programlisting>xmodmap $HOME/.xmodmaprc</programlisting>

	  <para>Például ezeket a gombokat be lehet
	    állítani az <keycap>F13</keycap>,
	    <keycap>F14</keycap> és <keycap>F15</keycap>
	    billentyûkre is.  Ezekre aztán az
	    alkalmazásokban vagy az ablakkezelõben
	    további hasznos funkciókat tudunk
	    beállítani.</para>

	  <para>Ehhez a következõt kell megadnunk az
	    <filename>~/.xmodmaprc</filename>
	    állományban:</para>

	  <programlisting>keycode 115 = F13
keycode 116 = F14
keycode 117 = F15</programlisting>

	  <para>Ha például az <package>x11-wm/fvwm2</package> ablakkezelõt
	    használjuk, akkor az <keycap>F13</keycap> gombra be
	    tudjuk állítani a kurzor alatt
	    álló ablak
	    lekicsinyítésére (vagy
	    visszanagyítására); az
	    <keycap>F14</keycap> billentyûvel az
	    elõtérbe tudjuk hozni a kurzor alatt levõ
	    ablakot, vagy ha már elöl van, akkor
	    hátra tudjuk rakni; az <keycap>F15</keycap> gomb
	    elõhozza a munkakörnyezet (alkalmazás)
	    menüjét még olyankor is, amikor a kurzor
	    nincs is az asztalon.  Ez utóbbi abban az esetben
	    lehet hasznos, amikor az asztal egyáltalán nem
	    látható (és a billentyûn
	    látható rajz pontosan is ezt mutatja).</para>

	  <para>A következõ beállítások
	    valósítják meg az imént
	    említett funkciókat az
	    <filename>~/.fvwmrc</filename> állományon
	    belül:</para>

	  <programlisting>Key F13        FTIWS    A        Iconify
Key F14        FTIWS    A        RaiseLower
Key F15        A        A        Menu Workplace Nop</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="x-3d-acceleration">
	  <para>Hogyan lehet hardveres 3D gyorsítást
	    használni az &opengl;-hez?</para>
	</question>

	<answer>
	  <para>Az &xorg; pillanatnyilag használt
	    verziójától és a
	    videokártyánktól függ, hogy
	    tudunk-e 3D gyorsítást alkalmazni.  Ha nVidia
	    kártyánk van, akkor a portok közül
	    telepíteni tudjuk a &os;-hez készített
	    bináris meghajtót:</para>

	  <itemizedlist>
	    <listitem>
	      <para>A legújabb nVidia-kártyákat az
		<package>x11/nvidia-driver</package>
		port támogatja.</para>
	    </listitem>

	    <listitem>
	      <para>A GeForce2&nbsp;MX/3/4 sorozatú
		nVidia-kártyákat a meghajtó 96XX
		változata támogatja, amely az <package>x11/nvidia-driver-96xx</package>
		portból telepíthetõ.</para>
	    </listitem>

	    <listitem>
	      <para>Az ettõl is régebbi
		kártyák, például a GeForce
		vagy Riva&nbsp;TNT esetén a meghajtó 71XX
		változata javasolt, amely az <package>x11/nvidia-driver-71xx</package>
		porton keresztül érhetõ el.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Az nVidia honlapján részletes
	    leírást találhatunk arról, hogy
	    melyik kártyát melyik meghajtó ismeri.
	    Ez az információ a következõ
	    címen érhetõ el: <uri xlink:href="http://www.nvidia.com/object/IO_32667.htm">http://www.nvidia.com/object/IO_32667.htm</uri>.
	    </para>

	  <para>A Matrox&nbsp;G200/G400 esetén az <package>x11-servers/mga_hal</package> portot
	    érdemes megnéznünk.</para>

	  <para>ATI&nbsp;Rage&nbsp;128 és Radeon
	    kártyák számára a &man.ati.4x;,
	    &man.r128.4x; és &man.radeon.4x; man oldalakat
	    ajánljuk.</para>

	  <para>3dfx Voodoo&nbsp;3, 4, 5 és Banshee
	    kártyák számára az <package>x11-servers/driglide</package> port
	    áll rendelkezésre.</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter xml:id="networking" xml:lang="hu">
    <title>Hálózatok</title>

    <qandaset>
      <qandaentry>
	<question xml:id="diskless-booting">
	  <para>Honnan lehet többet megtudni a <quote>lemez
	    nélküli
	    mûködésrõl</quote>?</para>
	  </question>

	  <answer>
	    <para>A <quote>lemez nélküli
	      mûködés</quote> kifejezés arra utal,
	      hogy a &os; rendszerünk hálózaton
	      keresztül indul el, valamint a
	      mûködéséhez szükséges
	      állományokat nem merevlemezrõl, hanem
	      egy szerverrõl olvassa be.  Ennek
	      részleteirõl <link xlink:href="&url.books.handbook;/network-diskless.html">kézikönyv lemez
		nélküli mûködésrõl szóló részében</link>
	      olvashatunk.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="router">
	  <para>A &os; használható kizárólag
	    csak hálózati
	    útválasztóként?</para>
	</question>

	<answer>
	  <para>Igen.  Ezzel kapcsolatban a kézikönyv <link xlink:href="&url.books.handbook;/advanced-networking.html">
	    Egyéb haladó hálózati
	    témák</link> címû
	    fejezetét javasoljuk elolvasásra,
	    különös tekintettel az <link xlink:href="&url.books.handbook;/network-routing.html">útválasztás és az átjárók</link>
	    bemutatására.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="win95-connection">
	  <para>&os;-n keresztül lehet &windows;
	    operációs rendszerrel internetre
	    csatlakozni?</para>
	</question>

	<answer>
	  <para>Ezt a kérdést általában
	    olyanok teszik fel, akiknek két
	    számítógépük van otthon,
	    és ezek közül az egyiken a &os;, a
	    másikon pedig a &windows; valamelyik változata
	    fut.  A &os; rendszer fog az internethez csatlakozni,
	    és ezen keresztül szeretnénk a
	    windowsos géprõl is elérni azt.  Ez
	    tulajdonképpen az elõzõ
	    kérdés egy speciális esete, és
	    remekül megoldható.</para>

	  <para>Ha betárcsázós kapcsolattal
	    csatlakozunk az internethez, akkor érdemes tudnunk,
	    hogy a felhasználói módban futó
	    &man.ppp.8; tartalmaz egy <option>-nat</option>
	    kapcsolót.  A &man.ppp.8; programot úgy tudjuk
	    a <option>-nat</option> kapcsolóval futtatni, ha az
	    <filename>/etc/rc.conf</filename> állományban
	    a <literal>gateway_enable</literal>
	    beállítást a <emphasis>YES</emphasis>
	    értékre állítjuk.  Ezután
	    állítsuk be a windowsos gépünket
	    ennek megfelelõen és minden mûködni
	    fog.  A további részletekrõl a
	    &man.ppp.8; man oldalán vagy a <link xlink:href="&url.books.handbook;/userppp.html">kézikönyv
	      felhasználói PPP-rõl
	      szóló bejegyzésében</link>
	    olvashatunk.</para>

	  <para>Amennyiben rendszerszintû PPP-t használunk
	    vagy Ethernettel csatlakozunk az internethez, akkor a
	    &man.natd.8; démonra lesz
	    szükségünk.  Erre vonatkozóan a
	    kézikönyv <link xlink:href="&url.books.handbook;/network-natd.html">natd</link>
	    démonról szóló
	    szakaszában találhatunk részletesebb
	    információkat.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="slip-ppp-support">
	  <para>A &os; támogatja a SLIP és a PPP
	    használatát?</para>
	</question>

	<answer>
	  <para>Igen.  Érdemes elolvasnunk az &man.slattach.8;,
	    &man.sliplogin.8;, &man.ppp.8; és &man.pppd.8; man
	    oldalakat.  A &man.ppp.8; és a &man.pppd.8;
	    egyaránt támogatja a beérkezõ
	    és kimenõ kapcsolatokat, miközben a
	    &man.sliplogin.8; kizárólag csak
	    beérkezõ kapcsolatokkal dolgozik, valamint a
	    &man.slattach.8; pedig csak kimenõ
	    kapcsolatokkal.</para>

	  <para>Ezek pontos használatáról olvassuk
	    el a <link xlink:href="&url.books.handbook;/ppp-and-slip.html">kézikönyv
	      PPP-rõl és a SLIP-rõl szóló
	      fejezetét</link>.</para>

	  <para>Ha viszont csak egy <quote>shellen</quote>
	    keresztül érjük el az internetet, akkor
	    hasznos lehet megnéznünk a <package>net/slirp</package> csomagot.
	    Segítségével a helyi géprõl
	    (korlátozott módon) hozzá tudunk
	    férni különbözõ FTP és
	    HTTP szolgáltatásokhoz.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="natd">
	  <para>A &os; támogat hálózati
	    címfordítást (NAT) vagy
	    maszkolást?</para>
	</question>

	<answer>
	  <para>Igen.  Ha egy felhasználói PPP kapcsolat
	    esetén szeretnénk hálózati
	    címfordítást alkalmazni, akkor olvassuk
	    el a <link xlink:href="&url.books.handbook;/userppp.html">kézikönyv
	      felhasználói PPP-vel foglalkozó
	      részét</link>.  Ha viszont
	    más típusú hálózati
	    kapcsolatok esetén kívánunk
	    címfordítást használni, akkor
	    ahhoz a kézikönyv <link xlink:href="&url.books.handbook;/network-natd.html">natd</link>
	    démonnal kapcsolatos részét kell
	    fellapoznunk.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="parallel-connect">
	  <para>A PLIP segítségével hogyan tudok
	    két &os; rendszert összekapcsolni
	    párhuzamos porton keresztül?</para>
	</question>

	<answer>
	  <para>Ezt illetõen a kézikönyv <link xlink:href="&url.books.handbook;/network-plip.html">PLIP-rõl
	      szóló szakaszát</link>
	      érdemes megnéznünk.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ethernet-aliases">
	  <para>Hogyan lehet álneveket megadni az Ethernet
	    eszközöknek?</para>
	</question>

	<answer>
	  <para>Amennyiben az álnév ugyanazon az
	    alhálózaton található, mint a
	    hozzá tartozó interfész, akkor
	    egyszerûen csak adjuk meg a <literal>netmask
	    0xffffffff</literal> paramétert az &man.ifconfig.8;
	    parancs meghívásakor, például
	    így:</para>

	  <screen>&prompt.root; <userinput>ifconfig ed0 alias 192.0.2.2 netmask 0xffffffff</userinput></screen>

	  <para>Minden más esetben a hagyományos
	    módon adjunk meg egy hálózati
	    címet és egy hálózati
	    maszkot:</para>

	  <screen>&prompt.root; <userinput>ifconfig ed0 alias 172.16.141.5 netmask 0xffffff00</userinput></screen>

	  <para>Errõl bõvebben a <link xlink:href="&url.books.handbook;/configtuning-virtual-hosts.html">&os; kézikönyvben</link>
	    olvashatunk.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="port-3c503">
	  <para>A 3C503 kártya hogyan
	    állítható másik
	    hálózati portra?</para>
	</question>

	<answer>
	  <para>Ha a kártyán egy másik portot
	    szeretnénk használni, akkor ahhoz meg kell
	    adnunk egy további paramétert a
	    &man.ifconfig.8; meghívásakor.  Itt az
	    alapértelmezett port a <literal>link0</literal>.  Ha
	    a BNC helyett az AUI portot akarjuk használni, akkor
	    ennek a <literal>link2</literal> értéket kell
	    megadnunk.  Az ilyen típusú
	    beállítások az
	    <filename>/etc/rc.conf</filename> állomány
	    (lásd &man.rc.conf.5;) <literal>ifconfig_*</literal>
	    változóival adhatóak meg.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="nfs">
	  <para>Miért okoz gondot az NFS használata &os;
	    alatt?</para>
	</question>

	<answer>
	  <para>A személyi
	  számítógépekben
	    található bizonyos hálózati
	    kártyák (szépen szólva)
	    ügyesebbek a többieknél, ami az olyan
	    komolyabb hálózati alkalmazások, mint
	    például az NFS esetén gondokat
	    okozhat.</para>

	  <para>Ezzel kapcsolatban
	    <link xlink:href="&url.books.handbook;/network-nfs.html">
	      kézikönyv NFS-rõl szóló
	      részét</link> érdemes
	    megnéznünk.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="nfs-linux">
	  <para>Miért nem lehet hálózati
	    állományrendszereket csatlakoztatni &linux;
	    alól?</para>
	</question>

	<answer>
	  <para>A &linux; egyes változataiban
	    található NFS kód csak bizonyos
	    privilegizált portokról fogad el
	    kéréseket.  Próbáljuk meg a
	    következõt:</para>

	  <screen>&prompt.root; <userinput>mount -o -P linux:/valami /mnt</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="nfs-sun">
	  <para>Miért nem lehet hálózati
	    állományrendszereket csatlakoztatni &sun;
	    típusú rendszerek alól?</para>
	</question>

	<answer>
	  <para>A &sunos; 4.<replaceable>X</replaceable>
	    változatait futtató munkaállomások
	    csak privilegizált portokról fognak el
	    kéréseket.  Próbálkozzunk az
	    alábbi paranccsal:</para>

	  <screen>&prompt.root; <userinput>mount -o -P sun:/valami /mnt</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="exports-errors">
	  <para>A <command>mountd</command> miért küld
	    folyton <errorname>can't change attributes</errorname>
	    hibaüzenetet és miért jelenik meg a
	    <errorname>bad exports list</errorname> hibaüzenet a
	    &os; alapú NFS szerveren?</para>
	</question>

	<answer>
	  <para>Ez leginkább azért történik,
	    mert nem jól adtuk meg az
	    <filename>/etc/exports</filename> állomány
	    tartalmát.  Olvassuk át a &man.exports.5; man
	    oldalt és a kéziköny
	    <link xlink:href="&url.books.handbook;/network-nfs.html">NFS-rõl</link>
	    szóló részét,
	    különös tekintettel az <link xlink:href="&url.books.handbook;/network-nfs.html#CONFIGURING-NFS">NFS
	      beállítására</link>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ppp-nextstep">
	  <para>A <emphasis>NeXTStep</emphasis> gépekkel
	    miért nem sikerül PPP-n keresztül
	    kommunikálni?</para>
	</question>

	<answer>
	  <para>Próbáljuk meg az
	    <filename>/etc/rc.conf</filename> állományban
	    (lásd &man.rc.conf.5;) kikapcsolni a TCP
	    kiterjesztések használatát úgy,
	    hogy az alábbi változót a
	    <literal>NO</literal> értékre
	    állítjuk:</para>

	  <programlisting>tcp_extensions=NO</programlisting>

	  <para>A <emphasis>Xylogic</emphasis> által
	    gyártott <emphasis>Annex</emphasis>
	    típusú gépek esetén is javasolt
	    megtenni a fenti változtatást.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ip-multicast">
	  <para>Hogyan lehet engedélyezni a multicast
	    használatát az IP-n belül?</para>
	</question>

	<answer>
	  <para>A &os; alapértelmezés szerint
	    támogatja a multicast mûveleteket.  Amennyiben egy
	    multicast küldéseket közvetítõ
	    útválasztót szeretnénk
	    beállítani, akkor újra kell
	    fordítanunk a rendszermagunkat a
	    <literal>MROUTING</literal> beállítás
	    használatával és elindítani a
	    &man.mrouted.8; démont.  Ez a démon úgy
	    aktiválható a rendszer minden egyes
	    indításakor, ha az
	    <filename>/etc/rc.conf</filename> állományban
	    az <literal>mrouted_enable</literal> változót
	    <literal>YES</literal> értékûre
	    állítjuk.</para>

	  <note>
	    <para>A &os; újabb változataiban az
	      &man.mrouted.8; multicast útválasztó
	      démon, a &man.map-mbone.8; valamint az
	      &man.mrinfo.8; segédprogramok már nem
	      szerepelnek az alaprendszerben.  Ezek a programok
	      már a &os; Portgyûjteményében az
	      <package>net/mrouted</package> portban
	      találhatóak meg.</para>
	  </note>

	  <para>Az MBONE használatához további
	    eszközök találhatóak a külön
	    <link xlink:href="http://www.FreeBSD.org/ports/mbone.html">mbone</link>
	    kategóriában a Portgyûjeményen
	    belül.  Ha a <command>vic</command> és
	    <command>vat</command> nevû konferenciaszervezõ
	    eszközöket keressük, akkor itt érdemes
	    szétnéznünk!</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="dec-pci-chipset">
	  <para>Milyen hálózati kártyák
	     épülnek a DEC PCI
	     chipkészletére?</para>
	</question>

	<answer>
	  <para>Glen Foster (<email>gfoster@driver.nsta.org</email>) a
	    következõ listát állította
	    össze róluk, amelyet
	    kiegészítettünk még
	    néhány további elemmel:</para>

	  <table>
	    <title>A DEC PCI chipkészletére
	      épülõ hálózati
	      kártyák</title>

	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry>Gyártó</entry>
		  <entry>Típus</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>ASUS</entry>
		  <entry>PCI-L101-TB</entry>
		</row>
		<row>
		  <entry>Accton</entry>
		  <entry>ENI1203</entry>
		</row>
		<row>
		  <entry>Cogent</entry>
		  <entry>EM960PCI</entry>
		</row>
		<row>
		  <entry>Compex</entry>
		  <entry>ENET32-PCI</entry>
		</row>
		<row>
		  <entry>D-Link</entry>
		  <entry>DE-530</entry>
		</row>
		<row>
		  <entry>Dayna</entry>
		  <entry>DP1203, DP2100</entry>
		</row>
		<row>
		  <entry>DEC</entry>
		  <entry>DE435, DE450</entry>
		</row>
		<row>
		  <entry>Danpex</entry>
		  <entry>EN-9400P3</entry>
		</row>
		<row>
		  <entry>JCIS</entry>
		  <entry>Condor JC1260</entry>
		</row>
		<row>
		  <entry>Linksys</entry>
		  <entry>EtherPCI</entry>
		</row>
		<row>
		  <entry>Mylex</entry>
		  <entry>LNP101</entry>
		</row>
		<row>
		  <entry>SMC</entry>
		  <entry>EtherPower 10/100 (Model 9332)</entry>
		</row>
		<row>
		  <entry>SMC</entry>
		  <entry>EtherPower (Model 8432)</entry>
		</row>
		<row>
		  <entry>TopWare</entry>
		  <entry>TE-3500P</entry>
		</row>
		<row>
		  <entry>Znyx (2.2.<replaceable>x</replaceable>)</entry>
		  <entry>ZX312, ZX314, ZX342, ZX345, ZX346,
		    ZX348</entry>
		</row>
		<row>
		  <entry>Znyx (3.<replaceable>x</replaceable>)</entry>
		  <entry>ZX345Q, ZX346Q, ZX348Q, ZX412Q, ZX414, ZX442,
		    ZX444, ZX474, ZX478, ZX212, ZX214 (10mbps/hd)</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="fqdn-hosts">
	  <para>Miért kell teljes hálózati neveket
	    megadni?</para>
	</question>

	<answer>
	  <para>Erre a <link xlink:href="&url.books.handbook;/mail-trouble.html">&os; kézikönyvben</link>
	    találjuk meg a választ.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="network-permission-denied">
	  <para>Miért jelenik meg a <errorname>Permission
	    denied</errorname> hibaüzenet minden egyes
	    hálózati mûvelet esetén?</para>
	</question>

	<answer>
	  <para>Amennyiben a rendszermagot az
	    <literal>IPFIREWALL</literal>
	    beállítással fordítottuk le,
	    akkor nem szabad elfelejtenünk, hogy ez
	    alapértelmezés szerint minden olyan csomagot
	    eldob, amelyet külön nem
	    engedélyeztünk.</para>

	  <para>Ha véletlenül rosszul
	    állítottuk volna be a rendszerünkön
	    futó tûzfalat, akkor a hálózat
	    mûködését úgy tudjuk
	    visszaállítani, ha <systemitem class="username">root</systemitem>
	    felhasználóként kiadjuk a
	    következõ parancsot:</para>

	  <screen>&prompt.root; <userinput>ipfw add 65534 allow all from any to any</userinput></screen>

	  <para>Az <filename>/etc/rc.conf</filename>
	    állományban is megadhatjuk ehhez a
	    <literal>firewall_type="open"</literal> sort.</para>

	  <para>Ha a tûzfalak
	  beállításáról
	    szeretnénk többet megtudni &os; alatt, akkor
	    olvassuk el a <link xlink:href="&url.books.handbook;/firewalls.html">kézikönyv
	      erre vonatkozó fejezetét</link>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ipfw-fwd">
	  <para>Az <command>ipfw</command> <quote>fwd</quote>
	    szabálya miért nem irányít
	    át más gépekre
	    szolgáltatásokat?</para>
	</question>

	<answer>
	  <para>Valószínûleg azért, mert nem
	    egyszerûen a csomagok
	    továbbítására (forward) van
	    szükségünk, hanem hálózati
	    címfordításra.  Az <quote>fwd</quote>
	    szabály pontosan azt csinálja, amirõl a
	    nevét kapta: csomagokat továbbít, de
	    azokon belül semmit sem változtat meg.
	    Tegyük fel, hogy van egy ilyen
	    szabályunk:</para>

	  <screen>01000 fwd <replaceable>10.0.0.1</replaceable> from any to <replaceable>ize 21</replaceable></screen>

	  <para>Amikor egy csomag az <replaceable>ize</replaceable>
	    célcímmel megérkezik a
	    <replaceable>10.0.0.1</replaceable> gépre, akkor
	    benne a cél címe továbbra is az
	    <replaceable>ize</replaceable> lesz!  A csomag
	    célcíme <emphasis>nem</emphasis> fog
	    magától megváltozni a
	    <replaceable>10.0.0.1</replaceable> címre.  A
	    legtöbb gép általában eldobja
	    azokat a csomagokat, amelyeket nem egyenesen neki
	    címeztek.  Emiatt a <quote>fwd</quote> szabály
	    használata nem minden esetben úgy
	    mûködik, ahogy arra a felhasználó
	    számít.  Ez viszont ilyen, semmilyen hiba
	    nincs benne.</para>

	  <para>Részletesebb információkat a <link linkend="service-redirect">szolgáltatások
	    átirányításával
	    foglalkozó GYIK-ban</link>, a &man.natd.8; man
	    oldalán vagy a <link xlink:href="&url.base;/ports/index.html">Portgyûjtemény</link>
	    valamelyik port átirányítással
	    foglalkozó portjának
	    dokumentációjában
	    találhatunk.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="service-redirect">
	  <para>Hogyan lehet egyik géprõl a másikra
	    szolgáltatásokat
	    átirányítani?</para>
	</question>

	<answer>
	  <para>Az FTP (vagy más egyéb
	    szolgáltatás-) kéréseket a
	    Portgyûjteményen belül
	    található <package>sysutils/socket</package> porttal tudunk
	    átirányítani.  Az adott
	    szolgáltatás helyett egyszerûen csak
	    adjuk meg a <command>socket</command> parancsot és
	    annak paramétereit, valahogy így:</para>

	  <programlisting>ftp stream tcp nowait nobody /usr/local/bin/socket socket <replaceable>ftp.minta.com</replaceable> <replaceable>ftp</replaceable></programlisting>

	  <para>ahol az <replaceable>ftp.minta.com</replaceable> az a
	    gép, ahová át akarjuk
	    irányítani a szolgáltatást, az
	    <replaceable>ftp</replaceable> pedig a konkrét
	    szolgáltatás.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="bandwidth-mgr-tool">
	  <para>Hogyan lehet a sávszélességet
	    szabályozni?</para>
	</question>

	<answer>
	  <para>&os; alatt alapvetõen három eszköz
	    szolgál erre a célra.  A &man.dummynet.4; a &os;
	    részeként megtalálható
	    &man.ipfw.4; egyik komponense.  Az <link xlink:href="http://www.sonycsl.co.jp/person/kjc/programs.html">ALTQ</link>
	    a &os;-ben található &man.pf.4; rendszer
	    része, az <link xlink:href="http://www.etinc.com">Emerging Technologies</link>
	    által fejlesztett <application>Bandwith
	    Manager</application> pedig egy kereskedelmi
	    termék.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="bpf-not-configured">
	  <para>Miért jelenik meg a <errorname>/dev/bpf0: device
	    not configured</errorname> hibaüzenet?</para>
	</question>

	<answer>
	  <para>Olyan programot akarunk futtatni, amelynek
	    szüksége van a Berkeley Packet Filter
	    (&man.bpf.4;) használatára, azonban a
	    rendszermag ezt nem tartalmazza.  Úgy tudjuk
	    aktiválni, ha a rendszermag
	    konfigurációs állományába
	    felvesszük a következõ sort, majd
	    fordítunk egy új rendszermagot:</para>

	  <programlisting>device bpf        # Berkeley Packet Filter</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="mount-smb-share">
	  <para>Hogyan lehet a hálózaton
	    elérhetõ &windows; típusú
	    partíciókat csatlakoztatni, mint ahogy az
	    smbmount csinálja &linux; alatt?</para>
	</question>

	<answer>
	  <para>Erre az <application>SMBFS</application> eszközeit
	    használhatjuk, amely tartalmazza az ehhez
	    szükséges rendszermagbeli
	    módosításokat és a
	    hozzá tartozó felhasználói
	    programokat.  Ezek a programok és a hozzájuk
	    tartozó &man.mount.smbfs.8; man oldal az alaprendszer
	    részei.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="icmp-response-bw-limit">
	  <para>Mik azok az <errorname>Limiting icmp/open port/closed
	    port response</errorname> üzenetek a
	    naplókban?</para>
	</question>

	<answer>
	  <para>Ilyen üzeneteket akkor kapunk a
	    rendszermagtól, ha valaminek a hatására
	    több ICMP vagy TCP reset (RST) választ
	    küld, mint amennyit kellene.  Az ICMP válaszok
	    sokszor olyankor generálódnak, amikor
	    használaton kívüli UDP portokat akarnak
	    elérni a rendszerünkön.  A TCP reset pedig
	    általában olyankor keletkezik, amikor meg nem
	    nyitott TCP porthoz akarnak csatlakozni.  Többek
	    közt ilyenek okozhatják:</para>

	  <itemizedlist>
	    <listitem>
	      <para>A rendszer túlterhelését
		célzó, nyers erõvel indított
		<emphasis>Denial of Service</emphasis> (Dos)
		támadások (ellentétben az
		egycsomagos, adott sebezhetõség
		kihasználó
		támadásokkal).</para>
	    </listitem>

	    <listitem>
	      <para>A portok szisztematikus letapogatása,
		amelynek során egyszerre nagy
		mennyiségû portot próbálnak
		meg átvizsgálni (ellentétben azzal,
		amikor csak néhány jól ismert
		portot nyitnak meg).</para>
	    </listitem>
	  </itemizedlist>

	  <para>Az üzenetben olvasható elsõ szám
	    azt mondja meg, hogy a rendszermag mennyi csomagot
	    küldött volna, ha nem korlátoztuk volna, a
	    második pedig magát a határt jelzi.
	    Ezt a <varname>net.inet.icmp.icmplim</varname> sysctl
	    változó segítségével
	    tudjuk beállítani, ahogy például
	    most megnöveljük az értékét
	    <literal>300</literal>-ra:</para>

	  <screen>&prompt.root; <userinput>sysctl -w net.inet.icmp.icmplim=300</userinput></screen>

	  <para>Amennyiben le szeretnénk tiltani az ilyen
	    jellegû üzeneteket a naplókban, viszont
	    még továbbra is szükségünk
	    lenne a válaszküldés
	    korlátozására, a
	    <varname>net.inet.icmp.icmplim_output</varname> sysctl
	    változó segítségével
	    így tudjuk ezt megtenni:</para>

	  <screen>&prompt.root; <userinput>sysctl -w net.inet.icmp.icmplim_output=0</userinput></screen>

	  <para>Végezetül, ha teljesen ki akarjuk kapcsolni
	    a válaszküldés
	    korlátozását, akkor
	    állítsuk a
	    <varname>net.inet.icmp.icmplim</varname> sysctl
	    változót (lásd az elõbbi
	    példában) a <literal>0</literal> nulla
	    értékre.  A korlát törlése
	    azonban a fenti okok miatt egyáltalán nem
	    ajánlott.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="unknown-hw-addr-format">
	  <para>Mik azok az <errorname>arp: unknown hardware address
	    format</errorname> hibaüzenetek?</para>
	</question>

	<answer>
	  <para>Ez arra utal, hogy valamelyik gép a helyi
	    Ethernet-alapú hálózatunkon olyan
	    MAC-címet használ, amelynek a &os; nem ismeri
	    a formátumát.  Valószínûleg
	    olyankor kapjuk ezt a hibaüzenetet, amikor valaki
	    más kísérletezik az Ethernet
	    kártyája beállításaival
	    valahol a hálózaton.  Leggyakrabban
	    kábelmodemes hálózatokon
	    tapasztalhatunk ilyet.  Megnyugodhatunk, teljesen
	    veszélytelen, semmilyen hatással nincs a &os;
	    gépünk
	    teljesítményére.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="arp-wrong-iface">
	  <para>Miért jelennek meg <errorname>192.168.0.10 is on
	    fxp1 but got reply from 00:15:17:67:cf:82 on rl0</errorname>
	    üzenetek a konzolon és hogyan lehet ezeket
	    kikapcsolni?</para>
	</question>

	<answer>
	  <para>Ilyen üzeneteket akkor kapunk, amikor a
	    hálózaton kívülrõl
	    érkezik hozzánk váratlanul egy csomag.
	    A letiltásukhoz állítsuk a
	    <varname>net.link.ether.inet.log_arp_wrong_iface</varname>
	    értékét <literal>0</literal>-ra.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="cvsup-missing-libs">
	  <para>A <application>CVSup</application> programot
	    telepítése után nem lehet
	    elindítani, mert hibákat jelez.  Mi a
	    gond?</para>
	</question>

	<answer>
	  <para>Elõször is nézzük meg, hogy az
	    iménti hibaüzenet mellett nem látunk-e
	    valami hasonlót:</para>

	  <programlisting>/usr/libexec/ld-elf.so.1: Shared object "libXaw.so.6" not found</programlisting>

	  <para>Az ilyen jellegû hibák
	    általában olyankor keletkeznek, amikor olyan
	    gépre telepítjük a <package>net/cvsup</package> portot, amelyen
	    viszont nem található meg a
	    <application>&xorg;</application> programcsomag.
	    Amennyiben szükségünk lenne
	    <application>CVSup</application> programhoz mellékelt
	    grafikus felületre, akkor kénytelenek
	    leszünk mellé az
	    <application>&xorg;</application> programjait is
	    telepíteni.  Ha viszont egyszerûen csak
	    parancssorból szeretnénk használni a
	    <application>CVSup</application> lehetõségeit,
	    töröljük le a korábban
	    telepített csomagot, majd helyette rakjuk fel a
	    <package>net/cvsup-without-gui</package>
	    vagy a <package>net/csup</package> portot.
	    A &os; újabb változataiban
	    megpróbálkozhatunk a &man.csup.1;
	    használatával is.  Ezzel a
	    témával részletesebban a
	    kézikönyv <link xlink:href="&url.books.handbook;/cvsup.html">CVSup használatáról</link>
	    szóló része foglalkozik.</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter xml:id="security" xml:lang="hu">
    <title>Biztonság</title>

    <qandaset>
      <qandaentry>
	<question xml:id="sandbox">
	  <para>Mi az a <quote>járóka</quote>
	    (sandbox)?</para>
	</question>

	<answer>
	  <para>A járóka alapvetõen egy
	    biztonsági szakkifejezés.  Két dolgot
	    jelenthet:</para>

	    <itemizedlist>
	      <listitem>
		<para>Egy virtuális falak között
		  futó programot, melyeket azért emeltek a
		  program köré, hogy a
		  feltörését követõen
		  megakadályozzák a rendszer többi
		  részének
		  elérését.</para>

		<para>A program csak a falon belül
		  <quote>játszhat</quote>.  Ilyenkor semmilyen
		  olyan kódot nem képes futtatni, amellyel
		  át tudna lépni a falakon, így a
		  használatához nem kell elõzetesen
		  átvizsgálni a forrásait ahhoz,
		  hogy meg tudjuk gyõzõdni a
		  biztonságosságáról.</para>

		<para>Ez a fal lehet például egy
		  felhasználói azonosító.  A
		  &man.security.7; és &man.named.8; man oldalakon
		  is ezt a definíciót találjuk
		  meg.</para>

		<para>Vegyük például az
		  <literal>ntalk</literal> szolgáltatást
		  (lásd &man.inetd.8;).  Ezt a
		  szolgáltatást korábban a
		  <systemitem class="username">root</systemitem> felhasználó
		  azonosítójával futtatták,
		  de manapság viszont már a
		  <systemitem class="username">tty</systemitem> felhasználóval
		  fut.  A <systemitem class="username">tty</systemitem>
		  felhasználó lényegében egy
		  olyan járóka, amely az
		  <literal>ntalk</literal> szolgáltatás
		  feltörésekor nem engedi, hogy a rendszer
		  többi részéhez is hozzá
		  lehessen férni.</para>
	      </listitem>

	      <listitem>
		<para>A valódi gépet utánzó
		  rendszerben futó programot.  Ez már egy
		  sokkal kifinomultabb megoldás.  Ha ilyenkor
		  valakinek sikerül betörnie a programba,
		  akkor könnyen azt hiheti, hogy sikerült a
		  rendszer többi részét is
		  elérnie, de valójában csak egy
		  szimulált gépen van, és semmilyen
		  valós adatot nem képes
		  módosítani.</para>

		<para>Leggyakrabban ezt úgy szokták
		  elérni, hogy egy könyvtárban
		  létrehoznak egy szimulált
		  környezetet, majd itt futtatják az adott
		  programot a &man.chroot.8;
		  segítségével.  (Ekkor az
		  iménti könyvtár lesz a
		  gyökérkönyvtár az adott
		  folyamat számára, nem pedig a rendszer
		  igazi gyökere.)</para>

		<para>Másik szintén gyakori
		  megoldás a használt
		  állományrendszerek
		  írásvédett
		  csatlakoztatása, amely felett aztán
		  kialakítanak a program számára
		  egy látszólag írható
		  réteget.  Ilyenkor a program teljesen
		  úgy érzékeli, hogy képes a
		  rendszerben elérhetõ
		  állományokat módosítani,
		  azonban egyedül csak saját maga
		  látja ezeket, a rendszerben futó
		  többi program viszont nem
		  feltétlenül.</para>

		<para>Ezeket a járókákat
		  általában úgy szokták
		  felépíteni, hogy a
		  felhasználók (vagy a
		  támadók) számára teljesen
		  észrevétlenek legyenek.</para>
	      </listitem>
	    </itemizedlist>

	  <para>A &unix; két alapvetõ
	    járókát valósít meg.  Az
	    egyik a futó programok, a másik pedig a
	    felhasználói azonosítók
	    szintjén mûködik.</para>

	  <para>Futása közben minden &unix; program teljesen
	    elszigetelt minden más &unix; programtól,
	    így az egyik nem képes
	    módosítani a másik
	    memóriában tárolt adatait.  A
	    &windows;-tól eltérõen, ahol
	    ugyebár az egyik program könnyedén el
	    tudja érni egy másik
	    memóriaterületét, ezért a program
	    nem képesek egymásban kárt
	    tenni.</para>

	  <para>A &unix; alatt futó programok mindig egy adott
	    felhasználóhoz tartoznak.  Ha ez nem a
	    <systemitem class="username">root</systemitem> felhasználó, akkor
	    azzal lényegében egy tûzfalat hozunk
	    létre a különbözõ
	    felhasználók által birtokolt folyamatok
	    között.  A felhasználók
	    azonosítói emellett segítenek a lemezen
	    tárolt adatokat is elszigetelni
	    egymástól.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="securelevel">
	  <para>Mi az a biztonsági szint (securelevel)?</para>
	</question>

	<answer>
	  <para>A biztonsági szintek egy rendszermagon belül
	    megvalósított védelmi módszert
	    képviselnek.  A pozitív
	    értékû biztonsági szintek
	    esetén a rendszermag korlátoz bizonyos
	    feladatokat, amelyeket ilyenkor még a
	    rendszeradminisztrátor (vagyis a
	    <systemitem class="username">root</systemitem> felhasználó) sem
	    képes elvégezni.  Az írás
	    pillanatában a biztonsági szintek, több
	    más dolog mellett, a következõk
	    szabályozására alkalmasak:</para>

	  <itemizedlist>
	    <listitem>
	      <para>a különbözõ
		állományjelzõk, például
		az <literal>schg</literal> (a <quote>system
		immutable</quote> jelzés)
		törlése;</para>
	    </listitem>

	    <listitem>
	      <para>a rendszermag memóriájának
		elérése a <filename>/dev/mem</filename>
		és <filename>/dev/kmem</filename>
		eszközökön keresztül;</para>
	    </listitem>

	    <listitem>
	      <para>a rendszermag moduljainak
		betöltése;</para>
	    </listitem>

	    <listitem>
	      <para>a tûzfal szabályainak
		módosítása.</para>
	    </listitem>
	  </itemizedlist>

	  <para>A jelenleg futó rendszer biztonsági
	    szintjét a következõ parancs
	    segítségével lehet
	    lekérdezni:</para>

	  <screen>&prompt.root; <userinput>sysctl kern.securelevel</userinput></screen>

	  <para>A parancs eredménye az adott &man.sysctl.8;
	    változó (vagyis esetünkben a
	    <varname>kern.securelevel</varname>) és annak
	    értéke lesz, amely egy szám.  Ez
	    utóbbi adja meg a biztonsági szint
	    aktuális értékét.  Amennyiben ez
	    pozitív (vagyis nullánál nagyobb),
	    akkor érvényben vannak a biztonsági
	    szintekhez kapcsolódó bizonyos
	    korlátozások.</para>

	  <para>Egy mûködõ rendszer biztonsági
	    szintjét nem lehet csökkenteni, hiszen ezzel
	    tulajdonképpen hatástalanná
	    tennénk.  Ha olyan feladatot akarunk
	    végrehajtani, amely nem pozitív
	    biztonsági szintet igényel
	    (például az alaprendszer
	    frissítése vagy a dátum
	    átállítása), akkor ahhoz
	    elõször módosítanunk kell az
	    <filename>/etc/rc.conf</filename> állományt
	    (lásd <varname>kern_securelevel</varname> és
	    <varname>kern_securelevel_enable</varname>
	    változók), majd újraindítani a
	    rendszert.</para>

	  <para>A biztonsági szintekkel és rájuk
	    vonatkozó információkkal kapcsolatban
	    olvassuk el az &man.init.8; man oldalt.</para>

	    <warning>
	      <para>A biztonsági szintek nem
		feltétlenül jelentenek minden
		problémára tökéletes
		megoldást.  Rentegeg ismert
		hátulütõvel rendelkeznek, és
		gyakran a biztonság hamis érzetét
		keltik.</para>

	      <para>Ezzel kapcsolatban az egyik legnagyobb gond, hogy
		csak abban az esetben mûködik rendesen a
		rendszer, ha a rendszerindítás
		során a biztonsági szintek
		beállításáig minden
		állományt levédünk.  Ha a
		támadó képes lefuttatni a
		saját programját még a
		biztonsági szint beállítása
		elõtt (amely viszont elég késõn
		történik meg, hiszen a
		rendszerindítás során számos
		olyan dolog feladat van, amely nem végezhetõ
		el magasabb biztonsági szinteken), akkor azzal az
		egész védelmi módszer
		hatástalanítható.  Habár a
		rendszerindítás folyamán
		felhasznált állományok
		biztonságba helyezése technikailag
		egyáltalán nem lehetetlen,
		nehezebbé válik tõle a rendszer
		karbantartása, mivel ilyenkor az egész
		rendszert át kell állítanunk
		legalább egyfelhasználós
		módba és úgy
		módosítani a konfigurációs
		állományokat.</para>

	      <para>Ezt és az ehhez hasonló
		problémák gyakran felmerülnek a
		levelezési listákon,
		különösen a &a.security;
		archívumaiban.  <link xlink:href="&url.base;/search/index.html">Ezen</link> a
		funkción keresztül nézhetünk
		után a téma részletesebb
		tárgyalásának.
		Néhányan reménykednek, hogy a
		biztonsági szinteket hamarosan leváltja
		valami sokkal finomabb beállítási
		lehetõségekkel rendelkezõ
		megoldás, azonban a dolgok még
		eléggé homályosak ebbõl a
		szempontból.</para>

	      <para>Figyelmeztettünk mindenkit!</para>
	    </warning>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="extra-named-port">
	  <para>A BIND (<command>named</command>)
	    különféle nagyobb sorszámú
	    portokat használ.  Miért?</para>
	</question>

	<answer>
	  <para>A BIND a kimenõ kérésekhez
	    véletlenszerûen kiválaszt egy nagyobb
	    sorszámú portot.  A legújabb
	    változataiban már minden egyes
	    kéréshez külön
	    véletlenszerûen keres új UDP portot.  Ez
	    bizonyos hálózati konfigurációk
	    esetén problémákhoz vezethet,
	    különösen olyankor, amikor a
	    beérkezõ UDP csomagokat egy tûzfal
	    megállítja.  A tûzfalak által
	    blokkolt porttartományok használatát az
	    <literal>avoid-v4-udp-ports</literal> vagy az
	    <literal>avoid-v6-udp-ports</literal>
	    beállítással tilthatjuk le a program
	    számára.</para>

	  <warning>
	    <para>Ha ezt a portot (mint például az 53) az
	      <filename>/etc/namedb/named.conf</filename>
	      állományban a
	      <literal>query-source</literal> vagy a
	      <literal>query-source-v6</literal>
	      beállításokkal adjuk meg explicit
	      módon, akkor a program nem fogja
	      véletlenszerûen váltogatni a portokat.
	      Határozottan javasoljuk, hogy ezekkel az
	      opciókkal ne adjunk meg elõre
	      rögzített portokat.</para>
	  </warning>

	  <para>Mindenesetre örülünk, hogy ezt is valaki
	    megkérdezte!  Hiába, nem árt néha
	    nézegetni a &man.sockstat.1; kimenetét
	    és észrevenni benne néhány
	    furcsaságot.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="sendmail-port-587">
	  <para>A <application>sendmail</application> a
	    szabványos 25-ös port mellett az 587-es portot
	    használja!  Miért?</para>
	</question>

	<answer>
	  <para>A <application>sendmail</application> újabb
	    verzióiban felfedezhetõ
	    levélküldési lehetõségek az
	    587-es portot használják.  Jelenleg ezt
	    még nem sokan használják ki, de
	    növekszik a népszerûsége.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="toor-account">
	  <para>Kié az a nullás felhasználói
	    azonosítójú <systemitem class="username">toor</systemitem>
	    fiók?  Betörtek a gépre?</para>
	</question>

	<answer>
	  <para>Ne aggódjunk!  A <systemitem class="username">toor</systemitem> egy
	    <quote>alternatív</quote> rendszergazdai
	    hozzáférés (a <quote>toor</quote> a
	    <quote>root</quote> visszafelé).  Korábban
	    csak a &man.bash.1; parancsértelmezõ
	    telepítésekor jött létre, azonban
	    manapság már alapértelmezés
	    szerint létrejön.  A nem szabványos
	    parancsértelmezõk számára
	    találták ki, így nem a
	    <systemitem class="username">root</systemitem> alapértelmezett
	    parancsértelmezõjét kell
	    megváltoztatnunk.  Ez különösen olyan
	    parancsértelmezõk esetén fontos, amelyek
	    nem részei az alaprendszernek (például
	    a portként vagy csomagként telepített
	    parancsértelmezõk esetén) és
	    ezért a <filename>/usr/local/bin</filename>
	    könyvtárba fognak kerülni.  Ez a
	    könyvtár alapértelmezés szerint
	    azonban egy külön állományrendszeren
	    található.  Ha a <systemitem class="username">root</systemitem>
	    parancsértelmezõje viszont a <filename>/usr/local/bin</filename>
	    könyvtárban lenne, miközben a <filename>/usr</filename> (vagy bármelyik
	    más állományrendszer, amely az
	    imént említett könyvtárat
	    tartalmazza) nem csatlakoztatható valamilyen
	    oknál fogva, akkor a <systemitem class="username">root</systemitem> nem
	    lenne képes bejelentkezni és kijavítani
	    a problémát.  (Noha amikor
	    újraindítjuk a rendszerünket
	    egyfelhasználós módban, akkor a
	    rendszer rá fog kérdezni, hogy melyik
	    parancsértelmezõt akarjuk
	    használni.)</para>

	  <para>Egyesek nem szabványos
	    parancsértelmezõn keresztül a
	    <systemitem class="username">toor</systemitem> felhasználóval
	    végzik el a <systemitem class="username">root</systemitem> mindennapi
	    teendõit, így a szabványos
	    parancsértelmezõt csak a vészhelyzetekre
	    tartogatják.  Alapértelmezés szerint a
	    <systemitem class="username">toor</systemitem> felhasználóval nem
	    tudunk bejelentkezni, mivel nincs jelszava, ezért ha
	    használni akarjuk, akkor elõször
	    jelentkezzünk be a <systemitem class="username">root</systemitem>
	    felhasználóval, majd állítsunk
	    be neki egy jelszót.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="suidperl">
	  <para>A <command>suidperl</command> parancs miért nem
	    mûködik rendesen?</para>
	</question>

	<answer>
	  <para>Biztonsági okokból a
	    <command>suidperl</command> parancs
	    alapértelmezés szerint nem kerül
	    telepítésre.  Ha forrásból
	    frissítjük rendszerünket és azt
	    szeretnénk, hogy ennek során a
	    <command>suidperl</command> is leforduljon, akkor a
	    <command>perl</command> fordításának
	    megkezdése elõtt vegyük fel a
	    <literal>ENABLE_SUIDPERL=true</literal>
	    sort az <filename>/etc/make.conf</filename>
	    állományba.</para>
	</answer>

      </qandaentry>
    </qandaset>
  </chapter>

  <chapter xml:id="ppp" xml:lang="hu">
    <title>PPP</title>

    <qandaset>
      <qandaentry>
	<question xml:id="userppp">
	  <para>Nem mûködik a &man.ppp.8;.  Mit lehet a
	    gond?</para>
	</question>

	<answer>
	  <para>Elsõként mindenképpen olvassuk el a
	    &man.ppp.8; man oldalt és a kézikönyv
	    <link xlink:href="&url.books.handbook;/ppp-and-slip.html#USERPPP">PPP-vel</link>
	    foglalkozó részét.  A
	    következõ paranccsal engedélyezzük a
	    naplózást:</para>

	  <programlisting>set log Phase Chat Connect Carrier lcp ipcp ccp command</programlisting>

	  <para>Ezt a parancsot a &man.ppp.8; parancssorában vagy
	    az <filename>/etc/ppp/ppp.conf</filename>
	    konfigurációs állományban kell
	    megadnunk (leginkább a <literal>default</literal>
	    szakasz elejére érdemes betennünk).
	    Gondoskodjunk róla, hogy az
	    <filename>/etc/syslog.conf</filename> állomány
	    (lásd &man.syslog.conf.5;) tartalmazza az
	    alábbi sort, illetve az
	    <filename>/var/log/ppp.log</filename> állomány
	    létezzen:</para>

	  <programlisting>!ppp
*.*        /var/log/ppp.log</programlisting>

	  <para>A napló segítségével
	    már több mindent ki tudunk deríteni a
	    &man.ppp.8; mûködésérõl.  Ne
	    aggódjunk, ha nem értünk belõle
	    semmit.  Kérjünk segítséget
	    másoktól, nekik minden bizonnyal
	    segíteni fog a probléma
	    felderítésében.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ppp-hangs">
	  <para>A &man.ppp.8; miért bontja a vonalat, amikor
	    elindul?</para>
	</question>

	<answer>
	  <para>Ilyen általában azért
	    történik, mert nem tudta feloldani a
	    hálózati nevet.  Ezt a legkönnyebben
	    úgy tudjuk orvosolni, ha az
	    <filename>/etc/host.conf</filename> állományba
	    elõre rakjuk a <literal>hosts</literal> sort,
	    így a névfeloldó elõször az
	    <filename>/etc/hosts</filename> állománnyal
	    fog próbálkozni.  Ezután a
	    <filename>/etc/hosts</filename> állományba
	    vegyük fel a helyi gépet.  Ha nincs helyi
	    hálózatunk, akkor így írjuk
	    át a <systemitem>localhost</systemitem> sort:</para>

	  <programlisting>127.0.0.1        ize.minta.com ize localhost</programlisting>

	  <para>Minden más esetben egyszerûen csak
	    vegyünk fel egy újabb bejegyzést a
	    gépünkhöz.  Ennek pontosabb
	    részleteivel kapcsolatban nézzük meg a
	    megfelelõ man oldalakat.</para>

	  <para>Ha mindent jól csináltunk, akkor a
	    <command>ping -c1 `hostname`</command> parancs hiba
	    nélkül tér vissza.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ppp-nodial-auto">
	  <para>A &man.ppp.8; miért nem tárcsáz
	    <literal>-auto</literal> módban?</para>
	</question>

	<answer>
	  <para>Elõször is ellenõrizzük, hogy
	    létezik az alapértelmezett útvonal.  A
	    <command>netstat -rn</command> parancs (lásd
	    &man.netstat.1;) kiadása után
	    nagyjából a következõ két
	    bejegyzést kell látnunk:</para>

	  <programlisting>Destination        Gateway            Flags     Refs     Use     Netif Expire
default            10.0.0.2           UGSc        0        0      tun0
10.0.0.2           10.0.0.1           UH          0        0      tun0</programlisting>

	  <para>Feltételezzük, hogy a
	    kézikönyvbõl, a man oldalról vagy
	    <filename>ppp.conf.sample</filename>
	    állományból másoltuk ki ezeket a
	    címeket.  Ha nincs alapértelmezett
	    útvonalunk, akkor annak az lehet az oka, hogy a
	    <filename>ppp.conf</filename> állományba
	    elfelejtettük felvenni a <literal>HISADDR</literal>
	    kulcsszót.</para>

	  <para>Az alapértelmezett útvonal
	    hiányának másik oka lehet még, ha
	    az <filename>/etc/rc.conf</filename>
	    állományban (lásd &man.rc.conf.5;)
	    beállítottunk egy alapértelmezett
	    átjárót, de elfelejtettük az
	    <filename>ppp.conf</filename> állományba
	    betenni a következõ sort:</para>

	  <programlisting>delete ALL</programlisting>

	  <para>Ebben az esetben menjünk vissza a
	    kézikönyv <link xlink:href="&url.books.handbook;/userppp.html#USERPPP-FINAL">A rendszer végsõ beállítása</link>
	    címû részéhez.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="no-route-to-host">
	  <para>Mit jelent a <errorname>No route to host</errorname>
	    hibaüzenet?</para>
	</question>

	<answer>
	  <para>Általában azért jelentkezik, mert
	    az <filename>/etc/ppp/ppp.linkup</filename>
	    állományban nem adtuk meg az
	    alábbiakat:</para>

	  <programlisting>MYADDR:
  delete ALL
  add 0 0 HISADDR</programlisting>

	  <para>Erre csak akkor van szükségünk, ha
	    dinamikus IP-címünk van, vagy nem ismerjük az
	    átjáró címét.  Ha az
	    interaktív módot használjuk, akkor
	    ehhez a következõket kell begépelni
	    csomag módba lépés után (a
	    csomag módot a csupa nagybetûs
	    <acronym>PPP</acronym> jelzi a parancssorban):</para>

	  <programlisting>delete ALL
add 0 0 HISADDR</programlisting>

	  <para>A kézikönyv <link xlink:href="&url.books.handbook;/userppp.html#USERPPP-DYNAMICIP">A PPP és a dinamikus IP-címek</link>
	    címû részében olvashatunk
	    errõl bõvebben.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="connection-threeminutedrop">
	  <para>Miért szakad meg a kapcsolat 3 perc
	    után?</para>
	</question>

	<answer>
	  <para>A PPP alrendszer alapértelmezett lejárati
	    ideje 3 perc.  Ezt a beállítást a
	    következõ sor megadásával tudjuk
	    módosítani:</para>

	  <programlisting>set timeout <replaceable>NNN</replaceable></programlisting>

	  <para>ahol az <replaceable>NNN</replaceable>
	    másodpercekben megadja a kapcsolat
	    lezárása elõtti inaktivitás
	    maximális idejét.  Ha az
	    <replaceable>NNN</replaceable> értéke nulla,
	    akkor a kapcsolat idõtúllépés
	    miatt soha nem fog magától megszakadni.  Ezt a
	    parancsot a <filename>ppp.conf</filename>
	    állományba tudjuk felvenni, vagy
	    interaktív módban a parancssorban
	    gépelhetjük be.  Emellett menet közben is
	    állítani tudjuk ezt az értéket,
	    ha a <application>ppp</application> szerverre a
	    &man.telnet.1; vagy a &man.pppctl.8;
	    segítségével rácsatlakozunk.
	    Errõl a &man.ppp.8; man oldal ad részletesebb
	    tájékoztatást.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ppp-drop-heavy-load">
	  <para>A kapcsolat miért szakad meg nagyobb
	    terhelést alatt?</para>
	</question>

	<answer>
	  <para>Ha beállítottuk a Link Quality Reporting
	    (LQR) használatát, akkor elõfordulhat,
	    hogy túlságosan sok csomag veszik el a
	    gépünk és a másik oldal
	    között.  A &man.ppp.8; ezért a vonalat
	    rossznak érzékeli és bontja.  A
	    &os;&nbsp;2.2.5 változata elõtt az LQR
	    alapértelmezés szerint engedélyezett
	    volt.  Az LQR így tiltható le:</para>

	  <programlisting>disable lqr</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ppp-drop-random">
	  <para>A kapcsolat miért szakad meg
	    véletlenszerûen?</para>
	</question>

	<answer>
	  <para>Néha elõfordulhat, hogy a zajos telefonvonal
	    esetén vagy a
	    hívásvárakoztatás
	    használatakor a modem bontja a vonalat, mivel
	    (helytelenül) azt hiszi, hogy nincs kapcsolat.</para>

	  <para>Manapság a legtöbb modemen
	    általában be lehet valahogy
	    állítani, hogy mennyire legyenek
	    elnézõek a kapcsolat ideiglenes
	    megszakadásával szemben.
	    Például egy &usrobotics;&nbsp;&sportster;
	    esetén ezt tizedmásodpercekben mérik az
	    <literal>S10</literal> regiszter
	    segítségével.  A modemünk ilyenkor
	    tehát úgy tehetõ sokkal
	    toleránsabbá, ha a következõ
	    hívási beállítást
	    adjuk:</para>

	  <programlisting>set dial "...... ATS10=10 OK ......"</programlisting>

	  <para>További részleteket a modem
	    kézikönyvébõl tudhatunk meg.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ppp-hangs-random">
	  <para>A kapcsolat miért fullad le
	    véletlenszerûen?</para>
	</question>

	<answer>
	  <para>Sokan tapasztalják, hogy a kapcsolat minden
	    különösebb magyarázat nélkül
	    lefullad.  Ilyenkor elsõként azt érdemes
	    tisztázni, hogy az összeköttetés
	    melyik oldalán történt a vonal
	    bontása.</para>

	  <para>Ha belsõ modemet használunk, akkor
	    próbáljuk meg a &man.ping.8; paranccsal
	    ellenõrizni, hogy a modem <acronym>TD</acronym>
	    lámpája villog-e az adatok
	    küldésekor.  Amennyiben igen (miközben az
	    <acronym>RD</acronym> lámpa viszont nem), akkor a
	    gond a vonal másik végén lesz.  Ha
	    viszont a <acronym>TD</acronym> nem villog, akkor a
	    probléma a mi oldalunkon áll fenn.  A
	    belsõ modemek esetében a
	    <filename>ppp.conf</filename> állományban a
	    <literal>set server</literal> parancsot is érdemes
	    megadnunk, így amikor a kapcsolat
	    leállását tapasztaljuk, a
	    &man.pppctl.8; segítségével rá
	    tudunk csatlakozni a &man.ppp.8; démonra.  Ha a
	    hálózati kapcsolat ekkor hirtelen erõre
	    kapna (mivel rácsatlakoztunk
	    kívülrõl) vagy egyáltalán nem
	    tudunk csatlakozni (feltételezve, hogy a <literal>set
	    socket</literal> parancs sikeresen lefutott az
	    induláskor), akkor a probléma még
	    mindig nálunk lesz.  Ha viszont sikerül
	    csatlakoznunk és a vonallal még mindig gondok
	    vannak, akkor próbáljuk a <literal>set log
	    local async</literal> parancs használatával
	    engedélyezni a helyi aszinkron
	    naplózást, majd egy másik
	    konzolból a &man.ping.8; parancs
	    segítségével kezdjük el
	    használni az összeköttetést.  Az
	    aszinkron naplózás jelezni fogja, ha
	    sikerül adatokat átvinni és fogadni a
	    kapcsolaton keresztül.  Ha ilyenkor nem látunk
	    visszafele érkezõ adatokat, akkor az arra utal,
	    hogy a gond a vonal távoli végén
	    van.</para>

	  <para>Miután sikeresen kiderítettük, hogy
	    az adott probléma helyi vagy távoli, két
	    lehetõségünk van:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Amennyiben távoli, olvassuk el a <xref linkend="ppp-remote-not-responding"/>
		  válaszát.</para>
	    </listitem>

	    <listitem>
	      <para>Amennyiben helyi, olvassuk el a <xref linkend="ppp-hung"/> válaszát.</para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ppp-remote-not-responding">
	  <para>A vonal túlsó végérõl
	    nem érkezik válasz.  Mi lehet tenni?</para>
	</question>

	<answer>
	  <para>Ezzel szemben nagyon keveset tudunk mi,
	    felhasználók tenni.  A legtöbb
	    internetszolgáltató egyszerûen nem
	    hajlandó segítséget nyújtani
	    abban az esetben, ha nem valamelyik &microsoft;
	    operációs rendszert használjuk.  A
	    <filename>ppp.conf</filename> állományunkban a
	    <literal>enable lqr</literal> sor megadásával
	    engedélyezni tudjuk a &man.ppp.8;
	    számára, hogy észlelhesse a
	    távoli hibákat és bontsa a vonalat, de
	    ez a vizsgálat viszonylag idõigényes
	    és ennélfogva nem túlságosan
	    hasznos.  A szolgáltatónknak pedig ne nagyon
	    emlegessük, hogy felhasználói PPP-t
	    futtatunk.</para>

	  <para>Elõször próbáljunk meg letiltani
	    mindenféle tömörítést a
	    következõ sor megadásával:</para>

	  <programlisting>disable pred1 deflate deflate24 protocomp acfcomp shortseq vj
deny pred1 deflate deflate24 protocomp acfcomp shortseq vj</programlisting>

	  <para>Kapcsolódjunk újra és
	    ellenõrizzük, hogy továbbra is
	    mûködõképes a kapcsolat.  Ha ennek
	    hatására javul a helyzet vagy a
	    probléma teljesen megoldódik, akkor a
	    beállítások egyenkénti
	    próbálgatásával keressük
	    meg, hogy melyik okozta a gondot.  Ez már
	    elegendõ lesz ahhoz, hogy komolyabban felvegyük a
	    kapcsolatot a szolgáltatónkkal (habár
	    ebbõl gyorsan ki fog derülni, hogy nem &microsoft;
	    terméket használunk).</para>

	  <para>Mielõtt szólnánk a
	    szolgáltatónknak, a gépünkön
	    engedélyezzük az aszinkron
	    naplózást és várjuk meg,
	    amíg a kapcsolat újra megszakad.  Erre nem
	    árt felkészülnünk, mert viszonylag
	    sok tárhelyet igényel.  Innen majd a
	    portról utoljára olvasott adat lesz a
	    lényeges.  Ez általában szöveges
	    adat és akár a probléma konkrét
	    okára is utalhat (<errorname>Memory
	    fault</errorname>, <errorname>Core
	    dumped</errorname>?).</para>

	  <para>Ha segítõkész
	    szolgáltatót választottuk, akkor a
	    naplózást akár az õ oldalunkon is
	    engedélyezhetjük, így amikor a vonal
	    megszakad, az õ szemszögükbõl is
	    képesek leszünk elemezni a
	    problémát.  Ilyen esetben nyugodtan
	    küldjünk egy levelet &a.brian;
	    címére vagy kérjük meg a
	    szolgáltatónkat, hogy közvetlenül
	    vele tárgyaljon.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ppp-hung">
	  <para>A &man.ppp.8; teljesen megállt.  Mi lehet
	    tenni?</para>
	</question>

	<answer>
	  <para>A legjobban úgy járunk, ha a &man.ppp.8;
	    programot nyomkövetési
	    információkkal fordítjuk újra,
	    majd a &man.gdb.1; segítségével
	    lekérünk egy hívási láncot
	    az éppen megakadt <application>ppp</application>
	    példánytól.  A
	    <application>ppp</application> alkalmazást a
	    következõ parancsokkal tudjuk úgy
	    újrafordítani, hogy tartalmazza a
	    kívánt információkat:</para>

	  <screen>&prompt.root; <userinput>gdb ppp `pgrep ppp`</userinput></screen>

	  <para>Ezt követõen a <application>gdb</application>
	    parancssorában a <command>bt</command> és
	    <command>where</command> parancsok
	    segítségével hozzá tudunk jutni
	    a hívási lánchoz.  Mentsük el
	    valahova a <application>gdb</application> által
	    kinyert adatokat, majd a <command>detach</command>
	    paranccsal váljunk le a futó programról
	    és a <command>quit</command>
	    begépelésével lépjünk ki a
	    <application>gdb</application> programból.</para>

	  <para>Végezetül az elmentett eredményeket
	    küldjük el &a.brian; címére.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ppp-loginok-thennothing">
	  <para>Miért nem történik semmi a
	    <quote>Login OK!</quote> üzenet után?</para>
	</question>

	<answer>
	  <para>A &os; 2.2.5 elõtti kiadásaiban a
	    &man.ppp.8; az összeköttetés
	    létrejötte után megvárta, hogy a
	    távoli pont kezdeményezze a
	    kapcsolatvezérlõ protokoll (Line Control
	    Protocol, LCP) használatát.  Sok
	    szolgáltató azonban nem csinál ilyet,
	    ehelyett inkább a klienstõl várják
	    mindezt.  Az LCP kezdeményezését
	    így kényszeríthetjük ki a
	    &man.ppp.8; használata során:</para>

	  <programlisting>set openmode active</programlisting>

	    <note>
	      <para>Általában semmilyen gond nem
		származik abból, ha a mind a két
		oldal kezdeményez, így az
		<varname>openmode</varname> alapértelmezés
		szerint <literal>active</literal>
		értékû.  A következõ
		szakaszban azonban bemutatjuk mikor <emphasis>gondot
		okoz</emphasis> a használata.</para>
	    </note>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ppp-same-magic">
	  <para>Folyamatosan <errorname>Magic is same</errorname>
	    hibák jelennek meg.  Ez mire utal?</para>
	</question>

	<answer>
	  <para>Csatlakozás után idõnként
	    elõfordulhat, hogy <errorname>magic is the
	    same</errorname> hibaüzeneteket látunk a
	    naplóban.  Ezek az üzenetek bizonyos esetekben
	    teljesen ártalmatlanok, máskor viszont
	    akár komolyabb problémákat is jelezhet.
	    A legtöbb PPP implementáció nem él
	    túl egy ilyen hibát, és még ha
	    látszólag létre is jön ilyenkor a
	    kapcsolat, folyamatosan konfigurációs
	    kérések és válaszok
	    jönnek-mennek a naplóban egészen addig,
	    amíg a &man.ppp.8; végül fel nem adja
	    és lezárja a kapcsolatot.</para>

	  <para>Ez általában olyan szervereken jelenik
	    meg, ahol nem elég gyorsak a lemezek és minden
	    kapcsolathoz elindítanak egy &man.getty.8; és
	    a bejelentkezéskor vagy azt következõ
	    elindítják a &man.ppp.8; programot.  Egyes
	    visszajelzések szerint ilyen egyébként
	    gyakran elõfordul a slirp használatakor.  A
	    problémát egyébként a
	    &man.getty.8; és a &man.ppp.8; indítása
	    között eltelt idõ okozza, amikor a kliens
	    oldalán futó &man.ppp.8; elkezdi küldeni
	    a kapcsolatvezérlõ (Line Control Protocol, LCP)
	    csomagokat.  Mivel ilyenkor az ECHO még mindig
	    aktív a szerver adott portján, a kliens
	    &man.ppp.8; a saját csomagjainak
	    <quote>tükrözõdését</quote>
	    fogja látni.</para>

	  <para>Az LCP beállításának
	    része az összeköttetés két
	    oldalán egy-egy bûvös szám
	    (<quote>magic number</quote>)
	    megállapítása, amellyel ezután
	    észlelhetõek az ilyen
	    <quote>tükrözõdések</quote>.  A
	    protokoll szerint amikor a két pont
	    megpróbálja ugyanazt a bûvös
	    számot használni, akkor visszautasítja
	    (NAK jelzést küld) és egy másikat
	    választ.  Ha ilyenkor még a szerver
	    portján aktív az ECHO, akkor a kliens oldali
	    &man.ppp.8; azt tapasztalja, hogy elkezd LCP csomagokat
	    küldeni, majd mivel ugyanazt kapja vissza, erre egy NAK
	    jelzést válaszol.  Ugyanígy
	    látja magát a NAK jelzést (aminek
	    hatására a &man.ppp.8; megváltoztatja a
	    bûvös számát) is.  Ennek
	    eredményeképpen hirtelen nagy
	    mennyiségû
	    bûvösszám-váltás keletkezik,
	    ami pedig szépen felhalmozódik a szerver
	    terminálpufferében.  Ahogy a &man.ppp.8;
	    végre elindul a szerveren, elönti ez a rengeteg
	    információ, aminek alapján
	    sikertelennek ítéli meg az LCP
	    beállítását és feladja a
	    további próbálkozást.
	    Eközben a kliens számára megszûnnek
	    a visszaverõdõ csomagok és csak annyit
	    lát, hogy a szerver bontja a kapcsolatot.</para>

	  <para>Ezt úgy tudjuk elkerülni, ha a
	    <filename>ppp.conf</filename> állományban a
	    távoli pontra bízzuk az
	    beállítás
	    kezdeményezését:</para>

	  <programlisting>set openmode passive</programlisting>

	  <para>Ennek hatására a &man.ppp.8;
	    megvárja, hogy a szerver kezdeményezze az LCP
	    beállítását.  Egyes szerverek
	    azonban sosem teszik meg ezt.  Ilyenkor valami ilyesmit
	    tudunk tenni:</para>

	  <programlisting>set openmode active 3</programlisting>

	  <para>Így a &man.ppp.8; 3&nbsp;másodpercig
	    passzív marad, majd csak ezután kezd el LCP
	    kérésket küldeni.  Ha a távoli
	    pont eközben küld valamilyen kérést,
	    az &man.ppp.8; azonnal válaszol rá és
	    nem várja végig a 3&nbsp;másodperces
	    idõtartamot.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ppp-lcp-constant">
	  <para>Az LCP beállítása egészen a
	    kapcsolat befejezõdéséig
	    folytatódik.  Mi lehet a probléma?</para>
	</question>

	<answer>
	  <para>A &man.ppp.8; programban jelenleg van egy olyan
	    hibásan implementált jellemzõ, ahol az LCP,
	    CCP és IPCP válaszokat nem
	    társítja az eredeti kérésekhez.
	    Ennek következményeképpen, ha az egyik
	    PPP implementáció 6&nbsp;másodperccel
	    lassabb a másik oldalnál, akkor az még
	    két további LCP konfigurációs
	    kérést is küld, ami viszont
	    végzetesnek bizonyul.</para>

	  <para>Vegyünk például két
	    implementációt, az <systemitem>A</systemitem> és
	    a <systemitem>B</systemitem> pontokat.  Az <systemitem>A</systemitem>
	    már közvetlenül a csatlakozás
	    után LCP kéréseket kezd el
	    küldeni, miközben a <systemitem>B</systemitem> csak
	    7&nbsp;másodperc múlva tud elindulni.  Mire
	    végre a <systemitem>B</systemitem> pont is elindul, addigra
	    az <systemitem>A</systemitem> már kiküldött 3 LCP
	    kérést.  Most feltételezzük, hogy
	    nincs ECHO, máskülönben az elõzõ
	    szakaszban leírt, bûvös számokkal
	    kapcsolatos problémába
	    ütköznénk.  A <systemitem>B</systemitem> ekkor
	    tehát küld egy kérést, majd
	    nyugtázza az <systemitem>A</systemitem> ponttól kapott
	    korábbi kérést.  Ennek
	    hatására az <systemitem>A</systemitem> pont
	    <acronym>OPENED</acronym> állapotba megy át,
	    újra küld és nyugtázza az
	    elõzõ kérést <systemitem>B</systemitem>
	    felé.  Eközben a <systemitem>B</systemitem>
	    további két nyugtázást küld
	    az <systemitem>A</systemitem> pontról kapott további
	    két kérésre, a <systemitem>B</systemitem>
	    indulása elõttrõl.  A <systemitem>B</systemitem>
	    ekkor megkapja az <systemitem>A</systemitem> elsõ
	    nyugtáját és átvált
	    <acronym>OPENED</acronym> állapotba.  Az
	    <systemitem>A</systemitem> ekkor megkapja a második
	    nyugtát a <systemitem>B</systemitem> ponttól és
	    visszavált <acronym>REQ-SENT</acronym>
	    állapotba, majd az RFC szerint elküld
	    (elõre) egy újabb kérést.  Ekkor
	    megkapja a harmadik nyugtát és
	    <acronym>OPENED</acronym> állapotba vált.
	    Eközben a <systemitem>B</systemitem> megkapja elõre
	    küldött kérést a <systemitem>A</systemitem>
	    ponttól, amelynek hatására
	    <acronym>ACK-SENT</acronym> állapotba vált
	    vissza, és az RFC szerint ismét küld egy
	    (második) kérést és egy
	    nyugtázást.  Az <systemitem>A</systemitem> erre
	    megkapja a kérést, visszavált
	    <acronym>REQ-SENT</acronym> állapotban és
	    küld egy újabb kérést.  Ekkor
	    közvetlenül megkapja a
	    rákövetkezõ nyugtázást
	    és átvált <acronym>OPENED</acronym>
	    állapotba.</para>

	  <para>Ez egészen addig folytatódik, amíg
	    az egyik oldal rá nem eszmél, hogy ennek nincs
	    túlságosan sok értelme és
	    feladja a próbálkozást.</para>

	  <para>Ez legkönnyebben úgy kerülhetõ el,
	    ha ilyenkor az egyik oldalt <literal>passive</literal>
	    típusúra állítjuk, vagyis az
	    egyik oldalon várunk egy keveset a
	    beállítás
	    kezdeményezésére.  Ezt a
	    következõ paranccsal lehet megoldani:</para>

	  <programlisting>set openmode passive</programlisting>

	  <para>Óvatosan bánjunk ezzel a
	    paraméterrel!  A beállítás
	    kezdeményezésének
	    várakoztatási idejét a
	    következõ paraméterrel tudjuk
	    megadni:</para>

	  <programlisting>set stopped <replaceable>N</replaceable></programlisting>

	  <para>Használhatjuk viszont ezt a parancsot is (ahol
	    <replaceable>N</replaceable> adja meg, hogy mennyi
	    másodperc teljen el a beállítás
	    megkezdése elõtt):</para>

	  <programlisting>set openmode active <replaceable>N</replaceable></programlisting>

	  <para>Az ezzel kapcsolatos további részleteket a
	    man oldalon olvashatjuk.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ppp-shell-test-lockup">
	  <para>Miért akad meg a &man.ppp.8;, ha egy
	    külsõ parancsot adunk ki alatta?</para>
	</question>

	<answer>
	  <para>A <command>shell</command> vagy <command>!</command>
	    parancsok végrehajtásakor a &man.ppp.8;
	    elindít egy parancsértelmezõt (illetve ha
	    paramétereket is adtunk meg, akkor a &man.ppp.8;
	    átadja azokat is), majd megvárja annak
	    befejezõdését.  Ha a parancs
	    futtatása közben éppen egy PPP
	    kapcsolatot akartunk használni, akkor erre az
	    idõre az elõbbiek miatt látszólag
	    meg fog állni.  Ez tehát azért
	    történik, mert a &man.ppp.8; megvárja a
	    parancs lefutását.</para>

	  <para>Ha nem akarjuk megvárni a parancs
	    befejezõdését, akkor inkább
	    használjuk a <command>!bg</command> parancsot.  Ennek
	    hatására az adott parancs a
	    háttérben fog lefutni és a &man.ppp.8;
	    képes lesz folyamatosan szemmel tartani az
	    összeköttetést.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ppp-null-modem">
	  <para>A &man.ppp.8; null-modem kábel
	    használatakor miért nem lép ki
	    soha?</para>
	</question>

	<answer>
	  <para>A &man.ppp.8; ilyen esetekben nem képes
	    magától megállapítani, hogy mikor
	    bontották a vonalat.  Ennek oka a tûk null-modem
	    kábelben kiosztott szerepében keresendõ.
	    Amikor ilyen típusú kapcsolattal dolgozunk, a
	    következõ sor megadásával ne
	    felejtsük el engedélyezni az LQR
	    használatát:</para>

	  <programlisting>enable lqr</programlisting>

	  <para>Ha a távoli pont LQR csomagokat küld, akkor
	    a &man.ppp.8; alapértelmezés szerint fogadja
	    azokat.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ppp-auto-noreasondial">
	  <para>A &man.ppp.8; miért tárcsáz
	    látszólag minden különösebb ok
	    nélkül <option>-auto</option>
	    módban?</para>
	</question>

	<answer>
	  <para>Amennyiben a &man.ppp.8; szándékainkkal
	    szemben váratlanul kezdene el tárcsázni,
	    akkor keressük meg kiváltó okát
	    és használjunk hívási
	    szûrést (Dial filter, dfilter) ennek
	    megelõzésére.</para>

	  <para>A tárcsázás okát a
	    következõ sor használatával tudjuk
	    kideríteni:</para>

	  <programlisting>set log +tcp/ip</programlisting>

	  <para>Ennek hatására a kapcsolaton
	    keresztüláramló összes forgalmat
	    naplózni fogjuk.  Így a legközelebb,
	    amikor a vonal hirtelen aktív lesz, a
	    hozzá tartozó idõbélyegek
	    alapján könnyen elõ tudjuk keresni, hogy
	    pontosan miért is történt.</para>

	  <para>Az automatikus tárcsázást bizonyos
	    esetekben le tudjuk tiltani.  Ez általában egy
	    olyan probléma, amely a névfeloldások
	    miatt keletkezik.  Úgy tudjuk megakadályozni,
	    hogy a névfeloldások
	    felépítsék a kapcsolatot (ami viszont
	    <emphasis>nem</emphasis> gátolja abban a &man.ppp.8;
	    programot, hogy egy már meglevõ kapcsolaton
	    keresztül küldjön ilyen csomagokat), ha az
	    alábbi beállításokat adjuk
	    meg:</para>

	  <programlisting>set dfilter 1 deny udp src eq 53
set dfilter 2 deny udp dst eq 53
set dfilter 3 permit 0/0 0/0</programlisting>

	  <para>Ezek az értékek nem minden esetben
	    megfelelõek számunkra, hiszen ezzel együtt az
	    igény szerinti tárcsázás
	    kényelmét is szûkítjük, mivel
	    a legtöbb program közvetlenül
	    névfeloldással kezd, mielõtt komolyabb
	    hálózati forgalmat bonyolítana
	    le.</para>

	  <para>A névfeloldás esetében
	    igyekezzünk kideríteni, hogy pontosan melyik
	    program is próbál hálózati
	    neveket feloldatni.  Az esetek
	    többségében
	    valószínûleg a &man.sendmail.8; lesz a
	    bûnös.  Amennyiben ez a helyzet, akkor az
	    <application>sendmail</application> démonnak a
	    saját konfigurációs
	    állományában kell
	    beállítanunk, hogy ne oldasson fel
	    hálózati neveket.  Az érintett
	    konfigurációs állomány
	    módosításának pontos
	    részleteirõl a kézikönyv <link xlink:href="&url.books.handbook;/smtp-dialup.html">Levelezés
	      betárcsázós kapcsolattal</link>
	    címû szakszában olvashatunk
	    bõvebben.  Továbbá az
	    <filename>.mc</filename> állományunkba a
	    következõ sort is érdemes
	    felvennünk:</para>

	  <programlisting>define(`confDELIVERY_MODE', `d')dnl</programlisting>

	  <para>Ezzel a <application>sendmail</application>
	    beindításáig mindent egy sorban fog
	    eltárolni (általában a
	    <application>sendmail</application> démont a
	    <option>-bd -q30m</option> paraméterekkel
	    szokták meghívni, ami arra utasítja,
	    hogy 30&nbsp;percenként dolgozza fel a sorát)
	    vagy amíg a <command>sendmail
	    -q</command> parancs le nem fut
	    (például a <filename>ppp.linkup</filename>
	    állományból).</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ccp-errors">
	  <para>Mit jelentenek a CCP hibák?</para>
	</question>

	<answer>
	  <para>A naplóban folyamatosan a következõ
	    üzeneteket lehet látni:</para>

	  <programlisting>CCP: CcpSendConfigReq
CCP: Received Terminate Ack (1) state = Req-Sent (6)</programlisting>

	  <para>Ilyenek azért keletkeznek, mert a &man.ppp.8; a
	    <literal>Predictor1</literal>
	    tömörítési eljárást
	    próbálja meg beállítani, azonban
	    a távoli pont egyáltalán semmilyen
	    tömörítést nem akar
	    használni.  Az ilyen üzenetek többnyire
	    ártalmatlanok, de ha el akarjuk tüntetni ezeket,
	    akkor próbáljuk meg a következõ
	    módon kikapcsolni a <literal>Predictor1</literal>
	    tömörítés
	    használatát:</para>

	  <programlisting>disable pred1</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ppp-connectionspeed">
	  <para>A &man.ppp.8; miért nem naplózza a
	    kapcsolat sebességét?</para>
	</question>

	<answer>
	  <para>A modemmel végzett teljes
	    <quote>beszélgetés</quote>
	    szövegének
	    rögzítéséhez a
	    következõket kell engedélyezni:</para>

	  <programlisting>set log +connect</programlisting>

	  <para>Ennek eredményeképpen a &man.ppp.8;
	    egészen az utolsóként lekért
	    karakterláncig naplóz mindent.</para>

	  <para>Ha PAP vagy CHAP hitelesítést
	    használunk (ezért a <literal>CONNECT</literal>
	    parancs kiadása után már nincs semmi
	    <quote>mondanivalónk</quote> a
	    hívószkriptben, tehát nincs
	    <literal>set login</literal> szkript), és
	    szeretnénk látni a csatlakozási
	    sebességet, ne felejtsük el utasítani a
	    &man.ppp.8; programot, hogy a teljes
	    <literal>CONNECT</literal> sort kérje le, valahogy
	    így:</para>

	  <programlisting>set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 4 \
  \"\" ATZ OK-ATZ-OK ATDT\\T TIMEOUT 60 CONNECT \\c \\n"</programlisting>

	  <para>Itt most megkapjuk a <literal>CONNECT</literal> sort,
	    ezután nem küldünk semmit, majd
	    várunk egy soremelést, aminek
	    hatására a &man.ppp.8; arra
	    kényszerül, hogy a teljes
	    <literal>CONNECT</literal> választ beolvassa.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ppp-ignores-backslash">
	  <para>A &man.ppp.8; miért hagyja figyelmen
	    kívül a <literal>\</literal> karaktereket a
	    szkriptekben?</para>
	</question><answer>

	  <para>A <application>ppp</application> a
	    konfigurációs állományokból
	    minden sort külön beolvas, ezért a
	    <literal>set phone "123 456 789"</literal> és
	    hozzá hasonló karakterláncok
	    esetén képes felismerni, hogy a megadott
	    számok valójában
	    <emphasis>egyetlen</emphasis> paramétert
	    formáznak.  A <literal>&quot;</literal>
	    megadásához a visszaper karaktert
	    (<literal>\</literal>) kell használnunk.</para>

	  <para>Amikor tárcsázásért
	    felelõs értelmezõ beolvassa az egyes
	    paramétereket, újraértelmezi ezeket
	    olyan speciális helyettesítési
	    szekvenciák után kutatva, mint
	    például a <literal>\P</literal> vagy
	    <literal>\T</literal> (részletesebben lásd a
	    man oldalon).  A kettõs elemzés miatt
	    nekünk is a megfelelõ számban kell
	    megadnunk ezeket a helyettesítendõ
	    karaktereket.</para>

	  <para>Ha tehát egy <literal>\</literal> karaktert
	    szeretnénk átküldeni a modemünknek,
	    akkor nagyjából valami ilyesmit kellene
	    írnunk:</para>

	  <programlisting>set dial "\"\" ATZ OK-ATZ-OK AT\\\\X OK"</programlisting>

	  <para>Ennek az eredménye a következõ
	    lesz:</para>

	  <programlisting>ATZ
OK
AT\X
OK</programlisting>

	  <para>Vagy:</para>

	  <programlisting>set phone 1234567
set dial "\"\" ATZ OK ATDT\\T"</programlisting>

	  <para>Ez pedig a következõ szekvenciát
	    adja:</para>

	  <programlisting>ATZ
OK
ATDT1234567</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ppp-segfault-nocore">
	  <para>A &man.ppp.8; miért küld
	    <errorname>Segmentation Fault</errorname> hibát,
	    miközben nem is keletkezik
	    <filename>ppp.core</filename> állomány?</para>
	</question>

	<answer>
	  <para>A <application>ppp</application> (vagy más
	    hasonló program) elméletileg soha nem hoz
	    létre <filename>.core</filename>
	    állományt.  Mivel a &man.ppp.8;
	    tulajdonképpen a nullás
	    felhasználói azonosítóval fut,
	    az operációs rendszer soha nem fogja a
	    &man.ppp.8; memórialenyomatát
	    leállítása elõtt a lemezre
	    menteni.  Ha viszont &man.ppp.8; mûködése
	    valóban leáll egy szegmentációs
	    hiba vagy bármilyen más
	    <filename>.core</filename> állományt
	    eredményezõ jelzés miatt,
	    <emphasis>és</emphasis> valóban a legfrissebb
	    változatát használjuk (lásd a
	    fejezet elejét), akkor a következõt
	    tehetjük:</para>

	  <screen>&prompt.root; <userinput>cd /usr/src/usr.sbin/ppp</userinput>
&prompt.root; <userinput>echo STRIP= &gt;&gt; /etc/make.conf</userinput>
&prompt.root; <userinput>echo CFLAGS+=-g &gt;&gt; /etc/make.conf</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

	  <para>A fenti parancsokkal telepíteni tudjuk a
	    &man.ppp.8; egy nyomonkövethetõ
	    változatát.  A &man.ppp.8;
	    futtatásához <systemitem class="username">root</systemitem>
	    felhasználónak kell lennünk, mivel minden
	    korábbi engedélyét
	    felülírtuk az elõbbiek során.  A
	    &man.ppp.8; indításakor ne felejtsük el
	    megjegyezni pontosan az aktuális
	    könyvtárat sem.</para>

	  <para>Innentõl kezdve, amikor a &man.ppp.8; kap egy
	    szegmentációs hibára vonatkozó
	    jelzést, létre fog hozni egy
	    <filename>ppp.core</filename> nevû
	    állományt.  Ennek birtokában a
	    következõt kell csinálnunk:</para>

	  <screen>&prompt.user; <userinput>su</userinput>
&prompt.root; <userinput>gdb /usr/sbin/ppp ppp.core</userinput>
<prompt>(gdb)</prompt> <userinput>bt</userinput>
.....
<prompt>(gdb)</prompt> <userinput>f 0</userinput>
....
<prompt>(gdb)</prompt> <userinput>i args</userinput>
....
<prompt>(gdb)</prompt> <userinput>l</userinput>
.....</screen>

	  <para>Az így beszerzett információkat
	    mellékelve nagyobb
	    valószínûséggel kaphatunk
	    választ az ezzel kapcsolatos
	    kérdésünkre.</para>

	  <para>Ha járatosak vagyunk a &man.gdb.1;
	    használatában, akkor a
	    <filename>.core</filename> állományban
	    további részletek és
	    információk utáni is kutathatunk,
	    például mi okozta a hibát, milyen
	    változóknak ekkor milyen értékei
	    voltak stb.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ppp-autodialprocess-noconnect">
	  <para>Miért nem csatlakozik soha az a program, amely a
	    hívást kezdeményezte
	    <option>-auto</option> módban?</para>
	</question>

	<answer>
	  <para>Ez korábban egy ismert probléma volt a
	    &man.ppp.8; használatával kapcsolatban, amikor
	    dinamikus helyi IP-címet akart
	    beállítani <option>-auto</option>
	    módban.  Ez a hiba az újabb
	    változatokban már nem nincs meg (a man oldalon
	    keressünk rá az <literal>iface</literal>
	    részre).</para>

	  <para>A gondot az okozta, hogy amikor a
	    tárcsázást elindító
	    program meghívja a &man.connect.2;
	    rendszerhívást, akkor a &man.tun.4;
	    interfészhez tartozó IP-cím a
	    végpontot képviselõ sockethez
	    társul.  A rendszermag létrehozza az elsõ
	    kimenõ csomagot és kiírja a &man.tun.4;
	    eszközre.  A &man.ppp.8; ekkor beolvassa a csomagot
	    és felépíti a kapcsolatot.  Ha a
	    &man.ppp.8; dinamikus IP-cím
	    kiosztásának eredményeképpen
	    ilyenkor az interfész címe megváltozik,
	    akkor azzal egyidõben az eredeti socket végpont
	    érvénytelenné válik.  Így
	    a távoli végpont felé küldött
	    további csomagok általában
	    eldobódnak.  Ha valahogy mégis
	    eljutnának a céljukhoz, a válasz
	    már semmiképpen sem érkezhet meg, mivel
	    a küldéshez használt IP-címnek
	    már nem az adott gép a tulajdonosa.</para>

	  <para>Számos elméleti
	    megközelítés létezik az
	    imént felvázolt probléma
	    megoldására.  A legszebb az lenne, ha a
	    távoli pont lehetõség szerint a
	    korábban használt IP-címet
	    osztaná ki újra.  A &man.ppp.8; jelenlegi
	    változata pontosan ugyanezt teszi, viszont a
	    legtöbbi implementáció már
	    nem.</para>

	  <para>Részünkrõl az bizonyulna a
	    legegyszerûbb megoldásnak, ha a &man.tun.4;
	    intefész IP-címe egyáltalán nem
	    változhatna meg, hanem helyette menet közben az
	    összes kimenõ csomag, köztük
	    természetesen a forrás IP-címe az
	    interfész IP-címérõl az
	    idõközben beállított IP-címre
	    változna.  Ez lényegében az, amit a
	    &man.ppp.8; legújabb változataiban
	    felbukkanó <literal>iface-alias</literal>
	    opció is csinál (a &man.libalias.3; és
	    a &man.ppp.8; <option>-nat</option> kapcsolója
	    segítségével): karbantartja az
	    összes korábban használt interfész
	    címét és átfordítja
	    ezeket az utoljára beállított
	    címre.</para>

	  <para>A másik (és
	    valószínûleg a sokkal
	    megbízhatóbb) lehetõség egy olyan
	    rendszerhívás implementálása
	    lenne, amely képes az összes használatban
	    levõ socketet egyik IP-címrõl a
	    másik IP-címre
	    átállítani.  A &man.ppp.8; ekkor fel
	    tudná használni ezt arra, hogy
	    módosítsa az összes addig futó
	    program socketjét az új IP-cím
	    beállításakor.  Ugyanezzel a
	    rendszerhívással a <acronym>DHCP</acronym>
	    kliensek is képesek lennének
	    átállítani a socketjeiket.</para>

	  <para>Lehetõségünk van még
	    IP-cím nélkül is létrehozni
	    interfészeket.  A kimenõ csomagok ekkor a
	    <systemitem class="ipaddress">255.255.255.255</systemitem>
	    IP-címet használnák egészen
	    addig, amíg az elsõ
	    <literal>SIOCAIFADDR</literal> &man.ioctl.2;
	    rendszerhívás le nem zajlik.  A &man.ppp.8;
	    feladata ilyenkor a forrás IP-cím
	    megváltoztatása, de ha ez <systemitem class="ipaddress">255.255.255.255</systemitem>, akkor egyedül
	    csak az IP-címnek és az
	    ellenõrzõösszegnek kell megváltoznia.
	    Ez viszont már valamilyen mértékben
	    trükközést a rendszermagon belül,
	    mivel így könnyen tudunk csomagokat küldeni
	    egy rosszul beállított interfészre is,
	    feltételezve, hogy valamilyen módon
	    képesek vagyunk ilyeneket visszamenõleg
	    helyreállítani.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ppp-nat-games">
	  <para>A legtöbb játék miért nem
	    mûködik a <option>-nat</option> kapcsoló
	    megadásával?</para>
	</question>

	<answer>
	  <para>A játékok és a hozzájuk
	    hasonló alkalmazások általában
	    azért nem mûködnek, amikor a
	    &man.libalias.3; könyvtárat használjuk,
	    mert a távoli gép megpróbál
	    kapcsolódni a belsõ hálózatunkon
	    levõ géphez és kéretlen UDP
	    csomagokat kezd el küldeni neki.  A
	    címfordítást végzõ
	    programnak fogalma sincs róla, hogy ezeket a
	    csomagokat egy belsõ gépnek kell
	    továbbküldenie.</para>

	  <para>Akkor lehetünk biztosak ebben, ha egyedül csak
	    azt a szoftvert indítjuk el, amellyel gondjaink
	    akadtak, majd a vagy az átjáró
	    &man.tun.4; interfészét kezdjük el a
	    &man.tcpdump.1; segítségével, vagy
	    pedig engedélyezzük az
	    átjárón a &man.ppp.8; TCP/IP
	    naplózó funkcióját (<literal>set
	    log +tcp/ip</literal>).</para>

	  <para>Ahogy elindítjuk a gondokat okozó
	    programot, látnunk kell a csomagjait, ahogy
	    megpróbálnak keresztüljutni az
	    átjárón.  Az erre érkezõ
	    válaszolok eldobódnak (ez jelenti a
	    problémát).  Jegyezzük fel a csomagokhoz
	    társuló portszámokat és
	    állítsuk el a programot.  Csináljuk meg
	    néhányszor ezt a vizsgálatot,
	    így ellenõrizni tudjuk, hogy mindig ugyanazokat
	    a portokat használja-e.  Amennyiben úgy
	    tapasztaljuk, hogy igen, akkor az
	    <filename>/etc/ppp/ppp.conf</filename>
	    állományba a következõ sort kell
	    betenni a megfelelõ helyre a mûködés
	    helyreállításához:</para>

	  <programlisting>nat port <replaceable>protokoll</replaceable> <replaceable>belsõ-gép</replaceable>:<replaceable>port</replaceable> <replaceable>port</replaceable></programlisting>

	  <para>ahol a <replaceable>protokoll</replaceable> lehet
	    <literal>tcp</literal> vagy <literal>udp</literal>, a
	    <replaceable>belsõ-gép</replaceable> annak a
	    gépnek a címe, ahova tovább akarjuk
	    küldeni a csomagokat, valamint a
	    <replaceable>port</replaceable> a csomagok
	    célportját adja meg.</para>

	  <para>A fenti parancs megváltoztatása
	    nélkül nem tudjuk ugyanezt a szoftvert más
	    gépeken is használni, és itt azzal most
	    nem is foglalkozunk, hogy miként lehet két
	    belsõ géprõl használni ugyanazt a
	    programot.  Mindenesetre annyi biztos, hogy a
	    külvilág felé a belsõ
	    hálózatunk csupán egyetlen
	    gépnek fog látszani.</para>

	  <para>Ha azt látjuk, hogy az alkalmazás nem
	    mindig ugyanazt a portot használja, akkor három
	    választási lehetõségünk
	    van:</para>

	  <orderedlist>
	    <listitem>
	      <para>Készítsük el a
		támogatását a &man.libalias.3;
		függvénykönyvtárhoz.  A
		különbözõ
		<quote>szélsõséges esetekre</quote> a
		<filename>/usr/src/sys/netinet/libalias/alias_*.c</filename>
		állományokban találhatunk
		példákat (az
		<filename>alias_ftp.c</filename> tökéletes
		kiindulási alap).  Ez általában
		annyit jelent, hogy beolvasunk bizonyos ismert
		kimenõ csomagokat, beazonosítjuk benne azt
		az utasítást, amelynek
		hatására a külsõ gép
		csatlakozni próbál a belsõ
		géphez egy adott (véletlenszerûen
		választott) porton, majd beállítunk
		hozzá egy <quote>útvonalat</quote>,
		így a rákövetkezõ csomagok
		már tudni fogják, hogy merre
		menjenek.</para>

	      <para>Ez ugyan a legnehezebb megoldás, de egyben ez
		is a legjobb, ráadásul így a szoftver
		több gépen is
		mûködtethetõ.</para>
	    </listitem>

	    <listitem>
	      <para>Proxy használata.  Elõfordulhat, hogy az
		alkalmazás támogatja a
		<literal>socks5</literal> protokollt vagy (mint ahogy a
		<command>cvsup</command> is csinálja) rendelkezik
		<quote>passzív</quote> móddal, és
		így lehetõleg igyekszik elkerülni azt,
		hogy a távoli géprõl kapcsolatot
		próbáljanak meg indítani a helyi
		gépre.</para>
	    </listitem>

	    <listitem>
	      <para>A <literal>nat addr</literal>
		használatával irányítsunk
		át mindent a belsõ gépre.  Ez viszont
		egy nagyon durva megközelítés.</para>
	    </listitem>
	  </orderedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="useful-port-numbers">
	  <para>Valaki összeírta már a hasznosabb
	    portok sorszámait?</para>
	</question>

	<answer>
	  <para>Egyelõre még nem, de
	  szándékunkban áll
	    összeállítani egy ilyen listát
	    (már amennyiben igény lesz rá).  Minden
	    itt szereplõ példában az
	    <replaceable>belsõ</replaceable> helyett mindig annak a
	    gépnek a belsõ IP-címét
	    írjuk, amelyrõl játszani akarunk.</para>

	  <itemizedlist>
	    <listitem>
	      <para><application>Asheron's Call</application></para>

	      <para><literal>nat port udp
		belsõ :65000
		65000</literal></para>

	      <para>Manuálisan változtassuk meg a
		játékon belül a portszámot
		<literal>65000</literal>-re.  Ha a belsõ
		hálózatunkról több
		gépen is szeretnénk játszni, akkor
		mindegyiknek adjuk meg egy egyedi portot (vagyis
		<literal>65001</literal>, <literal>65002</literal>
		stb.), majd vegyünk fel mindegyikhez egy-egy
		<literal>nat port</literal> sort.</para>
	    </listitem>

	    <listitem>
	      <para><application>Half Life</application></para>

	      <para><literal>nat port udp
		belsõ:27005
		27015</literal></para>
	    </listitem>

	    <listitem>
	      <para><application>PCAnywhere 8.0</application></para>

	      <para><literal>nat port udp
		belsõ:5632
		5632</literal></para>

	      <para><literal>nat port tcp
		belsõ:5631
		5631</literal></para>
	    </listitem>

	    <listitem>
	      <para><application>Quake</application></para>

	      <para><literal>nat port udp
		belsõ:6112
		6112</literal></para>
	    </listitem>

	    <listitem>
	      <para><application>Quake 2</application></para>

	      <para><literal>nat port udp
		belsõ:27901
		27910</literal></para>

	      <para><literal>nat port udp
		belsõ:60021
		60021</literal></para>

	      <para><literal>nat port udp
		belsõ:60040
		60040</literal></para>
	    </listitem>

	    <listitem>
	      <para><application>Red Alert</application></para>

	      <para><literal>nat port udp
		belsõ:8675
		8675</literal></para>

	      <para><literal>nat port udp
		belsõ:5009
		5009</literal></para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="fcs-errors">
	  <para>Mik azok az FCS hibák?</para>
	</question>

	<answer>
	  <para>Az FCS jelentése <literal>F</literal>rame
	    <literal>C</literal>heck <literal>S</literal>equence, vagyis
	    az <quote>Adatkeret ellenõrzésének
	    sorozata</quote>.  Mindegyik PPP csomaghoz tartozik egy
	    ellenõrzõösszeg, amely arról
	    gondoskodik, hogy ugyanaz az adat érkezzen meg, mint
	    amit elküldtek.  Amennyiben egy bejövõ csomag
	    FCS értéke érvénytelennek
	    minõsül, a csomag eldobódik és a
	    HDLC FCS számláló
	    értékkel eggyel növekszik.  A HDLC
	    hibaszámlálói a <literal>show
	    hdlc</literal> parancs segítségével
	    tekinthetõek meg.</para>

	  <para>Ha rosszul mûködik az
	    összeköttetés (vagy a soros vonali
	    meghajtónk folyamatosan eldobja a csomagokat), akkor
	    láthatunk helyenként FCS hibákat.
	    Többnyire nem érdemes az ilyenek miatt
	    aggódni, habár ez jelentõs
	    mértékben lassítja a
	    tömörítést végzõ
	    protokollok munkáját.  Ha külsõ
	    modemünk van, akkor ne felejtsük el a
	    megfelelõ módon leárnyékolni,
	    mivel ebbõl is származhat a
	    probléma.</para>

	  <para>Ha a vonal a kapcsolódást
	    követõen szinte azonnal lemerevedik és
	    hirtelen nagy mennyiségû FCS hiba jelentkezik,
	    akkor az arra is utalhat, hogy az
	    összeköttetés nem tisztán
	    8&nbsp;bites.  Gondoskodjunk róla, hogy a modem ne a
	    szoftveres forgalomirányítást
	    (XON/XOFF) használja.  Ha viszont az adatok
	    közvetítéséhez mégis
	    szoftveres forgalomirányítást
	    <emphasis>kell</emphasis> használnunk, akkor a
	    <literal>set accmap 0x000a0000</literal> parancs
	    kiadásával jelezzük a &man.ppp.8;
	    felé, hogy a <literal>^Q</literal> és
	    <literal>^S</literal> karaktereket
	    helyettesítse.</para>

	  <para>Nagy mennyiségû FCS hibát olyan
	    esetekben is tapasztalhatunk, amikor a távoli pont
	    abbahagyta a <acronym>PPP</acronym> üzenetek
	    küldését.  Ilyenkor javasolt
	    engedélyezni az aszinkron naplózás
	    használatát, aminek
	    segítségével gyorsan meg tudjuk
	    állapítani, hogy a beérkezõ adatok
	    bejelentkezõ vagy shell üzeneteket.  Ha a
	    másik oldalon egy shell parancssorát kapjuk
	    meg, akkor a &man.ppp.8; a <command>close lcp</command>
	    megadásával a vonal eldobása
	    nélkül leállítható (az
	    utána következõ <command>term</command>
	    paranccsal pedig a távoli gépen futó
	    shellre tudunk csatlakozni).</para>

	  <para>Ha a naplókban látszólag semmi sem
	    indokolja az összeköttetés
	    leállását, próbáljunk meg
	    erre rákérdezni a távoli pont
	    (talán a szolgáltató?)
	    karbantartójánál.</para>
	</answer>
      </qandaentry>

      <qandaentry xml:id="PPPoEwithNAT">
	<question xml:id="macos-win98-pppoe-freeze">
	  <para>A &macos; és &windows;&nbsp;98 alól
	    indított kapcsolatok miért állnak le, ha
	    PPPoE fut az átjárón?</para>
	</question>

	<answer>
	  <para>A probléma megoldását Michael
	    Wozniak (<email>mwozniak@netcom.ca</email>) adta meg, valamint
	    Dan Flemming (<email>danflemming@mac.com</email>) alkalmazta
	    ugyanezt Macre:</para>

	  <para>Ennek oka az ún.
	    útválasztási <quote>fekete lyuk</quote>.
	    A &macos; és a &windows;&nbsp;98 (de
	    valószínûleg az összes többi
	    &microsoft; operációs rendszer) olyan nagy
	    méretû TCP csomagokat küld, amelyek
	    már nem férnek bele egy PPPoE keretbe (amely
	    mérete Ethernet estén 1500&nbsp;byte
	    alapértelmezés szerint)
	    <emphasis>és</emphasis> beállítja
	    hozzá a darabolás letiltását
	    jelzõ (<quote>do not fragment</quote>) bitet (TCP
	    esetén ez alapértelmezett), és a Telco
	    útválasztó pedig nem küldi el a
	    <quote>must fragment</quote> (<quote>darabolni kell</quote>)
	    ICMP csomagot a letölteni kívánt oldal
	    szolgáltatója felé.  (Másik
	    lehetõség, hogy az
	    útválasztó ugyan küld egy ilyen
	    ICMP csomagot, de ezt a
	    tartalomszolgáltatónál
	    található tûzfal eldobja.) Amikor
	    válaszul a szolgáltató olyan kereteket
	    kezd el küldeni, amelyek nem illeszkednek a PPPoE
	    keresztmetszetébe, a Telco
	    útválasztó egyszerûen eldobja
	    ezeket és a lap nem pedig nem lesz
	    elérhetõ (egyes képek és oldalak
	    esetén elõfordul).  Úgy tûnik, ez az
	    alapbeállítás a legtöbb Telco
	    PPPoE konfiguráció esetében.</para>

	  <para>Ezt a hibát úgy javíthatjuk, ha a
	    &windows;&nbsp;95/98 rendszerekben megtalálható
	    <command>regedit</command> segítségével
	    felvesszük a következõ
	    regisztrációs bejegyzést:</para>

	  <programlisting>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\NetTrans\0000\MaxMTU</programlisting>

	  <para>A karakterlánc értéke legyen
	    <literal>1436</literal>, mivel bizonyos ADSL
	    útválasztók
	    állítólag nem képesek
	    ennél nagyobb méretû csomagokat kezelni.
	    &windows;&nbsp;2000 esetén ezt a
	    beállítást a
	    <literal>Tcpip\Parameters\Interfaces\a
	    hálózati kártya
	    azonosítója\MTU</literal> helyen kell keresni
	    és típusa duplaszó (DWORD).</para>

	  <para>A &windows; MTU beállításaival
	    kapcsolatban olvassuk el a Microsoft Knowledge Base
	    címén található dokumentumokat:
	    <link xlink:href="http://support.microsoft.com/support/kb/articles/Q158/4/74.asp">Q158474
	    - Windows TCPIP Registry Entries</link> és <link xlink:href="http://support.microsoft.com/support/kb/articles/Q120/6/42.asp">Q120642
	    - TCPIP &amp; NBT Configuration Parameters for &windowsnt;
	    </link>.</para>

	  <para>&windows;&nbsp;2000 alatt a regisztrációs
	    adatbázisban érdemes még a
	    <literal>Tcpip\Parameters\Interfaces\a
	    hálózati kártya
	    azonosítója\EnablePMTUBHDetect</literal>
	    duplaszó értékét
	    <literal>1</literal>-re állítani, ahogy arra
	    az imént említett 120642-es &microsoft;
	    dokumentum is hivatkozik.</para>

	  <para>Sajnos a &macos; nem nyújt semmilyen
	    beállítási lehetõséget a
	    TCP/IP beállítások
	    megváltoztatására.  Léteznek
	    viszont kereskedelmi termékek, amelyek
	    lehetõvé teszi a felhasználók
	    számára, hogy igényeik szerint
	    módosítsák rendszerük TCP/IP
	    beállításait.  A hálózati
	    címfordítást használók
	    keressék meg az MTU
	    beállításaikat és adják
	    meg az <literal>1450</literal> értéket az
	    eredeti <literal>1500</literal> helyett.</para>

	  <para>A &man.ppp.8; újabb (2.3 vagy afeletti)
	    változatai már tartalmaznak egy
	    <command>enable tcpmssfixup</command> parancsot, amellyel az
	    MSS értéke tetszõlegesen
	    átállítható.  Ez
	    alapértelmezés szerint engedélyezett.
	    Ha valamiért mégis a &man.ppp.8; egy
	    korábbi változatával kellene
	    dolgoznunk, akkor érdemes megnéznünk
	    <package>net/tcpmssd</package>
	    portot.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="desperation">
	  <para>Ezek közül egyik sem használt &mdash;
	    segítség!  Mit lehetne még
	    tenni?</para>
	</question>

	<answer>
	  <para>Ha eddig minden más csõdött mondott,
	    akkor próbáljuk meg elküldeni az
	    összes beszerezhetõ információt,
	    beleértve a konfigurációs
	    állományokat, hogyan indítjuk el a
	    &man.ppp.8; programot, a naplók fontosabb
	    részeit és a <command>netstat -rn</command>
	    parancs kimenetét (a csatlakozás elõtt
	    és után) a &a.questions; címére
	    vagy a <link xlink:href="news:comp.unix.bsd.freebsd.misc">comp.unix.bsd.freebsd.misc</link>
	    hírcsoportba, és valaki talán majd
	    megmutatja a helyes irányt.</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter xml:id="serial" xml:lang="hu">
    <title>Soros vonali kommunikáció</title>

    <para>Ebben a szakaszban a &os; alatti soros vonali
      kommunikációval kapcsolatos kérdéseket
      tárgyaljuk.  A PPP és SLIP
      használatáról a <link linkend="networking">Hálózatok</link>
      címû részben esik szó.</para>

    <qandaset>
      <qandaentry>
	<question xml:id="found-serial">
	  <para>Honnan deríthetõ ki, hogy a &os; felismerte
	    a soros portokat a gépben?</para>
	</question>

	<answer>
	  <para>Ahogy a &os; rendszermagja az elindulása
	    után azokat a soros portokat fogja keresni, amelyeket a
	    konfigurációs állományban
	    beállítottunk.  Figyeljük a rendszer
	    indulása közben megjelenõ üzeneteket
	    vagy adjuk ki a következõ parancsot a rendszer
	    indulásának befejeztével:</para>

	  <screen>&prompt.user; <userinput>dmesg | grep -E "^sio[0-9]"</userinput></screen>

	  <para>Íme egy példa az iménti parancs
	    kimenetére:</para>

	  <programlisting>sio0: &lt;16550A-compatible COM port&gt; port 0x3f8-0x3ff irq 4 flags 0x10 on acpi0
sio0: type 16550A
sio1: &lt;16550A-compatible COM port&gt; port 0x2f8-0x2ff irq 3 on acpi0
sio1: type 16550A</programlisting>

	  <para>Ezen két soros portot láthatunk.  Az
	    elsõ a negyedik megszakítást és a
	    <literal>0x3f8</literal> címet használja
	    és egy 16550A típusú UART chip.  A
	    második ugyanolyan chip, de a harmadik
	    megszakítást és a
	    <literal>0x2f8</literal> címet használja.  A
	    belsõ modemeket a rendszer úgy kezeli, mintha
	    soros portok lennének, azzal a kivétellel,
	    hogy a modem mindig <quote>kapcsolódik</quote> az
	    adott porthoz.</para>

	  <para>A <filename>GENERIC</filename> rendszermag
	    alapértelmezés szerint két soros portot
	    támogat, a példában szereplõ
	    megszakítási- és
	    memóriaértékek
	    felhasználásával.  Ha ezek a
	    beállítások nem felelnek meg a
	    rendszerünk számára, esetleg modemet
	    raktunk a gépünkbe vagy a rendszermagban
	    több soros portot is támogatni
	    szeretnénk, akkor nincs más teendõnk,
	    mint ennek megfelelõen megváltoztatni a
	    rendszermag paramétereit.  A <link linkend="make-kernel">rendszermag fordításáról szóló</link>
	    rész tárgyalja ennek részleteit.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="found-modem">
	  <para>Honnan deríthetõ ki, hogy a &os; felismerte
	    a modemkártyát a gépben?</para>
	</question>

	<answer>
	  <para>Olvassuk el az elõzõ kérdésre
	    adott választ.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="access-serial-ports">
	  <para>Hogyan lehet a soros portokat elérni &os;
	    alatt?</para>
	</question>

	<answer>
	  <para>A harmadik soros port, a <filename>sio2</filename>
	    (lásd &man.sio.4;, DOS alatt
	    <filename>COM3</filename>) a
	    <filename>/dev/cuad2</filename> eszközön
	    keresztül érhetõ el
	    tárcsázó eszközként,
	    és a <filename>/dev/ttyd2</filename>
	    eszközön keresztül behívó
	    eszközként.  Mi a különbség a
	    két eszközosztály
	    között?</para>

	  <para>A
	    <filename>ttydX</filename>
	    eszközöket behívásra
	    használjuk.  Amikor tehát a
	    <filename>/dev/ttydX</filename>
	    eszközt blokkoló módban nyitjuk meg,
	    akkor a hívó program egészen addig
	    várni fog, amíg a megfelelõ
	    <filename>cuadX</filename>
	    eszköz inaktívvá nem válik, majd
	    kivárja, hogy megérkezzen a
	    hívás fogadását
	    tolmácsoló jelzés.  Amikor megnyitjuk a
	    <filename>cuadX</filename>
	    eszközt, gondoskodik róla, hogy a soros portot
	    ekkor ne használja a
	    <filename>ttydX</filename>
	    eszköz.  Ha a port szabaddá válik,
	    egyszerûen <quote>ellopja</quote> a
	    <filename>ttydX</filename>
	    eszköztõl.  Sõt, a
	    <filename>cuadX</filename>
	    eszközt egyáltalán nem érdekli a
	    hívás fogadása jelzés.  Ezzel a
	    megoldással és egy automata modem
	    segítségével a távoli
	    felhasználók bármikor be tudnak
	    jelentkezni a rendszerünkbe, hogy közben
	    ugyanezzel a modemmel továbbra is tudunk
	    tárcsázni, mivel a rendszer elintézi a
	    többit.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="enable-multiport-serial">
	  <para>Hogyan lehet engedélyezi a többportos soros
	    vonali kártyák
	    támogatását?</para>
	</question>

	<answer>
	  <para>Ismét megemlítjük, hogy a rendszermag
	    beállításával foglalkozó
	    részben olvashatunk bõvebben a rendszermag
	    paraméterezésének
	    mikéntjérõl.  A többportos soros
	    vonali kártyák esetén a
	    kártyán található mindegyik
	    soros porthoz vegyünk fel egy-egy &man.sio.4;
	    bejegyzést a &man.device.hints.5;
	    állományába.  Az IRQ és vektor
	    értékeket azonban csak az egyiknél
	    adjuk meg, mivel a kártyán
	    található összes port egyetlen
	    megszakításon fog osztozni.  A
	    következetesség kedvéért az
	    utolsó porthoz adjuk meg a
	    megszakítást.  Ne felejtsük el még
	    megadni a rendszermag konfigurációs
	    állományában az alábbi
	    opciót sem:</para>

	  <programlisting>options COM_MULTIPORT</programlisting>

	  <para>Az alábbi <filename>/boot/device.hints</filename>
	    egy AST típusú négyportos soros vonali
	    kártyát láthatunk a tizenkettedik
	    megszakításon:</para>

	  <programlisting>hint.sio.4.at="isa"
hint.sio.4.port="0x2a0"
hint.sio.4.flags="0x701"
hint.sio.5.at="isa"
hint.sio.5.port="0x2a8"
hint.sio.5.flags="0x701"
hint.sio.6.at="isa"
hint.sio.6.port="0x2b0"
hint.sio.6.flags="0x701"
hint.sio.7.at="isa"
hint.sio.7.port="0x2b8"
hint.sio.7.flags="0x701"
hint.sio.7.irq="12"</programlisting>

	  <para>A <literal>flags</literal> paraméterrel megadott
	    értékek azt jelzik, hogy a fõport
	    <literal>7</literal> alszámmal rendelkezik
	    (<literal>0x700</literal>), valamint az összes port
	    ugyanazon a megszakításon osztozik
	    (<literal>0x001</literal>).</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="multiport-serial-share-irq">
	  <para>A &os; képes több többportos soros
	    vonali kártyát ugyanazon a
	    megszakításon keresztül
	    használni?</para>
	</question>

	<answer>
	  <para>Sajnos még nem.  Minden kártyához
	    másik megszakítást kell megadni.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="default-serial-params">
	  <para>Hogyan lehet beállítani a portok
	    alapértelmezett paramétereit?</para>
	</question>

	<answer>
	  <para>Ezzel kapcsolatban olvassuk el a &os;
	    kézikönyv <link xlink:href="&url.books.handbook;/serial.html#SERIAL-HW-CONFIG">soros kommunikációt</link>
	    tárgyaló részét.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="enable-dialup">
	  <para>Hogyan lehet a modemen betárcsázást
	    beállítani?</para>
	</question>

	<answer>
	  <para>Erre vonatkozóan olvassuk el a &os;
	    kézikönyv <link xlink:href="&url.books.handbook;/dialup.html">betárcsázós szolgáltatásokkal</link>
	    kapcsolatos részét.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="dumb-terminal">
	  <para>Hogyan lehet <quote>buta</quote> terminálokat
	    &os;-re csatlakoztatni?</para>
	</question>

	<answer>
	  <para>Az ezzel kapcsolatos információkat a &os;
	    kézikönyv <link xlink:href="&url.books.handbook;/term.html">terminálokról</link>
	    szóló részében
	    találhatjuk meg.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="cannot-tip">
	  <para>Miért nem indul el a <command>tip</command> vagy
	    <command>cu</command> parancs?</para>
	</question>

	<answer>
	  <para>Elõfordulhat, hogy rendszerünkön a
	    &man.tip.1; és &man.cu.1; programok csak az
	    <systemitem class="username">uucp</systemitem> felhasználón
	    és a <systemitem class="groupname">dialer</systemitem> csoporton
	    keresztül tudnak hozzáférni a
	    mûködésükhöz
	    szükséges <filename>/var/spool/lock</filename>
	    könyvtárhoz.  A <systemitem class="groupname">dialer</systemitem>
	    csoport segítségével lehet
	    szabályozni, hogy ki férhessen hozzá a
	    modemekhez vagy a távoli rendszerekhez.  Ilyenkor
	    egyszerûen csak vegyük fel magunkat a
	    <systemitem class="groupname">dialer</systemitem> csoportba.</para>

	  <para>A következõ parancs kiadásával
	    viszont ettõl függetlenül is
	    engedélyezhetjük a rendszerünkön
	    belül, hogy bárki használhassa a
	    &man.tip.1; vagy &man.cu.1; parancsokat:</para>

	  <screen>&prompt.root; <userinput>chmod 4511 /usr/bin/cu</userinput>
&prompt.root; <userinput>chmod 4511 /usr/bin/tip</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="hayes-unsupported">
	  <para>A rendszerhez csatlakozó Hayes
	    szabványú modem támogatott &mdash; mi
	    ilyenkor teendõ?</para>
	</question>

	<answer>
	  <para>A &os; kézikönyvben lásd <link xlink:href="&url.books.handbook;/dialout.html#HAYES-UNSUPPORTED">ezt</link>
	    a választ.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="direct-at">
	  <para>Hogyan adjuk meg az AT parancsokat?</para>
	</question>

	<answer>
	  <para>A &os; kézikönyvben lásd <link xlink:href="&url.books.handbook;/dialout.html#DIRECT-AT">ezt</link>
	    a választ.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="gt-failure">
	  <para>A <literal>pn</literal> tulajdonságnál
	    miért nem lehet <literal>@</literal> jelet
	    megadni?</para>
	</question>

	<answer>
	  <para>A &os; kézikönyvben lásd <link xlink:href="&url.books.handbook;/dialout.html#GT-FAILURE">ezt</link>
	    a választ.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="dial-command-line">
	  <para>Hogyan lehet telefonszámokat
	    tárcsázni parancssorból?</para>
	</question>

	<answer>
	  <para>A &os; kézikönyvben lásd <link xlink:href="&url.books.handbook;/dialout.html#DIAL-COMMAND-LINE">ezt</link>
	    a választ.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="set-bps">
	  <para>Minden alkalommal meg kell adni az adatátviteli
	    sebességet?</para>
	</question>

	<answer>
	  <para>A &os; kézikönyvben lásd <link xlink:href="&url.books.handbook;/dialout.html#SET-BPS">ezt</link>
	    a választ.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="terminal-server">
	  <para>Terminálszerver segítségével
	    hogyan lehet könnyen elérni egyszerre több
	    gépet is?</para>
	</question>

	<answer>
	  <para>A &os; kézikönyvben lásd <link xlink:href="&url.books.handbook;/dialout.html#TERMINAL-SERVER">ezt</link>
	    a választ.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="tip-multiline">
	  <para>A &man.tip.1; képes több vonalat is
	    használni az egyes gépek
	    eléréséhez?</para>
	</question>

	<answer>
	  <para>A &os; kézikönyvben lásd <link xlink:href="&url.books.handbook;/dialout.html#TIP-MULTILINE">ezt</link>
	    a választ.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="multi-controlp">
	  <para>Miért kell kétszer lenyomni a <keycombo action="simul"><keycap>Ctrl</keycap><keycap>P</keycap></keycombo>
	    billentyûket, hogy egyszer elküldjük
	    ezeket?</para>
	</question>

	<answer>
	  <para>A &os; kézikönyvben lásd <link xlink:href="&url.books.handbook;/dialout.html#MULTI-CONTROLP">ezt</link>
	    a választ.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="uppercase">
	  <para>Miért lett hirtelen minden NAGYBETûS?</para>
	</question>

	<answer>
	  <para>A &os; kézikönyvben lásd <link xlink:href="&url.books.handbook;/dialout.html#UPPERCASE">ezt</link>
	    a választ.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="tip-filetransfer">
	  <para>Hogyan lehet állományokat mozgatni a
	    <command>tip</command> használatával?</para>
	</question>

	<answer>
	  <para>A &os; kézikönyvben lásd <link xlink:href="&url.books.handbook;/dialout.html#TIP-FILETRANSFER">ezt</link>
	    a választ.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="zmodem-tip">
	  <para>Hogyan használható a zmodem protokoll a
	    <command>tip</command> programmal?</para>
	</question>

	<answer>
	  <para>A &os; kézikönyvben lásd <link xlink:href="&url.books.handbook;/dialout.html#ZMODEM-TIP">ezt</link>
	    a választ.</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter xml:id="misc" xml:lang="hu">
    <title>Egyéb kérdések</title>

    <qandaset>
      <qandaentry>
	<question xml:id="more-swap">
	  <para>A &os; miért használ sokkal több
	    lapozóállományt, mint a &linux;?</para>
	</question>

	<answer>
	  <para>A &os; csupán látszólag
	    használ több helyet a lapozásra, mint a
	    &linux;, valójában egyébként
	    nem.  A &os; és a &linux; közt az egyik
	    leglényegesebb különbség, hogy a
	    &os; valamivel elõre gondolkodik, és az
	    összes pillanatnyilag nem használt lapot
	    kilapozza a központi memóriából a
	    lapozóterületre.  Ezzel igyekszik minél
	    több memóriát
	    elõkészíteni az aktív
	    használatra.  A &linux; ezzel szemben a
	    lapozást csak végsõ esetben
	    használja.  Ennek megfelelõen a
	    lapozóterület gyakoribb
	    használatát remekül ellensúlyozza
	    a fizikai memória hatékonyabb
	    kihasználása.</para>

	  <para>Habár a &os; igyekszik ebben a tekintetben
	    elõrelátó lenni, nem minden esetben tudja
	    pontosan eldönteni, hogy a rendszerben mely lapokat nem
	    használják éppen.  Emiatt nem fogja az
	    összes memóriát kilapozni, ha
	    például egész éjszakára
	    futni hagyjuk a gépünket.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="top-freemem">
	  <para>A <command>top</command> miért jelez kevés
	    szabad memóriát, miközben csak
	    néhány program fut?</para>
	</question>

	<answer>
	  <para>Röviden úgy válaszolhatnánk
	    meg ezt a kérdést, hogy a szabad memória
	    igazából elvesztegetett memória.  A
	    programok által szabadon hagyott
	    memóriát a &os; rendszermagja többnyire a
	    lemez gyorsítótárazására
	    használja fel.  A &man.top.1; kimenetében
	    olvasható <literal>Inact</literal>,
	    <literal>Cache</literal> és <literal>Buf</literal>
	    értékek a lényegében
	    különbözõ öregedési szintek
	    szerint kategorizált tárazott adatok.  A
	    tárazás lényegében arra utal,
	    hogy a rendszernek így nem a lassú
	    elérésû lemezen kell a gyakran
	    elérni kívánt adatok után
	    kutatni, aminek köszönhetõen növekszik
	    az összteljesítmény.  A &man.top.1;
	    kimenetében tehát <literal>Free</literal>
	    kategória alacsony értéke
	    alapvetõen jót jelent, feltéve, ha nem
	    <emphasis>nagyon</emphasis> kevés.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="chmod-symlinks">
	  <para>A <command>chmod</command> miért nem
	    változtatja meg a szimbolikus linkek
	    engedélyeit?</para>
	</question>

	<answer>
	  <para>A szimbolikus linkekhez alapértelmezés
	    szerint nem tartoznak engedélyek, ezért a
	    &man.chmod.1; ilyen esetekben az eredeti
	    állomány engedélyeit változtatja
	    meg.  Ezért például, ha adott egy
	    <filename>ize</filename> nevû állomány,
	    valamint erre egy <filename>mize</filename> nevû
	    szimbolikus link, akkor a következõ parancs mindig
	    mûködni fog:</para>

	  <screen>&prompt.user; <userinput>chmod g-w mize</userinput></screen>

	  <para>Ennek ellenére az <filename>mize</filename>
	    engedélyei nem fognak megváltozni.</para>

	  <para>Ha egy adott könyvtárszerkezetben
	    elhelyezkedõ állományok engedélyeit
	    akarjuk egyszerre módosítani, akkor a
	    <option>-R</option> opció mellett a
	    <option>-H</option> vagy <option>-L</option> opciókat
	    is meg kell adnunk.  Errõl részletesebb
	    információkat a &man.chmod.1; és a
	    &man.symlink.7; man oldalairól tudhatunk meg.</para>

	    <warning>
	      <para>A &man.chmod.1; <option>-R</option> opciója
		<emphasis>rekurzív</emphasis>
		mûködést tesz lehetõvé.
		Óvatosan bánjunk a
		könyvtárakkal vagy a
		könyvtárakra mutató szimbolikus
		linkekkel a &man.chmod.1; használata
		során.  Ha egy szimbolikus link által
		hivatkozott könyvtár engedélyeit
		akarjuk megváltoztatni, akkor a &man.chmod.1;
		parancsnak ne adjunk meg semmilyen paramétert
		és a nevet zárjuk perjellel (<filename>/</filename>).
		Például, ha az <filename>ize</filename> a
		<filename>mize</filename>
		könyvtárra mutató szimbolikus link,
		és meg akarjuk változtatni az
		<filename>ize</filename> engedélyeit (ami
		valójában a <filename>mize</filename> engedélyeit
		jelenti), akkor valami ilyesmit kellene
		megadnunk:</para>

	      <screen>&prompt.user; <userinput>chmod 555 ize/</userinput></screen>

	      <para>A név végén szereplõ
		perjelbõl a &man.chmod.1; tudni fogja, hogy
		követnie kell a <filename>foo</filename>
		szimbolikus linket és így az általa
		hivatkozott könyvtár, a <filename>mize</filename> engedélyeit
		fogja megváltoztatni.</para>
	    </warning>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="dos-binaries">
	  <para>A &os; képes DOS programokat futtatni?</para>
	</question>

	<answer>
	  <para>Igen, a Portgyûjteményben
	    található <package>emulators/doscmd</package>, vagyis egy DOS
	    emulációs program
	    segítségével.</para>

	  <para>Amennyiben a <application>doscmd</application>
	    önmagában még nem lenne elegendõ, egy
	    másik segédprogram, a <package>emulators/pcemu</package>
	    segítségével emulálni tudunk egy
	    8088-as processzort, valamint a BIOS annyi
	    részét, hogy futtatni tudjunk szöveges
	    DOS alkalmazásokat.  A használatához az
	    X&nbsp;Window&nbsp;Systemre is szükségünk
	    lesz.</para>

	  <para>Érdemes ezenkívül még
	    megpróbálnunk a &os;
	    Portgyûjteményében
	    található <package>emulators/dosbox</package> portot is.  Ez
	    az alkalmazás elsõsorban a régi DOS-os
	    játékok futtatásához
	    szükséges környezet
	    emulációjára koncentrál, a helyi
	    állományrendszerben található
	    állományok
	    felhasználásával.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="translation">
	  <para>Hogyan tudjuk az anyanyelvünkre lefordítani
	    a &os; dokumentációját?</para>
	</question>

	<answer>
	  <para>Olvassuk el a &os; Dokumentációs Projekt
	    bevezetõjében található <link xlink:href="&url.books.fdp-primer;/translations.html">Fordítói
	      GYIK-ot</link>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="freebsd-mail-bounces">
	  <para>A <systemitem class="fqdomainname">FreeBSD.org</systemitem>
	    tartományon belüli e-mail címekre
	    küldött levelek miért pattannak
	    vissza?</para>
	</question>

	<answer>
	  <para>A <systemitem class="fqdomainname">FreeBSD.org</systemitem>
	    levelezõrendszere a bejövõ levelekre
	    vonatkozóan átvett néhány
	    szigorúbb ellenõrzést a
	    <application>Postfix</application>
	    alkalmazástól, és ezért eldobja
	    azokat a leveleket, amelyek formátuma hibás
	    vagy feltehetõen szemét.  A leveleink az
	    alábbi okok miatt pattanhatnak vissza:</para>

	  <itemizedlist>
	    <listitem>
	      <para>A levelet olyan név- vagy
		IP-tartományból küldtük, ahonnan
		korábban levélszemetet küldtek,
		ezért feketelistára került.</para>

	      <para>A &os; levelezõ szerverei eldobnak minden olyan
		levelet, amelyek feketelistás
		tartományokból érkeznek.  Ha olyan
		cégen vagy tartományon keresztül
		akarunk küldeni, amelyik levélszemetet
		gyárt vagy továbbít, akkor
		váltsunk szolgáltatót.</para>
	    </listitem>

	    <listitem>
	      <para>A levél törzse csak HTML kódot
		tartalmaz.</para>

	      <para>A leveleinket egyszerû szöveges
		formátumban küldjük.
		Állítsuk be a levelezõ
		kliensünket erre.</para>
	    </listitem>

	    <listitem>
	      <para>A <systemitem class="fqdomainname">FreeBSD.org</systemitem>
		címen üzemelõ levelezõ szerver nem
		tudta a csatlakozó gép
		IP-címét szimbolikus névre
		feloldani.</para>

	      <para>Az ellenkezõ irányú
		névfeloldás sikeressége alapvetõ
		követelmény a levelek
		fogadásához.  Gondoskodjunk róla,
		hogy a levelezõ szerverünk
		IP-címével mûködjön az
		inverz névfeloldás, Sok otthoni
		szolgáltatás (DSL, kábel,
		betárcsázós stb.  kapcsolat) erre
		nem ad lehetõséget.  Ilyenkor a leveleinket
		próbáljuk meg a
		szolgáltatónk levelezõ szerverein
		keresztül küldeni.</para>
	    </listitem>

	    <listitem>
	      <para>Az SMTP protokoll EHLO/HELO részében
		megadott hálózati név nem
		oldható fel valós IP-címre.</para>

	      <para>Egy teljes, feloldható hálózati
		név elegendhetetlen a levél
		elfogadásához szükséges SMTP
		párbeszéd
		érvényességéhez.  Ha nincs
		hivatalosan bejegyzett hálózati
		nevünk, akkor a szolgáltató
		levelezõ szervereit kell használnunk a
		levél elküldéséhez.</para>
	    </listitem>

	    <listitem>
	      <para>A küldött üzenet
	      azonosítója (Message ID) végén
		a <systemitem>localhost</systemitem> szerepel.</para>

	      <para>Egyes levelezõ kliensek rossz
		azonosítónak hoznak létre az
		üzenetekhez, ezért a rendszer nem
		hajlandó elfogadni ezeket.  Ilyenkor vagy
		rávesszük valahogy a levelezõ
		kliensünket, hogy rendes azonosítókat
		készítsen, vagy úgy
		állítjuk be a
		levéltovábbítónkat, hogy
		érvényes azonosítókra
		írja át.</para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="free-account">
	  <para>Hogyan lehet egyszerûen &os; rendszereket
	    elérni?</para>
	</question>

	<answer>
	  <para>Habár a &os; maga nem nyújt akárki
	    számára hozzáférést a
	    saját szervereihez, mások viszont
	    kínálnak bárki által
	    elérhetõ &unix; rendszereket.  Ennek
	    költsége és minõsége
	    szolgáltatónként
	    változik.</para>

	  <para>Az <link xlink:href="http://www.arbornet.org/">Arbornet,
	    Inc</link>, vagy másik nevén
	    <emphasis>M-Net</emphasis> 1983 óta szolgáltat
	    nyílt hozzáférést &unix;
	    típusú rendszerekhez.  Egy System&nbsp;III
	    alapokon mûködõ Altos rendszerrõl a
	    1991-ben BSD/OS-re váltottak, majd 2000
	    júliusában aztán &os;-re
	    váltottak.  Az <emphasis>M-Net</emphasis>
	    <application>telnet</application> és
	    <application>SSH</application>
	    szolgáltatásokon keresztül is
	    elérhetõ, és lényegében a
	    &os; alatt elérhetõ összes programhoz enged
	    egy alapvetõ hozzáférést.  A
	    hálózati hozzáférés
	    azonban csak a tagok és a támogatók
	    számára engedélyezett.  Ez egy
	    non-profit szervezet.  Az <emphasis>M-Net</emphasis>
	    rendelkezik üzenõfallal (bulletin board system,
	    BBS) és interaktív csevegõrendszerrel
	    is.</para>

	  <para>A <link xlink:href="http://www.grex.org/">Grex</link> az
	    <emphasis>M-Net</emphasis>
	    szolgáltatásához hasonlóan
	    ugyanúgy kínál üzenõfalat
	    és csevegési lehetõséget.
	    Többségében azonban &sun; 4M
	    gépeik vannak, amelyen &sunos; fut.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="sup-define">
	  <para>Mi az a <command>sup</command> és hogyan lehet
	    használni?</para>
	</question>

	<answer>
	  <para>A <link xlink:href="http://www.FreeBSD.org/cgi/ports.cgi?^sup">SUP</link>
	    mozaikszó mögött a <quote>Software Update
	    Protocol</quote> (<quote>Szoftverfrissítési
	    protokoll</quote>) áll, amelyet fejlesztési
	    fák szinkronban tartására dolgoztak ki
	    a Carnegie-Mellon Egyetemen.  Régebben ennek
	    segítségével tartották
	    frissítették magukat a fejlesztõi
	    források különbözõ
	    tükrözései a &os; Projekten
	    belül.</para>

	  <para>A <acronym>SUP</acronym> nem kifejezetten egy
	    sávszélesség-takarékos
	    megoldás, és egy ideje már
	    nyugdíjba vonult.  A forrásainkat jelen
	    pillanatban a <link xlink:href="&url.books.handbook;/synching.html#CVSUP">CVSup</link>
	    használatával tudjuk frissíteni.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="daemon-name">
	  <para>Hogy hívják azt a cuki kis vörös
	    fickót?</para>
	</question>

	<answer>
	  <para>Igazából nincs neve, mindenki
	    egyszerûen csak <quote>BSD démonnak</quote>
	    nevezi.  Ha mégis hívni szeretnénk
	    valahogy, akkor szólítsuk csak
	    <quote>beastie</quote>-nek, ugyanis a <quote>beastie</quote>
	    kiejtése megegyezik a <quote>BSD</quote>
	    szóéval
	    (<quote>bíeszdi</quote>).</para>

	  <para>A BSD démonról a saját <link xlink:href="http://www.mckusick.com/beastie/index.html">honlapján</link>
	    tudhatunk meg többet.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="use-beastie">
	  <para>Felhasználható a BSD démon
	    képe?</para>
	</question>

	<answer>
	  <para>Talán.  A BSD démon jogait Marshall Kirk
	    McKusick birtokolja.  A felhasználás pontos
	    lehetõségeivel kapcsolatban olvassuk el <link xlink:href="http://www.mckusick.com/beastie/mainpage/copyright.html">Statement
	    on the Use of the BSD Daemon Figure</link> címû
	    írást.</para>

	  <para>Röviden úgy foglalhatnánk össze,
	    hogy ízléses stílusban a saját
	    céljainkra mindaddig nyugodtan
	    felhasználhatjuk a képet, amíg
	    megemlítjük az eredeti szerzõt.  Ha
	    kereskedelmi céljaink vannak, akkor írjunk
	    &a.mckusick; címére.  A pontosabb
	    részleteket a <link xlink:href="http://www.mckusick.com/beastie/index.html">BSD démon honlapján</link>
	    olvashatjuk.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="daemon-images">
	  <para>Található valahol
	    felhasználható kép a BSD
	    démonról?</para>
	</question>

	<answer>
	  <para>EPS és XFig formátumú rajzok a
	    <filename>/usr/share/examples/BSD_daemon/</filename>
	    könyvtárban vannak.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="glossary">
	  <para>A levelezési listákon szerepeltek
	    ismeretlen kifejezések vagy
	    rövidítések.  Hol lehet ezeknek
	    utánanézni?</para>
	</question>

	<answer>
	  <para>Olvassuk el a <link xlink:href="&url.books.handbook;/freebsd-glossary.html">&os; szakkifejezéseinek gyûjteményét</link>.
	    </para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="bikeshed-painting">
	  <para>Miért fontos annyira a
	    biciklitároló színe?</para>
	</question>

	<answer>
	  <para>Erre röviden úgy adhatnánk
	    választ, hogy ezzel igazából nem kell
	    annyira törõdnünk.  Ha viszont valamivel
	    terjedelmesebben akarunk válaszolni, akkor azt
	    mondhatnánk, hogy azért, mert egy
	    biciklitároló megépítése
	    még nem tántorít el senkit sem a
	    válaszott szín
	    kritizálásától és az
	    átfestésének
	    fontolgatásától.  Ez a metafora
	    alapvetõen arról szól, hogy nem kell
	    feltétlenül minden apró
	    részletrõl vitatkoznunk csupán
	    azért, mert jobban értünk hozzá.
	    Sokak tapasztalata szerint ugyanis a
	    változtatásokhoz kapcsolódó
	    megjegyzések által gerjesztett zaj
	    fordítottan arányos az adott
	    változtatás
	    bonyolultságával.</para>

	  <para>A még hosszabb és teljesebb válasz
	    eredetileg egy nagyon hosszú és
	    fárasztó vita eredményeképpen
	    keletkezett, amikor arról esett szó, hogy a
	    &man.sleep.1; törtekkel dolgozzon-e vagy sem.  Erre
	    válaszul küldte &a.phk; az azóta
	    híressé vált <quote><link xlink:href="http://www.FreeBSD.org/cgi/getmsg.cgi?fetch=506636+517178+/usr/local/www/db/text/1999/freebsd-hackers/19991003.freebsd-hackers">A
	    bike shed (any color will do) on greener
	    grass...</link></quote> (<quote>(Bármilyen
	    színû) biciklitároló megfelelne
	    egy zöldebb gyepen...</quote>) címû
	    levelét.  Ebbõl szeretnénk most
	    idézni:</para>

	  <blockquote>
	    <attribution>&a.phk;, &a.hackers.name;, 1999.
	      október 2.</attribution>

	    <para><quote>Mirõl is szól ez a
		biciklitároló?</quote> &mdash;
	      kérdezték tõlem sokan.</para>

	    <para>Ez egy hosszú, vagy még inkább
	      régi történet, amely azonban
	      valójában meglehetõsen rövid.  C.
	      Northcote Parkinson <quote>Parkinson
		törvénye</quote> címmel írt egy
	      könyvet az 1960-as évek elején,
	      amelyben elég nagy betekintést adott a
	      vezetés dinamikájába.</para>

	    <para><emphasis>[a könyv részletes
	      bemutatását most
	      kihagyjuk]</emphasis></para>

	    <para>A konkrét példában egy
	      biciklitároló szerepel egy
	      atomerõmûvel szemben, szóval ez is
	      eléggé jól érzékelteti
	      a könyv korát.</para>

	    <para>Parkinson ezen keresztül bemutatja, hogyan kell
	      egy igazgatói tanács elé járulni
	      egy több millió vagy akár
	      milliárd dolláros atomerõmû
	      megépítéséhez, azonban egy
	      egyszerû biciklitároló
	      megépítésekor könnyen
	      véget nem érõ vitatkozásba
	      bonyolódhatunk.</para>

	    <para>Parkinson elmagyarázza, mindez azért
	      van, mert egy atomerõmû annyira
	      óriási, drága és bonyolult,
	      hogy az emberek egyszerûen nem értik meg.
	      Ezért nem szólnak semmit és
	      megnyugtatják magukat a
	      feltételezéssel, hogy valaki más
	      korábban már biztosan
	      utánajárt a részleteknek.  Richard P.
	      Feynmann is könyveiben rengeteg érdekes
	      és nagyon találó példát
	      ad ezekre Los Alamossal kapcsolatban.</para>

	    <para>Vegyünk ezzel szemben most egy
	      biciklitárolót.  Bárki képes egy
	      hétvége alatt összetákolni egy
	      ilyet és még így is marad ideje
	      megnézni a meccset.  Ezért nem
	      számít, mennyire jól megfogalmazott,
	      elõkészített és logikus is a
	      javaslatunk, valaki biztosan meg fogja ragadni a
	      lehetõséget, hogy az orrunk elõtt
	      fitogtassa a képességeit és
	      megmutassa magát: õ bizony <emphasis>itt
	      járt</emphasis>.</para>

	    <para>Dániában ezt mi úgy
	      hívjuk, hogy <quote>otthagyjuk a kezünk
	      nyomát</quote>.  Ez mindössze a
	      személyes büszkeségrõl és
	      tekintélyrõl szól, vagyis hogy
	      végre elmondhassuk: <quote>Ezt nézd!
	      <emphasis>Én</emphasis> csináltam.</quote>
	      Ez ugyan leginkább a politikusokra jellemzõ,
	      de alapvetõen minden emberben ott él.
	      Gondoljunk csak a friss betonban hagyott
	      lábnyomokra.</para>
	  </blockquote>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter xml:id="funnies" xml:lang="hu">
    <title>Mókás dolgok a &os;-vel kapcsolatban</title>

    <qandaset>
      <qandaentry>
	<question xml:id="very-very-cool">
	  <para>Mennyire hûsít a &os;?</para>
	</question>

	<answer>
	  <para>Kérdés: Mérte már valaki,
	    hogy a &os; futása közben mennyire melengeti meg
	    a számítógépet?  Úgy
	    hírlik, a &linux; ebben a tekintetben sokkal jobb,
	    mint a DOS, de &os;-rõl még nem ismert ezzel
	    kapcsolatban semmi.  Mondjuk, elég tüzesnek
	    tûnik.</para>

	  <para>Válasz: Nem, de korábban már
	    számos tesztet végeztünk bekötött
	    szemû önkénteseken, akiknek elõzetesen
	    250&nbsp;mikrogram LSD-25-öt adagoltak.  A tesztalanyok
	    35&nbsp;százaléka szerint a &os; kissé
	    narancsos ízû volt, míg a &linux;
	    inkább a rózsaszín ködhöz
	    hasonlított.  A hõmérséklettel
	    kapcsolatban azonban egyik csoport sem észlelt
	    komolyabb változást.  Végül
	    aztán teljesen el kellett vetnünk a
	    kísérlet eredményeit, mert menet
	    közben túlságosan sok
	    önkéntes kóborolt el, és ezzel
	    torzították a mérések
	    eredményeit.  A legtöbb önkéntes
	    azóta is Apple-nél van, és azóta
	    is egy új <quote>színes, szagos</quote>
	    grafikus felületen dolgoznak.  Szép kis
	    felfordulás!</para>

	  <para>Komolyan: a &os; és a &linux; is egyaránt
	    a processzorokban található
	    <acronym>HLT</acronym> (halt) utasítást
	    használja arra, hogy az üresjáratban
	    levõ rendszer energiafogyasztását
	    és ezáltal hõtermelését is
	    valamennyire mérsékelje.  Emellett még
	    az APM (Advanced Power Management) is támogatott,
	    így a &os; akár tetszés szerint
	    alacsonyabb energiafogyasztású módba is
	    tudja tenni a processzort.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="letmeoutofhere">
	  <para>Mi mocorog a memóriamodulokban?</para>
	</question>

	<answer>
	  <para>Kérdés: A &os; csinál valami
	    <quote>szokatlan</quote> a rendszermag fordítása
	    közben, ami miatt a memóriák felõl
	    mocorgást lehet hallani?  Amikor fordítok
	    (vagy egy rövid ideig, amikor az
	    indításkor a rendszer keresi a
	    floppymeghajtót) valamilyen furcsa
	    mocorgásszerû hang jön a
	    memóriamodulokból.</para>

	  <para>Válasz: Igen!  Gyakran utalnak a BSD rendszerek
	    dokumentációiban mindenféle
	    <quote>démonokra</quote>, és ezzel
	    kapcsolatban a legtöbb ember nem is tudja, hogy ezek
	    valójában apró, öntudatos,
	    fizikailag nem létezõ lények, amelyek a
	    rendszer indulása után
	    megszállják a
	    számítógépünket.  A
	    memóriából kiszûrõdõ
	    mocorgás hangja igazából a
	    démonok közti magas frekvenciás
	    beszélgetésbõl ered, amikor éppen
	    arról egyeztetnek, hogy miként
	    birkózzanak meg a különbözõ
	    rendszeradminisztrációs feladatokkal.</para>

	  <para>Ha teljesen megõrjít minket ez a
	    zajongás, akkor úgy tudunk tõlük
	    megszabadulni, ha kiadjuk DOS-ból a jó
	    öreg <command>fdisk /mbr</command> parancsot.  Ekkor
	    viszont ne lepõdjünk meg, ha netalán
	    visszalõnének és próbálnak
	    minket megállítani.  Ha eközben a
	    hangszóróinkból Bill Gates
	    sátáni kacaja harsanna fel, akkor rohanjunk
	    és ne is nézzünk többet vissza!  A
	    BSD démonok támogatásától
	    mentesen a &windows; és a DOS ikerördögei
	    ilyenkor gyakran visszaszerzik gépünk felett a
	    teljes irányítást és ezzel
	    örök szenvedésre kárhoztatják
	    gyarló lelkünket.  Ennek tudatában lehet,
	    hogy mégis csak jobb lenne, ha egyszerûen csak
	    hozzászoknánk azokhoz a furcsa hangokhoz,
	    nem?</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="changing-lightbulbs">
	  <para>Hány &os; fejlesztõ kell egy
	    villanykörte kicseréléséhez?</para>
	</question>

	<answer>
	  <para>Ezeregyszázhatvankilenc:</para>

	  <para>Huszonhárman panaszkodnak a -current
	    listán, hogy már megint kiment a villany.</para>

	  <para>Négyen erre azt válaszolják, hogy
	    ez csak konfigurációs probléma,
	    ezért ennek a -questions listán a
	    helye.</para>

	  <para>Hárman írnak róla
	    hibajelentést, de ezek közül az egyik
	    ráadásul tévesen a
	    <literal>doc</literal> kategóriába kerül,
	    és csak annyi áll benne, hogy
	    <quote>sötét van</quote>.</para>

	  <para>Erre az egyikük beszerel egy
	    kipróbálatlan villanykörtét,
	    amitõl nem mûködik a rendszer többi
	    része, így öt perc múlva ki is
	    szereli.</para>

	  <para>Nyolcan leszidják a hibajelentések
	    íróit, hogy nem mellékelték a
	    javítást a jelentéseik
	    mellé.</para>

	  <para>Öten siránkoznak, hogy nem mûködik
	    a rendszer.</para>

	  <para>Harmincegyen erre azt válaszolják, hogy
	    nekik minden remekül mûködik, és az
	    érintettek minden bizonnyal pont rosszkor
	    frissítettek.</para>

	  <para>Egy küld egy új villanykörtét a
	    -hackers listára.</para>

	  <para>Erre egy rászól, hogy õ már
	    három évvel ezelõtt megcsinálta
	    ugyanezt, de amikor beküldte a -current listára,
	    akkor senki sem foglalkozott vele, és
	    egyébként sem szereti a
	    hibajelentéseket.  Emellett ráadásul az
	    új villanykörte egyébként sem
	    tetszik.</para>

	  <para>Huszonheten nekiállnak skandálni, hogy a
	    villanykörték nem tartoznak az alaprendszerbe,
	    ezért a committerek a közösség
	    megkérdezése nélkül nem
	    csinálhatnak semmit, és különben is:
	    <emphasis>Mi errõl a -core
	    véleménye?</emphasis></para>

	  <para>Kétszázan eközben megvitatják,
	    milyen színû legyen a
	    biciklitároló.</para>

	  <para>Hárman jelzik, hogy a javítás nem
	    felel meg a &man.style.9;
	    elõírásainak.</para>

	  <para>Tizenheten megjegyzik, hogy az újonnan javasolt
	    villanykörte GPL licenccel rendelkezik.</para>

	  <para>Ötszázhatvankilencen valóságos
	    vitaözönt indítanak a GPL, a BSD, MIT
	    és NPL licencek elõnyeit illetõen, majd
	    megjegyzéseket tesznek különféle meg
	    nem nevezett FSF alapítók személyes
	    higéniajára.</para>

	  <para>Heten a vita bizonyos részeit átviszik a
	    -chat és -advocacy listákra.</para>

	  <para>Egy végül beszereli a javasolt
	    villanykörtét, de az valamivel mintha
	    halványabban világítani, mint az
	    elõzõ.</para>

	  <para>Ketten leszólják a szerelést,
	    és összekapnak azon, hogy most akkor a &os;
	    inkább maradjon sötétségben vagy
	    érje be a halványabb
	    világítással.</para>

	  <para>Negyvenhárman rikácsolva követelik a
	    halványan világító
	    villanykörte kiszerelését és
	    panaszukat megírják a -core
	    listára.</para>

	  <para>Tizenegyen egy kisebb villanykörtét
	    kérnek, mert ha majd portolni akárják a
	    Tamagotchijukra a rendszert, akkor ott is
	    használható legyen.</para>

	  <para>Hetvenhárman felemelik a szavukat a -hackers
	    és -chat listákon felerõsödött
	    zaj miatt, és tiltakozásul leiratkoznak
	    ezekrõl a listákról.</para>

	  <para>Tizenhárman erre egy <quote>leiratkozom</quote>,
	    <quote> Hogyan kell innen leiratkozni?</quote> vagy
	    <quote>Kérlek, vegyetek le errõl a
	    listáról</quote> témájú
	    levelet küldenek a megszokott stílusban.</para>

	  <para>Egy eközben beszerel végre egy
	    mûködõ villanykörtét, miközben
	    mindenki azzal van elfoglalva, hogy szidja a másikat,
	    így szinte észre sem veszik.</para>

	  <para>Harmincegy ezután hozzáteszi, hogy az
	    új villanykörte
	    0,364&nbsp;százalékkal jobban
	    világítana, ha TenDRA-val
	    csinálták volna (akkor viszont kocka
	    alakú lenne) és a &os;-nek ezért a GCC
	    helyett TenDRA-t kellene használnia.</para>

	  <para>Egy valaki megemlíti, hogy az új
	    villanykörtén nincs is burkolat.</para>

	  <para>Kilencen (beleértve a hibajelentések
	    íróit) azt kérdezgetik folyton, hogy
	    <quote>Mi az az MFC?</quote>.</para>

	  <para>Ötvenheten két hét múlva
	    kezdenek el panaszkodni, hogy a villanykörte
	    kiment.</para>

	  <para><emphasis>&a.nik; hozzáteszi:</emphasis></para>

	  <para><emphasis>Nagyon jót nevettem
	    ezen.</emphasis></para>

	  <para><emphasis>Közben az jutott az eszembe, hogy
	    <quote>Várjunk csak, nem kellene valahol a
	    felsorolásban lennie egy <quote>egy, aki pedig
	    ledokumentálja</quote>
	    résznek?</quote></emphasis></para>

	  <para><emphasis>És akkor végre
	    megértettem :-)</emphasis></para>

	  <para><emphasis>&a.tabthorpe;</emphasis> szerint: <quote>Egy
	    sem, mert a <emphasis>valódi</emphasis> &os;
	    fejlesztõk nem félnek a
	    sötétben!</quote></para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="dev-null">
	  <para>Hova kerül a <filename>/dev/null</filename>
	    eszközre küldött adat?</para>
	</question>

	<answer>
	  <para>A processzoron található speciális
	    adatsüllyesztõbe kerül, majd hõvé
	    alakul és elszállítja a felszerelt
	    hûtõborda és ventillátor.
	    Ezért is annyira fontos a processzor
	    hûtése: az emberek minél gyorsabb
	    géppel rendelkeznek, annál inkább
	    gondatlanná válnak és annál
	    több adat köt ki a <filename>/dev/null</filename>
	    eszközben.  Ha sikerül letörölnünk
	    a <filename>/dev/null</filename> eszközt (amivel
	    így lényegében letiltjuk a processzor
	    adatsüllyesztõjét), akkor a processzorunk
	    ugyan kevésbé fog melegedni, viszont gyorsan
	    eldugul a sok adattól és furcsán kezd
	    el viselkedni.  Ha nagyon gyors hálózati
	    kapcsolattal rendelkezünk, akkor úgy is le
	    tudjuk hûteni a processzorunkat, ha folyamatosan
	    olvassuk a <filename>/dev/random</filename> eszközt
	    és valahova elküldjük az eredményt.
	    Ekkor viszont vigyázzunk arra, hogy ezzel a
	    módszerrel könnyen túlmelegedhet a
	    hálózati kártyánk és a
	    gyökér állományrendszerünk,
	    valamint a szolgáltató sem fog
	    örülni ennek, mert akkor a felesleges hõ
	    náluk keletkezik.  Általában viszont
	    jó a hûtésük, ezért ha okosan
	    csináljuk, akkor semmi gondunk nem származik belõle.</para>

	  <para><emphasis>Paul Robinson
	    hozzáteszi:</emphasis></para>

	  <para>Vannak még más módszerek is.
	    Minden jó rendszergazda tudja, hogy szokás a
	    képernyõre is folyamatosan adatot küldeni,
	    mert így a pixik is vidámabbak lesznek.  A
	    képernyõt formázó pixik (melyek
	    gyakran tévesen és hibásan
	    <quote>pixeleknek</quote> hívnak) a fejükön
	    viselt kalapok szerint három csoportba
	    sorolhatóak (vörös, zöld vagy
	    kék), és annak megfelelõen bújnak
	    elõ (illetve mutatják meg a kalapjukat), hogy
	    kapnak-e enni.  A videokártyák felelõsek
	    azért, hogy a kapott adatokból pixiétel
	    készüljön és hogy az eljusson a
	    pixikhez &mdash; minél drágább a
	    kártya, annál jobb minõségû
	    az elõállított étel, és
	    annál fegyelmezettebben viselkednek a pixik.
	    Állandó cirogatásra is
	    szükségük van &mdash; ez a
	    képernyõvédõk feladata.</para>

	  <para>Az elõbbi javaslatot azzal tudnám még
	    kiegészíteni, hogy a
	    <filename>/dev/random</filename> eszköztõl
	    származó adatokat akár a konzolra is
	    küldhetjük, így a pixiket is jól
	    tudjuk lakatni.  Ezzel együtt nem jár semmilyen
	    hõtermelés, viszont a pixik boldogok lesznek
	    és így könnyen meg tudunk szabadulni a
	    felesleges adatoktól is, még úgy is, ha
	    kissé zavarosnak tûnik közben a
	    kép.</para>

	  <para>Mellesleg mint az egyik nagy szolgáltató
	    egykori rendszergazdája elmondhatom, hogy mivel
	    tapasztalatom szerint a szerverszobában nehéz
	    tartani a megfelelõ hõmérsékletet,
	    ezért nem ajánlom senkinek a felesleges adatok
	    átküldését a
	    hálózaton.  A csomagok
	    közvetítésével és
	    irányításával foglalkozó
	    tündérek sem különösebben szoktak
	    örülni ennek.</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter xml:id="advanced" xml:lang="hu">
    <title>Témák haladóknak</title>

    <qandaset>
      <qandaentry>
	<question xml:id="learn-advanced">
	  <para>Honnan lehet többet megtudni a &os; belsõ
	    felépítésérõl?</para>
	</question>

	<answer>
	  <para>Jelen pillanatban csak egyetlen mû foglalkozik az
	    operációs rendszerek
	    felépítésével a &os;
	    szemszögébõl, név szerint a Marshall
	    Kirk McKusick és George V.  Neville-Neil által
	    írt <quote>The Design and Implementation of the
	    &os; Operating System</quote> címû könyv
	    (ISBN 0-201-70245-2), amely a &os;
	    5.<replaceable>X</replaceable> változatára
	    koncentrál.</para>

	  <para>Emellett a &unix; típusú rendszerek
	    használatával kapcsolatos ismeret remekül
	    alkalmazható a &os; esetén is.</para>

	  <para>A témához tartozó többi
	    könyvet a kézikönyv <link xlink:href="&url.books.handbook;/bibliography-osinternals.html">Az
	      operációs rendszerek belsõ
	      mûködésével</link>
	    foglalkozó irodalomjegyzékben
	    találhatjuk meg.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="how-to-contribute">
	  <para>Hogyan lehet bekapcsolódni a &os;
	    fejlesztésébe?</para>
	</question>

	<answer>
	  <para>Pontosabb tanácsokat akkor kapunk, ha elolvassuk
	    a <link xlink:href="&url.articles.contributing.en;/article.html">&os;
	    fejlesztésérõl szóló
	    cikket</link>.  Nagyon is számítunk mindenki
	    segítségére!</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="define-snap-release">
	  <para>Mik azok a pillanatkiadások és
	    kiadások?</para>
	</question>

	<answer>
	  <para>Jelenleg három aktív és
	    félig aktív ág van a &os; <link xlink:href="http://www.FreeBSD.org/cgi/cvsweb.cgi">CVS
	    repositoryjában</link>.  (A korábbi
	    ágakat már csak nagyon ritkán
	    módosítják, ezért is csak
	    három aktív fejlesztési ágon
	    fejlesztenek):</para>

	    <itemizedlist>
	      <listitem>
		<para><literal>RELENG_7</literal> avagy
		  <emphasis>7-STABLE</emphasis></para>
	      </listitem>

	      <listitem>
		<para><literal>RELENG_8</literal> avagy
		  <emphasis>8-STABLE</emphasis></para>
	      </listitem>

	      <listitem>
		<para><literal>HEAD</literal> avagy
		  <emphasis>-CURRENT</emphasis> avagy
		  <emphasis>9-CURRENT</emphasis></para>
	      </listitem>
	    </itemizedlist>

	  <para>A <literal>HEAD</literal> nem olyan ág, mint a
	    másik kettõ.  Ez egyszerûen csak
	    <quote><emphasis>a jelenlegi, még el nem
	    ágaztatott fejlesztési
	    irány</emphasis></quote> jelentéssel
	    bír, amire pedig sokszor röviden csak
	    <emphasis>-CURRENT</emphasis> néven
	    hivatkoznak.</para>

	  <para>Jelen pillanatban a <emphasis>-CURRENT</emphasis> a
	    9.<replaceable>X</replaceable> fejlesztési
	    irányát képviseli; az
	    <literal>6-STABLE</literal> ág, a
	    <symbol>RELENG_6</symbol>, 2005 novemberében, a
	    <literal>7-STABLE</literal> ág, a
	    <symbol>RELENG_7</symbol>, 2008 februárjában,
	    míg a <literal>8-STABLE</literal> ág, a
	    <symbol>RELENG_8</symbol>, 2009 novemberében
	    vált le a <quote>-CURRENT</quote>
	    ágból.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="custrel">
	  <para>Hogyan lehet saját kiadást
	    készíteni?</para>
	</question>

	<answer>
	  <para>Olvassuk el a <link xlink:href="&url.articles.releng.en;/article.html">kiadások
	      készítésérõl
	      szóló</link> cikket.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="makeworld-clobbers">
	  <para>A <command>make world</command>
	    parancs miért írja felül a
	    korábban telepített binárisokat?</para>
	</question>

	<answer>
	  <para>Mert alapvetõen ez lenne a cél: ahogy a neve
	    is sugallja, a rendszer újrafordítása,
	    vagyis a
	    <command>make world</command>
	    parancs feladata a rendszerben található
	    összes bináris
	    újrafordítása, aminek
	    eredményeképpen egy tiszta és
	    összefüggõ környezetet kapunk
	    (ezért is tart ilyen sokáig).</para>

	  <para>Ha a <command>make
	    world</command> vagy a <command>make
	    install</command> parancs
	    futtatása elõtt megadjuk a
	    <envar>DESTDIR</envar> környezeti
	    változót, akkor a frissen létrehozott
	    binárisok az általa mutatott
	    könyvtárba fognak kerülni pontosan
	    úgy, ahogy az eredeti rendszer.  Az osztott
	    könyvtárak bizonyos
	    módosításai és egyes programok
	    fordítása azonban könnyen térdre
	    kényszerítheti a <command>make
	    world</command>
	    futását.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="cvsup-round-robin">
	  <para>Miért nem forgó (<quote>round
	    robin</quote>) névfeloldással lehet
	    elérni a <application>CVSup</application> szervereket
	    és így megosztani köztük a
	    terhelést?</para>
	</question>

	<answer>
	  <para>Habár a <application>CVSup</application>
	    tükrözések óránként
	    frissítik magukat a központi
	    <application>CVSup</application> szerverrõl, maga a
	    frissítés azonban bármikor
	    megtörténhet.  Ennek
	    következményeképpen egyes szervereken
	    frissebb kód található, miközben a
	    többin még az egy órával
	    ezelõtti állapot szerepel.  Ha a <systemitem class="fqdomainname">cvsup.FreeBSD.org</systemitem> forgó
	    névfeloldással mûködne, akkor a
	    felhasználók mindig egy
	    véletlenszerûen választott
	    <application>CVSup</application> szervert kapnának,
	    és ezért a <application>CVSup</application>
	    egymás utáni futtatásakor könnyen
	    elõfordulhatna, hogy a rendszer régebbi
	    forrásait kapjuk vissza.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="ctm">
	  <para>A <emphasis>-CURRENT</emphasis> forrásait
	    korlátozott interneteléréssel is lehet
	    követni?</para>
	</question>

	<answer>
	  <para>Igen, ezt a <link xlink:href="&url.books.handbook;/synching.html#CTM">CTM</link>
	    használatával
	    <emphasis>anélkül</emphasis> is megtudjuk tenni,
	    hogy le kellene töltenünk az egész
	    forrásfát.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="split-1392k">
	  <para>Hogyan lehet 1392&nbsp;KB-os darabokra felosztani az
	    egyes terjesztéseket?</para>
	</question>

	<answer>
	  <para>Az újabb BSD alapú rendszerekben a
	    &man.split.1; parancsnak már van egy
	    <option>-b</option> paramétere, amellyel
	    tetszõleges méretûre fel tudunk darabolni
	    állományokat.</para>

	  <para>Íme erre egy példa a
	    <filename>/usr/src/release/Makefile</filename>
	    állományból:</para>

	  <programlisting>ZIPNSPLIT=              gzip --no-name -9 -c | split -b 1392k -</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="submitting-kernel-extensions">
	  <para>Hova lehet küldeni a rendszermaghoz írt
	    kiegészítéseket?</para>
	</question>

	<answer>
	  <para>Erre vonatkozóan vessünk egy
	    pillantást a <link xlink:href="&url.articles.contributing.en;/article.html">&os; továbbfejlesztésérõl szóló</link>
	    cikkre.</para>

	  <para>Köszönjük, hogy gondolt
	    ránk!</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="pnp-initialize">
	  <para>A rendszer hogyan érzékeli és
	    inicializálja a Plug and Play ISA
	    kártyákat?</para>
	</question>

	<answer>
	  <para>Frank Durda IV
	    (<email>uhclem@nemesis.lonestar.org</email>)
	    válasza:</para>

	  <para>Dióhéjban úgy tudnám ezt
	    elmagyarázni, hogy van néhány I/O port,
	    amelyet lekérdezve a PnP kártya képes
	    válaszolni, hogy elérhetõ-e.
	    Ezért a PnP eszközök keresése azzal
	    kezdõdik, hogy a rendszer felteszi a
	    kérdést, van-e PnP kártya a
	    számítógépben.  Erre
	    aztán a különbözõ
	    kártyák a típusuk
	    megjelölésével válaszolnak,
	    amelyet ugyanezen az I/O porton kell visszaolvasni,
	    így ha már legalább egy bitet
	    beállít valaki, akkor folytatható a
	    keresés.  Ezután a keresést
	    végzõ kódrész letiltja az
	    <literal>X</literal> alatti (a &microsoft; és az
	    &intel; által kiosztott) azonosítóval
	    rendelkezõ kártyákat, majd ismét
	    megnézi, hogy valaki továbbra is
	    válaszol-e.  Amennyiben a válasz
	    <literal>0</literal>, az arra utal, hogy már nincs
	    aktív kártya az <literal>X</literal>
	    azonosító felett.  Ezt követõen a
	    rendszer megpróbálkozik az
	    <literal>X</literal> alatti azonosítók
	    lekérdezésével.  Végül
	    folytatja az <literal>X</literal> alatti keresést az
	    <literal>X&nbsp;-(korlát&nbsp;/&nbsp;4)</literal>
	    feletti azonosítók letiltásával,
	    majd megismétli az iménti
	    kérdést.  Ezzel a félig-meddig
	    bináris keresési módszerrel
	    aztán képes 2<superscript>64</superscript>
	    lépésnél jóval kevesebbõl
	    felderíteni a rendszerünkben
	    megtalálható PnP
	    kártyákat.</para>

	  <para>Az azonosítók két 32&nbsp;bit
	    hosszúságú mezõbõl
	    (ezért írtunk az elõbb
	    2<superscript>64</superscript> lépést)
	    és egy 8&nbsp;bites
	    ellenõrzõösszegbõl állnak.  Az
	    elsõ 32&nbsp;bit a gyártót
	    azonosítja.  Ugyan soha nem vallják be, de
	    úgy tûnik, hogy még ugyanannak a
	    gyártónak is lehetnek eltérõ
	    gyártóazonosítóval
	    rendelkezõ kártyái.  A
	    gyártók számára fenntartott
	    32&nbsp;bites mezõ ezért valamennyire
	    túlzás.</para>

	  <para>A második 32&nbsp;bit lehet a kártya
	    sorozatszáma vagy bárki más, amely
	    alapján egyértelmûen
	    beazonosítható.  A gyártó
	    ugyanazzal a 32&nbsp;bites értékkel nem
	    gyárthat egy másik kártyát, csak
	    abban az esetben, ha a másik 32&nbsp;bit is
	    eltér.  Ennek köszönhetõen egy
	    gépen belül még az azonos
	    típusú kártyák is el fognak
	    térni 64&nbsp;biten.</para>

	  <para>Az iménti 32&nbsp;bites csoportok nem lehetnek
	    teljesen nullák, ezért lehetséges, hogy a
	    bináris keresés során a
	    válaszban legalább egy bit mindig aktív
	    lesz.</para>

	  <para>Miután a rendszer sikeresen beazonosította
	    a rendelkezésre álló
	    kártyákat, egyenként újra
	    elindítja ezeket (ugyanazon az I/O porton
	    keresztül), és megpróbálja
	    kitalálni, hogy az adott eszközöknek milyen
	    erõforrásokra van szüksége, milyen
	    megszakítást akarnak használni stb.  Az
	    összes kártyától lekérdezi
	    ezeket az információkat.</para>

	  <para>Az így megszerzett információkat
	    aztán még kiegészíti a
	    merevlemezen vagy az MLB BIOS-ban található
	    ECU állományok tartalmával.  Az ECU
	    és az MLB BIOS PnP támogatása
	    általában viszont nem valódi, és
	    az ilyen eszközök igazából nem is
	    állítanak be semmit maguktól.  A BIOS
	    és az ECU átvizsgálása azonban
	    segít a felderítést végzõ
	    rutinnak értesíteni a tényleges PnP
	    eszközöket, hogy ne foglaljanak el olyan
	    erõforrásokat, amelyeket a rendszer nem tud
	    áthelyezni.</para>

	  <para>Ezután a PnP eszközöket a kód
	    még egyszer végigjárja és
	    átadja nekik a
	    mûködésükhöz
	    szükséges I/O, DMA, IRQ és
	    memóracímek hozzárendeléseit.
	    Az eszközök ekkor a megadott helyeken
	    elérhetõvé válnak és
	    úgy is maradnak a rendszer következõ
	    indításáig, de igazából
	    semmi sem rögzíti ezeket.</para>

	  <para>Talán túlságosan is
	    egyszerûsítettem a fentieket, de szerintem
	    már ennyi is elegendõ az alapok
	    megértéséhez.</para>

	  <para>A &microsoft; néhány elsõdleges
	    nyomtatási állapotot jelzõ portot
	    átrakott PnP-re, azzal a címszóval,
	    hogy egyik kártya sem kódolta át ezeket
	    a címeket az ellenkezõ I/O ciklusok
	    számára.  Találtam is egy eredeti IBM
	    nyomtatókártyát, amely valóban
	    át tudta írni az állapotjelzõ
	    portot a PnP kezdeti változataiban, de arra a
	    &microsoft; csak annyit mondott, hogy
	    <quote>fogós</quote>.  Ezért a
	    nyomtatási állapotot jelzõ portot a
	    címek beállítására
	    használja, illetve még a
	    <literal>0x800</literal>-as portot és egy harmadik
	    I/O portot valahol a <literal>0x200</literal> és a
	    <literal>0x3ff</literal>
	    környékén.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="major-numbers">
	  <para>Hogyan lehet fõeszközazonosítót
	    rendelni egy általunk fejlesztett
	    meghajtóhoz?</para>
	</question>

	<answer>
	  <para>2003 februárja óta a &os; képes
	    dinamikusan és önmûködõen
	    futás közben lefoglalni
	    fõeszközazonosítókat a
	    meghajtóknak (lásd &man.devfs.5;),
	    ezért erre tulajdonképpen már nincs
	    szükség.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="alternate-directory-layout">
	  <para>A könyvtárakra vonatkozóan milyen
	    más kiosztási házirendek léteznek
	    még?</para>
	</question>

	<answer>
	  <para>A könyvtárak más fajta
	    kiosztására vonatkozóan annyit tudok
	    válaszolni, hogy a jelenleg is alkalmazott
	    sémát az 1983-ban megalkotott változata
	    óta változatlanul használjuk.
	    Eredetileg a gyors állományrendszerhez
	    készítettem, de soha nem ragaszkodtam
	    hozzá.  Remekül megoldja a cilindercsoportok
	    betelésének problémáját,
	    azonban sokan megjegyezték már, hogy a
	    &man.find.1; esetén gyengén mûködik.
	    A legtöbb állományrendszert
	    mélységi bejárással
	    hozzák létre, így a
	    könyvtárak szétszóródnak a
	    cilindercsoportok közt és ezzel a
	    késõbbi mélységi keresések
	    számára a lehetõ legrosszabb helyzetet
	    alakítják ki.  Ha valaki például
	    tudja elõre a létrehozni kívánt
	    könyvtárak számát, akkor ezt
	    úgy lehet megoldani, ha a mûvelet során
	    <literal>(összes&nbsp;/&nbsp;cilindercsoportok)</literal>
	    mennyiségû könyvtárat hozunk
	    létre az egyes cilindercsoportokban.  Ennek
	    meghatározására
	    nyilvánvalóan lehet adni valamilyen
	    heurisztikát.  Már egy kisebb elõre
	    rögzített szám, mint
	    például a 10 kiválasztása is
	    legalább egy nagyságrendnyi javulást
	    jelent.  Ha szeretnénk
	    megkülönböztetni az
	    állományrendszerek
	    visszaállítását a
	    hagyományos mûködéstõl (amire a
	    jelenlegi algoritmus sokkal érzékenyebb),
	    akkor érdemes tizes csoportokba összefogni a
	    könyvtárakat, feltéve, hogy
	    10&nbsp;másodpercen belül hoztuk létre
	    ezeket.  Mindenesetre elmondható, hogy ezzel
	    nyugodtan lehet kísérletezni.</para>

	  <para>&a.mckusick;, 1998 szeptembere</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="kernel-panic-troubleshooting">
	  <para>Hogyan lehet kinyerni a legtöbb
	    információt a rendszermag
	    összeomlásából?</para>
	</question>

	<answer>
	  <para>Általában így néz ki a
	    rendszermag összeomlása:</para>

	  <programlisting>Fatal trap 12: page fault while in kernel mode
fault virtual address   = 0x40
fault code              = supervisor read, page not present
instruction pointer     = 0x8:0xf014a7e5
stack pointer           = 0x10:0xf4ed6f24
frame pointer           = 0x10:0xf4ed6f28
code segment            = base 0x0, limit 0xfffff, type 0x1b
                        = DPL 0, pres 1, def32 1, gran 1
processor eflags        = interrupt enabled, resume, IOPL = 0
current process         = 80 (mount)
interrupt mask          =
trap number             = 12
panic: page fault</programlisting>

	  <para>Amikor egy ilyen üzenetet látunk, akkor nem
	    elegendõ újra elõcsalni a hibát
	    és beküldeni.  Az
	    utasításszámláló
	    (<quote>instruction pointer</quote>) értéke
	    ugyan nagyon fontos, de sajnos konfigurációk
	    szerint eltérhet.  Más szóval
	    úgy fogalmazhatnék, hogy ennek az
	    értéke a használatban levõ
	    rendszermag értékétõl
	    függõen változhat.  Ha a
	    <filename>GENERIC</filename> rendszermagot használjuk
	    valamelyik kiadásból, akkor viszont már
	    elképzelhetõ, hogy valaki más is le tudja
	    nyomozni a hibát okozó függvényt.
	    Ha viszont egy saját
	    beállításokkal rendelkezõ
	    rendszermagot használunk, akkor egyedül csak
	    <emphasis>mi</emphasis> vagyunk képesek megmondani a
	    hiba pontos helyét.</para>

	  <para>Ezért a javaslatom a következõ:</para>

	    <procedure>
	      <step>
		<para>Jegyezzük le az
		  utasításszámláló
		  értékét.  A
		  <literal>0x8:</literal> rész ebben az esetben
		  annyira nem fontos, egyedül csak a
		  <literal>0xf0xxxxxx</literal> részre van
		  szükségünk.</para>
	      </step>

	      <step>
		<para>A rendszer újraindításakor
		  írjuk be a következõt:</para>

		<screen>&prompt.user; <userinput>nm -n /a.hibát.okozó.rendszermag | grep f0xxxxxx</userinput></screen>

		<para>ahol az <literal>f0xxxxxx</literal> az
		  utasításszámláló
		  értéke.  Könnyen elõfordulhat,
		  hogy ilyenkor még nem találunk
		  egyezést, mivel a rendszermag
		  szimbólumtáblájában csak
		  az egyes függvények belépési
		  pontjai találhatóak, és ha az
		  utasításszámláló
		  általában valamelyikük
		  belsejébe mutat, nem az elejükre.  Ha
		  tehát nem még látunk semmit,
		  akkor egyszerûen hagyjuk el az utolsó
		  számjegyet és
		  próbálkozzunk így:</para>

		<screen>&prompt.user; <userinput>nm -n /a.hibát.okozó.rendszermag | grep f0xxxxx</userinput></screen>

		<para>Ha még ez sem hoz eredményt, akkor
		  vágjunk le a végérõl egy
		  újabb számjegyet.  Egészen addig
		  csináljuk, amíg nem kapunk valami
		  értékelhetõ eredményt.
		  Ilyennek tekintjük például azokat a
		  függvényeket, amelyek a hibát
		  okozhatták.  Ez ugyan egy nem annyira pontos
		  felderítési eszköz, viszont
		  még ez is jobb a semminél.</para>
	      </step>
	    </procedure>

	  <para>A legjobb viszont mégis az, amikor sikerül
	    lementeni a hiba bekövetkezésekor a memória
	    tartalmát, majd a &man.kgdb.1;
	    használatával elõbányászni
	    belõle egy hívási láncot.</para>

	  <para>Ehhez többnyire a következõ
	    módszer javasolt:</para>

	  <procedure>
	    <step>
	      <para>A rendszermag konfigurációs
		állományába
		(<filename>/usr/src/sys/arch/conf/RENDSZERMAGKONFIG</filename>)
		vegyük fel a következõ sort:</para>

	      <programlisting>makeoptions     DEBUG=-g          # A rendszermag fordítása gdb(1) szimbólumokkal</programlisting>
	    </step>

	    <step>
	      <para>Lépjünk be a <filename>/usr/src</filename>
		könyvtárba:</para>

	      <screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>
	    </step>

	    <step>
	      <para>Fordítsuk le a rendszermagot:</para>

	      <screen>&prompt.root; <userinput>make buildkernel KERNCONF=RENDSZERMAGKONFIG</userinput></screen>
	    </step>

	    <step>
	      <para>Várjuk meg, amíg a &man.make.1;
		befejezi a fordítást.</para>
	    </step>

	    <step>
	      <screen>&prompt.root; <userinput>make installkernel KERNCONF=RENDSZERMAGKONFIG</userinput></screen>
	    </step>

	    <step>
	      <para>Indítsuk újra a gépet.</para>
	    </step>
	  </procedure>

	  <note>
	    <para>A <varname>KERNCONF</varname> használata
	      nélkül a <filename>GENERIC</filename>
	      rendszermag fordul és
	      telepítõdik.</para>
	  </note>

	  <para>A &man.make.1; programnak a folyamat
	  végeredményeként két rendszermagot
	    kell készítenie: a
	    <filename>/usr/obj/usr/src/sys/RENDSZERMAGKONFIG/kernel</filename>
	    és a
	    <filename>/usr/obj/usr/src/sys/RENDSZERMAGKONFIG/kernel.debug</filename>.
	    Ezek közül a <filename>kernel</filename>
	    <filename>/boot/kernel/kernel</filename> néven
	    mentõdik el, miközben a
	    <filename>kernel.debug</filename> használható
	    nyomonkövetésre a &man.kgdb.1;
	    programmal.</para>

	  <para>A rendszer csak akkor fogja elmenteni
	    összeomláskor a memória tartalmát,
	    ha az <filename>/etc/rc.conf</filename>
	    állományban beállítjuk a
	    <varname>dumpdev</varname> értékét a
	    lapozóállományt tároló
	    partícióra (vagy az <literal>AUTO</literal>
	    értékre).  Ennek hatására az
	    &man.rc.8; szkriptek a &man.dumpon.8; paranccsal
	    képesek engedélyezni a memória
	    lementését.  A &man.dumpon.8;
	    természetesen manuálisan is
	    elindítható.  Az összeomlást
	    követõen a memória lementett
	    tartalmához a &man.savecore.8; programmal
	    férhetünk hozzá.  Amikor viszont az
	    <filename>/etc/rc.conf</filename> állományban
	    megadjuk a <varname>dumpdev</varname>
	    értékét, az &man.rc.8; szkriptek
	    maguktól lefuttatják a &man.savecore.8;
	    parancsot és átrakják a mentést
	    a <filename>/var/crash</filename>
	    könyvtárba.</para>

	    <note>
	      <para>A &os; által létrehozott
		memóriamentések mérete
		általában a
		számítógépünkben
		levõ fizikai memória
		mennyiségével egyezik meg.  Tehát
		ha 512&nbsp;MB RAM van a gépünkben, akkor
		egy 512&nbsp;MB méretû mentést fogunk
		kapni.  Ezért gondoskodjunk róla, hogy a
		<filename>/var/crash</filename> könyvtárban
		mindig legyen elegendõ hely az
		állomány tárolásához.
		A &man.savecore.8; kézzel is lefuttathazó,
		és ilyenkor a memóriát akár
		egy másik könyvtárba is
		menthetjük.  A mentés méretét
		<literal>options
		MAXMEM=N</literal>
		beállítással is
		korlátozhatjuk, ahol az
		<replaceable>N</replaceable> értéke a
		rendszermag által használható
		memória mérete KB-okban.
		Például, ha 1&nbsp;GB RAM van a
		gépünkben, de a rendszermag által
		használható memóriát
		lekorlátozzuk 128&nbsp;MB-ra, akkor a
		mentés mérete sem 1&nbsp;GB lesz, hanem
		csak 128&nbsp;MB.</para>
	    </note>

	  <para>Ahogy sikerült hozzájutnunk a
	    memóriamentéshez, azonnal is
	    kérhetünk a &man.kgdb.1;
	    használatával egy hívási
	    láncot belõle:</para>

	  <screen>&prompt.user; <userinput>kgdb /usr/obj/usr/sys/RENDSZERMAGKONFIG/kernel.debug /var/crash/vmcore.0</userinput>
<prompt>(kgdb)</prompt> <userinput>backtrace</userinput></screen>

	  <para>Elõfordulhat, hogy ilyenkor több oldalnyi
	    információ özönlik hirtelen a
	    képernyõre, ezért javasolt ezeket
	    lementeni a &man.script.1; programmal.  A
	    nyomkövetési szimbólumokat is
	    tartalmazó rendszermag esetén még
	    akár azt a sort is megkapjuk a rendszermagon
	    belül, ahol a hiba történt.  A
	    hívási láncot általában
	    alulról felfelé kell olvasni, és
	    ebbõl deríthetõ, hogy pontosan milyen
	    események is vezettek az összeomláshoz.
	    A &man.kgdb.1; használatával még a
	    különbözõ változók
	    és struktúrák értékeit is
	    meg tudjuk vizsgálni, így még
	    többet megtudhatunk a rendszer
	    állapotáról az összeomlás
	    pillanatában.</para>

	  <tip>
	    <para>Ha az iméntiek mentén nagyon
	      fellelkesültünk volna és van egy
	      másik
	      számítógépünk is, akkor a
	      &man.kgdb.1; akár távoli
	      nyomkövetésre is
	      beállítható, aminek
	      köszönhetõen a &man.kgdb.1;
	      használatával az egyik rendszeren meg tudjuk
	      állítani a másikon futó
	      rendszermagot, ellenõrizhetjük a
	      viselkedését, akárcsak
	      bármelyik más felhasználói
	      program esetében.</para>
	  </tip>

	  <para>Ha netalán engedélyeztük volna a
	    <literal>DDB</literal> beállítást,
	    és a rendszermag beleáll a
	    nyomkövetõbe, akkor a rendszert mi magunk is
	    össze tudjuk omlasztani (és így a
	    memóriát elmenteni) a <literal>ddb</literal>
	    parancssorában a <literal>panic</literal> parancs
	    kiadásával.  Ilyenkor a nyomkövetõ
	    általában még egyszer megáll az
	    összeomláskor.  Ekkor a
	    <literal>continue</literal> paranccsal fejeztethetjük
	    be a memória lementését.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="dlsym-failure">
	  <para>A <function>dlsym()</function> függvény
	    miért nem mûködik már az ELF
	    állományokra?</para>
	</question>

	<answer>
	  <para>Az ELF állományokhoz tartozó
	    segédprogramok alapértelmezés szerint nem
	    teszik láthatóvá a dinamikus linker
	    számára a végrehajtható
	    állományban definiált
	    szimbólumokat.  Ennek eredményeképpen a
	    <function>dlsym()</function> a <function>dlopen(NULL,
	    flags)</function> függvénytõl kapott
	    információk alapján nem találja
	    meg a keresett szimbólumokat.</para>

	  <para>Ha szükségünk lenne ilyen
	    keresésekre a <function>dlsym()</function>
	    használata során a program
	    végrehajtható állományán
	    belül, akkor az adott programot a
	    <option>--export-dynamic</option> opció
	    megadásával kell linkelni (lásd
	    &man.ld.1;).</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="change-kernel-address-space">
	  <para>Hogyan növelhetõ vagy csökkenthetõ a
	    rendszermag címtere &i386;
	    architektúrán?</para>
	</question>

	<answer>
	  <para>Az &i386; platformon a rendszermag címtere
	    alapértelmezés szerint 1&nbsp;GB
	    (<acronym>PAE</acronym> esetén 2&nbsp;GB).  Ha
	    komolyabb hálózati forgalmat
	    bonyolító szerverünk van
	    (például egy nagyobb FTP vagy HTTP szerver)
	    vagy rendszerükön használni akarjuk a ZFS
	    állományrendszert, akkor könnyen
	    kifuthatunk a címtérbõl.</para>

	  <para>A címtér méretének
	    megváltoztatásához vegyük fel a
	    következõ sort a rendszermag
	    konfigurációs
	    állományába, majd fordítsuk
	    újra a rendszermagot:</para>

	  <programlisting>options KVA_PAGES=<replaceable>N</replaceable></programlisting>

	  <para>Az <replaceable>N</replaceable> megfelelõ
	    értékének
	    megállapításához osszuk el a
	    beállítani kívánt
	    címtér (MB-okban megadott)
	    méretét néggyel.  (Tehát
	    például 2&nbsp;GB esetén ez
	    <literal>512</literal> lesz.)</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter xml:id="acknowledgments" xml:lang="hu">
    <title>Köszönetnyilvánítás</title>

    <para>Ezt a szegény kis ártatlan GYIKocskát
      több százan, ha nem is éppen több ezren
      írták, újraírták,
      szerkesztették, hajtogatták, tekergették,
      csonkítgatták, kibelezték,
      nézegették, összekutyulták,
      emlegették, felöklendezték,
      újraépítették,
      javítgatták és felpezsdítették
      az utóbbi években.  Folyamatosan.</para>

    <para>Ezúton is szeretnénk köszönetet
      mondani mindazoknak, akik gondozásukba vették,
      és mindenkit csak bátorítani tudunk, hogy
      <link xlink:href="&url.articles.contributing.en;/article.html">csatlakozzon
      hozzájuk</link> a GYIK
      továbbfejlesztésében.</para>
  </chapter>

  &bibliography;
</book>
