<?xml version="1.0" encoding="euc-jp"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: r42932
     $FreeBSD$
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="updating-upgrading">
  <info><title>&os; のアップデートとアップグレード</title>
    <authorgroup>
      <author><personname><firstname>Jim</firstname><surname>Mock</surname></personname><contrib>再構成、再編成および改訂: </contrib></author>
      <!-- Mar 2000 -->
    </authorgroup>
    <authorgroup>
      <author><personname><firstname>Jordan</firstname><surname>Hubbard</surname></personname><contrib>原作: </contrib></author>
      <author><personname><firstname>Poul-Henning</firstname><surname>Kamp</surname></personname></author>
      <author><personname><firstname>John</firstname><surname>Polstra</surname></personname></author>
      <author><personname><firstname>Nik</firstname><surname>Clayton</surname></personname></author>
    </authorgroup>
    
  </info>

  

  <sect1 xml:id="updating-upgrading-synopsis">
    <title>この章では</title>

    <para>あるリリースから次のリリースまでの期間にも、
      &os; の開発は休みなく続けられています。
      最新の開発ツリーと同期することを好む人もいますし、
      公式のリリース版を好んで使う方もいます。
      しかしながら、公式のリリースといえども、
      セキュリティや他の重要な修正のため、時にはアップデートを行う必要があります。
      使用しているバージョンに関わらず、&os; は、
      手元のシステムを最新の開発ツリーと同期するために必要なツールをすべて用意しています。
      そして、これらのツールは、&os; のバージョンをアップグレードするために使えます。
      この章では、開発ブランチを追いかける方法、および、&os;
      システムをアップデートする基本的なツールについて解説しています。</para>

    <para>この章を読んで分かるのは:</para>

    <itemizedlist>
      <listitem>
	<para>システムと Ports Collection
	  のアップデートに用いるユーティリティについて</para>
      </listitem>

      <listitem>
	<para><application>freebsd-update</application>,
	  <application>Subversion</application> もしくは
	  <application>CTM</application>
	  を使った &os; システムの更新方法</para>
      </listitem>

      <listitem>
	<para>インストールされているシステムと、変更が行われていない状態との比較方法。</para>
      </listitem>

      <listitem>
	<para><application>Subversion</application>
	  またはドキュメント用の ports<!-- and
	  <application>Docsnap</application>--> を使って、
	  インストールされているドキュメントを最新のものにアップデートする方法。</para>
      </listitem>

      <listitem>
	<para>2 つの開発ブランチ、&os.stable; と &os.current; の違い</para>
      </listitem>

      <listitem>
	<para>ベースシステム全体を再構築しインストールする方法</para>
      </listitem>

    </itemizedlist>

    <para>この章を読む前に、以下の準備をしましょう。</para>

    <itemizedlist>
      <listitem>
	<para>ネットワーク接続の適切な設定 (<xref linkend="advanced-networking"/>)</para>
      </listitem>
      <listitem><para>サードパーティ製のソフトウェアのインストール方法の習得
        (<xref linkend="ports"/>)</para></listitem>
    </itemizedlist>

    <note>
      <para>この章を通じて、
	&os; のソースコードをダウンロードしたりアップデートするのに
	<command>svn</command> が用いられます。
	このコマンドを使うためには、<package>devel/subversion</package> port または package
	をインストールしておく必要があります。</para>
    </note>
  </sect1>

  <sect1 xml:id="updating-upgrading-freebsdupdate">
    <info><title>&os; Update</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>寄稿: </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Colin</firstname><surname>Percival</surname></personname><contrib>ベースとなったノートの提供: </contrib></author>
      </authorgroup>
    </info>
    

    <indexterm><primary>Updating and Upgrading</primary></indexterm>
    <indexterm>
      <primary>freebsd-update</primary>
      <see>updating-upgrading</see>
    </indexterm>

    <para>セキュリティパッチを適用することは、コンピュータソフトウェア、
      特にオペレーティングシステムを管理する上で重要な役割を果たします。
      しかしながら、&os; においては、
      このプロセスは簡単なものではありませんでした。
      ソースコードにパッチを当て、コードからバイナリを再構築し、
      バイナリを再びインストールする必要がありました。</para>

    <para>現在の &os; では <command>freebsd-update</command>
      と呼ばれるユーティリティが追加され、状況は変わりました。
      このユーティリティは 2 つの機能を持っています。
      第一に、&os; ベースシステムのビルドやインストールを行うことなく、
      バイナリによってセキュリティおよび eratta アップデートできます。
      第二に、このユーティリティはマイナーおよびメジャーリリースのアップグレードに対応しています。</para>

    <note>
      <para>バイナリアップデートは、
	セキュリティチームがサポートしているすべてのアーキテクチャとリリースで利用できます。
	新しいリリースにアップデートする前に、
	アップデートしようとしているリリースのアナウンスに目を通し、
	重要な情報がないかどうかを確認してください。
	リリースのアナウンスは
	<uri xlink:href="http://www.FreeBSD.org/ja/releases/">http://www.FreeBSD.org/ja/releases/</uri>
	で確認できます。</para>
    </note>

    <para>もし <command>crontab</command> の中に
      &man.freebsd-update.8; の機能が含まれていたら、
      以下の作業を行うまでは無効にしておいてください。</para>

    <sect2 xml:id="freebsdupdate-config-file">
      <title>設定ファイル</title>

      <para><filename>/etc/freebsd-update.conf</filename>
	の設定をデフォルトからきめ細かく調整して、
	アップデートプロセスを制御するユーザもいます。
	この作業は良く文書化されていますが、
	以下の項目については説明が必要でしょう。</para>

      <programlisting># Components of the base system which should be kept updated.
Components src world kernel</programlisting>

      <para>このパラメータは、&os; のどの部分を最新に維持するかを設定します。
	デフォルトではソースコード、ベースシステム全体、そしてカーネルをアップデートします。
	Components に設定できる項目は、インストール時に選択できるものと同じです。
	たとえば、ここで <literal>world/games</literal> を追加すると、
	game にパッチが当たるようになります。
	<literal>src/bin</literal> を追加すると、
	<filename>src/bin</filename>
	ソースコードのアップデートを許可します。</para>

      <para>この部分についてはデフォルトのままにしておき、
	アップデートする項目をユーザがリストに加える形にするのがベストでしょう。
	ソースコードとバイナリが同期していないと、
	悲惨な結果をもたらす可能性があります。</para>

      <programlisting># Paths which start with anything matching an entry in an IgnorePaths
# statement will be ignored.
IgnorePaths</programlisting>

      <para><filename>/bin</filename> や
	<filename>/sbin</filename>
	等の特定のディレクトリをアップデートで変更しないように、
	これらのパスを追加してください。
	このオプションは、ローカルの変更点を <command>freebsd-update</command>
	が上書きすることを防ぐ目的にも利用できます。</para>

      <programlisting># Paths which start with anything matching an entry in an UpdateIfUnmodified
# statement will only be updated if the contents of the file have not been
# modified by the user (unless changes are merged; see below).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</programlisting>

      <para>このオプションは、指定したディレクトリにある設定ファイルを、
	ローカルで変更されていない場合のみアップデートします。
	ユーザがこれらのファイルを変更していると、
	これらのファイルの自動アップデートは無効になります。
	他に、<literal>KeepModifiedMetadata</literal>
	という別のオプションが存在します。
	このオプションは、<command>freebsd-update</command>
	がマージ中に変更点を保存するようにします。</para>

      <programlisting># When upgrading to a new &os; release, files which match MergeChanges
# will have any local changes merged into the version from the new release.
MergeChanges /etc/ /var/named/etc/</programlisting>

      <para><command>freebsd-update</command>
	がマージすべきファイルが存在するディレクトリの一覧です。
	ファイルのマージのプロセスは、
	&man.mergemaster.8; と同様 &man.diff.1; パッチの連続ですが、
	選択肢は少なく、マージを承認するか、エディタを起動するか、
	<command>freebsd-update</command>
	を中断するかどうかを選んでください。
	もし、心配な点があれば、
	<filename>/etc</filename>
	をバックアップしてからマージを承認してください。
	<command>mergemaster</command> の詳細な情報については、
	<xref linkend="mergemaster"/> で確認してください。</para>

      <programlisting># Directory in which to store downloaded updates and temporary
# files used by &os; Update.
# WorkDir /var/db/freebsd-update</programlisting>

      <para>ここではすべてのパッチや一次ファイルを置くディレクトリを指定しています。
	バージョンをアップグレードするのであれば、
	この場所には少なくともギガバイトの空き容量が必要です。</para>

      <programlisting># When upgrading between releases, should the list of Components be
# read strictly (StrictComponents yes) or merely as a list of components
# which *might* be installed of which &os; Update should figure out
# which actually are installed and upgrade those (StrictComponents no)?
# StrictComponents no</programlisting>

      <para>このオプションを <literal>yes</literal> に設定すると、
	<command>freebsd-update</command> は
	<literal>Components</literal> のリストが完全に正しいと判断し、
	このリスト以外の変更点については取り扱いません。
	<command>freebsd-update</command> は、効率的に
	<literal>Components</literal>
	リストに属するファイルをアップデートします。</para>
    </sect2>

    <sect2 xml:id="freebsdupdate-security-patches">
      <title>セキュリティパッチ</title>

      <para>以下のコマンドを実行すると、&os;
	のセキュリティパッチがダウンロードされ、インストールされます。</para>

      <screen>&prompt.root; <userinput>freebsd-update fetch</userinput>
&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>アップデートによってカーネルにパッチが当たった場合には、
	パッチが当たったカーネルで起動するように、
	システムを再起動する必要があります。
	もしくは、システムにパッチが当てられ、
	毎晩の &man.cron.8; ジョブとして、<command>freebsd-update</command>
	を実行するように、
	以下のエントリを <filename>/etc/crobntab</filename>
	に追加してください。</para>

      <programlisting>@daily                                  root    freebsd-update cron</programlisting>

      <para>このエントリは、毎日一度 <command>freebsd-update</command>
	を実行することを意味します。
	<option>cron</option> と共に実行すると、
	<command>freebsd-update</command>
	はアップデートが存在するときだけ確認します。
	パッチが存在すると、
	自動的にローカルディスクにダウンロードされますが、適用はされません。
	ダウンロードされたパッチを確認し、手動でインストールする必要のあることが、
	<systemitem class="username">root</systemitem> 宛てにメールで通知されます。</para>

      <para>うまく行かなかった場合には、<command>freebsd-update</command>
	を以下のように実行すると、最後の変更までロールバックできます。</para>

      <screen>&prompt.root; <userinput>freebsd-update rollback</userinput></screen>

      <para>カーネルまたはカーネルモジュールがアップデートされた場合には、
	完了後にシステムを再起動してください。
	この作業によって、&os; がバイナリをメモリに読み込みます。</para>

      <para><command>freebsd-update</command>
	ユーティリティが自動的にアップデートするカーネルは
	<filename>GENERIC</filename> のみです。
	カスタムカーネルがインストールされている場合には、
	<command>freebsd-update</command> が他の部分をインストールした後、
	カーネルを再構築し、もう一度インストールする必要があります。
	しかしながら、<filename>GENERIC</filename> カーネルが <filename>/boot/GENERIC</filename>
	に存在する場合には、
	現在のシステムで実行されているカーネルでなくとも、
	<command>freebsd-update</command>
	によりアップデートされます。</para>

      <note>
	<para><filename>GENERIC</filename> カーネルを、常に <filename>/boot/GENERIC</filename>
	  に置いておくことは良い考えです。
	  さまざまな問題を解決する際や、
	  <xref linkend="freebsdupdate-upgrade"/> に説明されているように、
	  <command>freebsd-update</command>
	  を用いてバージョンをアップグレードする際に助けとなります。</para>
      </note>

      <para><filename>/etc/freebsd-update.conf</filename>
	のデフォルトの設定を変更しない限り、
	<command>freebsd-update</command> は、
	他の更新と共にカーネルソースをアップデートします。
	新しいカスタムカーネルの再構築と再インストールは、
	通常通り行うことができます。</para>

      <note>
	<para><command>freebsd-update</command> は、
	  常にカーネルをアップデートするとは限りません。
	  <command>freebsd-update install</command>
	  によってカーネルソースが変更されなかった場合には、
	  カスタムカーネルを再構築する必要はありません。
	  しかしながら <command>freebsd-update</command> は、
	  <filename>/usr/src/sys/conf/newvers.sh</filename>
	  を常にアップデートします。
	  これは、現在のシステムのパッチレベルを
	  <command>uname -r</command> が <literal>-p</literal>
	  で表示する時にこのファイルが参照されます。
	  そのため、何も変更されていない場合でも、カスタムカーネルを再構築することにより、
	  &man.uname.1; がシステムの正確なパッチレベルを報告するようになります。
	  各システムにインストールされているアップデートをすばやく把握できるようになるので、
	  特に複数のシステムを管理するときに助けとなります。</para>
      </note>
    </sect2>

    <sect2 xml:id="freebsdupdate-upgrade">
      <title>メジャーおよびマイナーバージョンのアップグレード</title>

      <para>&os; のマイナーバージョン間のアップグレード、
	たとえば、&os;&nbsp;9.0 から &os;&nbsp;9.1 へのアップグレードは、
	<emphasis>マイナーバージョン</emphasis> アップグレードと呼ばれます。
	通常は、マイナーバージョンのアップグレードを行った後でも、
	インストールされているアプリケーションは問題なく動きます。</para>

      <para><emphasis>メジャーバージョン</emphasis> アップグレードは、
	&os;&nbsp;8.X から &os;&nbsp;9.X へのアップグレードといった、
	&os; のメジャーバージョンが変わるようなアップグレードのことです。
	メジャーバージョンのアップグレードでは、
	古いオブジェクトファイルやライブラリが削除され、
	これらに依存する多くのサードパーティ製アプリケーションに影響を与える可能性があります。
	インストールされているすべての ports を削除して再インストールするか、
	メジャーアップグレード後、
	<package>ports-mgmt/portmaster</package>
	といったユーティリティを使ってアップグレードすることが推奨されています。
	インストールされているアプリケーションのブルートフォース的な再構築は、
	以下のコマンドにより行うことができます。</para>

      <screen>&prompt.root; <userinput>portmaster -af</userinput></screen>

      <para>このコマンドは、すべての ports を適切に再インストールしようとします。
	<varname>BATCH</varname> 環境変数を
	<literal>yes</literal> に設定しておくと、
	アップデートプロセスの途中の質問に対し
	<literal>yes</literal> と答えるようになるので、
	ビルドプロセスでの手動操作を省略できます。</para>

      <sect3 xml:id="freebsd-update-custom-kernel">
	<title>カスタムカーネルの取り扱い</title>

	<para>カスタムカーネルを使用している場合には、アップグレードのプロセスは、
	  幾分複雑となります。
	  アップグレードの手順は &os; のバージョンによって変わります。</para>

	<sect4 xml:id="freebsd-update-custom-kernel-8x">
	  <title>&os;&nbsp;8.X におけるカスタムカーネル</title>

	  <para><filename>GENERIC</filename> カーネルが
	    <filename>/boot/GENERIC</filename>
	    に置かれている必要があります。
	    もし <filename>GENERIC</filename>
	    カーネルがシステムに存在しない場合には、 
	    以下のどれかの方法で用意してください。</para>

	  <itemizedlist>
	    <listitem>
	      <para>ただ一度だけカスタムカーネルを構築したのであれば、
		<filename>/boot/kernel.old</filename>
		は <filename>GENERIC</filename> カーネルそのものです。
		このディレクトリの名前を
		<filename>/boot/GENERIC</filename>
		へと変更してください。</para>
	    </listitem>

	    <listitem>
	      <para>コンピュータへの物理的なアクセスが可能であれば、
		以下のコマンドを実行することで、
		インストールメディアから <filename>GENERIC</filename>
		カーネルをインストールできます。</para>

	      <screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>cd /cdrom/X.Y-RELEASE/kernels</userinput>
&prompt.root; <userinput>./install.sh GENERIC</userinput></screen>

	      <para>ここで <filename>X.Y-RELEASE</filename>
		を実際のリリース番号に置き換えてください。
		<filename>GENERIC</filename> は、デフォルトで <filename>/boot/GENERIC</filename>
		にインストールされます。</para>
	    </listitem>

	    <listitem>
	      <para>上記の方法がすべて失敗するのであれば、
		<filename>GENERIC</filename> カーネルをソースから再構築して、
		インストールしてください。</para>

	      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>env DESTDIR=/boot/GENERIC make kernel __MAKE_CONF=/dev/null SRCCONF=/dev/null</userinput>
&prompt.root; <userinput>mv /boot/GENERIC/boot/kernel/* /boot/GENERIC</userinput>
&prompt.root; <userinput>rm -rf /boot/GENERIC/boot</userinput></screen>

	      <para><command>freebsd-update</command> は、このカーネルを
		<filename>GENERIC</filename> カーネルとして扱います。
		<filename>GENERIC</filename> コンフィグレーションファイルは、
		とにかく変更してはいけません。
		また、特別なオプションを指定しないで構築してください。</para>
	    </listitem>
	  </itemizedlist>

	  <para>この時点で <filename>GENERIC</filename>
	    カーネルで再起動する必要はありません。</para>
	</sect4>

	<sect4 xml:id="freebsd-update-custom-kernel-9x">
	  <title>&os;&nbsp;9.X 以降のシステムにおけるカスタムカーネル</title>

	  <itemizedlist>
	    <listitem>
	      <para>ただ一度だけカスタムカーネルを構築したのであれば、
		<filename>/boot/kernel.old</filename>
		は <filename>GENERIC</filename> カーネルそのものです。
		ただ単にこのディレクトリの名前を
		<filename>/boot/kernel</filename>
		へと変更してください。</para>
	    </listitem>

	    <listitem>
	      <para>コンピュータへの物理的なアクセスが可能であれば、
		以下のコマンドで、インストールメディアから
		<filename>GENERIC</filename>
		カーネルをインストールできます。</para>

	      <screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>cd /cdrom/usr/freebsd-dist</userinput>
&prompt.root; <userinput>tar -C/ -xvf kernel.txz boot/kernel/kernel</userinput></screen>
	    </listitem>

	    <listitem>
	      <para>上記の方法が失敗するのであれば、
		<filename>GENERIC</filename> カーネルをソースから再構築して、
		インストールしてください。</para>

	      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make kernel __MAKE_CONF=/dev/null SRCCONF=/dev/null</userinput></screen>

	      <para><command>freebsd-update</command> は、このカーネルを
		<filename>GENERIC</filename> カーネルとして扱います。
		<filename>GENERIC</filename> コンフィグレーションファイルは、
		とにかく変更してはいけません。
		また、特別なオプションを指定しないで構築してください。</para>
	    </listitem>
	  </itemizedlist>

	  <para>この時点で <filename>GENERIC</filename>
	    カーネルで再起動する必要はありません。</para>
	</sect4>
      </sect3>

      <sect3 xml:id="freebsdupdate-using">
	<title>アップグレードを行う</title>

	<para><command>freebsd-update</command>
	  によるメジャー、またはマイナーバージョンのアップデートでは、
	  リリースバージョンをターゲットにして実行します。
	  以下のコマンドは、&os;&nbsp;9.1 にアップデートします。</para>

	<screen>&prompt.root; <userinput>freebsd-update -r 9.1-RELEASE upgrade</userinput></screen>

	<para>コマンドを実行すると、<command>freebsd-update</command>
	  は設定ファイルと現在のシステムを評価し、
	  アップデートするために必要な情報を収集します。
	  画面には、どのコンポーネントが認識され、
	  どのコンポーネントが認識されていないといったリストが表示されます。
	  たとえば以下のように表示されます。</para>

	<screen>Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature for 9.0-RELEASE from update1.FreeBSD.org... done.
Fetching metadata index... done.
Inspecting system... done.

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD do not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable (y/n)? y</screen>

	<para>ここで、<command>freebsd-update</command>
	  はアップグレードに必要なすべてのファイルをダウンロードします。
	  何をインストールし、どのように進むかといった質問をされることもあります。</para>

	<para>カスタムカーネルを使っていると、
	  上記のステップで以下のような警告が表示されます。</para>

	<screen>WARNING: This system is running a "<replaceable>MYKERNEL</replaceable>" kernel, which is not a
kernel configuration distributed as part of FreeBSD 9.0-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running "/usr/sbin/freebsd-update install"</screen>

	<para>この時点ではこの警告を無視してもかまいません。
	  アップデートされた <filename>GENERIC</filename> カーネルは、
	  アップグレードプロセスの途中で利用されます。</para>

	<para>すべてのパッチがローカルシステムへダウンロードされたら、
	  次にパッチが適用されます。
	  このプロセスには時間がかかります。
	  この時間はコンピュータの性能とワークロードに依存します。
	  その後、設定ファイルがマージされます。
	  このプロセスでは、ユーザはファイルをマージするか、
	  画面上にエディタを立ち上げて手動でマージするかを尋ねられます。
	  プロセスが進むごとに、成功したマージのすべての結果の情報がユーザに示されます。
	  マージに失敗したり、無視した場合には、プロセスが中断します。
	  ユーザによっては <filename>/etc</filename>
	  のバックアップを取り、
	  <filename>master.passwd</filename> や <filename>group</filename>
	  のような重要なファイルを後で手動でマージする方もいます。</para>

	<note>
	  <para>すべてのパッチは別のディレクトリでマージされており、
	    まだ、システムには反映されていません。
	    すべてのパッチが正しく適用され、
	    すべての設定ファイルがマージされてプロセスがスムーズに進んだら、
	    ユーザは以下のコマンドを用いて、
	    変更点をディスクに反映してください。</para>

	<screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

	</note>

	<para>パッチは最初にカーネルとカーネルモジュールに対して当てられます。
	  ここでコンピュータを再起動する必要があります。
	  システムがカスタムカーネルを実行している場合には、
	  &man.nextboot.8; を使って次回の再起動時のカーネルを、
	  アップデートされた <filename>/boot/GENERIC</filename>
	  に設定してください。</para>

	<screen>&prompt.root; <userinput>nextboot -k GENERIC</userinput></screen>

	<warning>
	  <para><filename>GENERIC</filename> カーネルで再起動する前に、
	    カーネルにシステムが適切に起動するために必要なすべてのドライバが含まれていること、
	    もしアップデートしているコンピュータがリモートでアクセスしているのであれば、
	    ネットワーク接続に必要なすべてのドライバも含まれていることを確認してください。
	    特に、これまで実行しているカスタムカーネルが、
	    カーネルモジュールとして提供されているビルドインの機能を含んでいるのであれば、
	    これらのモジュールを一時的に <filename>/boot/loader.conf</filename>
	    の機能を用いて、
	    <filename>GENERIC</filename> に読み込んでください。
	    アップグレードプロセスが終わるまでは、
	    重要ではないサービスを無効にするとともに、
	    必要のないディスクやネットワークのマウントなども避けることが推奨されています。</para>
	</warning>

	<para>アップデートされたカーネルでコンピュータを再起動してください。</para>

	<screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>

	<para>システムがオンラインに戻ったら、以下のコマンドを使って
	  <command>freebsd-update</command> を再び実行してください。
	  アップデートプロセスの状態は保存されているので、
	  <command>freebsd-update</command> を実行すると、最初からではなく、
	  古い共有ライブラリとオブジェクトファイルを削除するプロセスから始まります。</para>

	<screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

	<note>
	  <para>使用しているライブラリのバージョン番号の付けられ方によって、
	    3 つのインストールフェーズが 2 つになる場合もあります。</para>
	</note>
      </sect3>

      <sect3 xml:id="freebsdupdate-portsrebuild">
	<title>メジャーバージョンアップグレード後の ports の再構築</title>

	<para>メジャーバージョンアップグレードを行った後では、
	  すべてのサードパーティ製のソフトウェアを再構築し、
	  再インストールする必要があります。
	  この作業が必要なのは、インストールされているソフトウェアが、
	  アップグレードの際に削除されたライブラリに依存している可能性があるためです。
	  <package>ports-mgmt/portupgrade</package>
	  は、このプロセスを自動化します。</para>

	<screen>&prompt.root; <userinput>portmaster -f</userinput></screen>

	<para>この作業の終了後、最後にもう一度
	  <command>freebsd-update</command>
	  を実行して、
	  すべてのアップグレードプロセスのやり残し作業を行い、
	  アップグレードのプロセスを完了してください。</para>

	<screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

	<para><filename>GENERIC</filename>
	  カーネルを一時的に読み込んでいたのであれば、
	  ここで、通常の方法を用いて新しいカスタムを構築し、インストールしてください。</para>

	<para>コンピュータを再起動し、新しい &os; を立ち上げてください。
	  これでアップグレードのプロセスは完了です。</para>
      </sect3>
    </sect2>

    <sect2 xml:id="freebsdupdate-system-comparison">
      <title>システムの状態の比較</title>

      <para><command>freebsd-update</command> を用いて、
	インストールされている &os; の状態と、
	正しく動作することが分かっている状態とを比較できます。
	このオプションは、システムのユーティリティ、ライブラリ、
	設定ファイルを評価します。
	比較を行うには、以下のコマンドを実行してください。</para>

      <screen>&prompt.root; <userinput>freebsd-update IDS &gt;&gt; outfile.ids</userinput></screen>

      <warning>
	<para>コマンドライン名は <acronym>IDS</acronym> ですが、
	  <package>security/snort</package>
	  のような侵入検知システムの本当の置き換えになるものではありません。
	  <command>freebsd-update</command> はデータをディスクに保存するので、
	  不正な変更が行われる可能性があります。
	  <varname>kern.securelevel</varname> と、
	  <command>freebsd-update</command> のデータを使用しないときに、
	  読み取りのみの許可属性に設定されているファイルシステムに置くことで、
	  不正な変更の可能性を低くできますが、
	  よりよい解決方法は、
	  <acronym>DVD</acronym>
	  または安全に保存されている外部 <acronym>USB</acronym>
	  ディスクのような安全なディスクとシステムを比較することです。</para>
      </warning>

      <para>このコマンドを実行すると、システムは検査され、
	リリースファイルの &man.sha256.1;
	ハッシュ値と現在インストールされているファイルのハッシュ値がファイルの一覧と共に、指定した
	<filename>outfile.ids</filename> ファイルに送られます。</para>

      <para>これらの行は極めて長いのですが、出力形式は簡単にすぐに解析できます。
	たとえば、これらのリリースで異なっているすべてのファイルを知りたいのであれば、
	以下のコマンドを実行してください。</para>

      <screen>&prompt.root; <userinput>cat outfile.ids | awk '{ print $1 }' | more</userinput>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</screen>

      <para>上の表示例では出力は切り捨てられており、
	実際にはもっと多くのファイルが存在します。
	これらのファイルには、運用中に変更されるファイルがあります。
	たとえば、<filename>/etc/passwd</filename>
	はユーザがシステムに追加されると変更されます。
	また、カーネルモジュールのようなファイルは、
	<command>freebsd-update</command>
	によりアップデートされるため、変更されます。
	このような特別なファイルやディレクトリを除外するには、
	それらを <filename>/etc/freebsd-update.conf</filename> の
	<literal>IDSIgnorePaths</literal> オプションに追加してください。</para>

      <para>以前に議論した方法とは別に、
	このシステムを入念なアップグレード方法の一部として用いることができます。</para>
    </sect2>
  </sect1>

  <sect1 xml:id="updating-upgrading-portsnap">
    <info><title>Portsnap: Ports Collection アップデートツール</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>寄稿: </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Colin</firstname><surname>Percival</surname></personname><contrib>ベースとなったノートの提供: </contrib></author>
      </authorgroup>
    </info>
    

    <indexterm><primary>アップデートとアップグレード</primary></indexterm>
    <indexterm>
      <primary>Portsnap</primary>
      <see>アップデートとアップグレード</see>
    </indexterm>

    <para>&os; のベースシステムには、
      Ports Collection をアップデートする &man.portsnap.8; があります。
      このユーティリティは、&os; のサイトに接続し、セキュリティキーを検証し、
      Ports Collection の最新版をダウンロードします。
      セキュリティキーは、
      ダウンロードしたすべてのファイルの検証に用いられます。
      最新の Ports Collection ファイルをダウンロードするには、
      以下のコマンドを実行してください。</para>

    <screen>&prompt.root; <userinput>portsnap fetch</userinput>
Looking up portsnap.FreeBSD.org mirrors... 9 mirrors found.
Fetching snapshot tag from geodns-1.portsnap.freebsd.org... done.
Fetching snapshot metadata... done.
Updating from Tue May 22 02:12:15 CEST 2012 to Wed May 23 16:28:31 CEST 2012.
Fetching 3 metadata patches.. done.
Applying metadata patches... done.
Fetching 3 metadata files... done.
Fetching 90 patches.....10....20....30....40....50....60....70....80....90. done.
Applying patches... done.
Fetching 133 new ports or files... done.</screen>

    <para>この例では、&man.portsnap.8;
      が現在の ports に対するパッチを見つけ、検証したことを示しています。
      また、ユーティリティは以前に実行していることも示しています。
      もし初めて実行したのであれば、Ports Collection のダウンロードのみが行われます。</para>

    <para>&man.portsnap.8; が <command>fetch</command> に成功すると、
      検証を通った Ports Collection と、
      それに続くパッチがローカルシステムに存在します。
      はじめて <command>portsnap</command> を実行した時には、
      <literal>extract</literal> を使って、
      ダウンロードしたファイルをインストールしてください。</para>

    <screen>&prompt.root; <userinput>portsnap extract</userinput>
/usr/ports/.cvsignore
/usr/ports/CHANGES
/usr/ports/COPYRIGHT
/usr/ports/GIDs
/usr/ports/KNOBS
/usr/ports/LEGAL
/usr/ports/MOVED
/usr/ports/Makefile
/usr/ports/Mk/bsd.apache.mk
/usr/ports/Mk/bsd.autotools.mk
/usr/ports/Mk/bsd.cmake.mk
<replaceable>...</replaceable></screen>

    <para>すでにインストールされている Ports Collection
      をアップデートするには、
      <command>portsnap update</command> を使ってください。</para>

    <screen>&prompt.root; <userinput>portsnap update</userinput></screen>

    <para>これでアップデートプロセスは完了しました。
      更新された Ports Collection を使って、
      アプリケーションをインストールしたり、
      アップグレードできます。</para>

    <para><literal>fetch</literal> を使う場合には、
      <literal>extract</literal> および <literal>update</literal>
      を連続して行うことができます。</para>

    <screen>&prompt.root; <userinput>portsnap fetch update</userinput></screen>

    <para>このコマンドにより最新の
      Ports Collection がダウンロードされ、
      <filename>/usr/ports</filename>
      以下にあるローカルの Ports Collection がアップデートされます。</para>
  </sect1>

  <sect1 xml:id="updating-upgrading-documentation">
    <title>ドキュメントのアップデート</title>

    <indexterm><primary>Updating and Upgrading</primary></indexterm>

    <indexterm>
      <primary>Documentation</primary>
      <see>Updating and Upgrading</see>
    </indexterm>

    <para>ドキュメントは、&os; オペレーティングシステムの必須要素です。
      &os; ドキュメントセットの最新バージョンは、<link xlink:href="http://www.freebsd.org/doc/">&os; ウェブサイト</link>
      から入手できますが、
      ネットワーク接続が遅い、もしくはまったく接続できないユーザもいます。
      ローカルのドキュメントを最新の &os;
      ドキュメントセットにアップデートする方法がいくつも用意されています。</para>

    <sect2 xml:id="dsvn-doc">
      <title><application>Subversion</application>
	を用いたドキュメントのアップデート方法</title>

      <para>&os; のドキュメントのソースは、
	<application>svn</application> を用いて入手できます。
	この節では以下について説明します。</para>

      <itemizedlist>
	<listitem>
	  <para>ドキュメントツールチェインのインストール方法。
	    このツールは、&os;
	    のドキュメントをソースから再構築するのに必要です。</para>
	</listitem>

	<listitem>
	  <para><application>svn</application> を用いて、
	    ドキュメントのソースを
	    <filename>/usr/doc</filename>
	    以下にダウンロードする方法。</para>
	</listitem>

	<listitem>
	  <para>&os; ドキュメントをソースから再構築し、
	    <filename>/usr/share/doc</filename>
	    以下にインストールする方法。</para>
	</listitem>

	<listitem>
	  <para>ドキュメントのビルドシステムにおいてサポートされているビルドオプションの説明。
	    たとえば、翻訳されたドキュメンテーションのみを構築するオプションや、
	    ある特定の出力フォーマットを指定するようなオプションについて説明します。</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2 xml:id="installing-documentation-toolchain">
      <title><application>svn</application>
	およびドキュメントツールチェインのインストール</title>

      <para>&os; のドキュメントをソースから再構築するには、
	ツールのコレクションが必要です。
	これらのツールは多くのディスク容量を使用するため、
	&os; ベースシステムの一部ではありません。
	また、すべての &os; ユーザにとって有用というわけではなく、&os;
	のために新しいドキュメントを活発に執筆している方や、
	頻繁にドキュメントをソースからアップデートする方に向けたものです。</para>

      <para><application>svn</application> を含め必要なツールは、
	<package>textproc/docproj</package> メタ port 
	からインストールできます。この port は、
	&os; ドキュメンテーションプロジェクトにより開発されています。</para>

      <note>
	<para>ドキュメントの &postscript; や PDF 版が必要なければ、かわりに
	  <package>textproc/docproj-nojadetex</package>
	  をインストールすることも考えてよいでしょう。
	  このドキュメンテーションのツールチェインは、
	  <application>teTeX</application>
	  と呼ばれる組版エンジンを除いたすべてをインストールします。
	  <application>teTeX</application> は大きなツールのコレクションです。
	  そのため、もし PDF 出力を本当に必要としなければ、
	  このツールをインストールしないことはとても賢明です。</para>
      </note>
    </sect2>

    <sect2 xml:id="updating-documentation-sources">
      <title>ドキュメントのソースをアップデートする</title>

      <para>以下の例では、<application>svn</application> を使って
	western US ミラーから HTTPS プロトコルを用いて、
	ドキュメントのソースをダウンロードします。</para>

      <screen>&prompt.root; <userinput>svn checkout https://svn0.us-west.FreeBSD.org/doc/head /usr/doc</userinput></screen>

      <para>利用可能な <link linkend="svn-mirrors">Subversion ミラーサイト</link>
	の中からもっとも近いミラーを使ってください。</para>

      <para>最初にドキュメントのソースをダウンロードするには少し時間がかかります。
	ダウンロードが終わるまでお待ちください。</para>

      <para>ダウンロードしたドキュメントのソースをアップデートするには、
	以下のコマンドを実行してください。</para>

      <screen>&prompt.root; <userinput>svn update /usr/doc</userinput></screen>

      <para>ソースを入手したら、
	<filename>/usr/doc/Makefile</filename> を使い、
	以下のようにドキュメントをアップデートすることもできます。</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make update</userinput></screen>
    </sect2>

    <sect2 xml:id="updating-documentation-options">
      <title>ドキュメントのソースの調整可能なオプション</title>

      <para>&os; のドキュメントセットのアップデートとビルドシステムは、
	ドキュメンテーションの一部のアップデートを簡単にするオプションや、
	特定の翻訳のビルドに対応しています。
 	これらのオプションは、システム全般のオプションである
	<filename>/etc/make.conf</filename> や、&man.make.1;
	に与えるコマンドラインオプションで設定できます。</para>

      <para>オプションには以下のようなものがあります。</para>

      <variablelist>
	<varlistentry>
	  <term><varname>DOC_LANG</varname></term>

	  <listitem>
	    <para>ビルドおよびインストールの言語およびエンコーディングの一覧。
	      たとえば、英語のドキュメントを指定するには
	      <literal>en_US.ISO8859-1</literal> を設定します。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>FORMATS</varname></term>

	  <listitem>
	    <para>ビルドを行うフォーマット、または出力フォーマットの一覧。
	      現在は <literal>html</literal>,
	      <literal>html-split</literal>, <literal>txt</literal>,
	      <literal>ps</literal>, <literal>pdf</literal>,
	      そして <literal>rtf</literal> に対応しています。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>DOCDIR</varname></term>

	  <listitem>
	    <para>ドキュメントをインストールする場所。デフォルトは
	      <filename>/usr/share/doc</filename> です。</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>&os; のシステム全般のオプションに関連するもっと多くの
	<command>make</command> 変数については、
	&man.make.conf.5; をご覧ください。</para>

      <para>&os; ドキュメントのビルドシステムで対応しているさらなる
	<command>make</command> の変数に関しては、
	<link xlink:href="&url.doc.langbase.en;/books/fdp-primer">新しい貢献者のための &os; ドキュメンテーションプロジェクト入門 </link> を参照してください。</para>
    </sect2>

    <sect2 xml:id="updating-installed-documentation">
      <title>ソースから &os; ドキュメントをインストールする</title>

      <para>ドキュメントのソースの最新スナップショットを
	<filename>/usr/doc</filename> にダウンロードしたら、
	インストールされているドキュメントをアップデートする準備がすべて整いました。</para>

      <para><varname>DOC_LANG</varname>
	で定義されているすべての言語を完全にアップデートするには、
	以下のように入力してください。</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>もし、ある特定の言語のみをアップデートしたいのであれば、
	<filename>/usr/doc</filename>
	サブディレクトリで以下のように &man.make.1; を実行してください。</para>

      <screen>&prompt.root; <userinput>cd /usr/doc/en_US.ISO8859-1</userinput>
&prompt.root; <userinput>make update install clean</userinput></screen>

      <para><varname>FORMATS</varname> を設定して、
	以下のようにインストールする出力形式を指定できます。</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make FORMATS='html html-split' install clean</userinput></screen>

      <para>ドキュメントを編集したり、訂正したものを提出する方法については、
	<link xlink:href="&url.books.fdp-primer;">新しい貢献者のための &os;
	ドキュメンテーションプロジェクト入門</link> をご覧ください。</para>
    </sect2>

    <sect2 xml:id="doc-ports">
      <info><title>ドキュメンテーション ports</title>
	<authorgroup>
	  <author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>ベースとなった作業:</contrib></author>
	</authorgroup>
      </info>

      

      <indexterm><primary>Updating and Upgrading</primary></indexterm>

      <indexterm>
	<primary>documentation package</primary>
	<see>Updating and Upgrading</see>
      </indexterm>

      <para>これまでのセクションでは、ソースコードを用いた &os;
	ドキュメントのアップデート方法について説明してきました。
	すべての &os; システムで、
	ソースからドキュメントをアップデートすることは難しいかも知れませんし、
	できたとしても現実的ではないこともあります。
	ドキュメントをソースから構築するには、
	かなり大きなツールとユーティリティから構成される
	<emphasis>ドキュメンテーションツールチェイン</emphasis>
	が必要なためです。
	また、<application>svn</application>
	リポジトリからソースをチェックアウトし、
	チェックアウトしたソースからドキュメントを手動で構築する方法について、
	それなりに熟知している必要もあります。
	この節では、インストールされている
	&os; のドキュメントをアップデートするもう一つの方法である、
	Ports Collection を用いた方法について説明し、
	以下について説明します。</para>

      <itemizedlist>
	<listitem>
	  <para>構築済のドキュメントのスナップショットをダウンロードしてインストールする方法。
	    ローカルでの構築作業やドキュメンテーションツールチェインをインストールする必要はありません。</para>
	</listitem>

	<listitem>
	  <para>ドキュメントのソースをダウンロードし、ports
	    フレームワークを使って構築する方法です。
	    チェックアウトおよび構築作業が簡単になります。</para>
	</listitem>
      </itemizedlist>

      <para>&os; のドキュメントをアップデートするこれらの方法は、
	&a.doceng; が毎月アップデートしている
        <emphasis>ドキュメンテーション ports</emphasis>
	によりサポートされています。
	これらの ports は、&os; Ports&nbsp;Collection の <link xlink:href="http://www.freshports.org/docs/">docs</link>
	カテゴリにまとめられています。</para>

      <sect3 xml:id="doc-ports-install-make">
	<title>ドキュメンテーション ports の構築とインストール</title>

	<para>ドキュメンテーション ports では、
	  ports の構築フレームワークが用いられるので、
	  ドキュメントを簡単に構築できます。
	  この ports は、ドキュメントのソースを自動的にチェックアウトし、
	  環境変数やコマンドラインオプションを適切に設定して &man.make.1;
	  を実行します。
	  また、他の &os; port, package のインストールと同様に簡単な方法で、
	  ドキュメントのインストールやアンインストールを行うことができます。</para>

	<note>
	  <para>追加の機能として、この ports は
	    <emphasis>ドキュメンテーションツールチェイン</emphasis> ports
	    への依存を理解しているので、
	    構築時にはドキュメンテーションツールチェインも自動的にインストールされます。</para>
	</note>

	<para>ドキュメンテーション ports の構成は以下の通りです。</para>

	<itemizedlist>
	  <listitem>
	    <para><quote>マスタ port</quote>, <package>misc/freebsd-doc-en</package>。
	      すべての英語文書の ports をインストールします。</para>
	  </listitem>

	  <listitem>
	    <para><quote>すべてのドキュメントの port</quote>, <package>misc/freebsd-doc-all</package>。
	      これは、すべての利用可能な言語のすべてのドキュメントを構築します。</para>
	  </listitem>

	  <listitem>
	    <para>各言語のために <quote>スレーブ port</quote>
	      が用意されています。たとえば、<package>misc/freebsd-doc-hu</package>
	      はハンガリー語のドキュメンテーション port です。</para>
	  </listitem>
	</itemizedlist>

	<para>たとえば、<uri xlink:href="http://www.FreeBSD.org">http://www.FreeBSD.org</uri> と同じ形式である、
	  英語版の分割された <acronym>HTML</acronym> 形式を構築し、
	  <filename>/usr/local/share/doc/freebsd</filename>
	  にインストールするには以下の port をインストールしてください。</para>

	<screen>&prompt.root; <userinput>cd /usr/ports/misc/freebsd-doc-en</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

	<sect4 xml:id="doc-ports-options">
	  <title>共通のオプション</title>

	  <para>ドキュメンテーション ports
	    にはたくさんのオプションが用意されており、
	    以下のように
	    ports の振る舞いをデフォルトの設定から変更できます。</para>

	  <variablelist>
	    <varlistentry>
	      <term><varname>WITH_HTML</varname></term>

	      <listitem>
		<para>HTML 形式を構築します。
		  各ドキュメントに対し、単一版の HTML ファイルが構築されます。
		  整形されたドキュメントは、
		  <filename>article.html</filename> や
		  <filename>book.html</filename> といった名前で、
		  必要に応じて画像とともにインストールされます。</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><varname>WITH_PDF</varname></term>

	      <listitem>
		<para>&adobe; Portable Document Format (PDF) を構築します。
		  整形されたドキュメントは、
		  <filename>article.pdf</filename> や
		  <filename>book.pdf</filename>
		  といった名前でインストールされます。</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><varname>DOCBASE</varname></term>

	      <listitem>
		<para>ドキュメントのインストール先を設定します。
		  デフォルトのインストール先は <filename>/usr/local/share/doc/freebsd</filename>
		  です。</para>

		<note>
		  <para>デフォルトのターゲットディレクトリは、
		    <application>svn</application>
		    を用いる方法とは異なります。
		    ports は通常 <filename>/usr/local</filename>
		    ディレクトリ以下にインストールされるためです。
		    <varname>PREFIX</varname> 変数を使うことで、
		    このディレクトリ以外にもインストールできます。</para>
		</note>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>以下は、上記の変数を用いてハンガリー語のドキュメントを
	    PDF 形式でインストールする方法です。</para>

	  <screen>&prompt.root; cd /usr/ports/misc/freebsd-doc-hu
&prompt.root; make -DWITH_PDF DOCBASE=share/doc/freebsd/hu install clean</screen>
	</sect4>
      </sect3>

      <sect3 xml:id="doc-ports-install-package">
	<title>ドキュメンテーション package の利用</title>

	<para>前節で説明した、
	  ソースからドキュメンテーション port を構築する方法では、
	  ドキュメンテーションツールチェインをローカルにインストールする必要があり、
	  また、ports の構築のためにディスク容量を必要とします。
	  ドキュメンテーションツールチェインをインストールするリソースがない場合や、
	  ソースから構築する場合には多くのディスク容量を必要とするため、
	  構築済みのドキュメンテーション ports
	  のスナップショットが用意されています。</para>

	<para>&a.doceng; は、毎月 &os; ドキュメンテーション package
	  のスナップショットをアップデートしています。
	  これらのバイナリ package は、システムに用意されている
	  &man.pkg.add.1;, &man.pkg.delete.1; などの
	  package 管理ツールを用いて扱うことができます。</para>

	<note>
	  <para>バイナリ package を使うと、
	    インストールする言語に用意されている
	    <emphasis>すべて</emphasis> の形式の
	    &os; ドキュメントがインストールされます。</para>
	</note>

	<para>たとえば、以下のコマンドを実行すると、
	  ハンガリー語のドキュメントの最新 package がインストールされます。</para>

	<screen>&prompt.root; <userinput>pkg_add -r hu-freebsd-doc</userinput></screen>

	<note>
	  <para>ドキュメントの package は、対応する port 名とは異なり、
	    <literal>lang-freebsd-doc</literal>
	    の形式で名前がつけられています。
	    ここで、<replaceable>lang</replaceable> は言語コードの短縮形です。
	    ハンガリー語の場合は <literal>hu</literal>、簡体字の場合には
	    <literal>zh_cn</literal> です。</para>
	</note>
      </sect3>

      <sect3 xml:id="doc-ports-update">
	<title>ドキュメンテーション ports のアップデート</title>

	<para>他の port と同様に、ドキュメンテーション port
	  をアップデートできます。
	  たとえば、以下のコマンドを実行すると、<package>ports-mgmt/portupgrade</package>
	  から、package だけを使ってインストールされているハンガリー語のドキュメントをアップデートします。</para>

	<screen>&prompt.root; <userinput>portmaster -PP hu-freebsd-doc</userinput></screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="current-stable">
    <title>開発ブランチを追いかける</title>
    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>&os; には二つの開発ブランチがあります。
      それは &os.current; と &os.stable; です。
      この章ではそれぞれについて説明し、
      どのようにしてシステムの対応するツリーを最新の状態に保つかについて説明します。
      まずは &os.current;、次に &os.stable; について説明します。</para>

    <para><emphasis>訳: &a.hanai;、1996 年 11 月 6 日</emphasis></para>

    <sect2 xml:id="current">
      <title>最新の &os; を追いかける</title>

      <para>&os.current; とは &os; の開発の <quote>最前線</quote> です。
	&os.current; のユーザは高い技術力を持つことが要求され、
	自分のシステムが抱える困難な問題を自力で解決できなければなりません。
        もし &os; を使い始めたばかりなら、
        これを運用することについて十分検討を重ねた方が良いでしょう。</para>

      <sect3>
	<title>&os.current; ってなに?</title>

        <para>&os.current; は &os; の最新のソースコードです。
          中には現在開発途上のソフトウェア、
          実験的な変更、あるいは過渡的な機能などが含まれています。
          また、この中に入っている機能がすべて、
	  次の公式リリースに入るとは限りません。&os.current;
	  をソースからほぼ毎日コンパイルしている人はたくさんいますが、
          時期によってはコンパイルさえできない状態になっていることもあります。
          これらの問題は可能な限り迅速に解決されますが、
          &os.current; が不幸をもたらすか、
          それとも非常に素晴らしい機能をもたらすかは、
	  まさにソースコードを同期した瞬間によるのです!</para>
      </sect3>

      <sect3>
	<title>誰が &os.current; を必要としてるの?</title>

        <para>&os.current; は、
	  次の 3 つの重要なグループを対象としています。</para>

        <orderedlist>
          <listitem>
            <para>ソースツリーのある部分に関して活発に作業している
	      &os; コミュニティのメンバ。
              彼らにとっては <quote>最新のもの</quote> にしておくのが
              絶対に必要なことなのです。</para>
	</listitem>

	<listitem>
	    <para>活発にテストしている &os; コミュニティのメンバ。
              彼らは、&os.current;
              が <quote>健全である</quote> ことを可能な限り保証するために、
              種々の問題を解決するのに時間を惜しまない人々です。
	      これらのテスターは、さまざまな変更に関する提案や
              &os; の大まかな方向付けを行ないたいと思っている
              人々でもあり、それを実装するためのパッチを提示します。</para>
	</listitem>

	<listitem>
	    <para>単に、さまざまな事に目を向け、
	      参考のために最新のソースを使いたいと思っている人々。
              これらの人々はまた、
              時々コメントやコードを寄稿してくれます。</para>
          </listitem>
        </orderedlist>
      </sect3>

      <sect3>
        <title>&os.current;
          に期待しては<emphasis>いけない</emphasis>ことは?</title>

      <orderedlist>
          <listitem>
	    <para>次のリリースの前に、最も早く新しい機能を入手すること。
	      リリース前の機能は十分にテストされていないため、
	      バグを含んでいく可能性が大いにあります。</para>
          </listitem>

          <listitem>
            <para>バグを修正するための素早い方法。
	      いかなるコミットは、
	      元からあるバグを修正するのと同じく、
	      新しいバグを生み出すおそれがあります。</para>
          </listitem>

          <listitem>
            <para><quote>公式のサポート</quote> はありません。</para>
          </listitem>
        </orderedlist>
      </sect3>

      <sect3>
	<title>&os.current; を使う</title>

        <orderedlist>
          <listitem>
	    <para>&a.current.name; と &a.svn-src-head.name;<indexterm><primary>-CURRENT</primary><secondary>使用</secondary></indexterm> メーリングリスト
              に加わってください。
	      さまざまな人がシステムの現在の状態について述べているコメントを見たり、
	      システムを正常に保つための重要な情報を見逃さないために、
              <emphasis>必須の</emphasis> ことです。</para>

	    <para>&a.svn-src-head.name; メーリングリストでは、
              それぞれの変更についての
	      commit ログが記録されています。
              また、それに関して起こり得る副作用の情報を得ることができますので、
              参加する価値のあるメーリングリストです。</para>

	    <para>これらのメーリングリストに入るには、
	      &a.mailman.lists.link;
	      をたどって参加したいメーリングリストをクリックし、
	      手順の説明にしたがってください。
	      ソースツリー全体の変更点を追いかけるのであれば、
	      &a.svn-src-all.name; メーリングリストを購読してください。</para>
          </listitem>

          <listitem>
	    <para>&os; <link linkend="mirrors">ミラーサイト</link>
	      からソースの入手するには、以下のようないくつかの方法があります。</para>

            <orderedlist>
	      <listitem>
		<para><link linkend="svn">svn</link><indexterm>
		      <primary>Subversion</primary>
		  </indexterm>
		  <indexterm>
		    <primary>-CURRENT</primary>
		    <secondary><application>Subversion</application>
		      を使った同期</secondary>
		  </indexterm>
		  を使って、
		  希望する開発ブランチ、
		  もしくはリリースブランチをチェックアウトしてください。
		  この方法は、開発中の &os; リポジトリへのアクセスを提供しており、
		  推奨されています。
		  <link linkend="svn-mirrors">Subversion ミラーサイト</link>
		  のひとつの <literal>head</literal> ブランチから
		  -CURRENT コードをチェックアウトしてください。
		  リポジトリサイズの観点から、
		  希望するサブツリーのみをチェックアウトすることが推奨されます。</para>
	      </listitem>

              <listitem>
                <para><application>CTM</application><indexterm>
		    <primary>-CURRENT</primary>
		    <secondary>CTM を使った同期</secondary>
		  </indexterm>を用いる。
		  接続料が高額だったり、email でのアクセスしかできないような、
                  あまり良質でない TCP/IP 接続の場合には、<application>CTM</application>
		  を利用すると良いでしょう。ただし、<application>
		  Subversion</application>
		  ほどには信頼はできません。
		  そのため、インターネットに接続しているシステムであれば、
		  <application>Subversion</application>
		  を利用されることを推奨します。</para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>もし、ソースを眺めるだけでなく、
	      走らせるために入手するのであれば、
              一部だけ選ぶのではなく、&os.current;
              の<emphasis>全体</emphasis>を手に入れてください。
	      ソースのさまざまな部分が他の部分の更新に依存しており、
              一部のみをコンパイルしようとすると、
              ほぼ間違いなく問題が起きます。</para>

            <para>&os.current; をコンパイル<indexterm>
		<primary>-CURRENT</primary>
		<secondary>コンパイル</secondary>
	      </indexterm>する前に
	      <filename>/usr/src/Makefile</filename>
	      を注意深く読んでください。
	      アップグレードの処理の一部として、最初に
	      <link linkend="makeworld">新しいカーネルをインストールし
	      て、world を再構築</link> してください。&a.current; と
	      <filename>/usr/src/UPDATING</filename> を読めば、
	      次のリリースへ向けて移ってゆくに当たって、
	      ときどき必要となる既存システムからの新システムの構築手順についての最新情報が得られるでしょう。</para>
          </listitem>

          <listitem>
            <para>アクティブになってください!
	      &os.current; のユーザには、
	      拡張やバグ潰しに関して提案することが勧められています。
              コードを伴う提案はもっとも歓迎されるものです!</para>
          </listitem>
        </orderedlist>
      </sect3>
    </sect2>

    <sect2 xml:id="stable">
      <title>安定版の &os; を使う</title>

      <para><emphasis>訳: &a.jp.iwasaki;</emphasis></para>

      <sect3>
	<title>&os.stable; ってなに?</title>
	<indexterm><primary>-STABLE</primary></indexterm>

        <para>&os.stable; とは定期的に公開されるリリースを作成するための開発ブランチです。
          このブランチに加えられる変更は原則として、
          事前に &os.current; で試験ずみであるという特徴があります。
          ただ<emphasis>そうであっても</emphasis>、
          これは開発用ブランチの一つであるということに注意してください。
          つまり、ある時点における &os.stable; のソースが
          どんな場合にも使えるものであるとは限らないということです。
          このブランチはもう一つの開発の流れというだけであって、
          エンドユーザ向けのものではありません。</para>
      </sect3>

      <sect3>
	<title>誰が &os.stable; を必要としているの?</title>

	<para>FreeBSD の開発プロセスに興味があったり、
	  それに対する貢献を考えていて、特にそれが次回の
	  <quote>ポイント</quote> リリースに関係するものであるなら
	  &os.stable; を追うことを考えると良いでしょう。</para>

	<para>セキュリティ上の修正は &os.stable; ブランチに対して行なわれますが、
          そのために &os.stable; を追う<emphasis>必要</emphasis>はありません。
	  すべての &os; セキュリティ勧告には
	  EOL に達していないすべてのリリースに対する問題点の修正方法が説明されています。

	  <footnote>
	    <para>現時点での古いリリースの FreeBSD
	      のセキュリティポリシーの全説明を知るには、<link xlink:href="&url.base;/security/">http://www.FreeBSD.org/ja/security/</link>
	      を参照してください。</para>
	  </footnote>。</para>

	<para>&os.stable; ブランチはいつもコンパイルができ、
	  安定に動作すべきですが、
	  それが保証されているというわけではありません。
          また、コードは  &os.stable; に加えられる前に
          &os.current; で開発されるのですが、&os.stable; のユーザは
	  &os.current; よりも多いため、&os.current;
	  で発見されなかったバグが &os.stable; で発見され、
	  ときどきそれが問題となることがあるのは避けることができません。</para>

	<para>このような理由から、盲目的に &os.stable;
          を追いかけるべきでは<emphasis>ありません</emphasis>。
          特に、最初に開発環境もしくはテスト環境でコードを十分に試験せずに、
          プロダクション品質が要求されるサーバを &os.stable;
          にアップグレードしてはいけません。</para>

	<para>もし試験をする資源的な余裕がない場合は、
          リリース間のバイナリアップデート機能を利用して、
          最新の FreeBSD リリースを使うことを推奨します。</para>
      </sect3>

      <sect3>
	<title>&os.stable; を使う</title>

	<indexterm>
	  <primary>-STABLE</primary>
	  <secondary>利用する</secondary>
	</indexterm>

        <orderedlist>
          <listitem>
	    <para>&os.stable; の構築に関連する事柄や、
	      その他の注意すべき点 に関する情報を得るために、
	      &a.stable.name; メーリングリストに加わってください。
              また開発者は議論の余地がある修正や変更を考えている場合に、
              このメーリングリストで公表し、
              提案された変更に関して問題が生じるかどうかを返答する機会をユーザに与えます。</para>

	    <para>追いかけているブランチに関連する
	      <application>svn</application> メーリングリストに参加してください。
	      たとえば、9-STABLE ブランチを追いかけているユーザは
	      &a.svn-src-stable-9.name; メーリングリストに参加してください。
	      このリストでは、
	      変更がなされるごとに作成される commit log やそれに伴う
	      起こりうる副作用についての情報が記録されています。</para>

	    <para>これらのメーリングリストに入るには、
	      &a.mailman.lists.link;
	      をたどって参加したいメーリングリストをクリックし、
	      手順の説明にしたがってください。
	      ソースツリー全体の変更点を追いかけるには、
	      &a.svn-src-all.name; メーリングリストを購読してください。</para>
          </listitem>

          <listitem>
	    <para>毎月公開されている &os.stable;
	      からビルドされたスナップショットの新しいシステムをインストールするには、
	      詳細について、
	      <link xlink:href="&url.base;/snapshots/">スナップショット</link>
	      をご覧ください。
	      もしくは、<link linkend="mirrors">ミラーサイト</link>から最近の
	      &os.stable; リリースをインストールし、下記の説明に従って最新の
	      &os.stable; のソースコードに更新することもできます。</para>

	    <para>既に &os; の以前のリリースが動いているシステムを
	      &os; <link linkend="mirrors">ミラーサイト</link>
	      からアップグレードするには、
	      以下のようないくつかの方法があります。</para>

	    <orderedlist>
	      <listitem>
		<para><link linkend="svn">svn</link><indexterm>
		    <primary>Subversion</primary>
		  </indexterm> を使って、
		  希望する開発ブランチ、
		  もしくはリリースブランチをチェックアウしてください。
		  この方法は、開発中の &os; リポジトリへのアクセスを提供しており、
		  推奨されています。
		  ブランチ名については、現在の開発のヘッドブランチは
		  <literal>head</literal>、および <link xlink:href="&url.base;/releng/">リリースエンジニアリングのページ</link>
		  の特定のブランチでは
                  <literal>stable/9</literal><indexterm>
		    <primary>-STABLE</primary>
		    <secondary><application>Subversion</application>
		      を使った同期</secondary>
		  </indexterm>、または
		  <literal>releng/9.2</literal> となります。
		  <application>Subversion</application>
		  を使ってベースシステムをチェックアウトする際の
		  URL のプレフィックスは、<link linkend="svn-mirrors">Subversion ミラーサイト</link>
		  で説明されています。
		  リポジトリサイズの観点から、
		  希望するサブツリーのみをチェックアウトすることが推奨されます。</para>
	      </listitem>

	      <listitem>
		<para>インターネットへの接続に高速な回線を利用できないのであれば、
		  <application>CTM</application><indexterm>
		    <primary>-STABLE</primary>
		    <secondary>CTM を使って同期する</secondary>
		  </indexterm>
		  を検討してみましょう。</para>
	      </listitem>
	   </orderedlist>
	 </listitem>

          <listitem>
	    <para>&os.stable;<indexterm>
	        <primary>-STABLE</primary>
		<secondary>構築、コンパイル</secondary>
	      </indexterm> をコンパイルする前に、
	      <filename>/usr/src/Makefile</filename> をよく読んでください。
              アップグレードの処理の一部として最初に
	      <link linkend="makeworld">新しいカーネルをインストールして、
	      world を再構築</link> してください。&a.stable; と
	      <filename>/usr/src/UPDATING</filename> を読んで、
	      次のリリースへ向けて移ってゆくに当たって、
	      ときどき必要となる既存システムからの新システムの構築手順についての最新情報を得てください。</para>
          </listitem>
        </orderedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="synching">
    <title>ソースの同期</title>

    <para><emphasis>訳: &a.jp.iwasaki;、1997 年 9 月 13 日</emphasis></para>

    <para>インターネット接続または電子メールを使用して、&os;
      プロジェクトのソースのある一部分または全体の最新を追いかける方法は色々あります。
      基本的なサービスは <link linkend="svn">Subversion</link>
      と <link linkend="ctm">CTM</link> です。</para>

    <warning>
      <para>ソースツリーの一部を最新のものに更新することは可能です。
	ただし、サポートされているアップデート手順は、
	ソースツリー全体を最新のものに更新し、
	<filename>/bin</filename>, <filename>/sbin</filename>
	といったユーザ空間で動作するもの、
	およびカーネルソースを再構築することのみです。
	ソースツリーの一部だけであったり、カーネルだけ、
	もしくはユーザランドのプログラムだけを更新した場合は、
	問題が生じることがよくあります。
        この時に発生する問題はコンパイル時のエラーからカーネルパニック、
        データの破壊とさまざまです。</para>
    </warning>

    <indexterm>
      <primary>Subversion</primary>
    </indexterm>

    <para><application>Subversion</application>
      は <emphasis>pull</emphasis> 同期モデルを採用しています。
      ユーザ (または <command>cron</command> スクリプト) が <command>svn</command>
      を起動し、ファイルを最新状態にします。
      <application>Subversion</application> は、
      ローカルのソースツリーをアップデートする最も好ましい方法です。
      更新情報はその時点の最新のものであり、
      ユーザはいつダウンロードするかをコントロールします。
      特定のファイルやディレクトリに限定して更新することも簡単にできます。
      更新情報はサーバによって素早く生成されます。</para>

    <indexterm>
      <primary><application>CTM</application></primary>
    </indexterm>
    <para>一方、<application>CTM</application>
      はあなたが持っているソースとマスタアーカイブ上に
      あるそれとの対話的な比較をおこないませんし、
      あるいは向こう側から変更点を pull したりもしません。
      そのかわりに、前回の実行時からの変更を認識するスクリプトが
      マスタ CTM マシン上で一日に数回実行され、
      すべての変更を compress して通し番号を振り、
      さらに電子メールで、印字可能な ASCII
      キャラクタのみで転送できるようにエンコードします。
      受信した後は、
      これらの <quote>CTM のデルタ</quote> は自動
      的にデコード、検査してユーザのソースのコピーに変更を適用する
	&man.ctm.rmail.1; によって処理可能となります。
      この処理は <application>Subversion</application>
      よりずっと効率的であり、<emphasis>pull</emphasis> モデルというよりむしろ
      <emphasis>push</emphasis> モデルであるため、
      サーバ資源の負荷は軽くなります。</para>

    <para>他のトレードオフもあります。
      <application>Subversion</application> であれば、
      うっかりローカルのアーカイブの一部を消してしまっても、
      壊れた部分を検出して再構築してくれます。
      <application>CTM</application> はこれをやってくれません。
      もしソースツリーの一部を消してしまい、
      そしてバックアップを取っていないのであれば、最新の CTM
      <quote>ベースデルタ</quote> を用いて、一からやり直し、
      <application>CTM</application>
      を使ってすべてを再構築しなければなりません。</para>
  </sect1>

  <sect1 xml:id="makeworld">
    <title><quote>world</quote> の再構築</title>

    <indexterm>
      <primary><quote>world</quote> の再構築</primary>
    </indexterm>
    <para>&os.stable;、&os.current; などの
      &os; のどれか特定のバージョンについて、
      ローカルのソースツリーを同期させたら、
      そのソースツリーを使ってシステムを再構築できます。</para>

    <warning>
      <title>バックアップの作成</title>

      <para>システムを再構築する<emphasis>前に</emphasis>、
	バックアップを作成することの重要性は、
	いくら強調してもし過ぎると言うことはありません。
	システム全体の再構築とは難しい作業ではありませんが、
        どんなに注意していたとしても、<!-- hrs:2000/01/12 inevitably -->
	ソースツリーそのものに手違いがあった時には、
        システムが起動しなくなってしまう状態になることがあるのです。
      </para>

      <para>まず、バックアップがきちんと作成されていることを確認して、
	起動可能インストールメディアを用意してください。
        多分、それを使うことはないと思いますが、
        あとで後悔することのないよう、念のため用意しておきましょう。</para>
    </warning>

    <warning>
      <title>メーリングリストに参加する</title>

      <indexterm><primary>メーリングリスト</primary></indexterm>

      <para>もともと、&os.stable; と &os.current; のコードブランチは、
        <emphasis>開発中のもの</emphasis>です。
        &os; の作業に貢献してくださっている人達も人間ですから、
        時にはミスをすることだってあるでしょう。
      </para>

      <para>そのような間違いは、
	単に警告を示す見慣れない診断メッセージをシステムが表示するような、
	まったく害のないものであることもあれば、システムを起動できなくしたり、
        ファイルシステムを破壊してしまうような、
	恐ろしい結果を招くものかも知れません。</para>

      <para>問題が生じた場合、
        問題の詳細と、どのようなシステムが影響を受けるかについて書かれた
	<quote>注意 (heads up)</quote>
	の記事が適切なメーリングリストに投稿されます。
	そして、その問題が解決されると、
	<quote>問題解決 (all clear)</quote>
	のアナウンス記事が同様に投稿されます。</para>

      <para>&os.stable; や &os.current; ブランチを追随しているユーザで、
	&a.stable; や &a.current; を読まないというのは、
	自ら災難を招くようなものです。</para>

      <para><emphasis>訳注:</emphasis>
      これらのメーリングリストは英語でやりとりされているため、
      日本語での投稿は歓迎されません。英語でのやりとりができない人は、
      <link xlink:href="http://www.jp.FreeBSD.org">FreeBSD 友の会</link>
      の運営しているメーリングリストをあたってみるのがいいでしょう。
      </para>
    </warning>

    <warning>
      <title><command>make world</command> は使わないこと</title>

      <para>古いドキュメントの中には、
	<command>make world</command> を使うことを薦めているものがあります。
	これは、重要な手順をいくつか抜かしてしまうので、
	エキスパートでなければ使うべきではありません。
	ほぼあらゆる場合において、<command>make world</command>
	を実行するのは間違っており、
	ここで説明されている手順を用いるべきです。</para>
    </warning>

    <sect2 xml:id="canonical-build">
      <title>システムを更新する正式な方法</title>

      <para>システムを更新する前に、
	<filename>/usr/src/UPDATING</filename> を読んでください。
	このファイルには、用意したソースコードで buildworld
	を行う前に必要な手順が書かれています。
	その後、以下の手順を踏んでください。</para>

      <para>この節で説明するアップデートのプロセスは、古いコンパイラ、
	古いカーネル、古い world、そして古いコンフィグレーションファイルからなる、
	古いバージョンの &os; をアップデートすることを想定しています。
	ここで <quote>world</quote> は、コアシステムのバイナリ、ライブラリ、
	プログラミングファイルを意味します。
	コンパイラは <quote>world</quote> の一部ですが、
	いくつか特別に気をつけなければならないことがあります。</para>

      <para>また、これらのステップでは、
	新しいバージョンのソースをすでに入手していることも仮定しています。
	もしシステムのソースコードが古いようでしたら、
	<xref linkend="synching"/> を読んで、
	ソースコードを新しいバージョンへ同期する方法の詳細を理解してください。</para>

      <para>ソースからのシステムのアップデートは、
	当初予想していたものよりとらえがたいものです。
	長い年月において避けられない依存問題が判明したため、
	&os; の開発者達は、推奨されるアプローチを大きく変更しました。
	この節では、現在推奨されているアップグレードの手順の背後にある、
	理論的根拠について説明します。</para>

      <para>連続したアップデートの手順は、以下の問題に対応している必要があります。</para>

      <itemizedlist>
	<listitem>
	  <para>古いコンパイラは、
	    バグを含み新しいカーネルをコンパイルできない可能性があります。
	    そのため、新しいカーネルの構築には、
	    新しいコンパイラを使う必要があります。
	    ことのことは、新しいカーネルを構築する前に、
	    新しいコンパイラを構築していなければならないことを意味しています。
	    必ずしも、新しいカーネルを構築する前に、新しいコンパイラが
	    <emphasis>インストールされている</emphasis>
	    必要があることを意味しているわけではありません。</para>
	</listitem>

	<listitem>
	  <para>新しい world は、
	    新しいカーネルの機能に依存している可能性があるため、
	    新しい world をインストールする前に、
	    新しいカーネルがインストールされていなければなりません。</para>
	</listitem>
      </itemizedlist>

      <para>これら 2 つの重要事項は、
	以下の説明で中心となる <buildtarget>buildworld</buildtarget>,
	<buildtarget>buildkernel</buildtarget>,
	<buildtarget>installkernel</buildtarget>,
	<buildtarget>installworld</buildtarget> の基本です。
	他の理由については以下でリストアップします。</para>

      <itemizedlist>
	<listitem>
	  <para>古い world は、新しいカーネルでは正しく動かないかも知れません。
	    そのため、新しいカーネルをインストールしたら、
	    直ちに新しい world をインストールしてください。</para>
	</listitem>

	<listitem>
	  <para>設定の中には、新しい world
	    をインストールする前に変更すべきものがありますが、
	    古い world を壊す可能性があります。
	    そのため、一般的に設定のアップデートは、
	    2 つの手順が必要です。</para>
	</listitem>

	<listitem>
	  <para>多くの場合、アップデートのプロセスは、ファイルを置き換えたり、
	    追加のみを行い、古いファイルを削除しません。
	    このことが問題を引き起こす可能性があります。
	    そのため、アップデートにおいては、
	    手動で削除すべきファイルがあることを、
	    特定のステップで指定することもあります。
	    これは将来自動化されるかもしれないし、されないかもしれません。</para>
	</listitem>
      </itemizedlist>

      <para>これらを配慮し、以下の推奨手順が作られました。
	アップデートの細かい手順においては、追加の手順が必要になるかもしれませんが、
	この中心となるプロセスは、しばらくの間変わっていません。</para>

      <orderedlist>
	<listitem>
	  <para><command>make buildworld</command></para>

	  <para>新しいコンパイラと関連ツールを最初にコンパイルし、
	    その後、新しいコンパイラで、
	    新しい world の残りの部分をコンパイルします。
	    コンパイルされたものは、
	    <filename>/usr/obj</filename> に格納されます。</para>
	</listitem>

	<listitem>
	  <para><command>make
	      buildkernel</command></para>

	  <para>ここでは、
	    <filename>/usr/obj</filename> にある
	    <emphasis>新しい</emphasis> コンパイラが用いられます。
	    これにより、コンパイラとカーネルのミスマッチを防ぐことができます。</para>
	</listitem>

	<listitem>
	  <para><command>make installkernel</command></para>

	  <para>新しくアップデートされたカーネルで起動できるように、
	    新しいカーネルとカーネルモジュールをディスク上に配置します。
	   </para>
	</listitem>

	<listitem>
	  <para>シングルユーザモードで再起動</para>

	  <para>シングルユーザモードは、
	    すでに実行されているソフトウェアをアップデートする際の問題を最小限にします。
	    また、新しいカーネル上で古い world が実行される際の問題も最小限にします。</para>
	</listitem>

	<listitem>
	  <para><command>mergemaster -p</command></para>

	  <para>新しい world における最初の設定ファイルのアップデートを行います。
	    たとえば、新しいユーザグループをシステムに追加したり、
	    パスワードデータベースに対し、新しいユーザ名を追加するかもしれません。
	    前回のアップデート後に、
	    新しいグループや特別のシステムのユーザアカウントが追加された場合に、
	    <buildtarget>installworld</buildtarget> のステップで、
	    新しくインストールされたシステムのユーザまたはシステムのグループ名を問題なく使うことができるように、
	    この作業がときどき必要となります。</para>
	</listitem>

	<listitem>
	  <para><command>make installworld</command></para>

	  <para>world を <filename>/usr/obj</filename> からコピーします。
	    これで、ディスクには新しいカーネルと world が置かれたことになります。</para>
	</listitem>

	<listitem>
	  <para><command>mergemaster</command></para>

	  <para>ディスクに新しい world が置かれたので、
	    残りの設定ファイルをアップデートします。</para>
	</listitem>

	<listitem>
	  <para><command>make
	      delete-old</command></para>

	  <para>このターゲットは (使われなくなった) ファイルを削除します。
	    もし使われなくなったファイルがディスクに残っていると、
	    問題が起きる可能性があるため重要な作業です。
	    たとえば、古い <filename>utmp.h</filename> が残っていると、
	    新しい <filename>utmpx.h</filename> をインストールしたときに、
	    問題が起きる ports があります。</para>
	</listitem>

	<listitem>
	  <para>再起動</para>

	  <para>新しいカーネル、world そして設定ファイルがロードされたので、
	    再起動が必要です。</para>
	</listitem>

	<listitem>
	  <para><command>make
	      delete-old-libs</command></para>

	  <para>使われなくなったライブラリが新しいライブラリと競合することを避けるため削除します。
	  古いライブラリを削除する前にすべての ports を再構築する必要があります。</para>
	</listitem>
      </orderedlist>

      <para>もし、&os; のあるブランチのあるリリースから、
	同じブランチの最新リリースにアップデートするのであれば
	(たとえば 9.0 から 9.1)、
	この手順にしたがわなくても良いでしょう。
	なぜならば、コンパイラ、カーネル、ユーザランド、そして設定ファイルの間で、
	重度のミスマッチが起きることはあまり考えられないためです。
	マイナーなアップデートでは、新しいカーネルの構築とインストール後に、
	古いアプローチである
	<command>make world</command>
	を用いてもうまくいくでしょう。</para>

      <para>メジャーリリースをまたいだアップデートでは、
	この方法を用いないと、何らかの問題にぶつかるでしょう。</para>

      <para>大きなアップグレードにおいては、
	installworld の前に特定のファイルの名前の変更や削除するといった、
	特別な追加のステップが必要となることがあります。
	<filename>/usr/src/UPDATING</filename> を注意深く読んでください。
	特にファイルの最後には、
	現在推奨されているアップグレードの手順が詳しく正確に説明されています。</para>

      <para>この手続きは、
	開発者たちがある種のミスマッチを完全に避けるために、長い年月をかけて進化してきました。
	願わくば、この現在の手順が長い間安定してほしいものです。</para>

      <para>まとめると、現在、ソースからの &os;
	のアップグレードにおいて推奨されている方法は以下となります。</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput>
&prompt.root; <userinput>make installkernel</userinput>
&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <note>
	<para>まれに <buildtarget>buildworld</buildtarget>
	  の前に <command>mergemaster -p</command>
	  を余分に実行することが必要な場合があります。その場合は
	  <filename>UPDATING</filename> にそう書かれています。
	  &os; のメジャーバージョンをまたいで更新するのでなければ、
	  通常はこの手順を省略してもなんら問題ないでしょう。</para>
      </note>

      <para><buildtarget>installkernel</buildtarget>
	が無事に終了したら、ローダのプロンプトから
	<command>boot -s</command>
	を使ってシングルユーザモードで立ち上げてください。</para>

      <para>UFS を使っているのなら、以下を実行してください。</para>

      <screen>&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput></screen>

      <para>ZFS を使っている場合には、以下を実行してください
	(zpool の名前を zroot としています)。</para>

      <screen>&prompt.root; <userinput>zfs set readonly=off zroot</userinput>
&prompt.root; <userinput>zfs mount -a</userinput></screen>

      <para>その後、以下を実行してください。:</para>

       <screen>&prompt.root; <userinput>adjkerntz -i</userinput>
&prompt.root; <userinput>mergemaster -p</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput>
&prompt.root; <userinput>mergemaster</userinput>
&prompt.root; <userinput>make delete-old</userinput>
&prompt.root; <userinput>reboot</userinput>
&prompt.root; <userinput>make delete-old-libs</userinput></screen>

      <warning>
	<title>この後の説明を読んでください</title>

	<para>この後の節ではそれぞれのステップについて詳しく説明しています。
	  特にカスタムカーネルを利用する場合について説明しています。</para>
      </warning>
    </sect2>

    <sect2 xml:id="src-updating">
      <title><filename>/usr/src/UPDATING</filename> を読む</title>

      <para>アップデートする前に、
	<filename>/usr/src/UPDATING</filename> を読んでください。
	このファイルには潜在的な問題や
	特定のコマンドの順などの重要な情報が含まれています。
	<filename>UPDATING</filename> がこの節に書かれているものと矛盾している時は
	<filename>UPDATING</filename> を優先してください。</para>

      <important>
	<para><filename>UPDATING</filename> を読むということは、
	  適切なメーリングリストを購読する代わりにはなりません。
	  二つの要求は相補的なもので排他的なものではないのです。</para>
      </important>
    </sect2>

    <sect2 xml:id="make-conf">
      <title><filename>/etc/make.conf</filename> の確認</title>

      <indexterm>
        <primary><filename>make.conf</filename></primary>
      </indexterm>

      <para>&man.make.1; のオプションの説明は、&man.make.conf.5; や
	<filename>/usr/share/examples/etc/make.conf</filename> にあります。
	これらの設定を <filename>/etc/make.conf</filename> に追加して、
	&man.make.1; の実行やプログラムの構築方法を設定してください。
	ある設定を変更したことにより、影響が広い範囲におよび、
	驚くべき結果をもたらす可能性があります。
	両方のファイルに書かれているコメントを読むことと、
	デフォルトの設定は、パフォーマンスと安全性の観点から選ばれていることを覚えておいてください。</para>

      <para><filename>/etc/make.conf</filename> で設定されたオプションは、
	&man.make.1; が使われる際には常に有効となります。
	Ports Collection からアプリケーションをコンパイルする時、
	ユーザが書いた C プログラムや &os;
	オペレーティングシステムを構築する際に影響を及ぼします。</para>
    </sect2>

    <sect2 xml:id="src-conf">
      <title><filename>/etc/src.conf</filename> を確認する</title>

      <indexterm>
	<primary><filename>src.conf</filename></primary>
      </indexterm>

      <para><filename>/etc/src.conf</filename> は、
	ソースコードを用いたオペレーティングシステムの構築についてコントロールします。
	<filename>/etc/make.conf</filename> とは異なり、
	<filename>/etc/src.conf</filename> に書かれた設定は、
	&os; オペレーティングシステムそのものを構築するときにのみ影響します。
	このファイルで設定可能な多くのオプションについては、
	&man.src.conf.5; に記述されています。
	一見したところ無効にされている、
	使われていないカーネルモジュールやビルドオプションに注意してください。
	ときどき予期しなかったり、わずかな影響を与えることがあります。</para>
    </sect2>

    <sect2 xml:id="updating-etc">
      <title><filename>/etc</filename> にあるファイルの更新</title>

      <para><filename>/etc</filename> には、
        システム起動時に実行されるスクリプトだけでなく、
	システムの設定に関連する情報の大部分が含まれています。
	そのディレクトリに含まれるスクリプトは、
	&os; のバージョンによって多少異なります。</para>

      <para>設定ファイルのなかには、<filename>/etc/group</filename>
	のように稼働中のシステムが日々利用しているものもあります。</para>

      <para>
        <command>make installworld</command> によるインストールの段階では、
        特定のユーザ名、あるいはグループが存在していることを
        要求する場面があります。システムのアップグレードを行なう際には、
	それらのユーザ名やグループが削除、
	あるいは変更されて存在していない可能性が考えられます。
	<command>make buildworld</command> において、
	それらのユーザ名やグループが存在するか確認が行われる場合もあります。
      </para>

      <para>解決方法は、buildworld の前に <option>-p</option>
	をつけて &man.mergemaster.8; を実行することです。
	これを実行すると、<buildtarget>buildworld</buildtarget> や
	<buildtarget>installworld</buildtarget>
	が成功するために必要なファイルだけを比較します。</para>

      <tip>
	<para>名前を変更したり、削除してしまったグループが所有しているファイルを、
          次のようにして調べることもできます。
        </para>

	<screen>&prompt.root; <userinput>find / -group GID -print</userinput></screen>

	<para>このコマンドはグループ名もしくは数字で示されるグループ ID
	  で指定されたグループ <replaceable>GID</replaceable>
	  が所有するすべてのファイルを表示します。</para>
      </tip>
    </sect2>

    <sect2 xml:id="makeworld-singleuser">
      <title>シングルユーザモードへの移行</title>
      <indexterm><primary>シングルユーザモード</primary></indexterm>

      <para>コンパイルは、シングルユーザモードで行なうことを考えてください。
	システムの再インストールは重要なシステムファイル、
	すべての標準システムのバイナリ、ライブラリ、インクルードファイルを操作します。
	稼働中のシステムに (特に他のユーザがそのシステムにログインしている時に)
	そのような変更を加えることは、トラブルを引き起こす原因となります。</para>

      <indexterm><primary>マルチユーザモード</primary></indexterm>
      <para>もう一つの方法として、マルチユーザモードでシステムを再構築して、
        シングルユーザモードに移行してからそれをインストールする、
        というのがあります。もしこのような方法で行ないたい場合は、
        以下の手順を構築が完了するところまで飛ばしてください。
	<buildtarget>installkernel</buildtarget> もしくは
	<buildtarget>installworld</buildtarget> を実行する際に、
	シングルユーザモードに移行してください。</para>

      <screen>&prompt.root; <userinput>shutdown now</userinput></screen>

      <para>あるいはシステムを再起動し、ブートプロンプトから
	<quote>single user</quote> オプションを選択してください。
	シングルユーザモードで起動した後は、
	シェルプロンプトから次のように実行してください。</para>

      <screen>&prompt.root; <userinput>fsck -p</userinput>
&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

      <para>これはファイルシステムをチェックした後、
        <filename>/</filename> を読み書き可能にして再マウント、
        <filename>/etc/fstab</filename> に指定されている、
        それ以外の UFS ファイルシステムをすべてマウントしてから
        スワップを有効にします。
      </para>

        <note>
          <para>CMOS クロックが地域時間に設定されていて
	    GMT ではない場合
	    (&man.date.1; が正しい時間と地域を表示しないなら当てはまります)、
	    次のコマンドを実行すしてください。</para>

<screen>&prompt.root; <userinput>adjkerntz -i</userinput></screen>

          <para>こうすれば、
	    確実に地域時刻が正しく設定されます。</para>
        </note>

    </sect2>

    <sect2 xml:id="cleaning-usr-obj">
      <title><filename>/usr/obj</filename> の削除</title>

      <para>システムが再構築される時、構築されたものはデフォルトで
	<filename>/usr/obj</filename> 以下のサブディレクトリに格納されます。
	そのディレクトリの下は <filename>/usr/src</filename>
	と同じ構造となります。</para>

      <para>もしこのディレクトリが存在しているのであれば、
	このディレクトリを削除して、
	<command>make buildworld</command> の行程にかかる時間を短縮し、
	依存問題に悩まされるようなトラブルを回避することができます。</para>

      <para><filename>/usr/obj</filename> 以下のファイルには、変更不可
	(immutable) フラグがセットされているものがある可能性があります。
	このようなファイルは最初に &man.chflags.1;
	を用いてから削除する必要があります。</para>

      <screen>&prompt.root; <userinput>cd /usr/obj</userinput>
&prompt.root; <userinput>chflags -R noschg *</userinput>
&prompt.root; <userinput>rm -rf *</userinput></screen>
    </sect2>

    <sect2 xml:id="updating-upgrading-compilebase">
      <title>ベースシステムの再構築</title>

      <sect3>
	<title>出力メッセージの保存</title>

	<para>実行される &man.make.1; からの出力は、ファイルに保存すると良いでしょう。
	  もし、何か障害が発生した場合、エラーメッセージのコピーを
	  &os; メーリングリストに投稿してください。</para>

	<para>ファイルに保存する最も簡単な方法は、&man.script.1;
	  コマンドを使い、引数に出力を保存したいファイル名を指定することです。
	  これを make world の直前に行ない、再構築が終了したら
	  以下のように <userinput>exit</userinput> と入力してください。</para>

	<screen>&prompt.root; <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out
&prompt.root; <userinput>make TARGET</userinput>
<emphasis>&hellip; compile, compile, compile &hellip;</emphasis>
&prompt.root; <userinput>exit</userinput>
Script done, &hellip;</screen>

	<para><filename>/tmp</filename>
	  に出力を保存しては<emphasis>いけません</emphasis>。
	  このディレクトリは、次の再起動で削除されてしまう可能性があります。
	  出力の保存には、<filename>/var/tmp</filename> や
          <systemitem class="username">root</systemitem> のホームディレクトリが適しています。</para>
      </sect3>

      <sect3 xml:id="make-buildworld">
	<title>ベースシステムの構築</title>

	<para><filename>/usr/src</filename> にて、
	  次のように実行してください。</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>

	<indexterm><primary><command>make</command></primary></indexterm>

	<para>world を再構築するには、&man.make.1; を使用してください。
	  このコマンドは、<filename>Makefile</filename> から、
	  &os; を構成するプログラムの再構築方法や、
	  どういう順番でそれらを構築すべきかといったような指示を読み込みます。</para>

	<para>コマンドラインの一般的な書式は、次のとおりです。</para>

	<screen>&prompt.root; <userinput>make -x -DVARIABLE target</userinput></screen>

	<para>この例では、<option>-<replaceable>x</replaceable></option> が
	  &man.make.1; に渡されるオプションになります。
	  どのようなオプションが利用できるかについては、&man.make.1;
	  を参照してください。</para>

	<para>
          <option>-D<replaceable>VARIABLE</replaceable></option> は、
          <filename>Makefile</filename> に渡される変数であり、
          この変数は <filename>Makefile</filename> の動作をコントロールします。
          また、<filename>/etc/make.conf</filename> で設定される変数も
          同様です。これは変数を設定するもう一つの方法として用意されています。
	  たとえば以下の通りです。</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE target</userinput></screen>

	<para>
          は、プロファイル版のライブラリを構築しないことを指定する
          もう一つの記法で、<filename>/etc/make.conf</filename> 中の</para>

	<programlisting>NO_PROFILE=    true 	#    Avoid compiling profiled libraries</programlisting>

	<para>の行に対応します。</para>

	<para><replaceable>target</replaceable> は、&man.make.1; に
	  どのように動作するのかを指示するためのものです。
	  各 <filename>Makefile</filename> には、数多くの異なる
          <quote>ターゲット (target)</quote> が定義されていて、
          指定されたターゲットによって動作が決まります。
        </para>

	<para><filename>Makefile</filename> に書かれているターゲットには、
	  システムの再構築に必要な段階を、
	  多くのさらに細かい段階に分割するため、
	  構築の過程で利用されるものがあります。</para>

	<para>大抵の場合、&man.make.1; にパラメータを指定する必要はないでしょうから、
	  コマンドラインは次のようなものになります。</para>

	<screen>&prompt.root; <userinput>make target</userinput></screen>

	<para>ここで、<replaceable>target</replaceable>
	  は、多くのビルドオプションのどれかになります。
	  最初のターゲットはいつも <buildtarget>buildworld</buildtarget>
	  になるでしょう。</para>

	<para>その名前が示すように、<buildtarget>buildworld</buildtarget> は
	  <filename>/usr/obj</filename>
	  以下に新しい完全なディレクトリツリーを構築し、
          <buildtarget>installworld</buildtarget> は、そのツリーを
	  現在のマシンにインストールします。</para>

	<para>選択肢が分けられていることは、二つの理由から有用です。
	  まず第一に、構築作業は
	  <quote>何にも依存せず独立して行なわれ</quote>、
	  稼働中のシステムにまったく影響を与えません。
          <!-- hrs:2000/02/14: needs good phrase that means "self hosted" -->
          そのため、マルチユーザモードで稼働中のシステムでも、何一つ
          悪影響を与えずに <buildtarget>buildworld</buildtarget> を
          実行することができます。
          ただし、<buildtarget>installworld</buildtarget> は
	  シングルユーザモードで行なうことをおすすめします。</para>

	<para>第二に、NFS マウントを利用することで、
	  ネットワーク上の複数のマシンをアップグレードすることが可能な点があげられます。
	  たとえば三台のマシン、
	  <systemitem>A</systemitem>, <systemitem>B</systemitem>, <systemitem>C</systemitem>
	  をアップグレードしたい場合には、まずマシン <systemitem>A</systemitem>
	  で <command>make buildworld</command> と
          <command>make installworld</command> を実行します。
	  それから、マシン <systemitem>B</systemitem> とマシン <systemitem>C</systemitem>
	  でマシン <systemitem>A</systemitem> の
          <filename>/usr/src</filename> と <filename>/usr/obj</filename> を
	  NFS マウントし、<command>make installworld</command>
	  とすることで構築済みのシステムを各マシンにインストールできます。</para>

	<para><buildtarget>world</buildtarget> ターゲットも利用可能ですが、
          このターゲットの利用は推奨されていません。</para>

        <para>そのかわり、次のコマンド</para>

	<screen>&prompt.root; <userinput>make buildworld</userinput></screen>

        <para>を実行してください。ここで <command>make</command> に
	  <option>-j</option> をつけると、
	  同時に複数のプロセスを生成できます。
          この機能はマルチ CPU マシンで特に効果を発揮します。
          構築過程の大部分では CPU 性能の限界より
          I/O 性能の限界の方が問題となるため、シングル CPU
          マシンにも効果があります。</para>

 	<para>普通のシングル CPU マシンで以下のコマンド</para>

	  <screen>&prompt.root; <userinput>make -j4 buildworld</userinput></screen>

	<para>を実行すると、&man.make.1; は最大 4 個までのプロセスを同時に実行します。
          メーリングリストに投稿された経験的な報告によると、
          4 個という指定が最も良いパフォーマンスを示すようです。</para>

	<para>もし、複数の CPU を備えたマシンで SMP 設定が行なわれたカーネルを
          利用しているなら、6 から 10 の間の値を設定し、速度がどれくらい
          向上するか確認してみてください。</para>
      </sect3>

      <sect3>
	<title>システムの構築にかかる時間</title>

	<indexterm>
	  <primary><quote>world</quote> の再構築</primary>
	  <secondary>時間</secondary>
	</indexterm>

        <para>構築時間を決める要素はさまざまありますが、
	  十分新しいマシンであれば、
	  トリックや近道を使わずに普通に構築した場合、&os.stable;
	  の構築には 1, 2 時間しかかからないでしょう。
          &os.current; の構築は、もう少し時間がかかります。</para>
      </sect3>
    </sect2>

    <sect2 xml:id="new-kernel">
      <title>新しいカーネルの構築とインストール</title>
      <indexterm>
        <primary>カーネル (kernel)</primary>
	<secondary>構築、コンパイル</secondary>
      </indexterm>

      <para>新しいシステムの全機能を完全に利用できるようにするには、
	カーネルを再構築してください。
	再構築は、ある種のメモリ構造体が変更された時には特に必須であり、
        &man.ps.1; や &man.top.1; のようなプログラムは、
        カーネルとソースコードのバージョンが一致しないと正常に動作しないでしょう。</para>

      <para>最も簡単で安全にカーネルの再構築を行なう方法は、
        <filename>GENERIC</filename> を使ったカーネルを構築・インストールすることです。
        <filename>GENERIC</filename> にはあなたが必要とするデバイスがすべて含まれていない
        かも知れませんが、あなたのシステムをシングルユーザモードで
        起動させるのに必要なものはすべて入っています。
        これは新しいバージョンのシステムがきちんと動作するかどうか
        調べる良い方法の一つです。
	<filename>GENERIC</filename> で起動して、
	システムが正常に動作しているかどうかを確かめたら、
	カスタムカーネルコンフィグレーションファイルを使って新しいカーネルを構築してください。</para>

      <para>&os; では、新しいカーネルを構築する前に <link linkend="make-buildworld">build world</link> を行うことが重要です。
	</para>

      <note>
	<para>既にあるコンフィグレーションファイルを使ってカスタムカーネルを構築するには、
	  <literal>KERNCONF=MYKERNEL</literal>
	  を使ってください。</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildkernel KERNCONF=MYKERNEL</userinput>
&prompt.root; <userinput>make installkernel KERNCONF=MYKERNEL</userinput></screen>

      </note>

      <para><literal>kern.securelevel</literal> を 1 より大きくしていて、
	<emphasis>かつ</emphasis> カーネルのバイナリファイルに
	<literal>noschg</literal> のようなフラグを設定している場合は、
	<buildtarget>installkernel</buildtarget>
	を行うのにシングルユーザモードに移行してください。
	それ以外の場合は、
	マルチユーザモードでこれらのコマンドを問題なく動かせるはずです。
	<literal>kern.securelevel</literal> について詳しくは
	&man.init.8; を、ファイルの様々なフラグについて詳しくは
	&man.chflags.1; をご覧ください。</para>
    </sect2>

    <sect2 xml:id="new-kernel-singleuser">
      <title>シングルユーザモードで再起動する</title>
      <indexterm><primary>single-user mode</primary></indexterm>

      <para>新しいカーネルが動作するかどうかテストするために、
	シングルユーザモードで再起動してください。
        シングルユーザモードでの起動は、
        <xref linkend="makeworld-singleuser"/>
        に書かれている手順に従ってください。</para>
    </sect2>

    <sect2 xml:id="make-installworld">
      <title>新しいシステムバイナリのインストール</title>

      <para>次に、<buildtarget>installworld</buildtarget>
	を使って新しいシステムバイナリのインストールを行ないます。</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput></screen>

      <note>
	<para><command>make buildworld</command>
	  に変数を指定した場合は、同じ指定を
          <command>make installworld</command> にも指定しなければなりません。
	  ただし <option>-j</option> は
          <buildtarget>installworld</buildtarget> で絶対に使ってはいけません。</para>

	<para>たとえば以下のように実行したなら、</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE buildworld</userinput></screen>

	<para>以下のようにしてインストールしなければなりません。</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE installworld</userinput></screen>

	<para>もしそうしなかった場合、
          <command>make buildworld</command> の段階で構築されていない
          プロファイル版ライブラリをインストールしようとしてしまうでしょう。</para>
      </note>
    </sect2>

    <sect2 xml:id="post-installworld-updates">
      <title><command>make installworld</command> で更新されないファイルの更新</title>

      <para>システムの再構築は、いくつかのディレクトリ、
	特に、<filename>/etc</filename> や
	<filename>/var</filename> や
	<filename>/usr</filename> において、
        新規に導入されたり、変更された設定ファイルによる
        ファイルの更新は行なわれません。</para>

      <para>これらのディレクトリのファイルを更新するもっとも簡単な方法は、
	&man.mergemaster.8; を使うことです。
	必ず <filename>/etc</filename>
	のバックアップを取って不測の事態に備えてください。</para>

    <sect3 xml:id="mergemaster">
      <info><title><command>mergemaster</command></title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>寄稿: </contrib></author>
	</authorgroup>
      </info>
      
        <indexterm><primary><command>mergemaster</command></primary></indexterm>

      <para>&man.mergemaster.8; は Bourne シェルスクリプトで、
	<filename>/etc</filename>
	にある設定ファイルとソースツリーの
	<filename>/usr/src/etc</filename>
	にある設定ファイルの違いを確認するのを手伝ってくれます。
        これを使うのが、ソースツリーにある設定ファイルにシステムの設定ファイルを
	更新するために推奨される方法です。</para>

      <para>始めるには、プロンプトから
	<command>mergemaster</command> と入力してください
	<command>mergemaster</command> は
	<filename>/</filename> を起点とした一時的なルート環境を構築し、
	さまざまなシステム設定ファイルを
	(訳注: デフォルトでは <filename>/var/tmp/temproot</filename> に)
	置いていきます。
	これらのファイルは現在システムにインストールされているファイルと比較されます。
	異なるファイルは &man.diff.1; 形式で示され、
	<option>+</option> の記号は追加または変更された行を表し、
	<option>-</option> は完全に削除されたか新しく置き換えられた行を表します。
	&man.diff.1; の書式とファイルの違いの表示方法についてのより詳しい情報は、
	&man.diff.1; を参照してください。</para>

      <para>&man.mergemaster.8; は違いのあるファイルをそれぞれ示します。
	新しいファイルを削除するか、
	一時ファイルをそのままインストールするか、
	一時ファイルと現在インストールされているファイルを統合するか、
	もしくは &man.diff.1; の結果をもう一度見るか選択できます。</para>

      <para>一時ファイルの削除を選ぶと、&man.mergemaster.8;
	に現在のファイルを変更しないで新しいバージョンを削除せよと伝えます。
	この選択は、現在のファイルを変更する理由が分からないのであれば、
	お勧めできません。
	&man.mergemaster.8; のプロンプトで <keycap>?</keycap> とタイプすれば、
	いつでもヘルプが見られます。
	ファイルのスキップを選ぶと、他のすべてのファイルを終えたあと、
	もう一度そのファイルが提示されます。</para>

      <para>一時ファイルをそのままインストールすることを選ぶと、
	現在のファイルを新しいファイルで置き換えます。
	ほとんどの手を加えていないファイルは、
	これが一番よい選択です。</para>

      <para>ファイルの統合を選んだ場合、
	テキストエディタが起動され、両方のファイルの中身が提示されます。
	画面上に並ぶ両方のファイルを見て新しいファイルを作成するために両方から必要な部分を選択し、
	2 つのファイルを統合することができます。
	並んでいるファイルを比較するとき、
	<keycap>l</keycap> で左側の中身を選択し、
	<keycap>r</keycap> で右側の中身を選択します。
	最終出力は左右両方の部分でできたファイルになるでしょう。
	このファイルをインストールすることができます。
	たいてい、このオプションはユーザが設定を変更したファイルに使われます。</para>

      <para>&man.diff.1; の結果をもう一度見る、を選択すると、
	ちょうど先ほど &man.mergemaster.8; が選択肢を表示する前と同じように、
	ファイルの相異点を見ることができます。</para>

      <para>&man.mergemaster.8; がシステムファイルの比較を終えたあと、
	他のオプションについてもプロンプトが表示されます。
	&man.mergemaster.8;
	が、パスワードファイルを再構築するかどうかを尋ねることがあります。
	最後に残った一時ファイルを削除するかどうかを尋ねて終了します。</para>
      </sect3>

      <sect3>
	<title>手動での更新</title>

      <para>手動で更新する場合には、単にファイルを
	<filename>/usr/src/etc</filename>
	から <filename>/etc</filename> に
	コピーしないでください。正常に動作しないでしょう。
	ファイルの中には、
	<quote>インストールという手順を踏まなければならないもの</quote>
	が含まれています。
	<filename>/usr/src/etc</filename> は
	<filename>/etc</filename>
	にそのまま置き換えられるようなコピーでは
	<emphasis>ない</emphasis>からです。
        また、<filename>/etc</filename> にあるべきファイルのうちで
	<filename>/usr/src/etc</filename> にないものもあります。</para>

      <para>&man.mergemaster.8; を (勧められた通り)
	使っているのであれば、<link linkend="updating-upgrading-rebooting">次の節</link>
	まで飛ばしてもかまいません。</para>

      <para>手動で行う際の一番簡単な方法は、
	ファイルを新しいディレクトリにインストールしてから、
	以前のものと異なっている部分を調べて更新作業を行なうことです。</para>

      <warning>
	<title>既存の <filename>/etc</filename> をバックアップする</title>

	<para>たとえば以下のようにして、
	  既存の <filename>/etc</filename>
	  をどこか安全な場所にコピーしておきましょう。</para>

	<screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

	<para>ここで、<option>-R</option> は再帰的なコピーを行ない、
	  <option>-p</option> はファイルの更新時間や所有者などを保存します。</para>
      </warning>

      <para>新しい <filename>/etc</filename>
	やその他のファイルをインストールするための、
	仮のディレクトリを作ってください。</para>

      <screen>&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>

      <para>
        上の例は、必要なディレクトリ構造をつくり、ファイルをインストールします。
	<filename>/var/tmp/root</filename> 以下に作られる、
	たくさんの空のサブディレクトリは削除する必要があります。
	一番簡単なやり方は、次のとおりです。</para>

      <screen>&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d . -type d | xargs rmdir 2&gt;/dev/null</userinput></screen>

      <para>これは空ディレクトリをすべて削除します。
	空でないディレクトリに関する警告を避けるために、
	標準エラー出力は <filename>/dev/null</filename> に
	リダイレクトされます。</para>

      <para>この段階の <filename>/var/tmp/root</filename> には、
	本来 <filename>/</filename>
	以下にあるべきファイルがすべて含まれています。各ファイルを順に見て、
	既存のシステムにあるファイルと異なる部分を調べてください。</para>

      <para><filename>/var/tmp/root</filename>
	以下にインストールされているファイルの中には、
	<quote>.</quote> から始まっているものがあります。
	<command>ls -a</command> を使って確かめてください。</para>

      <para>もっとも簡単な方法は、二つのファイルを比較するコマンド
	&man.diff.1; を使うことです。</para>

      <screen>&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>

      <para>このコマンドは、<filename>/etc/shells</filename> ファイルと
	新しい <filename>/var/tmp/root/etc/shells</filename>
	ファイルの異なる部分を表示します。
	内容を確認して、書き換えたものに変更点をマージするか、
        それとも既存のファイルを新しいもので上書きするかを判断してください。</para>

      <tip>
	<title>新しい root ディレクトリ
	  (<filename>/var/tmp/root</filename>) の名前に
          タイムスタンプを付けておくと、
          異なるバージョン間の比較を楽に行なうことができます。</title>

	<para>頻繁にシステムの再構築を行なうということは、
	  <filename>/etc</filename> の更新もまた、
	  頻繁に行う必要があるということです。
	  これはちょっと手間のかかる作業です。</para>

	<para>この作業は、あなたが <filename>/etc</filename>
	  にマージした、
          新しく変更されたファイルの最新のセットのコピーを保存しておくことで
          素早く行なうことができます。</para>

	<procedure>
	  <step>
	    <para>普通に make world します。
	      <filename>/etc</filename> や
	      他のディレクトリを更新したくなったときは、ターゲット
	      ディレクトリに、そのときの日付に基づく名前をつけてください。</para>

	      <screen>&prompt.root; <userinput>mkdir /var/tmp/root-20130214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-20130214 \
    distrib-dirs distribution</userinput></screen>
	  </step>

	  <step>
	    <para>上に説明されているように、
	      このディレクトリから変更点をマージします。
              その作業が終了しても、
              <filename>/var/tmp/root-20130214</filename>
	      を削除しては<emphasis>いけません</emphasis>。</para>
	  </step>

	  <step>
	    <para>最新版のソースをダウンロードして再構築したら、
	      ステップ 1 にしたがってください。今度は、
	      新しい日付を反映したディレクトリを作成してください。
	      この例では、<filename>/var/tmp/root-20130221</filename>
	      という新しいディレクトリをつくります。</para>
	  </step>

	  <step>
	    <para>&man.diff.1; を使用し、
              二つのディレクトリを比較する再帰的 diff を作成することで、
              一週間の間に行なわれたソースへの変更による相違点を調べます。
            </para>

	    <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-20130214 root-20130221</userinput></screen>

	    <para>これによって報告される相違点は、大抵の場合、<filename>/var/tmp/root-20130221/etc</filename>
	      と
	      <filename>/etc</filename>
	      との相違点に比べて非常に少ないものになります。
	      相違点が少ないため、変更点を既存の
	      <filename>/etc</filename>
	      にマージすることは、比較的容易になります。</para>
	  </step>

	  <step>
	    <para>ここまで終了したら、
	      <filename>/var/tmp/root-*</filename>
              の二つのうち、古い方のディレクトリは削除して構いません。
            </para>

	      <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-20130214</userinput></screen>
	  </step>

	  <step>
	    <para>この工程を、
	      <filename>/etc</filename>
	      へ変更点をマージする必要があるたび、繰り返してください。</para>
	  </step>
	</procedure>

	<para>ディレクトリ名の生成を自動化するには、&man.date.1;
	  を利用してください。</para>

	<screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
      </tip>
      </sect3>
    </sect2>

    <sect2 xml:id="make-delete-old">
      <info><title>使われなくなったファイル、ディレクトリの削除</title>
	<authorgroup>
	  <author><personname><firstname>Anton</firstname><surname>Shterenlikht</surname></personname><contrib>ベースとなったノートの提供: </contrib></author>
	</authorgroup>
      </info>
      

      <indexterm>
	<primary>Deleting obsolete files and directories</primary>
      </indexterm>

      <para>&os; の開発サイクルにおいて、
	ファイルやシステムの一部が使われなくなることがあります。
	それらの機能が別の場所で実装されたり、
	ライブラリのバージョン番号が変わったり、
	システムから完全に削除されることがあるためです。
	システムのアップデート時に削除が必要になるのは、
	古いファイル、ライブラリそしてディレクトリです。
	これらのファイルを削除することで、
	記憶媒体やバックアップ媒体において不必要な容量を占めている古いファイルが、
	システム上に散乱することがなくなります。
	また、古いライブラリのセキュリティや安定性に問題があると、
	ライブラリを新しくしてシステムを安定な状態にし、
	古いライブラリによりシステムがクラッシュすることを防がなければなりません。
	使われなくなったファイル、ディレクトリ、ライブラリは
	<filename>/usr/src/ObsoleteFiles.inc</filename>
	にまとめられています。以下の手順により、
	アップグレードの過程でこれらのファイルを削除できます。</para>

      <para>
	<command>make installworld</command>
	と、その後の <command>mergemaster</command> が無事に終わったら、
	以下の方法で使われなくなったファイルやライブラリを確認してください。</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make check-old</userinput></screen>

      <para>見つかった古いファイルは、以下のコマンドで削除できます。</para>

      <screen>&prompt.root; <userinput>make delete-old</userinput></screen>

      <tip>
	<para>その他のターゲットについては
	  <filename>/usr/src/Makefile</filename> をご覧ください。</para>
      </tip>

      <para>使われなくなったファイルを削除する際、
	ファイルごとに確認が求められます。
	確認を省略し、自動的にファイルを削除するには、
	以下のように <varname>BATCH_DELETE_OLD_FILES</varname>
	を設定してください。</para>

      <screen>&prompt.root; <userinput>make -DBATCH_DELETE_OLD_FILES delete-old</userinput></screen>

      <para><command>yes</command>
	をコマンドへパイプでつなげても省略できます。</para>

      <screen>&prompt.root; <userinput>yes|make delete-old</userinput></screen>

    </sect2>

    <sect2 xml:id="updating-upgrading-rebooting">
      <title>再起動</title>

      <para>すべてがあるべき正しい場所に存在することをチェックしたら、
	&man.shutdown.8; を実行してシステムを再起動してください。</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>
    </sect2>

    <sect2 xml:id="make-delete-old-libs">
      <title>使われなくなったライブラリの削除</title>

      <warning>
	<title>Warning</title>

        <para>使われなくなったファイルを削除すると、
	  削除したファイルに依存していたアプリケーションは壊れてしまいます。
	  特に、古いライブラリを削除する場合に起こり得ます。
	  通常、<command>make
	    delete-old-libs</command>
	  を実行する前に、
	  これらの古いライブラリを使っているプログラム、ports、
	  ライブラリを再構築する必要があります。</para>
      </warning>

      <para>共有ライブラリをチェックするユーティリティとして、
	Ports Collection の
	<package>sysutils/libchk</package> や
	<package>sysutils/bsdadminscripts</package>
	を利用できます。</para>

      <para>使われなくなった共有ライブラリは、
	新しいライブラリと競合し、以下のようなメッセージを表示することがあります。</para>

      <screen>/usr/bin/ld: warning: libz.so.4, needed by /usr/local/lib/libtiff.so, may conflict with libz.so.5
/usr/bin/ld: warning: librpcsvc.so.4, needed by /usr/local/lib/libXext.so, may conflict with librpcsvc.so.5</screen>

      <para>この問題を解決するには、
	まずライブラリがどの port によってインストールされたかを調べて下さい。</para>

      <screen>&prompt.root; <userinput>pkg_info -W  /usr/local/lib/libtiff.so</userinput>
  /usr/local/lib/libtiff.so was installed by package tiff-3.9.4
  &prompt.root; <userinput>pkg_info -W /usr/local/lib/libXext.so</userinput>
  /usr/local/lib/libXext.so was installed by package libXext-1.1.1,1</screen>

      <para>見つかった port をアンインストールし、
	再構築、再インストールしてください。
	この過程は <package>ports-mgmt/portmaster</package>
	で自動化できます。
	すべての ports が再構築され、
	古いライブラリがどこにも使われていないことを確認したら、
	以下のコマンドで古いライブラリを削除してください。</para>

      <screen>&prompt.root; <userinput>make delete-old-libs</userinput></screen>
      <para>ここまで来れば、&os; システムのアップグレードは成功です。
	おめでとうございます。</para>

      <para>もしちょっとした問題があった場合でも、
        システムの一部を再構築するのは簡単です。
	たとえば、アップグレードや <filename>/etc</filename>
	のマージの途中で誤って
	<filename>/etc/magic</filename> を削除してしまい、
	その結果 &man.file.1; が動作しなくなってしまったような場合には、
	次のコマンドを実行して修復してください。</para>

	<screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2 xml:id="updating-questions">
      <title>質問ですか?</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>変更が行なわれたら、その度にシステムの再構築が必要になるのでしょうか?</para>
	  </question>

	  <answer>
	    <para>それは変更の性質によるので、なんとも言えません。
	      たとえば、<application>svn</application> を実行したとき、
	      次にあげるようなファイルが更新されていたとします。</para>

	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

	    <para>このときには、改めてシステム全体を再構築する必要はないでしょう。
	      そのかわり、適切なサブディレクトリに移って
	      <command>make all install</command> を行ってください。
	      しかし、たとえば <filename>src/lib/libc/stdlib</filename>
	      のような大きな変更が行なわれた場合には、
	      システム全体を再構築するか、
	      少なくとも静的にリンクされているものを作り直す必要があります。</para>

	    <para>結局のところ、
	      どの時点で現在のシステムをアップグレードするかはあなたが決めることです。
	      2 週間ごとにシステムを再構築し、その 2 週間の変更を取り込むユーザもいますし、
	      変更のあった部分だけ再構築し、
	      すべての依存関係を確かめたいと考えるユーザもいます。</para>

	    <para>それらはどのくらいの頻度でアップグレードしたいか、
	      そして &os.stable; か &os.current; のどちらを追いかけているのかによります。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>signal 11<indexterm>
	        <primary>signal 11</primary>
	      </indexterm>
	      (もしくは他のシグナル番号) のエラーがたくさん出て
	      コンパイルが失敗します。何が起こっているんでしょうか?</para>
	  </question>

	  <answer>
	    <para>これは通常、ハードウェアに問題があることを示しています。
              システムの再構築は、ハードウェアに対する負荷耐久試験を行なうための
              有効な手段の一つで、メモリに関係する問題がよく報告されます。
	      その大部分は、
              不可解な異常終了となることで発見されます。</para>

	    <para>本当にこの問題によるものかどうかは、<application>make</application>
	      をもう一度実行し、
              異なる段階で異常終了が発生するか、ということから確認できます。</para>

	    <para>このエラーに対応するには、マシンの部品を交換して、
	      どの部分が悪いのかを調べてみてください。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>終了したら <filename>/usr/obj</filename>
	      を削除してもかまいませんか?</para>
	  </question>

	  <answer>
	    <para>一言で答えるなら「削除しても構わない」です。</para>

	    <para><filename>/usr/obj</filename> には、
              コンパイルの段階で生成された
              すべてのオブジェクトファイルが含まれています。
              通常 <command>make buildworld</command> の最初の段階では、
              このディレクトリを削除して新しくつくり直すようになっています。
	      構築終了後も <filename>/usr/obj</filename>
              を保存しておいても、あまり意味はありません。
	      削除すれば、だいたい 2&nbsp;GB
	      のディスクスペースを解放することができます。</para>

	    <para>良く理解をしているユーザであれば、
	      この段階を省略して <command>make buildworld</command>
	      を行なうことができます。
	      こうすると、ほとんどのソースは再コンパイルされないため、
              構築はかなり高速化されます。
	      これは裏をかえせば、デリケートな依存関係の問題によって、
              システムの構築が奇妙な失敗に終わる可能性があるということです。
              &os; メーリングリストではしばしば、構築の失敗が、
              この段階の省略によるものだということを理解せずに
              不満の声をあげる人がいます。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>構築を中断した場合、その構築を途中から再開することはできますか?</para>
	  </question>

	  <answer>
	    <para>それは、問題が起こるまでに、
              どれだけの作業を終えているかによって変わります。</para>

	    <para>一般的に <command>make buildworld</command> は、
	      &man.gcc.1; や &man.make.1; まどの基本的なツールや、
	      システムライブラリの新しいコピーを作成します。
	      その後、これらのツールやライブラリがインストールされてから、
              自分自身の再構築に使われ、もう一度、インストールされます。
	      &man.ls.1; や &man.grep.1;
	      といった標準的なユーザプログラムを含むシステム全体が、 
	      その新しいシステムファイルを用いて作り直されます。</para>

	    <para>再構築の最終段階では、
	      まったく安全に次のようにすることができます。</para>

	    <screen><emphasis>&hellip; fix the problem &hellip;</emphasis>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNO_CLEAN all</userinput></screen>

	    <para>
              これは、前回の <command>make buildworld</command>
              の作業をやり直しません。
            </para>

	    <para>次のメッセージ</para>

	      <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

	    <para>が <command>make buildworld</command> の出力にある場合には、
	      上のようにしてもほとんど悪影響が現れることはありません。</para>

	    <para>もしこのメッセージがないとか、よく分からないという場合には、
	      安全を確保し、後悔するようなことがないよう、
              システムの再構築を最初からやり直しましょう。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>どのようにすれば make world を高速化できますか?</para>
          </question>

          <answer>
	    <itemizedlist>
	      <listitem>
		<para>シングルユーザモードで動かしてください。</para>
	      </listitem>

	      <listitem>
		<para><filename>/usr/src</filename> と
		  <filename>/usr/obj</filename>
		  を、異なるディスク上の別のファイルシステムに置いてください。
		  また可能ならば、
		  異なるディスクコントローラに接続されたディスクを使ってください。</para>
	      </listitem>

	      <listitem>
		<para>さらに高速化するには、これらのファイルシステムを
		  &man.ccd.4; を使って、
		  複数のディスク上に置いてください。</para>
	      </listitem>

	      <listitem>
		<para><filename>/etc/make.conf</filename> に
		  <quote>NO_PROFILE=true</quote> をセットして、
		  プロファイル版の作成を無効化してください。</para>
	      </listitem>

	      <listitem>
		<para>&man.make.1; に
		  <option>-j<replaceable>n</replaceable></option>
		  を指定して、複数のプロセスを並列に実行させてください。
		  これは、単一のプロセッサでも複数のプロセッサでも、
		  同様に恩恵を得ることができます。</para>
	      </listitem>

	      <listitem>
		<para><filename>/usr/src</filename>
		  のあるファイルシステムを、<option>noatime</option>
		  オプションを付けてマウントもしくは再マウントしてください。
                  これは、そのファイルシステムにおいて、
                  最後にアクセスされた時刻の書き込みを抑制します。
		  おそらく、この情報が必要になることはないでしょう。</para>

                <screen>&prompt.root; <userinput>mount -u -o noatime /usr/src</userinput></screen>

                <warning>
                  <para>上の例は、
		    <filename>/usr/src</filename>
		    自身が独立したファイルシステムであることを想定しています。
		    もし <filename>/usr</filename>
		    の一部である場合には、
		    かわりに適切なマウントポイントを指定すしてください。</para>
                </warning>
              </listitem>

	      <listitem>
		<para><filename>/usr/obj</filename>
		  のあるファイルシステムを、<option>async</option>
		  オプションをつけてマウントもしくは再マウントしてください。
		  これによって、ディスクへの書き込みが非同期になります。
                  つまり、書き込み命令はすぐに完了するのに対し、
                  実際にデータがディスクに書き込まれるのは、その数秒後になります。
                  これによって、書き込み処理の一括化が可能になるため、
		  劇的なパフォーマンスの向上が期待できます。
                  <!-- hrs:2000/02/15 (for ja-translators)
                       "be clusterd togather" is translated into "clusterization" -->
                </para>

		<warning>
		  <para>
                    このオプションを指定すると、ファイルシステムは
		    壊れやすくなってしまうことに注意してください。
                    このオプションを付けていて、突然電源が落ちた場合には、
                    再起動後にファイルシステムが復旧不能になる可能性が
                    非常に高くなります。</para>

		  <para>もし、<filename>&gt;/usr/obj</filename>
		    が、ファイルシステムにある唯一のディレクトリであれば、
		    これは問題になりません。
                    しかし、同じファイルシステムに、他の貴重なデータを置いているときには、
		    このオプションを有効にする前に、
		    バックアップをきちんと取っておきましょう。</para>
		</warning>

		<screen>&prompt.root; <userinput>mount -u -o async /usr/obj</userinput></screen>

		<warning>
		  <para>もし <filename>/usr/obj</filename>
		    自身がファイルシステムでない場合には、
		    適切なマウントポイントを指すように、
                    上の例の名前を置き換えてください。</para>
		</warning>
	      </listitem>
	    </itemizedlist>
	  </answer>
	</qandaentry>

        <qandaentry>
          <question>
            <para>なにか悪いことがあったらどうすればいいですか?</para>
          </question>

          <answer>
            <para>自分の環境に前のビルドの余計なゴミが残っていないことをはっきりと確認してください。</para>

            <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root; <userinput>rm -rf /usr/obj/usr</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

            <para>ええ、<command>make cleandir</command>
	      は本当に 2 回実行するのです。</para>

            <para>そして、<command>make buildworld</command> を行い、
	      全プロセスを最初からやり直してください。</para>

            <para>まだ問題があれば、エラーと <command>uname -a</command>
	      の出力を &a.questions; に送ってください。
	      設定についてさらに質問されても答えられるよう用意してください!</para>
          </answer>
        </qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 xml:id="small-lan">
    <info><title>複数のマシンで追いかける</title>
      <authorgroup>
	<author><personname><firstname>Mike</firstname><surname>Meyer</surname></personname><contrib>寄稿: </contrib></author>
      </authorgroup>
    </info>
    
    <indexterm>
      <primary>NFS</primary>
      <secondary>複数のマシンにインストール</secondary>
    </indexterm>

    <para>複数のコンピュータで同じソースツリーを追いかけていて、
      全部のマシンにソースをダウンロードして全部を再構築するのは、
      ディスクスペース、ネットワーク帯域、そして CPU サイクルの無駄使いです。
      解決策は 1 つのマシンに仕事のほとんどをさせ、
      残りのマシンは NFS 経由でそれをマウントする、というものです。
      このセクションではそのやり方を概観します。</para>

    <sect2 xml:id="small-lan-preliminaries">
      <title>準備</title>

      <para>まず初めに、同じバイナリで動かそうとするマシンたちを決めます。
	このマシンたちのことを<emphasis>ビルドセット</emphasis>と呼びます。
	それぞれのマシンはカスタムカーネルを持っているかもしれませんが、
	同じユーザランドバイナリを動かそうというのです。
	このビルドセットから、
	<emphasis>ビルドマシン</emphasis>となるマシンを 1 台選びます。
	ベースシステムとカーネルを構築するのはこのマシンになります。
	理想的には、このマシンは <command>make buildworld</command>
	と <command>make buildkernel</command>
	を実行するのに十分な CPU を持った速いマシンであるべきです。
	<emphasis>テストマシン</emphasis>となるべきマシンも選んでください。
	更新されたソフトウェアを使う前にそのマシンでテストするのです。
	テストマシンはかなり長い時間落ちていても
	だいじょうぶなマシン<emphasis>であったほうがいいでしょう</emphasis>。
	ビルドマシンでもかまいませんが、ビルドマシンである必要はありません。</para>

      <para>このビルドセットのマシンはすべて
	<filename>/usr/obj</filename> と
	<filename>/usr/src</filename>
	を同じマシンの同じ場所からマウントする必要があります。
	理想的にはビルドマシンの 2 つの違うドライブ上にあるとよいのですが、
	ビルドマシンに NFS マウントされていてもかまいません。
	ビルドセット自体が複数ある場合は、
	<filename>/usr/src</filename>
	はひとつのビルドマシン上にあるべきです。
	他のマシンからはそれを NFS マウントするようにしましょう。</para>

      <para>最後にビルドセットのすべてのマシン上の
	<filename>/etc/make.conf</filename> と
	<filename>/etc/src.conf</filename>
	がビルドマシンと一致していることを確認してください。
	つまり、ビルドマシンはビルドセットのどのマシンもインストールしようとしている
	ベースシステムを全部ビルドしなければならないということです。
	また、各ビルドマシンは <filename>/etc/make.conf</filename>
	にそれぞれのビルドマシンのカーネル名を
	<varname>KERNCONF</varname> で指定し、
	ビルドマシンは自分自身のカーネルから順に全部のカーネル名を
	<varname>KERNCONF</varname> にリストアップしてください。
	各マシンのカーネルもビルドするのであれば、
	ビルドマシンは各マシンのカーネル設定ファイルを <filename>/usr/src/sys/arch/conf</filename>
	に持っていなければなりません。</para>
    </sect2>

    <sect2 xml:id="small-lan-base-system">
      <title>ベースシステム</title>

      <para>ビルドマシンにて、
	<xref linkend="make-buildworld"/>
	に書いてあるようにカーネルとベースシステムを構築してください。
	でも、まだインストールしないでください。
	ビルドが終わったら、テストマシンに移り、
	ビルドしたカーネルをインストールしてください。
	テストマシンが NFS 経由で
	<filename>/usr/src</filename> と
	<filename>/usr/obj</filename>
	をマウントしているなら、
	シングルユーザで再起動したときにネットワークを使えるようにして、
	これらのディレクトリをマウントするようにしてください。
	もっとも簡単な方法は、
	マルチユーザモードで起動して、<command>shutdown now</command>
	を実行してシングルユーザモードに移行することです。
	そうしたら、カーネルとベースシステムをインストールし、
	いつもするように
	<command>mergemaster</command> を実行してください。
	終わったら、
	テストマシンを再起動して通常のマルチユーザ動作に戻します。</para>

      <para>テストマシンにあるものすべてがちゃんと動いている確信が得られたら、
        同じ手順でビルドセットの他のマシンにも新しいソフトウェアをインストールします。</para>
    </sect2>

    <sect2 xml:id="small-lan-ports">
      <title>Ports</title>

      <para>ports ツリーにも同じアイデアが使えます。
	最初に重要な点は、
	ビルドセットのすべてのマシンに同じマシンの <filename>/usr/ports</filename> をマウントすることです。
	そして、distfiles を共有するように
	<filename>/etc/make.conf</filename> を適切に設定します。
	NFS マウントによってマップされる <systemitem class="username">root</systemitem>
	ユーザが何であれ、<varname>DISTDIR</varname>
	はそのユーザが書き込める共通の共有ディレクトリに設定する必要があります。
	各マシンは <varname>WRKDIRPREFIX</varname>
	を自分のマシンのビルドディレクトリに設定しなければなりません。
	最後に、packages をビルドして配布するのであれば、
	<varname>DISTDIR</varname> と同じように
	<varname>PACKAGES</varname> ディレクトリも設定してください。</para>
    </sect2>
  </sect1>
</chapter>
