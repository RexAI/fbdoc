<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project

     $FreeBSD$
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="advanced-networking">
  <title>Advanced Networking</title>

  <sect1 xml:id="advanced-networking-synopsis">
    <title>Synopsis</title>

    <para>This chapter covers a number of advanced networking
      topics.</para>

    <para>After reading this chapter, you will know:</para>

    <itemizedlist>
      <listitem>
	<para>The basics of gateways and routes.</para>
      </listitem>

      <listitem>
	<para>How to set up &ieee; 802.11 and &bluetooth;
	  devices.</para>
      </listitem>

      <listitem>
	<para>How to make &os; act as a bridge.</para>
      </listitem>

      <listitem>
	<para>How to set up network booting on a diskless
	  machine.</para>
      </listitem>

      <listitem>
	<para>How to set up network <acronym>PXE</acronym> booting
	  with an
	  <acronym>NFS</acronym> root file system.</para>
      </listitem>

      <listitem>
	<para>How to set up network address translation.</para>
      </listitem>

      <listitem>
	<para>How to set up <acronym>IPv6</acronym> on a &os;
	  machine.</para>
      </listitem>

      <listitem>
	<para>How to configure <acronym>ATM</acronym>.</para>
      </listitem>

      <listitem>
	<para>How to enable and utilize the features of the Common
	  Address Redundancy Protocol (<acronym>CARP</acronym>) in
	  &os;.</para>
      </listitem>
    </itemizedlist>

    <para>Before reading this chapter, you should:</para>

    <itemizedlist>
      <listitem>
	<para>Understand the basics of the
	  <filename>/etc/rc</filename> scripts.</para>
      </listitem>

      <listitem>
	<para>Be familiar with basic network terminology.</para>
      </listitem>

      <listitem>
	<para>Know how to configure and install a new &os; kernel
	  (<xref linkend="kernelconfig"/>).</para>
      </listitem>

      <listitem>
	<para>Know how to install additional third-party software
	  (<xref linkend="ports"/>).</para>
      </listitem>

    </itemizedlist>
  </sect1>

  <sect1 xml:id="network-routing">
    <info><title>Gateways and Routes</title>
      <authorgroup>
	<author><personname><firstname>Coranth</firstname><surname>Gryphon</surname></personname><contrib>Contributed by </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>routing</primary></indexterm>
    <indexterm><primary>gateway</primary></indexterm>
    <indexterm><primary>subnet</primary></indexterm>

    <para>For one machine to be able to find another over a network,
      there must be a mechanism in place to describe how to get from
      one to the other.  This is called
      <firstterm>routing</firstterm>.  A <quote>route</quote> is a
      defined pair of addresses: a <quote>destination</quote> and a
      <quote>gateway</quote>.  The pair indicates that when trying
      to get to this <emphasis>destination</emphasis>, communicate
      through this <emphasis>gateway</emphasis>.  There are three
      types of destinations: individual hosts, subnets, and
      <quote>default</quote>.  The <quote>default route</quote> is
      used if none of the other routes apply.  There are also three
      types of gateways: individual hosts, interfaces (also called
      <quote>links</quote>), and Ethernet hardware
      (<acronym>MAC</acronym>) addresses.</para>

    <sect2>
      <title>An Example</title>

      <para>This example &man.netstat.1; output illustrates several
	aspects of routing:</para>

      <screen>&prompt.user; <userinput>netstat -r</userinput>
Routing tables

Destination      Gateway            Flags     Refs     Use     Netif Expire

default          outside-gw         UGSc       37      418      ppp0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       ed0     77
10.20.30.255     link#1             UHLW        1     2421
example.com      link#1             UC          0        0
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 =&gt;
host2.example.com link#1             UC          0        0
224              link#1             UC          0        0</screen>

      <indexterm><primary>default route</primary></indexterm>
      <para>The first two lines specify the default route, described
	in more detail in <xref linkend="network-routing-default"/>,
	and the <systemitem>localhost</systemitem> route.</para>

      <indexterm><primary>loopback device</primary></indexterm>
      <para>The interface (<literal>Netif</literal> column) that this
	routing table specifies to use for
	<literal>localhost</literal> is <filename>lo0</filename>,
	also known as the loopback device.  This says to keep all
	traffic for this destination internal, rather than sending it
	out over the network.</para>

      <indexterm>
	<primary>Ethernet</primary>
	<secondary>MAC address</secondary>
      </indexterm>
      <para>The addresses beginning with <systemitem class="etheraddress">0:e0:</systemitem> are Ethernet hardware addresses,
	also known as <acronym>MAC</acronym> addresses.  &os; will
	automatically identify any hosts, <systemitem>test0</systemitem> in
	the example, on the local Ethernet and add a route for that
	host over the Ethernet interface,
	<filename>ed0</filename>.  This type of route has a
	timeout, seen in the <literal>Expire</literal> column, which
	is used if the host does not respond in a specific amount of
	time.  When this happens, the route to this host will be
	automatically deleted.  These hosts are identified using the
	Routing Information Protocol (<acronym>RIP</acronym>), which
	calculates routes to local hosts based upon a shortest path
	determination.</para>

      <indexterm><primary>subnet</primary></indexterm>

      <para>&os; will add subnet routes for the local subnet.
	<systemitem class="ipaddress">10.20.30.255</systemitem> is the broadcast
	address for the subnet <systemitem class="ipaddress">10.20.30</systemitem>
	and <systemitem class="fqdomainname">example.com</systemitem> is the
	domain name associated with that subnet.  The designation
	<literal>link#1</literal> refers to the first Ethernet card in
	the machine.</para>

      <para>Local network hosts and local subnets have their routes
	automatically configured by a daemon called &man.routed.8;.
	If it is not running, only routes which are statically defined
	by the administrator will exist.</para>

      <para>The <literal>host1</literal> line refers to the host
	by its Ethernet address.  Since it is the sending host, &os;
	knows to use the loopback interface
	(<filename>lo0</filename>) rather than the Ethernet
	interface.</para>

      <para>The two <literal>host2</literal> lines represent aliases
	which were created using &man.ifconfig.8;.  The
	<literal>=&gt;</literal> symbol after the
	<filename>lo0</filename> interface says that an alias
	has been set in addition to the loopback address.  Such routes
	only show up on the host that supports the alias; all other
	hosts on the local network will have a
	<literal>link#1</literal> line for such routes.</para>

      <para>The final line (destination subnet <systemitem class="ipaddress">224</systemitem>) deals with
	multicasting.</para>

      <para>Finally, various attributes of each route can be seen in
	the <literal>Flags</literal> column.  Below is a short table
	of some of these flags and their meanings:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*"/>
	  <colspec colwidth="4*"/>

	  <tbody>
	    <row>
	      <entry>U</entry>
	      <entry>Up: The route is active.</entry>
	    </row>

	    <row>
	      <entry>H</entry>
	      <entry>Host: The route destination is a single
		host.</entry>
	    </row>

	    <row>
	      <entry>G</entry>
	      <entry>Gateway: Send anything for this destination on to
		this remote system, which will figure out from there
		where to send it.</entry>
	    </row>

	    <row>
	      <entry>S</entry>
	      <entry>Static: This route was configured manually, not
		automatically generated by the system.</entry>
	    </row>

	    <row>
	      <entry>C</entry>
	      <entry>Clone: Generates a new route based upon this
		route for machines to connect to.  This type of route
		is normally used for local networks.</entry>
	    </row>

	    <row>
	      <entry>W</entry>
	      <entry>WasCloned: Indicated a route that was
		auto-configured based upon a local area network
		(Clone) route.</entry>
	    </row>

	    <row>
	      <entry>L</entry>
	      <entry>Link: Route involves references to Ethernet
		hardware.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2 xml:id="network-routing-default">
      <title>Default Routes</title>

      <indexterm><primary>default route</primary></indexterm>

      <para>When the local system needs to make a connection to a
	remote host, it checks the routing table to determine if a
	known path exists.  If the remote host falls into a subnet
	that it knows how to reach, the system checks to see if it
	can connect using that interface.</para>

      <para>If all known paths fail, the system has one last option:
	the <quote>default</quote> route.  This route is a special
	type of gateway route (usually the only one present in the
	system), and is always marked with a <literal>c</literal> in
	the flags field.  For hosts on a local area network, this
	gateway is set to the system which has a direct connection to
	the Internet.</para>

      <para>The default route for a machine which itself is
	functioning as the gateway to the outside world, will be the
	gateway machine at the Internet Service Provider
	(<acronym>ISP</acronym>).</para>

      <para>This example is a common configuration for a default
	route:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="advanced-networking/net-routing"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced">
[Local2]  &lt;--ether--&gt;  [Local1]  &lt;--PPP--&gt; [ISP-Serv]  &lt;--ether--&gt;  [T1-GW]</literallayout>
	</textobject>
      </mediaobject>

      <para>The hosts <systemitem>Local1</systemitem> and
	<systemitem>Local2</systemitem> are on the local network.
	<systemitem>Local1</systemitem> is connected to an
	<acronym>ISP</acronym> using a
	<acronym>PPP</acronym> connection.  This
	<acronym>PPP</acronym> server is connected through a local
	area network to another gateway computer through an external
	interface to the <acronym>ISP</acronym>.</para>

      <para>The default routes for each machine will be:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Host</entry>
	      <entry>Default Gateway</entry>
	      <entry>Interface</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Local2</entry>
	      <entry>Local1</entry>
	      <entry>Ethernet</entry>
	    </row>

	    <row>
	      <entry>Local1</entry>
	      <entry>T1-GW</entry>
	      <entry>PPP</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>A common question is <quote>Why is
	  <systemitem>T1-GW</systemitem> configured as the default gateway for
	  <systemitem>Local1</systemitem>, rather than the
	  <acronym>ISP</acronym> server it is connected
	  to?</quote>.</para>

      <para>Since the <acronym>PPP</acronym> interface is using an
	address on the <acronym>ISP</acronym>'s local network for
	the local side of the connection, routes for any other
	machines on the <acronym>ISP</acronym>'s local network will
	be automatically generated.  The system already knows how
	to reach the <systemitem>T1-GW</systemitem> machine, so there is no
	need for the intermediate step of sending traffic to the
	<acronym>ISP</acronym>'s server.</para>

      <para>It is common to use the address <systemitem class="ipaddress">X.X.X.1</systemitem> as the gateway address for
	the local network.  So, if the local class C address space is
	<systemitem class="ipaddress">10.20.30</systemitem> and the
	<acronym>ISP</acronym> is using <systemitem class="ipaddress">10.9.9</systemitem>, the default routes would
	be:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Host</entry>
	      <entry>Default Route</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Local2 (10.20.30.2)</entry>
	      <entry>Local1 (10.20.30.1)</entry>
	    </row>

	    <row>
	      <entry>Local1 (10.20.30.1, 10.9.9.30)</entry>
	      <entry>T1-GW (10.9.9.1)</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>The default route can be easily defined in
	<filename>/etc/rc.conf</filename>.  In this example, on
	<systemitem>Local2</systemitem>, add the following line to
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>defaultrouter="10.20.30.1"</programlisting>

      <para>It is also possible to add the route directly using
	&man.route.8;:</para>

      <screen>&prompt.root; <userinput>route add default 10.20.30.1</userinput></screen>

      <para>For more information on manual manipulation of network
	routing tables, refer to &man.route.8;.</para>
    </sect2>

    <sect2 xml:id="network-dual-homed-hosts">
      <title>Dual Homed Hosts</title>

      <indexterm><primary>dual homed hosts</primary></indexterm>

      <para>A a dual-homed system is a host which resides on two
	different networks.</para>

      <para>The dual-homed machine might have two Ethernet cards, each
	having an address on a separate subnet.  Alternately, the
	machine can have one Ethernet card and uses &man.ifconfig.8;
	aliasing.  The former is used if two physically separate
	Ethernet networks are in use and the latter if there is one
	physical network segment, but two logically separate
	subnets.</para>

      <para>Either way, routing tables are set up so that each subnet
	knows that this machine is the defined gateway (inbound route)
	to the other subnet.  This configuration, with the machine
	acting as a router between the two subnets, is often used
	to implement packet filtering or firewall security in
	either or both directions.</para>

      <para>For this machine to forward packets between the two
	interfaces, &os; must be configured as a router, as
	demonstrated in the next section.</para>
    </sect2>

    <sect2 xml:id="network-dedicated-router">
      <title>Building a Router</title>

      <indexterm><primary>router</primary></indexterm>

      <para>A network router is a system that forwards packets from
	one interface to another.  Internet standards and good
	engineering practice prevent the &os; Project from enabling
	this by default in &os;.  This feature can be enabled by
	changing the following variable to <literal>YES</literal> in
	&man.rc.conf.5;:</para>

      <programlisting>gateway_enable="YES"          # Set to YES if this host will be a gateway</programlisting>

      <para>This option will set the &man.sysctl.8; variable
	<varname>net.inet.ip.forwarding</varname> to
	<literal>1</literal>.  To stop routing, reset this to
	<literal>0</literal>.</para>

      <indexterm><primary>BGP</primary></indexterm>
      <indexterm><primary>RIP</primary></indexterm>
      <indexterm><primary>OSPF</primary></indexterm>
      <para>The new router will need routes to know where to send the
	traffic.  If the network is simple enough, static routes can
	be used.  &os; comes with the standard BSD routing daemon
	&man.routed.8;, which speaks <acronym>RIP</acronym> versions
	1 and 2, and <acronym>IRDP</acronym>.  Support for
	<acronym>BGP</acronym>v4, <acronym>OSPF</acronym>v2, and other
	sophisticated routing protocols is available with the
	<package>net/zebra</package> package or
	port.</para>
    </sect2>

    <sect2 xml:id="network-static-routes">
      <info><title>Setting Up Static Routes</title>
	<authorgroup>
	  <author><personname><firstname>Al</firstname><surname>Hoang</surname></personname><contrib>Contributed by </contrib></author>
	</authorgroup>
      </info>
      <!-- Feb 2004 -->
      

      <sect3>
	<title>Manual Configuration</title>

	<para>Consider the following network:</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="advanced-networking/static-routes"/>
	  </imageobject>

	  <textobject>
	<literallayout class="monospaced">
    INTERNET
      | (10.0.0.1/24) Default Router to Internet
      |
      |Interface xl0
      |10.0.0.10/24
   +------+
   |      | RouterA
   |      | (FreeBSD gateway)
   +------+
      | Interface xl1
      | 192.168.1.1/24
      |
  +--------------------------------+
   Internal Net 1      | 192.168.1.2/24
                       |
                   +------+
                   |      | RouterB
                   |      |
                   +------+
                       | 192.168.2.1/24
                       |
                     Internal Net 2</literallayout>
	  </textobject>
	</mediaobject>

	<para>In this scenario, <systemitem>RouterA</systemitem> is a &os;
	  machine that is acting as a router to the rest of the
	  Internet.  It has a default route set to <systemitem class="ipaddress">10.0.0.1</systemitem> which allows it to
	  connect with the outside world.  <systemitem>RouterB</systemitem> is
	  already configured properly as it uses <systemitem class="ipaddress">192.168.1.1</systemitem> as the gateway.</para>

	<para>The routing table on <systemitem>RouterA</systemitem> looks
	  something like this:</para>

	<screen>&prompt.user; <userinput>netstat -nr</userinput>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0.0/24        link#1             UC          0        0    xl0
192.168.1.0/24     link#2             UC          0        0    xl1</screen>

	<para>With the current routing table, <systemitem>RouterA</systemitem>
	  cannot reach Internal Net 2 as it does not have a route for
	  <systemitem class="ipaddress">192.168.2.0/24</systemitem>.  The
	  following command adds the Internal Net 2 network to
	  <systemitem>RouterA</systemitem>'s routing table using <systemitem class="ipaddress">192.168.1.2</systemitem> as the next
	  hop:</para>

	<screen>&prompt.root; <userinput>route add -net 192.168.2.0/24 192.168.1.2</userinput></screen>

	<para>Now <systemitem>RouterA</systemitem> can reach any hosts on the
	  <systemitem class="ipaddress">192.168.2.0/24</systemitem>
	  network.</para>
      </sect3>

      <sect3>
	<title>Persistent Configuration</title>

	<para>The above example configures a static route on a
	  running system.  However, the routing information will not
	  persist if the &os; system reboots.  Persistent static
	  routes can be entered in
	  <filename>/etc/rc.conf</filename>:</para>

	<programlisting># Add Internal Net 2 as a static route
static_routes="internalnet2"
route_internalnet2="-net 192.168.2.0/24 192.168.1.2"</programlisting>

	<para>The <literal>static_routes</literal> configuration
	  variable is a list of strings separated by a space, where
	  each string references a route name.  This example only
	  has one string in <literal>static_routes</literal>,
	  <replaceable>internalnet2</replaceable>.  The variable
	  <literal>route_internalnet2</literal>
	  contains all of the configuration parameters to
	  &man.route.8;.  This example is equivalent to the
	  command:</para>

	  <screen>&prompt.root; <userinput>route add -net 192.168.2.0/24 192.168.1.2</userinput></screen>

	<para>Using more than one string in
	  <literal>static_routes</literal> creates multiple static
	  routes.  The following shows an example of adding static
	  routes for the <systemitem class="ipaddress">192.168.0.0/24</systemitem>
	  and <systemitem class="ipaddress">192.168.1.0/24</systemitem>
	  networks:</para>

	<programlisting>static_routes="net1 net2"
route_net1="-net 192.168.0.0/24 192.168.0.1"
route_net2="-net 192.168.1.0/24 192.168.1.1"</programlisting>
      </sect3>
    </sect2>

    <sect2 xml:id="network-routing-propagation">
      <title>Routing Propagation</title>

      <para>When an address space is assigned to a network, the
	service provider configures their routing tables so that all
	traffic for the network will be sent to the link for the
	site.  But how do external sites know to send their packets
	to the network's <acronym>ISP</acronym>?</para>

      <para>There is a system that keeps track of all assigned
	address spaces and defines their point of connection to the
	Internet backbone, or the main trunk lines that carry Internet
	traffic across the country and around the world.  Each
	backbone machine has a copy of a master set of tables, which
	direct traffic for a particular network to a specific
	backbone carrier, and from there down the chain of service
	providers until it reaches your network.</para>

      <para>It is the task of the service provider to advertise to
	the backbone sites that they are the point of connection, and
	thus the path inward, for a site.  This is known as route
	propagation.</para>
    </sect2>

    <sect2 xml:id="network-routing-troubleshooting">
      <title>Troubleshooting</title>

      <indexterm>
	<primary>&man.traceroute.8;</primary>
      </indexterm>

      <para>Sometimes, there is a problem with routing propagation
	and some sites are unable to connect.  Perhaps the most
	useful command for trying to figure out where routing is
	breaking down is &man.traceroute.8;.  It is useful when
	&man.ping.8; fails.</para>

      <para>When using &man.traceroute.8;, include the name of the
	remote host to connect to.  The output will show the gateway
	hosts along the path of the attempt, eventually either
	reaching the target host, or terminating because of a lack of
	connection.</para>

      <para>For more information, refer to &man.traceroute.8;.</para>
    </sect2>

    <sect2 xml:id="network-routing-multicast">
      <title>Multicast Routing</title>

      <indexterm>
	<primary>multicast routing</primary>
      </indexterm>
      <indexterm>
	<primary>kernel options</primary>
	<secondary>MROUTING</secondary>
      </indexterm>
      <para>&os; natively supports both multicast applications and
	multicast routing.  Multicast applications do not require any
	special configuration of &os;; as applications will generally
	run out of the box.  Multicast routing requires that support
	be compiled into a custom kernel:</para>

      <programlisting>options MROUTING</programlisting>

      <para>The multicast routing daemon, &man.mrouted.8;, must be
	configured to set up tunnels and <acronym>DVMRP</acronym> via
	<filename>/etc/mrouted.conf</filename>.  More details on
	multicast configuration may be found in
	&man.mrouted.8;.</para>

      <note>
	<para>The &man.mrouted.8; multicast routing daemon implements
	  the <acronym>DVMRP</acronym> multicast routing protocol,
	  which has largely been replaced by &man.pim.4; in many
	  multicast installations.  &man.mrouted.8; and the related
	  &man.map-mbone.8; and &man.mrinfo.8; utilities are available
	  in the &os; Ports&nbsp;Collection as <package>net/mrouted</package>.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 xml:id="network-wireless">
    <info><title>Wireless Networking</title>
      <authorgroup>
	<author><personname><othername>Loader</othername></personname></author>

	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname></author>

	<author><personname><firstname>Murray</firstname><surname>Stokely</surname></personname></author>
      </authorgroup>
    </info>
    

    <indexterm><primary>wireless networking</primary></indexterm>
    <indexterm>
      <primary>802.11</primary>
      <see>wireless networking</see>
    </indexterm>

    <sect2>
      <title>Wireless Networking Basics</title>

      <para>Most wireless networks are based on the &ieee; 802.11
	standards.  A basic wireless network consists of multiple
	stations communicating with radios that broadcast in either
	the 2.4GHz or 5GHz band, though this varies according to the
	locale and is also changing to enable communication in the
	2.3GHz and 4.9GHz ranges.</para>

      <para>802.11 networks are organized in two ways.  In
	<emphasis>infrastructure mode</emphasis>, one station acts as
	a
	master with all the other stations associating to it, the
	network is known as a <acronym>BSS</acronym>, and the master
	station is termed an access point (<acronym>AP</acronym>).
	In a <acronym>BSS</acronym>, all communication passes through
	the <acronym>AP</acronym>; even when one station wants to
	communicate with another wireless station, messages must go
	through the <acronym>AP</acronym>.  In the second form of
	network, there is no master and stations communicate directly.
	This form of network is termed an <acronym>IBSS</acronym>
	and is commonly known as an <emphasis>ad-hoc
	  network</emphasis>.</para>

      <para>802.11 networks were first deployed in the 2.4GHz band
	using protocols defined by the &ieee; 802.11 and 802.11b
	standard.  These specifications include the operating
	frequencies and the <acronym>MAC</acronym> layer
	characteristics, including framing and transmission rates,
	as communication can occur at various rates.  Later, the
	802.11a standard defined operation in the 5GHz band, including
	different signaling mechanisms and higher transmission rates.
	Still later, the 802.11g standard defined the use of 802.11a
	signaling and transmission mechanisms in the 2.4GHz band in
	such a way as to be backwards compatible with 802.11b
	networks.</para>

      <para>Separate from the underlying transmission techniques,
	802.11 networks have a variety of security mechanisms.  The
	original 802.11 specifications defined a simple security
	protocol called <acronym>WEP</acronym>.  This protocol uses a
	fixed pre-shared key and the RC4 cryptographic cipher to
	encode data transmitted on a network.  Stations must all
	agree on the fixed key in order to communicate.  This scheme
	was shown to be easily broken and is now rarely used except
	to discourage transient users from joining networks.  Current
	security practice is given by the &ieee; 802.11i specification
	that defines new cryptographic ciphers and an additional
	protocol to authenticate stations to an access point and
	exchange keys for data communication.  Cryptographic keys
	are periodically refreshed and there are mechanisms for
	detecting and countering intrusion attempts.  Another
	security protocol specification commonly used in wireless
	networks is termed <acronym>WPA</acronym>, which was a
	precursor to 802.11i.  <acronym>WPA</acronym> specifies a
	subset of the requirements found in 802.11i and is designed
	for implementation on legacy hardware.  Specifically,
	<acronym>WPA</acronym> requires only the
	<acronym>TKIP</acronym> cipher that is derived from the
	original <acronym>WEP</acronym> cipher.  802.11i permits use
	of <acronym>TKIP</acronym> but also requires support for a
	stronger cipher, AES-CCM, for encrypting data.  The
	<acronym>AES</acronym> cipher was not required in
	<acronym>WPA</acronym> because it was deemed too
	computationally costly to be implemented on legacy
	hardware.</para>

      <para>The other standard to be aware of is 802.11e.  It defines
	protocols for deploying multimedia applications, such as
	streaming video and voice over IP (<acronym>VoIP</acronym>),
	in an 802.11 network.  Like 802.11i, 802.11e also has a
	precursor specification termed <acronym>WME</acronym> (later
	renamed <acronym>WMM</acronym>) that has been defined by an
	industry group as a subset of 802.11e that can be deployed now
	to enable multimedia applications while waiting for the final
	ratification of 802.11e.  The most important thing to know
	about 802.11e and
	<acronym>WME</acronym>/<acronym>WMM</acronym> is that it
	enables prioritized traffic over a wireless network through
	Quality of Service (<acronym>QoS</acronym>) protocols and
	enhanced media access protocols.  Proper implementation of
	these protocols enables high speed bursting of data and
	prioritized traffic flow.</para>

      <para>&os; supports networks that operate using 802.11a,
	802.11b, and 802.11g.  The <acronym>WPA</acronym> and 802.11i
	security protocols are likewise supported (in conjunction with
	any of 11a, 11b, and 11g) and <acronym>QoS</acronym> and
	traffic prioritization required by the
	<acronym>WME</acronym>/<acronym>WMM</acronym> protocols are
	supported for a limited set of wireless devices.</para>
    </sect2>

    <sect2 xml:id="network-wireless-basic">
      <title>Basic Setup</title>

      <sect3>
	<title>Kernel Configuration</title>

	<para>To use wireless networking, a wireless networking card
	  is needed and the kernel needs to be configured with the
	  appropriate wireless networking support.  The kernel is
	  separated into multiple modules so that only the required
	  support needs to be configured.</para>

	<para>The most
	  commonly used wireless devices are those that use parts made
	  by Atheros.  These devices are supported by &man.ath.4;
	  and require the following line to be added to
	  <filename>/boot/loader.conf</filename>:</para>

	<programlisting>if_ath_load="YES"</programlisting>

	<para>The Atheros driver is split up into three separate
	  pieces: the driver (&man.ath.4;), the hardware support
	  layer that handles chip-specific functions
	  (&man.ath.hal.4;), and an algorithm for selecting the
	  rate for transmitting frames.  When this support is loaded
	  as kernel modules, any dependencies are automatically
	  handled.  To load support for a different type of wireless
	  device, specify the module for that device.  This example
	  is for devices based on the Intersil Prism parts
	  (&man.wi.4;) driver:</para>

	<programlisting>if_wi_load="YES"</programlisting>

	<note>
	  <para>The examples in this section use an &man.ath.4;
	    device and the device name in the examples must be
	    changed according to the configuration.  A list of
	    available wireless drivers and supported adapters can be
	    found in the &os; Hardware Notes, available on
	    the <link xlink:href="http://www.FreeBSD.org/releases/index.html">Release
	      Information</link> page of the &os; website.  If a
	    native &os; driver for the wireless device does not
	    exist, it may be possible to use the &windows; driver
	    with the help of the <link linkend="config-network-ndis">NDIS</link> driver
	    wrapper.</para>
	</note>

	<para>In addition, the modules that implement cryptographic
	  support for the security protocols to use must be loaded.
	  These are intended to be dynamically loaded on demand by
	  the &man.wlan.4; module, but for now they must be manually
	  configured.  The following modules are available:
	  &man.wlan.wep.4;, &man.wlan.ccmp.4;, and &man.wlan.tkip.4;.
	  The &man.wlan.ccmp.4; and &man.wlan.tkip.4; drivers are
	  only needed when using the <acronym>WPA</acronym> or
	  802.11i security protocols.  If the network does not use
	  encryption, &man.wlan.wep.4; support is not needed.  To
	  load these modules at boot time, add the following lines to
	  <filename>/boot/loader.conf</filename>:</para>

	<programlisting>wlan_wep_load="YES"
wlan_ccmp_load="YES"
wlan_tkip_load="YES"</programlisting>

	<para>Once this information has been added to
	  <filename>/boot/loader.conf</filename>, reboot the &os;
	  box.  Alternately, load the modules by hand using
	  &man.kldload.8;.</para>

	<note>
	  <para>For users who do not want to use modules, it is
	    possible to compile these drivers into the kernel by
	    adding the following lines to a custom kernel
	    configuration file:</para>

	  <programlisting>device wlan              # 802.11 support
device wlan_wep          # 802.11 WEP support
device wlan_ccmp         # 802.11 CCMP support
device wlan_tkip         # 802.11 TKIP support
device wlan_amrr         # AMRR transmit rate control algorithm
device ath               # Atheros pci/cardbus NIC's
device ath_hal           # pci/cardbus chip support
options AH_SUPPORT_AR5416 # enable AR5416 tx/rx descriptors
device ath_rate_sample   # SampleRate tx rate control for ath</programlisting>

	  <para>With this information in the kernel configuration
	    file, recompile the kernel and reboot the &os;
	    machine.</para>
	</note>

	<para>Information about the wireless device should appear
	  in the boot messages, like this:</para>

	<screen>ath0: &lt;Atheros 5212&gt; mem 0x88000000-0x8800ffff irq 11 at device 0.0 on cardbus1
ath0: [ITHREAD]
ath0: AR2413 mac 7.9 RF2413 phy 4.5</screen>
      </sect3>
    </sect2>

    <sect2>
      <title>Infrastructure Mode</title>

      <para>Infrastructure (<acronym>BSS</acronym>) mode is the
	mode that is typically used.  In this mode, a number of
	wireless access points are connected to a wired network.
	Each wireless network has its own name, called the
	<acronym>SSID</acronym>.  Wireless clients connect to the
	wireless access points.</para>

      <sect3>
	<title>&os; Clients</title>

	<sect4>
	  <title>How to Find Access Points</title>

	  <para>To scan for available networks, use &man.ifconfig.8;.
	    This request may take a few moments to complete as it
	    requires the system to switch to each available wireless
	    frequency and probe for available access points.  Only
	    the superuser can initiate a scan:</para>

	  <screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0</userinput>
&prompt.root; <userinput>ifconfig wlan0 up scan</userinput>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
dlinkap         00:13:46:49:41:76   11   54M -90:96   100 EPS  WPA WME
freebsdap       00:11:95:c3:0d:ac    1   54M -83:96   100 EPS  WPA</screen>

	  <note>
	    <para>The interface must be <option>up</option> before
	      it can scan.  Subsequent scan requests do not require
	      the interface to be marked as up again.</para>
	  </note>

	  <para>The output of a scan request lists each
	    <acronym>BSS</acronym>/<acronym>IBSS</acronym> network
	    found.  Besides listing the name of the network, the
	    <literal>SSID</literal>, the output also shows the
	    <literal>BSSID</literal>, which is the
	    <acronym>MAC</acronym> address of the access point.  The
	    <literal>CAPS</literal> field identifies the type of
	    each network and the capabilities of the stations
	    operating there:</para>

	  <table frame="none" pgwide="0">
	    <title>Station Capability Codes</title>

	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry>Capability Code</entry>
		  <entry>Meaning</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry><literal>E</literal></entry>
		  <entry>Extended Service Set
		    (<acronym>ESS</acronym>).  Indicates that
		    the station is part of an infrastructure network
		    rather than an <acronym>IBSS</acronym>/ad-hoc
		    network.</entry>
		</row>

		<row>
		  <entry><literal>I</literal></entry>
		  <entry><acronym>IBSS</acronym>/ad-hoc network.
		    Indicates that the station is part of an ad-hoc
		    network rather than an <acronym>ESS</acronym>
		    network.</entry>
		</row>

		<row>
		  <entry><literal>P</literal></entry>
		  <entry>Privacy.  Encryption is required for all
		    data frames exchanged within the
		    <acronym>BSS</acronym> using cryptographic means
		    such as <acronym>WEP</acronym>,
		    <acronym>TKIP</acronym> or
		    <acronym>AES</acronym>-<acronym>CCMP</acronym>.</entry>
		</row>

		<row>
		  <entry><literal>S</literal></entry>
		  <entry>Short Preamble.  Indicates that the network
		    is using short preambles, defined in 802.11b High
		    Rate/DSSS PHY, and utilizes a 56 bit sync field
		    rather than the 128 bit field used in long
		    preamble mode.</entry>
		</row>

		<row>
		  <entry><literal>s</literal></entry>
		  <entry>Short slot time.  Indicates that the 802.11g
		    network is using a short slot time because there
		    are no legacy (802.11b) stations present.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>

	  <para>One can also display the current list of known
	    networks with:</para>

	  <screen>&prompt.root; <userinput>ifconfig wlan0 list scan</userinput></screen>

	  <para>This information may be updated automatically by the
	    adapter or manually with a <option>scan</option> request.
	    Old data is automatically removed from the cache, so over
	    time this list may shrink unless more scans are
	    done.</para>
	</sect4>

	<sect4>
	  <title>Basic Settings</title>

	  <para>This section provides a simple example of how to make
	    the wireless network adapter work in &os; without
	    encryption.  Once familiar with these concepts, it is
	    strongly recommend to use <link linkend="network-wireless-wpa">WPA</link> to set up
	    the wireless network.</para>

	  <para>There are three basic steps to configure a wireless
	    network: select an access point, authenticate the
	    station, and configure an <acronym>IP</acronym> address.
	    The following sections discuss each step.</para>

	  <sect5>
	    <title>Selecting an Access Point</title>

	    <para>Most of the time, it is sufficient to let the system
	      choose an access point using the builtin heuristics.
	      This is the default behaviour when an interface is
	      marked as up or it is listed in
	      <filename>/etc/rc.conf</filename>:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="DHCP"</programlisting>

	    <para>If there are multiple access points, a specific
	      one can be selected by its
	      <acronym>SSID</acronym>:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="ssid <replaceable>your_ssid_here</replaceable> DHCP"</programlisting>

	    <para>In an environment where there are multiple access
	      points with the same <acronym>SSID</acronym>, which
	      is often done to simplify roaming, it may be necessary
	      to associate to one specific device.  In this case, the
	      <acronym>BSSID</acronym> of the access point can be
	      specified, with or without the
	      <acronym>SSID</acronym>:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="ssid <replaceable>your_ssid_here</replaceable> bssid <replaceable>xx:xx:xx:xx:xx:xx</replaceable> DHCP"</programlisting>

	    <para>There are other ways to constrain the choice of an
	      access point, such as limiting the set of frequencies
	      the system will scan on.  This may be useful for a
	      multi-band wireless card as scanning all the possible
	      channels can be time-consuming.  To limit operation to a
	      specific band, use the <option>mode</option>
	      parameter:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="mode <replaceable>11g</replaceable> ssid <replaceable>your_ssid_here</replaceable> DHCP"</programlisting>

	    <para>This example will force the card to operate in
	      802.11g, which is defined only for 2.4GHz frequencies
	      so any 5GHz channels will not be considered.  This can
	      also be achieved with the
	      <option>channel</option> parameter, which locks
	      operation to one specific frequency, and the
	      <option>chanlist</option> parameter, to specify a list
	      of channels for scanning.  More information about these
	      parameters can be found in &man.ifconfig.8;.</para>
	  </sect5>

	  <sect5>
	    <title>Authentication</title>

	    <para>Once an access point is selected, the station
	      needs to authenticate before it can pass data.
	      Authentication can happen in several ways.  The most
	      common scheme, open authentication, allows any station
	      to join the network and communicate.  This is the
	      authentication to use for test purposes the first time
	      a wireless network is setup.  Other schemes require
	      cryptographic handshakes to be completed before data
	      traffic can flow, either using pre-shared keys or
	      secrets, or more complex schemes that involve backend
	      services such as <acronym>RADIUS</acronym>.  Open
	      authentication is the default setting.  The next most
	      common setup is <acronym>WPA-PSK</acronym>, also
	      known as <acronym>WPA</acronym> Personal, which is
	      described in <xref linkend="network-wireless-wpa-wpa-psk"/>.</para>

	    <note>
	      <para>If using an &apple; &airport; Extreme base
		station for an access point, shared-key authentication
		together with a <acronym>WEP</acronym> key needs to
		be configured.  This can be configured in
		<filename>/etc/rc.conf</filename> or by using
		&man.wpa.supplicant.8;.  For a single &airport; base
		station, access can be configured with:</para>

	      <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="authmode shared wepmode on weptxkey <replaceable>1</replaceable> wepkey <replaceable>01234567</replaceable> DHCP"</programlisting>

	      <para>In general, shared key authentication should be
		avoided because it uses the <acronym>WEP</acronym> key
		material in a highly-constrained manner, making it
		even easier to crack the key.  If
		<acronym>WEP</acronym> must be used for compatibility
		with legacy devices, it is better to use
		<acronym>WEP</acronym> with <literal>open</literal>
		authentication.  More information regarding
		<acronym>WEP</acronym> can be found in <xref linkend="network-wireless-wep"/>.</para>
	    </note>
	  </sect5>

	  <sect5>
	    <title>Getting an <acronym>IP</acronym> Address with
	      <acronym>DHCP</acronym></title>

	    <para>Once an access point is selected and the
	      authentication parameters are set, an
	      <acronym>IP</acronym> address must be obtained in
	      order to communicate.  Most of the time, the
	      <acronym>IP</acronym> address is obtained via
	      <acronym>DHCP</acronym>.  To achieve that, edit
	      <filename>/etc/rc.conf</filename> and add
	      <literal>DHCP</literal> to the configuration for the
	      device:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="DHCP"</programlisting>

	    <para>The
	      wireless interface is now ready to bring up:</para>

	    <screen>&prompt.root; <userinput>service netif start</userinput></screen>

	    <para>Once the interface is running, use &man.ifconfig.8;
	      to see the status of the interface
	      <filename>ath0</filename>:</para>

	    <screen>&prompt.root; <userinput>ifconfig wlan0</userinput>
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        ether 00:11:95:d5:43:62
        inet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255
        media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
        status: associated
        ssid dlinkap channel 11 (2462 Mhz 11g) bssid 00:13:46:49:41:76
        country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
        scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
        roam:rate 5 protmode CTS wme burst</screen>

	    <para>The <literal>status: associated</literal> line means
	      that it is connected to the wireless network.  The
	      <literal>bssid 00:13:46:49:41:76</literal> is the
	      <acronym>MAC</acronym> address of the access point and
	      <literal>authmode OPEN</literal> indicates that the
	      communication is not encrypted.</para>
	  </sect5>

	  <sect5>
	    <title>Static <acronym>IP</acronym> Address</title>

	    <para>In an <acronym>IP</acronym> address cannot be
	      obtained from a <acronym>DHCP</acronym> server, set a
	      fixed <acronym>IP</acronym> address.  Replace the
	      <literal>DHCP</literal> keyword shown above with the
	      address information.  Be sure to retain any other
	      parameters for selecting the access point:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="inet <replaceable>192.168.1.100</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>your_ssid_here</replaceable>"</programlisting>
	  </sect5>
	</sect4>

	<sect4 xml:id="network-wireless-wpa">
	  <title><acronym>WPA</acronym></title>

	  <para>Wi-Fi Protected Access (<acronym>WPA</acronym>) is a
	    security protocol used together with 802.11 networks to
	    address the lack of proper authentication and the weakness
	    of <acronym>WEP</acronym>.  WPA leverages the 802.1X
	    authentication protocol and uses one of several ciphers
	    instead of <acronym>WEP</acronym> for data integrity.
	    The only cipher required by <acronym>WPA</acronym> is the
	    Temporary Key Integrity Protocol
	    (<acronym>TKIP</acronym>).  <acronym>TKIP</acronym> is a
	    cipher that extends the basic RC4 cipher used by
	    <acronym>WEP</acronym> by adding integrity checking,
	    tamper detection, and measures for responding to detected
	    intrusions.  <acronym>TKIP</acronym> is designed to work
	    on legacy hardware with only software modification.  It
	    represents a compromise that improves security but is
	    still not entirely immune to attack.
	    <acronym>WPA</acronym> also specifies the
	    <acronym>AES-CCMP</acronym> cipher as an alternative to
	    <acronym>TKIP</acronym>, and that is preferred when
	    possible.  For this specification, the term
	    <acronym>WPA2</acronym> or <acronym>RSN</acronym> is
	    commonly used.</para>

	  <para><acronym>WPA</acronym> defines authentication and
	    encryption protocols.  Authentication is most commonly
	    done using one of two techniques: by 802.1X and a backend
	    authentication service such as <acronym>RADIUS</acronym>,
	    or by a minimal handshake between the station and the
	    access point using a pre-shared secret.  The former is
	    commonly termed <acronym>WPA</acronym> Enterprise and the
	    latter is known as <acronym>WPA</acronym> Personal.  Since
	    most people will not set up a <acronym>RADIUS</acronym>
	    backend server for their wireless network,
	    <acronym>WPA-PSK</acronym> is by far the most commonly
	    encountered configuration for
	    <acronym>WPA</acronym>.</para>

	  <para>The control of the wireless connection and the key
	    negotiation or authentication with a server is done using
	    &man.wpa.supplicant.8;.  This program requires a
	    configuration file,
	    <filename>/etc/wpa_supplicant.conf</filename>, to run.
	    More information regarding this file can be found in
	    &man.wpa.supplicant.conf.5;.</para>

	  <sect5 xml:id="network-wireless-wpa-wpa-psk">
	    <title><acronym>WPA-PSK</acronym></title>

	    <para><acronym>WPA-PSK</acronym>, also known as
	      <acronym>WPA</acronym> Personal, is based on a
	      pre-shared key (<acronym>PSK</acronym>) which is
	      generated from a given password and used as the master
	      key in the wireless network.  This means every wireless
	      user will share the same key.
	      <acronym>WPA-PSK</acronym> is intended for small
	      networks where the use of an authentication server is
	      not possible or desired.</para>

	    <warning>
	      <para>Always use strong passwords that are sufficiently
		long and made from a rich alphabet so that they will
		not be easily guessed or attacked.</para>
	    </warning>

	    <para>The first step is the configuration of
	      <filename>/etc/wpa_supplicant.conf</filename> with
	      the <acronym>SSID</acronym> and the pre-shared key of
	      the network:</para>

	    <programlisting>network={
  ssid="freebsdap"
  psk="freebsdmall"
}</programlisting>

	    <para>Then, in <filename>/etc/rc.conf</filename>,
	      indicate that the wireless device configuration will be
	      done with <acronym>WPA</acronym> and the
	      <acronym>IP</acronym> address will be obtained with
	      <acronym>DHCP</acronym>:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"</programlisting>

	    <para>Then, bring up the interface:</para>

	    <screen>&prompt.root; <userinput>service netif start</userinput>
Starting wpa_supplicant.
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 5
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 6
DHCPOFFER from 192.168.0.1
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <para>Or, try to configure the interface manually using
	      the information in
	      <filename>/etc/wpa_supplicant.conf</filename>:</para>

	    <screen>&prompt.root; <userinput>wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</userinput>
Trying to associate with 00:11:95:c3:0d:ac (SSID='freebsdap' freq=2412 MHz)
Associated with 00:11:95:c3:0d:ac
WPA: Key negotiation completed with 00:11:95:c3:0d:ac [PTK=CCMP GTK=CCMP]
CTRL-EVENT-CONNECTED - Connection to 00:11:95:c3:0d:ac completed (auth) [id=0 id_str=]</screen>

	    <para>The next operation is to launch &man.dhclient.8;
	      to get the <acronym>IP</acronym> address from the
	      <acronym>DHCP</acronym> server:</para>

	    <screen>&prompt.root; <userinput>dhclient wlan0</userinput>
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 -- renewal in 300 seconds.
&prompt.root; <userinput>ifconfig wlan0</userinput>
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <note>
	      <para>If <filename>/etc/rc.conf</filename> has an
		<literal>ifconfig_wlan0="DHCP"</literal> entry,
		&man.dhclient.8; will be launched automatically after
		&man.wpa.supplicant.8; associates with the access
		point.</para>
	    </note>

	    <para>If <acronym>DHCP</acronym> is not possible or
	      desired, set a static <acronym>IP</acronym> address
	      after &man.wpa.supplicant.8; has authenticated the
	      station:</para>

	    <screen>&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.100 netmask 255.255.255.0</userinput>
&prompt.root; <userinput>ifconfig wlan0</userinput>
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.100 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <para>When <acronym>DHCP</acronym> is not used, the
	      default gateway and the nameserver also have to be
	      manually set:</para>

	    <screen>&prompt.root; <userinput>route add default your_default_router</userinput>
&prompt.root; <userinput>echo "nameserver your_DNS_server" &gt;&gt; /etc/resolv.conf</userinput></screen>
	  </sect5>

	  <sect5 xml:id="network-wireless-wpa-eap-tls">
	    <title><acronym>WPA</acronym> with
	      <acronym>EAP-TLS</acronym></title>

	    <para>The second way to use <acronym>WPA</acronym> is with
	      an 802.1X backend authentication server.  In this case,
	      <acronym>WPA</acronym> is called
	      <acronym>WPA</acronym> Enterprise to differentiate it
	      from the less secure <acronym>WPA</acronym> Personal.
	      Authentication in <acronym>WPA</acronym> Enterprise is
	      based on the Extensible Authentication Protocol
	      (<acronym>EAP</acronym>).</para>

	    <para><acronym>EAP</acronym> does not come with an
	      encryption method.  Instead, <acronym>EAP</acronym> is
	      embedded inside an encrypted tunnel.  There are many
	      <acronym>EAP</acronym> authentication methods, but
	      <acronym>EAP-TLS</acronym>, <acronym>EAP-TTLS</acronym>,
	      and <acronym>EAP-PEAP</acronym> are the most
	      common.</para>

	    <para>EAP with Transport Layer Security
	      (<acronym>EAP-TLS</acronym>) is a well-supported
	      wireless authentication protocol since it was the
	      first <acronym>EAP</acronym> method to be certified
	      by the <link xlink:href="http://www.wi-fi.org/">Wi-Fi alliance</link>.
	      <acronym>EAP-TLS</acronym> requires three certificates
	      to run: the certificate of the Certificate Authority
	      (<acronym>CA</acronym>) installed on all machines, the
	      server certificate for the authentication server, and
	      one client certificate for each wireless client.  In
	      this <acronym>EAP</acronym> method, both the
	      authentication server and wireless client authenticate
	      each other by presenting their respective certificates,
	      and then verify that these certificates were signed by
	      the organization's <acronym>CA</acronym>.</para>

	    <para>As previously, the configuration is done via
	      <filename>/etc/wpa_supplicant.conf</filename>:</para>

	    <programlisting>network={
  ssid="freebsdap" <co xml:id="co-tls-ssid"/>
  proto=RSN  <co xml:id="co-tls-proto"/>
  key_mgmt=WPA-EAP <co xml:id="co-tls-kmgmt"/>
  eap=TLS <co xml:id="co-tls-eap"/>
  identity="loader" <co xml:id="co-tls-id"/>
  ca_cert="/etc/certs/cacert.pem" <co xml:id="co-tls-cacert"/>
  client_cert="/etc/certs/clientcert.pem" <co xml:id="co-tls-clientcert"/>
  private_key="/etc/certs/clientkey.pem" <co xml:id="co-tls-pkey"/>
  private_key_passwd="freebsdmallclient" <co xml:id="co-tls-pwd"/>
}</programlisting>

	    <calloutlist>
	      <callout arearefs="co-tls-ssid">
		<para>This field indicates the network name
		  (<acronym>SSID</acronym>).</para>
	      </callout>

	      <callout arearefs="co-tls-proto">
		<para>This example uses the <acronym>RSN</acronym>
		  &ieee; 802.11i protocol, also known as
		  <acronym>WPA2</acronym>.</para>
	      </callout>

	      <callout arearefs="co-tls-kmgmt">
		<para>The <literal>key_mgmt</literal> line refers to
		  the key management protocol to use.  In this
		  example, it is <acronym>WPA</acronym> using
		  <acronym>EAP</acronym> authentication.</para>
	      </callout>

	      <callout arearefs="co-tls-eap">
		<para>This field indicates the <acronym>EAP</acronym>
		  method for the connection.</para>
	      </callout>

	      <callout arearefs="co-tls-id">
		<para>The <literal>identity</literal> field contains
		  the identity string for
		  <acronym>EAP</acronym>.</para>
	      </callout>

	      <callout arearefs="co-tls-cacert">
		<para>The <literal>ca_cert</literal> field indicates
		  the pathname of the <acronym>CA</acronym>
		  certificate file.  This file is needed to verify
		  the server certificate.</para>
	      </callout>

	      <callout arearefs="co-tls-clientcert">
		<para>The <literal>client_cert</literal> line gives
		  the pathname to the client certificate file.  This
		  certificate is unique to each wireless client of the
		  network.</para>
	      </callout>

	      <callout arearefs="co-tls-pkey">
		<para>The <literal>private_key</literal> field is the
		  pathname to the client certificate private key
		  file.</para>
	      </callout>

	      <callout arearefs="co-tls-pwd">
		<para>The <literal>private_key_passwd</literal> field
		  contains the passphrase for the private key.</para>
	      </callout>
	    </calloutlist>

	    <para>Then, add the following lines to
	      <filename>/etc/rc.conf</filename>:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"</programlisting>

	    <para>The next step is to bring up the interface:</para>

	    <screen>&prompt.root; <userinput>service netif start</userinput>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <para>It is also possible to bring up the interface
	      manually using &man.wpa.supplicant.8; and
	      &man.ifconfig.8;.</para>
	  </sect5>

	  <sect5 xml:id="network-wireless-wpa-eap-ttls">
	    <title><acronym>WPA</acronym> with
	      <acronym>EAP-TTLS</acronym></title>

	    <para>With <acronym>EAP-TTLS</acronym>, both the
	      authentication server and the client need a certificate.
	      With <acronym>EAP-TTLS</acronym>, a client certificate
	      is optional.  This method is similar to a web server
	      which creates a secure <acronym>SSL</acronym> tunnel
	      even if visitors do not have client-side certificates.
	      <acronym>EAP-TTLS</acronym> uses an encrypted
	      <acronym>TLS</acronym> tunnel for safe transport of
	      the authentication data.</para>

	    <para>The required configuration can be added to
	      <filename>/etc/wpa_supplicant.conf</filename>:</para>

	    <programlisting>network={
  ssid="freebsdap"
  proto=RSN
  key_mgmt=WPA-EAP
  eap=TTLS <co xml:id="co-ttls-eap"/>
  identity="test" <co xml:id="co-ttls-id"/>
  password="test" <co xml:id="co-ttls-passwd"/>
  ca_cert="/etc/certs/cacert.pem" <co xml:id="co-ttls-cacert"/>
  phase2="auth=MD5" <co xml:id="co-ttls-pha2"/>
}</programlisting>

	    <calloutlist>
	      <callout arearefs="co-ttls-eap">
		<para>This field specifies the <acronym>EAP</acronym>
		  method for the connection.</para>
	      </callout>

	      <callout arearefs="co-ttls-id">
		<para>The <literal>identity</literal> field contains
		  the identity string for <acronym>EAP</acronym>
		  authentication inside the encrypted
		  <acronym>TLS</acronym> tunnel.</para>
	      </callout>

	      <callout arearefs="co-ttls-passwd">
		<para>The <literal>password</literal> field contains
		  the passphrase for the <acronym>EAP</acronym>
		  authentication.</para>
	      </callout>

	      <callout arearefs="co-ttls-cacert">
		<para>The <literal>ca_cert</literal> field indicates
		  the pathname of the <acronym>CA</acronym>
		  certificate file.  This file is needed to verify
		  the server certificate.</para>
	      </callout>

	      <callout arearefs="co-ttls-pha2">
		<para>This field specifies the authentication
		  method used in the encrypted <acronym>TLS</acronym>
		  tunnel.  In this example,
		  <acronym>EAP</acronym> with MD5-Challenge is used.
		  The <quote>inner authentication</quote> phase is
		  often called <quote>phase2</quote>.</para>
	      </callout>
	    </calloutlist>

	    <para>Next, add the following lines to
	      <filename>/etc/rc.conf</filename>:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"</programlisting>

	    <para>The next step is to bring up the interface:</para>

	    <screen>&prompt.root; <userinput>service netif start</userinput>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>
	  </sect5>

	  <sect5 xml:id="network-wireless-wpa-eap-peap">
	    <title><acronym>WPA</acronym> with
	      <acronym>EAP-PEAP</acronym></title>

	    <note>
	      <para><acronym>PEAPv0/EAP-MSCHAPv2</acronym> is the most
		common <acronym>PEAP</acronym> method.  In this
		chapter, the term <acronym>PEAP</acronym> is used to
		refer to that method.</para>
	    </note>

	    <para>Protected EAP (<acronym>PEAP</acronym>) is designed
	      as an alternative to <acronym>EAP-TTLS</acronym> and
	      is the most used <acronym>EAP</acronym> standard after
	      <acronym>EAP-TLS</acronym>.  In a network with mixed
	      operating systems, <acronym>PEAP</acronym> should be
	      the most supported standard after
	      <acronym>EAP-TLS</acronym>.</para>

	    <para><acronym>PEAP</acronym> is similar to
	      <acronym>EAP-TTLS</acronym> as it uses a server-side
	      certificate to authenticate clients by creating an
	      encrypted <acronym>TLS</acronym> tunnel between the
	      client and the authentication server, which protects
	      the ensuing exchange of authentication information.
	      <acronym>PEAP</acronym> authentication differs from
	      <acronym>EAP-TTLS</acronym> as it broadcasts the
	      username in the clear and only the password is sent
	      in the encrypted <acronym>TLS</acronym> tunnel.
	      <acronym>EAP-TTLS</acronym> will use the
	      <acronym>TLS</acronym> tunnel for both the username
	      and password.</para>

	    <para>Add the following lines to
	      <filename>/etc/wpa_supplicant.conf</filename> to
	      configure the <acronym>EAP-PEAP</acronym> related
	      settings:</para>

	    <programlisting>network={
  ssid="freebsdap"
  proto=RSN
  key_mgmt=WPA-EAP
  eap=PEAP <co xml:id="co-peap-eap"/>
  identity="test" <co xml:id="co-peap-id"/>
  password="test" <co xml:id="co-peap-passwd"/>
  ca_cert="/etc/certs/cacert.pem" <co xml:id="co-peap-cacert"/>
  phase1="peaplabel=0" <co xml:id="co-peap-pha1"/>
  phase2="auth=MSCHAPV2" <co xml:id="co-peap-pha2"/>
}</programlisting>

	    <calloutlist>
	      <callout arearefs="co-peap-eap">
		<para>This field specifies the <acronym>EAP</acronym>
		  method for the connection.</para>
	      </callout>

	      <callout arearefs="co-peap-id">
		<para>The <literal>identity</literal> field contains
		  the identity string for <acronym>EAP</acronym>
		  authentication inside the encrypted
		  <acronym>TLS</acronym> tunnel.</para>
	      </callout>

	      <callout arearefs="co-peap-passwd">
		<para>The <literal>password</literal> field contains
		  the passphrase for the <acronym>EAP</acronym>
		  authentication.</para>
	      </callout>

	      <callout arearefs="co-peap-cacert">
		<para>The <literal>ca_cert</literal> field indicates
		  the pathname of the <acronym>CA</acronym>
		  certificate file.  This file is needed to verify
		  the server certificate.</para>
	      </callout>

	      <callout arearefs="co-peap-pha1">
		<para>This field contains the parameters for the
		  first phase of authentication, the
		  <acronym>TLS</acronym> tunnel.  According to the
		  authentication server used, specify a specific
		  label for authentication.  Most of the time, the
		  label will be <quote>client <acronym>EAP</acronym>
		    encryption</quote> which is set by using
		  <literal>peaplabel=0</literal>.  More information
		  can be found in  &man.wpa.supplicant.conf.5;.</para>
	      </callout>

	      <callout arearefs="co-peap-pha2">
		<para>This field specifies the authentication
		  protocol used in the encrypted
		  <acronym>TLS</acronym> tunnel.  In the
		  case of <acronym>PEAP</acronym>, it is
		  <literal>auth=MSCHAPV2</literal>.</para>
	      </callout>
	    </calloutlist>

	    <para>Add the following to
	      <filename>/etc/rc.conf</filename>:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"</programlisting>

	    <para>Then, bring up the interface:</para>

	    <screen>&prompt.root; <userinput>service netif start</userinput>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>
	  </sect5>
	</sect4>

	<sect4 xml:id="network-wireless-wep">
	  <title><acronym>WEP</acronym></title>

	  <para>Wired Equivalent Privacy (<acronym>WEP</acronym>) is
	    part of the original 802.11 standard.  There is no
	    authentication mechanism, only a weak form of access
	    control which is easily cracked.</para>

	  <para><acronym>WEP</acronym> can be set up using
	    &man.ifconfig.8;:</para>

	  <screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0</userinput>
&prompt.root; <userinput>ifconfig wlan0 inet 192.168.1.100 netmask 255.255.255.0 \
	    ssid my_net wepmode on weptxkey 3 wepkey 3:0x3456789012</userinput></screen>

	  <itemizedlist>
	    <listitem>

	      <para>The <literal>weptxkey</literal> specifies which
		<acronym>WEP</acronym> key will be used in the
		transmission.  This example uses the third key.
		This must match the setting on the access point.
		When unsure which key is used by the access point,
		try <literal>1</literal> (the first key) for this
		value.</para>
	    </listitem>

	    <listitem>
	      <para>The <literal>wepkey</literal> selects one of the
		<acronym>WEP</acronym> keys.  It should be in the
		format <replaceable>index:key</replaceable>.  Key
		<literal>1</literal> is used by default; the index
		only needs to be set when using a key other than the
		first key.</para>

	      <note>
		<para>Replace the <literal>0x3456789012</literal>
		  with the key configured for use on the access
		  point.</para>
	      </note>
	    </listitem>
	  </itemizedlist>

	  <para>Refer to &man.ifconfig.8; for further
	    information.</para>

	  <para>The &man.wpa.supplicant.8; facility can be used to
	    configure a wireless interface with
	    <acronym>WEP</acronym>.  The example above can be set up
	    by adding the following lines to
	    <filename>/etc/wpa_supplicant.conf</filename>:</para>

	  <programlisting>network={
  ssid="my_net"
  key_mgmt=NONE
  wep_key3=3456789012
  wep_tx_keyidx=3
}</programlisting>

	  <para>Then:</para>

	  <screen>&prompt.root; <userinput>wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</userinput>
Trying to associate with 00:13:46:49:41:76 (SSID='dlinkap' freq=2437 MHz)
Associated with 00:13:46:49:41:76</screen>
	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Ad-hoc Mode</title>

      <para><acronym>IBSS</acronym> mode, also called ad-hoc mode, is
	designed for point to point connections.  For example, to
	establish an ad-hoc network between the machines
	<systemitem>A</systemitem> and <systemitem>B</systemitem>, choose two
	<acronym>IP</acronym> addresses and a
	<acronym>SSID</acronym>.</para>

      <para>On <systemitem>A</systemitem>:</para>

      <screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0 wlanmode adhoc</userinput>
&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap</userinput>
&prompt.root; <userinput>ifconfig wlan0</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
	  status: running
	  ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst</screen>

      <para>The <literal>adhoc</literal> parameter indicates that the
	interface is running in <acronym>IBSS</acronym> mode.</para>

      <para><systemitem>B</systemitem> should now be able to detect
	<systemitem>A</systemitem>:</para>

      <screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0 wlanmode adhoc</userinput>
&prompt.root; <userinput>ifconfig wlan0 up scan</userinput>
  SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
  freebsdap       02:11:95:c3:0d:ac    2   54M -64:-96  100 IS   WME</screen>

      <para>The <literal>I</literal> in the output confirms that
	<systemitem>A</systemitem> is in ad-hoc mode.  Now, configure
	<systemitem>B</systemitem> with a different <acronym>IP</acronym>
	address:</para>

      <screen>&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</userinput>
&prompt.root; <userinput>ifconfig wlan0</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
	  status: running
	  ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst</screen>

      <para>Both <systemitem>A</systemitem> and <systemitem>B</systemitem> are now
	ready to exchange information.</para>
    </sect2>

    <sect2 xml:id="network-wireless-ap">
      <title>&os; Host Access Points</title>

      <para>&os; can act as an Access Point (<acronym>AP</acronym>)
	which eliminates the need to buy a hardware
	<acronym>AP</acronym> or run an ad-hoc network.  This can
	be particularly useful when a &os; machine is acting as a
	gateway to another network such as the Internet.</para>

      <sect3 xml:id="network-wireless-ap-basic">
	<title>Basic Settings</title>

	<para>Before configuring a &os; machine as an
	  <acronym>AP</acronym>, the kernel must be configured with
	  the appropriate networking support for the wireless card
	  as well as the security protocols being used.  For more
	  details, see <xref linkend="network-wireless-basic"/>.</para>

	<note>
	  <para>The <acronym>NDIS</acronym> driver wrapper for
	    &windows; drivers does not currently support
	    <acronym>AP</acronym> operation.  Only native &os;
	    wireless drivers support <acronym>AP</acronym>
	    mode.</para>
	</note>

	<para>Once wireless networking support is loaded, check if
	  the wireless device supports the host-based access point
	  mode, also known as hostap mode:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0</userinput>
&prompt.root; <userinput>ifconfig wlan0 list caps</userinput>
drivercaps=6f85edc1&lt;STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG&gt;
cryptocaps=1f&lt;WEP,TKIP,AES,AES_CCM,TKIPMIC&gt;</screen>

	<para>This output displays the card's capabilities.  The
	  <literal>HOSTAP</literal> word confirms that this wireless
	  card can act as an <acronym>AP</acronym>.  Various supported
	  ciphers are also listed: <acronym>WEP</acronym>,
	  <acronym>TKIP</acronym>, and <acronym>AES</acronym>.  This
	  information indicates which security protocols can be used
	  on the <acronym>AP</acronym>.</para>

	<para>The wireless device can only be put into hostap mode
	  during the creation of the network pseudo-device, so a
	  previously created device must be destroyed first:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 destroy</userinput></screen>

	<para>then regenerated with the correct option before setting
	  the other parameters:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0 wlanmode hostap</userinput>
&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1</userinput></screen>

	<para>Use &man.ifconfig.8; again to see the status of the
	  <filename>wlan0</filename> interface:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
	  status: running
	  ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst dtimperiod 1 -dfs</screen>

	<para>The <literal>hostap</literal> parameter indicates the
	  interface is running in the host-based access point
	  mode.</para>

	<para>The interface configuration can be done automatically at
	  boot time by adding the following lines to
	  <filename>/etc/rc.conf</filename>:</para>

	<programlisting>wlans_ath0="wlan0"
create_args_wlan0="wlanmode hostap"
ifconfig_wlan0="inet <replaceable>192.168.0.1</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>freebsdap</replaceable> mode 11g channel <replaceable>1</replaceable>"</programlisting>
      </sect3>

      <sect3>
	<title>Host-based Access Point Without Authentication or
	  Encryption</title>

	<para>Although it is not recommended to run an
	  <acronym>AP</acronym> without any authentication or
	  encryption, this is a simple way to check if the
	  <acronym>AP</acronym> is working.  This configuration is
	  also important for debugging client issues.</para>

	<para>Once the <acronym>AP</acronym> is configured, initiate
	  a scan from another wireless machine to find the
	  <acronym>AP</acronym>:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0</userinput>
&prompt.root; <userinput>ifconfig wlan0 up scan</userinput>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M -66:-96  100 ES   WME</screen>

	<para>The client machine found the <acronym>AP</acronym> and
	  can be associated with it:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</userinput>
&prompt.root; <userinput>ifconfig wlan0</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
	  status: associated
	  ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
	  scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
	  roam:rate 5 protmode CTS wme burst</screen>
      </sect3>

      <sect3>
	<title><acronym>WPA</acronym> Host-based Access Point</title>

	<para>This section focuses on setting up a &os;
	  <acronym>AP</acronym> using the <acronym>WPA</acronym>
	  security protocol.  More details regarding
	  <acronym>WPA</acronym> and the configuration of
	  <acronym>WPA</acronym>-based
	  wireless clients can be found in <xref linkend="network-wireless-wpa"/>.</para>

	<para>The &man.hostapd.8; daemon is used to deal with client
	  authentication and key management on the
	  <acronym>WPA</acronym>-enabled <acronym>AP</acronym>.</para>

	<para>The following configuration operations are performed
	  on the &os; machine acting as the <acronym>AP</acronym>.
	  Once the <acronym>AP</acronym> is correctly working,
	  &man.hostapd.8; should be automatically enabled at boot
	  with the following line in
	  <filename>/etc/rc.conf</filename>:</para>

	<programlisting>hostapd_enable="YES"</programlisting>

	<para>Before trying to configure &man.hostapd.8;, first
	  configure the basic settings introduced in <xref linkend="network-wireless-ap-basic"/>.</para>

	<sect4>
	  <title><acronym>WPA-PSK</acronym></title>

	  <para><acronym>WPA-PSK</acronym> is intended for small
	    networks where the use of a backend authentication server
	    is not possible or desired.</para>

	  <para>The configuration is done in
	    <filename>/etc/hostapd.conf</filename>:</para>

	  <programlisting>interface=wlan0 <co xml:id="co-ap-wpapsk-iface"/>
debug=1 <co xml:id="co-ap-wpapsk-dbug"/>
ctrl_interface=/var/run/hostapd <co xml:id="co-ap-wpapsk-ciface"/>
ctrl_interface_group=wheel <co xml:id="co-ap-wpapsk-cifacegrp"/>
ssid=freebsdap <co xml:id="co-ap-wpapsk-ssid"/>
wpa=1 <co xml:id="co-ap-wpapsk-wpa"/>
wpa_passphrase=freebsdmall <co xml:id="co-ap-wpapsk-pass"/>
wpa_key_mgmt=WPA-PSK <co xml:id="co-ap-wpapsk-kmgmt"/>
wpa_pairwise=CCMP TKIP <co xml:id="co-ap-wpapsk-pwise"/></programlisting>

	  <calloutlist>
	    <callout arearefs="co-ap-wpapsk-iface">
	      <para>This field indicates the wireless interface used
		for the <acronym>AP</acronym>.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-dbug">
	      <para>This field sets the level of verbosity during the
		execution of &man.hostapd.8;.  A value of
		<literal>1</literal> represents the minimal
		level.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-ciface">
	      <para>The <literal>ctrl_interface</literal> field gives
		the pathname of the directory used by &man.hostapd.8;
		to store its domain socket files for the communication
		with external programs such as &man.hostapd.cli.8;.
		The default value is used in this example.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-cifacegrp">
	      <para>The <literal>ctrl_interface_group</literal> line
		sets the group which is allowed to access the control
		interface files.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-ssid">
	      <para>This field sets the network name.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-wpa">
	      <para>The <literal>wpa</literal> field enables
		<acronym>WPA</acronym> and specifies which
		<acronym>WPA</acronym> authentication protocol will
		be required.  A value of <literal>1</literal>
		configures the <acronym>AP</acronym> for
		<acronym>WPA-PSK</acronym>.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-pass">
	      <para>The <literal>wpa_passphrase</literal> field
		contains the ASCII passphrase for
		<acronym>WPA</acronym> authentication.</para>

	      <warning>
		<para>Always use strong passwords that are
		  sufficiently long and made from a rich alphabet so
		  that they will not be easily guessed or
		  attacked.</para>
	      </warning>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-kmgmt">
	      <para>The <literal>wpa_key_mgmt</literal> line refers
		to the key management protocol to use.  This example
		sets <acronym>WPA-PSK</acronym>.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-pwise">
	      <para>The <literal>wpa_pairwise</literal> field
		indicates the set of accepted encryption algorithms by
		the <acronym>AP</acronym>.  In this example, both
		<acronym>TKIP</acronym> (<acronym>WPA</acronym>) and
		<acronym>CCMP</acronym> (<acronym>WPA2</acronym>)
		ciphers are accepted.  The <acronym>CCMP</acronym>
		cipher is an alternative to <acronym>TKIP</acronym>
		and is strongly preferred when possible.
		<acronym>TKIP</acronym> should be used solely for
		stations incapable of doing
		<acronym>CCMP</acronym>.</para>
	    </callout>
	  </calloutlist>

	  <para>The next step is to start &man.hostapd.8;:</para>

	  <screen>&prompt.root; <userinput>service hostapd forcestart</userinput></screen>

	  <screen>&prompt.root; <userinput>ifconfig wlan0</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 2290
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  inet6 fe80::211:95ff:fec3:dac%ath0 prefixlen 64 scopeid 0x4
	  ether 00:11:95:c3:0d:ac
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
	  status: associated
	  ssid freebsdap channel 1 bssid 00:11:95:c3:0d:ac
	  authmode WPA2/802.11i privacy MIXED deftxkey 2 TKIP 2:128-bit txpowmax 36 protmode CTS dtimperiod 1 bintval 100</screen>

	  <para>Once the <acronym>AP</acronym> is running, the
	    clients can associate with it.  See <xref linkend="network-wireless-wpa"/> for more details.
	    It is possible to see the stations associated with the
	    <acronym>AP</acronym> using <command>ifconfig
	      wlan0 list
	      sta</command>.</para>
	</sect4>
      </sect3>

      <sect3>
	<title><acronym>WEP</acronym> Host-based Access Point</title>

	<para>It is not recommended to use <acronym>WEP</acronym> for
	  setting up an <acronym>AP</acronym> since there is no
	  authentication mechanism and the encryption is easily
	  cracked.  Some legacy wireless cards only support
	  <acronym>WEP</acronym> and these cards will only support
	  an <acronym>AP</acronym> without authentication or
	  encryption.</para>

	<para>The wireless device can now be put into hostap mode and
	  configured with the correct <acronym>SSID</acronym> and
	  <acronym>IP</acronym> address:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0 wlanmode hostap</userinput>
&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 \
	ssid freebsdap wepmode on weptxkey 3 wepkey 3:0x3456789012 mode 11g</userinput></screen>

	<itemizedlist>
	  <listitem>
	    <para>The <literal>weptxkey</literal> indicates which
	      <acronym>WEP</acronym> key will be used in the
	      transmission.  This example uses the third key as key
	      numbering starts with <literal>1</literal>.  This
	      parameter must be specified in order to encrypt the
	      data.</para>
	  </listitem>

	  <listitem>
	    <para>The <literal>wepkey</literal> sets the selected
	      <acronym>WEP</acronym> key.  It should be in the format
	      <replaceable>index:key</replaceable>.  If the index is
	      not given, key <literal>1</literal> is set.  The index
	      needs to be set when using keys other than the first
	      key.</para>
	  </listitem>
	</itemizedlist>

	<para>Use &man.ifconfig.8; to see the status of the
	  <filename>wlan0</filename> interface:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
	  status: running
	  ssid freebsdap channel 4 (2427 Mhz 11g) bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy ON deftxkey 3 wepkey 3:40-bit
	  txpower 21.5 scanvalid 60 protmode CTS wme burst dtimperiod 1 -dfs</screen>

	<para>From another wireless machine, it is now possible to
	  initiate a scan to find the <acronym>AP</acronym>:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0</userinput>
&prompt.root; <userinput>ifconfig wlan0 up scan</userinput>
SSID            BSSID              CHAN RATE  S:N   INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M 22:1   100 EPS</screen>

	<para>In this example, the client machine found the
	  <acronym>AP</acronym> and can associate with it using the
	  correct parameters.  See <xref linkend="network-wireless-wep"/> for more details.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Using Both Wired and Wireless Connections</title>

      <para>A wired connection provides better performance and
	reliability, while a wireless connection provides flexibility
	and mobility.  Laptop users typically want to roam seamlessly
	between the two types of connections.</para>

      <para>On &os;, it is possible to combine two or even more
	network interfaces together in a <quote>failover</quote>
	fashion.  This type of configuration uses the most preferred
	and available connection from a group of network interfaces,
	and the operating system switches automatically when the link
	state changes.</para>

      <para>Link aggregation and failover is covered in <xref linkend="network-aggregation"/> and an example for using
	both wired and wireless connections is provided at <xref linkend="networking-lagg-wired-and-wireless"/>.</para>
    </sect2>

    <sect2>
      <title>Troubleshooting</title>

      <para>This section describes
	a number of steps to help troubleshoot common wireless
	networking problems.</para>

      <itemizedlist>
	<listitem>
	  <para>If the access point is not listed when scanning,
	    check that the configuration has not limited the wireless
	    device to a limited set of channels.</para>
	</listitem>

	<listitem>
	  <para>If the device cannot associate with an access point,
	    verify that the configuration matches the settings on the
	    access point.  This includes the authentication scheme and
	    any security protocols.  Simplify the configuration as
	    much as possible.  If using a security protocol such as
	    <acronym>WPA</acronym> or <acronym>WEP</acronym>,
	    configure the access point for open authentication and
	    no security to see if traffic will pass.</para>
	</listitem>

	<listitem>
	  <para>Once the system can associate with the access point,
	    diagnose the security configuration using tools like
	    &man.ping.8;.</para>

	  <para>Debugging support is provided by
	    &man.wpa.supplicant.8;.  Try running this utility manually
	    with the <option>-dd</option> option and look at the
	    system logs.</para>
	</listitem>

	<listitem>
	  <para>There are many lower-level debugging tools.
	    Debugging messages can be enabled in the 802.11 protocol
	    support layer using &man.wlandebug.8;.  On a &os; system
	    prior to &os;&nbsp;9.1, this program can be found in
	    <filename>/usr/src/tools/tools/net80211</filename>.
	    For example, to enable console messages related to
	    scanning for access points and the 802.11 protocol
	    handshakes required to arrange communication:</para>

	  <screen>&prompt.root; <userinput>wlandebug -i ath0 +scan+auth+debug+assoc</userinput>
  net.wlan.0.debug: 0 =&gt; 0xc80000&lt;assoc,auth,scan&gt;</screen>

	  <para>Many useful statistics are maintained by
	    the 802.11 layer and <command>wlanstats</command>, found
	    in <filename>/usr/src/tools/tools/net80211</filename>,
	    will dump this information.  These statistics should
	    display all errors identified by the 802.11 layer.
	    However, some errors are identified in the device drivers
	    that lie below the 802.11 layer so they may not show up.
	    To diagnose device-specific problems, refer to the
	    drivers' documentation.</para>
	</listitem>
      </itemizedlist>

      <para>If the above information does not help to clarify the
	problem, submit a problem report and include output from the
	above tools.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="network-bluetooth">
    <info><title>Bluetooth</title>
      <authorgroup>
	<author><personname><firstname>Pav</firstname><surname>Lucistnik</surname></personname><contrib>Written by </contrib><affiliation>
	    <address><email>pav@FreeBSD.org</email></address>
	  </affiliation></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>Bluetooth</primary></indexterm>
    <sect2>
      <title>Introduction</title>

      <para>Bluetooth is a wireless technology for creating personal
	networks operating in the 2.4 GHz unlicensed band, with a
	range of 10 meters.  Networks are usually formed ad-hoc from
	portable devices such as cellular phones, handhelds and
	laptops.  Unlike Wi-Fi wireless technology, Bluetooth offers
	higher level service profiles, such as FTP-like file servers,
	file pushing, voice transport, serial line emulation, and
	more.</para>

      <para>The Bluetooth stack in &os; is implemented using the
	&man.netgraph.4; framework.  A broad variety of Bluetooth
	<acronym>USB</acronym> dongles is supported by &man.ng.ubt.4;.
	Broadcom BCM2033 based Bluetooth devices are supported by
	the &man.ubtbcmfw.4; and &man.ng.ubt.4; drivers.  The 3Com
	Bluetooth PC Card 3CRWB60-A is supported by the
	&man.ng.bt3c.4; driver.  Serial and UART based Bluetooth
	devices are supported by &man.sio.4;, &man.ng.h4.4; and
	&man.hcseriald.8;.  This section describes the use of a
	<acronym>USB</acronym> Bluetooth dongle.</para>
    </sect2>

    <sect2>
      <title>Plugging in the Device</title>

      <para>By default, Bluetooth device drivers are available as
	kernel modules.  Before attaching a device, load the driver
	into the kernel:</para>

      <screen>&prompt.root; <userinput>kldload ng_ubt</userinput></screen>

      <para>If the Bluetooth device is present in the system during
	system startup, load the module from
	<filename>/boot/loader.conf</filename>:</para>

      <programlisting>ng_ubt_load="YES"</programlisting>

      <para>Plug in the <acronym>USB</acronym> dongle.  Output
	similar to the following will appear on the console and in
	the system log:</para>

      <screen>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2
ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,
      wMaxPacketSize=49, nframes=6, buffer size=294</screen>

      <para>To start and stop the Bluetooth stack, use
	&man.service.8;.  It is a good idea to stop the stack before
	unplugging the device.  When starting the stack, the output
	should be similar to the following:</para>

      <screen>&prompt.root; <userinput>service bluetooth start ubt0</userinput>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO link&gt;
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</screen>
    </sect2>

    <sect2>
      <title>Host Controller Interface
	(<acronym>HCI</acronym>)</title>

      <indexterm><primary>HCI</primary></indexterm>

      <para>The Host Controller Interface (<acronym>HCI</acronym>)
	provides a command interface to the baseband controller and
	link manager as well as access to hardware status and control
	registers.  This interface provides a uniform method for
	accessing Bluetooth baseband capabilities.  The
	<acronym>HCI</acronym> layer on the host exchanges data and
	commands with the <acronym>HCI</acronym> firmware on the
	Bluetooth hardware.  The Host Controller Transport Layer
	(physical bus) driver provides both <acronym>HCI</acronym>
	layers with the ability to exchange information.</para>

      <para>A single netgraph node of type <emphasis>hci</emphasis>
	is created for a single Bluetooth device.  The
	<acronym>HCI</acronym> node is normally connected to the
	downstream Bluetooth device driver node and the upstream
	<acronym>L2CAP</acronym> node.  All <acronym>HCI</acronym>
	operations must be performed on the <acronym>HCI</acronym>
	node and not on the device driver node.  The default name
	for the <acronym>HCI</acronym> node is
	<quote>devicehci</quote>.  For more details, refer to
	&man.ng.hci.4;.</para>

      <para>One of the most common tasks is discovery of Bluetooth
	devices in <acronym>RF</acronym> proximity.  This operation is
	called <emphasis>inquiry</emphasis>.  Inquiry and other
	<acronym>HCI</acronym> related operations are done using
	&man.hccontrol.8;.  The example below shows how to find out
	which Bluetooth devices are in range.  The list of devices
	should be displayed in a few seconds.  Note that a remote
	device will only answer the inquiry if it is set to
	<emphasis>discoverable</emphasis> mode.</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci inquiry</userinput>
Inquiry result, num_responses=1
Inquiry result #0
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error [00]</screen>

      <para>The <literal>BD_ADDR</literal> is the unique address of a
	Bluetooth device, similar to the <acronym>MAC</acronym>
	address of a network card.  This address is needed for
	further communication with a device.  It is possible to
	assign a human readable name to a BD_ADDR.  Information
	regarding the known Bluetooth hosts is contained in
	<filename>/etc/bluetooth/hosts</filename>.  The following
	example shows how to obtain the human readable name that
	was assigned to the remote device:</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4</userinput>
BD_ADDR: 00:80:37:29:19:a4
Name: Pav's T39</screen>

      <para>If an inquiry is performed on a remote Bluetooth device,
	it will find the computer as
	<quote>your.host.name (ubt0)</quote>. The name assigned to the
	local device can be changed at any time.</para>

      <para>The Bluetooth system provides a point-to-point connection
	between two Bluetooth units, or a point-to-multipoint
	connection which is shared among several Bluetooth devices.
	The following example shows how to obtain the list of active
	baseband connections for the local device:</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci read_connection_list</userinput>
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</screen>

      <para>A <emphasis>connection handle</emphasis> is useful when
	termination of the baseband connection is required, though
	it is normally not required to do this by hand.  The stack
	will automatically terminate inactive baseband
	connections.</para>

      <screen>&prompt.root; <userinput>hccontrol -n ubt0hci disconnect 41</userinput>
Connection handle: 41
Reason: Connection terminated by local host [0x16]</screen>

      <para>Type <command>hccontrol help</command> for a complete
	listing of available <acronym>HCI</acronym> commands.  Most
	of the <acronym>HCI</acronym> commands do not require
	superuser privileges.</para>
    </sect2>

    <sect2>
      <title>Logical Link Control and Adaptation Protocol
	(<acronym>L2CAP</acronym>)</title>

      <indexterm><primary>L2CAP</primary></indexterm>

      <para>The Logical Link Control and Adaptation Protocol
	(<acronym>L2CAP</acronym>) provides connection-oriented and
	connectionless data services to upper layer protocols with
	protocol multiplexing capability and segmentation and
	reassembly operation.  <acronym>L2CAP</acronym> permits
	higher level protocols and applications to transmit and
	receive <acronym>L2CAP</acronym> data packets up to 64
	kilobytes in length.</para>

      <para><acronym>L2CAP</acronym> is based around the concept of
	<emphasis>channels</emphasis>.  A channel is a logical
	connection on top of a baseband connection.  Each channel is
	bound to a single protocol in a many-to-one fashion.  Multiple
	channels can be bound to the same protocol, but a channel
	cannot be bound to multiple protocols.  Each
	<acronym>L2CAP</acronym> packet received on a channel is
	directed to the appropriate higher level protocol.  Multiple
	channels can share the same baseband connection.</para>

      <para>A single netgraph node of type <emphasis>l2cap</emphasis>
	is created for a single Bluetooth device.  The
	<acronym>L2CAP</acronym> node is normally connected to the
	downstream Bluetooth <acronym>HCI</acronym> node and upstream
	Bluetooth socket nodes.  The default name for the
	<acronym>L2CAP</acronym> node is <quote>devicel2cap</quote>.
	For more details refer to &man.ng.l2cap.4;.</para>

      <para>A useful command is &man.l2ping.8;, which can be used to
	ping other devices.  Some Bluetooth implementations might not
	return all of the data sent to them, so <literal>0
	  bytes</literal> in the following example is normal.</para>

      <screen>&prompt.root; <userinput>l2ping -a 00:80:37:29:19:a4</userinput>
0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0</screen>

      <para>The &man.l2control.8; utility is used to perform various
	operations on <acronym>L2CAP</acronym> nodes.  This example
	shows how to obtain the list of logical connections (channels)
	and the list of baseband connections for the local
	device:</para>

      <screen>&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_channel_list</userinput>
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_connection_list</userinput>
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</screen>

      <para>Another diagnostic tool is &man.btsockstat.1;.  It is
	similar to &man.netstat.1;, but for Bluetooth network-related
	data structures.  The example below shows the same logical
	connection as &man.l2control.8; above.</para>

      <screen>&prompt.user; <userinput>btsockstat</userinput>
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</screen>
    </sect2>

    <sect2>
      <title><acronym>RFCOMM</acronym> Protocol</title>

      <para>The <acronym>RFCOMM</acronym> protocol provides emulation
	of serial ports over the <acronym>L2CAP</acronym> protocol.
	The protocol is based on the ETSI standard TS 07.10.
	<acronym>RFCOMM</acronym> is a simple transport protocol,
	with additional provisions for emulating the 9 circuits of
	RS-232 (EIATIA-232-E) serial ports.  <acronym>RFCOMM</acronym>
	supports up to 60 simultaneous connections
	(<acronym>RFCOMM</acronym> channels) between two Bluetooth
	devices.</para>

      <para>For the purposes of <acronym>RFCOMM</acronym>, a complete
	communication path involves two applications running on the
	communication endpoints with a communication segment between
	them.  <acronym>RFCOMM</acronym> is intended to cover
	applications that make use of the serial ports of the devices
	in which they reside.  The communication segment is a direct
	connect Bluetooth link from one device to another.</para>

      <para><acronym>RFCOMM</acronym> is only concerned with the
	connection between the devices in the direct connect case,
	or between the device and a modem in the network case.
	<acronym>RFCOMM</acronym> can support other configurations,
	such as modules that communicate via Bluetooth wireless
	technology on one side and provide a wired interface on the
	other side.</para>

      <para>In &os;, <acronym>RFCOMM</acronym> is implemented at the
	Bluetooth sockets layer.</para>
    </sect2>

    <sect2>
      <title>Pairing of Devices</title>

      <para>By default, Bluetooth communication is not authenticated,
	and any device can talk to any other device.  A Bluetooth
	device, such as a cellular phone, may choose to require
	authentication to provide a particular service.  Bluetooth
	authentication is normally done with a
	<emphasis><acronym>PIN</acronym> code</emphasis>, an ASCII
	string up to 16 characters in length.  The user is required
	to enter the same <acronym>PIN</acronym> code on both devices.
	Once the user has entered the <acronym>PIN</acronym> code,
	both devices will generate a <emphasis>link key</emphasis>.
	After that, the link key can be stored either in the devices
	or in a persistent storage.  Next time, both devices will
	use the previously generated link key.  This procedure is
	called <emphasis>pairing</emphasis>.  Note that if the link
	key is lost by either device, the pairing must be
	repeated.</para>

      <para>The &man.hcsecd.8; daemon is responsible for handling
	Bluetooth authentication requests.  The default configuration
	file is <filename>/etc/bluetooth/hcsecd.conf</filename>.  An
	example section for a cellular phone with the
	<acronym>PIN</acronym> code arbitrarily set to
	<quote>1234</quote> is shown below:</para>

      <programlisting>device {
        bdaddr  00:80:37:29:19:a4;
        name    "Pav's T39";
        key     nokey;
        pin     "1234";
      }</programlisting>

      <para>The only limitation on <acronym>PIN</acronym> codes is
	length.  Some devices, such as Bluetooth headsets, may have
	a fixed <acronym>PIN</acronym> code built in.  The
	<option>-d</option> switch forces &man.hcsecd.8; to stay in
	the foreground, so it is easy to see what is happening.  Set
	the remote device to receive pairing and initiate the
	Bluetooth connection to the remote device.  The remote device
	should indicate that pairing was accepted and request the
	<acronym>PIN</acronym> code.  Enter the same
	<acronym>PIN</acronym> code listed in
	<filename>hcsecd.conf</filename>.  Now the computer and the
	remote device are paired.  Alternatively, pairing can be
	initiated on the remote device.</para>

      <para>The following line can be added to
	<filename>/etc/rc.conf</filename> to configure &man.hcsecd.8;
	to start automatically on system start:</para>

      <programlisting>hcsecd_enable="YES"</programlisting>

      <para>The following is a sample of the &man.hcsecd.8; daemon
	output:</para>

      <programlisting>hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4</programlisting>
    </sect2>

    <sect2>
      <title>Service Discovery Protocol
	(<acronym>SDP</acronym>)</title>

      <indexterm><primary>SDP</primary></indexterm>

      <para>The Service Discovery Protocol (<acronym>SDP</acronym>)
	provides the means for client applications to discover the
	existence of services provided by server applications as well
	as the attributes of those services.  The attributes of a
	service include the type or class of service offered and the
	mechanism or protocol information needed to utilize the
	service.</para>

      <para><acronym>SDP</acronym> involves communication between a
	<acronym>SDP</acronym> server and a <acronym>SDP</acronym>
	client.  The server maintains a list of service records that
	describe the characteristics of services associated with the
	server.  Each service record contains information about a
	single service.  A client may retrieve information from a
	service record maintained by the <acronym>SDP</acronym> server
	by issuing a <acronym>SDP</acronym> request.  If the client,
	or an application associated with the client, decides to use
	a service, it must open a separate connection to the service
	provider in order to utilize the service.
	<acronym>SDP</acronym> provides a mechanism for discovering
	services and their attributes, but it does not provide a
	mechanism for utilizing those services.</para>

      <para>Normally, a <acronym>SDP</acronym> client searches for
	services based on some desired characteristics of the
	services.  However, there are times when it is desirable to
	discover which types of services are described by an
	<acronym>SDP</acronym> server's service records without any
	prior information about the services.  This process of
	looking for any offered services is called
	<emphasis>browsing</emphasis>.</para>

      <para>The Bluetooth <acronym>SDP</acronym> server, &man.sdpd.8;,
	and command line client, &man.sdpcontrol.8;, are included in
	the standard &os; installation.  The following example shows
	how to perform a <acronym>SDP</acronym> browse query.</para>

      <screen>&prompt.user; <userinput>sdpcontrol -a 00:01:03:fc:6e:ec browse</userinput>
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server (0x1000)
Protocol Descriptor List:
        L2CAP (0x0100)
                Protocol specific parameter #1: u/int/uuid16 1
                Protocol specific parameter #2: u/int/uuid16 1

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor (0x1001)

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP (0x1102)
Protocol Descriptor List:
        L2CAP (0x0100)
        RFCOMM (0x0003)
                Protocol specific parameter #1: u/int8/bool 1
Bluetooth Profile Descriptor List:
        LAN Access Using PPP (0x1102) ver. 1.0</screen>

      <para>Note that each service has a list of attributes, such
	as the <acronym>RFCOMM</acronym> channel.  Depending on the
	service, the user might need to make note of some of the
	attributes.  Some Bluetooth implementations do not support
	service browsing and may return an empty list.  In this case,
	it is possible to search for the specific service.  The
	example below shows how to search for the
	<acronym>OBEX</acronym> Object Push
	(<acronym>OPUSH</acronym>) service:</para>

      <screen>&prompt.user; <userinput>sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH</userinput></screen>

      <para>Offering services on &os; to Bluetooth clients is done
	with the &man.sdpd.8; server.  The following line can be added
	to <filename>/etc/rc.conf</filename>:</para>

      <programlisting>sdpd_enable="YES"</programlisting>

      <para>Then the &man.sdpd.8; daemon can be
	started with:</para>

      <screen>&prompt.root; <userinput>service sdpd start</userinput></screen>

      <para>The local server application that wants to provide
	Bluetooth service to the remote clients will register service
	with the local <acronym>SDP</acronym> daemon.  An example of
	such an application is &man.rfcomm.pppd.8;.  Once started,
	it will register the Bluetooth LAN service with the local
	<acronym>SDP</acronym> daemon.</para>

      <para>The list of services registered with the local
	<acronym>SDP</acronym> server can be obtained by issuing a
	<acronym>SDP</acronym> browse query via the local control
	channel:</para>

      <screen>&prompt.root; <userinput>sdpcontrol -l browse</userinput></screen>
    </sect2>

    <sect2>
      <title>Dial-Up Networking and Network Access with
	<acronym>PPP</acronym> Profiles</title>

      <para>The Dial-Up Networking (<acronym>DUN</acronym>) profile is
	mostly used with modems and cellular phones.  The scenarios
	covered by this profile are the following:</para>

      <itemizedlist>
	<listitem>
	  <para>Use of a cellular phone or modem by a computer as a
	    wireless modem for connecting to a dial-up Internet access
	    server, or for using other dial-up services.</para>
	</listitem>

	<listitem>
	  <para>Use of a cellular phone or modem by a computer to
	    receive data calls.</para>
	</listitem>
      </itemizedlist>

      <para>Network access with a <acronym>PPP</acronym> profile can
	be used in the following situations:</para>

      <itemizedlist>
	<listitem>
	  <para><acronym>LAN</acronym> access for a single Bluetooth
	    device.</para>
	</listitem>

	<listitem>
	  <para><acronym>LAN</acronym> access for multiple Bluetooth
	    devices.</para>
	</listitem>

	<listitem>
	  <para>PC to PC connection using <acronym>PPP</acronym>
	    networking over serial cable emulation.</para>
	</listitem>
      </itemizedlist>

      <para>In &os;, these profiles are implemented with &man.ppp.8;
	and the &man.rfcomm.pppd.8; wrapper which converts a
	<acronym>RFCOMM</acronym> Bluetooth connection into something
	<acronym>PPP</acronym> can use.  Before a profile can be used,
	a new <acronym>PPP</acronym> label must be created in
	<filename>/etc/ppp/ppp.conf</filename>.  Consult
	&man.rfcomm.pppd.8; for examples.</para>

      <para>In the following example, &man.rfcomm.pppd.8; is used
	to open a <acronym>RFCOMM</acronym> connection to a remote
	device with a BD_ADDR of <literal>00:80:37:29:19:a4</literal>
	on a <acronym>DUN</acronym> <acronym>RFCOMM</acronym> channel.
	The actual <acronym>RFCOMM</acronym> channel number will be
	obtained from the remote device via <acronym>SDP</acronym>.
	It is possible to specify the <acronym>RFCOMM</acronym>
	channel by hand, and in this case &man.rfcomm.pppd.8; will
	not perform the <acronym>SDP</acronym> query.  Use
	&man.sdpcontrol.8; to find out the <acronym>RFCOMM</acronym>
	channel on the remote device.</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</userinput></screen>

      <para>In order to provide network access with the
	<acronym>PPP</acronym> <acronym>LAN</acronym> service,
	&man.sdpd.8; must be running and a new entry for
	<acronym>LAN</acronym> clients must be created in
	<filename>/etc/ppp/ppp.conf</filename>.  Consult
	&man.rfcomm.pppd.8; for examples.  Finally, start the
	<acronym>RFCOMM</acronym> <acronym>PPP</acronym> server on a
	valid <acronym>RFCOMM</acronym> channel number.  The
	<acronym>RFCOMM</acronym> <acronym>PPP</acronym> server will
	automatically register the Bluetooth <acronym>LAN</acronym>
	service with the local <acronym>SDP</acronym> daemon.  The
	example below shows how to start the <acronym>RFCOMM</acronym>
	<acronym>PPP</acronym> server.</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -s -C 7 -l rfcomm-server</userinput></screen>
    </sect2>

    <sect2>
      <title><acronym>OBEX</acronym> Object Push
	(<acronym>OPUSH</acronym>) Profile</title>

      <indexterm><primary>OBEX</primary></indexterm>
      <para><acronym>OBEX</acronym> is a widely used protocol for
	simple file transfers between mobile devices.  Its main use
	is in infrared communication, where it is used for generic
	file transfers between notebooks or <acronym>PDA</acronym>s,
	and for sending business cards or calendar entries between
	cellular phones and other devices with <acronym>PIM</acronym>
	applications.</para>

      <para>The <acronym>OBEX</acronym> server and client are
	implemented as a third-party package,
	<application>obexapp</application>, which is available as
	<package>comms/obexapp</package> package or
	port.</para>

      <para>The <acronym>OBEX</acronym> client is used to push and/or
	pull objects from the <acronym>OBEX</acronym> server.  An
	object can, for example, be a business card or an appointment.
	The <acronym>OBEX</acronym> client can obtain the
	<acronym>RFCOMM</acronym> channel number from the remote
	device via <acronym>SDP</acronym>.  This can be done by
	specifying the service name instead of the
	<acronym>RFCOMM</acronym> channel number.  Supported service
	names are: <acronym>IrMC</acronym>, <acronym>FTRN</acronym>,
	and <acronym>OPUSH</acronym>.  It is also possible to specify
	the <acronym>RFCOMM</acronym> channel as a number.  Below is
	an example of an <acronym>OBEX</acronym> session where the
	device information object is pulled from the cellular phone,
	and a new object, the business card, is pushed into the
	phone's directory.</para>

      <screen>&prompt.user; <userinput>obexapp -a 00:80:37:29:19:a4 -C IrMC</userinput>
obex&gt; get telecom/devinfo.txt devinfo-t39.txt
Success, response: OK, Success (0x20)
obex&gt; put new.vcf
Success, response: OK, Success (0x20)
obex&gt; di
Success, response: OK, Success (0x20)</screen>

      <para>In order to provide the <acronym>OPUSH</acronym> service,
	&man.sdpd.8; must be running and a root folder, where all
	incoming objects will be stored, must be created.  The
	default path to the root folder is <filename>/var/spool/obex</filename>.  Finally,
	start the <acronym>OBEX</acronym> server on a valid
	<acronym>RFCOMM</acronym> channel number.  The
	<acronym>OBEX</acronym> server will automatically register
	the <acronym>OPUSH</acronym> service with the local
	<acronym>SDP</acronym> daemon.  The example below shows how
	to start the <acronym>OBEX</acronym> server.</para>

      <screen>&prompt.root; <userinput>obexapp -s -C 10</userinput></screen>
    </sect2>

    <sect2>
      <title>Serial Port Profile</title>

      <para>The Serial Port Profile (<acronym>SPP</acronym>) allows
	Bluetooth devices to perform serial cable emulation.  This
	profile allows legacy applications to use Bluetooth as a
	cable replacement, through a virtual serial port
	abstraction.</para>

      <para>In &os;, &man.rfcomm.sppd.1; implements
	<acronym>SPP</acronym> and a pseudo tty is used as a virtual
	serial port abstraction.  The example below shows how to
	connect to a remote device serial port service.  A
	<acronym>RFCOMM</acronym> channel does not have to be
	specified as &man.rfcomm.sppd.1; can obtain it from the
	remote device via <acronym>SDP</acronym>.  To override this,
	specify a <acronym>RFCOMM</acronym> channel on the command
	line.</para>

      <screen>&prompt.root; <userinput>rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</userinput>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</screen>

      <para>Once connected, the pseudo tty can be used as serial
	port:</para>

      <screen>&prompt.root; <userinput>cu -l ttyp6</userinput></screen>
    </sect2>

    <sect2>
      <title>Troubleshooting</title>

      <sect3>
	<title>A Remote Device Cannot Connect</title>

	<para>Some older Bluetooth devices do not support role
	  switching.  By default, when &os; is accepting a new
	  connection, it tries to perform a role switch and become
	  master.  Devices, which do not support this will not be able
	  to connect.  Since role switching is performed when a
	  new connection is being established, it is not possible
	  to ask the remote device if it supports role switching.
	  There is a <acronym>HCI</acronym> option to disable role
	  switching on the local side:</para>

	<screen>&prompt.root; <userinput>hccontrol -n ubt0hci write_node_role_switch 0</userinput></screen>
      </sect3>

      <sect3>
	<title>Displaying Bluetooth Packets</title>

	<para>Use the third-party package
	  <application>hcidump</application>, which is available as a
	  <package>comms/hcidump</package> package or
	  port.  This utility is similar to &man.tcpdump.1; and can
	  be used to display the contents of Bluetooth packets on
	  the terminal and to dump the Bluetooth packets to a
	  file.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="network-bridging">
    <info><title>Bridging</title>
      <authorgroup>
	<author><personname><firstname>Andrew</firstname><surname>Thompson</surname></personname><contrib>Written by </contrib></author>
      </authorgroup>
    </info>
    

    <sect2>
      <title>Introduction</title>

      <indexterm><primary><acronym>IP</acronym>
	  subnet</primary></indexterm>
      <indexterm><primary>bridge</primary></indexterm>
      <para>It is sometimes useful to divide one physical network,
	such as an Ethernet segment, into two separate network
	segments without having to create <acronym>IP</acronym>
	subnets and use a router to connect the segments together.
	A device that connects two networks together in this fashion
	is called a <quote>bridge</quote>.  A &os; system with two
	network interface cards can act as a bridge.</para>

      <para>The bridge works by learning the <acronym>MAC</acronym>
	layer (Ethernet) addresses of the devices on each of its
	network interfaces.  It forwards traffic between two networks
	only when the source and destination are on different
	networks.</para>

      <para>In many respects, a bridge is like an Ethernet switch with
	very few ports.</para>
    </sect2>

    <sect2>
      <title>Situations Where Bridging Is Appropriate</title>

      <para>There are many common situations in which a bridge is used
	today.</para>

      <sect3>
	<title>Connecting Networks</title>

	<para>The basic operation of a bridge is to join two or more
	  network segments together.  There are many reasons to use a
	  host based bridge over plain networking equipment such as
	  cabling constraints, firewalling, or connecting pseudo
	  networks such as a virtual machine interface.  A bridge can
	  also connect a wireless interface running in hostap mode to
	  a wired network and act as an access point.</para>
      </sect3>

      <sect3>
	<title>Filtering/Traffic Shaping Firewall</title>

	<indexterm><primary>firewall</primary></indexterm>
	<indexterm><primary>NAT</primary></indexterm>

	<para>A common situation is where firewall functionality is
	  needed without routing or Network Address Translation
	  (<acronym>NAT</acronym>).</para>

	<para>An example is a small company that is connected via
	  <acronym>DSL</acronym>
	  or <acronym>ISDN</acronym> to an <acronym>ISP</acronym>.
	  There are thirteen globally-accessible <acronym>IP</acronym>
	  addresses from the <acronym>ISP</acronym> and ten computers
	  on the network.  In this situation, using a router-based
	  firewall is difficult because of subnetting issues.</para>

	<indexterm><primary>router</primary></indexterm>
	<indexterm><primary><acronym>DSL</acronym></primary></indexterm>
	<indexterm><primary><acronym>ISDN</acronym></primary></indexterm>
	<para>A bridge-based firewall can be configured and dropped
	  into the path just downstream of the <acronym>DSL</acronym>
	  or <acronym>ISDN</acronym> router without any
	  <acronym>IP</acronym> numbering issues.</para>
      </sect3>

      <sect3>
	<title>Network Tap</title>

	<para>A bridge can join two network segments and be used to
	  inspect all Ethernet frames that pass between them using
	  &man.bpf.4; and &man.tcpdump.1; on the bridge interface or
	  by sending a copy of all frames out an additional interface
	  known as a span port.</para>
      </sect3>

      <sect3>
	<title>Layer 2 <acronym>VPN</acronym></title>

	<para>Two Ethernet networks can be joined across an
	  <acronym>IP</acronym> link by bridging the networks to an
	  EtherIP tunnel or a &man.tap.4; based solution such as
	  <application>OpenVPN</application>.</para>
      </sect3>

      <sect3>
	<title>Layer 2 Redundancy</title>

	<para>A network can be connected together with multiple links
	  and use the Spanning Tree Protocol <acronym>STP</acronym>
	  to block redundant paths.  For an Ethernet network to
	  function properly, only one active path can exist between
	  two devices.  <acronym>STP</acronym> will detect loops and
	  put the redundant links into a blocked state.  Should one
	  of the active links fail, <acronym>STP</acronym> will
	  calculate a different tree and enable one of the blocked
	  paths to restore connectivity to all points in the
	  network.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Kernel Configuration</title>

      <para>This section covers the &man.if.bridge.4; implementation.
	A netgraph bridging driver is also available, and is described
	in &man.ng.bridge.4;.</para>

      <para>In &os;, &man.if.bridge.4; is a kernel module which is
	automatically loaded by &man.ifconfig.8; when creating a
	bridge interface.  It is also possible to compile the bridge
	in to the kernel by adding <literal>device if_bridge</literal>
	to a custom kernel configuration file.</para>

      <para>Packet filtering can be used with any firewall package
	that hooks in via the &man.pfil.9; framework.  The firewall
	can be loaded as a module or compiled into the kernel.</para>

      <para>The bridge can be used as a traffic shaper with
	&man.altq.4; or &man.dummynet.4;.</para>
    </sect2>

    <sect2>
      <title>Enabling the Bridge</title>

      <para>The bridge is created using interface cloning.  To create
	a bridge use &man.ifconfig.8;:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge create</userinput>
bridge0
&prompt.root; <userinput>ifconfig bridge0</userinput>
bridge0: flags=8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        id 00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:00:00:00:00:00 priority 0 ifcost 0 port 0</screen>

      <para>When a bridge interface is created, it is automatically
	assigned a randomly generated Ethernet address.  The
	<literal>maxaddr</literal> and <literal>timeout</literal>
	parameters control how many <acronym>MAC</acronym> addresses
	the bridge will keep in its forwarding table and how many
	seconds before each entry is removed after it is last seen.
	The other parameters control how <acronym>STP</acronym>
	operates.</para>

      <para>Next, add the member network interfaces to the bridge.
	For the bridge to forward packets, all member interfaces and
	the bridge need to be up:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge0 addm fxp0 addm fxp1 up</userinput>
&prompt.root; <userinput>ifconfig fxp0 up</userinput>
&prompt.root; <userinput>ifconfig fxp1 up</userinput></screen>

      <para>The bridge is now forwarding Ethernet frames between
	<filename>fxp0</filename> and
	<filename>fxp1</filename>.  Add the following lines to
	<filename>/etc/rc.conf</filename> so the bridge is created
	at startup:</para>

      <programlisting>cloned_interfaces="bridge0"
ifconfig_bridge0="addm fxp0 addm fxp1 up"
ifconfig_fxp0="up"
ifconfig_fxp1="up"</programlisting>

      <para>If the bridge host needs an <acronym>IP</acronym>
	address, the correct place to set this is on the bridge
	interface itself rather than one of the member interfaces.
	This can be set statically or via
	<acronym>DHCP</acronym>:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge0 inet 192.168.0.1/24</userinput></screen>

      <para>It is also possible to assign an <acronym>IPv6</acronym>
	address to a bridge interface.</para>
    </sect2>

    <sect2>
      <title>Firewalling</title>

      <indexterm><primary>firewall</primary></indexterm>

      <para>When packet filtering is enabled, bridged packets will
	pass through the filter inbound on the originating interface
	on the bridge interface, and outbound on the appropriate
	interfaces.  Either stage can be disabled.  When direction of
	the packet flow is important, it is best to firewall on the
	member interfaces rather than the bridge itself.</para>

      <para>The bridge has several configurable settings for passing
	non-<acronym>IP</acronym> and <acronym>IP</acronym> packets,
	and layer2 firewalling with &man.ipfw.8;.  See
	&man.if.bridge.4; for more information.</para>
    </sect2>

    <sect2>
      <title>Spanning Tree</title>

      <para>The bridge driver implements the Rapid Spanning Tree
	Protocol (<acronym>RSTP</acronym> or 802.1w) with backwards
	compatibility with legacy <acronym>STP</acronym>.
	<acronym>STP</acronym> is used to detect and remove loops
	in a network topology.  <acronym>RSTP</acronym> provides
	faster convergence than legacy <acronym>STP</acronym>, the
	protocol will exchange information with neighboring switches
	to quickly transition to forwarding without creating loops.
	&os; supports <acronym>RSTP</acronym> and
	<acronym>STP</acronym> as operating modes, with
	<acronym>RSTP</acronym> being the default mode.</para>

      <para><acronym>STP</acronym> can be enabled on member interfaces
	using &man.ifconfig.8;.  For a bridge with
	<filename>fxp0</filename> and
	<filename>fxp1</filename> as the current interfaces,
	enable <acronym>STP</acronym> with:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge0 stp fxp0 stp fxp1</userinput>
bridge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether d6:cf:d5:a0:94:6d
        id 00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0
        member: fxp0 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 3 priority 128 path cost 200000 proto rstp
                role designated state forwarding
        member: fxp1 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role designated state forwarding</screen>

      <para>This bridge has a spanning tree ID of
	<literal>00:01:02:4b:d4:50</literal> and a priority of
	<literal>32768</literal>.  As the <literal>root id</literal>
	is the same, it indicates that this is the root bridge for the
	tree.</para>

      <para>Another bridge on the network also has
	<acronym>STP</acronym> enabled:</para>

      <screen>bridge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        id 00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4
        member: fxp0 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role root state forwarding
        member: fxp1 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 5 priority 128 path cost 200000 proto rstp
                role designated state forwarding</screen>

      <para>The line <literal>root id 00:01:02:4b:d4:50 priority 32768
	  ifcost 400000 port 4</literal> shows that the root bridge is
	<literal>00:01:02:4b:d4:50</literal> and has a path cost of
	<literal>400000</literal> from this bridge.  The path to the
	root bridge is via <literal>port 4</literal> which is
	<filename>fxp0</filename>.</para>
    </sect2>

    <sect2>
      <title>Advanced Bridging</title>

      <sect3>
	<title>Reconstruct Traffic Flows</title>

	<para>The bridge supports monitor mode, where the packets are
	  discarded after &man.bpf.4; processing and are not
	  processed or forwarded further.  This can be used to
	  multiplex the input of two or more interfaces into a single
	  &man.bpf.4; stream.  This is useful for reconstructing the
	  traffic for network taps that transmit the RX/TX signals out
	  through two separate interfaces.</para>

	<para>To read the input from four network interfaces as one
	  stream:</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up</userinput>
&prompt.root; <userinput>tcpdump -i bridge0</userinput></screen>
      </sect3>

      <sect3>
	<title>Span Ports</title>

	<para>A copy of every Ethernet frame received by the bridge
	  will be transmitted out a designated span port.  The number
	  of span ports configured on a bridge is unlimited, but if an
	  interface is designated as a span port, it cannot also be
	  used as a regular bridge port.  This is most useful for
	  snooping a bridged network passively on another host
	  connected to one of the span ports of the bridge.</para>

	<para>To send a copy of all frames out the interface named
	  <filename>fxp4</filename>:</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 span fxp4</userinput></screen>
      </sect3>

      <sect3>
	<title>Private Interfaces</title>

	<para>A private interface does not forward any traffic to any
	  other port that is also a private interface.  The traffic is
	  blocked unconditionally so no Ethernet frames will be
	  forwarded, including <acronym>ARP</acronym>.  If traffic
	  needs to be selectively blocked, a firewall should be used
	  instead.</para>
      </sect3>

      <sect3>
	<title>Sticky Interfaces</title>

	<para>If a bridge member interface is marked as sticky,
	  dynamically learned address entries are treated at static
	  once entered into the forwarding cache.  Sticky entries are
	  never aged out of the cache or replaced, even if the address
	  is seen on a different interface.  This gives the benefit of
	  static address entries without the need to pre-populate the
	  forwarding table.  Clients learned on a particular segment
	  of the bridge can not roam to another segment.</para>

	<para>Another example of using sticky addresses is to
	  combine the bridge with <acronym>VLAN</acronym>s to create
	  a router where customer networks are isolated without
	  wasting <acronym>IP</acronym> address space.  Consider that
	  <systemitem class="fqdomainname">CustomerA</systemitem> is on
	  <literal>vlan100</literal> and <systemitem class="fqdomainname">CustomerB</systemitem> is on
	  <literal>vlan101</literal>.  The bridge has the address
	  <systemitem class="ipaddress">192.168.0.1</systemitem> and is also an
	  Internet router.</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101</userinput>
&prompt.root; <userinput>ifconfig bridge0 inet 192.168.0.1/24</userinput></screen>

	<para>In this example, both clients see <systemitem class="ipaddress">192.168.0.1</systemitem> as their default
	  gateway.  Since the bridge cache is sticky, one host can not
	  spoof the <acronym>MAC</acronym> address of the other
	  customer in order to intercept their traffic.</para>

	<para>Any communication between the <acronym>VLAN</acronym>s
	  can be blocked using a firewall or, as seen in this example,
	  private interfaces:</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 private vlan100 private vlan101</userinput></screen>

	<para>The customers are completely isolated from each other
	  and the full <systemitem class="netmask">/24</systemitem> address
	  range can be allocated without subnetting.</para>
      </sect3>

      <sect3>
	<title>Address Limits</title>

	<para>The number of unique source <acronym>MAC</acronym>
	  addresses behind an interface can be limited.  Once the
	  limit is reached, packets with unknown source addresses
	  are dropped until an existing host cache entry expires or
	  is removed.</para>

	<para>The following example sets the maximum number of
	  Ethernet devices for <systemitem class="fqdomainname">CustomerA</systemitem> on
	  <literal>vlan100</literal> to 10:</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 ifmaxaddr vlan100 10</userinput></screen>
      </sect3>

      <sect3>
	<title><acronym>SNMP</acronym> Monitoring</title>

	<para>The bridge interface and <acronym>STP</acronym>
	  parameters can be monitored via &man.bsnmpd.1; which is
	  included in the &os; base system.  The exported bridge
	  <acronym>MIB</acronym>s conform to the
	  <acronym>IETF</acronym> standards so any
	  <acronym>SNMP</acronym> client or monitoring package can be
	  used to retrieve the data.</para>

	<para>On the bridge, uncomment the
	  <literal>begemotSnmpdModulePath."bridge" =
	    "/usr/lib/snmp_bridge.so"</literal> line from
	  <filename>/etc/snmp.config</filename> and start
	  &man.bsnmpd.1;.  Other configuration, such as community
	  names and access lists, may need to be modified.  See
	  &man.bsnmpd.1; and &man.snmp.bridge.3; for more
	  information.</para>

	<para>The following examples use the
	  <application>Net-SNMP</application> software (<package>net-mgmt/net-snmp</package>) to query a
	  bridge from a client system.  The <package>net-mgmt/bsnmptools</package> port can
	  also be used.  From the <acronym>SNMP</acronym> client
	  which is running <application>Net-SNMP</application>, add
	  the following lines to
	  <filename>$HOME/.snmp/snmp.conf</filename> in order to
	  import the bridge <acronym>MIB</acronym> definitions:</para>

	<programlisting>mibdirs +/usr/share/snmp/mibs
mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB</programlisting>

	<para>To monitor a single bridge using the IETF BRIDGE-MIB
	  (RFC4188):</para>

	<screen>&prompt.user; <userinput>snmpwalk -v 2c -c public bridge1.example.com mib-2.dot1dBridge</userinput>
BRIDGE-MIB::dot1dBaseBridgeAddress.0 = STRING: 66:fb:9b:6e:5c:44
BRIDGE-MIB::dot1dBaseNumPorts.0 = INTEGER: 1 ports
BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 = Timeticks: (189959) 0:31:39.59 centi-seconds
BRIDGE-MIB::dot1dStpTopChanges.0 = Counter32: 2
BRIDGE-MIB::dot1dStpDesignatedRoot.0 = Hex-STRING: 80 00 00 01 02 4B D4 50
...
BRIDGE-MIB::dot1dStpPortState.3 = INTEGER: forwarding(5)
BRIDGE-MIB::dot1dStpPortEnable.3 = INTEGER: enabled(1)
BRIDGE-MIB::dot1dStpPortPathCost.3 = INTEGER: 200000
BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 = Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedCost.3 = INTEGER: 0
BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 = Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedPort.3 = Hex-STRING: 03 80
BRIDGE-MIB::dot1dStpPortForwardTransitions.3 = Counter32: 1
RSTP-MIB::dot1dStpVersion.0 = INTEGER: rstp(2)</screen>

	<para>The <literal>dot1dStpTopChanges.0</literal> value is
	  two, indicating that the <acronym>STP</acronym> bridge
	  topology has changed twice.  A topology change means that
	  one or more links in the network have changed or failed
	  and a new tree has been calculated.  The
	  <literal>dot1dStpTimeSinceTopologyChange.0</literal> value
	  will show when this happened.</para>

	<para>To monitor multiple bridge interfaces, the private
	  BEGEMOT-BRIDGE-MIB can be used:</para>

	<screen>&prompt.user; <userinput>snmpwalk -v 2c -c public bridge1.example.com</userinput>
enterprises.fokus.begemot.begemotBridge
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName."bridge0" = STRING: bridge0
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName."bridge2" = STRING: bridge2
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress."bridge0" = STRING: e:ce:3b:5a:9e:13
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress."bridge2" = STRING: 12:5e:4d:74:d:fc
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts."bridge0" = INTEGER: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts."bridge2" = INTEGER: 1
...
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange."bridge0" = Timeticks: (116927) 0:19:29.27 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange."bridge2" = Timeticks: (82773) 0:13:47.73 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges."bridge0" = Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges."bridge2" = Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot."bridge0" = Hex-STRING: 80 00 00 40 95 30 5E 31
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot."bridge2" = Hex-STRING: 80 00 00 50 8B B8 C6 A9</screen>

	<para>To change the bridge interface being monitored via the
	  <literal>mib-2.dot1dBridge</literal> subtree:</para>

	<screen>&prompt.user; <userinput>snmpset -v 2c -c private bridge1.example.com</userinput>
BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2</screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="network-aggregation">
    <info><title>Link Aggregation and Failover</title>
      <authorgroup>
	<author><personname><firstname>Andrew</firstname><surname>Thompson</surname></personname><contrib>Written by </contrib></author>
      </authorgroup>
    </info>
    

    <indexterm><primary>lagg</primary></indexterm>
    <indexterm><primary>failover</primary></indexterm>
    <indexterm><primary><acronym>FEC</acronym></primary></indexterm>
    <indexterm><primary><acronym>LACP</acronym></primary></indexterm>
    <indexterm><primary>loadbalance</primary></indexterm>
    <indexterm><primary>roundrobin</primary></indexterm>

    <sect2>
      <title>Introduction</title>

      <para>The &man.lagg.4; interface allows aggregation of multiple
	network interfaces as one virtual interface for the purpose of
	providing fault-tolerance and high-speed links.</para>
    </sect2>

    <sect2>
      <title>Operating Modes</title>

      <para>The following operating modes are supported by
	&man.lagg.4;:</para>

      <variablelist>
	<varlistentry>
	  <term>Failover</term>
	  <listitem>
	    <para>Sends and receives traffic only through the master
	      port.  If the master port becomes unavailable, the next
	      active port is used.  The first interface added is the
	      master port and any interfaces added after that are used
	      as failover devices.  If failover to a non-master port
	      occurs, the original port will become master when it
	      becomes available again.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>&cisco; Fast &etherchannel;</term>
	  <listitem>
	    <para>&cisco; Fast &etherchannel; (<acronym>FEC</acronym>)
	      is a static setup and does not negotiate aggregation
	      with the peer or exchange frames to monitor the link.
	      If the switch supports <acronym>LACP</acronym>, that
	      should be used instead.</para>

	    <para><acronym>FEC</acronym> balances outgoing traffic
	      across the active ports based on hashed protocol header
	      information and accepts incoming traffic from any active
	      port.  The hash includes the Ethernet source and
	      destination address and, if available, the
	      <acronym>VLAN</acronym> tag, and the
	      <acronym>IPv4</acronym> or <acronym>IPv6</acronym>
	      source and destination address.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><acronym>LACP</acronym></term>
	  <listitem>
	    <para>The &ieee; 802.3ad Link Aggregation Control Protocol
	      (<acronym>LACP</acronym>) and the Marker Protocol.
	      <acronym>LACP</acronym> will negotiate a set of
	      aggregable links with the peer in to one or more Link
	      Aggregated Groups (<acronym>LAG</acronym>s).  Each
	      <acronym>LAG</acronym> is composed of ports of the
	      same speed, set to full-duplex operation.  The traffic
	      will be balanced across the ports in the
	      <acronym>LAG</acronym> with the greatest total speed.
	      In most cases, there will only be one
	      <acronym>LAG</acronym> which contains all ports.  In
	      the event of changes in physical connectivity,
	      <acronym>LACP</acronym> will quickly converge to a new
	      configuration.</para>

	    <para><acronym>LACP</acronym> balances outgoing traffic
	      across the active ports based on hashed protocol header
	      information and accepts incoming traffic from any active
	      port.  The hash includes the Ethernet source and
	      destination address and, if available, the
	      <acronym>VLAN</acronym> tag, and the IPv4 or
	      <acronym>IPv6</acronym> source and destination
	      address.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Loadbalance</term>
	  <listitem>
	    <para>This is an alias of <emphasis>FEC</emphasis>
	      mode.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Round-robin</term>
	  <listitem>
	    <para>Distributes outgoing traffic using a round-robin
	      scheduler through all active ports and accepts incoming
	      traffic from any active port.  This mode violates
	      Ethernet frame ordering and should be used with
	      caution.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>Examples</title>

      <example xml:id="networking-lacp-aggregation-cisco">
	<title><acronym>LACP</acronym> Aggregation with a &cisco;
	  Switch</title>

	<para>This example connects two interfaces on a &os; machine
	  to the switch as a single load balanced and fault tolerant
	  link.  More interfaces can be added to increase throughput
	  and fault tolerance.  Frame ordering is mandatory on
	  Ethernet links and any traffic between two stations always
	  flows over the same physical link, limiting the maximum
	  speed to that of one interface.  The transmit algorithm
	  attempts to use as much information as it can to
	  distinguish different traffic flows and balance across the
	  available interfaces.</para>

	<para>On the &cisco; switch, add the
	  <replaceable>FastEthernet0/1</replaceable> and
	  <replaceable>FastEthernet0/2</replaceable> interfaces to
	  channel group <replaceable>1</replaceable>:</para>

	<screen><userinput>interface FastEthernet0/1
 channel-group 1 mode active
 channel-protocol lacp</userinput>
!
<userinput>interface FastEthernet0/2
 channel-group 1 mode active
 channel-protocol lacp</userinput></screen>

	<para>Create the &man.lagg.4; interface using
	  <replaceable>fxp0</replaceable> and
	  <replaceable>fxp1</replaceable>, and bring the interfaces up
	  with the <acronym>IP</acronym> address of
	  <replaceable>10.0.0.3/24</replaceable>:</para>

	<screen>&prompt.root; <userinput>ifconfig fxp0 up</userinput>
&prompt.root; <userinput>ifconfig fxp1 up</userinput>
&prompt.root; <userinput>ifconfig lagg0 create </userinput>
&prompt.root; <userinput>ifconfig lagg0 up laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24</userinput></screen>

	<para>View the interface status by running:</para>

	<screen>&prompt.root; <userinput>ifconfig lagg0</userinput></screen>

	<para>Ports marked as <emphasis>ACTIVE</emphasis> are part of
	  the active aggregation group that has been negotiated with
	  the remote switch.  Traffic will be transmitted and
	  received through active ports.  Use the verbose output of
	  &man.ifconfig.8; to view the <acronym>LAG</acronym>
	  identifiers.</para>

	<screen>lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        media: Ethernet autoselect
        status: active
        laggproto lacp
        laggport: fxp1 flags=1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;
        laggport: fxp0 flags=1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;</screen>

	<para>To see the port status on the &cisco; switch, use
	  <userinput>show lacp neighbor</userinput>:</para>

	<screen>switch# show lacp neighbor
Flags:  S - Device is requesting Slow LACPDUs
        F - Device is requesting Fast LACPDUs
        A - Device is in Active mode       P - Device is in Passive mode

Channel group 1 neighbors

Partner's information:

                  LACP port                        Oper    Port     Port
Port      Flags   Priority  Dev ID         Age     Key     Number   State
Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D
Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D</screen>

	<para>For more detail, type <userinput>show lacp neighbor
	  detail</userinput>.</para>

	<para>To retain this configuration across reboots, the
	  following entries can be added to
	  <filename>/etc/rc.conf</filename>:</para>

	<programlisting>ifconfig_<replaceable>fxp0</replaceable>="up"
ifconfig_<replaceable>fxp1</replaceable>="up"
cloned_interfaces="<literal>lagg0</literal>"
ifconfig_<literal>lagg0</literal>="laggproto lacp laggport <replaceable>fxp0</replaceable> laggport <replaceable>fxp1</replaceable> <replaceable>10.0.0.3/24</replaceable>"</programlisting>
      </example>

      <example xml:id="networking-lagg-failover">
	<title>Failover Mode</title>

	<para>Failover mode can be used to switch over to a secondary
	  interface if the link is lost on the master interface.
	  To configure failover mode, first bring the underlying
	  physical interfaces up.  Then, create the &man.lagg.4;
	  interface, using <replaceable>fxp0</replaceable> as the
	  master interface and <replaceable>fxp1</replaceable> as
	  the secondary interface, and assign an <acronym>IP</acronym>
	  address of
	  <replaceable>10.0.0.15/24</replaceable>:</para>

	<screen>&prompt.root; <userinput>ifconfig fxp0 up</userinput>
&prompt.root; <userinput>ifconfig fxp1 up</userinput>
&prompt.root; <userinput>ifconfig lagg0 create</userinput>
&prompt.root; <userinput>ifconfig lagg0 up laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24</userinput></screen>

	<para>The interface should now look something like
	  this:</para>

	<screen>&prompt.root; <userinput>ifconfig lagg0</userinput>
lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.15 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: fxp1 flags=0&lt;&gt;
        laggport: fxp0 flags=5&lt;MASTER,ACTIVE&gt;</screen>

	<para>Traffic will be transmitted and received on
	  <replaceable>fxp0</replaceable>.  If the link is lost on
	  <replaceable>fxp0</replaceable>,
	  <replaceable>fxp1</replaceable> will become the active link.
	  If the link is restored on the master interface, it will
	  once again become the active link.</para>

	<para>To retain this configuration across reboots, the
	  following entries can be added to
	  <filename>/etc/rc.conf</filename>:</para>

	<programlisting>ifconfig_<replaceable>fxp0</replaceable>="up"
ifconfig_<replaceable>fxp1</replaceable>="up"
cloned_interfaces="<literal>lagg0</literal>"
ifconfig_<literal>lagg0</literal>="laggproto failover laggport <replaceable>fxp0</replaceable> laggport <replaceable>fxp1</replaceable> <replaceable>10.0.0.15/24</replaceable>"</programlisting>
      </example>

      <example xml:id="networking-lagg-wired-and-wireless">
	<title>Failover Mode Between Wired and Wireless
	  Interfaces</title>

	<para>For laptop users, it is usually desirable to configure
	  the wireless device as a secondary interface, which is used
	  when the wired connection is not available.  With
	  &man.lagg.4;, it is possible to use one
	  <acronym>IP</acronym> address, prefer the wired connection
	  for both performance and security reasons, while
	  maintaining the ability to transfer data over the wireless
	  connection.</para>

	<para>In this setup, override the underlying wireless
	  interface's <acronym>MAC</acronym> address to match that
	  of the &man.lagg.4;, which is inherited from the wired
	  interface.</para>

	<para>In this example, the wired interface,
	  <replaceable>bge0</replaceable>, is the master, and the
	  wireless interface, <replaceable>wlan0</replaceable>, is
	  the failover interface.  The
	  <replaceable>wlan0</replaceable> device was created from
	  <replaceable>iwn0</replaceable>, which will be configured
	  with the wired connection's <acronym>MAC</acronym> address.
	  The first step is to determine the <acronym>MAC</acronym>
	  address of the wired interface:</para>

	<screen>&prompt.root; <userinput>ifconfig bge0</userinput>
bge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	options=19b&lt;RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM,TSO4&gt;
	ether 00:21:70:da:ae:37
	inet6 fe80::221:70ff:feda:ae37%bge0 prefixlen 64 scopeid 0x2
	nd6 options=29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt;
	media: Ethernet autoselect (1000baseT &lt;full-duplex&gt;)
	status: active</screen>

	<para>Replace <replaceable>bge0</replaceable> to match the
	  system's interface name.  The <literal>ether</literal>
	  line will contain the <acronym>MAC</acronym> address of
	  the wired interface.  Now, change the
	  <acronym>MAC</acronym> address of the underlying wireless
	  interface:</para>

	<screen>&prompt.root; <userinput>ifconfig iwn0 ether 00:21:70:da:ae:37</userinput></screen>

	<para>Bring the wireless interface up, but do not set an
	  <acronym>IP</acronym> address:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev iwn0 ssid my_router up</userinput></screen>

	<para>Bring the <replaceable>bge0</replaceable> interface up.
	  Create the &man.lagg.4; interface with
	  <replaceable>bge0</replaceable> as master, and failover to
	  <replaceable>wlan0</replaceable>:</para>

	<screen>&prompt.root; <userinput>ifconfig bge0 up</userinput>
&prompt.root; <userinput>ifconfig lagg0 create</userinput>
&prompt.root; <userinput>ifconfig lagg0 up laggproto failover laggport bge0 laggport wlan0</userinput></screen>

	<para>The interface will now look something like this:</para>

	<screen>&prompt.root; <userinput>ifconfig lagg0</userinput>
lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=8&lt;VLAN_MTU&gt;
        ether 00:21:70:da:ae:37
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: wlan0 flags=0&lt;&gt;
        laggport: bge0 flags=5&lt;MASTER,ACTIVE&gt;</screen>

	<para>Then, start the <acronym>DHCP</acronym> client to
	  obtain an <acronym>IP</acronym> address:</para>

	<screen>&prompt.root; <userinput>dhclient lagg0</userinput></screen>

	<para>To retain this configuration across reboots, the
	  following entries can be added to
	  <filename>/etc/rc.conf</filename>:</para>

	<programlisting>ifconfig_bge0="up"
ifconfig_iwn0="ether 00:21:70:da:ae:37"
wlans_iwn0="wlan0"
ifconfig_wlan0="WPA"
cloned_interfaces="<literal>lagg0</literal>"
ifconfig_<literal>lagg0</literal>="laggproto failover laggport bge0 laggport wlan0 DHCP"</programlisting>
      </example>
    </sect2>
  </sect1>

  <sect1 xml:id="network-diskless">
    <info><title>Diskless Operation</title>
      <authorgroup>
	<author><personname><firstname>Jean-Fran&ccedil;ois</firstname><surname>Dock&egrave;s</surname></personname><contrib>Updated by </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Alex</firstname><surname>Dupre</surname></personname><contrib>Reorganized and enhanced by </contrib></author>
      </authorgroup>
    </info>
    

    <indexterm><primary>diskless workstation</primary></indexterm>
    <indexterm><primary>diskless operation</primary></indexterm>

    <para>A &os; machine can boot over the network and operate
      without a local disk, using file systems mounted from an
      <acronym>NFS</acronym> server.  No system modification is
      necessary, beyond standard configuration files.  Such a system
      is relatively easy to set up because all the necessary elements
      are readily available:</para>

    <para>The &intel; Preboot eXecution Environment
      (<acronym>PXE</acronym>) can be used to load the kernel over
      the network.  It provides a form of smart boot
      <acronym>ROM</acronym> built into some networking cards or
      motherboards.  See &man.pxeboot.8; for more details.</para>

    <para>A sample script
      (<filename>/usr/share/examples/diskless/clone_root</filename>)
      eases the creation and maintenance of the workstation's root
      file system on the server.  The script will probably require
      a little customization.</para>

    <para>Standard system startup files exist in <filename>/etc</filename> to detect and support a
      diskless system startup.</para>

    <para>Swapping, if needed, can be done either to an
      <acronym>NFS</acronym> file or to a local disk.</para>

    <para>There are many ways to set up diskless workstations.  Many
      elements are involved, and most can be customized to suit local
      taste.  The following will describe variations on the setup of a
      complete system, emphasizing simplicity and compatibility with
      the standard &os; startup scripts.  The system described has
      the following characteristics:</para>

    <itemizedlist>
      <listitem>
	<para>The diskless workstations use a shared, read-only
	  <filename>/</filename> and
	  <filename>/usr</filename>.</para>

	<para>The root file system is a copy of a standard &os;
	  root, with some configuration files overridden by ones
	  specific to diskless operation or, possibly, to the
	  workstation they belong to.</para>

	<para>The parts of the root which have to be writable are
	  overlaid with &man.md.4; file systems.  Any changes will be
	  lost when the system reboots.</para>
      </listitem>
    </itemizedlist>

    <caution>
      <para>As described, this system is insecure.  It should live in
	a protected area of a network and be untrusted by other
	hosts.</para>
    </caution>

    <sect2>
      <title>Background Information</title>

      <para>Setting up diskless workstations is both relatively
	straightforward and prone to errors.  These are sometimes
	difficult to diagnose for a number of reasons.  For
	example:</para>

      <itemizedlist>
	<listitem>
	  <para>Compile time options may determine different behaviors
	    at runtime.</para>
	</listitem>

	<listitem>
	  <para>Error messages are often cryptic or totally
	    absent.</para>
	</listitem>
      </itemizedlist>

      <para>In this context, having some knowledge of the background
	mechanisms involved is useful to solve the problems that may
	arise.</para>

      <para>Several operations need to be performed for a successful
	bootstrap:</para>

      <itemizedlist>
	<listitem>
	  <para>The machine needs to obtain initial parameters such as
	    its <acronym>IP</acronym> address, executable filename,
	    server name, and root path.  This is done using the
	    <acronym>DHCP</acronym> or <acronym>BOOTP</acronym>
	    protocols.  <acronym>DHCP</acronym> is a compatible
	    extension of <acronym>BOOTP</acronym>, and uses the same
	    port numbers and basic packet format.  It is possible to
	    configure a system to use only <acronym>BOOTP</acronym>
	    and &man.bootpd.8; is included in the base &os;
	    system.</para>
	</listitem>

	<listitem>
	  <para><acronym>DHCP</acronym> has a number of advantages
	    over <acronym>BOOTP</acronym> such as nicer configuration
	    files and support for <acronym>PXE</acronym>.  This
	    section describes mainly a <acronym>DHCP</acronym>
	    configuration, with equivalent examples using
	    &man.bootpd.8; when possible.  The sample configuration
	    uses <application>ISC DHCP</application> which is
	    available in the Ports Collection.</para>
	</listitem>

	<listitem>
	  <para>The machine needs to transfer one or several programs
	    to local memory.  Either <acronym>TFTP</acronym> or
	    <acronym>NFS</acronym> are used.  The choice between
	    <acronym>TFTP</acronym> and <acronym>NFS</acronym> is a
	    compile time option in several places.  A common source of
	    error is to specify filenames for the wrong protocol.
	    <acronym>TFTP</acronym> typically transfers all files from
	    a single directory on the server and expects filenames
	    relative to this directory.  <acronym>NFS</acronym> needs
	    absolute file paths.</para>
	</listitem>

	<listitem>
	  <para>The possible intermediate bootstrap programs and the
	    kernel need to be initialized and executed.
	    <acronym>PXE</acronym> loads &man.pxeboot.8;, which is
	    a modified version of the &os; third stage loader,
	    &man.loader.8;.  The third stage loader will obtain most
	    parameters necessary to system startup and leave them
	    in the kernel environment before transferring control.
	    It is possible to use a <filename>GENERIC</filename>
	    kernel in this case.</para>
	</listitem>

	<listitem>
	  <para>Finally, the machine needs to access its file systems
	    using <acronym>NFS</acronym>.</para>
	</listitem>
      </itemizedlist>

      <para>Refer to &man.diskless.8; for more information.</para>
    </sect2>

    <sect2>
      <title>Setup Instructions</title>

      <sect3>
	<title>Configuration Using <application>ISC
	    DHCP</application></title>

	<indexterm>
	  <primary>DHCP</primary>
	  <secondary>diskless operation</secondary>
	</indexterm>

	<para>The <application>ISC DHCP</application> server can
	  answer both <acronym>BOOTP</acronym> and
	  <acronym>DHCP</acronym> requests.</para>

	<para><application>ISC DHCP</application> is not part of
	  the base system.  Install the <package>net/isc-dhcp42-server</package> port or
	  package.</para>

	<para>Once <application>ISC DHCP</application> is installed,
	  edit its configuration file,
	  <filename>/usr/local/etc/dhcpd.conf</filename>.  Here
	  follows a commented example for <acronym>PXE</acronym> host
	  <systemitem>corbieres</systemitem>:</para>

	<programlisting>default-lease-time 600;
max-lease-time 7200;
authoritative;

option domain-name "example.com";
option domain-name-servers 192.168.4.1;
option routers 192.168.4.1;

subnet 192.168.4.0 netmask 255.255.255.0 {
  use-host-decl-names on; <co xml:id="co-dhcp-host-name"/>
  option subnet-mask 255.255.255.0;
  option broadcast-address 192.168.4.255;

  host corbieres {
    hardware ethernet 00:02:b3:27:62:df;
    fixed-address corbieres.example.com;
    next-server 192.168.4.4; <co xml:id="co-dhcp-next-server"/>
    filename "pxeboot"; <co xml:id="co-dhcp-filename"/>
    option root-path "192.168.4.4:/data/misc/diskless"; <co xml:id="co-dhcp-root-path"/>
  }
}</programlisting>

	<calloutlist>
	  <callout arearefs="co-dhcp-host-name">
	    <para>This option tells <application>dhcpd</application>
	      to send the value in the <literal>host</literal>
	      declarations as the hostname for the diskless host.
	      An alternate way would be to add an <literal>option
	      host-name corbieres</literal>
	      inside the <literal>host</literal> declarations.</para>
	  </callout>

	  <callout arearefs="co-dhcp-next-server">
	    <para>The <literal>next-server</literal> directive
	      designates the <acronym>TFTP</acronym> or
	      <acronym>NFS</acronym> server to use for loading
	      &man.loader.8; or the kernel file.  The default is to
	      use the same host as the <acronym>DHCP</acronym>
	      server.</para>
	  </callout>

	  <callout arearefs="co-dhcp-filename">
	    <para>The <literal>filename</literal> directive defines
	      the file that <acronym>PXE</acronym> will load for the
	      next execution step.  It must be specified according
	      to the transfer method used.
	      <acronym>PXE</acronym> uses <acronym>TFTP</acronym>,
	      which is why a relative filename is used here.  Also,
	      <acronym>PXE</acronym> loads
	      <filename>pxeboot</filename>, not the kernel.  There are
	      other interesting possibilities, like loading
	      <filename>pxeboot</filename> from a &os; CD-ROM
	      <filename>/boot</filename> directory.
	      Since &man.pxeboot.8; can load a
	      <filename>GENERIC</filename> kernel, it is possible to
	      use <acronym>PXE</acronym> to boot from a remote
	      CD-ROM.</para>
	  </callout>

	  <callout arearefs="co-dhcp-root-path">
	    <para>The <literal>root-path</literal> option defines
	      the path to the root file system, in usual
	      <acronym>NFS</acronym> notation.  When using
	      <acronym>PXE</acronym>, it is possible to leave off the
	      host's <acronym>IP</acronym> address as long as the
	      <acronym>BOOTP</acronym> kernel option is not enabled.
	      The <acronym>NFS</acronym> server will then be the
	      same as the <acronym>TFTP</acronym> one.</para>
	  </callout>
	</calloutlist>
      </sect3>

      <sect3>
	<title>Booting with <acronym>PXE</acronym></title>

	<para>By default, &man.pxeboot.8; loads the kernel via
	  <acronym>NFS</acronym>.  It can be compiled to use
	  <acronym>TFTP</acronym> instead by specifying the
	  <literal>LOADER_TFTP_SUPPORT</literal> option in
	  <filename>/etc/make.conf</filename>.  See the comments in
	  <filename>/usr/share/examples/etc/make.conf</filename> for
	  instructions.</para>

	<para>There are two other <filename>make.conf</filename>
	  options which may be useful for setting up a serial console
	  diskless machine:
	  <literal>BOOT_PXELDR_PROBE_KEYBOARD</literal>, and
	  <literal>BOOT_PXELDR_ALWAYS_SERIAL</literal>.</para>

	<para>To use <acronym>PXE</acronym> when the machine starts,
	  select the <literal>Boot from network</literal> option in
	  the <acronym>BIOS</acronym> setup or type a function key
	  during system initialization.</para>
      </sect3>

      <sect3>
	<title>Configuring the <acronym>TFTP</acronym> and
	  <acronym>NFS</acronym> Servers</title>

	<indexterm>
	  <primary>TFTP</primary>
	  <secondary>diskless operation</secondary>
	</indexterm>
	<indexterm>
	  <primary>NFS</primary>
	  <secondary>diskless operation</secondary>
	</indexterm>

	<para>If <acronym>PXE</acronym> is configured to use
	  <acronym>TFTP</acronym>, enable &man.tftpd.8; on the file
	  server:</para>

	<procedure>
	  <step>
	    <para>Create a directory from which &man.tftpd.8; will
	      serve the files, such as <filename>/tftpboot</filename>.</para>
	  </step>

	  <step>
	    <para>Add this line to
	      <filename>/etc/inetd.conf</filename>:</para>

	    <programlisting>tftp	dgram	udp	wait	root	/usr/libexec/tftpd	tftpd -l -s /tftpboot</programlisting>

	    <note>
	      <para>Some
		<acronym>PXE</acronym> versions require the
		<acronym>TCP</acronym> version of
		<acronym>TFTP</acronym>.  In this case, add a second
		line, replacing <literal>dgram udp</literal> with
		<literal>stream tcp</literal>.</para>
	    </note>
	  </step>

	  <step>
	    <para>Tell &man.inetd.8; to reread its configuration file.
	      Add <option>inetd_enable="YES"</option> to
	      <filename>/etc/rc.conf</filename> in order for this
	      command to execute correctly:</para>

	    <screen>&prompt.root; <userinput>service inetd restart</userinput></screen>
	  </step>
	</procedure>

	<para>Place <filename>tftpboot</filename>
	  anywhere on the server.  Make sure that the location is
	  set in both <filename>/etc/inetd.conf</filename> and
	  <filename>/usr/local/etc/dhcpd.conf</filename>.</para>

	<para>Enable
	  <acronym>NFS</acronym> and export the appropriate file
	  system on the <acronym>NFS</acronym> server.</para>

	<procedure>
	  <step>
	    <para>Add this line to
	      <filename>/etc/rc.conf</filename>:</para>

	    <programlisting>nfs_server_enable="YES"</programlisting>
	  </step>

	  <step>
	    <para>Export the file system where the diskless root
	      directory is located by adding the following to
	      <filename>/etc/exports</filename>.  Adjust the
	      mount point and replace <replaceable>
		corbieres</replaceable> with the names of the diskless
	      workstations:</para>

	    <programlisting><replaceable>/data/misc</replaceable> -alldirs -ro <replaceable>margaux corbieres</replaceable></programlisting>
	  </step>

	  <step>
	    <para>Tell &man.mountd.8; to reread its configuration
	      file.  If <acronym>NFS</acronym> is enabled in
	      <filename>/etc/rc.conf</filename>, it is recommended
	      to reboot instead.</para>

	    <screen>&prompt.root; <userinput>service mountd restart</userinput></screen>
	  </step>
	</procedure>
      </sect3>

      <sect3>
	<title>Building a Diskless Kernel</title>

	<indexterm>
	  <primary>diskless operation</primary>
	  <secondary>kernel configuration</secondary>
	</indexterm>

	<para>When using <acronym>PXE</acronym>, building a custom
	  kernel with the following options is not strictly necessary.
	  These options cause more <acronym>DHCP</acronym> requests
	  to be issued during kernel startup, with a small risk of
	  inconsistency between the new values and those retrieved
	  by &man.pxeboot.8; in some special cases.  The advantage
	  is that the host name will be set.  Otherwise, set the
	  host name in a client-specific
	  <filename>/etc/rc.conf</filename>.</para>

	<programlisting>options     BOOTP          # Use BOOTP to obtain IP address/hostname
options     BOOTP_NFSROOT  # NFS mount root file system using BOOTP info</programlisting>

	<para>The custom kernel can also include
	  <literal>BOOTP_NFSV3</literal>,
	  <literal>BOOT_COMPAT</literal> and
	  <literal>BOOTP_WIRED_TO</literal>.  Refer to
	  <filename>NOTES</filename> for descriptions of these
	  options.</para>

	<para>These option names are historical and slightly
	  misleading as they actually enable indifferent use of
	  <acronym>DHCP</acronym> and <acronym>BOOTP</acronym>
	  inside the kernel.</para>

	<para>Build the custom kernel, using the instructions in
	  <xref linkend="kernelconfig"/>, and copy it to the place
	  specified in
	  <filename>/usr/local/etc/dhcpd.conf</filename>.</para>
      </sect3>

      <sect3>
	<title>Preparing the Root File System</title>

	<indexterm>
	  <primary>root file system</primary>
	  <secondary>diskless operation</secondary>
	</indexterm>

	<para>Create a root file system for the diskless
	  workstations in the location listed as
	  <literal>root-path</literal> in
	  <filename>/usr/local/etc/dhcpd.conf</filename>.</para>

	<sect4>
	  <title>Using <command>make world</command> to Populate
	    Root</title>

	  <para>This method is quick and will install a complete
	    virgin system, not just the root file system, into
	    <envar>DESTDIR</envar>.  Execute the following
	    script:</para>

	  <programlisting>#!/bin/sh
export DESTDIR=/data/misc/diskless
mkdir -p ${DESTDIR}
cd /usr/src; make buildworld &amp;&amp; make buildkernel
make installworld &amp;&amp; make installkernel
cd /usr/src/etc; make distribution</programlisting>

	  <para>Once done, customize
	    <filename>/etc/rc.conf</filename> and
	    <filename>/etc/fstab</filename> placed into
	    <envar>DESTDIR</envar> according to the system's
	    requirements.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>Configuring Swap</title>

	<para>If needed, a swap file located on the server can be
	  accessed via <acronym>NFS</acronym>.</para>

	<sect4>
	  <title><acronym>NFS</acronym> Swap</title>

	  <para>The kernel does not support enabling
	    <acronym>NFS</acronym> swap at boot time.  Swap must be
	    enabled by the startup scripts, by mounting a writable
	    file system and creating and enabling a swap file.  To
	    create a swap file:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=/path/to/swapfile bs=1k count=1 oseek=100000</userinput></screen>

	  <para>To enable the swap file, add the following line to
	    <filename>/etc/rc.conf</filename>:</para>

	  <programlisting>swapfile=<replaceable>/path/to/swapfile</replaceable></programlisting>
	</sect4>
      </sect3>

      <sect3>
	<title>Miscellaneous Issues</title>

	<sect4>
	  <title>Running with a Read-only <filename>/usr</filename></title>

	  <indexterm>
	    <primary>diskless operation</primary>
	    <secondary>/usr read-only</secondary>
	  </indexterm>

	  <para>If the diskless workstation is configured to run
	    <application>&xorg;</application>, adjust the
	    <application>XDM</application> configuration file as it
	    puts the error log on <filename>/usr</filename> by default.</para>
	</sect4>

	<sect4>
	  <title>Using a Non-&os; Server</title>

	  <para>When the server for the root file system is not
	    running &os;, create the root file system on a &os;
	    machine, then copy it to its destination, using
	    &man.tar.1; or &man.cpio.1;.</para>

	  <para>In this situation, there are sometimes problems with
	    the special files in <filename>/dev</filename>, due to differing
	    major/minor integer sizes.  A solution to this problem
	    is to export a directory from the non-&os; server, mount
	    this directory onto a &os; machine, and use &man.devfs.5;
	    to allocate device nodes transparently for the
	    user.</para>
	</sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="network-pxe-nfs">
    <info><title>PXE Booting with an <acronym>NFS</acronym> Root File
      System</title>
      <authorgroup>
	<author><personname><firstname>Craig</firstname><surname>Rodrigues</surname></personname><affiliation>
	    <address>rodrigc@FreeBSD.org</address>
	  </affiliation><contrib>Written by </contrib></author>
      </authorgroup>
    </info>
    

    <para>The &intel; Preboot eXecution Environment
      (<acronym>PXE</acronym>) allows booting the operating system
      over the network.  <acronym>PXE</acronym> support is usually
      provided in the <acronym>BIOS</acronym> where it can be enabled
      in the <acronym>BIOS</acronym> settings which enable booting
      from the network.  A fully functioning
      <acronym>PXE</acronym> setup also requires properly configured
      <acronym>DHCP</acronym> and <acronym>TFTP</acronym>
      servers.</para>

    <para>When the host computer boots, it receives information over
      <acronym>DHCP</acronym> about where to obtain the initial boot
      loader via <acronym>TFTP</acronym>.  After the host computer
      receives this information, it downloads the boot loader via
      <acronym>TFTP</acronym> and then executes the boot loader.
      This is documented in section 2.2.1 of the <link xlink:href="http://download.intel.com/design/archives/wfm/downloads/pxespec.pdf">Preboot
	Execution Environment (<acronym>PXE</acronym>)
	Specification</link>.  In &os;, the boot loader retrieved
      during the <acronym>PXE</acronym> process is
      <filename>/boot/pxeboot</filename>.  After
      <filename>/boot/pxeboot</filename> executes, the &os; kernel is
      loaded and the rest of the &os; bootup sequence proceeds.
      Refer to <xref linkend="boot"/> for more information about the
      &os; booting process.</para>

    <sect2>
      <title>Setting Up the &man.chroot.8; Environment for the
	<acronym>NFS</acronym> Root File System</title>

      <procedure>
	<step>
	  <para>Choose a directory which will have a &os;
	    installation which will be <acronym>NFS</acronym>
	    mountable.  For example, a directory such as <filename>/b/tftpboot/FreeBSD/install</filename>
	    can be used.</para>

	  <screen>&prompt.root; <userinput>export NFSROOTDIR=/b/tftpboot/FreeBSD/install</userinput>
&prompt.root; <userinput>mkdir -p ${NFSROOTDIR}</userinput></screen>
	</step>

	<step>
	  <para>Enable the <acronym>NFS</acronym> server by following
	    the instructions in <xref linkend="network-configuring-nfs"/>.</para>
	</step>

	<step>
	  <para>Export the directory via <acronym>NFS</acronym> by
	    adding the following to
	    <filename>/etc/exports</filename>:</para>

	  <programlisting>/b -ro -alldirs</programlisting>
	</step>

	<step>
	  <para>Restart the <acronym>NFS</acronym> server:</para>

	  <screen>&prompt.root; <userinput>service nfsd restart</userinput></screen>
	</step>

	<step>
	  <para>Enable &man.inetd.8; by following the steps outlined
	    in <xref linkend="network-inetd-settings"/>.</para>
	</step>

	<step>
	  <para>Add the following line to
	    <filename>/etc/inetd.conf</filename>:</para>

	  <programlisting>tftp dgram udp wait root /usr/libexec/tftpd tftpd -l -s /b/tftpboot</programlisting>
	</step>

	<step>
	  <para>Restart &man.inetd.8;:</para>

	  <screen>&prompt.root; <userinput>service inetd restart</userinput></screen>
	</step>

	<step>
	  <para>Rebuild the &os; kernel and userland (<xref linkend="makeworld"/>):</para>

	  <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput></screen>
	</step>

	<step>
	  <para>Install &os; into the directory mounted over
	    <acronym>NFS</acronym>:</para>

	  <screen>&prompt.root; <userinput>make installworld DESTDIR=${NFSROOTDIR}</userinput>
&prompt.root; <userinput>make installkernel DESTDIR=${NFSROOTDIR}</userinput>
&prompt.root; <userinput>make distribution DESTDIR=${NFSROOTDIR}</userinput></screen>
	</step>

	<step>
	  <para>Test that the <acronym>TFTP</acronym> server works
	    and can download the boot loader which will be obtained
	    via <acronym>PXE</acronym>:</para>

	  <screen>&prompt.root; <userinput>tftp localhost</userinput>
tftp&gt; <userinput>get FreeBSD/install/boot/pxeboot</userinput>
Received 264951 bytes in 0.1 seconds</screen>
	</step>

	<step>
	  <para>Edit <filename>${NFSROOTDIR}/etc/fstab</filename> and
	    create an entry to mount the root file system over
	    <acronym>NFS</acronym>:</para>

	  <programlisting># Device                                         Mountpoint    FSType   Options  Dump Pass
myhost.example.com:/b/tftpboot/FreeBSD/install       /         nfs      ro        0    0</programlisting>

	  <para>Replace <replaceable>myhost.example.com</replaceable>
	    with the hostname or <acronym>IP</acronym> address of the
	    <acronym>NFS</acronym> server.  In this example, the root
	    file system is mounted read-only in order to prevent
	    <acronym>NFS</acronym> clients from potentially deleting
	    the contents of the root file system.</para>
	</step>

	<step>
	  <para>Set the root password in the &man.chroot.8;
	    environment:</para>

	  <screen>&prompt.root; <userinput>chroot ${NFSROOTDIR}</userinput>
&prompt.root; <userinput>passwd</userinput></screen>

	  <para>This sets the root password for client machines which
	    are <acronym>PXE</acronym> booting.</para>
	</step>

	<step>
	  <para>Enable &man.ssh.1; root logins for client machines
	    which are <acronym>PXE</acronym> booting by editing
	    <filename>${NFSROOTDIR}/etc/ssh/sshd_config</filename>
	    and enabling <literal>PermitRootLogin</literal>.  This
	    option is documented in &man.sshd.config.5;.</para>
	</step>

	<step>
	  <para>Perform other customizations of the &man.chroot.8;
	    environment in ${NFSROOTDIR}.  These customizations could
	    include things like adding packages with &man.pkg.add.1;,
	    editing the password file with &man.vipw.8;, or editing
	    &man.amd.conf.5; maps for automounting.  For
	    example:</para>

	  <screen>&prompt.root; <userinput>chroot ${NFSROOTDIR}</userinput>
&prompt.root; <userinput>pkg_add -r bash</userinput></screen>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title>Configuring Memory File Systems Used by
	<filename>/etc/rc.initdiskless</filename></title>

      <para>When booting from an <acronym>NFS</acronym> root volume,
	<filename>/etc/rc</filename> detects the
	<acronym>NFS</acronym> boot and runs
	<filename>/etc/rc.initdiskless</filename>.  Read the comments
	in this script to understand what is going on.  In this case,
	<filename>/etc</filename> and <filename>/var</filename> need to be memory backed
	file systems so that these directories are writable but the
	<acronym>NFS</acronym> root directory is read-only:</para>

      <screen>&prompt.root; <userinput>chroot ${NFSROOTDIR}</userinput>
&prompt.root; <userinput>mkdir -p conf/base</userinput>
&prompt.root; <userinput>tar -c -v -f conf/base/etc.cpio.gz --format cpio --gzip etc</userinput>
&prompt.root; <userinput>tar -c -v -f conf/base/var.cpio.gz --format cpio --gzip var</userinput></screen>

      <para>When the system boots, memory file systems for <filename>/etc</filename> and <filename>/var</filename> will be created and
	mounted and the contents of the
	<filename>cpio.gz</filename> files will be copied into
	them.</para>
    </sect2>

    <sect2 xml:id="network-pxe-setting-up-dhcp">
      <title>Setting up the <acronym>DHCP</acronym> Server</title>

      <para><acronym>PXE</acronym> requires a <acronym>TFTP</acronym>
	and a <acronym>DHCP</acronym> server to be set up.  The
	<acronym>DHCP</acronym> server does not need to be the same
	machine as the <acronym>TFTP</acronym> server, but it needs
	to be accessible in the network.</para>

      <procedure>
	<step>
	  <para>Install the <acronym>DHCP</acronym> server by
	    following the instructions documented at <xref linkend="network-dhcp-server"/>.  Make sure that
	    <filename>/etc/rc.conf</filename> and
	    <filename>/usr/local/etc/dhcpd.conf</filename> are
	    correctly configured.</para>
	</step>

	<step>
	  <para>In <filename>/usr/local/etc/dhcpd.conf</filename>,
	    configure the <literal>next-server</literal>,
	    <literal>filename</literal>, and
	    <literal>option root-path</literal> settings to specify
	    the <acronym>TFTP</acronym> server <acronym>IP</acronym>
	    address, the path to <filename>/boot/pxeboot</filename>
	    in <acronym>TFTP</acronym>, and the path to the
	    <acronym>NFS</acronym> root file system.  Here is a sample
	    <filename>dhcpd.conf</filename> setup:</para>

	  <programlisting>subnet 192.168.0.0 netmask 255.255.255.0 {
   range 192.168.0.2 192.168.0.3 ;
   option subnet-mask 255.255.255.0 ;
   option routers 192.168.0.1 ;
   option broadcast-address 192.168.0.255 ;
   option domain-name-servers 192.168.35.35, 192.168.35.36 ;
   option domain-name "example.com";

   # IP address of TFTP server
   next-server 192.168.0.1 ;

   # path of boot loader obtained
   # via tftp
   filename "FreeBSD/install/boot/pxeboot" ;

   # pxeboot boot loader will try to NFS mount this directory for root FS
   option root-path "192.168.0.1:/b/tftpboot/FreeBSD/install/" ;

}</programlisting>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title>Configuring the <acronym>PXE</acronym> Client and
	Debugging Connection Problems</title>

      <procedure>
	<step>
	  <para>When the client machine boots up, enter the
	    <acronym>BIOS</acronym> configuration menu.  Configure the
	    <acronym>BIOS</acronym> to boot from the network.  If all
	    previous configuration steps are correct, everything
	    should &quot;just work&quot;.</para>
	</step>

	<step>

	  <para>Use the <package>net/wireshark</package> package or
	    port to debug the network traffic involved during the
	    <acronym>PXE</acronym> booting process, as illustrated
	    in the diagram below.  In <xref linkend="network-pxe-setting-up-dhcp"/>, an example
	    configuration is shown where the <acronym>DHCP</acronym>,
	    <acronym>TFTP</acronym>, and <acronym>NFS</acronym>
	    servers are on the same machine.  However, these
	    servers can be on separate machines.</para>

	  <figure>
	    <title><acronym>PXE</acronym> Booting Process with
	      <acronym>NFS</acronym> Root Mount</title>

	    <mediaobject>
	      <imageobjectco>
		<areaspec units="calspair">
		  <area xml:id="co-pxenfs1" coords="2873,8133 3313,7266"/>
		  <area xml:id="co-pxenfs2" coords="3519,6333 3885,5500"/>
		  <area xml:id="co-pxenfs3" coords="4780,5866 5102,5200"/>
		  <area xml:id="co-pxenfs4" coords="4794,4333 5102,3600"/>
		  <area xml:id="co-pxenfs5" coords="3108,2666 3519,1800"/>
		</areaspec>
		<imageobject>
		  <imagedata fileref="advanced-networking/pxe-nfs"/>
		</imageobject>
		<calloutlist>
		  <callout arearefs="co-pxenfs1">
		    <para>Client broadcasts a
		      <literal>DHCPDISCOVER</literal> message.</para>
		  </callout>
		  <callout arearefs="co-pxenfs2">
		    <para>The <acronym>DHCP</acronym> server responds
		      with the <acronym>IP</acronym> address,
		      <literal>next-server</literal>,
		      <literal>filename</literal>, and
		      <literal>root-path</literal> values.</para>
		  </callout>
		  <callout arearefs="co-pxenfs3">
		    <para>The client sends a <acronym>TFTP</acronym>
		      request to <literal>next-server</literal>,
		      asking to retrieve
		      <literal>filename</literal>.</para>
		  </callout>
		  <callout arearefs="co-pxenfs4">
		    <para>The <acronym>TFTP</acronym> server responds
		      and sends <literal>filename</literal> to
		      client.</para>
		  </callout>
		  <callout arearefs="co-pxenfs5">
		    <para>The client executes
		      <literal>filename</literal>, which is
		      &man.pxeboot.8;, which then loads the kernel.
		      When the kernel executes, the root file system
		      specified by <literal>root-path</literal> is
		      mounted over <acronym>NFS</acronym>.</para>
		  </callout>
		</calloutlist>
	      </imageobjectco>
	    </mediaobject>
	  </figure>
	</step>

	<step>
	  <para>Make sure that the <filename>pxeboot</filename> file
	    can be retrieved by <acronym>TFTP</acronym>.  On the
	    <acronym>TFTP</acronym> server, read
	    <filename>/var/log/xferlog</filename> to ensure that the
	    <filename>pxeboot</filename> file is being retrieved from
	    the correct location.  To test this example
	    configuration:</para>

	  <screen>&prompt.root; <userinput>tftp 192.168.0.1</userinput>
tftp&gt; <userinput>get FreeBSD/install/boot/pxeboot</userinput>
Received 264951 bytes in 0.1 seconds</screen>

	  <para>The <literal>BUGS</literal> sections in &man.tftpd.8;
	    and &man.tftp.1; document some limitations with
	    <acronym>TFTP</acronym>.</para>
	</step>

	<step>
	  <para>Make sure that the root file system can be mounted
	    via <acronym>NFS</acronym>.  To test this example
	    configuration:</para>

	  <screen>&prompt.root; <userinput>mount -t nfs 192.168.0.1:/b/tftpboot/FreeBSD/install /mnt</userinput></screen>
	</step>

	<step>
	  <para>Read the code in
	    <filename>src/sys/boot/i386/libi386/pxe.c</filename> to
	    understand how the <filename>pxeboot</filename> loader
	    sets variables like <literal>boot.nfsroot.server</literal>
	    and <literal>boot.nfsroot.path</literal>.  These variables
	    are then used in the <acronym>NFS</acronym> diskless root
	    mount code in
	    <filename>src/sys/nfsclient/nfs_diskless.c</filename>.</para>
	</step>

	<step>
	  <para>Read &man.pxeboot.8; and &man.loader.8;.</para>
	</step>
      </procedure>
    </sect2>
  </sect1>

  <sect1 xml:id="network-natd">
    <info><title>Network Address Translation</title>
      <authorgroup>
	<author><personname><firstname>Chern</firstname><surname>Lee</surname></personname><contrib>Contributed by </contrib></author>
      </authorgroup>
    </info>
    

    <sect2 xml:id="network-natoverview">
      <title>Overview</title>

      <indexterm>
	<primary>&man.natd.8;</primary>
      </indexterm>
      <para>&os;'s Network Address Translation
	(<acronym>NAT</acronym>) daemon, &man.natd.8;, accepts
	incoming raw <acronym>IP</acronym> packets, changes the
	source to the local machine, and injects these packets back
	into the outgoing <acronym>IP</acronym> packet stream.  The
	source <acronym>IP</acronym> address and port are changed
	such that when data is received back, it is able to determine
	the original location of the data and forward it back to its
	original requester.</para>

      <indexterm>
	<primary>Internet connection sharing</primary>
      </indexterm>
      <indexterm>
	<primary><acronym>NAT</acronym></primary>
      </indexterm>
      <para>The most common use of <acronym>NAT</acronym> is to
	perform what is commonly known as Internet Connection
	Sharing.</para>
    </sect2>

    <sect2 xml:id="network-natsetup">
      <title>Setup</title>

      <para>Due to the diminishing <acronym>IP</acronym> address
	space in <acronym>IPv4</acronym> and the increased number of
	users on high-speed consumer lines such as cable or
	<acronym>DSL</acronym>, people are increasingly in need of
	an Internet Connection Sharing solution.  The ability to
	connect several computers online through one connection and
	<acronym>IP</acronym> address makes &man.natd.8; a reasonable
	choice.</para>

      <para>Most commonly, a user has a machine connected to a cable
	or <acronym>DSL</acronym> line with one <acronym>IP</acronym>
	address and wishes to use this one connected computer to
	provide Internet access to several more over a
	<acronym>LAN</acronym>.</para>

      <para>To do this, the &os; machine connected to the Internet
	must act as a gateway.  This gateway machine must have two
	<acronym>NIC</acronym>s: one connects to the Internet router
	and the other connects to a <acronym>LAN</acronym>.  All the
	machines on the <acronym>LAN</acronym> are connected through
	a hub or switch.</para>

      <note>
	<para>There are many ways to get a <acronym>LAN</acronym>
	  connected to the Internet through a &os; gateway.  This
	  example will only cover a gateway with at least two
	  <acronym>NIC</acronym>s.</para>
      </note>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="advanced-networking/natd"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced">  _______       __________       ________
 |       |     |          |     |        |
 |  Hub  |-----| Client B |-----| Router |----- Internet
 |_______|     |__________|     |________|
     |
 ____|_____
|          |
| Client A |
|__________|</literallayout>
	</textobject>

	<textobject>
	  <phrase>Network Layout</phrase>
	</textobject>
      </mediaobject>

      <para>A setup like this is commonly used to share an Internet
	connection.  One of the <acronym>LAN</acronym> machines is
	connected to the Internet and the rest of the machines access
	the Internet through that <quote>gateway</quote>
	machine.</para>
    </sect2>

    <sect2 xml:id="network-natdloaderconfiguration">
      <title>Boot Loader Configuration</title>

      <indexterm>
	<primary>boot loader</primary>
	<secondary>configuration</secondary>
      </indexterm>

      <para>The kernel features for &man.natd.8; are not enabled in
	the <filename>GENERIC</filename> kernel, but they can be
	loaded at boot time by adding a couple of options to
	<filename>/boot/loader.conf</filename>:</para>

      <programlisting>ipfw_load="YES"
ipdivert_load="YES"</programlisting>

      <para>Additionally, the
	<literal>net.inet.ip.fw.default_to_accept</literal> tunable
	option should be set to <literal>1</literal>:</para>

      <programlisting>net.inet.ip.fw.default_to_accept="1"</programlisting>

      <note>
	<para>It is a good idea to set this option during the first
	  attempts to setup a firewall and <acronym>NAT</acronym>
	  gateway.  This sets the default policy of &man.ipfw.8; to
	  be more permissive than the default <literal>deny ip from
	    any to any</literal>, making it slightly more difficult
	  to get locked out of the system right after a reboot.</para>
      </note>
    </sect2>

    <sect2 xml:id="network-natdkernconfiguration">
      <title>Kernel Configuration</title>

      <indexterm>
	<primary>kernel</primary>
	<secondary>configuration</secondary>
      </indexterm>
      <para>When modules are not an option or if it is preferable to
	build all the required features into a custom kernel, the
	following options must be in the custom kernel configuration
	file:</para>

      <programlisting>options IPFIREWALL
options IPDIVERT</programlisting>

      <para>Additionally, the following may also be suitable:</para>

      <programlisting>options IPFIREWALL_DEFAULT_TO_ACCEPT
options IPFIREWALL_VERBOSE</programlisting>
    </sect2>

    <sect2 xml:id="network-natdsystemconfiguration">
      <title>System Startup Configuration</title>

      <para>To enable firewall and <acronym>NAT</acronym> support at
	boot time, the following must be in
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>gateway_enable="YES" <co xml:id="co-natd-gateway-enable"/>
firewall_enable="YES" <co xml:id="co-natd-firewall-enable"/>
firewall_type="OPEN" <co xml:id="co-natd-firewall-type"/>
natd_enable="YES"
natd_interface="<replaceable>fxp0</replaceable>" <co xml:id="co-natd-natd-interface"/>
natd_flags="" <co xml:id="co-natd-natd-flags"/></programlisting>

      <calloutlist>
	<callout arearefs="co-natd-gateway-enable">
	  <para>Sets up the machine to act as a gateway.  Running
	    <command>sysctl net.inet.ip.forwarding=1</command> would
	    have the same effect.</para>
	</callout>

	<callout arearefs="co-natd-firewall-enable">
	  <para>Enables the firewall rules in
	    <filename>/etc/rc.firewall</filename> at boot.</para>
	</callout>

	<callout arearefs="co-natd-firewall-type">
	  <para>This specifies a predefined firewall ruleset that
	    allows anything in.  See
	    <filename>/etc/rc.firewall</filename> for additional
	    types.</para>
	</callout>

	<callout arearefs="co-natd-natd-interface">
	  <para>Indicates which interface to forward packets through.
	    This is the interface that is connected to the
	    Internet.</para>
	</callout>

	<callout arearefs="co-natd-natd-flags">
	  <para>Any additional configuration options passed to
	    &man.natd.8; on boot.</para>
	</callout>
      </calloutlist>

      <para>These
	<filename>/etc/rc.conf</filename> options will run
	<command>natd -interface fxp0</command> at boot.  This can
	also be run manually after boot.</para>

      <note>
	<para>It is also possible to use a configuration file for
	  &man.natd.8; when there are too many options to pass.  In
	  this case, the configuration file must be defined by adding
	  the following line to
	  <filename>/etc/rc.conf</filename>:</para>

	<programlisting>natd_flags="-f /etc/natd.conf"</programlisting>

	<para>A list of configuration options, one per line, can be
	  added to <filename>/etc/natd.conf</filename>.  For
	  example:</para>

	<programlisting>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</programlisting>

	<para>For more information about this configuration file,
	  consult &man.natd.8;.</para>
      </note>

      <para>Each machine and interface behind the
	<acronym>LAN</acronym> should be assigned
	<acronym>IP</acronym> addresses in the private network space,
	as defined by <link xlink:href="ftp://ftp.isi.edu/in-notes/rfc1918.txt">RFC
	  1918</link>, and have a default gateway of the
	&man.natd.8; machine's internal <acronym>IP</acronym>
	address.</para>

      <para>For example, client <systemitem>A</systemitem> and
	<systemitem>B</systemitem> behind the <acronym>LAN</acronym> have
	<acronym>IP</acronym> addresses of <systemitem class="ipaddress">192.168.0.2</systemitem> and <systemitem class="ipaddress">192.168.0.3</systemitem>, while the &man.natd.8;
	machine's <acronym>LAN</acronym> interface has an
	<acronym>IP</acronym> address of <systemitem class="ipaddress">192.168.0.1</systemitem>.  The default gateway
	of clients <systemitem>A</systemitem> and <systemitem>B</systemitem> must be
	set to that of the &man.natd.8; machine, <systemitem class="ipaddress">192.168.0.1</systemitem>.  The &man.natd.8;
	machine's external Internet interface does not require any
	special modification for &man.natd.8; to work.</para>
    </sect2>

    <sect2 xml:id="network-natdport-redirection">
      <title>Port Redirection</title>

      <para>The drawback with &man.natd.8; is that the
	<acronym>LAN</acronym> clients are not accessible from the
	Internet.  Clients on the <acronym>LAN</acronym> can make
	outgoing connections to the world but cannot receive incoming
	ones.  This presents a problem if trying to run Internet
	services on one of the <acronym>LAN</acronym> client machines.
	A simple way around this is to redirect selected Internet
	ports on the &man.natd.8; machine to a <acronym>LAN</acronym>
	client.</para>

      <para>For example, an <acronym>IRC</acronym> server runs on
	client <systemitem>A</systemitem> and a web server runs on client
	<systemitem>B</systemitem>.  For this to work properly, connections
	received on ports 6667 (<acronym>IRC</acronym>) and 80
	(<acronym>HTTP</acronym>) must be redirected to the
	respective machines.</para>

      <para>The syntax for <option>-redirect_port</option> is as
	follows:</para>

      <programlisting>     -redirect_port proto targetIP:targetPORT[-targetPORT]
                 [aliasIP:]aliasPORT[-aliasPORT]
                 [remoteIP[:remotePORT[-remotePORT]]]</programlisting>

      <para>In the above example, the argument should be:</para>

      <programlisting>    -redirect_port tcp 192.168.0.2:6667 6667
    -redirect_port tcp 192.168.0.3:80 80</programlisting>

      <para>This redirects the proper <acronym>TCP</acronym> ports
	to the <acronym>LAN</acronym> client machines.</para>

      <para>Port ranges over individual ports can be indicated with
	<option>-redirect_port</option>.  For example,
	<replaceable>tcp 192.168.0.2:2000-3000 2000-3000</replaceable>
	would redirect all connections received on ports 2000 to 3000
	to ports 2000 to 3000 on client <systemitem>A</systemitem>.</para>

      <para>These options can be used when directly running
	&man.natd.8;, placed within the
	<literal>natd_flags=""</literal> option in
	<filename>/etc/rc.conf</filename>, or passed via a
	configuration file.</para>

      <para>For further configuration options, consult
	&man.natd.8;</para>
    </sect2>

    <sect2 xml:id="network-natdaddress-redirection">
      <title>Address Redirection</title>

      <indexterm><primary>address redirection</primary></indexterm>
      <para>Address redirection is useful if more than one
	<acronym>IP</acronym> address is available.  Each
	<acronym>LAN</acronym> client can be assigned its own
	external <acronym>IP</acronym> address by &man.natd.8;,
	which will then rewrite outgoing packets from the
	<acronym>LAN</acronym> clients with the proper external
	<acronym>IP</acronym> address and redirects all traffic
	incoming on that particular <acronym>IP</acronym> address
	back to the specific <acronym>LAN</acronym> client.  This is
	also known as static <acronym>NAT</acronym>.  For example,
	if <acronym>IP</acronym> addresses <systemitem class="ipaddress">128.1.1.1</systemitem>, <systemitem class="ipaddress">128.1.1.2</systemitem>, and <systemitem class="ipaddress">128.1.1.3</systemitem> are available, <systemitem class="ipaddress">128.1.1.1</systemitem> can be used as the
	&man.natd.8; machine's external <acronym>IP</acronym>
	address, while <systemitem class="ipaddress">128.1.1.2</systemitem> and
	<systemitem class="ipaddress">128.1.1.3</systemitem> are forwarded back
	to <acronym>LAN</acronym> clients <systemitem>A</systemitem> and
	<systemitem>B</systemitem>.</para>

      <para>The <option>-redirect_address</option> syntax is as
	follows:</para>

      <programlisting>-redirect_address localIP publicIP</programlisting>


      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry>localIP</entry>
	      <entry>The internal <acronym>IP</acronym> address of
		the <acronym>LAN</acronym> client.</entry>
	    </row>

	    <row>
	      <entry>publicIP</entry>
	      <entry>The external <acronym>IP</acronym> address
		corresponding to the <acronym>LAN</acronym>
		client.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>In the example, this argument would read:</para>

      <programlisting>-redirect_address 192.168.0.2 128.1.1.2
-redirect_address 192.168.0.3 128.1.1.3</programlisting>

      <para>Like <option>-redirect_port</option>, these arguments are
	placed within the <literal>natd_flags=""</literal> option
	of <filename>/etc/rc.conf</filename>, or passed via a
	configuration file.  With address redirection, there is no
	need for port redirection since all data received on a
	particular <acronym>IP</acronym> address is redirected.</para>

      <para>The external <acronym>IP</acronym> addresses on the
	&man.natd.8; machine must be active and aliased to the
	external interface.  Refer to &man.rc.conf.5; for
	details.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="network-ipv6">
    <info><title><acronym>IPv6</acronym></title>
      <authorgroup>
	<author><personname><firstname>Aaron</firstname><surname>Kaplan</surname></personname><contrib>Originally Written by </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Restructured and Added by </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Brad</firstname><surname>Davis</surname></personname><contrib>Extended by </contrib></author>
      </authorgroup>
    </info>

    

    <para><acronym>IPv6</acronym>, also known as
      <acronym>IPng</acronym> <quote><acronym>IP</acronym> next
	generation</quote>, is the new version of the well known
      <acronym>IP</acronym> protocol, also known as
      <acronym>IPv4</acronym>.  &os; includes the <link xlink:href="http://www.kame.net/">KAME</link>
      <acronym>IPv6</acronym> reference implementation.  &os; comes
      with everything needed to use <acronym>IPv6</acronym>.  This
      section focuses on getting <acronym>IPv6</acronym> configured
      and running.</para>

    <para>In the early 1990s, people became aware of the rapidly
      diminishing address space of <acronym>IPv4</acronym>.  Given
      the expansion rate of the Internet, there were two major
      concerns:</para>

    <itemizedlist>
      <listitem>
	    <para>Running out of addresses.  For years the use of
	      RFC1918 private address space
	      (<systemitem class="ipaddress">10.0.0.0/8</systemitem>,
	      <systemitem class="ipaddress">172.16.0.0/12</systemitem>, and
	      <systemitem class="ipaddress">192.168.0.0/16</systemitem>) and NAT
	      has slowed down the exhaustion.  Even though, there are
	      very few remaining IPv4 addresses.  The Internet
	      Assigned Numbers Authority (<acronym>IANA</acronym>) has
	      issued the last of the available major blocks to the
	      Regional Registries.  Once each Regional Registry runs
	      out, there will be no more available and switching to 
	      <acronym>IPv6</acronym> will be critical.</para>
      </listitem>

      <listitem>
	    <para>Every block of IPv4 addresses allocated required
	      routing information to be exchanged between many routers
	      on the Internet, and these routing tables were getting
	      too large to allow efficient routing.</para>
      </listitem>
    </itemizedlist>

    <para><acronym>IPv6</acronym> deals with these and many other
      issues by providing the following:</para>

    <itemizedlist>
      <listitem>
	<para>128 bit address space which allows for
	  340,282,366,920,938,463,463,374,607,431,768,211,456
	  addresses.  This means there are approximately
	  6.67 * 10^27 <acronym>IPv6</acronym> addresses per square
	  meter on the planet.</para>
      </listitem>

      <listitem>
	<para>Routers only store network aggregation addresses in
	  their routing tables, thus reducing the average space of a
	  routing table to 8192 entries.</para>
      </listitem>
    </itemizedlist>

    <para>There are many other useful features of
      <acronym>IPv6</acronym>:</para>

    <itemizedlist>
      <listitem>
	<para>Address autoconfiguration (<link xlink:href="http://www.ietf.org/rfc/rfc2462.txt">RFC2462</link>).</para>
      </listitem>

      <listitem>
	<para>Anycast addresses (<quote>one-out-of
	    many</quote>).</para>
      </listitem>

      <listitem>
	<para>Mandatory multicast addresses.</para>
      </listitem>

      <listitem>
	<para><acronym>IPsec</acronym> (<acronym>IP</acronym>
	  security).</para>
      </listitem>

      <listitem>
	<para>Simplified header structure.</para>
      </listitem>

      <listitem>
	<para>Mobile <acronym>IP</acronym>.</para>
      </listitem>

      <listitem>
	<para><acronym>IPv6</acronym>-to-<acronym>IPv4</acronym>
	  transition mechanisms.</para>
      </listitem>
    </itemizedlist>


    <para>For more information see:</para>

    <itemizedlist>
      <listitem>
	<para><link xlink:href="http://www.kame.net">KAME.net</link></para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>Background on <acronym>IPv6</acronym> Addresses</title>

      <para>There are different types of <acronym>IPv6</acronym>
	addresses: unicast, anycast, and multicast.</para>

      <para>Unicast addresses are the well known addresses.  A packet
	sent to a unicast address arrives at the interface
	belonging to the address.</para>

      <para>Anycast addresses are syntactically indistinguishable from
	unicast addresses but they address a group of interfaces.  The
	packet destined for an anycast address will arrive at the
	nearest (in router metric) interface.  Anycast addresses may
	only be used by routers.</para>

      <para>Multicast addresses identify a group of interfaces.  A
	packet destined for a multicast address will arrive at all
	interfaces belonging to the multicast group.</para>

      <note>
	<para>The <acronym>IPv4</acronym> broadcast address, usually
	  <systemitem class="ipaddress">xxx.xxx.xxx.255</systemitem>, is expressed
	  by multicast addresses in <acronym>IPv6</acronym>.</para>
      </note>

      <table frame="none">
	<title>Reserved <acronym>IPv6</acronym> Addresses</title>

	<tgroup cols="4">
	  <thead>
	    <row>
	      <entry><acronym>IPv6</acronym> address</entry>
	      <entry>Prefixlength (Bits)</entry>
	      <entry>Description</entry>
	      <entry>Notes</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><systemitem>::</systemitem></entry>
	      <entry>128 bits</entry>
	      <entry>unspecified</entry>
	      <entry>Equivalent to <systemitem class="ipaddress">0.0.0.0</systemitem> in
		<acronym>IPv4</acronym>.</entry>
	    </row>

	    <row>
	      <entry><systemitem>::1</systemitem></entry>
	      <entry>128 bits</entry>
	      <entry>loopback address</entry>
	      <entry>Equivalent to <systemitem class="ipaddress">127.0.0.1</systemitem> in
		<acronym>IPv4</acronym>.</entry>
	    </row>

	    <row>
	      <entry><systemitem>::00:xx:xx:xx:xx</systemitem></entry>
	      <entry>96 bits</entry>
	      <entry>embedded <acronym>IPv4</acronym></entry>
	      <entry>The lower 32 bits are the compatible
		<acronym>IPv4</acronym> address.</entry>
	    </row>

	    <row>
	      <entry><systemitem>::ff:xx:xx:xx:xx</systemitem></entry>
	      <entry>96 bits</entry>
	      <entry><acronym>IPv4</acronym> mapped
		<acronym>IPv6</acronym> address</entry>
	      <entry>The lower 32 bits are the <acronym>IPv4</acronym>
		address for hosts which do not support
		<acronym>IPv6</acronym>.</entry>
	    </row>

	    <row>
	      <entry><systemitem>fe80::</systemitem> - <systemitem>feb::</systemitem></entry>
	      <entry>10 bits</entry>
	      <entry>link-local</entry>
	      <entry>Equivalent to the loopback address in
		<acronym>IPv4</acronym>.</entry>
	    </row>

	    <row>
	      <entry><systemitem>fec0::</systemitem> - <systemitem>fef::</systemitem></entry>
	      <entry>10 bits</entry>
	      <entry>site-local</entry>
	      <entry>&nbsp;</entry>
	    </row>

	    <row>
	      <entry><systemitem>ff::</systemitem></entry>
	      <entry>8 bits</entry>
	      <entry>multicast</entry>
	      <entry>&nbsp;</entry>
	    </row>

	    <row>
	      <entry><systemitem>001</systemitem> (base
		2)</entry>
	      <entry>3 bits</entry>
	      <entry>global unicast</entry>
	      <entry>All global unicast addresses are assigned from
		this pool.  The first 3 bits are
		<quote>001</quote>.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>

    <sect2>
      <title>Reading <acronym>IPv6</acronym> Addresses</title>

      <para>The canonical form is represented as:
	<systemitem>x:x:x:x:x:x:x:x</systemitem>, with each
	<quote>x</quote> being a 16 bit hex value.  For example:
	<systemitem>FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</systemitem>.</para>

      <para>Often an address will have long substrings of all zeros.
	One such substring per address can be abbreviated by
	<quote>::</quote>.  Also, up to three leading
	<quote>0</quote>s per hex quad can be omitted.  For example,
	<systemitem>fe80::1</systemitem> corresponds to the
	canonical form <systemitem>fe80:0000:0000:0000:0000:0000:0000:0001</systemitem>.</para>

      <para>A third form is to write the last 32 bit part in the
	well known (decimal) <acronym>IPv4</acronym> style with dots
	(<quote>.</quote>) as separators.  For example, <systemitem>2002::10.0.0.1</systemitem> corresponds to the
	hexadecimal canonical representation <systemitem>2002:0000:0000:0000:0000:0000:0a00:0001</systemitem>,
	which in turn is equivalent to <systemitem>2002::a00:1</systemitem>.</para>

      <para>Here is a sample entry from &man.ifconfig.8;:</para>

      <screen>&prompt.root; <userinput>ifconfig</userinput></screen>

      <programlisting>rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active</programlisting>

      <para><systemitem>fe80::200:21ff:fe03:8e1%rl0</systemitem> is an
	auto configured link-local address.  It is generated from
	the <acronym>MAC</acronym> address as part of the auto
	configuration.</para>

      <para>For further information on the structure of
	<acronym>IPv6</acronym> addresses, see <link xlink:href="http://www.ietf.org/rfc/rfc3513.txt">RFC3513</link>.</para>
    </sect2>

    <sect2>
      <title>Getting Connected</title>

      <para>Currently, there are four ways to connect to other
	<acronym>IPv6</acronym> hosts and networks:</para>

      <itemizedlist>
	<listitem>
	  <para>Contact an Internet Service Provider to see if they
	    offer <acronym>IPv6</acronym>.</para>
	</listitem>

	<listitem>
	  <para><link xlink:href="http://www.sixxs.net">SixXS</link> offers
	    tunnels with end-points all around the globe.</para>
	</listitem>
	
	<listitem>
	  <para><link xlink:href="http://www.tunnelbroker.net">Hurricane
	    Electric</link> offers tunnels with end-points all around
	    the globe.</para>
	</listitem>

	<listitem>
	  <para>Tunnel via 6-to-4 as described in <link xlink:href="http://www.ietf.org/rfc/rfc3068.txt">RFC3068</link>.</para>
	</listitem>

	<listitem>
	  <para>Use the
	    <package>net/freenet6</package> port
	    for a dial-up connection.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Applying the Needed Changes to
	<filename>/etc/rc.conf</filename></title>

      <sect3>
	<title><acronym>IPv6</acronym> Client
	  Auto-Configuration</title>

	<para>To automatically configure a machine on a
	  <acronym>LAN</acronym> which acts as a client, not a
	  router, two items are required.  First to enable the
	  <filename>em0</filename> to receive the router
	  solicitation messages, add this line to
	  <filename>rc.conf</filename>:</para>
	
	<programlisting>ifconfig_<replaceable>em0</replaceable>_ipv6="inet6 accept_rtadv"</programlisting>
	
	<para>Secondly, the router solicitation daemon, &man.rtsol.8;,
	  should be enabled by adding the following to
	  <filename>rc.conf</filename>:</para>
	
	<programlisting>rtsold_enable="YES"</programlisting>

	<para>For &os;&nbsp;8.<replaceable>x</replaceable>,
	  add:</para>

	<programlisting>ipv6_enable="YES"</programlisting>
	  </sect3>
	  <sect3>
	    <title><acronym>IPv6</acronym> Client Static
	      Configuration</title>

	<para>To statically assign the <acronym>IPv6</acronym>
	  address, <systemitem>2001:db8:4672:6565:2026:5043:2d42:5344</systemitem>,
	  to <filename>fxp0</filename>, add the following for
	  &os;&nbsp;9.<replaceable>x</replaceable>:</para>

	<programlisting>ifconfig_<replaceable>fxp0</replaceable>_ipv6="inet6 2001:db8:4672:6565:2026:5043:2d42:5344 prefixlen 64"</programlisting>

	<note>
	  <para>Be sure to change <replaceable>prefixlen
	      64</replaceable> to the appropriate value for the
	    subnet.</para>
	</note>

	<para>For &os;&nbsp;8.<replaceable>x</replaceable>,
	  add:</para>

	<programlisting>ipv6_ifconfig_<replaceable>fxp0</replaceable>="2001:db8:4672:6565:2026:5043:2d42:5344"</programlisting>

	<para>To assign a default router of <systemitem>2001:db8:4672:6565::1</systemitem>, add the
	  following to <filename>/etc/rc.conf</filename>:</para>

	<programlisting>ipv6_defaultrouter="2001:db8:4672:6565::1"</programlisting>
      </sect3>

      <sect3>
	<title><acronym>IPv6</acronym> Router/Gateway Settings</title>

	<para>This section demonstrates how to take the directions
	  from a tunnel provider and convert it into settings that
	  will persist through reboots.  To restore the tunnel on
	  startup, add the following lines to
	  <filename>/etc/rc.conf</filename>.</para>

	<para>The first entry lists the generic tunneling interfaces
	  to be configured.  This example configures one interface,
	  <filename>gif0</filename>:</para>

	<programlisting>gif_interfaces="gif<replaceable>0</replaceable>"</programlisting>

	<para>To configure that interface with a local endpoint of
	  <replaceable>MY_IPv4_ADDR</replaceable> to a remote endpoint
	  of <replaceable>REMOTE_IPv4_ADDR</replaceable>:</para>

	<programlisting>gifconfig_gif0="<replaceable>MY_IPv4_ADDR REMOTE_IPv4_ADDR</replaceable>"</programlisting>

	<para>To apply the <acronym>IPv6</acronym> address that has
	  been assigned for use as the <acronym>IPv6</acronym> tunnel
	  endpoint, add the following line for
	  &os;&nbsp;9.<replaceable>x</replaceable> and later:</para>

	<programlisting>ifconfig_gif0_ipv6="inet6 <replaceable>MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR</replaceable>"</programlisting>

	<para>For &os;&nbsp;8.<replaceable>x</replaceable>,
	  add:</para>

	<programlisting>ipv6_ifconfig_gif0="<replaceable>MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR</replaceable>"</programlisting>

	<para>Then, set the default route for
	  <acronym>IPv6</acronym>.  This is the other side of the
	  <acronym>IPv6</acronym> tunnel:</para>

	<programlisting>ipv6_defaultrouter="<replaceable>MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR</replaceable>"</programlisting>
      </sect3>

      <sect3>
	<title><acronym>IPv6</acronym> Tunnel Settings</title>

	<para>If the server is to route <acronym>IPv6</acronym>
	  between the rest of the network and the world, the following
	  <filename>/etc/rc.conf</filename> setting will also be
	  needed:</para>

	<programlisting>ipv6_gateway_enable="YES"</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Router Advertisement and Host Auto Configuration</title>

      <para>This section demonstrates how to setup &man.rtadvd.8; to
	advertise the <acronym>IPv6</acronym> default route.</para>

      <para>To enable &man.rtadvd.8;, add the following to
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>rtadvd_enable="YES"</programlisting>

      <para>It is important to specify the interface on which to
	do <acronym>IPv6</acronym> router solicitation.  For example,
	to tell &man.rtadvd.8; to use
	<filename>fxp0</filename>:</para>

      <programlisting>rtadvd_interfaces="fxp0"</programlisting>

      <para>Next, create the configuration file,
	<filename>/etc/rtadvd.conf</filename> as seen in this
	example:</para>

      <programlisting>fxp0:\
	:addrs#1:addr="2001:471:1f11:246::":prefixlen#64:tc=ether:</programlisting>

      <para>Replace <filename>fxp0</filename> with the interface
	to be used and <systemitem>2001:471:1f11:246::</systemitem> with the
	prefix of the allocation.</para>

      <para>For a dedicated <systemitem class="netmask">/64</systemitem>
	subnet, nothing else needs to be changed.  Otherwise, change
	the <literal>prefixlen#</literal> to the correct value.</para>
    </sect2>

    <sect2>
      <title><acronym>IPv6</acronym> and <acronym>IPv6</acronym>
        Address Mapping</title>

      <para>When <acronym>IPv6</acronym> is enabled on a server, there
	may be a need to enable <acronym>IPv4</acronym> mapped
	<acronym>IPv6</acronym> address communication.  This
	compatibility option allows for <acronym>IPv4</acronym>
	addresses to be represented as <acronym>IPv6</acronym>
	addresses.  Permitting <acronym>IPv6</acronym> applications
	to communicate with <acronym>IPv4</acronym> and vice versa
	may be a security issue.</para>

      <para>This option may not be required in most cases and is
	available only for compatibility.  This option will allow
	<acronym>IPv6</acronym>-only applications to work with
	<acronym>IPv4</acronym> in a dual stack environment.  This
	is most useful for third party applications which may not
	support an <acronym>IPv6</acronym>-only environment.  To
	enable this feature,
	add the following to <filename>/etc/rc.conf</filename>:</para>

      <programlisting>ipv6_ipv4mapping="YES"</programlisting>

      <para>Reviewing the information in <acronym>RFC</acronym> 3493,
	section 3.6 and 3.7 as well as <acronym>RFC</acronym> 4038
	section 4.2 may be useful to some adminstrators.</para>
    </sect2>

	<sect2>
	  <title>Application Use of <acronym>IPv6</acronym></title>

	    <para>Currently <acronym>IPv6</acronym> support for many
	      applications and services is very good, though for some
	      software it still needs work.  For authoritative
	      information about the support of
	      <acronym>IPv6</acronym>, please consult the Official
	      Documentation for the software in question.</para>

	    <para>Web, <acronym>DNS</acronym> and Mail applications
	      and servers have the best support for
	      <acronym>IPv6</acronym> because they are the most common
	      use case.  Other applications may have varying degrees
	      of <acronym>IPv6</acronym> support.</para>
	</sect2>
  </sect1>

  <sect1 xml:id="network-atm">
    <info><title>Asynchronous Transfer Mode (<acronym>ATM</acronym>)</title>
      <authorgroup>
	<author><personname><firstname>Harti</firstname><surname>Brandt</surname></personname><contrib>Contributed by </contrib></author>
      </authorgroup>
    </info>

    

    <sect2>
      <title>Configuring Classical <acronym>IP</acronym> over
	<acronym>ATM</acronym></title>

      <para>Classical <acronym>IP</acronym> over
	<acronym>ATM</acronym> (<acronym>CLIP</acronym>) is the
	simplest method to use Asynchronous Transfer Mode
	(<acronym>ATM</acronym>) with <acronym>IP</acronym>.  It can
	be used with Switched Virtual Circuits
	(<acronym>SVC</acronym>s) and with Permanent Virtual Circuits
	(<acronym>PVC</acronym>s).  This section describes how to
	set up a network based on <acronym>PVC</acronym>s.</para>

      <sect3>
	<title>Fully Meshed Configurations</title>

	<para>The first method to set up a <acronym>CLIP</acronym>
	  with <acronym>PVC</acronym>s is to connect each machine
	  to each other machine in the network via a dedicated
	  <acronym>PVC</acronym>.  While this is simple to
	  configure, it becomes impractical for a large number of
	  machines.  The following example supposes four machines in
	  the network, each connected to the <acronym role="Asynchronous Transfer Mode">ATM</acronym> network
	  with an <acronym role="Asynchronous Transfer Mode">ATM</acronym> adapter
	  card.  The first step is the planning of the
	  <acronym>IP</acronym> addresses and the <acronym role="Asynchronous Transfer Mode">ATM</acronym>
	  connections between the machines.  This example uses the
	  following:</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*"/>
	    <colspec colwidth="1*"/>
	    <thead>
	      <row>
		<entry>Host</entry>
		<entry><acronym>IP</acronym> Address</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><systemitem>hostA</systemitem></entry>
		<entry><systemitem class="ipaddress">192.168.173.1</systemitem></entry>
	      </row>

	      <row>
		<entry><systemitem>hostB</systemitem></entry>
		<entry><systemitem class="ipaddress">192.168.173.2</systemitem></entry>
	      </row>

	      <row>
		<entry><systemitem>hostC</systemitem></entry>
		<entry><systemitem class="ipaddress">192.168.173.3</systemitem></entry>
	      </row>

	      <row>
		<entry><systemitem>hostD</systemitem></entry>
		<entry><systemitem class="ipaddress">192.168.173.4</systemitem></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>To build a fully meshed net, one <acronym>ATM</acronym>
	  connection is needed between each pair of machines:</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*"/>
	    <colspec colwidth="1*"/>
	    <thead>
	      <row>
		<entry>Machines</entry>
		<entry>VPI.VCI couple</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><systemitem>hostA</systemitem> -
		  <systemitem>hostB</systemitem></entry>
		<entry>0.100</entry>
	      </row>

	      <row>
		<entry><systemitem>hostA</systemitem> -
		  <systemitem>hostC</systemitem></entry>
		<entry>0.101</entry>
	      </row>

	      <row>
		<entry><systemitem>hostA</systemitem> -
		  <systemitem>hostD</systemitem></entry>
		<entry>0.102</entry>
	      </row>

	      <row>
		<entry><systemitem>hostB</systemitem> -
		  <systemitem>hostC</systemitem></entry>
		<entry>0.103</entry>
	      </row>

	      <row>
		<entry><systemitem>hostB</systemitem> -
		  <systemitem>hostD</systemitem></entry>
		<entry>0.104</entry>
	      </row>

	      <row>
		<entry><systemitem>hostC</systemitem> -
		  <systemitem>hostD</systemitem></entry>
		<entry>0.105</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>The Virtual Path Identifier <acronym>VPI</acronym> and
	  Virtual Channel Identifier <acronym>VCI</acronym> values
	  at each end of the connection may differ, but for
	  simplicity, this example assumes they are the same.  Next,
	  configure the <acronym>ATM</acronym> interfaces on each
	  host:</para>

	<screen>hostA&prompt.root; <userinput>ifconfig hatm0 192.168.173.1 up</userinput>
hostB&prompt.root; <userinput>ifconfig hatm0 192.168.173.2 up</userinput>
hostC&prompt.root; <userinput>ifconfig hatm0 192.168.173.3 up</userinput>
hostD&prompt.root; <userinput>ifconfig hatm0 192.168.173.4 up</userinput></screen>

	<para>This example assumes that the <acronym>ATM</acronym>
	  interface is <filename>hatm0</filename> on all hosts.
	  Next, the <acronym>PVC</acronym>s need to be configured on
	  <systemitem>hostA</systemitem>.  This should already be configured
	  on the <acronym>ATM</acronym> switch; consult the manual
	  for the switch on how to do this.</para>

	<screen>hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 100 llc/snap ubr</userinput>
hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 101 llc/snap ubr</userinput>
hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 102 llc/snap ubr</userinput>

hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 100 llc/snap ubr</userinput>
hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 103 llc/snap ubr</userinput>
hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 104 llc/snap ubr</userinput>

hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 101 llc/snap ubr</userinput>
hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 103 llc/snap ubr</userinput>
hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 105 llc/snap ubr</userinput>

hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 102 llc/snap ubr</userinput>
hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 104 llc/snap ubr</userinput>
hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 105 llc/snap ubr</userinput></screen>

	<para>Other traffic contracts besides <literal>ubr</literal>
	  can be used if the <acronym>ATM</acronym> adapter supports
	  it.  In this case, the name of the traffic contract is
	  followed by the parameters of the traffic.  Help for the
	  &man.atmconfig.8; tool can be obtained with:</para>

	<screen>&prompt.root; <userinput>atmconfig help natm add</userinput></screen>

	<para>Refer to &man.atmconfig.8; for more information.</para>

	<para>The same configuration can also be done via
	  <filename>/etc/rc.conf</filename>.  These lines configure
	  <systemitem>hostA</systemitem>:</para>

	<programlisting>network_interfaces="lo0 hatm0"
ifconfig_hatm0="inet 192.168.173.1 up"
natm_static_routes="hostB hostC hostD"
route_hostB="192.168.173.2 hatm0 0 100 llc/snap ubr"
route_hostC="192.168.173.3 hatm0 0 101 llc/snap ubr"
route_hostD="192.168.173.4 hatm0 0 102 llc/snap ubr"</programlisting>

	<para>The current state of all <acronym>CLIP</acronym> routes
	  can be obtained with:</para>

	<screen>hostA&prompt.root; <userinput>atmconfig natm show</userinput></screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="carp">
    <info><title>Common Address Redundancy Protocol
      (<acronym>CARP</acronym>)</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Contributed by </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary><acronym>CARP</acronym></primary>
    </indexterm>
    <indexterm>
      <primary>Common Address Redundancy Protocol</primary>
    </indexterm>

    <para>The Common Address Redundancy Protocol
      (<acronym>CARP</acronym>) allows multiple hosts to share the
      same <acronym>IP</acronym> address.  In some configurations,
      this may be used for availability or load balancing.  Hosts
      may use separate <acronym>IP</acronym> addresses, as in the
      example provided here.</para>

    <para>To enable support for <acronym>CARP</acronym>, the &os;
      kernel can be rebuilt as described in <xref linkend="kernelconfig"/> with the following option:</para>

    <programlisting>device	carp</programlisting>

    <para>Alternatively, the <filename>if_carp.ko</filename> module
      can be loaded at boot time.  Add the following line to
      <filename>/boot/loader.conf</filename>:</para>

    <programlisting>if_carp_load="YES"</programlisting>

    <para><acronym>CARP</acronym> functionality should now be
      available and may be tuned via several &man.sysctl.8;
      variables:</para>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>OID</entry>
	    <entry>Description</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><varname>net.inet.carp.allow</varname></entry>
	    <entry>Accept incoming <acronym>CARP</acronym> packets.
	      Enabled by default.</entry>
	  </row>

	  <row>
	    <entry><varname>net.inet.carp.preempt</varname></entry>
	    <entry>This option downs all of the
	      <acronym>CARP</acronym> interfaces on the host when one
	      goes down.  Disabled by default.</entry>
	  </row>

	  <row>
	    <entry><varname>net.inet.carp.log</varname></entry>
	    <entry>A value of <literal>0</literal> disables any
	      logging.  A value of <literal>1</literal> enables
	      logging of bad <acronym>CARP</acronym> packets.  Values
	      greater than <literal>1</literal> enable logging of
	      state changes for the <acronym>CARP</acronym>
	      interfaces.  The default value is
	      <literal>1</literal>.</entry>
	  </row>

	  <row>
	    <entry><varname>net.inet.carp.arpbalance</varname></entry>
	    <entry>Balance local network traffic using
	      <acronym>ARP</acronym>.  Disabled by default.</entry>
	  </row>

	  <row>
	    <entry><varname>net.inet.carp.suppress_preempt</varname></entry>
	    <entry>A read-only variable showing the status of
	      preemption suppression.  Preemption can be suppressed
	      if the link on an interface is down.  A value of
	      <literal>0</literal> means that preemption is not
	      suppressed.  Every problem increments this
	      variable.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>The <acronym>CARP</acronym> devices themselves may be
      created using &man.ifconfig.8;:</para>

    <screen>&prompt.root; <userinput>ifconfig carp0 create</userinput></screen>

    <para>In a real environment, each interface has a unique
      identification number known as a Virtual Host IDentification
      (<acronym>VHID</acronym>) which is used to distinguish the
      host on the network.</para>

    <sect2>
      <title>Using <acronym>CARP</acronym> for Server
	Availability</title>

      <para>One use of <acronym>CARP</acronym> is to provide server
	availability.  This example configures failover support for
	three hosts, all with unique <acronym>IP</acronym>
	addresses and providing the same web content.  These machines
	act in conjunction with a Round Robin
	<acronym>DNS</acronym> configuration.  The failover machine
	has two additional <acronym>CARP</acronym> interfaces, one
	for each of the content server's
	<acronym>IP</acronym> addresses.  When a
	failure occurs, the failover server will pick up the failed
	machine's <acronym>IP</acronym> address.
	This means that the failure should go completely unnoticed
	by the user.  The failover server requires identical content
	and services as the other content servers it is expected to
	pick up load for.</para>

      <para>The two machines should be configured identically other
	than their hostnames and <acronym>VHID</acronym>s.  This
	example calls these machines
	<systemitem>hosta.example.org</systemitem> and
	<systemitem>hostb.example.org</systemitem> respectively.  First, the
	required lines for a <acronym>CARP</acronym> configuration
	have to be added to <filename>/etc/rc.conf</filename>.  Here
	are the lines for
	<systemitem>hosta.example.org</systemitem>:</para>

      <programlisting>hostname="hosta.example.org"
ifconfig_fxp0="inet 192.168.1.3 netmask 255.255.255.0"
cloned_interfaces="carp0"
ifconfig_carp0="vhid 1 pass testpass 192.168.1.50/24"</programlisting>

      <para>On <systemitem>hostb.example.org</systemitem>, use the following
	lines:</para>

      <programlisting>hostname="hostb.example.org"
ifconfig_fxp0="inet 192.168.1.4 netmask 255.255.255.0"
cloned_interfaces="carp0"
ifconfig_carp0="vhid 2 pass testpass 192.168.1.51/24"</programlisting>

      <note>
	<para>It is very important that the passwords, specified by
	  the <option>pass</option> option to &man.ifconfig.8;, are
	  identical.  The <filename>carp</filename> devices will
	  only listen to and accept advertisements from machines
	  with the correct password.  The <acronym>VHID</acronym>
	  must also be unique for each machine.</para>
      </note>

      <para>The third machine, <systemitem>provider.example.org</systemitem>,
	should be prepared so that it may handle failover from either
	host.  This machine will require two
	<filename>carp</filename> devices, one to handle each
	host.  The appropriate <filename>/etc/rc.conf</filename>
	configuration lines will be similar to the following:</para>

      <programlisting>hostname="provider.example.org"
ifconfig_fxp0="inet 192.168.1.5 netmask 255.255.255.0"
cloned_interfaces="carp0 carp1"
ifconfig_carp0="vhid 1 advskew 100 pass testpass 192.168.1.50/24"
ifconfig_carp1="vhid 2 advskew 100 pass testpass 192.168.1.51/24"</programlisting>

      <para>Having the two <filename>carp</filename> devices will
	allow <systemitem>provider.example.org</systemitem> to notice and pick
	up the <acronym>IP</acronym> address of either machine, should
	it stop responding.</para>

      <note>
	<para>The default &os; kernel <emphasis>may</emphasis> have
	  preemption enabled.  If so,
	  <systemitem>provider.example.org</systemitem> may not relinquish the
	  <acronym>IP</acronym> address back to the original content
	  server.  In this case, an administrator may have to manually
	  force the <acronym>IP</acronym> back to the master.  The
	  following command should be issued on
	  <systemitem>provider.example.org</systemitem>:</para>

	<screen>&prompt.root; <userinput>ifconfig carp0 down &amp;&amp; ifconfig carp0 up</userinput></screen>

	<para>This should be done on the <filename>carp</filename>
	  interface which corresponds to the correct host.</para>
      </note>

      <para>At this point, <acronym>CARP</acronym> should be enabled
	and available for testing.  For testing, either networking
	has to be restarted or the machines rebooted.</para>

      <para>More information is available in &man.carp.4;.</para>
    </sect2>
  </sect1>
</chapter>
