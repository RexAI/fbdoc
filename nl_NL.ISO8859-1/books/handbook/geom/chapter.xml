<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Dutch Documentation Project

     $FreeBSD$

     %SOURCE%	en_US.ISO8859-1/books/handbook/geom/chapter.xml
     %SRCID%	39988
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="GEOM">
  <info><title>GEOM: Modulair schijftransformatie raamwerk</title>
    <authorgroup>
      <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Geschreven door </contrib></author>
    </authorgroup>
    <authorgroup>
      <author><personname><firstname>Siebrand</firstname><surname>Mazeland</surname></personname><contrib>Vertaald door </contrib></author>
    </authorgroup>
  </info>

  

  <sect1 xml:id="geom-synopsis">
    <title>Overzicht</title>

    <indexterm><primary>GEOM</primary></indexterm>

    <indexterm>
      <primary>GEOM schijf raamwerk</primary>

      <see>GEOM</see>
    </indexterm>

    <para>Dit hoofdstuk beschrijft het gebruik van schijven in het
      GEOM raamwerk in &os;.  Hieronder vallen de belangrijkste
      <acronym role="Redundant Array of Inexpensive Disks">RAID</acronym>
      besturingsprogramma's die het raamwerk gebruikt voor
      instellingen.  In dit hoofdstuk wordt niet diepgaand beschreven
      hoe GEOM omgaat met I/O, het onderliggende subsysteem of code.
      Die informatie staat in het hulppagina voor &man.geom.4; en de
      verscheidene <quote>SEE ALSO</quote> referenties.  Dit hoofdstuk
      is ook geen definitief stuk over het instellen van
      <acronym>RAID</acronym>.  Alleen de door GEOM ondersteunde
      <acronym>RAID</acronym>-classificaties worden beschreven.</para>

    <para>Na het lezen van dit hoofdstuk weet de lezer:</para>

    <itemizedlist>
      <listitem>
	<para>Welk type <acronym>RAID</acronym>-ondersteuning via GEOM
	  beschikbaar is;</para>
      </listitem>

      <listitem>
	<para>Hoe de basisgereedschappen te gebruiken om de
	  verschillende <acronym>RAID</acronym>-niveaus in te stellen,
	  te onderhouden en te wijzigen;</para>
      </listitem>

      <listitem>
	<para>Hoe schijfapparaten via GEOM te spiegelen, aaneen te
	  schakelen, te versleutelen en vanaf afstand schijven aan te
	  sluiten;</para>
      </listitem>

      <listitem>
	<para>Hoe problemen op te lossen met schijven die via het GEOM
	  raamwerk zijn aangesloten.</para>
      </listitem>
    </itemizedlist>

    <para>Veronderstelde voorkennis:</para>

    <itemizedlist>
      <listitem>
	<para>Begrijpen hoe &os; omgaat met schijfapparaten (<xref linkend="disks"/>);</para>
      </listitem>

      <listitem>
	<para>Weten hoe een nieuwe &os; kernel in te stellen en te
	  installeren (<xref linkend="kernelconfig"/>).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="GEOM-intro">
    <title>GEOM inleiding</title>

    <para>GEOM staat toegang en controle toe op klassen, Master Boot
      Records, <acronym>BSD</acronym> labels, enzovoort, door gebruik
      te maken van diensten of de speciale bestanden in <filename>/dev</filename>.  GEOM ondersteunt
      verschillende software <acronym>RAID</acronym> instellingen en
      biedt transparante toegang tot het besturingssysteem en de
      hulpprogramma's.</para>
  </sect1>

  <sect1 xml:id="GEOM-striping">
    <info><title>RAID0 - aaneengeschakeld</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Geschreven door </contrib></author>
	<author><personname><firstname>Murray</firstname><surname>Stokely</surname></personname></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>GEOM</primary></indexterm>

    <indexterm><primary>aaneengeschakeld</primary></indexterm>

    <para>Aaneenschakelen is een methode die gebruikt wordt
      om meerdere schijven te combineren tot een enkele volume.  In
      veel gevallen wordt dit gedaan met hardware controllers.  Het
      GEOM subsysteem biedt softwareondersteuning voor
      <acronym>RAID</acronym>0, ook wel bekend als aaneenschakelen
      (<quote>disk striping</quote>).</para>

    <para>In een <acronym>RAID</acronym>0-systeem worden gegevens
      opgedeeld in blokken die verdeeld worden over de schijven in een
      reeks.  In plaats van te hoeven wachten tot een systeem 256k naar
      één schijf heeft geschreven, kan een
      <acronym>RAID</acronym>0-systeem tegelijkertijd 64k naar vier
      verschillende schijven schrijven, waardoor superieure I/O
      prestaties worden bereikt.  Deze prestaties kunnen nog verbeterd
      worden door meerdere schijfcontrollers te gebruiken.</para>

    <para>Iedere schijf in een
      <acronym>RAID</acronym>0-aaneenschakeling moet van dezelfde
      grootte zijn, omdat I/O-verzoeken altijd zijn opgebouwd uit
      precies gelijk over de schijven verdeelde verzoeken tot lezen of
      schrijven.</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="geom/striping" align="center"/>
      </imageobject>

      <textobject>
	<phrase>Illustratie aaneengeschakelde schijven</phrase>
      </textobject>
    </mediaobject>

    <procedure>
      <title>Ongeformatteerde ATA-schijven aaneenschakelen</title>

      <step>
	<para>Laad de module <filename>geom_stripe.ko</filename>:</para>

	<screen>&prompt.root; <userinput>kldload geom_stripe</userinput></screen>
      </step>

      <step>
	<para>Zorg ervoor dat er een koppelpunt beschikbaar is.  Als dit
	  volume een rootpartitie wordt, gebruikt dan tijdelijk een
	  ander koppelpunt zoals <filename>/mnt</filename>:</para>

	<screen>&prompt.root; <userinput>mkdir /mnt</userinput></screen>
      </step>

      <step>
	<para>Stel de apparaatnamen voor de schijven vast die aaneen
	  worden geschakeld en maak het nieuwe apparaat aan.  Om twee
	  ongebruikte, ongepartitioneerde <acronym>ATA</acronym>
	  schijven aaneen te schakelen (<filename>/dev/ad2</filename>
	  en <filename>/dev/ad3</filename>):</para>

	<screen>&prompt.root; <userinput>gstripe label -v st0 /dev/ad2 /dev/ad3</userinput>
Metadata value stored on /dev/ad2.
Metadata value stored on /dev/ad3.
Done.</screen>
      </step>

      <step>
	<para>Schrijf een standaard label naar de nieuwe partitie, ook
	  wel bekend als een partitietabel en installeer de standaard
	  opstart code:</para>

	<screen>&prompt.root; <userinput>bsdlabel -wB /dev/stripe/st0</userinput></screen>
      </step>

      <step>
	<para>Dit proces hoort twee nieuwe apparaten gemaakt te hebben
	  in de map <filename>/dev/stripe</filename>
	  naast het apparaat <filename>st0</filename>, te weten
	  <filename>st0a</filename> en
	  <filename>st0c</filename>.  Vanaf nu kan er een
	  bestandssysteem op <filename>st0a</filename> worden
	  gezet met behulp van de <command>newfs</command> applicatie:</para>

	<screen>&prompt.root; <userinput>newfs -U /dev/stripe/st0a</userinput></screen>

	<para>Na het uitvoeren van het bovenstaande commando rollen er
	  veel getallen over het scherm en na een aantal seconden is
	  het proces afgerond.  Het volume is gereed en klaar om
	  aangekoppeld te worden.</para>
      </step>
    </procedure>

    <para>Om de nieuwe aaneengeschakelde schijf handmatig te koppelen
      moet het volgende gedaan worden:</para>

    <screen>&prompt.root; <userinput>mount /dev/stripe/st0a /mnt</userinput></screen>

    <para>Om dit aaneengeschakelde bestandssysteem automatisch aan te
      koppelen bij het opstarten wordt de volume-informatie in
      <filename>/etc/fstab</filename> gezet.  Voor dit doel wordt een
      permanent koppelpunt, genaamd <filename>stripe</filename>, aangemaakt:</para>

    <screen>&prompt.root; <userinput>mkdir /stripe</userinput>
&prompt.root; <userinput>echo "/dev/stripe/st0a /mnt ufs rw 2 2" \</userinput>
      <userinput>&gt;&gt; /etc/fstab</userinput></screen>

    <para>Laadt de module <filename>geom_stripe.ko</filename> ook
      automatisch bij het initialiseren van een systeem door de volgende
      regel toe te voegen aan <filename>/boot/loader.conf</filename>:</para>

    <screen>&prompt.root; <userinput>echo 'geom_stripe_load="YES"' &gt;&gt; /boot/loader.conf</userinput></screen>
  </sect1>

  <sect1 xml:id="GEOM-mirror">
    <title>RAID1 - spiegelen</title>

    <indexterm><primary>GEOM</primary></indexterm>

    <indexterm><primary>schijf spiegelen</primary></indexterm>

    <indexterm><primary>RAID1</primary></indexterm>

    <para><acronym>RAID1</acronym>, of <firstterm>spiegelen</firstterm>, is de
      techniek om dezelfde gegevens naar meer dan één schijf te schrijven.
      Spiegels worden normaliter gebruikt om tegen gegevensverlies te beschermen
      indien een schijf kapot gaat.  Elke schijf in een spiegel bevat een
      identieke kopie van de gegevens.  Wanneer een individuele schijf het
      begeeft, blijft de spiegel functioneren, en levert het gegevens van de
      schijven die nog wel functioneren.  De computer blijft draaien en de
      beheerder heeft tijd om de kapotte schijf te vervangen zonder onderbreking
      voor de gebruikers.</para>

    <para>Twee veelvoorkomende situaties worden in deze voorbeelden getoond.
      Het eerste is het maken van een spiegel van twee nieuwe schijven en het
      als vervanging voor een bestaande enkele schijf te gebruiken.  Het tweede
      voorbeeld maakt een spiegel op een enkele nieuwe schijf aan, kopieert de
      gegevens van de oude schijf er naar toe, en plaatst daarna de oude schijf
      in de spiegel.  Hoewel deze procedure iets moeilijker is, is er maar één
      nieuwe schijf nodig.</para>

    <para>Traditioneel zijn de twee schijven in een spiegel van hetzelfde model
      en hebben ze dezelfde capaciteit, maar &man.gmirror.8; verplicht dit niet.
      Spiegels die met ongelijke schijven zijn gemaakt zullen de capaciteit van
      de kleinste schijf in de spiegel aannemen.  Extra schijfruimte op grotere
      schijven zal ongebruikt blijven.  Schijven die later in de spiegel worden
      geplaatst moeten tenminste evenveel capaciteit hebben als de kleinste
      schijf die reeds in de spiegel zit.</para>

    <warning>
      <para>De procedures voor het spiegelen die hier getoond worden zijn
	niet-destructief, maar maak zoals bij elke grote schijfoperatie eerst
	een volledige back-up.</para>
    </warning>

    <sect2 xml:id="GEOM-mirror-metadata">
      <title>Kwesties met meta-gegevens</title>

      <para>Veel schijfsystemen slaan meta-gegevens op aan het einde van elke
	schijf.  Oude meta-gegevens dienen gewist te worden voordat de schijf
	herbruikt wordt voor een spiegel.  De meeste problemen worden
	veroorzaakt door twee soorten van achtergebleven meta-gegevens:
	GPT-partitietabellen en oude meta-gegevens van &man.gmirror.8; van een
	vorige spiegel.</para>

      <para>GPT-meta-gegevens kunnen gewist worden met &man.gpart.8;.  Dit
	voorbeeld wist zowel de primaire als de back-up GPT-partitietabellen van
	schijf <filename>ada8</filename>:</para>

      <screen>&prompt.root; <userinput>gpart destroy -F ada8</userinput></screen>
      <para>&man.gmirror.8; kan in één stap een schijf uit een actieve spiegel
	halen en de meta-gegevens wissen.  Hier wordt de voorbeeldschijf
	<filename>ada8</filename> uit de actieve spiegel
	<filename>gm4</filename> gehaald:</para>

      <screen>&prompt.root; <userinput>gmirror remove gm4 ada8</userinput></screen>

      <para>Gebruik, als de spiegel niet draait maar er nog oude meta-gegevens
	van de spiegel op de schijf staan, <command>gmirror clear</command> om
	deze te verwijderen:</para>

      <screen>&prompt.root; <userinput>gmirror clear ada8</userinput></screen>

      <para>&man.gmirror.8; slaat één blok aan meta-gegevens aan het einde van
	de schijf op.  Omdat GPT-partitieschema's ook meta-gegevens aan het
	einde van de schijf opslaan, wordt het spiegelen van volledige
	GPT-schijven met &man.gmirror.8; niet aangeraden.  Hier wordt
	MBR-partitionering gebruikt omdat het alleen een partitietabel aan het
	begin van de schijf opslaat en niet conflicteert met
	&man.gmirror.8;.</para>
    </sect2>

    <sect2>
      <title>Een spiegel met twee nieuwe schijven maken</title>

      <para>In dit voorbeeld is &os; reeds op een enkele schijf
	<filename>ada0</filename> geïnstalleerd.  Twee nieuwe schijven,
	<filename>ada1</filename> en <filename>ada2</filename> zijn met
	het systeem verbonden.  Er zal een nieuwe spiegel op deze twee schijven
	aangemaakt worden die de oude enkele schijf zal vervangen.</para>

      <para>&man.gmirror.8; heeft een kernelmodule
	<filename>geom_mirror.ko</filename> nodig, ingebouwd in de kernel of
	geladen tijdens het opstarten of draaien.  Laadt nu handmatig de
	kernelmodule:</para>

      <screen>&prompt.root; <userinput>gmirror load</userinput></screen>

      <para>Maak de spiegel aan met de twee nieuwe schijven:</para>

      <screen>&prompt.root; <userinput>gmirror label -v gm0 /dev/ada1 /dev/ada2</userinput></screen>

      <para><filename>gm0</filename> is een door de gebruiker gekozen
	apparaatnaam die aan de nieuwe spiegel wordt toegekend.  Nadat de
	spiegel is gestart, zal deze apparaatnaam verschijnen in de map
	<filename>/dev/mirror/</filename>.</para>

      <para>Nu kunnen er met &man.gpart.8; MBR- en bsdlabel-partitietabellen op
	de spiegel worden aangemaakt.  Hier wordt er een traditioneel schema
	van een gesplitst bestandssysteem getoond, met partities voor
	<filename>/</filename>, swap, <filename>/var</filename>,
	<filename>/tmp</filename> en <filename>/usr</filename>.  Dit werkt ook
	voor een enkel bestandssysteem met enkel <filename>/</filename> en
	een wisselpartitie.</para>

      <para>Partities op de spiegel hoeven niet dezelfde grootte te hebben als
	die op de bestaande schijf, maar moeten groot genoeg zijn om alle
	gegevens die reeds op <filename>ada0</filename> staan te kunnen
	bevatten.</para>

      <screen>&prompt.root; <userinput>gpart create -s MBR mirror/gm0</userinput>
&prompt.root; <userinput>gpart add -t freebsd -a 4k mirror/gm0</userinput>
&prompt.root; <userinput>gpart show mirror/gm0</userinput>
=&gt;       63  156301423  mirror/gm0  MBR  (74G)
         63         63                    - free -  (31k)
        126  156301299                 1  freebsd  (74G)
  156301425         61                    - free -  (30k)</screen>

      <screen>&prompt.root; <userinput>gpart create -s BSD mirror/gm0s1</userinput>
&prompt.root; <userinput>gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1</userinput>
&prompt.root; <userinput>gpart add -t freebsd-swap -a 4k -s 4g mirror/gm0s1</userinput>
&prompt.root; <userinput>gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1</userinput>
&prompt.root; <userinput>gpart add -t freebsd-ufs  -a 4k -s 1g mirror/gm0s1</userinput>
&prompt.root; <userinput>gpart add -t freebsd-ufs  -a 4k       mirror/gm0s1</userinput>
&prompt.root; <userinput>gpart show mirror/gm0s1</userinput>
=&gt;        0  156301299  mirror/gm0s1  BSD  (74G)
          0          2                      - free -  (1.0k)
          2    4194304                   1  freebsd-ufs  (2.0G)
    4194306    8388608                   2  freebsd-swap  (4.0G)
   12582914    4194304                   4  freebsd-ufs  (2.0G)
   16777218    2097152                   5  freebsd-ufs  (1.0G)
   18874370  137426928                   6  freebsd-ufs  (65G)
  156301298          1                      - free -  (512B)</screen>

      <para>Maak de spiegel opstartbaar door opstartcode in het MBR en bsdlabel
	te installeren en de actieve slice in te stellen:</para>

      <screen>&prompt.root; <userinput>gpart bootcode -b /boot/mbr mirror/gm0</userinput>
&prompt.root; <userinput>gpart set -a active -i 1 mirror/gm0</userinput>
&prompt.root; <userinput>gpart bootcode -b /boot/boot mirror/gm0s1</userinput></screen>

      <para>Formatteer de bestandssystemen op de nieuwe spiegel en zet daarbij
	soft-updates aan.</para>

      <screen>&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1a</userinput>
&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1d</userinput>
&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1e</userinput>
&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1f</userinput></screen>

      <para>Bestandssystemen van de originele schijf
	(<filename>ada0</filename>) kunnen nu met &man.dump.8; en
	&man.restore.8; naar de spiegel gekopieerd worden:</para>

      <screen>&prompt.root; <userinput>mount /dev/mirror/gm0s1a /mnt</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - / | (cd /mnt &amp;&amp; restore -rf -)</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1d /mnt/var</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1e /mnt/tmp</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1f /mnt/usr</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - /var | (cd /mnt/var &amp;&amp; restore -rf -)</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - /tmp | (cd /mnt/tmp &amp;&amp; restore -rf -)</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr &amp;&amp; restore -rf -)</userinput></screen>

      <para><filename>/mnt/etc/fstab</filename> moet bewerkt worden om naar de
	nieuwe bestandssystemen op de spiegel te wijzen:</para>

      <programlisting># Device		Mountpoint	FStype	Options	Dump	Pass#
/dev/mirror/gm0s1a	/		ufs	rw	1	1
/dev/mirror/gm0s1b	none		swap	sw	0	0
/dev/mirror/gm0s1d	/var		ufs	rw	2	2
/dev/mirror/gm0s1e	/tmp		ufs	rw	2	2
/dev/mirror/gm0s1f	/usr		ufs	rw	2	2</programlisting>

      <para>Als de kernelmodule &man.gmirror.8; niet in de kernel is ingebouwd,
	wordt <filename>/mnt/boot/loader.conf</filename> bewerkt om de module
	tijdens het opstarten te laden:</para>

      <programlisting>geom_mirror_load="YES"</programlisting>

      <para>Herstart het systeem om de nieuwe spiegel te testen en te verifiëren
	dat alle gegevens zijn gekopieerd.  Het BIOS zal de spiegel als twee
	individuele schijven zien in plaats van als een spiegel.  Omdat de
	schijven identiek zijn, maakt het niet uit vanaf welke schijf wordt
	opgestart.</para>

      <para>Bekijk de sectie <link linkend="gmirror-troubleshooting">Problemen
	  oplossen</link> als er problemen zijn tijdens het opstarten.  Door de
	originele <filename>ada0</filename> uit te schakelen en los te
	koppelen kan het als offline back-up bewaard worden.</para>

      <para>Tijdens het gebruik zal de spiegel zich net zoals de originele
	enkele schijf gedragen.</para>
    </sect2>

    <sect2>
      <title>Een spiegel met een bestaande schijf aanmaken</title>

      <para>In dit voorbeeld is &os; reeds geïnstalleerd op een enkele schijf,
	<filename>ada0</filename>.  Een nieuwe schijf,
	<filename>ada1</filename>, is met het systeem verbonden.  Er zal
	een spiegel van één schijf worden aangemaakt op de nieuwe schijf, het
	bestaande systeem zal ernaar worden gekopieerd, en daarna zal de oude
	schijf in de spiegel worden geplaatst.  Deze enigszins complexe
	procedure is nodig omdat &man.gmirror.8; een blok van 512 bytes aan
	meta-gegevens aan het einde van elke schijf moet plaatsen en de
	bestaande <filename>ada0</filename> meestal alle ruimte reeds heeft
	toegewezen.</para>

      <para>Laadt de kernelmodule &man.gmirror.8;:</para>

      <screen>&prompt.root; <userinput>gmirror load</userinput></screen>

      <para>Controleer de mediagrootte van de originele schijf met
	&man.diskinfo.8;:</para>

      <screen>&prompt.root; <userinput>diskinfo -v ada0 | head -n3</userinput>
/dev/ada0
	512             # sectorsize
	1000204821504   # mediasize in bytes (931G)</screen>

      <para>Maak een spiegel aan op de nieuwe schijf.  Om er zeker van te zijn
	dat de capaciteit van de spiegel niet groter is dan die van de originele
	schijf, wordt &man.gnop.8; gebruikt om een nepschijf van precies
	dezelfde grootte aan te maken.  Deze schijf slaat geen gegevens op, maar
	wordt alleen gebruikt om de grootte van de spiegel te begrenzen.
	Wanneer &man.gmirror.8; de spiegel aanmaakt, zal het de capaciteit
	beperken tot de grootte van <filename>gzero.nop</filename> zelfs
	als de nieuwe schijf (<filename>ada1</filename>) meer ruimte heeft.
	Merk op dat de <replaceable>1000204821504</replaceable> op de tweede
	regel gelijk moet zijn aan de mediagrootte van
	<filename>ada0</filename> zoals hierboven door &man.diskinfo.8; is
	getoond.</para>

      <screen>&prompt.root; <userinput>geom zero load</userinput>
&prompt.root; <userinput>gnop create -s 1000204821504 gzero</userinput>
&prompt.root; <userinput>gmirror label -v gm0 gzero.nop ada1</userinput>
&prompt.root; <userinput>gmirror forget gm0</userinput></screen>

      <para><filename>gzero.nop</filename> slaat geen gegevens op, dus ziet
	de spiegel het niet als verbonden.  De spiegel wordt verteld om
	componenten die niet verbonden zijn te <quote>vergeten</quote>, waarbij
	referenties naar <filename>gzero.nop</filename> worden verwijderd.
	Het resultaat is een spiegelapparaat dat slechts één enkele schijf,
	<filename>ada1</filename>, bevat.</para>

      <para>Bekijk de partitietabel van <filename>ada0</filename> nadat
	<filename>gm0</filename> is aangemaakt.</para>

      <para>Deze uitvoer komt van een schijf van 1&nbsp;TB.  Als er wat
	niet-toegewezen ruimte aanwezig is aan het einde van de schijf, kan de
	inhoud direct van <filename>ada0</filename> naar de nieuwe spiegel
	worden gekopieerd.</para>

      <para>Als de uitvoer echter toont dat alle ruimte op de schijf is
	toegewezen zoals in de volgende lijst, is er geen ruimte over voor de
	512 bytes aan meta-gegevens van &man.gmirror.8; aan het einde van de
	schijf.</para>

      <screen>&prompt.root; <userinput>gpart show ada0</userinput>
=&gt;        63  1953525105        ada0  MBR  (931G)
          63  1953525105           1  freebsd  [active]  (931G)</screen>

      <para>In dit geval moet de partitietabel worden bewerkt om de capaciteit
	op <filename>mirror/gm0</filename> met één sector te verminderen.
	De procedure hiervoor wordt later uitgelegd.</para>

      <para>In beide gevallen dienen de partitietabellen op de primaire schijf
	eerst gekopieerd te worden.  Dit kan gedaan worden met de subcommando's
	<command>backup</command> en <command>restore</command> van
	&man.gpart.8;.</para>

      <screen>&prompt.root; <userinput>gpart backup ada0 &gt; table.ada0</userinput>
&prompt.root; <userinput>gpart backup ada0s1 &gt; table.ada0s1</userinput></screen>

      <para>Deze subcommando's maken twee bestanden aan,
	<filename>table.ada0</filename> en <filename>table.ada0s1</filename>.
	Dit voorbeeld komt van een schijf van 1&nbsp;TB af:</para>

      <screen>&prompt.root; <userinput>cat table.ada0</userinput>
MBR 4
1 freebsd         63 1953525105   [active]</screen>

      <screen>&prompt.root; <userinput>cat table.ada0s1</userinput>
BSD 8
1  freebsd-ufs          0    4194304
2 freebsd-swap    4194304   33554432
4  freebsd-ufs   37748736   50331648
5  freebsd-ufs   88080384   41943040
6  freebsd-ufs  130023424  838860800
7  freebsd-ufs  968884224  984640881</screen>

      <para>Als de gehele schijf was gebruikt in de uitvoer van &man.gpart.8;
	<command>show</command>, dan moet de capaciteit in deze partitietabellen
	met één sector verminderd worden.  Bewerk de twee bestanden zodat de
	grootte van zowel de slice als de laatste partitie met één verminderd
	wordt.  Dit zijn de laatste getallen in elke lijst.</para>

      <screen>&prompt.root; <userinput>cat table.ada0</userinput>
MBR 4
1 freebsd         63 <emphasis>1953525104</emphasis>   [active]</screen>

      <screen>&prompt.root; <userinput>cat table.ada0s1</userinput>
BSD 8
1  freebsd-ufs          0    4194304
2 freebsd-swap    4194304   33554432
4  freebsd-ufs   37748736   50331648
5  freebsd-ufs   88080384   41943040
6  freebsd-ufs  130023424  838860800
7  freebsd-ufs  968884224  <emphasis>984640880</emphasis></screen>

      <para>Als er tenminste één sector aan het einde van de schijf niet was
	toegewezen, kunnen deze twee bestanden ongewijzigd gebruikt worden.</para>
      <para>Herstel nu de partitietabel naar
	<filename>mirror/gm0</filename>.</para>

      <screen>&prompt.root; <userinput>gpart restore mirror/gm0 &lt; table.ada0</userinput>
&prompt.root; <userinput>gpart restore mirror/gm0s1 &lt; table.ada0s1</userinput></screen>

      <para>Controleer de partitietabel met &man.gpart.8;
	<command>show</command>.  Dit voorbeeld heeft
	<filename>gm0s1a</filename> voor <filename>/</filename>,
	<filename>gm0s1d</filename> voor <filename>/var</filename>,
	<filename>gm0s1e</filename> voor <filename>/usr</filename>,
	<filename>gm0s1f</filename> voor <filename>/data1</filename> en
	<filename>gm0s1g</filename> voor <filename>/data2</filename>.</para>

      <screen>&prompt.root; <userinput>gpart show mirror/gm0</userinput>
=&gt;        63  1953525104  mirror/gm0  MBR  (931G)
          63  1953525042           1  freebsd  [active]  (931G)
  1953525105          62              - free -  (31k)

&prompt.root; <userinput>gpart show mirror/gm0s1</userinput>
=&gt;         0  1953525042  mirror/gm0s1  BSD  (931G)
           0     2097152             1  freebsd-ufs  (1.0G)
     2097152    16777216             2  freebsd-swap  (8.0G)
    18874368    41943040             4  freebsd-ufs  (20G)
    60817408    20971520             5  freebsd-ufs  (10G)
    81788928   629145600             6  freebsd-ufs  (300G)
   710934528  1242590514             7  freebsd-ufs  (592G)
  1953525042          63                - free -  (31k)</screen>

      <para>Zowel de slice als de laatste partitie dienen wat vrije ruimte aan
	het einde van elke schijf te hebben.</para>

      <para>Maak bestandssystemen aan op deze nieuwe partities.  Het aantal
	partities zal variëren, overeenkomend met de partities op de originele
	schijf, <filename>ada0</filename>.</para>

      <screen>&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1a</userinput>
&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1d</userinput>
&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1e</userinput>
&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1f</userinput>
&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1g</userinput></screen>

      <para>Maak de spiegel opstartbaar door opstartcode in het MBR en bsdlabel
	te installeren en de actieve slice in te stellen:</para>

      <screen>&prompt.root; <userinput>gpart bootcode -b /boot/mbr mirror/gm0</userinput>
&prompt.root; <userinput>gpart set -a active -i 1 mirror/gm0</userinput>
&prompt.root; <userinput>gpart bootcode -b /boot/boot mirror/gm0s1</userinput></screen>

      <para>Pas <filename>/etc/fstab</filename> aan zodat het de nieuwe
	partities op de spiegel gebruikt.  Maak eerst een kopie van dit bestand
	als <filename>/etc/fstab.orig</filename>.</para>

      <screen>&prompt.root; <userinput>cp /etc/fstab /etc/fstab.orig</userinput></screen>

      <para>Wijzig <filename>/etc/fstab</filename> door
	<filename>/dev/ada0</filename> door
	<filename>mirror/gm0</filename> te vervangen.</para>

      <programlisting># Device		Mountpoint	FStype	Options	Dump	Pass#
/dev/mirror/gm0s1a	/		ufs	rw	1	1
/dev/mirror/gm0s1b	none		swap	sw	0	0
/dev/mirror/gm0s1d	/var		ufs	rw	2	2
/dev/mirror/gm0s1e	/usr		ufs	rw	2	2
/dev/mirror/gm0s1f	/data1		ufs	rw	2	2
/dev/mirror/gm0s1g	/data2		ufs	rw	2	2</programlisting>

      <para>Als de kernelmodule &man.gmirror.8; niet in de kernel is gebouwd,
	wijzig dan <filename>/boot/loader.conf</filename> om het te
	laden:</para>

      <programlisting>geom_mirror_load="YES"</programlisting>

      <para>Bestandssystemen van de originele schijf kunnen nu met &man.dump.8;
	en &man.restore.8; naar de spiegel gekopieerd worden.  Merk op dat het
	maken van een snapshot voor elk bestandssysteem dat met <command>dump
	  -L</command> gedumpt is even kan duren.</para>

      <screen>&prompt.root; <userinput>mount /dev/mirror/gm0s1a /mnt</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - /    | (cd /mnt &amp;&amp; restore -rf -)</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1d /mnt/var</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1e /mnt/usr</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1f /mnt/data1</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1g /mnt/data2</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr &amp;&amp; restore -rf -)</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - /var | (cd /mnt/var &amp;&amp; restore -rf -)</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - /data1 | (cd /mnt/data1 &amp;&amp; restore -rf -)</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - /data2 | (cd /mnt/data2 &amp;&amp; restore -rf -)</userinput></screen>

      <para>Start het systeem opnieuw op vanaf <filename>ada1</filename>.
	Als alles werkt, zal het systeem opstarten vanaf
	<filename>mirror/gm0</filename>, wat nu dezelfde gegevens bevat die
	<filename>ada0</filename> eerder bevatte.  Zie de sectie <link linkend="gmirror-troubleshooting">Problemen oplossen</link> als er
	problemen zijn met het opstarten.</para>

      <para>Op dit moment bestaat de spiegel nog steeds alleen uit de enkele
	schijf <filename>ada1</filename>.</para>

      <para>Nadat er succesvol van <filename>mirror/gm0</filename> is
	opgestart, is de laatste stap het plaatsen van
	<filename>ada0</filename> in de spiegel.</para>

      <important>
	<para>Als <filename>ada0</filename> in de spiegel wordt geplaatst,
	  zal de vorige inhoud worden overschreven door gegevens in de spiegel.
	  Ben er zeker van dat <filename>mirror/gm0</filename> dezelfde
	  gegevens bevat als <filename>ada0</filename> voordat
	  <filename>ada0</filename> aan de spiegel wordt toegevoegd.  Als
	  er iets mis is met de gegevens die door &man.dump.8; en
	  &man.restore.8; gekopieerd zijn, draai dan
	  <filename>/etc/fstab</filename> terug om de bestandssystemen op
	  <filename>ada0</filename> aan te koppelen, start opnieuw op, en
	  probeer de hele procedure nogmaals.</para>
      </important>

      <screen>&prompt.root; <userinput>gmirror insert gm0 ada0</userinput>
GEOM_MIRROR: Device gm0: rebuilding provider ada0</screen>

      <para>De synchronisatie tussen de twee schijven zal onmiddellijk beginnen.
	&man.gmirror.8; <command>status</command> toont de voortgang.</para>

      <screen>&prompt.root; <userinput>gmirror status</userinput>
      Name    Status  Components
mirror/gm0  DEGRADED  ada1 (ACTIVE)
                      ada0 (SYNCHRONIZING, 64%)</screen>

      <para>Na een tijd zal de synchronisatie voltooid zijn.</para>

      <screen>GEOM_MIRROR: Device gm0: rebuilding provider ada0 finished.
&prompt.root; <userinput>gmirror status</userinput>
      Name    Status  Components
mirror/gm0  COMPLETE  ada1 (ACTIVE)
                      ada0 (ACTIVE)</screen>

      <para><filename>mirror/gm0</filename> bestaat nu uit de twee schijven
	<filename>ada0</filename> en <filename>ada1</filename>, en de
	inhoud wordt automatisch met elkaar gesynchroniseerd.  In het gebruik
	zal <filename>mirror/gm0</filename> zich net zo gedragen als de
	originele enkele schijf.</para>
    </sect2>

    <sect2 xml:id="gmirror-troubleshooting">
      <title>Problemen oplossen</title>

      <sect3>
	<title>Problemen met opstarten</title>

	<sect4>
	  <title>BIOS-instellingen</title>

	  <para>Mogelijk is het nodig om de BIOS-instellingen te wijzigen om
	    van één van de nieuwe gespiegelde schijven op te starten.  Beide
	    spiegelschijven kunnen gebruikt worden voor het opstarten.  Als
	    componenten van een spiegel bevatten ze identieke gegevens.</para>
	</sect4>

	<sect4>
	  <title>Opstartproblemen</title>

	  <para>Als het opstarten met dit bericht stopt, is er iets mis met het
	    spiegelapparaat:</para>

	  <screen>Mounting from ufs:/dev/mirror/gm0s1a failed with error 19.

Loader variables:
  vfs.root.mountfrom=ufs:/dev/mirror/gm0s1a
  vfs.root.mountfrom.options=rw

Manual root filesystem specification:
  &lt;fstype&gt;:&lt;device&gt; [options]
      Mount &lt;device&gt; using filesystem &lt;fstype&gt;
      and with the specified (optional) option list.

    eg. ufs:/dev/da0s1a
        zfs:tank
        cd9660:/dev/acd0 ro
          (which is equivalent to: mount -t cd9660 -o ro /dev/acd0 /)

  ?               List valid disk boot devices
  .               Yield 1 second (for background tasks)
  &lt;empty line&gt;    Abort manual input

mountroot&gt;</screen>

	  <para>Het vergeten om de module <filename>geom_mirror</filename> in
	    <filename>/boot/loader.conf</filename> te laden kan dit probleem
	    veroorzaken.  Start op vanaf een &os;-9 of nieuwere CD of USB-stick
	    en kies <literal>Shell</literal> op de eerste prompt om dit op te
	    lossen.  Laadt daarna de spiegelmodule en en koppel het
	    spiegelapparaat aan:</para>

	  <screen>&prompt.root; <userinput>gmirror load</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1a /mnt</userinput></screen>

	  <para>Voeg een regel om de spiegelmodule te laden toe aan
	    <filename>/mnt/boot/loader.conf</filename>:</para>

	  <programlisting>geom_mirror_load="YES"</programlisting>

	  <para>Sla het bestand op en start opnieuw op.</para>

	  <para>Andere problemen die <literal>error 19</literal> veroorzaken
	    zijn lastiger om op te lossen.  Typ
	    <literal>ufs:/dev/ada0s1a</literal> in op de prompt.  Hoewel het
	    systeem van <filename>ada0</filename> zou moeten opstarten,
	    verschijnt er een andere prompt om een shell uit te kiezen omdat
	    <filename>/etc/fstab</filename> onjuist is.  Druk op de prompt op
	    de Enter-toets.  Draai de wijzigingen tot nu toe terug door
	    <filename>/etc/fstab</filename> terug te draaien, waardoor de
	    bestandssystemen vanaf de originele schijf (
	    <filename>ada0</filename>) in plaats vanaf de spiegel worden
	    aangekoppeld.  Start het systeem opnieuw op en probeer de procedure
	    nogmaals.</para>

	  <screen>Enter full pathname of shell or RETURN for /bin/sh:
&prompt.root; <userinput>cp /etc/fstab.orig /etc/fstab</userinput>
&prompt.root; <userinput>reboot</userinput></screen>
	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Herstellen van falende schijven</title>

      <para>Het mooie aan het spiegelen van schijven is dat een individuele
	schijf kan falen zonder dat de spiegel gegevens verliest.</para>

      <para><filename>ada0</filename> is één van de twee schijven die de
	spiegel in het vorige voorbeeld vormen.  Als
	<filename>ada0</filename> faalt zal de spiegel blijven werken en
	gegevens leveren van de overgebleven werkende schijf,
	<filename>ada1</filename>.</para>

      <para>Om de kapotte schijf te vervangen wordt de computer uitgezet en de
	kapotte schijf fysiek vervangen door een nieuwe schijf van gelijke of
	grotere capaciteit.  Fabrikanten passen enigszins willekeurige waarden
	toe om schijven in gigabytes aan te duiden, de enige manier om er echt
	zeker van te zijn is om de totale hoeveelheid aan sectors aangegeven
	door <command>diskinfo -v</command> te vergelijken.  Een schijf met een
	grotere capaciteit dan in de spiegel zal werken, alhoewel de extra
	ruimte op de nieuwe schijf niet gebruikt zal worden.</para>

      <para>Nadat de computer opnieuw is aangezet, zal de spiegel in een
	<quote>degraded</quote> toestand met slechts één schijf draaien.  De
	spiegel wordt verteld om schijven die momenteel niet verbonden zijn te
	vergeten:</para>

      <screen>&prompt.root; <userinput>gmirror forget gm0</userinput></screen>

      <para>Alle oude meta-gegevens zouden <link linkend="GEOM-mirror-metadata">van de vervangende schijf gewist</link>
	moeten zijn.  Daarna wordt de schijf, in dit voorbeeld
	<filename>ada4</filename>, in de spiegel geplaatst:</para>

      <screen>&prompt.root; <userinput>gmirror insert gm0 /dev/ada4</userinput></screen>

      <para>De hersynchronisatie begint wanneer de nieuwe schijf in de spiegel
	wordt geplaatst.  Het kopiëren van gegevens van de spiegel naar een
	nieuwe schijf kan een tijd duren.  De prestaties van de spiegel zullen
	tijdens het kopiëren sterk verminderd zijn, dus is het het beste om
	nieuwe schijven in te voegen wanneer de vraag op de computer laag
	is.</para>

      <para>De voortgang kan met <command>gmirror status</command> gevolgd
	worden, wat de schijven die gesynchroniseerd en het percentage van de
	voltooiing laat zien.  Tijdens de hersynchronisatie zal de status
	<computeroutput>DEGRADED</computeroutput> zijn en veranderen in
	<computeroutput>COMPLETE</computeroutput> wanneer het proces is
	voltooid.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="GEOM-raid3">
    <info><title><acronym>RAID</acronym>3 - Striping op byte-niveau met toegewijde
      pariteit</title>
      <authorgroup>
	<author><personname><firstname>Mark</firstname><surname>Gladman</surname></personname><contrib>Geschreven door </contrib></author>
	<author><personname><firstname>Daniel</firstname><surname>Gerzo</surname></personname></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Gebaseerd op documentatie van </contrib></author>
	<author><personname><firstname>Murray</firstname><surname>Stokely</surname></personname></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>GEOM</primary></indexterm>

    <indexterm><primary>RAID3</primary></indexterm>

    <para><acronym>RAID</acronym>3 is een methode om verschillende schijven te
      combineren in een enkel volume met een toegewijde schijf voor de pariteit.
      In een <acronym>RAID</acronym>3-systeem worden de gegevens opgesplitst in
      een aantal bytes die over alle schijven in de rij worden geschreven,
      behalve naar één schijf die als een toegewijde schijf voor
      de pariteit dient.  Dit betekent dat het lezen van 1024&nbsp;kB van een
      <acronym>RAID</acronym>3-implementatie alle schijven in de rij zal
      benaderen.  De prestatie kan worden verhoogd door meerdere
      schijfcontrollers te gebruiken.  De <acronym>RAID</acronym>3-rij biedt een
      fouttolerantie van 1 schijf, terwijl het een capaciteit van 1 - 1/n maal
      de totale capaciteit biedt van alle schijven in de rij, waarbij n het
      aantal harde schijven in de rij is.  Zulke configuraties zijn meestal
      geschikt voor het opslaan van gegevens van grotere groottes, bijvoorbeeld
      multimedia-bestanden.</para>

    <para>Er zijn minstens 3 fysieke harde schijven nodig om een
      <acronym>RAID</acronym>3-rij te bouwen.  Elke schijf moet van dezelfde
      grootte zijn, aangezien I/O-verzoeken worden verweven om parallel naar
      meerdere schijven te lezen of schrijven.  Bovendien moet vanwege de aard
      van <acronym>RAID</acronym>3 het aantal schijven gelijk zijn aan 3, 5, 9,
      17, enzovoorts (dus 2^n + 1).</para>

    <sect2>
      <title>Een toegewijde <acronym>RAID</acronym>3-rij aanmaken.</title>

      <para>In &os; is ondersteuning voor <acronym>RAID</acronym>3
	geïmplementeerd in de <acronym>GEOM</acronym>-klasse
	&man.graid3.8;.  Voor het aanmaken van een toegewijde
	<acronym>RAID</acronym>3-rij op &os; zijn deze stappen nodig.</para>

      <note>
	<para>Hoewel het theoretisch mogelijk is om op &os; van een
	  <acronym>RAID</acronym>3-rij op te starten, is deze configuratie
	  ongebruikelijk en niet aangeraden.</para>
      </note>

      <procedure>
	<step>
	  <para>Laad ten eerste de kernelmodule
	    <filename>geom_raid3.ko</filename> door de volgende opdracht uit te
	    voeren:</para>

	  <screen>&prompt.root; <userinput>graid3 load</userinput></screen>

	  <para>Het is ook mogelijk om handmatig de module
	    <filename>geom_raid3.ko</filename> te laden:</para>

	  <screen>&prompt.root; <userinput>kldload geom_raid3.ko</userinput></screen>
	</step>

	<step>
	  <para>Zorg ervoor dat er een geschikt aankoppelpunt bestaat of maak
	    het aan:</para>

	  <screen>&prompt.root; <userinput>mkdir /multimedia/</userinput></screen>
	</step>

	<step>
	  <para>Bepaal de apparaatnamen voor de schijven die aan de rij worden
	    toegevoegd en maak het nieuwe <acronym>RAID</acronym>3-apparaat
	    aan.  Het laatst vermelde apparaat zal dienst doen als de toegewijde
	    schijf voor de pariteit.  Dit voorbeeld gebruikt drie
	    ongepartitioneerde <acronym>ATA</acronym>-schijven:
	    <filename>ada1</filename> en
	    <filename>ada2</filename> voor
	    gegevens en <filename>ada3</filename>
	    voor pariteit.</para>

	  <screen>&prompt.root; <userinput>graid3 label -v gr0 /dev/ada1 /dev/ada2 /dev/ada3</userinput>
Metadata value stored on /dev/ada1.
Metadata value stored on /dev/ada2.
Metadata value stored on /dev/ada3.
Done.</screen>
	</step>

	<step>
	  <para>Partitioneer het nieuw aangemaakte apparaat
	    <filename>gr0</filename> en zet er een UFS-bestandssysteem
	    op:</para>

	  <screen>&prompt.root; <userinput>gpart create -s GPT /dev/raid3/gr0</userinput>
&prompt.root; <userinput>gpart add -t freebsd-ufs /dev/raid3/gr0</userinput>
&prompt.root; <userinput>newfs -j /dev/raid3/gr0p1</userinput></screen>

	  <para>Vele getallen zullen over het scherm lopen, en na wat tijd zal
	    het proces voltooid zijn.  Het volume is aangemaakt en is klaar om
	    aangekoppeld te worden.</para>
	</step>

	<step>
	  <para>De laatste stap is het aankoppelen van het
	    bestandssysteem:</para>

	  <screen>&prompt.root; <userinput>mount /dev/raid3/gr0p1 /multimedia/</userinput></screen>

	  <para>De <acronym>RAID</acronym>3-rij is nu klaar voor gebruik.</para>
	</step>
      </procedure>

      <para>Aanvullende configuratie is nodig om de bovenstaande opstelling te
	behouden tussen het opnieuw starten van het systeem.</para>

      <procedure>
	<step>
	  <para>De module <filename>geom_raid3.ko</filename> moet geladen zijn
	    voordat de rij kan worden aangekoppeld.  Voeg de volgende regel toe
	    aan <filename>/boot/loader.conf</filename> om de kernelmodule
	    automatisch tijdens de initialisatie van het systeem te
	    laden:</para>

	  <programlisting>geom_raid3_load="YES"</programlisting>
	</step>

	<step>
	  <para>De volgende volume-informatie moet aan het bestand
	    <filename>/etc/fstab</filename> worden toegevoegd om het
	    bestandssysteem van de rij automatisch aan de koppelen tijdens het
	    opstarten van het systeem:</para>

	  <programlisting>/dev/raid3/gr0p1	/multimedia	ufs	rw	2	2</programlisting>
	</step>
      </procedure>
    </sect2>
  </sect1>

  <sect1 xml:id="geom-ggate">
    <title>GEOM Gate netwerk apparaten</title>

    <para>GEOM ondersteund het op afstand gebruiken van apparaten, zoals
      schijven, CD-ROMs, bestanden, etcetera door het gebruik van de
      gate-applicaties.  Dit is vergelijkbaar met <acronym>NFS</acronym>.</para>

    <para>Om te beginnen moet er een exports bestand gemaakt worden.
      Dit bestand specificeert wie de geëxporteerde bron mag
      benaderen en welke rechten er op dat moment verleend worden.
      Bijvoorbeeld om de vierde slice te exporteren van de eerste
      <acronym>SCSI</acronym> schijf, moet het volgende in
      <filename>/etc/gg.exports</filename> gezet worden:</para>

    <programlisting>192.168.1.0/24 RW /dev/da0s4d</programlisting>

    <para>Dit staat alle machines in het privé netwerk toe om het
      bestandssysteem op <filename>da0s4d</filename> te benaderen.</para>

    <para>Om dit apparaat te kunnen exporteren is het van belang dat de
      schijf nog niet gekoppeld is en moet de &man.ggated.8; dienst
      gestart worden.</para>

    <screen>&prompt.root; <userinput>ggated</userinput></screen>

    <para>Om vervolgens het apparaat aan een client machine te koppelen
      moet het volgende gedaan worden:</para>

    <screen>&prompt.root; <userinput>ggatec create -o rw 192.168.1.1 /dev/da0s4d</userinput>
ggate0
&prompt.root; <userinput>mount /dev/ggate0 /mnt</userinput></screen>

    <para>Vanaf dit moment kan de schijf benaderd worden via het
      koppelpunt <filename>/mnt</filename>.</para>

    <note>
      <para>Let op, dit mislukt als de schijf reeds gekoppeld is op
	de server machine of als deze reeds gekoppeld is aan een andere
	machine op het netwerk.</para>
    </note>

    <para>Zodra het apparaat niet langer nodig is, kan het veilig
      ontkoppeld worden met behulp van &man.umount.8; net zoals met
      elke andere schijf.</para>
  </sect1>

  <sect1 xml:id="geom-glabels">
    <title>Het labelen van schijven</title>

    <indexterm><primary>GEOM</primary></indexterm>

    <indexterm><primary>Disk Labels</primary></indexterm>

    <para>Tijdens het initialiseren van het systeem zal de &os; kernel
      apparaatknooppunten creëren nadat het een apparaat gevonden
      heeft.  Deze manier om te zoeken naar apparaten levert wat
      problemen op bijvoorbeeld wanneer er een nieuwe schijf wordt
      toegevoegd via <acronym>USB</acronym>.  Het is hoogst
      waarschijnlijk dat een flash apparaat een apparaatknooppunt
      krijgt van <filename>da0</filename>, waarna de originele
      <filename>da0</filename> op schuift naar
      <filename>da1</filename>.  Dit levert problemen op als
      bestandssystemen worden gekoppeld als ze gedefinieerd zijn in
      <filename>/etc/fstab</filename>, dit kan zelfs ertoe leiden dat
      het systeem niet opstart.</para>

    <para>Een mogelijke oplossing hiervoor is om de
      <acronym>SCSI</acronym> schijven een vaste plek te geven op
      een bepaalde volgorde, zodat zodra er een nieuwe schijf
      geplaatst wordt, deze een ongebruikt apparaatknooppunt
      toegewezen krijgt.  Maar wat als er <acronym>USB</acronym>
      apparaten zijn die de primaire <acronym>SCSI</acronym> schijf
      vervangt?  Dit gebeurd omdat <acronym>USB</acronym> apparaten
      meestal eerder gevonden worden dan een <acronym>SCSI</acronym>
      kaart.  Een oplossing hiervoor is om de apparaten pas toe te
      voegen als het systeem reeds gestart is, een andere methode kan
      zijn om alleen een enkele <acronym>ATA</acronym> schijf te
      koppelen en nooit <acronym>SCSI</acronym> schijven door middel
      van <filename>/etc/fstab</filename>.</para>

    <para>Maar er is een betere oplossing beschikbaar.  Door het gebruik
      van <command>glabel</command> kunnen beheerders en gebruikers een
      label toevoegen aan een schijf, en deze labels gebruiken in
      <filename>/etc/fstab</filename>.  Omdat <command>glabel</command>
      het label bewaard in de laatste sector van de schijf, kan het
      label bewaard blijven ook na een reboot en kan het
      bestandssysteem altijd gekoppeld worden ongeacht welk
      apparaatknooppunt toegekend is aan het apparaat.</para>

    <note>
      <para>Uiteraard hoeft een label niet permanent te zijn, het
	<command>glabel</command> programma kan zowel tijdelijke als
	permanente labels aanmaken.  Alleen een permanent label blijft
	beschikbaar ook na een reboot.  Zie de &man.glabel.8;
	handleiding voor meer informatie over de verschillen tussen de
	labeltypes.</para>
    </note>

    <sect2>
      <title>Label types en voorbeelden</title>

      <para>Er zijn twee type labels: een generiek label en een
	bestandssysteemlabel.  Labels kunnen permanent of tijdelijk
	zijn.  Permanente labels kunnen met de commando's &man.tunefs.8;
	of &man.newfs.8; aangemaakt worden.  Ze zullen vervolgens worden
	aangemaakt in een submap van
	<filename>/dev</filename>, welke genoemd wordt
	naar het bestandssysteemtype.  Bijvoorbeeld
	<acronym>UFS</acronym>2 labels worden geplaatst in de map
	<filename>/dev/ufs</filename>.  Permanente
	labels kunnen ook worden aangemaakt met het commando
	<command>glabel label</command>.  Deze zijn niet specifiek voor
	het bestandssysteem, en zullen in de map <filename>/dev/label</filename> aangemaakt
	worden.</para>

      <para>Een tijdelijk label verdwijnt na een herstart van het
	systeem.  Deze labels worden gecreëerd in
	<filename>/dev/label</filename> en zijn
	perfect voor experimenten.  Een tijdelijk kan met het commando
	<command>glabel create</command> worden aangemaakt.  Lees voor
	meer informatie de handleidingpagina van &man.glabel.8;.</para>

<!-- XXXTR: How do you create a file system label without running newfs
	    or when there is no newfs (e.g.: cd9660)? -->

      <para>Om een permanent label te schrijven voor een
	<acronym>UFS</acronym>2-bestandssysteem zonder de huidige data
	te vernietigen:</para>

      <screen>&prompt.root; <userinput>tunefs -L home /dev/da3</userinput></screen>

      <warning>
	<para>Als het bestandssyteem vol is kan dit leiden tot data
	  corruptie; echter als het bestandssysteem vol is zou het
	  hoofddoel moeten zijn om oude achtergebleven bestanden weg
	  te halen in plaats van het toevoegen van labels.</para>
      </warning>

      <para>Er zou nu een label moeten bestaan in
	<filename>/dev/ufs</filename>, welke
	toegevoegd kan worden aan het <filename>/etc/fstab</filename>
	bestand:</para>

      <programlisting>/dev/ufs/home	/home            ufs     rw              2      2</programlisting>

      <note>
	<para>Het bestandssysteem mag niet aangekoppeld zijn op het
	  moment dat <command>tunefs</command> gebruikt wordt.</para>
      </note>

      <para>Nu kan het bestandssysteem net als normaal worden gekoppeld:</para>

      <screen>&prompt.root; <userinput>mount /home</userinput></screen>

      <para>Vanaf dit moment is het mogelijk om, zolang de
	<filename>geom_label.ko</filename> geladen wordt tijdens het
	opstarten van het systeem, of als deze is meegecompileerd door
	middel van de <literal>GEOM_LABEL</literal> optie in de kernel,
	het apparaatknooppunt te wijzigen zonder ernstige gevolgen voor
	het systeem.</para>

      <para>Bestandssystemen kunnen ook een standaard label mee krijgen
	door gebruik te maken van de <option>-L</option> optie met het
	<command>newfs</command> commando.  Zie de &man.newfs.8;
	handleiding voor meer informatie.</para>

      <para>Het volgende commando kan worden gebruikt om een label te
	verwijderen:</para>

      <screen>&prompt.root; <userinput>glabel destroy home</userinput></screen>

      <para>Het volgende voorbeeld laat zien hoe de partities van een
	opstartschijf gelabeld worden.</para>

      <example>
	<title>Partities op de opstartschijf labelen</title>

	<para>Door de partities op de opstartschijf permanent te labelen
	  zou het systeem in staat moeten zijn om normaal door te gaan
	  met opstarten, zelfs als de schijf verplaatst is naar een
	  andere controller of is overgeplaatst naar een ander systeem.
	  In dit voorbeeld wordt aangenomen dat er een enkele
	  <acronym>ATA</acronym>-schijf wordt gebruikt, die momenteel
	  als <filename>ad0</filename> door het systeem wordt
	  herkend.  Het wordt ook aangenomen dat het standaard
	  partitieschema van &os; wordt gebruikt, met de
	  bestandssystemen <filename>/</filename>,
	  <filename>/var</filename>,
	  <filename>/usr</filename>, en
	  <filename>/tmp</filename>, alsmede een
	  wisselpartitie.</para>

	<para>Start het systeem opnieuw op, en druk bij de
	  &man.loader.8;-prompt op 4 om in enkele gebruikersmodus op te
	  starten.  Geef dan de volgende commando's:</para>

	<screen>&prompt.root; <userinput>glabel label rootfs /dev/ad0s1a</userinput>
GEOM_LABEL: Label for provider /dev/ad0s1a is label/rootfs
&prompt.root; <userinput>glabel label var /dev/ad0s1d</userinput>
GEOM_LABEL: Label for provider /dev/ad0s1d is label/var
&prompt.root; <userinput>glabel label usr /dev/ad0s1f</userinput>
GEOM_LABEL: Label for provider /dev/ad0s1f is label/usr
&prompt.root; <userinput>glabel label tmp /dev/ad0s1e</userinput>
GEOM_LABEL: Label for provider /dev/ad0s1e is label/tmp
&prompt.root; <userinput>glabel label swap /dev/ad0s1b</userinput>
GEOM_LABEL: Label for provider /dev/ad0s1b is label/swap
&prompt.root; <userinput>exit</userinput></screen>

	<para>Het systeem zal doorgaan met opstarten in
	  meergebruikersmodus.  Bewerk, nadat het opstarten is voltooid,
	  <filename>/etc/fstab</filename> en vervang de conventionele
	  namen door de respectievelijke labels.  Het uiteindelijke
	  bestand <filename>/etc/fstab</filename> zal er als volgt
	  uitzien:</para>

	<programlisting># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/label/swap          none            swap    sw              0       0
/dev/label/rootfs        /               ufs     rw              1       1
/dev/label/tmp           /tmp            ufs     rw              2       2
/dev/label/usr           /usr            ufs     rw              2       2
/dev/label/var           /var            ufs     rw              2       2</programlisting>

	<para>Het systeem kan nu worden herstart.  Als alles goed ging,
	  zal het normaal opstarten en zal <command>mount</command> dit
	  laten zien:</para>

	<screen>&prompt.root; <userinput>mount</userinput>
/dev/label/rootfs on / (ufs, local)
devfs on /dev (devfs, local)
/dev/label/tmp on /tmp (ufs, local, soft-updates)
/dev/label/usr on /usr (ufs, local, soft-updates)
/dev/label/var on /var (ufs, local, soft-updates)</screen>
      </example>

      <para>Beginnend met &os;&nbsp;7.2 ondersteunt de klasse &man.glabel.8;
	een nieuw labeltype voor <acronym>UFS</acronym>-bestandssystemen,
	gebaseerd op het unieke id van het bestandssysteem,
	<literal>ufsid</literal>.  Deze labels kunnen in de map <filename>/dev/ufsid</filename> gevonden worden en
	worden automatisch tijdens het opstarten aangemaakt.  Het is
	mogelijk om de <literal>ufsid</literal>-labels te gebruiken om
	partities aan te koppelen door middel van de faciliteit
	<filename>/etc/fstab</filename>.  Gebruik <command>glabel
	  status</command> om een lijst van bestandssystemen en hun
	overeenkomende <literal>ufsid</literal>-labels te ontvangen:</para>

      <screen>&prompt.user; <userinput>glabel status</userinput>
                  Name  Status  Components
ufsid/486b6fc38d330916     N/A  ad4s1d
ufsid/486b6fc16926168e     N/A  ad4s1f</screen>

      <para>In het bovenstaande voorbeeld representeert
	<filename>ad4s1d</filename> het bestandssysteem <filename>/var</filename>, terwijl
	<filename>ad4s1f</filename> het bestandssysteem <filename>/usr</filename> representeert.  Door gebruik
	te maken van de gegeven <literal>ufsid</literal>-waarden kunnen
	deze partities nu aangekoppeld worden met de volgende regels in
	<filename>/etc/fstab</filename>:</para>

      <programlisting>/dev/ufsid/486b6fc38d330916	/var	ufs	rw	2	2
/dev/ufsid/486b6fc16926168e	/usr	ufs	rw	2	2</programlisting>

      <para>Elke partitie met een <literal>ufsid</literal>-label kan op
	deze manier worden aangekoppeld, waardoor het niet meer nodig is
	om handmatig permanente labels voor ze aan te maken, terwijl er
	nog steeds van de voordelen van apparaatnaam-onafhankelijk
	aankoppelen genoten kan worden.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="geom-gjournal">
    <title>UFS logboeken door middel van GEOM</title>

    <indexterm><primary>GEOM</primary></indexterm>

    <indexterm><primary>Journaling</primary></indexterm>

    <para>Met de komst van &os;&nbsp;7.0 komt ook de langverwachte
      optie van <acronym>UFS</acronym> logboeken.  De implementatie
      zelf is gedaan door middel van het GEOM subsysteem, welke
      makkelijk geconfigureerd kan worden met behulp van de
      &man.gjournal.8; applicatie.</para>

    <para>Wat is logboeken? Logboek mogelijkheden betekend het opslaan
      van bestandssysteem transacties, zoals wijzigingen die een
      complete schrijfactie zijn, voor er meta-data wordt toegevoegd
      en voor de wijzigingen op schijf worden gezet.  Deze transactie
      log kan later opnieuw afgespeeld worden om te voorkomen dat er
      bestandssysteem inconsistenties voorkomen.</para>

    <para>Deze methode is een extra manier om te beschermen tegen
      gegevensverlies en inconsistenties van het bestandssysteem.  In
      tegenstelling tot Soft Updates, welke bijhoud welke meta-data
      wijzigingen er worden uitgevoerd en Snapshots, wat een beeld
      bestand is van het bestandssysteem, wordt er een complete log
      bewaard in de schijfruimte die speciaal voor deze taak is
      gereserveerd, en in sommige gevallen op een compleet andere
      schijf.</para>

    <para>In tegenstelling tot andere logboek implementaties is de
      <command>gjournal</command> methode blok gebaseerd en niet
      geïmplementeerd als onderdeel van het bestandssysteem maar
      als uitbreiding op <acronym>GEOM</acronym>.</para>

    <para>Om ondersteuning in te schakelen voor
      <command>gjournal</command>, moet de kernel over de volgende optie
      beschikken, welke standaard is op &os; 7.X-systemen:</para>

    <programlisting>options        UFS_GJOURNAL</programlisting>

    <para>Indien gejournalde volumes tijdens het opstarten aangekoppeld
      moeten worden, moet de kernelmodule
      <filename>geom_journal.ko</filename> ook geladen zijn, door de
      volgende regel aan <filename>/boot/loader.conf</filename> toe te
      voegen:</para>

    <programlisting>geom_journal_load="YES"</programlisting>

    <para>Ook kan deze functie in een eigen kernel worden ingebouwd,
      door de volgende regel aan het kernelinstellingenbestand toe te
      voegen:</para>

    <programlisting>options    GEOM_JOURNAL</programlisting>

    <para>Het creëren van een logboek op een vrij en beschikbaar
      bestandssysteem kan nu gedaan worden met behulp van de volgende
      stappen, ervan uitgaande dat <filename>da4</filename> de
      nieuwe beschikbare <acronym>SCSI</acronym> schijf is:</para>

    <screen>&prompt.root; <userinput>gjournal load</userinput>
&prompt.root; <userinput>gjournal label /dev/da4</userinput></screen>

    <para>Op dit moment zou er een <filename>ad4</filename>
      apparaatknooppunt en een <filename>ad4.journal</filename>
      apparaatknooppunt moeten zijn.  Nu kan er een bestandssysteem op
      gezet worden:</para>

    <screen>&prompt.root; <userinput>newfs -O 2 -J /dev/da4.journal</userinput></screen>

    <para>Het hiervoor ingevoerde commando zal een
      <acronym>UFS</acronym>2 bestandssysteem met logboek
      ondersteuning aanmaken.</para>

    <para>Koppel het apparaat op een gewenst koppelpunt met:</para>

    <screen>&prompt.root; <userinput>mount /dev/da4.journal /mnt</userinput></screen>

    <note>
      <para>In het geval dat er meerdere slices zijn, zal er een logboek
	voor elke slice gecreëerd worden.  Bijvoorbeeld, als
	<filename>ad4s1</filename> en <filename>ad4s2</filename>
	allebei slices zijn, dan zal <command>gjournal</command> een
	<filename>ad4s1.journal</filename> en een
	<filename>ad4s2.journal</filename> creëeren.</para>
    </note>

    <para>Voor performance doeleinden is het gewenst om het logboek op een
      andere schijf te bewaren.  Voor deze gevallen moet de
      logboekleverancier of het opslagapparaat gespecificeerd worden
      achter het apparaat waarop de logboek functionaliteit aangebracht
      moet worden.  De logboekfunctionaliteit kan ook worden
      ingeschakeld op een reeds bestaand systeem met behulp van
      <command>tunefs</command>.  Maak echter altijd een back-up voor dat
      dit soort dingen uitgeprobeerd worden.  In de meeste gevallen zal
      <command>gjournal</command> falen als het geen actueel logboek
      kan maken, maar het voorkomt geen dataverlies als gevolg van
      verkeerd gebruik van <command>tunefs</command>.</para>

    <para>Het is ook mogelijk om een journal van de opstartschijf van
      een &os;-systeem bij te houden.  Voor gedetailleerde instructies
      over deze taak wordt naar het artikel <link xlink:href="&url.articles.gjournal-desktop;">Implementing UFS
	Journaling on a Desktop PC</link> verwezen.</para>
  </sect1>
</chapter>
