<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE article PUBLIC "-//FreeBSD//DTD DocBook XML V5.0-Based Extension//EN"
	"http://www.FreeBSD.org/XML/share/xml/freebsd50.dtd">
<!-- The FreeBSD Spanish Documentation Project
     Original Revision: r1.1			-->
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="es">
  <info><title>Guía de &os; para usuarios de &linux;</title>
    

    <authorgroup>
      <author><personname><firstname>John</firstname><surname>Ferrell</surname></personname></author>
    </authorgroup>

    <copyright>
      <year>2008</year>
      <holder>El Proyecto de Documentación de &os;</holder>
    </copyright>

    <pubdate>$FreeBSD$</pubdate>

    <releaseinfo>$FreeBSD$</releaseinfo>

    <legalnotice xml:id="trademarks" role="trademarks">
      &tm-attrib.freebsd;
      &tm-attrib.linux;
      &tm-attrib.intel;
      &tm-attrib.redhat;
      &tm-attrib.unix;
      &tm-attrib.general;
    </legalnotice>

    <abstract>
      <para>El objetivo de este documento es familiarizar de forma
	rápida a usuarios de nivel intermedio o avanzado de
	&linux; sobre los conceptos básicos de
	&os;.</para>

      &trans.es.gabor;
    </abstract>
  </info>

  <sect1 xml:id="intro">
    <title>Introducción</title>

    <para>En este documento se muestran las diferencias entre &os; y &linux;
      para que usuarios de nivel intermedio o avanzado de &linux; puedan
      aprender rápidamente los fundamentos de &os;.  Es solamente
      una breve presentación técnica, no intenta explicar
      las diferencias de las <quote>filosofías</quote> que hay
      detrás de ambos sistemas operativos.</para>

    <para>Este documento presupone que usted ya tiene &os; instalado.  Si no lo
      ha instalado o necesita ayuda con el proceso de la instalación
      consulte el capítulo en el que se explica la <link xlink:href="&url.base;/doc/es_ES.ISO8859-1/books/handbook/install.html">
      instalación de &os;</link> del Handbook.</para>
  </sect1>

  <sect1 xml:id="shells">
    <title>Shells: ?No está Bash?</title>

    <para>Quienes vienen de &linux; se suelen sorprender de que
      <application>Bash</application> no sea la shell por omisión,
      que en &os; es &man.tcsh.1;.  De hecho <application>Bash</application>
      ni siquiera forma parte de la instalación mínima de
      &os;.  A pesar de esto tanto <application>Bash</application> como
      cualquiera de sus shell favoritas están en la <link xlink:href="article.html#SOFTWARE">Colección de Packages y Ports</link>
      de &os;.</para>

    <para>Si instala otras shell puede usar &man.chsh.1; como shell por
      omisión para sus usuarios, pero le recomendamos encarecidamente
      que no cambie la shell por omisión del usuario
      <systemitem class="username">root</systemitem>.  La razón es que las shell que no
      forman parte de la instalación base generalmente se instalan en
      <filename>/usr/local/bin</filename> o en
      <filename>/usr/bin</filename>.  En caso de problemas es posible que
      los sistemas de ficheros donde están
      <filename>/usr/local/bin</filename> y <filename>/usr/bin</filename>
      no puedan montarse.  En un caso así
      <systemitem class="username">root</systemitem> no podría acceder a su shell por
      omisión, con lo que no podría iniciar su sesión.
      Para evitar este tipo de problemas se creó una segunda cuenta
      de usuario <systemitem class="username">root</systemitem>, el usuario
      <systemitem class="username">toor</systemitem>.  Consulte la sección de seguridad
      de las FAQ si quiere saber más sobre <link xlink:href="&url.base;/doc/en_US.ISO8859-1/books/faq/security.html#TOOR-ACCOUNT">la cuenta toor</link>.</para>
  </sect1>

  <sect1 xml:id="software">
    <title>Packages y Ports: Instalación de software en &os;</title>

    <para>Aparte del método tradicional de instalar software en &unix;
      (descargar fuentes, descomprimir, editar el fuente y compilar),
      &os; ofrece dos alternativas para instalar programas: packages y
      dos alternativas para instalar programas: package y ports.  Una lista
      y ports.  Hay una lista completa de los ports disponibles <link xlink:href="http://www.freebsd.org/ports/master-index.html">aquí</link>.</para>

    <sect2 xml:id="packages">
      <title>Packages</title>

      <para>Los <quote>packages</quote> son programas precompilados,
	equivalentes en &os; a los ficheros <filename>.deb</filename> en
	sistemas Debian/Ubuntu y <filename>.rpm</filename> en sistemas
	Red&nbsp;Hat/Fedora.  Los packages se instalan usando
	&man.pkg.add.1;.  Por ejemplo, puede instalar
	<application>Apache 2.2</application> del siguiente modo:</para>

      <screen>&prompt.root; <userinput>pkg_add /tmp/apache-2.2.6_2.tbz</userinput></screen>

      <para>Al usar la opción <option>-r</option>, &man.pkg.add.1;
	automáticamente descargará el package indicado y
	lo instalará, así como todos aquellos que necesite
        para su funcionamiento.  Esto son las
	<literal>dependencias</literal>.</para>

      <screen>&prompt.root; <userinput>pkg_add -r apache22</userinput>
Fetching ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-6.2-release/Latest/apache22.tbz... Done.
Fetching ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-6.2-release/All/expat-2.0.0_1.tbz... Done.
Fetching ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-6.2-release/All/perl-5.8.8_1.tbz... Done.
[snip]

To run apache www server from startup, add apache22_enable="YES"
in your /etc/rc.conf. Extra options can be found in startup script.</screen>

      <note>
	<para>Si usa una versión release de &os; (6.2, 6.3, 7.0,
	  etc., lo que seguramente es una instalación desde CD-ROM)
	  <command>pkg_add -r</command> descargará packages
	  compilados para esa release específica.  Estos packages
	  <emphasis>pueden ser</emphasis> versiones desactualizadas
	  del programa.  Puede usar la variable <envar>PACKAGESITE</envar>
	  para ignorar este comportamiento, que es el que se espera por
	  omisión del programa.  Por ejemplo, asigne a
	  <envar>PACKAGESITE</envar> el valor <uri xlink:href="ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-6-stable/Latest/">ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-6-stable/Latest/</uri>
          si quiere descargar los packages más recientes compilados
	   para la versión 6.X.</para>
      </note>

      <para>Para más información sobre los packages consulte
	la sección 4.4 del Handbook: <link xlink:href="&url.base;/doc/es_ES.ISO8859-1/books/handbook/packages-using.html">Uso del sistema de packages</link>.</para>
    </sect2>

    <sect2 xml:id="ports">
      <title>Ports</title>

      <para>El segundo método que ofrece &os; para instalar programas
	es usar la Colección de Ports.  la Colección de Ports es
	un entorno de ficheros <filename>Makefile</filename> y parches
	adaptados específicamente para poder instalar desde el
	código fuente aplicaciones de lo más variopinto en
	sistemas &os;.  Si instala un port el sistema descargará
	los fuentes, aplicará los parches necesarios, compilará
	el código e instalará el programa (y hará
	exactamente los mismo con todas las dependencias).</para>

      <para>La Colección de Ports, también conocida como
	árbol de ports, está en
	<filename>/usr/ports</filename> si se instaló durante el
	proceso de instalación de &os;.  Si la Colección de
	Ports no está instalada puede hacerlo puede hacerlo desde
	los discos de instalación mediante &man.sysinstall.8; o
	desde los servidores de &os; gracias a &man.csup.1; o
	&man.portsnap.8;.  Tiene instrucciones detalladas para instalar la
	Colección de Ports en la <link xlink:href="&url.base;/doc/en_US.ISO8859-1/books/handbook/ports-using.html">sección 4.5.1</link>
	del Handbook.</para>

      <para>Instalar un port es (generalmente) tan simple como entrar en
	el directorio del port y ejecutar el proceso de
	compilación.  El ejemplo que se muestra a continuación
	instala <application>Apache 2.2</application> desde la Colección
	de Ports:</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/www/apache22</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>Una de las principales ventajas del uso de ports para instalar
	software es la posibilidad de ajustar las opciones de la
	instalación.  Por ejemplo, es posible activar
	<application>mod_ldap</application> dentro de su
	<application>Apache 2.2</application> durante la instalación
	mediante el uso de la variable <varname>WITH_LDAP</varname>
	de &man.make.1;:</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/www/apache22</userinput>
&prompt.root; <userinput>make WITH_LDAP="YES" install clean</userinput></screen>

      <para>Para más información sobre la Colección
	 de Ports consulte la sección del Handbook dedicada a <link xlink:href="&url.base;/doc/es_ES.ISO8859-1/books/handbook/ports-using.html">la
	 Colección de Ports</link>.</para>
    </sect2>

    <sect2 xml:id="which">
      <title>?Qué debería usar? ?Ports o Packages?</title>

      <para>Los packages son simplemente ports precompilados, así que
	es cuestión de elegir entre instalar desde los fuentes (ports)
	o instalar binarios directamente (packages).  Cualquiera de los
	dos tiene sus propias ventajas:</para>

      <itemizedlist>
	<title>Package (binario)</title>

	<listitem><simpara>Instalación más rápida
	  (compilar programas grandes puede llevar su
	  tiempo).</simpara></listitem>

	<listitem><simpara>No hay que comprender el proceso de compilar
	  software.</simpara></listitem>

	<listitem><simpara>No es necesario instalar compiladores en su
	  sistema.</simpara></listitem>
      </itemizedlist>

      <itemizedlist>
	<title>Ports (fuente)</title>

	<listitem><simpara>Es posible ajustar las opciones de la
	  instalación.  (Los packages se generan normalmente con las
	  opciones estándar.  Con los ports puede ajustar diversas
	  opciones, como disponer de módulos adicionales o cambiar
	  la ruta por omisión.)</simpara></listitem>

	<listitem><simpara>Puede usar sus propios parches si tiende
	  hacerlo.</simpara></listitem>
      </itemizedlist>

      <para>Si no tiene requisitos especiales los packages probablemente
	cubran sus necesidades sin problema.  Si alguna vez necesita
	algo más ajustado puede recurrir a los ports.  Tenga en
	cuenta que si necesita un programa a su medida pero sigue prefiriendo
	usar packages puede hacerse uno su gusto mediante
	<command>make</command> <buildtarget>patch</buildtarget> y luego
	copie el package a otras máquinas.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="startup">
    <title>Arranque del sistema: ?Dónde están los
      niveles de ejecución?</title>

    <para>&linux; usa el sistema de inicio SysV, mientras que &os; usa el
      sistema &man.init.8; tradicional en BSD.  En el &man.init.8; del
      estilo BSD no existen ni los niveles de ejecución ni
      <filename>/etc/inittab</filename>; en vez de esto el inicio se controla
      desde &man.rc.8;.  El script <filename>/etc/rc</filename> lee
      los ficheros <filename>/etc/defaults/rc.conf</filename> y
      <filename>/etc/rc.conf</filename> para determinar qué servicios
      deben arrancarse.  Después de esto se arrancan los servicios
      a los que se hace referencia en los scripts de arranque ubicados en
      <filename>/etc/rc.d/</filename> o
      <filename>/usr/local/etc/rc.d/</filename>.  Estos scripts son similares a
      los que hay en <filename>/etc/init.d/</filename> en un sistema
      &linux;.</para>

    <sidebar>
      <para><emphasis>?Por qué los script de arranque
	arranque están en dos sitios?</emphasis>  Los script situados en
	<filename>/etc/rc.d/</filename> son para programas del sistema
	<quote>base</quote>, como &man.cron.8;, &man.sshd.8;, &man.syslog.3; y
	otros.  Los scripts de <filename>/usr/local/etc/rc.d/</filename> son
	para software instalado por el usuario como por ejemplo
	<application>Apache</application>,
	<application>Squid</application>, etc.</para>

      <para><emphasis>?Cuál es la diferencia entre el sistema
	<quote>base</quote> y los programas instalados por el
	usuario?</emphasis>  &os; se desarrolla como un sistema operativo
	completo.  En otras palabras, el kernel, las bibliotecas del
	sistema y las utilidades (por ejemplo &man.ls.1;, &man.cat.1;,
	&man.cp.1;, etc.) se desarrollan y se publican como un todo.  A esto
	es a lo que nos referimos como <quote>sistema base</quote>.  Los
	programas instalados por el usuario, como por ejemplo
	<application>Apache</application>,
	<application>X11</application>,
	<application>Mozilla&nbsp;Firefox</application>, etc. no forman parte
	del sistema <quote>base</quote>.  Estos programas
	normalmente se instalan desde la <link xlink:href="article.html#SOFTWARE">Colección de Packages y
	 Ports</link>.
	Para separarlos del sistema <quote>base</quote> se instalan
	normalmente en <filename>/usr/local/</filename>.  De ahí que
	los binarios de los programas instalados por los usuario se
	sitúen en <filename>/usr/local/bin/</filename>, los ficheros
	de configuración en <filename>/usr/local/etc/</filename>,
	etc.</para>
    </sidebar>

    <para>Los servicios se arrancan mediante líneas
      <literal>NombreDeServicio_enable="YES"</literal> en
      <filename>/etc/rc.conf</filename> (&man.rc.conf.5;).  Eche un vistazo
      a <filename>/etc/defaults/rc.conf</filename>: La configuración
      por omisión del sistema puede sobreescribirse desde
      <filename>/etc/rc.conf</filename>.  Además, al instalar programas
      debe asegurarse de leer la documentación para determinar
      cómo arrancar los servicios que puedan estar relacionados.</para>

    <para>El siguiente fragmento de <filename>/etc/rc.conf</filename>
      arranca &man.sshd.8; y <application>Apache 2.2</application>.
      También hace que <application>Apache</application> arranque
      con SSL.</para>

    <programlisting># enable SSHD
sshd_enable="YES"
# enable Apache with SSL
apache22_enable="YES"
apache22_flags="-DSSL"</programlisting>

    <para>Una vez que un servicio aparece en
      <filename>/etc/rc.conf</filename> el servicio puede arrancarse
      desde la línea de comandos (sin reiniciar el sistema):</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd start</userinput></screen>

    <para>Si un servicio no dispone de la correspondiente entrada en
      <filename>/etc/rc.conf</filename> se puede arrancar desde la
      línea de comandos usando la opción
      <option>forcestart</option>:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd forcestart</userinput></screen>
  </sect1>

  <sect1 xml:id="network">
    <title>Configuración de la red</title>

    <sect2 xml:id="interfaces">
      <title>Interfaces de red</title>

      <para>Los nombres de interfaces de red representan en &os;
	el nombre del controlador seguido por un número, en lugar del
	esquema que usa &linux;, el genérico.
	<emphasis>ethX</emphasis>.  La salida de &man.ifconfig.8; que se
	muestra a continuación presenta dos interfaces del
	tipo &intel;&nbsp;Pro&nbsp;1000 (em0 y em1):</para>

      <screen>&prompt.user; <userinput>ifconfig</userinput>
em0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        options=b&lt;RXCSUM,TXCSUM,VLAN_MTU&gt;
        inet 10.10.10.100 netmask 0xffffff00 broadcast 10.10.10.255
        ether 00:50:56:a7:70:b2
        media: Ethernet autoselect (1000baseTX &lt;full-duplex&gt;)
        status: active
em1: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        options=b&lt;RXCSUM,TXCSUM,VLAN_MTU&gt;
        inet 192.168.10.222 netmask 0xffffff00 broadcast 192.168.10.255
        ether 00:50:56:a7:03:2b
        media: Ethernet autoselect (1000baseTX &lt;full-duplex&gt;)
        status: active</screen>
    </sect2>

    <sect2 xml:id="ipaddress">
      <title>Configuración de IP</title>

      <para>Con &man.ifconfig.8; puede asignar una dirección IP
	a una interfaz de red.  No obstante, si quiere que la IP siga
	asignada a la interfaz después de reiniciar tendrá
	que incluirla en <filename>/etc/rc.conf</filename>.  En el ejemplo
	siguiente se especifica el nombre de la máquina, la
	la dirección IP y la puerta de enlace por omisión:</para>

      <programlisting>hostname="servidor1.ejemplo.com"
ifconfig_em0="inet 10.10.10.100  netmask 255.255.255.0"
defaultrouter="10.10.10.1"</programlisting>

      <para>Con la siguiente configuración la interfaz indicada
	intentará obtener una dirección IP mediante
	DHCP:</para>

      <programlisting>hostname="servidor1.ejemplo.com"
ifconfig_em0="DHCP"</programlisting>

    </sect2>
  </sect1>

  <sect1 xml:id="firewall">
    <title>Cortafuegos</title>

    <para>Igual que &linux; dispone de <application>IPTABLES</application>,
      &os; también disponde de cortafuegos integrado en el kernel,
      solo que &os; en lugar de uno dispone de tres:</para>

    <itemizedlist>
      <listitem><simpara><link xlink:href="&url.base;/doc/en_US.ISO8859-1/books/handbook/firewalls-ipfw.html">IPFIREWALL</link></simpara></listitem>
      <listitem><simpara><link xlink:href="&url.base;/doc/en_US.ISO8859-1/books/handbook/firewalls-ipf.html">IPFILTER</link></simpara></listitem>
      <listitem><simpara><link xlink:href="&url.base;/doc/en_US.ISO8859-1/books/handbook/firewalls-pf.html">PF</link></simpara></listitem>
    </itemizedlist>

    <para><application>IPFIREWALL</application> o
      <application>IPFW</application> (el programa para manejar las reglas de
      <application>IPFW</application> es &man.ipfw.8;) es el cortafuegos
      que desarrollan y mantienen los desarrolladores de &os;.
      <application>IPFW</application> se puede combinar con &man.dummynet.4;
      para conseguir servicios de <quote>traffic shaping</quote> y simular
      diferentes tipos de conexiones.</para>

    <para>Veamos un ejemplo de regla que permite la entrada de tráfico
      <application>SSH</application>:</para>

    <programlisting>ipfw add allow tcp from any to me 22 in via $ext_if</programlisting>

    <para><application>IPFILTER</application> es el cortafuegos que
      desarrolla Darren&nbsp;Reed.  No es específico de &os; y se ha
      portado ya a diversos sistemas operativos como NetBSD, OpenBSD,
      SunOS, HP/UX y Solaris.</para>

    <para>El siguiente ejemplo permite la entrada de tráfico
      <application>SSH</application>:</para>

    <programlisting>pass in on $ext_if proto tcp from any to any port = 22</programlisting>

    <para>El último cortafuegos,
      <application>PF</application>, ha sido desarrollado por el proyecto
      OpenBSD.  <application>PF</application> fue creado como sustituto de
      <application>IPFILTER</application>, de ahí que la sintaxis de
      <application>PF</application> sea muy similar a la de
      <application>IPFILTER</application>.  <application>PF</application> se
      puede combinar con &man.altq.4; para disponer de QoS.</para>

    <para>En el siguiente ejemplo vemos una regla que permite la entrada de
      tráfico <application>SSH</application>:</para>

     <programlisting>pass in on $ext_if inet proto tcp from any to ($ext_if) port 22</programlisting>
  </sect1>

  <sect1 xml:id="updates">
    <title>Actualización de &os;</title>

    <para>Hay tres métodos para actualizar &os;: desde los fuentes,
      mediante actualizaciones binarias y con los discos de
      instalación.</para>

    <para>Actualizar desde código fuente es el método
      más complejo pero el que ofrece la mayor flexibilidad.
      Este proceso implica sincronizar su copia en local del código
      fuente de &os; desde los servidores
      <application>CVS</application> (Concurrent Versioning System).  Una vez
      actualizado el código puede compilar nuevas versiones de
      kernel y utilidades.  Si quiere más información
      consulte el <link xlink:href="&url.base;/doc/en_US.ISO8859-1/books/handbook/cutting-edge.html">capítulo 23</link>
      del Handbook.</para>

    <para>Las actualizaciones binarias son semejantes a
     <command>yum</command> o <command>apt-get</command> de &linux;.  El
     programa &man.freebsd-update.8; descargará las actualizaciones
     pendientes del sistema y las instalará.  Las actualizaciones pueden
     ser programadas con &man.cron.8;.</para>

    <note>
      <para>Si usa &man.cron.8; para programar las actualizaciones por favor,
	asegúrese de poner <command>freebsd-update cron</command> en su
	&man.crontab.1; para reducir la posibilidad de que una gran cantidad de
	servidores descarge actualizaciones al mismo tiempo.</para>

      <programlisting>0 3 * * * root /usr/sbin/freebsd-update cron</programlisting>
    </note>

    <para>El último método de actualización es
      desde los discos de instalación.  Es un proceso
      bastante claro.  Encienda el sistema desde el disco y seleccione
      la opción de actualizar.</para>
  </sect1>

  <sect1 xml:id="procfs">
    <title>procfs: perdido pero no olvidado</title>

    <para>Es posible que usando &linux; haya consultado
      <filename>/proc/sys/net/ipv4/ip_forward</filename> para determinar si
      <quote>IP forwarding</quote> estaba activado.  En &os; tendrá
      que usar &man.sysctl.8; para comprobar éste y otros
      parámetros puesto que &man.procfs.5; está obsoleto
      en las versiones más recientes de &os;.  Tenga en cuenta que
      <command>sysctl</command> también existe en
      &linux;.</para>

    <para>Siguiendo con el ejemplo de <quote>IP forwarding</quote>
      podría usar lo siguiente para determinar si tiene activado
      <quote>IP forwarding</quote> en su sistema &os;:</para>

    <screen>&prompt.user; <userinput>sysctl net.inet.ip.forwarding</userinput>
net.inet.ip.forwarding: 0</screen>

    <para>La opción <option>-a</option> se usa para ver la
      configuración del sistema:</para>

    <screen>&prompt.user; <userinput>sysctl -a</userinput>
kern.ostype: FreeBSD
kern.osrelease: 6.2-RELEASE-p9
kern.osrevision: 199506
kern.version: FreeBSD 6.2-RELEASE-p9 #0: Thu Nov 29 04:07:33 UTC 2007
    root@i386-builder.daemonology.net:/usr/obj/usr/src/sys/GENERIC

kern.maxvnodes: 17517
kern.maxproc: 1988
kern.maxfiles: 3976
kern.argmax: 262144
kern.securelevel: -1
kern.hostname: server1
kern.hostid: 0
kern.clockrate: { hz = 1000, tick = 1000, profhz = 666, stathz = 133 }
kern.posix1version: 200112
...</screen>

    <note>
      <para>Algunos de estos valores de <command>sysctl</command> son de
	sólo lectura.</para></note>

    <para>Hay ocasiones en las que es disponer de procfs es imprescindible,
      por ejemplo para ejecutar software antiguo, usar &man.truss.1; para
      seguir llamadas al sistema y para la <link xlink:href="&url.base;/doc/en_US.ISO8859-1/books/handbook/linuxemu.html">compatibilidad binaria con &linux;</link>.
      (aunque la compatibilidad binaria con &linux; use su propio procfs,
      &man.linprocfs.5;.)  Si necesita montar procfs añada las
      siguientes líneas a <filename>/etc/fstab</filename>:</para>

    <screen>proc                /proc           procfs  rw,noauto       0       0</screen>

    <note>
      <para>La opción <option>noauto</option> evitará
	que <filename>/proc</filename> sea montado automáticamente
	cuando el sistema arranque.</para></note>

    <para>Hecho esto monte procfs así:</para>

    <screen>&prompt.root; <userinput>mount /proc</userinput></screen>
  </sect1>

  <sect1 xml:id="commands">
    <title>Comandos más comunes</title>

    <sect2 xml:id="packageCommands">
      <title>Gestión de packages</title>

      <para>
	<informaltable frame="none" pgwide="1">
	  <tgroup cols="3">
	    <thead>
	      <row>
		<entry>&linux; command (Red&nbsp;Hat/Debian)</entry>
		<entry>&os; equivalente</entry>
		<entry>Resultado</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><command>yum install &lt;package&gt;</command> / <command>apt-get install &lt;package&gt;</command></entry>
		<entry><command>pkg_add -r &lt;package&gt;</command></entry>
		<entry>Instalar &lt;package&gt; desde un repositorio remoto</entry>
	      </row>

	      <row>
		<entry><command>rpm -ivh &lt;package&gt;</command> / <command>dpkg -i &lt;package&gt;</command></entry>
		<entry><command>pkg_add -v &lt;package&gt;</command></entry>
		<entry>Instalar package</entry>
	      </row>

	      <row>
		<entry><command>rpm -qa</command> / <command>dpkg -l</command></entry>
		<entry><command>pkg_info</command></entry>
		<entry>Ver packages instalados</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>
    </sect2>

    <sect2 xml:id="systemCommands">
      <title>Gestión del sistema</title>

      <para>
	<informaltable frame="none" pgwide="1">
	  <tgroup cols="3">
	    <thead>
	      <row>
		<entry>&linux; command</entry>
		<entry>&os; equivalente</entry>
		<entry>Resultado</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><command>lspci</command></entry>
		<entry><command>pciconf</command></entry>
		<entry>Ver dispositivos PCI</entry>
	      </row>

	      <row>
		<entry><command>lsmod</command></entry>
		<entry><command>kldstat</command></entry>
		<entry>Ver módulos cargados en el kernel</entry>
	      </row>

	      <row>
		<entry><command>modprobe</command></entry>
		<entry><command>kldload</command> / <command>kldunload</command></entry>
		<entry>Cargar/Borrar módulos del kernel</entry>
	      </row>

	      <row>
		<entry><command>strace</command></entry>
		<entry><command>truss</command></entry>
		<entry>Seguir llamadas del sistema</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>
    </sect2>
  </sect1>

  <sect1 xml:id="conclusion">
    <title>Conclusión</title>

    <para>Esperamos que este documento le haya servido de suficiente ayuda
      para empezar a usar &os;.  Recuerde visitar el <link xlink:href="&url.base;/doc/en_US.ISO8859-1/books/handbook/index.html">&os;&nbsp;Handbook</link>,
      donde encontrará lo tratado aquí expuesto en profundidad
      y muchos otros temas que no se han tocado en este documento.</para>
  </sect1>
</article>
