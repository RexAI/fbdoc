<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project

     The FreeBSD Spanish Documentation Project
     %SOURCE% en_US.ISO8859-1/books/handbook/serialcomms/chapter.xml
     %SRCID%    0.0

     $FreeBSD$
     $FreeBSDes: doc/es_ES.ISO8859-1/books/handbook/serialcomms/chapter.xml,v 1.4 2004/10/08 19:06:36 jesusr Exp $
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="serialcomms">
  <title>Comunicaciones serie</title>

  <sect1 xml:id="serial-synopsis">
    <title>Sinopsis</title>

    <indexterm><primary>serial communications</primary></indexterm>
    <para>&unix; siempre ha tenido soporte para comunicación
      serie.  De hecho, las primeras máquinas &unix; dependían
      de líneas serie para tener interacción con el usuario. Las
      cosas han cambiado mucho desde esos días cuando la
      <quote>terminal</quote> promedio consistía de una terminal
      serie de 10-caracteres-por-segundo, impresora y teclado. Este
      capítulo cubrirá algunas de las maneras en las que
      FreeBSD utiliza comunicaciones serie.</para>

    <para>Despues de leer este capítulo, usted entenderá:</para>
    <itemizedlist>
      <listitem><para>Como conectar terminales a su sistema
          FreeBSD.</para></listitem>
      <listitem><para>Como utilizar un modem para marcar a
          equipos remotos.</para></listitem>
      <listitem><para>Como permitir a usuarios remotos entrar
          a su sistema con un modem.</para></listitem>
      <listitem><para>Como arrancar su sistema desde una
          consola serie.</para></listitem>
    </itemizedlist>

    <para>Antes de leer este capítulo usted debería:</para>
    <itemizedlist>
      <listitem><para>Saber como configurar e instalar un nuevo kernel (<xref linkend="kernelconfig"/>).</para></listitem>
      <listitem><para>Entender procesos y permisos &unix; (<xref linkend="basics"/>).</para></listitem>
      <listitem><para>Tener acceso al manual técnico para el
         hardware serie (modem o tarjeta multipuerto) que le gustaría
         utilizar con FreeBSD.</para></listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="serial">
    <title>Introducción</title>

    <!-- XXX Write me! -->

    <sect2 xml:id="serial-terminology">
      <title>Terminología</title>

      <variablelist>
	<varlistentry>
	  <term>bps</term>
	  <listitem>
	    <indexterm><primary>bits-por-second</primary></indexterm>

	    <para>Bits por segundo &mdash; la tasa a la cual los datos
	      son transmitidos</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>DTE</term>
	  <listitem>
	    <indexterm><primary>DTE</primary></indexterm>

	    <para>Data Terminal Equipment (Equipo terminal de datos) &mdash;
	      por ejemplo, su computadora</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>DCE</term>
	  <listitem>
	    <indexterm><primary>DCE</primary></indexterm>

	    <para>Data Communications Equipment (Equipo de
	      comunicación de datos) &mdash;  su modem</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>RS-232</term>
	  <listitem>
	    <indexterm><primary>RS-232C cables</primary></indexterm>

	    <para>Estándar EIA para hardware de comunicación
	      serie</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Cuando se habla de tasa de comunicación de datos,
        ésta sección no usa el término
	<quote>baud</quote>. Baud se refiere al número de estados de
	transición eléctricos que pueden realizarse en un
	periodo de tiempo, mientras que <quote>bps</quote> (bits por segundo)
	es el término <emphasis>correcto</emphasis> a usar (al menos
	parece no molestar demasiado a los más aferrados).</para>
   </sect2>

    <sect2 xml:id="serial-cables-ports">
      <title>Cables y puertos</title>

      <para>Para conectar un modem o terminal a su sistema FreeBSD
        necesitará un puerto serie en su computadora y el cable
	apropiado para conectar a su dispositivo serie. Si ya está
	familiarizado con su hardware y el cable que requiere, puede
	saltarse esta sección.</para>

      <sect3 xml:id="term-cables">
	<title>Cables</title>

        <para>Existen diferentes tipos de cables serie. Los dos tipos
          más comunes para nuestros propósitos son cables
          null-modem y cables RS-232 estándar (<quote>normal</quote>).
          La documentación de su hardware debería describir
          el tipo de cable requerido.</para>

	<sect4 xml:id="term-cables-null">
	  <title>Cables null-modem</title>

	  <indexterm>
	    <primary>null-modem cable</primary>
	  </indexterm>
          <para>Un cable null-modem pasa algunas señales, como
	    <quote>tierra</quote>, normalmente, pero cambia otras
	    señales. Por ejemplo, el pin <quote>envío de
	    datos</quote> en un extremo va al pin <quote>recepción de
	    datos</quote> en el otro.</para>

          <para>Si le gusta fabricar sus propios cables, puede construir
            un cable null-modem
            para utilizar con terminales. Esta tabla muestra los nombres
            de señal y números de pin en un conector DB-25.
	    </para>

	  <informaltable frame="none" pgwide="1">
	    <tgroup cols="5">
	      <thead>
		<row>
		  <entry>Señal</entry>
		  <entry>Pin #</entry>
		  <entry/>
		  <entry>Pin #</entry>
		  <entry>Señal</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>SG</entry>
		  <entry>7</entry>
		  <entry>conecta a</entry>
		  <entry>7</entry>
		  <entry>SG</entry>
		</row>

		<row>
		  <entry>TD</entry>
		  <entry>2</entry>
		  <entry>conecta a</entry>
		  <entry>3</entry>
		  <entry>RD</entry>
		</row>

		<row>
		  <entry>RD</entry>
		  <entry>3</entry>
		  <entry>conecta to</entry>
		  <entry>2</entry>
		  <entry>TD</entry>
		</row>

		<row>
		  <entry>RTS</entry>
		  <entry>4</entry>
		  <entry>conecta a</entry>
		  <entry>5</entry>
		  <entry>CTS</entry>
		</row>

		<row>
		  <entry>CTS</entry>
		  <entry>5</entry>
		  <entry>conecta a</entry>
		  <entry>4</entry>
		  <entry>RTS</entry>
		</row>

		<row>
		  <entry>DTR</entry>
		  <entry>20</entry>
		  <entry>conecta a</entry>
		  <entry>6</entry>
		  <entry>DSR</entry>
		</row>

		<row>
		  <entry>DCD</entry>
		  <entry>8</entry>
		  <entry/>
		  <entry>6</entry>
		  <entry>DSR</entry>
		</row>

		<row>
		  <entry>DSR</entry>
		  <entry>6</entry>
		  <entry>conecta a</entry>
		  <entry>20</entry>
		  <entry>DTR</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>

	  <note>
            <para>Conectar <quote>Data Set Ready</quote> (DSR) y
              <quote>Data Carrier Detect</quote> (DCD) intérnamente
              en la capucha del conector, y entonces a <quote>Data
              Terminal Ready</quote> (DTR) en la capucha remota.</para>
	  </note>
	</sect4>

	<sect4 xml:id="term-cables-std">
	  <title>Cables estándard RS-232C</title>
	  <indexterm><primary>RS-232C cables</primary></indexterm>

          <para>Un cable serie estándar pasa todas las señales
            RS-232C normalmente. Esto es, el pin <quote>envío de
	    datos</quote> en un extremo va al pin <quote>envío de
	    datos</quote> en el otro extremo. Este es el tipo de cable a
	    utilizar para conectar un modem a su sistema FreeBSD, y
	    también es apropiado para algunas terminales.</para>
	</sect4>
      </sect3>

      <sect3 xml:id="term-ports">
	<title>Puertos</title>

        <para>Puertos serie son los dispositivos a través de los
          cuales los datos son transferidos entre una computadora FreeBSD
          y la terminal. Esta sección describe los tipos de puertos
          que existen y como son referidos en FreeBSD.</para>

	<sect4 xml:id="term-portkinds">
	  <title>Tipos de puertos</title>

          <para>Existen varios tipos de puertos serie. antes de comprar o
            construir un cable, necesita asegurarse que coincida con los
            puertos en su terminal y en su sistema FreeBSD.</para>

          <para>La mayoría de las terminales tienen puertos DB25.
            Computadoras personales, incluyendo PCs corriendo FreeBSD,
            tienen puertos DB25 o DB9. Si tiene una tarjeta multipuertos
            serie para su PC, tal vez tenga puertos RJ-12 o RJ-45.</para>

          <para>Vea la documentación que acompaña su hardware
	    para las especificaciones sobre el tipo de puerto en uso. Una
            inspección visual del puerto también funciona en
            la mayoría de los casos.</para>
	</sect4>

	<sect4 xml:id="term-portnames">
	  <title>Nombres de puerto</title>

          <para>En FreeBSD, se accesa cada puerto serie a través de
            una entrada en el directorio <filename>/dev</filename>. Existen
            dos tipos de entradas:</para>

	  <itemizedlist>
	    <listitem>
              <para>Puertos de llamada-entrante
                son llamados <filename>/dev/ttydN</filename>
                donde <replaceable>N</replaceable> es el número de
		puerto, iniciando desde cero. Generalmente, los puertos de
                llamada-entrante se utilizan para terminales. Los puertos
                de llamada-entrante requieren que la línea
		serie especifique la señal data carrier detect (DCD)
		para funcionar correctamente.</para>
            </listitem>

	    <listitem>
              <para>Puertos de llamada-saliente
                son llamados <filename>/dev/cuaaN</filename>.
                Usualmente no se utilizan los puertos de llamada-saliente
                para terminales, solo para modems. Puede utilizar el puerto
                de llamada-saliente si el cable serie o la terminal no
                soporta la señal de carrier detect.</para>
	    </listitem>
	  </itemizedlist>

          <para>Si tiene conectada una terminal al primer puerto serie
            (<filename>COM1</filename> en &ms-dos;), entonces usará
            <filename>/dev/ttyd0</filename> para referirse a la terminal. Si
            la terminal está en el segundo puerto serie (también
            conocido como <filename>COM2</filename>), utilice
            <filename>/dev/ttyd1</filename>, y así sucesivamente.
	    </para>

	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Configuración del kernel</title>

      <para>FreeBSD soporta cuatro puertos serie por omisión.
        en el mundo &ms-dos; éstos son conocidos como
        <filename>COM1</filename>,
        <filename>COM2</filename>,
        <filename>COM3</filename>, y
        <filename>COM4</filename>. FreeBSD actualmente soporta
        tarjetas de interfaz serie <quote>tontas</quote>, como la
        BocaBoard 1008 y 2016, así como tarjetas multipuerto
        más inteligentes como las fabricadas por Digiboard
        y Stallion Technologies. De cualquier manera, el kernel por
        omisión solo busca por los puertos COM estándares.
	</para>

      <para>Para ver si su kernel reconoce cualquiera de sus puertos serie,
        mire los mensajes mientras el kernel esta arrancando, o utilice el
        comando <command>/sbin/dmesg</command> para repetir los mensajes de
        arranque del kernel. En particular busque por mensajes que inicien
        con el caracter <literal>sio</literal>.</para>

      <tip><para>Para ver solamente los mensajes que contienen
        la palabra <literal>sio</literal>, use el comando:</para>

      <screen>&prompt.root; <userinput>/sbin/dmesg | grep 'sio'</userinput></screen>
      </tip>

      <para>Por ejemplo, en un sistema con cuatro puertos serie, éstos
        son los mensajes de arranque del kernel específicos de puerto
        serie:</para>

      <screen>sio0 at 0x3f8-0x3ff irq 4 on isa
sio0: type 16550A
sio1 at 0x2f8-0x2ff irq 3 on isa
sio1: type 16550A
sio2 at 0x3e8-0x3ef irq 5 on isa
sio2: type 16550A
sio3 at 0x2e8-0x2ef irq 9 on isa
sio3: type 16550A</screen>

      <para>Si su kernel no reconoce todos sus puertos serie,
        probablemente necesitará configurar un kernel
        FreeBSD personalizado para su sistema. Para información
        detallada sobre configurar su kernel, por favor vea <xref linkend="kernelconfig"/>.</para>

      <para>Las líneas de dispositivo relevantes para su fichero
        de configuración del kernel podrín verse de esta
        manera, para FreeBSD&nbsp;4.X:</para>

      <programlisting>device		sio0	at isa? port IO_COM1 irq 4
device		sio1	at isa? port IO_COM2 irq 3
device		sio2	at isa? port IO_COM3 irq 5
device		sio3	at isa? port IO_COM4 irq 9</programlisting>


      <para>y de esta manera, para FreeBSD&nbsp;5.X:</para>

      <programlisting>device		sio</programlisting>

      <para>Puede comentar o remover completamente líneas de
        dispositivos que no tenga en el caso de FreeBSD&nbsp;4.X;
        para FreeBSD&nbsp;5.X tiene que editar su fichero
        <filename>/boot/device.hints</filename> para configurar
        sus puertos serie. Por favor diríjase a la página
        de manual &man.sio.4; para mayor información sobre
        puertos serie y configuración de tarjetas multipuertos.
        Tenga cuidado si está utilizando un fichero de
	configuración que fué usado anteriomente para una
	versión diferente de FreeBSD porque las banderas de
	dispositivo y la sintaxis han cambiado entre versiones.</para>

      <note>
	<para><literal>port IO_COM1</literal> es una substitución para
	  <literal>port 0x3f8</literal>, <literal>IO_COM2</literal> es
	  <literal>0x2f8</literal>, <literal>IO_COM3</literal> es
	  <literal>0x3e8</literal>, y <literal>IO_COM4</literal> es
	  <literal>0x2e8</literal>, las cuales son direcciones de puerto
	  comunes para sus respectivos puertos serie; interrupciones 4,3,5 y
	  9 son peticiones comunes de líneas de interrupción.
	  Note también que puertos serie regulares
	  <emphasis>no pueden</emphasis> compartir interrupciones en PCs con
	  bus ISA (las tarjetas multipuerto tienen electrónicos que
	  les permiten a los 16550A's compartir una o dos líneas de
	  peticiones de interrupción).</para>
      </note>

    </sect2>

    <sect2>
      <title>Archivos especiales de dispositivo</title>

      <para>La mayoría de dispositivos en el kernel son accesados
        a través de <quote>ficheros especiales de dispositivo</quote>,
        los cuales están localizados en el directorio
	<filename>/dev</filename>.  Los dispositivos
	<filename>sio</filename> son accesados a través de los
	dispositivos
	<filename>/dev/ttydN</filename> (dial-in)
        y <filename>/dev/cuaaN</filename>
        (call-out). FreeBSD provee también dispositivos de
	inicialización
        (<filename>/dev/ttyidN</filename> y
        <filename>/dev/cuaiaN</filename>) y
        dispositivos de bloqueo
        (<filename>/dev/ttyldN</filename> y
        <filename>/dev/cualaN</filename>).
        Los dispotivos de inicialización son utilizados para
        inicializar los parámetros de comunicación de puerto
        cada vez que un puerto es abierto, como
        <literal>crtscts</literal> para modems que utilizan
        señalización <literal>RTS/CTS</literal> para
        control de flujo. Los dispositivos de bloqueo son utilizados
        para bloquear banderas en puertos y prevenir que usuarios o
        programas cambien ciertos parámetros; vea las páginas
        de manual &man.termios.4;, &man.sio.4;, y &man.stty.1; para
        información de las propiedades de terminales, bloqueo
        e inicialización de dispositivos y aplicación de
        opciones de terminal, respectivamente.</para>

      <sect3>
	<title>Creando ficheros de dispositivo especiales</title>

        <note><para>FreeBSD&nbsp;5.0 incluye el sistema de
          ficheros &man.devfs.5; el cual crea automáticamente
          nodos de dispositivos según se necesiten.
          si está corriendo una versión de FreeBSD
          con <literal>devfs</literal> habilitado entonces puede
          saltarse esta sección.</para></note>

        <para>Un script de shell llamado <command>MAKEDEV</command>
          en el directorio <filename>/dev</filename> administra los
          ficheros especiales de dispositivo. Para utilizar
	  <command>MAKEDEV</command> para crear un fichero especial de
	  dispositivo dial-up para <filename>COM1</filename> (port 0),
          <command>cd</command> a <filename>/dev</filename> y ejecute
          el comando <command>MAKEDEV ttyd0</command>. De la misma
          manera, para crear ficheros especiales de dispositivo para
          <filename>COM2</filename> (port 1), utilice
          <command>MAKEDEV ttyd1</command>.</para>

        <para><command>MAKEDEV</command> no crea solamente el
          fichero especial de dispositivo
          <filename>/dev/ttydN</filename>
          también crea los nodos
          <filename>/dev/cuaaN</filename>,
          <filename>/dev/cuaiaN</filename>,
          <filename>/dev/cualaN</filename>,
          <filename>/dev/ttyldN</filename>,
          y
          <filename>/dev/ttyidN</filename>.</para>

        <para>Despues de crear ficheros especiales de dispositivo nuevos,
          asegúrese de revisar los permisos en los ficheros
          (especialmente los ficheros <filename>/dev/cua*</filename>)
          para asegurarse que solamente los usuarios que deben tener
          acceso a esos ficheros especiales de dispositivo puedan leer
          y escribir en ellos &mdash; probablemente no desee permitir
          al usuario promedio utilizar sus modems para marcar al exterior.
          Los permisos por omisión en los ficheros
          <filename>/dev/cua*</filename> deberían ser suficientes:
	  </para>

	<screen>crw-rw----    1 uucp     dialer    28, 129 Feb 15 14:38 /dev/cuaa1
crw-rw----    1 uucp     dialer    28, 161 Feb 15 14:38 /dev/cuaia1
crw-rw----    1 uucp     dialer    28, 193 Feb 15 14:38 /dev/cuala1</screen>

        <para>Estos permisos permiten al usuario <systemitem class="username">uucp</systemitem> y
          usuarios en el grupo <systemitem class="username">dialer</systemitem> utilizar
	  dispositivos call-out.</para>
      </sect3>
    </sect2>


    <sect2 xml:id="serial-hw-config">
      <title>Configuración de puerto serie</title>

    <indexterm><primary><filename>ttyd</filename></primary></indexterm>
    <indexterm><primary><filename>cuaa</filename></primary></indexterm>

    <para>El dispositivo <filename>ttydN</filename>
      (o <filename>cuaaN</filename>) es el
      dispositivo regular que usted deseará abrir para sus
      aplicaciones. Cuando un proceso abre el dispositivo, tendrá un
      conjunto por omisión de propiedades de terminal E/S. Puede ver
      estas propiedades con el comando</para>

    <screen>&prompt.root; <userinput>stty -a -f /dev/ttyd1</userinput></screen>

    <para>Cuando cambia las propiedades de este dispositivo, las propiedades
      son efectivas hasta que el dispositivo es cerrado. Cuando es reabierto
      regresa a las propiedades por omisión. Para realizar cambios
      al conjunto por omisión, usted puede abrir y ajustar las
      propiedades del dispositivo de <quote>estado inicial</quote> . Por
      ejemplo, para activar el modo <option>CLOCAL</option>,
      comunicación de 8 bits y control de flujo
      <option>XON/XOFF</option> por omisión para
      <filename>ttyd5</filename>, teclée:</para>

    <screen>&prompt.root; <userinput>stty -f /dev/ttyid5 clocal cs8 ixon ixoff</userinput></screen>

    <indexterm>
      <primary>rc files</primary>
      <secondary><filename>rc.serial</filename></secondary>
    </indexterm>

    <!-- XXX; /etc/rc.serial is gone in 5.1.
      How do you set default parameters for these devices in 5.X ? -->

    <para>La inicialización para todo el sistema de los
      dispositivos serie es controlada en <filename>/etc/rc.serial</filename>.
      Este fichero afecta las propiedades por omisión de
      dispositivos serie.</para>

    <para>Para prevenir que ciertas propiedades sean cambiadas
      por una aplicación, haga ajustes al dispositivo
      <quote>bloquear estado</quote>. Por ejemplo, para confinar
      la velocidad en <filename>ttyd5</filename> a 57600&nbsp;bps,
      teclée:</para>

    <screen>&prompt.root; <userinput>stty -f /dev/ttyld5 57600</userinput></screen>

    <para>Ahora, una aplicación que abra
      <filename>ttyd5</filename> y trate de cambiar la velocidad
      del puerto se mantendrá con 57600&nbsp;bps.</para>

    <indexterm>
      <primary><command>MAKEDEV</command></primary>
    </indexterm>
    <para>Naturalmente, debería crear los dispositivos de  estado
      inicial y bloqueo de estado escribible únicamente para la
      cuenta <systemitem class="username">root</systemitem> .</para>
    </sect2>
  </sect1>

  <sect1 xml:id="term">
    <info><title>Terminales</title>
      <authorgroup>
        <author><personname><firstname>Sean</firstname><surname>Kelly</surname></personname><contrib>Contribuido por</contrib></author>
	<!-- 28 July 1996 -->
      </authorgroup>
    </info>
    

    <indexterm><primary>terminals</primary></indexterm>

    <para>Las terminales proveen una manera conveniente y de bajo coste
      de accesar su sistema FreeBSD cuando no se encuentra en la
      consola de la computadora o en una red conectada. Esta
      sección describe como utilizar terminales con FreeBSD.</para>

    <sect2 xml:id="term-uses">
      <title>Usos y tipos de terminales</title>

      <para>Los sistemas originales &unix; no tenín consolas.
        En su lugar la gente se firmaba y corría programas a
	través de terminales conectadas a los puertos serie de la
	computadora. Es bastante similar a usar un modem y un programa de
	terminal para marcar hacia un sistema remoto para hacer trabajo en
	modo texto.</para>

      <para>Las PCs actuales tienen consolas con gráficos de
        alta calidad, pero la habilidad para establecer una sesión en
	un puerto serie todavía existe en casi cualquier sistema
	operativo &unix; al día de hoy; FreeBSD no es la
	excepción.  Utilizando una terminal conectada a un puerto
	serie libre, usted puede accesar y correr cualquier programa de
	texto que podría correr normalmente en la consola o
	en una ventana <command>xterm</command> en el sistema X Window.</para>

      <para>Para el usuario corporativo, se pueden conectar muchas terminales
        a un sistema FreeBSD y ponerlas en los escritorios de sus empleados.
        Para un usuario casero, una computadora de reserva, como una IBM PC
        más antigua o una &macintosh;, puede ser una terminal cableada
        a una computadora más poderosa corriendo FreeBSD. Puede
	convertir lo que de otra manera sería una computadora de un
	solo usuario en un poderoso sistema de usuarios múltiples.
	</para>

      <para>Para FreeBSD, existen tres clases de terminales:</para>

      <itemizedlist>
	<listitem>
	  <para><link linkend="term-dumb">Terminales tontas</link></para>
	</listitem>

	<listitem>
	  <para><link linkend="term-pcs">PCs actuando como terminales</link></para>
	</listitem>

	<listitem>
	  <para><link linkend="term-x">Terminales X</link></para>
	</listitem>
      </itemizedlist>

      <para>Las subsecciones siguientes describen cada tipo.</para>

      <sect3 xml:id="term-dumb">
	<title>Terminales tontas</title>

        <para>Terminales tontas son piezas de hardware especializadas que
          le permiten conectar a computadoras a través de líneas
          serie. Son llamadas <quote>tontas</quote> porque solo tienen
          poder computacional suficiente para desplegar, enviar y recibir
          texto. No puede ejecutar ningún programa en ellas. Es la
          computadora a la cual se conectan la que tiene todo el poder para
          correr editores de texto, compiladores, correo electrónico,
          juegos, y demás.</para>

        <para>Existen cientos de tipos de terminales tontas hechas por
          muchos fabricantes, incluyendo VT-100 de Digital Equipment
          Corporation y WY-75 de Wyse. Cualquier tipo funcionará con
          FreeBSD. Algunas terminales superiores pueden incluso desplegar
          gráficos, pero solo ciertos paquetes de software pueden
          tomar ventaja de estas funciones avanzadas.</para>

        <para>Las terminales tontas son populares en ambientes de trabajo
          donde los trabajadores no necesitan acceso a aplicaciones
	  gráficas como las que provee el sistema X Window.</para>
      </sect3>

      <sect3 xml:id="term-pcs">
	<title>PCs actuando como terminales</title>

        <para>Si una <link linkend="term-dumb">terminal tonta</link> tiene
          apenas la habilidad para desplegar, enviar y recibir texto, entonces
          ciertamente cualquier computadora personal de reserva puede ser una
          terminal tonta. Todo lo que necesita es el cable apropiado y
	  algún software de <emphasis>emulación de
	  terminal</emphasis> para correr en la computadora.</para>

        <para>Tal configuración es popular en hogares. Por ejemplo, si
          su consorte se encuentra ocupado trabajando en la consola de
	  su sistema FreeBSD, usted puede realizar algún trabajo en
	  modo texto al mismo tiempo desde una computadora personal menos
	  poderosa conectada como una terminal al sistema FreeBSD.</para>
      </sect3>

      <sect3 xml:id="term-x">
	<title>Terminales X</title>

        <para>Las terminales X son el tipo más sofisticado de
          terminal disponible. En lugar de conectar a un puerto serie,
          usualmente se conectan a una red como Ethernet. En lugar de
          ser relegadas a aplicaciones de modo texto pueden desplegar
          aplicaciones X.</para>

        <para>Hemos introducido terminales X solo por complementar. Sin
          embargo, este capítulo <emphasis>no</emphasis> cubre
          instalación, configuración o uso de terminales
          X.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="term-config">
      <title>Configuración</title>

      <para>Esta sección describe lo que necesita para configurar en
        su sistema FreeBSD y permitirle habilitar sesiones de entrada en una
        terminal. Asume que ya tiene configurado su kernel para soportar el
        puerto serie al cual la terminal está conectada&mdash;y
        que la tiene conectada.</para>

      <para>Recuerde del <xref linkend="boot"/> que
        el proceso <command>init</command> es responsable del control
        e inicialización de todos los procesos al inicio del
        sistema. Una de las tareas ejecutadas por
        <command>init</command> es leer el
        fichero <filename>/etc/ttys</filename> e iniciar un proceso
        <command>getty</command> en las terminales disponibles.
        El proceso <command>getty</command> es responsable de leer
        un nombre de entrada e iniciar el programa  <command>login</command> .</para>

      <para>Así, para configurar terminales para su sistema
        FreeBSD los siguientes pasos deben hacerse como <systemitem class="username">root</systemitem>:</para>

      <procedure>
	<step>
          <para>Agregue una línea a <filename>/etc/ttys</filename> para
            la entrada en el directorio <filename>/dev</filename> para el
	    puerto serie si todavía no se encuentra ahí.</para>
	</step>

	<step>
          <para>Especifique que <command>/usr/libexec/getty</command> sea
            ejecutado en el puerto, y especifique el tipo apropiado de
            <replaceable>getty</replaceable> desde el fichero
            <filename>/etc/gettytab</filename> .</para>
	</step>

	<step>
	  <para>Especifique el tipo de terminal por omisión.</para>
	</step>

	<step>
	  <para>Ponga el puerto a <quote>on.</quote></para>
	</step>

	<step>
	  <para>Especifique si el puerto debe ser o no
	    <quote>seguro.</quote></para>
	</step>

	<step>
	  <para>Obligue a  <command>init</command> a releer el fichero
	    <filename>/etc/ttys</filename> .</para>
	</step>
      </procedure>

      <para>Como un paso opcional, tal vez desee crear un tipo
        <replaceable>getty</replaceable> personalizado para utilizar en el
        paso 2 mediante una entrada en  <filename>/etc/gettytab</filename>.
        Este capítulo no explica como realizarlo; por lo que se le
        exhorta a leer las páginas de manual &man.gettytab.5; y
        &man.getty.8; para mayor información.</para>

      <sect3 xml:id="term-etcttys">
	<title>Agregando una entrada a <filename>/etc/ttys</filename></title>

        <para>El fichero <filename>/etc/ttys</filename> lista todos los
          puertos en su sistema FreeBSD donde quiere permitir logins. Por
          ejemplo, la primera consola virtual <filename>ttyv0</filename> tiene
          una entrada en este fichero. Puede firmarse en la consola utilizando
          esta entrada. Este fichero también contiene entradas para las
          otras consolas virtuales, puertos serie y pseudo-ttys. Para una
          terminal conectada por cable, solo liste la entrada <filename>/dev</filename>
          del puerto serie sin la parte de <filename>/dev</filename> (por ejemplo,
          <filename>/dev/ttyv0</filename> debería estar listado como
          <filename>ttyv0</filename>).</para>

        <para>Una instalación por omisión de FreeBSD
          incluye un fichero <filename>/etc/ttys</filename> con soporte
          para los primeros cuatro puertos serie: <filename>ttyd0</filename>
          hasta <filename>ttyd3</filename>. Si está conectando una
          terminal a uno de esos puertos, no necesita agregar otra entrada.</para>

	<example xml:id="ex-etc-ttys">
	  <title>Agregando entradas de terminal a
	    <filename>/etc/ttys</filename></title>

          <para>Suponga que quisiéramos conectar dos terminales
            al sistema: una Wyse-50 y una vieja IBM PC 286 corriendo
            el software de terminal <application>Procomm</application>
            emulando una terminal VT-100. Conectamos la Wyse al segundo
            puerto serie y la 286 al sexto puerto serie (un puerto
            en una tarjeta multipuerto serie). Las entradas correspondiente
            en el fichero <filename>/etc/ttys</filename> se verían
            como esto:</para>

	  <programlisting>ttyd1<co xml:id="co-ttys-line1col1"/>  "/usr/libexec/getty std.38400"<co xml:id="co-ttys-line1col2"/>  wy50<co xml:id="co-ttys-line1col3"/>  on<co xml:id="co-ttys-line1col4"/>  insecure<co xml:id="co-ttys-line1col5"/>
ttyd5   "/usr/libexec/getty std.19200"  vt100  on  insecure
	  </programlisting>

	  <calloutlist>
	    <callout arearefs="co-ttys-line1col1">
              <para>El primer campo normalmente especifica el nombre
                de fichero especial de la terminal como es hallado
                en <filename>/dev</filename>.</para>
	    </callout>
	    <callout arearefs="co-ttys-line1col2">

              <para>El segundo campo es el comando a ejecutar por
                esta línea, el cual es usualmente &man.getty.8;.
                <command>getty</command> inicializa y abre la línea,
                establece la velocidad, pregunta por un nombre de usuario
                y entonces ejecuta el programa &man.login.1; .</para>

              <para>El programa <command>getty</command> acepta un
                parámetro (opcional) en su línea de
                comando, el tipo <replaceable>getty</replaceable>. Un
                tipo <replaceable>getty</replaceable> configura características
                en la línea de terminal, como tasa de bps y
                paridad. El programa <command>getty</command> lee
                estas características desde el fichero
                <filename>/etc/gettytab</filename>.</para>

              <para>El fichero <filename>/etc/gettytab</filename>
                contiene muchas entradas para líneas de terminal
                viejas y nuevas. En la mayoría de los casos, las
                entradas que empiezan con el texto <literal>std</literal>
                funcionarán para terminales conectadas físicamente.
                Estas entradas ignoran la paridad.
                Existe una entrada <literal>std</literal> por cada
                tasa de bps de 110 a 115200. Por supuesto puede agregar
                sus propias entradas a este fichero. La página de
                manual &man.gettytab.5; provee mayor información.</para>

              <para>Al establecer el tipo <replaceable>getty</replaceable>
                en el fichero <filename>/etc/ttys</filename>, asegúrese
                que las propiedades de comunicaciones en la terminal
                concuerden.</para>

              <para>Para nuestro ejemplo, la Wyse-50 no usa paridad
                y conecta a 38400&nbsp;bps. La 286&nbsp;PC no usa paridad y
                conecta a 19200&nbsp;bps.</para>

	    </callout>

	    <callout arearefs="co-ttys-line1col3">

              <para>El tercer campo es el tipo de terminal usualmente
                conectado a esa línea tty. Para puertos dial-up,
                <literal>unknown</literal> o
                <literal>dialup</literal> son usados típicamente
                en este campo puesto que los usuarios pueden marcar
                prácticamente con cualquier tipo de terminal o
                de software. Para terminales conectadas físicamente,
                el tipo de terminal no cambia, así que puede
                poner un tipo de terminal real del fichero de base
                de datos &man.termcap.5; en este campo.</para>

              <para>Para nuestro ejemplo, la Wyse-50 utiliza el
                tipo de terminal real mientras que la PC 286
                corriendo <application>Procomm</application> será
                puesta a emular una VT-100. </para>

	    </callout>

	    <callout arearefs="co-ttys-line1col4">
              <para>El cuarto campo especifica si el puerto debe
                habilitarse. Poniendo <literal>on</literal> aquí
                provocará que el proceso <command>init</command> inicie
                el programa en el segundo campo, <command>getty</command>.
                Si pone <literal>off</literal> en este campo, no habrá
                <command>getty</command>, y por consecuencia ningun login
                en el puerto.</para>
	    </callout>

	    <callout arearefs="co-ttys-line1col5">
              <para>El último campo es utilizado para especificar
                si el puerto es seguro. Marcar un puerto como seguro
                significa que se confía en él lo suficiente
                para permitir que la cuenta <systemitem class="username">root</systemitem>
                (o cualquier cuenta con un ID de usuario 0) se firme
                desde ese puerto. Los puertos inseguros no permiten
                entradas de <systemitem class="username">root</systemitem>.
                En un puerto inseguro, los usuarios deben firmarse desde
                cuentas sin privilegios y entonces utilizar &man.su.1;
                o un mecanismo similar para acceder a privilegios de
                superusuario.</para>

              <para>Es altamente recomendable que utilize
                <quote>insecure</quote> incluso para terminales
                que se encuentran detrás de puertas con
                llave. Es muy sencillo entrar y usar <command>su</command> si
                necesita privilegios de superusuario.</para>
	    </callout>
	  </calloutlist>
	</example>
      </sect3>

      <sect3 xml:id="term-hup">
	<title>Forzar <command>init</command> a que relea
	  <filename>/etc/ttys</filename></title>

        <para>Despues de realizar los cambios necesarios al fichero
          <filename>/etc/ttys</filename> debería
          mandar una señal SIGHUP (hangup) al proceso <command>init</command>
          para forzarlo a releer su fichero de configuración.
          Por ejemplo:</para>

	<screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

	<note>
          <para><command>init</command> siempre es el primer proceso
            que corre en un sistema, por lo tanto siempre tendrá
            el PID 1.</para>
	</note>

        <para>Si todo está puesto correctamente, todos los cables
          en su lugar, y las terminales están encendidas,
          entonces un proceso <command>getty</command> debe estar
          corriendo en cada terminal y debería ver prompts
          de entrada en sus terminales en este punto.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="term-debug">
      <title>Determinando errores en su conexión</title>

      <para>Incluso con la más meticulosa etención al detalle, algo
        puede salir mal mientras se configura una terminal. Esta es una lista de
        síntomas y algunos arreglos sugeridos.</para>

      <sect3>
	<title>No aparece prompt de login</title>

        <para>Asegúrese que la terminal está conectada y
          encendida, asegúrese que se encuentra ejecutando un
          software de emulación de terminal en el puerto serie
          correcto.</para>

        <para>Asegúrese que el cable está conectado firmemente
          tanto a la terminal como a la computadora FreeBSD. Asegúrese
          que es el tipo correcto de cable.</para>

        <para>Asegúrese que la terminal y FreeBSD concuerdan en la tasa
          de bps y propiedades de paridad. Si tiene una terminal de desplegado
          de video, asegúrese que los controles de contraste y brillo
          estén encendidos. Si es una terminal de impresión, asegúrese
          que papel y tinta se encuentren en forma.</para>

        <para>Asegúrese que un proceso <command>getty</command> esté
          corriendo y sirviendo la terminal. Por ejemplo, para obtener una lista
          de procesos <command>getty</command> con
          <command>ps</command>, teclée:</para>

        <screen>&prompt.root; <userinput>ps -axww|grep getty</userinput></screen>

        <para>Debería ver una entrada para la terminal.
          Por ejemplo, el siguiente desplegado muestra que un
          <command>getty</command> está corriendo en el
          segundo puerto serie <literal>ttyd1</literal> y está
          utilizando la entrada
          <literal>std.38400</literal> en
          <filename>/etc/gettytab</filename>:</para>

	<screen>22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyd1</screen>

        <para>Si no hay un proceso <command>getty</command> corriendo,
          asegúrese que tiene habilitado el puerto en
          <filename>/etc/ttys</filename>.
          Recuerde también ejecutar <command>kill -HUP 1</command>
          despues de modificar el fichero <filename>ttys</filename>.</para>

        <para>Si el proceso <command>getty</command> está corriendo
          pero la terminal todavía no despliega un prompt de
          login, o si despliega un prompt pero no le permite escribir,
          su terminal o cable tal vez no soporte inicialización
          por hardware. Trate cambiar la entrada en
          <filename>/etc/ttys</filename> de
          <literal>std.38400</literal> a
          <literal>3wire.38400</literal> recuerde correr
          <command>kill -HUP 1</command> despues de modificar
          <filename>/etc/ttys</filename>. La entrada
          <literal>3wire</literal> es similar a
          <literal>std</literal>, pero ignora la inicialización
          por harware. Tal vez necesite reducir la tasa de baudios
          o habilitar control de flujo por software cuando utilice
          <literal>3wire</literal> para prevenir desbordamientos
          de buffer.</para>

      </sect3>

      <sect3>
	<title>Si aparece basura en lugar de un prompt de login</title>

        <para>Asegúrese que la terminal y FreeBSD concuerdan en la
          tasa de bps y propiedades de paridad. Revise los procesos
          <command>getty</command> para asegurarse que el tipo correcto
          de <replaceable>getty</replaceable> está en uso. Si no
          es así, edite <filename>/etc/ttys</filename> y ejecute
          <command>kill -HUP 1</command>.</para>

      </sect3>

      <sect3>
	<title>Los caracteres aparecen doble; las contraseñas aparecen cuando se escriben</title>

        <para>Cambie la terminal (o el software de emulación de
          terminal) de <quote>half duplex</quote> o <quote>local echo</quote> a
          <quote>full duplex.</quote></para>

      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="dialup">
    <info><title>Servicio dial-in</title>
      <authorgroup>
	<author><personname><firstname>Guy</firstname><surname>Helmer</surname></personname><contrib>Contribuido por </contrib></author>
      </authorgroup>
      <authorgroup>
        <author><personname><firstname>Sean</firstname><surname>Kelly</surname></personname><contrib>Adiciones por </contrib></author>
      </authorgroup>
    </info>
    
    <indexterm><primary>dial-in service</primary></indexterm>

    <para>Configurar su sistema FreeBSD para servicio dial-in es muy
      similar a conectar terminales excepto que en lugar de lidiar con
      terminales se hace con modems.</para>

      <sect2>
	<title>Modems externos vs. internos</title>

        <para>Los modems externos parecen ser más convenientes para
          dial-up, debido a que los modems externos con frecuencia pueden
          ser configurados semi permanentemente vía parámetros
          almacenados en RAM no volatil y usualmente proveen indicadores
          luminosos que despliegan el estado de señales importantes RS-232.
          Luces parpadeantes impresionan a los visitantes, pero las luces son
          también útiles para ver si un modem se encuentra
          operando adecuádamente.</para>

        <para>Los modems internos usualmente carecen de RAM no volatil,
          entonces su configuración puede estar limitada a
          especificar DIP switches. Si su modem interno cuenta con
          algún indicador luminoso de señales, es probablemente
          dificil observar las luces cuando el sistema está cubierto
          y en su lugar.</para>

      <sect3>
	<title>Modems y cables</title>
	<indexterm><primary>modem</primary></indexterm>

        <para>Si se encuentra utilizando un modem externo, entonces
          necesitará por supuesto un cable adecuado. Un cable
          serie estándar RS-232C debe ser suficiente mientras
          todas las señales normales sean cableadas:</para>

	<itemizedlist>
	  <listitem>
	    <para>Transmitted Data (<acronym>TD</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Received Data (<acronym>RD</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Request to Send (<acronym>RTS</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Clear to Send (<acronym>CTS</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Data Set Ready (<acronym>DSR</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Data Terminal Ready (<acronym>DTR</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Carrier Detect (<acronym>CD</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Signal Ground (<acronym>SG</acronym>)</para>
	  </listitem>
	</itemizedlist>

        <para>FreeBSD necesita las señales <acronym>RTS</acronym> y
          <acronym>CTS</acronym> para control de flujo a velocidades
          mayores a 2400&nbsp;bps, la señal <acronym>CD</acronym> para
          detectar cuando una llamada ha sido respondida o la línea ha
          sido colgada, y la señal <acronym>DTR</acronym> para reiniciar el
          modem despues de completar una sesión.
          Algunos cables son hechos sin incluir todas las señales necesarias,
          así que si tiene problemas, como cuando una sesión no
          finaliza cuando la línea es colgada, tal vez el problema se
          deba al cable.</para>

        <para>Como otros sistemas operativos tipo &unix;, FreeBSD utiliza
          las señales de hardware para saber cuando una llamada ha sido
          contestada o una línea ha sido colgada y poder colgar
          y reiniciar el modem despues de una llamada. FreeBSD evita
          enviar comandos al modem o esperar por reportes de estado del
          modem. Si está familiarizado con la conexión de
          modems una PC funcionando como BBS, tal ves esto parezca extraño.</para>
      </sect3>
      </sect2>

      <sect2>
	<title>Consideraciones de interfaces serie</title>

        <para>FreeBSD soporta interfaces de comunicación  NS8250-,
          NS16450-, NS16550-, y  NS16550A-basado en EIA RS-232C (CCITT V.24).
          Los dispositivos 8250 y 16450 tienen buffers de un solo caracter.
          El dispositivo 16550 brinda un buffer de 16 caracteres, el cual
          permite un mejor desempeño del sistema. (Errores en 16550 simple
          impiden el uso del buffer de 16 caracteres, así que utilice
          16550A si es posible). Debido a que los dispositivos de buffer de
          un solo caracter requieren más trabajo del sistema operativo
          que los dispotivos de buffer de 16 caracteres, las tarjetas de
          interfaz serie basadas en 16550A son mayormente preferidas.
          Si el sistema tiene muchos puertos serie activos o tendrá
          una carga elevada, las tarjetas basadas en 16550A son mejores para
          comunicaciones con baja tasa de error.</para>
      </sect2>

    <sect2>
      <title>Revisión rápida</title>

      <indexterm><primary>getty</primary></indexterm>
      <para>Como con las terminales, <command>init</command>
        engendra un proceso <command>getty</command> para cada
        puerto serie configurado para conexiones dial-in.
        Por ejemplo, si un modem está conectado a
        <filename>/dev/ttyd0</filename>, el comando
        <command>ps ax</command> podría mostrar esto:</para>

      <screen> 4850 ??  I      0:00.09 /usr/libexec/getty V19200 ttyd0</screen>

      <para>Cuando un usuario marca la línea del modem y el modem
        conecta, la línea <acronym>CD</acronym> (Carrier Detect)
        es reportada por el modem.
        El kernel
        nota que se ha detectado una portadora y completa la apertura de
        <command>getty</command> del puerto. <command>getty</command>
        manda un prompt <prompt>login:</prompt> a la velocidad inicial
        de línea especificada. <command>getty</command> observa si
        se reciben caracteres válidos, y, en una configuración
        típica, si encuentra basura (probablemente debido a que la
        velocidad de conexión del modem es diferente a la velocidad
        de <command>getty</command>),  <command>getty</command> trata de
        ajustar la velocidad de la línea hasta que recibe caracteres
        razonables.</para>

      <indexterm>
        <primary><command>/usr/bin/login</command></primary>
      </indexterm>
      <para>Despues que el usuario entra su nombre de
        login, <command>getty</command> ejecuta
        <filename>/usr/bin/login</filename>, que completa
        la entrada preguntando por la contraseña del usuario y entonces
        inicia el shell del usuario.</para>
    </sect2>


    <sect2>
      <title>Archivos de configuración</title>

      <para>Existen tres ficheros de configuración del sistema
        en el directorio <filename>/etc</filename> que probablemente
        necesitará editar para permitir acceso de dial-up a su
        sistema FreeBSD. El primero, <filename>/etc/gettytab</filename>,
        contiene información de configuración para el
        daemon <filename>/usr/libexec/getty</filename>. El segundo,
        <filename>/etc/ttys</filename> contiene información que
        le dice a <filename>/sbin/init</filename> que dispositivos
        <filename>tty</filename> deben tener procesos <command>getty</command>
        corriendo. Por último, puede incluir comandos de inicialización
        de puerto en el script <filename>/etc/rc.serial</filename>.</para>

      <para>Existen dos escuelas de pensamiento en relación a modems dial-up
        en &unix;.
        Un grupo gusta de configurar sus modems y sistemas para que sin
        importar a que velocidad un usuario remoto marque, la interfaz local
        RS-232 computadora-a-modem corra a una velocidad fija. El beneficio
        de esta configuración es que el usuario remoto siempre obtiene
        un prompt de login del sistema inmediátamente.
        La desventaja es que el sistema no sabe cual es la tasa de datos
        verdadera del usuario, así que programas a pantalla completa
        como Emacs no ajustarán sus métodos de dibujado de
        pantalla para mejorar sus respuestas en conexiones más lentas.</para>

      <para>La otra escuela configura sus modems de interfaz RS-232 para variar
 	su velocidad basado en la velocidad de conexión del usuario remoto.
        Por ejemplo, conexiones V.32bis (14.4&nbsp;Kbps) al modem podrían
        hacer al modem correr su interfaz RS-232 a 19.2&nbsp;Kbps, mientras que
        conexiones 2400&nbsp;bps hacen correr la interfaz RS-232 del modem a
        2400&nbsp;bps. Debido a que <command>getty</command> no entiende
        el reporte de velocidad de conexión de cualquier modem,
        <command>getty</command> brinda un mensaje <prompt>login:</prompt> a una
        velocidad inicial y observa los caracteres que regresan en respuesta.
        Si el usuario recibe basura, se asume que sabe que debe presionar la
        tecla <keycode>Enter</keycode> hasta que reciba un prompt reconocible.
        Si la tasa de datos no concuerda, <command>getty</command> trata todo
        lo que el usuario escriba como <quote>basura</quote>, trata yendo a la
        siguiente velocidad y brinda el prompt <prompt>login:</prompt> de nuevo.
        Este procedimiento puede continuar hasta el cansancio, pero normalmente
        solo toma un teclazo o dos antes que el usuario reciba un prompt
        correcto. Obviamente, esta secuencia de login no parece tan limpia
        como el anterior método de <quote>velocidad fija</quote>, pero
        un usuario en una conexión de velocidad baja podría
        recibir una respuesta interactiva mejor desde programas a pantalla
        completa.</para>

      <para>Esta sección tratará de dar información de
        configuración balanceada, pero está cargada hacia tener la
        tasa de datos del modem siguiendo la tasa de conexión.</para>

      <sect3>
	<title><filename>/etc/gettytab</filename></title>

  <indexterm>
    <primary><filename>/etc/gettytab</filename></primary>
  </indexterm>
        <para><filename>/etc/gettytab</filename> es un fichero tipo
          &man.termcap.5; de información de configuración para
          &man.getty.8;. Por favor vea la página de manual &man.gettytab.5;
          para información completa del formato del fichero y la lista
          de capacidades.</para>

	<sect4>
	  <title>Configuración de velocidad fija</title>

          <para>Si está fijando la tasa de comunicación de datos
            de su modem a una velocidad particular, probablemente no necesitará
            ningún cambio a <filename>/etc/gettytab</filename>.</para>
	</sect4>

	<sect4>
	  <title>Configuración de velocidad concordante</title>

          <para>Necesitará crear una entrada en
            <filename>/etc/gettytab</filename> para darle información a
            <command>getty</command> acerca de las velocidades que desea usar
            para su modem. Si tiene un modem 2400&nbsp;bps, puede probablemente
            utilizar la entrada existente <literal>D2400</literal>.</para>

	  <programlisting>#
# Fast dialup terminals, 2400/1200/300 rotary (can start either way)
#
D2400|d2400|Fast-Dial-2400:\
        :nx=D1200:tc=2400-baud:
3|D1200|Fast-Dial-1200:\
        :nx=D300:tc=1200-baud:
5|D300|Fast-Dial-300:\
        :nx=D2400:tc=300-baud:</programlisting>

          <para>Si tiene un modem de mayor velocidad, probablemente necesite
            agregar una entrada en <filename>/etc/gettytab</filename>; aquí
            está una entrada que puede utilizar para un modem 14.4&nbsp;Kbps
            con una velociad de interfaz máxima de 19.2&nbsp;Kbps:</para>

	  <programlisting>#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:</programlisting>

          <para>esto resultará en una conexión de 8 bits, sin paridad.</para>

          <para>El ejemplo de arriba inicia la tasa de comunicaciones a 19.2&nbsp;Kbps
            (para conexiones V.32bis), entonces cicla a través de 9600&nbsp;bps
            (para V.32), 2400&nbsp;bps, 1200&nbsp;bps, 300&nbsp;bps, y de vuelta a
            19.2&nbsp;Kbps. El ciclado de la tasa de comunicaciones es implementado
            con la capacidad <literal>nx=</literal> (<quote>siguiente tabla</quote>).
            Cada una de las líneas usa una entrada
            <literal>tc=</literal> (<quote>continuación de tabla</quote>) para
            recoger el resto de las propiedades <quote>estándar</quote> para
            una tasa de datos en particular.</para>

          <para>Si tiene un modem 28.8&nbsp;Kbps y/o quiere tomar ventaja
            de la compresión en un modem 14.4&nbsp;Kbps, necesita
            utilizar una tasa de comunicaciones mayor a 19.2&nbsp;Kbps. Aquí
            hay un ejemplo de una entrada <filename>gettytab</filename> iniciando
            a 57.6&nbsp;Kbps:</para>

	  <programlisting>#
# Additions for a V.32bis or V.34 Modem
# Starting at 57.6 Kbps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:</programlisting>

          <para>Si tiene un CPU lento o un sistema muy cargado y no tiene
            puertos serie basados en 16550A, tal vez reciba errores en
            <errorname>sio</errorname>
            <quote>silo</quote> a 57.6&nbsp;Kbps.</para>
	</sect4>
      </sect3>

      <sect3 xml:id="dialup-ttys">
	<title><filename>/etc/ttys</filename></title>
	<indexterm>
	  <primary><filename>/etc/ttys</filename></primary>
	</indexterm>

        <para>La configuración del fichero <filename>/etc/ttys</filename>
          fué cubierto en <xref linkend="ex-etc-ttys"/>.
          La configuración para modems es similar pero debemos
          pasar un argumento diferente a <command>getty</command> y
          especificar un tipo diferente de terminal. El formato general
          tanto para configuración de velocidad fija y velocidad
          concordante es:</para>

	<programlisting>ttyd0   "/usr/libexec/getty <replaceable>xxx</replaceable>"   dialup on</programlisting>

        <para>El primer componente de la línea de arriba es el fichero
          de dispositivo especial para esta entrada &mdash; <literal>ttyd0</literal>
          significa que <filename>/dev/ttyd0</filename> es el fichero que
          <command>getty</command> estará vigilando. El segundo
          componente <literal>"/usr/libexec/getty
          xxx"</literal>
          (<replaceable>xxx</replaceable> será reemplazado por la
          capacidad inicial de <filename>gettytab</filename>) es el proceso
          que <command>init</command> ejecutará en el dispositivo.
          El tercer componente, <literal>dialup</literal>, es el tipo de
          terminal por omisión. El cuarto parámetro,
          <literal>on</literal>, le indica a <command>init</command> que
          la línea es operacional. Puede existir un quinto parámetro,
          <literal>secure</literal>, pero solo debería ser utilizado para
          terminales que estén físicamente seguras (como la consola
          del sistema).</para>

        <para>El tipo de terminal por omisión (<literal>dialup</literal>
          en el ejemplo de arriba) puede depender de preferencias locales.
          <literal>dialup</literal> es el tipo de terminal tradicional por
          omisión en líneas dial-up para que los usuarios
          puedan personalizar sus scripts de login para reconocer cuando
          la terminal es <literal>dialup</literal> y ajustar sus tipos de
          terminal automáticamente. De toda maneras, el autor encuentra
          más sencillo especificar en su sitio <literal>vt102</literal>
          como el tipo de terminal por omisión, puesto que los usuarios
          solo utilizan emulación VT102 en sus sistemas remotos.</para>

        <para>Despues de realizar los cambios a <filename>/etc/ttys</filename>,
          puede enviar al proceso <command>init</command> una señal <acronym>HUP</acronym>
          para que relea el fichero. Puede utilizar el comando

	<screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

          para mandar la señal. Si esta es su primera vez instalando el
          sistema, tal vez quiera esperar hasta que su(s) modem(s) estén
          configurados y conectados correctamente antes de señalizar a
          <command>init</command>.</para>

	<sect4>
	  <title>Configuración de velocidad fija</title>

          <para>Para una configuración de velocidad
            fija, su entrada <filename>ttys</filename> necesita tener una
            entrada de velocidad fija provista en <command>getty</command>.
            Para un modem cuya velocidad de puerto está fijada en
            19.2&nbsp;Kbps, la entrada <filename>ttys</filename> podría
            verse así:</para>

	  <programlisting>ttyd0   "/usr/libexec/getty std.19200"   dialup on</programlisting>

          <para>Si su modem está fijado a un velocidad de
            datos diferente, sustituya el valor apropiado por
            <literal>std.velocidad</literal>
            en lugar de <literal>std.19200</literal>. Asegúrese
            de usar un tipo válido listado en
            <filename>/etc/gettytab</filename>.</para>
	</sect4>

	<sect4>
	  <title>Configuración de velocidad concordante</title>

          <para>En una configuración de velocidad concordante su entrada
            <filename>ttys</filename> necesita referenciar el inicio de la entrada
            <quote>auto-baud</quote> (sic) en
            <filename>/etc/gettytab</filename>. Por ejemplo, si agregó la
            entrada sugerida arriba para un modem con velocidad concordante que
            inicia a 19.2&nbsp;Kbps (la entrada <filename>gettytab</filename>
            conteniendo el punto de inicio <literal>V19200</literal>), su entrada
            <filename>ttys</filename> podría verse como esta:</para>

	  <programlisting>ttyd0   "/usr/libexec/getty V19200"   dialup on</programlisting>
	</sect4>
      </sect3>

      <sect3>
	<title><filename>/etc/rc.serial</filename></title>
	<indexterm>
	  <primary>rc files</primary>
	  <secondary><filename>rc.serial</filename></secondary>
	</indexterm>

        <para>Modems de alta velocidad, como V.32, V.32bis, y V.34,
          necesitan usar control de flujo por hardware (<filename>RTS/CTS</filename>).
          Puede agregar comandos <command>stty</command> a
          <filename>/etc/rc.serial</filename> para activar la bandera
          de control de flujo por hardware en el kernel de FreeBSD para
          los puertos del modem.</para>

        <para>Por ejemplo para activar la bandera <literal>termios</literal>
          <varname>crtscts</varname> de dispositivos de inicialización
          dial-in y dial-out en el puerto serie #1
          (<filename>COM2</filename>), las siguientes líneas
          pueden agregarse a
          <filename>/etc/rc.serial</filename>:</para>
	<programlisting># Serial port initial configuration
stty -f /dev/ttyid1 crtscts
stty -f /dev/cuaia1 crtscts</programlisting>

      </sect3>
    </sect2>

    <sect2>
      <title>Propiedades del modem</title>

      <para>Si tiene un modem cuyos parámetros pueden ser activados
        permanentemente en RAM no volatil, necesitará utilizar un
        programa de terminal (como Telix en &ms-dos; o <command>tip</command> en
        FreeBSD) para activar los parámetros.
        Conecte al modem usando la misma velocidad de comunicación
        como velocidad inicial que <command>getty</command> usará y
        configure la RAM no volatil del modem para que concuerde con estos
        requerimientos:</para>

      <itemizedlist>
	<listitem>
	  <para><acronym>CD</acronym> activado cuando esté conectado</para>
	</listitem>

	<listitem>
	  <para><acronym>DTR</acronym> activado para operación; tirar DTR
	    cuelga la línea y reinicia el modem</para>
	</listitem>

	<listitem>
	  <para><acronym>CTS</acronym> control de flujo de datos transmitidos</para>
	</listitem>

	<listitem>
	  <para>Deshabilitar control de flujo <acronym>XON/XOFF</acronym></para>
	</listitem>

	<listitem>
	  <para><acronym>RTS</acronym> control de flujo de datos recibidos</para>
	</listitem>

	<listitem>
	  <para>Modo silencioso (sin códigos resultantes)</para>
	</listitem>

	<listitem>
	  <para>Sin eco de comandos</para>
	</listitem>
      </itemizedlist>

      <para>Por favor lea la documentación de su modem para saber
        que comandos y/o switches DIP necesita proporcionarle.</para>

      <para>Pro ejemplo, para activar los parámetros de arriba
        en un modem &usrobotics; &sportster; 14,400 externo, uno podría
        dar estos comandos al modem:</para>

      <programlisting>ATZ
AT&amp;C1&amp;D2&amp;H1&amp;I0&amp;R2&amp;W</programlisting>

      <para>Tal vez quiera también tomar esta oportunidad para
        ajustar otras propiedades en el modem, como si utilizará
        compresión V.42bis y/o MNP5.</para>

      <para>El modem &usrobotics; &sportster; 14,400 externo también posee
        switches DIP que necesitan activarse; para otros modems, tal vez pueda
        utilizar estas propiedades como un ejemplo:</para>

      <itemizedlist>
	<listitem>
	  <para>Switch 1: ARRIBA &mdash; DTR Normal</para>
	</listitem>

	<listitem>
	  <para>Switch 2: N/A (Códigos resultantes verbales/Códigos resultantes
	    numéricos)</para>
	</listitem>

	<listitem>
	  <para>Switch 3: ARRIBA &mdash; Suprimir códigos resultantes</para>
	</listitem>

	<listitem>
	  <para>Switch 4: ABAJO &mdash; No eco, comandos offline</para>
	</listitem>

	<listitem>
	  <para>Switch 5: ARRIBA &mdash; Auto respuesta</para>
	</listitem>

	<listitem>
	  <para>Switch 6: ARRIBA &mdash; Detección de señal Normal</para>
	</listitem>

	<listitem>
	  <para>Switch 7: ARRIBA &mdash; Cargar valores NVRAM por omisión</para>
	</listitem>

	<listitem>
	  <para>Switch 8: N/A (Modo inteligente/Modo tonto)</para>
	</listitem>
      </itemizedlist>

      <para>Códigos resultantes deberían ser deshabilitados
        o suprimidos para modems dial-up para evitar problemas que pueden
        ocurrir si <command>getty</command> erroneamente ofrece un prompt
        <prompt>login:</prompt> a un modem que se encuentra en modo de
        comandos y el modem hace eco del comando o regresa un código
        resultante. Esta secuencia puede resultar en una conversación
        larga y tonta entre <command>getty</command> y el modem.</para>

      <sect3>
	<title>Configuración de velocidad fija</title>

        <para>Para una configuración de velocidad fija necesitará
          configurar el modem para mantener una tasa de datos constante
          modem-a-computadora independiente de la tasa de comunicaciones.
          En un modem &usrobotics; &sportster; 14,400 externo estos comandos
          fijarán la tasa de datos modem-a-computadora a la velocidad
          utilizada para pasar los comandos:</para>

	<programlisting>ATZ
AT&amp;B1&amp;W</programlisting>
      </sect3>

      <sect3>
	<title>Configuración de velocidad concordante</title>

        <para>Para una configuración de velocidad variable necesitará
          configurar su modem para ajustar la tasa de datos de su puerto serie
          para que coincida con la tasa de llamada entrante. En un modem
          &usrobotics; &sportster; 14,400 externo estos comandos
          fijarán la tasa de corrección de errores de datos a la
          velocidad usada para pasar los comandos, pero le permite a la tasa del
          puerto serie variar para conexiones que no corrigen errores:</para>

	<programlisting>ATZ
AT&amp;B2&amp;W</programlisting>
      </sect3>

      <sect3>
	<title>Revisando la configuración del modem</title>

        <para>La mayoría de los modems de alta velocidad brindan
          comandos para ver los parámetros actuales de operación
          del modem en un modo entendible para humanos.
          En el modem &usrobotics; &sportster; 14,400 externo, el comando
          <command>ATI5</command> despliega los parámetros que están
          almacenados en la RAM no volatil. Para ver los parámetros reales
          de operación del modem (influenciado por los parámetros
          de los switches DIP del modem), utilice el comando <command>ATZ</command> y
          entonces <command>ATI4</command>.</para>

        <para>Si tiene una marca diferente de modem, revise el manual de
          su modem para ver como checar doblemente los parámetros de
          configuración de su modem.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Determinando errores</title>

      <para>Aquí hay unos cuantos pasos que puede seguir para revisar
        en sus sistema el modem dial-up.</para>

      <sect3>
	<title>Revisando el sistema FreeBSD</title>

        <para>Conecte su modem a su sistema FreeBSD, arranque el sistema, y,
          si su modem tiene luces de indicación de estado, mire si el
          indicador <acronym>DTR</acronym> del modem enciende cuando el prompt
          <prompt>login:</prompt> aparece en la consola del sistema
          &mdash; si enciende, eso debería significar que FreeBSD ha
          iniciado un proceso <command>getty</command> en el puerto de
          comunicaciones apropiado y está esperando a que el modem
          acepte la llamada.</para>

        <para>Si el indicador <acronym>DTR</acronym> no enciende, entre al
          sistema FreeBSD a travás de la consola y ponga un <command>ps
           ax</command> para ver si FreeBSD está tratando de correr
          un proceso <command>getty</command> en el puerto correcto. Debería
          ver líneas como estas entre los procesos desplegados:</para>

	<screen>  114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyd0
  115 ??  I      0:00.10 /usr/libexec/getty V19200 ttyd1</screen>

	<para>Si ve algo diferente, como esto:</para>

	  <screen>  114 d0  I      0:00.10 /usr/libexec/getty V19200 ttyd0</screen>

        <para>y el modem no ha aceptado una llamada todavía, esto
          significa que <command>getty</command> ha completado su apertura
          en el puerto de comunicaciones. Esto puede indicar un problema
          con el cableado o un modem mal configurado, debido a que
          <command>getty</command> no podría abrir el puerto de
          comunicaciones hasta que un <acronym>CD</acronym> (detección
          de señal) sea afirmado por el modem.</para>

        <para>si no ve ningún proceso <command>getty</command> esperando
          para abrir el puerto
          <filename>ttydN</filename> deseado,
          revise de nuevo sus entradas en <filename>/etc/ttys</filename> para
          ver si existe algún error ahí. También revise
          el fichero de log <filename>/var/log/messages</filename> para ver
          si existe algún mensaje de <command>init</command> o de
          <command>getty</command> relacionados a cualquier problema.
          Si existe cualquier mensaje, revise nuevamente los ficheros de
          configuración <filename>/etc/ttys</filename> y
          <filename>/etc/gettytab</filename>, así como los ficheros
          especiales de dispositivo <filename>/dev/ttydN</filename>, por
          cualquier error, entradas faltantes, o ficheros especiales de
          dispositivo faltantes.</para>
      </sect3>

      <sect3>
	<title>Trate de llamar</title>

        <para>Trate de llamar al sistema; asegúrese de usar 8 bits,
          sin paridad, y 1 bit de parada en el sistema remoto.
          Si no obtiene un prompt inmediatamente, o recibe basura, trate
          presionando <keycode>Enter</keycode> una vez por segundo.
          Si continua sin ver un prompt de <prompt>login:</prompt> despues
          de un tiempo, trate enviando un <command>BREAK</command>. Si
          está usando un modem de alta velocidad para realizar la
          marcación, trate marcando de nuevo despues de fijar la
          velociad de interfaz del modem (por medio de <command>AT&amp;B1</command>
          en un modem &usrobotics; &sportster;, por ejemplo).</para>

        <para>Si todavía no puede obtener un prompt de <prompt>login:</prompt>,
          revise <filename>/etc/gettytab</filename> de nuevo y revise nuevamente
          que</para>

	<itemizedlist>
	  <listitem>
            <para>El nombre de capacidad inicial especificado en
              <filename>/etc/ttys</filename> para la línea coincida con
              un nombre de una capacidad en <filename>/etc/gettytab</filename></para>
		</listitem>

	  <listitem>
            <para>Cada entrada <literal>nx=</literal> coincida con otro
              nombre de capacidad de <filename>gettytab</filename></para>
	  </listitem>

	  <listitem>
            <para>Cada entrada <literal>tc=</literal> coincida con otro
              nombre de capacidad de <filename>gettytab</filename></para>
	  </listitem>
	</itemizedlist>

        <para>Si marca pero el modem en el sistema FreeBSD no contesta,
          asegúrese que el modem está configurado para
          contestar el teléfono cuando <acronym>DTR</acronym> sea
          detectado. Si el modem parece estar configurado correctamente,
          verifique que <acronym>DTR</acronym> sea detectado revisando
          las luces indicadoras del modem (si tiene alguna).</para>

        <para>Si ha revisado todo varias veces y todavía no funciona,
          tome un descanso y regrese a eso depues. Si todavía continua
          sin funcionar, tal vez puede mandar un correo electrónico a
          &a.questions; describiendo su modem y su problema, y las buenas
          personas en la lista tratarán de ayudarle.</para>
      </sect3>
    </sect2>

  </sect1>

  <sect1 xml:id="dialout">
    <title>Servicio dial-out</title>
    <indexterm><primary>dial-out service</primary></indexterm>

    <para>Los siguientes son tips para que su equipo pueda conectarse a
      otra computadora mediante el modem. Esto es apropiado para
      establecer una sesión de terminal con un equipo remoto.</para>

    <para>Esto es útil para entrar a una BBS.</para>

    <para>Este tipo de conexión puede ser extremadamente útil
      para obtener un fichero del Internet si tiene problemas con PPP. Si
      necesita mandar por FTP algo y PPP no funciona, utilice la sesión
      de terminal para mandarlo por FTP. Entonces use zmodem para transferirlo
      a su máquina.</para>

    <sect2>
      <title>¿Mi modem Hayes no está soportado, que puedo hacer?</title>

      <para>En realidad, la página de manual para <command>tip</command> no está
        actualizada. Existe un marcador Hayes genérico incluido. Solo
        utilice <literal>at=hayes</literal> en su fichero
        <filename>/etc/remote</filename>.</para>

      <para>El controlador Hayes no es lo suficientemente inteligente
        para reconocer algunas de las funciones avanzadas de nuevos
        modems como <literal>BUSY</literal>, <literal>NO DIALTONE</literal>,
        o <literal>CONNECT 115200</literal> y solamente se confundirá.
        Debería apagar esos mensajes cuando utilice <command>tip</command>
        (usando <command>ATX0&amp;W</command>).</para>

      <para>También, la pausa de marcado para <command>tip</command> es
        de 60 segundos. Su modem debe utilizar un poco menos, o de otra manera
        tip pensará que existe un problema de comunicación.
        Trate con <command>ATS7=45&amp;W</command>.</para>

      <note>
        <para>Así como se envía, <command>tip</command> todavía
          no soporta modems Hayes completamente. La solución es
          editar el fichero <filename>tipconf.h</filename> en el
          directorio <filename>/usr/src/usr.bin/tip/tip</filename>.
          Obviamente necesita las fuentes de la distribución para
          hacer esto.</para>

        <para>Edite la línea <literal>#define HAYES 0</literal> a
          <literal>#define HAYES 1</literal>. Entonces haga un <command>make</command>
          y <command>make install</command>. Todo funciona bien despues
          de eso.</para>
      </note>
    </sect2>

    <sect2 xml:id="direct-at">
      <title>¿Como se espera que yo entre estos comandos AT?</title>

      <indexterm>
        <primary><filename>/etc/remote</filename></primary>
      </indexterm>
      <para>Haga lo que se llama una entrada <quote>directa</quote> en
        su fichero <filename>/etc/remote</filename>. Por ejemplo, si su
        modem está conectado al primer puerto serie, <filename>/dev/cuaa0</filename>,
        entonces ponga la siguiente línea:</para>

      <programlisting>cuaa0:dv=/dev/cuaa0:br#19200:pa=none</programlisting>

      <para>Utilice la tasa más alta de bps que su modem soporte en la
        capacidad br. Entonces, escriba <command>tip cuaa0</command> y estará
        conectado a su modem.</para>

      <para>Si no existe un fichero <filename>/dev/cuaa0</filename> en su sistema,
        haga esto:</para>

      <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV cuaa0</userinput></screen>

      <para>O use <command>cu</command> como <systemitem class="username">root</systemitem> con el
        siguiente comando:</para>

      <screen>&prompt.root; <userinput>cu -lline -sspeed</userinput></screen>

      <para><replaceable>line</replaceable> es el puerto serie
        (ejem.<filename>/dev/cuaa0</filename>) y
        <replaceable>speed</replaceable> es la velocidad
        (ejem.<literal>57600</literal>). Cuando termine de meter los
         comandos AT presione <keycap>~.</keycap> para salir.</para>
    </sect2>

    <sect2>
      <title>¡El signo <literal>@</literal> para la capacidad pn no
	funciona!</title>

      <para>El signo <literal>@</literal> en la capacidad número de teléfono
        le dice a tip que busque en <filename>/etc/phones</filename> por un
        número de teléfono.
        Pero el signo <literal>@</literal> también es un caracter especial
        en ficheros de capacidad como <filename>/etc/remote</filename>. Escápelo
        con una diagonal invertida:</para>

      <programlisting>pn=\@</programlisting>
    </sect2>

    <sect2>
      <title>Como puede marcar un número de teléfono. en la línea de comando?</title>

      <para>Ponga lo que se llama una entrada <quote>generica</quote> en su
        fichero <filename>/etc/remote</filename>. Por ejemplo:</para>

      <programlisting>tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuaa0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuaa0:br#57600:at=hayes:pa=none:du:</programlisting>

      <para>Entonces puede hacer cosas como:</para>

      <screen>&prompt.root; <userinput>tip -115200 5551234</userinput></screen>

      <para>Si prefiere <command>cu</command> y no <command>tip</command>,
	use una entrada <literal>cu</literal>:</para>

      <programlisting>cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuaa1:br#57600:at=hayes:pa=none:du:</programlisting>

      <para>y escriba:</para>

      <screen>&prompt.root; <userinput>cu 5551234 -s 115200</userinput></screen>
    </sect2>

    <sect2>
      <title>¿Tengo que teclear la tasa de bps cada vez que haga eso?</title>

      <para>Ponga una entrada para <literal>tip1200</literal> o
        <literal>cu1200</literal>, pero utilice cualquier tasa bps que sea
        apropiada con la capacidad br.  <command>tip</command> piensa que
        una buena opción por omisión es 1200&nbsp;bps es por
        eso que busca una entrada <literal>tip1200</literal>. Aunque no tiene
        que usar 1200&nbsp;bps.</para>
    </sect2>

    <sect2>
      <title>Acceso a un número de equipos a través de un servidor de terminales</title>

      <para>en lugar de esperar hasta que esté conectado y
        teclear <command>CONNECT &lt;host&gt;</command> cada vez, use
        la capacidad de tip <literal>cm</literal>. Por ejemplo, estas
        entradas en <filename>/etc/remote</filename>:</para>

      <programlisting>pain|pain.deep13.com|Forrester's machine:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank's machine:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cuaa2:br#38400:at=hayes:du:pa=none:pn=5551234:</programlisting>

      <para>Le permitirá teclear <command>tip pain</command> o
        <command>tip muffin</command> para conectar a los equipos pain
        o muffin, y <command>tip deep13</command> para accesar al servidor
        de terminales.</para>
    </sect2>

    <sect2>
      <title>¿Puede Tip tratar más de una línea para cada sitio?</title>

      <para>Eso es a menudo un problema donde una universidad tiene varias líneas
        de modems y varios miles de estudiantes tratando de usarlas.</para>

      <para>Haga una entrada para su universidad en
        <filename>/etc/remote</filename> y use <literal>@</literal> para
        la capacidad <literal>pn</literal> :</para>

      <programlisting>big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuaa3:br#9600:at=courier:du:pa=none:</programlisting>

      <para>Entonces liste los números de teléfonos para la universidad en
	<filename>/etc/phones</filename>:</para>

      <programlisting>big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</programlisting>

      <para><command>tip</command> tratará cada uno en el orden listado,
        entonces se rendirá. Si quiere seguir tratando, ejecute <command>tip</command>
        en un ciclo while.</para>
    </sect2>

    <sect2>
      <title>¿Porqué tengo que presionar
        <keycombo action="simul">
          <keycap>Ctrl</keycap>
          <keycap>P</keycap>
        </keycombo>
        dos veces para mandar un
        <keycombo action="simul">
          <keycap>Ctrl</keycap>
          <keycap>P</keycap>
        </keycombo>
        ?</title>

      <para><keycombo action="simul"><keycap>Ctrl</keycap><keycap>P</keycap></keycombo> es el caracter de <quote>forzado</quote> por omisión, usado para
        decirle a <command>tip</command> que el siguiente caracter es un dato literal.
        Puede establecer el caracter de forzado a cualquier otro
        caracter con el escape <command>~s</command>, el cual significa
        <quote>establecer una variable.</quote></para>

      <para>Escriba
        <command>~sforce=single-char</command>
        seguido por una nueva línea.  <replaceable>single-char</replaceable>
        es cualquier caracter. Si no especifica
        <replaceable>single-char</replaceable>, entonces el caracter de
        forzado es el caracter nulo, el cual puede
        obtener tecleando
        <keycombo action="simul">
          <keycap>Ctrl</keycap><keycap>2</keycap>
        </keycombo>
        o
        <keycombo action="simul">
          <keycap>Ctrl</keycap><keycap>Espacio</keycap>
        </keycombo>.
        Un buén valor para <replaceable>single-char</replaceable> es
        <keycombo action="simul">
          <keycap>Shift</keycap>
          <keycap>Ctrl</keycap>
          <keycap>6</keycap>
        </keycombo>, es cual solamente es usado
        en algunos servidores de terminales.</para>

      <para>Puede hacer que el caracter de forzado sea cualquiera
        que usted quiera especificando lo siguiente en su fichero
        <filename>&dollar;HOME/.tiprc</filename>:</para>

      <programlisting>force=&lt;single-char&gt;</programlisting>
    </sect2>

    <sect2>
      <title>¿¿De repente todo lo que escribo está en mayúsculas??</title>

      <para>Debe haber presionado
	<keycombo action="simul">
	  <keycap>Ctrl</keycap>
	  <keycap>A</keycap>
	</keycombo>, el<quote>caracter de mayúsculas</quote>
        de <command>tip</command>
        especialmente diseñado para personas
        con teclas caps-lock dañadas. Use <command>~s</command> como se ve
        arriba y establezca la variable <literal>raisechar</literal> a
        algo razonable. De hecho, puede establecerla a la misma del
        caracter de forzado, si nunca espera utilizar ninguna de estas
        funciones.</para>

      <para>Aquí hay un ejemplo de fichero
        .tiprc perfecto para usuarios de
        <application>Emacs</application> que necesitan teclear
        <keycombo action="simul">
          <keycap>Ctrl</keycap><keycap>2</keycap>
        </keycombo>
        y
        <keycombo action="simul">
          <keycap>Ctrl</keycap><keycap>A</keycap>
        </keycombo>
        con frecuencia:</para>

      <programlisting>force=^^
raisechar=^^</programlisting>

      <para>El ^^ es
	<keycombo action="simul">
	  <keycap>Shift</keycap><keycap>Ctrl</keycap><keycap>6</keycap>
	</keycombo>.</para>

    </sect2>

    <sect2>
      <title>¿Como puedo realizar transferencias de ficheros con <command>tip</command>?</title>

      <para>Si esta hablando con otro sistema &unix;, puede mandar y recibir
        ficheros con <command>~p</command> (put) y
        <command>~t</command> (take). Estos comandos ejecutan
        <command>cat</command> y <command>echo</command> en el sistema
        remoto para aceptar y envíar ficheros. La sintaxis
        es:</para>

      <cmdsynopsis>
	<command>~p</command>
	<arg choice="plain">fichero-local</arg>
	<arg choice="opt">fichero-remoto</arg>
      </cmdsynopsis>

      <cmdsynopsis>
	<command>~t</command>
	<arg choice="plain">fichero-remoto</arg>
	<arg choice="opt">fichero-local</arg>
      </cmdsynopsis>

      <para>No existe revisión de errores, así que probablemente
        debería usar otro protocolo, como zmodem.</para>
    </sect2>

    <sect2>
      <title>¿Como puedo ejecutar zmodem con <command>tip</command>?</title>

      <para>Para recibir ficheros, inicie el programa de envío en
        el extremo remoto. Entonces escriba <command>~C rz</command> para
        empezar a recibirlos localmente.</para>

      <para>Para enviar ficheros, inicie el programa de recepción
        el extremo remoto. Entonces escriba
        <command>~C sz files</command>
        para enviarlos
        al sistema remoto.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="serialconsole-setup">
    <info><title>Configurando la consola serie</title>
      <authorgroup>
        <author><personname><firstname>Kazutaka</firstname><surname>YOKOTA</surname></personname><contrib>Contribuido por </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Bill</firstname><surname>Paul</surname></personname><contrib>Basado en un documento de </contrib></author>
      </authorgroup>
    </info>
    
    <indexterm><primary>serial console</primary></indexterm>

    <sect2 xml:id="serialconsole-intro">
      <title>Introducción</title>

      <para>FreeBSD tiene la habilidad de arrancar en un sistema
        con solo una terminal tonta como consola. Tal configuración
        podría ser útil para dos clases de gente:
        administradores de sistema que quieran instalar FreeBSD en máquinas
        que no tienen teclado o monitor conectado, y desarrolladores
        que quieran corregir errores en el kernel o controladores
        de dispositivos.</para>

      <para>Como se describe en <xref linkend="boot"/>, FreeBSD emplea un
        sistema de arranque de tres estados. Los primeros dos estados se
        encuentran en el código del bloque de arranque el cual es
        almacenado al principio del slice en el disco de arranque. El
        bloque de arranque entonces cargará y ejecutará el
        cargador de arranque (<filename>/boot/loader</filename>) como
        la tercera etapa de código.</para>

      <para>Para poder configurar la consola serie debe configurar el
        código del bloque de arranque, el código del cargador
        de arranque y el kernel.</para>

    </sect2>

    <sect2 xml:id="serialconsole-howto-fast">
      <title>Configuracióm de consola serie, versión breve</title>

      <para>Esta sección asume que está usando la
        configuración por omisión y solo quiere una
        rápida revisión de la configuración de
        la consola serie.</para>

      <procedure>

	<step>
	  <para>Conecte el cable serie a COM1 y la terminal controladora.</para>
	</step>

	<step>
          <para>Para ver todos los mensajes de arranque en la consola
            serie escriba el siguiente comando mientras está
            firmado como superusuario:</para>
	  <screen>&prompt.root; echo 'console="comconsole"' &gt;&gt; /boot/loader.conf</screen>
	</step>

	<step>
          <para>Edite <filename>/etc/ttys</filename> y cambie
            <literal>dialup</literal> a <literal>vt100</literal> para la entrada
            <literal>ttyd0</literal>. De otra manera una
            contraseña no será requerida para conectar por medio
            de la consola serie, resultando en un agujero de seguridad
            potencial.</para>
	</step>

	<step>
	  <para>Reinicie el sistema para ver si los cambios tuvieron efecto.</para>
	</step>

      </procedure>

      <para>Si una configuración diferente es requerida, una
        explicación mas detallada existe en
        <xref linkend="serialconsole-howto"/>.</para>
    </sect2>

    <sect2 xml:id="serialconsole-howto">
      <title>Configuración de la consola serie</title>

      <procedure>
	<step>
	  <para>Prepare un cable serie.</para>

	  <indexterm><primary>null-modem cable</primary></indexterm>
          <para>Necesitará ya sea un cable null-modem o un cable
            serie estándar y un adaptador null-modem. Vea
            <xref linkend="serial-cables-ports"/> para una discusión
            sobre cables serie.</para>
	</step>

	<step>
	  <para>Desconecte su teclado.</para>

          <para>La mayoría de sistemas PC buscan el teclado durante
            la autoprueba de encendido (POST) y generarán un error
            si el teclado no es detectado. Algunas máquinas se quejan
            fuerte sobre la falta de un teclado y no continuarán
            arrancando hasta que este contectado.</para>

          <para>Si su computadora se queja con este error, pero arranca de
            todos modos, entonces no tiene que hacer nada especial. (Algunas
            máquinas con BIOS Phoenix instalado solo mostrarán
            <errorname>Keyboard failed</errorname> y continuarán
            arrancando normalmente.)</para>

          <para>Si su computadora se niega a arrancar sin un teclado
            conectado, entonces tendrá que configurar el BIOS para
            que ignore este error (si es posible). Consulte el manual de su
            tarjeta madre para los detalles de como hacer esto.</para>

	  <tip>
            <para>Poniendo el teclado como <quote>No instalado</quote> en el
              BIOS <emphasis>no</emphasis> significa que no podá usar
              su teclado. Todo lo que hace es decirle al BIOS que no busque
              un teclado al momento de encender, asi no se quejará si
              el teclado no se encuentra conectado. Puede dejar el teclado
              conectado incluso si esta bandera está puesta a
              <quote>No instalado</quote> y el teclado todaía funcionará.</para>
	  </tip>

	  <note>
            <para>Si su sistema tiene un ratón &ps2; es muy probable que
              también tenga que desconectar su ratón junto con
              el teclado. Esto se debe a que los ratones &ps2; comparten
              algún hardware con el teclado y dejandolo conectado puede
              ocasionar que el sistema piense que el teclado sigue conectado.
              Se dice que un sistema Gateway 2000 Pentium 90&nbsp;MHz con un
              AMI BIOS se comporta de esta manera. En general, esto no
              representa un problema puesto que el ratón no es muy
              útil sin el teclado de todas maneras.</para>
	  </note>
	</step>

	<step>
          <para>Conecte una terminal tonta a <filename>COM1</filename>
	    (<filename>sio0</filename>).</para>

          <para>Si no tiene una terminal tonta, puede utilizar una PC/XT
            vieja con un programa de modem, o el puerto serie en otro
            equipo &unix;. Si no tiene un <filename>COM1</filename>
            (<filename>sio0</filename>), consiga uno. En este momento,
            no existe manera de seleccionar un puerto diferente a <filename>COM1</filename>
            para los bloques de arranque sin recompilar los bloques de
            arranque. Si ya está utilizando <filename>COM1</filename> para
            otro dispositivo, necesitará remover temporalmente ese
            dispositivo e instalar un nuevo bloque de arranque y kernel una
            vez que tenga a FreeBSD arriba y funcionando. (Se asume que
            <filename>COM1</filename> estará disponible en un
            fichero/computadora/servidor de terminales de todas maneras;
            si realmente necesita <filename>COM1</filename> para algo
            más (y no puede cambiar ese algo a
            <filename>COM2</filename> (<filename>sio1</filename>)),
            entonces probablemente no debería de molestarse con todo
            esto en primer lugar.)</para>
	</step>

	<step>
          <para>Asegúrese de que el fichero de configuración de
            su kernel tenga las banderas apropiadas activadas para
            <filename>COM1</filename> (<filename>sio0</filename>).</para>

	  <para>Las banderas relevantes son:</para>

	  <variablelist>
	    <varlistentry>
	      <term><literal>0x10</literal></term>

	      <listitem>
                <para>Habilita el soporte de consola para esta unidad.
                  Las otras banderas de consola son ignoradas a menos que
                  ésta está activada. Actualmente, al menos
                  una unidad puede tener soporte de consola; la primera (en
                  orden de configuración) con esta bandera activada
                  es preferida. Esta opción por si sola no hará
                  del puerto serie una consola. Active la siguiente bandera
                  o utilice la opción <option>-h</option> descrita
                  abajo, junto con esta bandera.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>0x20</literal></term>

	      <listitem>
                <para>Obliga a esta unidad a ser la consola (a menos que
                  exista otra consola de mayor prioridad), sin importar
                  la opción <option>-h</option> discutida abajo. Esta
                  bandera reemplaza la opción <literal>COMCONSOLE</literal>
                  en las versiones 2.<replaceable>X</replaceable> de FreeBSD.
                  La bandera <literal>0x20</literal> debe ser utilizada junto
                  con la bandera <option>0x10</option>.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>0x40</literal></term>

	      <listitem>
                <para>Reserva esta unidad (en conjunto con
                  <literal>0x10</literal>) y hace esta unidad
                  no disponible para acceso normal. No debería
                  activar esta bandera en la unidad de puerto serie
                  la cual desee utilizar como la consola serie.
                  El único uso de esta bandera es designar
                  la unidad para corección de errore remota
                  del kernel. Revise <quote>El manual del
		  desarrollador</quote> para mayor información sobre
		  corrección de errores remotamente.</para>

		<note>
                  <para>En FreeBSD&nbsp;4.0 o posterior la semántica de
                    la bandera <literal>0x40</literal> es ligeramente
		    diferente y existe otra bandera para especificar un puerto
		    serie para corrección de errores remotamente.
		    </para>
		</note>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Ejemplo:</para>

	  <programlisting>device sio0 at isa? port IO_COM1 flags 0x10 irq 4</programlisting>

	  <para>Vea la página de manual &man.sio.4; para más
	    detalles.</para>

          <para>Si las banderas no fueron activadas, necesita correr
            UserConfig (en una consola diferente) o recompilar el
            kernel.</para>
	</step>

	<step>
          <para>Cree <filename>boot.config</filename> en el directorio
	    raíz de la partición <literal>a</literal> del
	    disco de arranque.</para>

          <para>Este fichero instruirá al código del bloque de
            arranque como le gustaría arrancar el sistema. Para activar
            la consola serie, necesita una o más de las
	    siguientes opciones&mdash; si quiere opciones múltiples
	    inclúyalas todas en la misma línea:</para>

	  <variablelist>
	    <varlistentry>
	      <term><option>-h</option></term>

	      <listitem>
                <para>Cambia entre consola interna y serie. Puede usar
		  esto para cambiar los dispositivos de consola. Por
		  ejemplo, si arranca desde la consola interna
		  (video), puede utilizar <option>-h</option> para dirigir el
		  cargador de arranque y el kernel a que usen el puerto serie
		  como su dispositivo de consola. Alternativamente, si
		  arranca desde el puerto serie, puede utilizar
		  <option>-h</option> para decirle al cargador de arranque y
		  al kernel que usen el video como consola.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><option>-D</option></term>

	      <listitem>
                <para>Cambia entre configuración de consola
		  simple y dual.  En la configuración simple la
		  consola será ya sea la consola interna
		  (video) o el puerto serie, dependiendo del estado de la
		  opción <option>-h</option> de arriba.  En la
		  configuración de consola dual, el video y el
                  puerto serie se convertirán en la consola al
		  mismo tiempo, sin importar del estado de la opción
		  <option>-h</option>.  De todas maneras, note que la
		  configuración de consola dual toma efecto
		  solamente mientras el bloque de arranca está
                  corriendo. Una vez que el cargador de arranque toma el
		  control, la consola especificada por la
		  opción <option>-h</option> se convierte en la
		  única consola.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><option>-P</option></term>

	      <listitem>
                <para>Hace que el bloque de arranque busque el teclado.
                  Si no se encuentra un teclado, la opción
		  <option>-D</option> y <option>-h</option> son activadas
		  automátivamente.</para>

		<note>
                  <para>Debido a problemas de espacio en la versión
		    actual del bloque de arranque, la opción
		    <option>-P</option> es capaz de detectar unicamente
		    teclados extendidos. Teclados con menos de 101 teclas
		    (y carentes de teclas F11 y F12) no pueden ser
		    detectados. Algunos teclados en laptops puede que no
		    sean correctamente encontrados debido a esta
                    limitación. Si este es el caso con su sistema, debe
                    abandonar el uso de la opción <option>-P</option>.
                    Desafortunádamente no hay una solución para
                    este problema.</para>
		</note>
	      </listitem>
	    </varlistentry>
	  </variablelist>

          <para>Utilice ya sea la opción <option>-P</option> para
            seleccionar la consola automáticamente, o la opción
            <option>-h</option> para activar la consola serie.</para>

          <para>Puede incluir otras opciones descritas en &man.boot.8;
            también.</para>

          <para>Las opciones, excepto por <option>-P</option>, serán
            pasadas al cargador de arranque (<filename>/boot/loader</filename>).
            El cargador de arranque determinará si el video interno
            o el puerto serie debería convertirse en la consola
            examinando el estado de la opción <option>-h</option>
            solamente. Esto significa que si especifica la opción
            <option>-D</option> pero no la opción <option>-h</option>
            en <filename>/boot.config</filename>, puede utilizar el puerto
            serie como consola solamente durante el bloque de arranque;
            el cargador de arranque usará el video interno como
            consola.</para>
	</step>

	<step>
	  <para>Arranque la máquina.</para>

          <para>Cuando inicia su equipo FreeBSD, los bloques de arranque
            mostrarán los contenidos de <filename>/boot.config</filename> a
            la consola. Por ejemplo:</para>

	  <screen>/boot.config: -P
Keyboard: no</screen>

          <para>La segunda línea aparece solamente si pone <option>-P</option>
            en <filename>/boot.config</filename> e indica la presencia/ausencia
            del teclado. Estos mensajes van a la consola serie o a la interna,
            o a ambas, dependiendo de la opción en
            <filename>/boot.config</filename>.</para>

	  <informaltable frame="none" pgwide="1">
	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry>Opciones</entry>
		  <entry>Mensaje va a</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>ninguna</entry>
		  <entry>consola interna</entry>
		</row>

		<row>
		  <entry><option>-h</option></entry>
		  <entry>consola serie</entry>
		</row>

		<row>
		  <entry><option>-D</option></entry>
		  <entry>consola serie e interna</entry>
		</row>

		<row>
		  <entry><option>-Dh</option></entry>
		  <entry>consola serie e interna</entry>
		</row>

		<row>
		  <entry><option>-P</option>, teclado presente</entry>
		  <entry>consola interna</entry>
		</row>

		<row>
		  <entry><option>-P</option>, teclado ausente</entry>
		  <entry>consola serie</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>

          <para>Despues de los mensajes de arriba, existirá una pausa
            pequeña antes que los bloques de arranque continuen cargando el
            cargador de arranque y antes de que cualquier mensaje posterior
            sea impreso en la consola. Bajo ciertas circunstancias, no necesita
            interrumpir los bloques de arranque, pero tal vez quiera hacerlo
            para asegurarse que las cosas están configuradas
            corréctamente.</para>

          <para>Presione cualquier tecla, diferente a  <keycode>Enter</keycode>,
            en la consola para interrumpir el proceso de arranque. Los bloques
            de arranque entonces esperarán una entrada para determinar
            como continuar. Debe ver algo como esto:</para>

	  <screen>&gt;&gt; FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:</screen>

          <para>Verifique que el mensaje de arriba aparece en la consola
            serie o en la interna o en ambas, de acuerdo a las opciones
            que puso en <filename>/boot.config</filename>. Si el mensaje
            aparece en la consola correcta, presione <keycode>Enter</keycode>
            para continuar el proceso de arranque.</para>

          <para>Si quiere usar la consola serie pero no ve el prompt en la
            terminal serie, algo está mal con su configuración.
            Mientras tanto, entre <option>-h</option> y presione Enter/Return
            (si es posible) para decirle al bloque de arranque (y entonces al
            cargador de arranque y al kernel) que elija el puerto serie como
            consola. Una vez que el sistema arranque, regrese y revise que fué
            lo que estuvo mal.</para>
	</step>
      </procedure>

      <para>Despues que el cargador de arranque ha cargado y usted se encuentra
        en la tercera etapa del proceso de arranque todavía puede cambiar
        entre la consola interna y la consola serie activando las variables de
        entorno apropiadas en el cargador de arranque.
        Vea <xref linkend="serialconsole-loader"/>.</para>
    </sect2>

  <sect2 xml:id="serialconsole-summary">
    <title>Resumen</title>

      <para>aquí está el resumen de varias configuraciones
        discutidas en esta sección y la consola seleccionada
        eventualmente.</para>

      <sect3>
	<title>Caso 1: Activó las banderas a 0x10 para
	  <filename>sio0</filename></title>

	<programlisting>device sio0 at isa? port IO_COM1 flags 0x10 irq 4</programlisting>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="4">
	    <thead>
	      <row>
		<entry>Opciones en /boot.config</entry>
		<entry>Consola durante bloques de arranque</entry>
		<entry>Consola durante cargador de arranque</entry>
		<entry>Consola en kernel</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry>ninguna</entry>
		<entry>interna</entry>
		<entry>interna</entry>
		<entry>interna</entry>
	      </row>

	      <row>
		<entry><option>-h</option></entry>
		<entry>serie</entry>
		<entry>serie</entry>
		<entry>serie</entry>
	      </row>

	      <row>
		<entry><option>-D</option></entry>
		<entry>serie e interna</entry>
		<entry>interna</entry>
		<entry>interna</entry>
	      </row>

	      <row>
		<entry><option>-Dh</option></entry>
		<entry>serie e interna</entry>
		<entry>serie</entry>
		<entry>serie</entry>
	      </row>

	      <row>
		<entry><option>-P</option>, teclado presente</entry>
		<entry>interna</entry>
		<entry>interna</entry>
		<entry>interna</entry>
	      </row>

	      <row>
		<entry><option>-P</option>, teclado ausente</entry>
		<entry>serie e interna</entry>
		<entry>serie</entry>
		<entry>serie</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>

      <sect3>
	<title>Caso 2: Activó las banderas a 0x30 para sio0</title>

	<programlisting>device sio0 at isa? port IO_COM1 flags 0x30 irq 4</programlisting>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="4">
	    <thead>
	      <row>
		<entry>Opciones en /boot.config</entry>
		<entry>Consola durante bloques de arranque</entry>
		<entry>Consola durante cargador de arranque</entry>
		<entry>Consola en kernel</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry>ninguna</entry>
		<entry>interna</entry>
		<entry>interna</entry>
		<entry>serie</entry>
	      </row>

	      <row>
		<entry><option>-h</option></entry>
		<entry>serie</entry>
		<entry>serie</entry>
		<entry>serie</entry>
	      </row>

	      <row>
		<entry><option>-D</option></entry>
		<entry>serie e interna</entry>
		<entry>interna</entry>
		<entry>serie</entry>
	      </row>

	      <row>
		<entry><option>-Dh</option></entry>
		<entry>serie e interna</entry>
		<entry>serie</entry>
		<entry>serie</entry>
	      </row>

	      <row>
		<entry><option>-P</option>, teclado presente</entry>
		<entry>interna</entry>
		<entry>interna</entry>
		<entry>serie</entry>
	      </row>

	      <row>
		<entry><option>-P</option>, teclado ausente</entry>
		<entry>serie e interna</entry>
		<entry>serie</entry>
		<entry>serie</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>
    </sect2>

    <sect2 xml:id="serialconsole-tips">
      <title>Consejos para la consola serie</title>

      <sect3>
	<title>Configurando un velocidad de puerto serie más rápida</title>

        <para>Por omisión, la configuración del puerto
          serie es: 9600 baud, 8 bits, sin paridad, y 1 bit de parada.
          Si desea cambiar la velocidad, necesita recompilar al menos los
          bloques de arranque. Agregue la siguiente línea a
          <filename>/etc/make.conf</filename> y compile nuevos
          bloques de arranque:</para>

	<programlisting>BOOT_COMCONSOLE_SPEED=19200</programlisting>

        <para>Vea <xref linkend="serialconsole-com2"/> para instrucciones
          detalladas sonre construir e instalar nuevos bloques de
          arranque.</para>

        <para>Si la consola serie está configurada de alguna otra
          manera que arrancando con <option>-h</option>, o si la consola
          serie usada por el kernel es diferente de la usada por los
          bloques de arranque, entonces también debe agregar la
          siguiente opción al fichero de configuración del kernel
          y compilar un nuevo kernel:</para>

	<programlisting>options CONSPEED=19200</programlisting>
      </sect3>

      <sect3 xml:id="serialconsole-com2">
	<title>Usando puertos serie para consola diferentes a <filename>sio0</filename></title>

        <para>Utilizar un puerto serie diferente a <filename>sio0</filename>
          como consola requiere cierta recompilación. Si quiere usar
          otro puerto serie por la razón que sea, recompile los
          bloques de arranque, el cargador de arranque y el kernel como
          sigue.</para>

	<procedure>
	  <step>
	    <para>Consiga las fuentes del kernel. (Vea <xref linkend="cutting-edge"/>)</para>
	  </step>

	  <step>
            <para>Edite <filename>/etc/make.conf</filename> y ponga
              <literal>BOOT_COMCONSOLE_PORT</literal> a la dirección
              del puerto que quiera usar (0x3F8, 0x2F8, 0x3E8 o 0x2E8).
              Solamente de <filename>sio0</filename> hasta
              <filename>sio3</filename> (<filename>COM1</filename>
              hasta <filename>COM4</filename>) pueden usarse; tarjetas
              multipuertos serie no funcionarán.
              No se necesita especificar interrupción.</para>
	  </step>

	  <step>
            <para>Cree un fichero personalizado de configuración de kernel
              y agrege las banderas apropiadas para el puerto serie que
              desee utilizar. Por ejemplo, si desea hacer de <filename>sio1</filename>
              (<filename>COM2</filename>) la consola:</para>

	    <programlisting>device sio1 at isa? port IO_COM2 flags 0x10 irq 3</programlisting>

	    <para>o</para>

	    <programlisting>device sio1 at isa? port IO_COM2 flags 0x30 irq 3</programlisting>

            <para>Las banderas de consola para otros puertos serie no deben
              activarse.</para>
	  </step>

	  <step>
	    <para>Recompile e instale los bloques de arranque y el cargador de arranque:</para>

	    <screen>&prompt.root; <userinput>cd /sys/boot</userinput>
&prompt.root; <userinput>make clean</userinput>
&prompt.root; <userinput>make</userinput>
&prompt.root; <userinput>make install</userinput></screen>
	  </step>

	  <step>
	    <para>Reconstruya e instale el kernel.</para>
	  </step>

	  <step>
            <para>Escriba los bloques de arranque al disco de
              arranque con &man.disklabel.8; y arranque desde
              el nuevo kernel.</para>
	  </step>
	</procedure>
      </sect3>

      <sect3 xml:id="serialconsole-ddb">
        <title>Accesando DDB Debugger desde la línea serie</title>

        <para>Si desea entrar al modo kernel debugger desde una consola
          serie (útil para diagnósticos remotos, !pero
          también peligroso si genera un BREAK ilegítimo
          en el puerto serie!) entonces debe compilar con las siguientes
          opciones:</para>

	<programlisting>options BREAK_TO_DEBUGGER
options DDB</programlisting>
      </sect3>

      <sect3>
	<title>Obteniendo un prompt de login en la consola serie</title>

        <para>Aunque esto no es requerido, tal vez quiera obtener
           un prompt de <emphasis>login</emphasis> a través de
           una línea serie, ahora que puede ver los mensajes
           de arranque y puede entrar a una sesión en modo
           kernel debug a través de la consola serie. Aquí
           está como hacerlo.</para>

        <para>Abra el fichero <filename>/etc/ttys</filename> con un editor
          y localice las líneas:</para>

      <programlisting>ttyd0 "/usr/libexec/getty std.9600" unknown off secure
ttyd1 "/usr/libexec/getty std.9600" unknown off secure
ttyd2 "/usr/libexec/getty std.9600" unknown off secure
ttyd3 "/usr/libexec/getty std.9600" unknown off secure</programlisting>

        <para><literal>ttyd0</literal> hasta <literal>ttyd3</literal>
          corresponde a <filename>COM1</filename> hasta
          <filename>COM4</filename>. Cambie <literal>off</literal> a
          <literal>on</literal> para el puerto deseado. Si ha cambiado la
          velocidad del puerto serie, necesita cambiar
          <literal>std.9600</literal> para que concuerde con los
          parámetros actuales, ej.
          <literal>std.19200</literal>.</para>

        <para>Tal vez tambien desee cambiar el tipo de terminal
          de <literal>unknown</literal> al tipo actual de su
          terminal serie.</para>

        <para>Despues de editar el fichero, debe hacer un <command>kill -HUP 1</command>
          para que este cambio surta efecto.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="serialconsole-loader">
      <title>Cambiando la consola desde el cargador de arranque</title>

      <para>Secciones anteriores describieron como instalar la consola
        serie manipulando el bloque de arranque. Esta sección muestra
        que puede especificar la consola especificando algunos
	comandos y variables de entorno en el cargador de arranque. Como el
	cargador de arranque es invocado en la tercera etapa del proceso de
	arranque, despues del bloque de arranque, las propiedades en el
	cargador de arranque sobreescribirán las del bloque de
	arranque.</para>

      <sect3>
	<title>Instalando la consola serie</title>

        <para>Puede facilmente especificarle al cargador de arranque y al kernel
          que utilicen la consola serie escribiendo solamente una línea
          en <filename>/boot/loader.rc</filename>:</para>

	<programlisting>set console="comconsole"</programlisting>

        <para>Esto tendrá efecto sin importar las opciones del
          bloque de arranque discutidas en la sección previa.</para>

        <para>Es mejor que ponga la línea de arriba como la primera
          línea en <filename>/boot/loader.rc</filename> para ver
          los mensajes de arranque en la consola serie tan pronto
          como sea posible.</para>

        <para>De igual manera, puede especificar la consola interna como:</para>

	<programlisting>set console="vidconsole"</programlisting>

        <para>Si no activa la variable de entorno <envar>console</envar>,
          el cargador de arranque, y por consecuencia el kernel,
          utilizarán cualquier consola que esté indicada
          por la opción <option>-h</option> en el bloque de
          arranque.</para>

        <para>En versiones 3.2 o posteriores, puede especificar la consola
          en <filename>/boot/loader.conf.local</filename> o
          <filename>/boot/loader.conf</filename>, en lugar de
          <filename>/boot/loader.rc</filename>. En este método su
          <filename>/boot/loader.rc</filename> debe verse como:</para>

	<programlisting>include /boot/loader.4th
start</programlisting>

        <para>Entonces, puede crear <filename>/boot/loader.conf.local</filename> y
          ponerle la siguiente línea.</para>

	<programlisting>console=comconsole</programlisting>

	<para>o</para>

	<programlisting>console=vidconsole</programlisting>

	<para>Vea &man.loader.conf.5; para mayor información.</para>

	<note>
          <para>Hasta el momento, el cargador de arranque no tiene una opción
            equivalente a la opción <option>-P</option> del bloque
            de arranque, y no existe una manera de seleccionar automáticamente
            la consola interna y la consola serie basandose en la presencia
            del teclado.</para>
	</note>
      </sect3>

      <sect3>
	<title>Utilizando un puerto serie para la consola diferente a <filename>sio0</filename></title>

        <para>Necesita recompilar el cargador de arranque para usar un puerto
          serie diferente a <filename>sio0</filename> para la consola
          serie. Siga el procedimiento descrito en <xref linkend="serialconsole-com2"/>.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="serialconsole-caveats">
      <title>Advertencias</title>

      <para>La idea aquí es permitir a las personas configurar servidores
        dedicados que no requieran hardware de gráficos o teclados
        conectados. Desafortunádamente, mientras la mayoría de
        los sistemas le permitirán arrancar sin un teclado, existen
        bastantes que no le permitirán arrancar sin un adaptador de
        gráficos. Máquinas con BIOS AMI pueden configurarse para
        arrancar sin adaptadores de gráficos instalados cambiando
        simplemente la opción <quote>graphics adapter</quote> en la
        configuración del CMOS a <quote>Not installed.</quote></para>

      <para>De cualquier manera, muchas máquinas no soportan esta opción
        y se negarán a arrancar si no tiene algún hardware de
        gráficos instalado en el sistema. Con estas máquinas,
        debe dejar algún tipo de tarjeta gráfica instalada,
        (incluso si solamente es una tarjeta mono barata) aunque no tendrá
        que conectarle un monitor. También puede tratar instalando un
        BIOS AMI.</para>
    </sect2>
  </sect1>
</chapter>
