<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project

     The FreeBSD Spanish Documentation Project
     %SOURCE% en_US.ISO8859-1/books/handbook/multimedia/chapter.xml
     %SRCID%    1.130

     $FreeBSD$
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="multimedia">
  <info><title>Multimedia</title>
    <authorgroup>
      <author><personname><firstname>Ross</firstname><surname>Lippert</surname></personname><contrib>Editado por </contrib></author>
    </authorgroup>
    
  </info>

  

  <sect1>
    <title>Sinopsis</title>

    <para>&os; admite una gran variedad de tarjetas de sonido,
      lo que permite disfrutar de sonido de alta fidelidad en su
      sistema. Ésto incluye la posibilidad de grabar y reproducir
      ficheros de audio tanto en los formatos MPEG Audio Layer 3
      (MP3), WAV y Ogg Vorbis, así como muchos otros.
      La Colección de Ports de &os; contiene también
      aplicaciones que le permitirán editar audio previamente grabado,
      añadir efectos y controlar dispositivos MIDI.</para>


    <para>Tras unas cuantas pruebas podrá reproducir ficheros de
      video y DVD en &os;.  La cantidad de aplicaciones disponibles
      para codificar, convertir y reproducir los diversos soportes de
      video es más limitada que lo que hay disponible para
      el sonido.  Por ejemplo, en el momento de escribir este texto
      no hay en la Colección de Ports de &os; una buena
      aplicación que permita pasar datos de un formato a
      otro, el equivalente a lo que hay en el campo del sonido con
      <package>audio/sox</package>.  A pesar de eso
      la situación en este área está cambiando
      rápidamente.</para>

    <para>Este capítulo muestra los pasos necesarios para configurar
      una tarjeta de sonido.  La configuración e instalación
      de X11 (<xref linkend="x11"/>) habrá solucionado ya todos
      los problemas que hubiera podido darle su tarjeta gráfica,
      aunque quizás haya algún pequeño detalle que
      añadir para mejorar la reproducción.</para>



    <para>Tras leer éste capítulo sabrá usted:</para>
    <itemizedlist>
      <listitem><para>Cómo configurar su sistema de modo que su tarjeta
        de sonido sea reconocida por el mismo.</para></listitem>

      <listitem><para>Confirmar el funcionamiento de su tarjeta usando
        herramientas de muestreo.</para></listitem>

      <listitem><para>Cómo enfrentarse a problemas de
        configuración de sonido.</para></listitem>

      <listitem><para>Cómo reproducir y crear ficheros
        MP3 y otros.</para></listitem>

      <listitem><para>Cómo gestiona el video el servidor X.</para></listitem>
      <listitem><para>Identificar unos cuantos ports para reproducir y
        codificar video que le darán muy buenos resultados.</para></listitem>
      <listitem><para>Cómo reproducir DVD y ficheros
        <filename>.mpg</filename> y
	<filename>.avi</filename>.</para></listitem>

      <listitem><para>Cómo convertir CD y DVD en ficheros
        de datos.</para></listitem>
      <listitem><para>Cómo configurar una tarjeta de TV.</para></listitem>
      <listitem><para>Cómo configurar un escáner de
        imágenes.</para></listitem>
    </itemizedlist>

    <para>Antes de leer éste capítulo debería:</para>

    <itemizedlist>
      <listitem><para>Saber configurar e instalar un nuevo kernel (<xref linkend="kernelconfig"/>).</para></listitem>
    </itemizedlist>


    <warning>
      <para>&nbsp;Si intenta montar un cd con &man.mount.8; provocará
        (como mínimo) un error en el sistema, pero puede
        llegar a provocar un <emphasis>kernel
        panic</emphasis>.  Dichos soportes tienen codificaciones
	especiales sustancialmente diferentes de los típicos
	sistemas de ficheros ISO.</para>
    </warning>


  </sect1>



  <sect1 xml:id="sound-setup">
    <info><title>Configuración de la tarjeta de sonido</title>
      <authorgroup>
        <author><personname><firstname>Moses</firstname><surname>Moore</surname></personname><contrib>Escrito por </contrib></author>
      </authorgroup>
      <authorgroup>
        <author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Ampliado para &os;&nbsp;5.X por </contrib></author>
      </authorgroup>
    </info>

    

  <sect2 xml:id="sound-device">
    <title>Configuración del sistema </title>

    <indexterm><primary>PCI</primary></indexterm>
    <indexterm><primary>ISA</primary></indexterm>
    <indexterm><primary>sound cards</primary></indexterm>
    <para>Antes de nada tendrá que saber a ciencia cierta el
      modelo de tarjeta que tiene, qué chip utiliza y si es PCI
      o ISA.  &os; admite una amplia variedad de tarjetas, tanto PCI como
      ISA.  Consulte la lista de dispositivos de sonido que puede usar
      en &os; en las <link xlink:href="&rel.current.hardware;">Hardware Notes</link>.  Las
      «Hardware Notes» le dirán también
      qué controlador es el que hace funcionar su tarjeta.</para>

    <indexterm>
      <primary>kernel</primary>
      <secondary>configuration</secondary>
    </indexterm>

    <para>Para poder usar su dispositivo de sonido en &os; tiene que
      cargar el controlador de dispositivo adecuado, cosa que puede
      hacerse de dos maneras.  La forma más fácil es
      cargar el módulo del kernel correspondiente a su tarjeta
      de sonido mediante &man.kldload.8;.  Puede hacerlo en su shell
      con la siguiente orden</para>

    <screen>&prompt.root; <userinput>kldload snd_emu10k1</userinput></screen>

    <para>o añadiendo la línea apropiada al fichero
      <filename>/boot/loader.conf</filename>:</para>

    <programlisting>snd_emu10k1_load="YES"</programlisting>

    <para>Ambos ejemplos son para una tarjeta de sonido
      Creative &soundblaster; Live!.  Encontrará una lista de
      módulos de sonido que puede cargar del mismo modo en
      <filename>/boot/defaults/loader.conf</filename>.  Si no está
      del todo seguro sobre el controlador que debe usar pruebe con el
      módulo <filename>snd_driver</filename>:</para>

    <screen>&prompt.root; <userinput>kldload snd_driver</userinput></screen>

    <para>Se trata de un «metacontrolador» que carga en
      memoria todos los controladores más habituales.  De este modo
      acelerará notablemente el proceso de detectar cuál es
      el controlador perfecto para su hardware.  También
      puede cargar todos los controladores de sonido desde
      <filename>/boot/loader.conf</filename>.</para>

    <para>Si quiere saber qué controlador se corresponde
      con su tarjeta de sonido una vez cargado el «metadriver»
      <filename>snd_driver</filename> debe comprobar el contenido de
      <filename>/dev/sndstat</filename> mediante la orden
      <command>cat /dev/sndstat</command>.</para>

    <para>El segundo método es compilar de forma estática
      el soporte para su tarjeta de sonido dentro de un kernel
      personalizado.  En la siguiente sección encontrará
      la información necesaria para añadir a su kernel
      el soporte que necesita su hardware.  Para más información
      sobre la compilación de un kernel consulte el <xref linkend="kernelconfig"/>.</para>

    <sect3>
      <title>Configuración de un kernel personalizado con soporte de sonido</title>

      <para>Lo primero que hay que hacer es añadir el
        controlador del «framework» de sonido
	&man.sound.4; al kernel;  tendrá que añadir
	la siguiente línea a su fichero de configuración
	del kernel:</para>

      <programlisting>device sound</programlisting>

      <para>Una vez hecho esto tiene que añadir el soporte
        para su tarjeta de sonido.  Evidentemente tendrá que
	saber exactamente qué controlador es el que hace
	funcionar su tarjeta.  Consulte la lista de dispositivos de
	sonido soportados que encontrará en las <link xlink:href="&rel.current.hardware;">Hardware Notes</link> y elija
	el controlador perfecto para su tarjeta.  Por ejemplo una
	una tarjeta de sonido Creative &soundblaster; Live! usará
	el controlador &man.snd.emu10k1.4;.  Siguiendo con el ejemplo,
	si queremos añadir soporte para esta tarjeta agregaremos
	lo siguiente:</para>

      <programlisting>device snd_emu10k1</programlisting>

      <para>Por favor, lea la página de manual del controlador
        si tiene dudas con la sintaxis.  La sintaxis específica
	para la configuración en el kernel de cada tarjeta de
	sonido soportada existente puede encontrarse también
	en <filename>/usr/src/sys/conf/NOTES</filename>.</para>

      <para>Las tarjetas ISA no PnP pueden requerir que se le
        facilite al kernel la información de la
	configuración de la tarjeta (IRQ, puerto de E/S, etc).  Esto
	se hace modificando el fichero
	<filename>/boot/device.hints</filename>.  Durante el proceso de
	arranque &man.loader.8; leerá este fichero y le
	pasará los parámetros al kernel.  Veamos un ejemplo:
	una vieja tarjeta Creative &soundblaster; 16 ISA no PnP
	utilizará el controlador &man.snd.sbc.4; junto con
	<literal>snd_sb16</literal>.  En el caso de esta tarjeta
	habrá que añadir las siguientes líneas
	al fichero de configuración del kernel</para>

      <programlisting>device snd_sbc
device snd_sb16</programlisting>

      <para>y añadir lo siguiente a
	<filename>/boot/device.hints</filename>:</para>

      <programlisting>hint.sbc.0.at="isa"
hint.sbc.0.port="0x220"
hint.sbc.0.irq="5"
hint.sbc.0.drq="1"
hint.sbc.0.flags="0x15"</programlisting>

      <para>La tarjeta del ejemplo usa el puerto de E/S <literal>0x220</literal>
	I/O port y la IRQ <literal>5</literal>.</para>

      <para>La sintaxis a utilizar en
	<filename>/boot/device.hints</filename> se explica en
	la página de manual de &man.sound.4; y en la del
	controlador en cuestión.</para>

      <para>En el ejemplo se muestran los parámetros por
        omisión.  En ciertos casos habrá que usar
	otra IRQ o usar otros parámetros para hacer funcionar
	la tarjeta de sonido.  Consulte la página de manual de
	&man.snd.sbc.4; para más información sobre esta
	tarjeta.</para>
    </sect3>
  </sect2>

  <sect2 xml:id="sound-testing">
    <title>Cómo probar su tarjeta de sonido</title>

    <para>Una vez que haya reiniciado con su kernel personalizado, o
      tras cargar el mólo del kernel necesario la tarjeta de
      sonido aparecerá en el búfer de mensajes del sistema
      (&man.dmesg.8;); deberí ser algo muy parecido a esto:</para>

    <screen>pcm0: &lt;Intel ICH3 (82801CA)&gt; port 0xdc80-0xdcbf,0xd800-0xd8ff irq 5 at device 31.5 on pci0
pcm0: [GIANT-LOCKED]
pcm0: &lt;Cirrus Logic CS4205 AC97 Codec&gt;</screen>

    <para>Puede comprobar el estado de la tarjeta de sonido en
      el fichero <filename>/dev/sndstat</filename>:</para>

    <screen>&prompt.root; <userinput>cat /dev/sndstat</userinput>
FreeBSD Audio Driver (newpcm)
Installed devices:
pcm0: &lt;Intel ICH3 (82801CA)&gt; at io 0xd800, 0xdc80 irq 5 bufsz 16384
kld snd_ich (1p/2r/0v channels duplex default)</screen>

    <para>El resultado en su sistema seguramente será distinto.  Si
      no aparecen dispositivos <filename>pcm</filename> revise todo el
      proceso a ver dónde está el error.  Revise su fichero
      de configuración del kernel nuevamente y compruebe que
      eligió el controlador de dispositivo adecuado.  Tiene una
      lista de problemas habituales en la <xref linkend="troubleshooting"/>.</para>

    <para>Si todo ha ido bien ya tiene una tarjeta de sonido funcionando
      en su sistema.  Si los pins de salida de sonido de su CD-ROM o DVD-ROM
      están colocados correctamente puede poner un CD en la unidad
      y reproducirlo con &man.cdcontrol.1;.</para>

      <screen>&prompt.user; <userinput>cdcontrol -f /dev/acd0 play 1</userinput></screen>

    <para>Hay muchas aplicaciones como <package>audio/workman</package> que le ofrecerán
      un interfaz más amigable.  Si quiere escuchar ficheros MP3
      puede instalar, por ejemplo,
      <package>audio/mpg123</package>.</para>

    <para>Hay otra via aún más rápida de probar su
      tarjeta de sonido.  Envíe datos a
      to <filename>/dev/dsp</filename> del siguiente modo:</para>

    <screen>&prompt.user; <userinput>cat fichero &gt; /dev/dsp</userinput></screen>

    <para>donde <filename>fichero</filename>
      puede ser cualquier fichero.  Esta orden producirá ruido,
      lo que confirmará que la tarjeta de sonido funciona.</para>

    <para>Puede manejar los niveles de la tarjeta de sonido con &man.mixer.8;.
      Tiene todos los detalles en la página de manual de
      &man.mixer.8;.</para>

    <sect3 xml:id="troubleshooting">
      <title>Problemas habituales</title>

      <indexterm><primary>device nodes</primary></indexterm>
      <indexterm><primary>I/O port</primary></indexterm>
      <indexterm><primary>IRQ</primary></indexterm>
      <indexterm><primary>DSP</primary></indexterm>

      <informaltable frame="none" pgwide="1">
         <tgroup cols="2">
  	  <thead>
	    <row>
	     <entry>Error</entry>
	      <entry>Solution</entry>
	    </row>
          </thead>

	  <tbody>
            <row>
              <entry><errorname>sb_dspwr(XX) timed out</errorname></entry>
              <entry><para>El puerto de E/S no ha sido configurado correctamente.</para></entry>
            </row>

            <row>
              <entry><errorname>bad irq XX</errorname></entry>
	      <entry><para>No ha elegido correctamente la IRQ.  Asegúrese
  	        de que la IRQ que ha elegido y la IRQ del sonido son la misma.</para></entry>
            </row>

            <row>
              <entry><errorname>xxx: gus pcm not attached, out of memory</errorname></entry>
              <entry><para>No queda memoria suficiente en el sistema para poder
	        usar el dispositivo.</para></entry>
            </row>

            <row>
              <entry><errorname>xxx: can't open /dev/dsp!</errorname></entry>
              <entry><para>Compruebe si hay otra aplicación utilizando
	        (y por tanto ocupando) el dispositivo.  Escriba
	        <command>fstat | grep dsp</command>.  Los sospechosos
                habituales son <application>esound</application> y
		el sistema de sonido de <application>KDE</application>.
                </para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect3>
  </sect2>

  <sect2 xml:id="sound-multiple-sources">
    <info><title>Cómo utilizar múltiples fuentes de sonido</title>
     <authorgroup>
      <author><personname><firstname>Munish</firstname><surname>Chopra</surname></personname><contrib>Escrito por </contrib></author>
     </authorgroup>
    </info>
    

    <para>Disponer de múltiples fuentes de sonido puede ser muy
      útil, por ejemplo cuando
      <application>esound</application> o
      <application>artsd</application> no permiten compartir el dispositivo
      de sonido con otra aplicación.</para>

    <para>&os; permite hacerlo gracias a los <emphasis>Virtual Sound
      Channels</emphasis> (<literal>canales virtuales de sonido</literal>),
      que se activan mediante &man.sysctl.8;.  Los canales virtuales
      permiten multiplexar la reproducción de sonido de su tarjeta
      mezclando el sonido en el kernel.</para>

    <para>El número de canales virtuales se configura utilizando
      dos sysctl; como <systemitem class="username">root</systemitem> escriba lo siguiente:</para>
    <screen>&prompt.root; <userinput>sysctl hw.snd.pcm0.vchans=4</userinput>
&prompt.root; <userinput>sysctl hw.snd.maxautovchans=4</userinput></screen>

    <para>En el ejemplo anterior se han creado cuatro canales virtuales, una
      cantidad muy razonable para el uso normal.
      <varname>hw.snd.pcm0.vchans</varname> es el número de canales
      virtuales de que dispone <filename>pcm0</filename>; puede configurarlo
      en cuanto el dispositivo sea reconocido por el sistema.
      <literal>hw.snd.maxautovchans</literal> es el número de canales
      virtuales que se le asignan a un nuevo dispositivo de audio cuando se
      conecta al sistema mediante &man.kldload.8;.  Puesto que el
      módulo <filename>pcm</filename> puede cargarse independientemente
      de los controladores de hardware
      <varname>hw.snd.maxautovchans</varname> puede almacenar cuántos
      canales virtuales tienen asignados los dispositivos que se vayan
      conectando al sistema.</para>

    <note>
      <para>No es posible modificar el número de canales virtuales
        de un dispositivo que esté en marcha.  Cierre antes todos
	los programas que estén utilizando el dispositivo, como
	reproductores de música o d&aelig;mons de sonido.</para>
    </note>

    <para>Si no usa &man.devfs.5; tendrá que configurar sus
      aplicaciones para que apunten a
      <filename>/dev/dsp0</filename>.<replaceable>x</replaceable>,
      donde <replaceable>x</replaceable> es un número entre 0 y 3 si
      <varname>hw.snd.pcm.0.vchans</varname> tiene un valor de 4 como en el
      ejemplo anterior.  Si se estuviera usando
      &man.devfs.5; en el ejemplo anterior cualquier programa que pidiera
      <filename>/dev/dsp0</filename> sería atendido de
      forma totalmente transparente.</para>
   </sect2>

  <sect2>
    <info><title>Asignación a los canales de mezcla de valores por omisión</title>
      <authorgroup>
	<author><personname><firstname>Josef</firstname><surname>El-Rayes</surname></personname><contrib>Escrito por </contrib></author>
      </authorgroup>
    </info>

    

    <para>Los valores por defecto de los distintos canales de mezcla
      están fijados en el código del controlador
      &man.pcm.4;.  Hay distintas aplicaciones y d&aelig;mons
      que le permitirán asignar valores al mezclador y que
      permanezcan entre uso y uso, pero no es una solución
      demasiado limpia.  Puede asignar valores por omisión a
      las mezclas a nivel de controlador definiendo los valores
      apropiados en <filename>/boot/device.hints</filename>.  Veamos
      un ejemplo:</para>

<programlisting>hint.pcm.0.vol="50"</programlisting>

    <para>Esto asignará al canal de volumen un valor por
      omisión de 50 al cargar el módulo
      &man.pcm.4;.</para>
  </sect2>
</sect1>



  <sect1 xml:id="sound-mp3">
    <info><title>Sonido MP3</title>
      <authorgroup>
	<author><personname><firstname>Chern</firstname><surname>Lee</surname></personname><contrib>Escrito por </contrib></author>
      </authorgroup>
      
    </info>

    

    <para>El formato MP3 (MPEG Layer 3 Audio) llega casi al nivel de
      calidad del CD, por lo que no hay motivo por el deba faltar en
      su escritorio &os;.</para>

    <sect2 xml:id="mp3-players">
      <title>Reproductores de MP3</title>

      <para>El reproductor de MP3 para X11 más extendido
	es, de lejos, <application>XMMS</application> (X Multimedia System).
	Puede usar en él «skins»de
	<application>Winamp</application> puesto que el interfaz
	gráfico de <application>XMMS</application> es casi
	idéntico al de Nullsoft
	<application>Winamp</application>.
	<application>XMMS</application> incluye también soporte nativo
	para «plug-ins».</para>

      <para>Puede instalar <application>XMMS</application> como port
	(<package>multimedia/xmms</package>) o como package.</para>

      <para>La interfaz de <application>XMMS</application> es intuitiva e
	incluye una lista de reproducción, un ecualizador
	gráfico y muchas otras cosas.  Si está acostumbrado
	a <application>Winamp</application>
	<application>XMMS</application> le será muy
	fácil de usar.</para>

      <para>El port <package>audio/mpg123</package>
        es un reproductor MP3 que se usa desde la shell.</para>

      <para>Puede especificarle desde la misma línea de órdenes
        a <application>mpg123</application> el dispositivo de
        sonido que debe usar y el fichero MP3 que debe reproducir.  Veamos
	un ejemplo:</para>

      <screen>&prompt.root; <userinput>mpg123 -a /dev/dsp1.0 ASaber-GrandesÉxitos.mp3</userinput>
High Performance MPEG 1.0/2.0/2.5 Audio Player for Layer 1, 2 and 3.
Version 0.59r (1999/Jun/15). Written and copyrights by Michael Hipp.
Uses code from various people. See 'README' for more!
THIS SOFTWARE COMES WITH ABSOLUTELY NO WARRANTY! USE AT YOUR OWN RISK!





Playing MPEG stream from ASaber-GrandesÉxitos.mp3 ...
MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo
</screen>

      <para>Sustituya <filename>/dev/dsp1.0</filename>
	por el dispositivo <filename>dsp</filename> que haya en su
	sistema.</para>

    </sect2>

    <sect2 xml:id="rip-cd">
      <title>Extracción de pistas de sonido de un CD</title>

      <para>Antes de convirtir una pista o todo un CD a MP3 la información
        sonido debe volcarse al disco duro.  Esto se hace convirtiendo
	los datos «raw CDDA» (CD Digital Audio) a ficheros
	WAV.</para>

      <para>La herramienta <command>cdda2wav</command>, que forma parte
	del port <package>sysutils/cdrtools</package>,
	permite la extracción de información de sonido en
	CD así como la información asociada a él.</para>

      <para>Con el CD en la unidad la siguiente orden
	(como <systemitem class="username">root</systemitem>) un CD entero en ficheros WAV
	individuales, uno por pista:</para>

      <screen>&prompt.root; <userinput>cdda2wav -D 0,1,0 -B</userinput></screen>

      <para><application>cdda2wav</application> soporta unidades CDROM
	ATAPI (IDE).  En el caso de unidades IDE  especifique
	el número de dispositivo en el lugar correspondiente al
	núro de unidad SCSI.  Por ejemplo, para extraer la pista
	7 desde una unidad IDE:</para>

      <screen>&prompt.root; <userinput>cdda2wav -D /dev/acd0 -t 7</userinput></screen>

      <para>La opción
        <option>-D <replaceable>0,1,0</replaceable></option>
	indica el dispositivo SCSI <filename>0,1,0</filename>,
	que corresponde con la salida de <command>cdrecord
	-scanbus</command>.</para>

      <para>Para extraer pistas de forma selectiva use la opción
	<option>-t</option>:</para>

      <screen>&prompt.root; <userinput>cdda2wav -D 0,1,0 -t 7</userinput></screen>

      <para>Esta opción extrae la séptima pista de un CDROM
        de sonido.  Si quiere extraer un rango de pistas, por ejemplo las
	pistas de la uno a la siete, declare el rango del siguiente
	modo:</para>

      <screen>&prompt.root; <userinput>cdda2wav -D 0,1,0 -t 1+7</userinput></screen>

      <para>La herramienta &man.dd.1; le permite también extraer
        pistas de sonido desde unidades ATAPI; consulte la <xref linkend="duplicating-audiocds"/> para más
	información.</para>

    </sect2>

    <sect2 xml:id="mp3-encoding">
      <title>Codificación de MP3</title>

      <para>Hoy por hoy el codificador de MP3 por antonomasia es
	<application>lame</application>.
	Puede encontrar <application>lame</application> en
	<package>audio/lame</package>.</para>

      <para>Partiendo de ficheros WAV previamente extraidos la
        siguiente orden convierte
	<filename>audio01.wav</filename> en
	<filename>audio01.mp3</filename>:</para>

      <screen>&prompt.root; <userinput>lame -h -b 128 \
--tt "Título de copla o cantar" \
--ta "Grupo, solista o coral sinfónica" \
--tl "Título del álbum" \
--ty "2001" \
--tc "Autor de la extracción y paso a MP3" \
--tg "Estilo" \
audio01.wav audio01.mp3</userinput></screen>

      <para>Los 128&nbsp;kbits pasan por se el estándar de ratio
        de bits de los MP3, aunque puede que usted sea de los que prefieren
	calidades más altas, 160 o incluso 192.  A mayor ratio
	de bits, más espacio en disco necesitará, aunque
	la calidad también será mayor.  La opción
	<option>-h</option> usa el modo «más calidad pero
	algo más lento».  Las opciones que empiezan por
	<option>--t</option> indican etiquetas ID3, que suelen contener
	información de la canción que contiene el fichero
	MP3.  Tiene información sobre otras opciones de
	codificación en la página de manual de
	<application>lame</application>.</para>
    </sect2>

    <sect2 xml:id="mp3-decoding">
      <title>Decodificación de MP3</title>

      <para>Para grabar un CD de sonido desde ficheros MP3 hay
        que convertirlos a formato WAV no comprimido.  Tanto
	<application>XMMS</application> como
	<application>mpg123</application> soportan la conversión
	de MP3 a un formato de fichero no comprimido.</para>

      <para>Escritura a disco desde <application>XMMS</application>:</para>

      <procedure>
	<step>
	  <para>Arranque <application>XMMS</application>.</para>
	</step>

	<step>
	  <para>Botón derecho del raón en la
	    ventana para acceder al menú de
	    <application>XMMS</application>.</para>
	</step>

	<step>
	  <para>Elija <literal>Preferences</literal> en
	    <literal>Options</literal>.</para>
	</step>

	<step>
	  <para>Cambie el «Output Plugin» a «Disk Writer
	      Plugin».</para>
	</step>

	<step>
	  <para>Pulse <literal>Configure</literal>.</para>
	</step>

	<step>
	  <para>Elija un directorio en el que guardar los ficheros
	    descomprimidos.</para>
	</step>

	<step>
	  <para>Cargue el fichero MP3 en <application>XMMS</application>
	    de la forma habitual, pero asegúrese de tener el
	    volumen al 100% y las opciones de ecualización
	    desactivadas.</para>
	</step>

	<step>
	  <para>Pulse <literal>Play</literal> &mdash;  parecerá
	    que <application>XMMS</application> está reproduciendo
	    música pero no sonará nada.  Lo que está
	    haciendo es volcar el MP3 a un fichero.</para>
	</step>

	<step>
	  <para>Recuerde que antes de poder volver a escuchar ficheros
	    MP3 de nuevo tendrá que devolver el «Plugin de
	    salida» por omisión a la posición
	    inicial.</para>
	</step>
      </procedure>

      <para>Escritura de la salida estándar en <application>mpg123</application>:</para>

      <procedure>
	<step>
	  <para>Ejecute <command>mpg123 -s audio01.mp3
	    &gt; audio01.pcm</command></para>
	</step>
      </procedure>

      <para><application>XMMS</application> genera un fichero WAV,
	mientras que  <application>mpg123</application> convierte MP3 a
	datos de sonido raw PCM.  Puede usar
	<application>cdrecord</application> con ambos formatos para crear
	CD de sonido.  Tendrá que usar &man.burncd.8; para raw PCM.
	Si lo que tiene son ficheros WAV escuchará un ligero clic
	al principio de cada pista: se trata de la cabecera del fichero
	WAV.  Puede eliminar esta cabecera mediante
	<application>SoX</application> (que puede instalar como port desde
	<package>audio/sox</package> o si lo prefiere como
	package):</para>

      <screen>&prompt.user; <userinput>sox -t wav -r 44100 -s -w -c 2 pista.wav pista.raw</userinput></screen>

      <para>Consulte la <xref linkend="creating-cds"/> para más
        información sobre el uso de grabadoras de CD en
	&os;.</para>
    </sect2>
 </sect1>


 <sect1 xml:id="video-playback">
  <info><title>Reproducción de vídeo</title>
    <authorgroup>
      <author><personname><firstname>Ross</firstname><surname>Lippert</surname></personname><contrib>Contributed by </contrib></author>
    </authorgroup>
    
  </info>


  

    <para>La reproducción de vídeo es un área muy
      nueva y en la que se producen grandes cambios a gran velocidad.
      Tenga paciencia.  Aquí no va a ser todo tan sencillo como al
      configurar el sonido.</para>

    <para>Antes de comenzar es imprescindible que sepa con certeza
      cuál es el modelo de su tarjeta gráfica y qué
      chip usa.  Tanto <application>&xorg;</application> como
      <application>&xfree86;</application> soportan gran cantidad de
      tarjetas gráficas, pero de pocas se puede decir que den
      un buen rendiemiento de reproducción.  Puede consultar una
      lista de extensiones que el servidor X  puede hacer funcionar en
      su tarjeta ejecutando &man.xdpyinfo.1; desde una sesión
      X11.</para>

    <para>Le recomendamos que tenga a mano un fichero MPEG no muy
      grande para usarlo en las pruebas que haga con los diversos
      reproductores y opciones.  Algunos reproductores de DVD
      buscarán por omisión soportes DVD en
      <filename>/dev/dvd</filename> (algunos incluso tienen fijado en
      el código el nombre de dicha unidad) seguramente le
      resultará útil ejecutar los siguientes enlaces
      simbólicos:</para>

      <screen>&prompt.root; <userinput>ln -sf /dev/acd0 /dev/dvd</userinput>
&prompt.root; <userinput>ln -sf /dev/acd0 /dev/rdvd</userinput></screen>

    <para>Tenga en cuenta que debido al diseño de &man.devfs.5;
      los enlaces creados a mano no sobrevivirán a un reinicio
      del sistema.  Para que así suceda tras cada reinicio debe
      añadir las siguientes líneas a
      <filename>/etc/devfs.conf</filename>:</para>

    <programlisting>link acd0 dvd
link acd0 rdvd</programlisting>

    <para>Además, el descifrado de DVD (una tarea que hará
      necesario llamar a funciones especiales de los DVD-ROM)
      requiere permisos de escritura en unidades DVD.</para>

    <para>Le recomendamos que aumente la memoria compartida del
      interfaz X11, para lo cual tendrá que incremente los
      valores asignados a varias &man.sysctl.8;:</para>

      <programlisting>kern.ipc.shmmax=67108864
kern.ipc.shmall=32768</programlisting>

  <sect2 xml:id="video-interface">
    <title>Cómo determinar las características de video</title>

    <indexterm><primary>XVideo</primary></indexterm>
    <indexterm><primary>SDL</primary></indexterm>
    <indexterm><primary>DGA</primary></indexterm>

    <para>Hay varias formas de reproducir vídeo en X11, pero cuál
      de ellas sea la que funcione depende en gran medida del
      hardware que intervenga.  Cada uno de los métodos que
      se describen más son mejores o peores según en
      qué hardware se ejecute.  Además el procesamiento de
      video en X11 es un asunto que está recibiendo mucha
      atención últimamente y en cada nueva versión
      de <application>&xorg;</application> y de
      <application>&xfree86;</application> no es extraño encontrar
      avances significativos.</para>

    <para>Veamos una lista de interfaces de vídeo muy comunes:</para>

    <orderedlist>
    <listitem>
      <para>X11: salida normal de X11 utilizando memoria compartida.</para>
    </listitem>
    <listitem>
      <para>XVideo: una extensión del interfaz X11 que permite la
        reproducción de vídeo en las ventanas de X11.</para>
    </listitem>
    <listitem>
      <para>SDL: Simple Directmedia Layer.</para>
    </listitem>
    <listitem>
      <para>DGA: Direct Graphics Access (<literal>acceso directo
        a gráficos</literal>.</para>
    </listitem>
    <listitem>
      <para>SVGAlib: capa de consola de gráficos a bajo nivel.</para>
    </listitem>
    </orderedlist>

    <sect3 xml:id="video-interface-xvideo">
    <title>XVideo</title>

      <para><application>&xorg;</application> y
        <application>&xfree86; 4.X</application> tienen una extensión
        llamada <emphasis>XVideo</emphasis> (también conocida como Xvideo,
	Xv o xv) que permite reproducir vídeo en ventanas del sistema
        X11 a través de un tipo de aceleración especial.
	Dicha extensión ofrece una calidad de reproducción
	muy alta incluso en máquinas muy cortas de recursos.</para>

      <para>Utilice <command>xvinfo</command> para saber qué
        extensión está utilizando:</para>

        <screen>&prompt.user; <userinput>xvinfo</userinput></screen>

      <para>XVideo is supported for your card if the result looks like:</para>
<screen>X-Video Extension version 2.2
screen #0
  Adaptor #0: "Savage Streams Engine"
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
      "XV_COLORKEY" (range 0 to 16777215)
              client settable attribute
              client gettable attribute (current value is 2110)
      "XV_BRIGHTNESS" (range -128 to 127)
              client settable attribute
              client gettable attribute (current value is 0)
      "XV_CONTRAST" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_SATURATION" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_HUE" (range -180 to 180)
              client settable attribute
              client gettable attribute (current value is 0)
    maximum XvImage size: 1024 x 1024
    Number of image formats: 7
      id: 0x32595559 (YUY2)
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        type: YUV (packed)
      id: 0x32315659 (YV12)
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x30323449 (I420)
        guid: 49343230-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x36315652 (RV16)
        guid: 52563135-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x3e0, 0x7c00
      id: 0x35315652 (RV15)
        guid: 52563136-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x7e0, 0xf800
      id: 0x31313259 (Y211)
        guid: 59323131-0000-0010-8000-00aa00389b71
        bits per pixel: 6
        number of planes: 3
        type: YUV (packed)
      id: 0x0
        guid: 00000000-0000-0000-0000-000000000000
        bits per pixel: 0
        number of planes: 0
        type: RGB (packed)
        depth: 1
        red, green, blue masks: 0x0, 0x0, 0x0</screen>

    <para>Tenga en cuenta que los formatos que aparecen en el listado
     (YUV2, YUV12, etc) no aparecen en todas las implementaciones de
     de XVideo y su ausencia puede despistar a algunos
     reproductores.</para>

    <para>Si el resultado se parece mucho a esto</para>
<screen>X-Video Extension version 2.2
screen #0
no adaptors present</screen>

    <para>lo más probable es que su tarjeta no soporte XVideo.</para>

    <para>Si su tarjeta gráfica no soporta XVideo lo único
      que significa es que para su sistema será más
      complicado alcanzar los requisitos computacionales necesarios
      para el procesamiento de vídeo.  Dependiendo de la tarjeta
      gráfica y el procesador que tenga es posible que de todos
      modos pueda salvar la papeleta.  Consulte la sección sobre
      recursos avanzados en la <xref linkend="video-further-reading"/>.</para>

    </sect3>

    <sect3 xml:id="video-interface-SDL">
    <title>Simple Directmedia Layer</title>

    <para>SDL (Simple Directmedia Layer) se creó pensando en una
      capa que permitiera aplicaciones fáciles de portar entre las
      plataformas  &microsoft.windows;, BeOS y &unix; y que permitiera
      al mismo tiempo un uso eficiente del sonido y el vídeo.  La
      capa SDL ofrece abstracción de hardware a bajo nivel, lo que
      a veces puee ser más eficiente que la propia
      interfaz X11.</para>

    <para>SDL está en <package>devel/sdl12</package>.</para>

    </sect3>

    <sect3 xml:id="video-interface-DGA">
    <title>Direct Graphics Access</title>

    <para>«Direct Graphics Access» es una extensión
      de X11 que permite que un programa sortée el servidor X y
      acceda directamente al «framebuffer».  Utiliza memoria
      de bajo nivel, así es imprescindible que se ejecute como
      <systemitem class="username">root</systemitem>.</para>

    <para>Puede probar y analizar el rendimiento de la extensión
      DGA con &man.dga.1;.  Al ejecutar <command>dga</command> la pantalla
      cambia de color cada vez que pulsa una tecla.  Para salir de la
      aplicación pulse <keycap>q</keycap>.</para>

    </sect3>

  </sect2>

  <sect2 xml:id="video-ports">
    <title>Ports y packages relacionados con el vídeo</title>

    <indexterm><primary>video ports</primary></indexterm>
    <indexterm><primary>video packages</primary></indexterm>

    <para>Esta sección expone el software existente en la
      Colección de Ports de &os; que puede usar para la
      reproducción de vídeo.  La reproducción
      de vídeo es un área del desarrollo de software
      donde hay muchísima actividad, de manera que las
      características de más de una de las aplicaciones
      que vamos a describir pueden ser distintas.</para>

    <para>Lo primero que hay que conocer es el importante detalle de
      que la mayoría de las aplicaciones de vídeo
      que funcionan en &os; se desarrollaron para Linux.  Muchas de
      esas aplicaciones todavía están en versiones
      beta.  Estos son algunos de los problemas que puede encontrarse
      durante el uso de software de vídeo en &os;:</para>

      <orderedlist>

      <listitem>
	<para>Una aplicación no puede reproducir un fichero
	  que ha generado otra aplicación distinta.</para>
      </listitem>

      <listitem>
	<para>Una aplicación no puede reproducir un fichero
	  que ella misma a generado.</para>
      </listitem>

      <listitem>
	<para>La misma aplicación ejecutándose en dos
	  máquinas distintas, compilada en cada una de esas
	  máquinas; la reproducción del mismo fichero
	  da resultados diferentes.</para>
      </listitem>

      <listitem>
	<para>El uso de un filtro aparentemente trivial como es
	  redimensionar una imagen aplicando una escala da como fruto un
	  resultado horroroso debido a que la rutina encargada de
	  aplicarla es defectuosa.</para>
      </listitem>

      <listitem>
        <para>Que una aplicación de volcados de memoria («core
	  dumps»).</para>
      </listitem>

      <listitem>
        <para>La documentación no se instala con el port, pero
	  sí que existe en la web o en el directorio
          <filename>work</filename> del port.</para>
      </listitem>

      </orderedlist>

    <para>La mayoría de estas aplicaciones muestra
      síntomas evidente de «Linuxismo», es decir,
      hay problemas derivados del modo en el que se implementan las
      bibliotecas en las distribuciones de Linux, o del hecho de que
      ciertas características del kernel de Linux han sido
      dadas por omnipresentes por los autores de las aplicaciones.  Estos
      problemas no siempre han sido advertidas y solucionadas de algún
      modo por los responsables de los ports, lo que puede desembocar
      en problemas como:</para>

      <orderedlist>

      <listitem>
        <para>El uso de <filename>/proc/cpuinfo</filename> para detectar
          las características del procesador.</para>
      </listitem>

      <listitem>
	<para>El uso erróneo de los hilos puede causar que
	  ciertos programas se cuelguen al intentar cerrarse en lugar
	  de cerrarse correctamente.</para>
      </listitem>

      <listitem>
	<para>Software que aún no está en la
	  Colección de Ports de &os; usado frecuentemente con
	  la aplicación.</para>
      </listitem>

      </orderedlist>

      <para>Hasta ahora los autores de las aplicaciones han colaborado
        de buen grado con los responsables de los ports para hacer
	más sencillo el trabajo de portar estas aplicaciones
	a &os;.</para>

    <sect3 xml:id="video-mplayer">
      <title>MPlayer</title>

      <para><application>MPlayer</application> es un reproductor de
        vídeo desarrollado muy recientemente y con un desarrollo
	rapidísimo.  Los objetivos del equipo
        <application>MPlayer</application> son la velocidad y la flexibilidad
	en Linux y otros sistemas Unix.  El proyecto comenzó
	cuando el fundador del equipo se cansó de padecer
	el pobre rendimiento de los reproductores de vídeo
	que había disponibles en ese momento.  Hay quien dice
	que el interfaz gráfico fue sacrificado en pos de
	un diseño más ligero, aunque una vez que
	se acostumbre a las opciones desde la línea de
	órdenes y a los atajos de teclado todo irá
	como la seda.</para>

      <sect4 xml:id="video-mplayer-building">
        <title>Compilación de MPlayer</title>
        <indexterm><primary>MPlayer</primary>
	           <secondary>making</secondary></indexterm>

	<para>Encontrará <application>MPlayer</application> en <package>multimedia/mplayer</package>.
	  <application>MPlayer</application> ejecuta una serie de
	  pruebas de hardware durante el proceso de compilación,
	  dando como resultado un binario que no tiene por qué
	  funcionar en otros sistemas.  Recuerde, por tanto, compilar
	  la aplicación como port y no utilice el package
	  binario.  Además hay múltiples parámetros
	  que puede pasarle a <command>make</command>, tal y como
	  verá al comenzar la compilación:</para>

	<screen>&prompt.root; <userinput>cd /usr/ports/multimedia/mplayer</userinput>
&prompt.root; <userinput>make</userinput>
N - O - T - E

Take a careful look into the Makefile in order
to learn how to tune mplayer towards you personal preferences!
For example,
make WITH_GTK1
builds MPlayer with GTK1-GUI support.
If you want to use the GUI, you can either install
/usr/ports/multimedia/mplayer-skins
or download official skin collections from
http://www.mplayerhq.hu/homepage/dload.html
</screen>

	<para>Las opciones por omisión del port deberían
	  bastar para la mayoría de los usuarios, aunque si
	  va a necesitar el codec XviD tendrá que especificar
	  <varname>WITH_XVID</varname> en la línea de
	  órdenes.  La unidad de DVD por defecto se puede
	  definir con la opción
	  <varname>WITH_DVD_DEVICE</varname>si la opción por omisión,
	  <filename>/dev/acd0</filename>, no le sirve.</para>

        <para>En el momento de escribir esto el port de
	  <application>MPlayer</application> genera la documentación
	  en formato HTML y dos ejecutables:
          <command>mplayer</command> y
          <command>mencoder</command>, que es una herramienta para
          recodificar vídeo.</para>

        <para>La documentación en HTML de
	  <application>MPlayer</application> es muy informativa.  Si el
	  lector no cubre todas sus dudas sobre hardware de vídeo
	  e interfaces con el contenido de este capítulo la
          documentación de <application>MPlayer</application>
          es el sitio donde debe buscar.  Si quiere más información
	  sobre el soporte de vídeo en &unix; el mejor sitio para
	  consultar es, sin duda alguna, la documentación de
          <application>MPlayer</application>.</para>

      </sect4>

      <sect4 xml:id="video-mplayer-using">
        <title>Uso de MPlayer</title>
        <indexterm><primary>MPlayer</primary>
	           <secondary>use</secondary></indexterm>

        <para>Los usuarios de <application>MPlayer</application> deben
          crear un subdirectorio <filename>.mplayer</filename> en su
          «home».  Para crear este directorio (necesario
	  para el funcionamiento de la aplicación) teclée
	  lo siguiente:</para>

<screen>&prompt.user; <userinput>cd /usr/ports/multimedia/mplayer</userinput>
&prompt.user; <userinput>make install-user</userinput></screen>

	<para>Las opciones de <command>mplayer</command> para la línea
	  de órdenes se detallan en la página de manual.  Si
	  necesita todavía más detalles consulte la
	  documentación en HTML.  En esta sección se
	  va a explicar solamente lo más básico.</para>

	<para>Para reproducir el fichero
	  <filename>ficherodeprueba.avi</filename>,
	  mediante una de las diversas interfaces de vídeo utilice la
	  opción <option>-vo</option>:</para>

	  <screen>&prompt.user; <userinput>mplayer -vo xv ficherodeprueba.avi</userinput></screen>
	  <screen>&prompt.user; <userinput>mplayer -vo sdl ficherodeprueba.avi</userinput></screen>
	  <screen>&prompt.user; <userinput>mplayer -vo x11 ficherodeprueba.avi</userinput></screen>
	  <screen>&prompt.root; <userinput>mplayer -vo dga ficherodeprueba.avi</userinput></screen>
	  <screen>&prompt.root; <userinput>mplayer -vo 'sdl:dga' ficherodeprueba.avi</userinput></screen>

	<para>Merece la pena que pruebe todas, puesto que el rendimiento
	  relativo depende en gran medida de muchos factores y será
	  muy distinto el resultado dependiendo del hardware.</para>

	<para>Si quiere reproducir un DVD sustituya
	 <filename>ficherodeprueba.avi</filename> por <option>dvd://<replaceable>N</replaceable> -dvd-device
	 <replaceable>DISPOSITIVO</replaceable></option>, donde
	 <replaceable>N</replaceable> es
	 el número de título que quiere reproducir y
	 <filename>DISPOSITIVO</filename> es el
	 nodo de dispositivo del DVD-ROM.  Veamos un ejemplo: para reproducir el
	 título 3 desde <filename>/dev/dvd</filename>
	 ejecutaremos:</para>

	<screen>&prompt.root; <userinput>mplayer -vo xv dvd://3 -dvd-device /dev/dvd</userinput></screen>

	<note>
	  <para>La unidad de DVD por omisión puede definirse
	    durante la compilación del port de
	    <application>MPlayer</application> con la opción
	    <varname>WITH_DVD_DEVICE</varname>.  Por defecto apunta a
	    <filename>/dev/acd0</filename>.  Tiene todos los
	    detalles en el
	    <filename>Makefile</filename> del port.</para>
	</note>

	<para>Consulte los atajos de teclado para parar la
	  reproducción, ponerla en pausa, etc. consulte la
	  salida de <command>mplayer -h</command> o mejor aún
	  lése la página de manual.</para>

	<para>Hay otras opciones que le resultarán de interés
	  para la reproducción:
          <option>-fs -zoom</option>, para la reproducción a pantalla
          completa y <option>-framedrop</option>, que mejora el
	  rendimiento.</para>

	<para>Para evitar que la línea de órdenes se
	  haga demasiado larga puede crear un fichero
	  <filename>.mplayer/config</filename> e introducir en él
	  las opciones que quiera usar desde el arranque de la
	  aplicación:</para>
<programlisting>vo=xv
fs=yes
zoom=yes</programlisting>

	<para>Para terminar, puede usar <command>mplayer</command>
	  para extraer un título de un DVD a un fichero
	  <filename>.vob</filename>.  Por ejemplo, si quiere extraer
	  el segundo título de un DVD escriba esto:</para>

	  <screen>&prompt.root; <userinput>mplayer -dumpstream -dumpfile salida.vob dvd://2 -dvd-device /dev/dvd</userinput></screen>

        <para>El fichero de salida, <filename>salida.vob</filename>,
	  un MPEG y puede manipularlo con las aplicaciones que se
	  describen en esta sección.</para>

      </sect4>
      <sect4 xml:id="video-mencoder">
        <title>mencoder</title>
        <indexterm>
	  <primary>mencoder</primary>
	</indexterm>

	<para>Antes de empezar a usar
         <command>mencoder</command> le recomendamos que se familiarice
	 con las opciones que se detallan en la documentación
	 HTML.  Hay también una página de manual, pero no
	 es de mucha utilidad sin la documentación HTML.  Hay una
	 ingente cantidad de formas de mejorar la calidad, reducir el
	 ratio de bits y cambiar formatos; alguno de esos pequeños
	 trucos pueden marcar la diferencia entre un buen y un mal
	 rendimiento.  Le mostramos un par de ejemplos por los que
	 puede empezar.  El primero es una simple copia:</para>

	 <screen>&prompt.user; <userinput>mencoder entrada.avi -oac copy -ovc copy -o salida.avi</userinput></screen>

         <para>Ciertas combinaciones erróneas de opciones en la
	 línea de órdenes pueden dar como fruto un fichero
	 de salida que no puede reproducir ni siquiera el propio
	 <command>mplayer</command>, así que si lo que quiere es
	 extraer datos a un fichero siga usando tranquilamente la opción
	 <option>-dumpfile</option> de
	 <command>mplayer</command>.</para>

	 <para>Para convertir
	 <filename>entrada.avi</filename> con
	 codificación MPEG4 y audio con codificación MPEG3
	 (necesitará <package>audio/lame</package>):</para>

	 <screen>&prompt.user; <userinput>mencoder entrada.avi -oac mp3lame -lameopts br=192 \
	 -ovc lavc -lavcopts vcodec=mpeg4:vhq -o salida.avi</userinput></screen>

	 <para>El fichero de salida puede verse con <command>mplayer</command>
	 y con <command>xine</command>.</para>

	 <para>Si sustituye
	   <filename>entrada.avi</filename>
	   por <option>dvd://1 -dvd-device /dev/dvd</option> y lo ejecuta
	   como <systemitem class="username">root</systemitem> puede recodificar un título
	   de DVD directamente.  Es posible que el resultado no sea
	   muy satisfactorio tras los primeros intentos, así que
	   le recomendamos que vuelque el título a un fichero
	   y haga todas las pruebas que necesite sobre ese fichero.</para>
      </sect4>

    </sect3>

    <sect3 xml:id="video-xine">
    <title>El reproductor de vídeo xine</title>

    <para>El reproductor de vídeo
      <application>xine</application> es un ambicioso proyecto que
      tiene como meta ofrecer no solamente una aplicación de
      vídeo «todo en uno», sino crear una
      biblioteca base reutilizable y un ejecutable modular que
      puede ampliarse mediante «plugins».  Existe como
      package y también como port: <package>multimedia/xine</package>.</para>

    <para>El reproductor <application>xine</application> está
     todavía en mantillas, pero sus primeros pasos están
     siendo muy interesantes.  <application>xine</application> requiere
     o una CPU rápida o una tarjeta gráfica, o bien
     soporte para la extensión XVideo.  El GUI es intuitivo, aunque
     un tanto pedestre.</para>

    <para>En el momento de escribir esto
     <application>xine</application> no incorpora ningún
     módulo de entrada que sirva para reproducir DVD codificados
     con CSS.  Hay versiones compiladas por terceros que tienen módulos
     que lo permiten, pero ninguna de ellas está en la
     Colección de Ports de &os;.</para>

    <para>Comparado con <application>MPlayer</application>
      <application>xine</application> deja las cosas más hechas
      para el usuario, pero al mismo tiempo pone más difícil
      el control exhaustivo sobre todo lo que pasa.  El reproductor
      <application>xine</application> da un mejor rendimiento
      en interfaces XVideo.</para>

    <para>Por omisión <application>xine</application> arranca
      con un intefaz gráfico de usuario.  Los menús
      pueden usarse para abrir un fichero en concreto:</para>

      <screen>&prompt.user; <userinput>xine</userinput></screen>

    <para>También puede invocar la aplicación desde la
      línea de órdenes para que reproduzca un fichero
      inmediatamente y sin utilizar el GUI:</para>

      <screen>&prompt.user; <userinput>xine -g -p fichero.avi</userinput></screen>

    </sect3>

    <sect3 xml:id="video-ports-transcode">
    <title>Las herramientas transcode</title>

    <para><application>transcode</application> no es un reproductor,
      sino una suite de herramientas para recodificar (también
      se podría usar la palabra «transcodificar», de
      ahí su nombre) ficheros de sonido y de vídeo.
      Con <application>transcode</application> es posible fundir ficheros
      de video y reparar ficheros deteriorados desde la línea de
      órdenes y en las interfaces de flujo
      <filename>stdin/stdout</filename>.</para>

    <para>Puede configurar gran cantidad de opciones en el
      momento de la compilación de <package>multimedia/transcode</package>; le
      recomendamos que use la siguiente línea de
      órdenes para compilar
      <application>transcode</application>:</para>

    <screen>&prompt.root; <userinput>make WITH_OPTIMIZED_CFLAGS=yes WITH_LIBA52=yes WITH_LAME=yes WITH_OGG=yes \
WITH_MJPEG=yes -DWITH_XVID=yes</userinput></screen>

    <para>La configuración que le proponemos deberí
      satisfacer a la mayoría de los usuarios.</para>

    <para>Veamos un ejemplo ilustrativo de las posibilidades de
      <command>transcode</command>: convertir un fichero DivX
      en un fichero PAL MPEG-1 (PAL VCD):</para>

      <screen>&prompt.user; <userinput>transcode -i input.avi -V --export_prof vcd-pal -o output_vcd</userinput>
&prompt.user; <userinput>mplex -f 1 -o output_vcd.mpg output_vcd.m1v output_vcd.mpa</userinput></screen>

    <para>Puede reproducir el fichero MPEG resultante,
      <filename>output_vcd.mpg</filename>,
      con <application>MPlayer</application>.  Si quiere también
      puede grabar el fichero en un CD-R y tendrá un VideoCD,
      aunque para eso tendrá que instalar <package>multimedia/vcdimager</package> y <package>sysutils/cdrdao</package>.</para>

    <para>Consulte la página de manual de <command>transcode</command>,
      pero no olvide consultar también el <link xlink:href="http://www.transcoding.org/cgi-bin/transcode">wiki de
      transcode</link>, en el que encontrará
      más información y muchos ejemplos.</para>
    </sect3>

  </sect2>

  <sect2 xml:id="video-further-reading">
    <title>Lecturas adicionales</title>

    <para>El desarrollo de las diversas aplicaciones de
      vídeo disponibles en &os; avanza
      rápidamente.  Es muy posible que en un futuro
      cercano la mayoría de los problemas de los que
      hemos hablado aquí hayan sido resueltos.  Mientras
      tanto quien quiera exprimir las capacidades de &os; en
      las áreas del sonido y el vídeo tendrán
      que recopilar la información repartida en varias
      FAQ y tutoriales y utilizar unos cuantos programas
      diferentes.  En esta sección se le proponen al
      lector interesado varias fuentes de información
      adicional.</para>

    <para>La
      <link xlink:href="http://www.mplayerhq.hu/DOCS/">documentación
      de MPlayer</link> contiene una gran cantidad de información
      técnica.  Cualquiera que quiera alcanzar un alto grado
      de conocimiento en vídeo sobre &unix; debe consultar
      esa documentación.  La lista de correo de
      <application>MPlayer</application> es sumamente hostil hacia
      quien no se ha molestado en leer la documentación
      <emphasis>antes</emphasis> de preguntar, así que si
      va a enviar informes de errores a esa lista, por favor,
      <emphasis>léase la documentación.</emphasis>.</para>

    <para>El texto
      <link xlink:href="http://dvd.sourceforge.net/xine-howto/en_GB/html/howto.html">      xine HOWTO</link>
      contiene un capítulo sobre mejora del rendimiento que
      afecta a todos los reproductores.</para>

    <para>Hay unas cuantas aplicaciones muy prometedoras que el lector
      debería al menos probar:</para>

    <itemizedlist>

       <listitem>
         <para><link xlink:href="http://avifile.sourceforge.net/">Avifile</link>, que
	   encontrará en los ports:<package>multimedia/avifile</package>.</para>
       </listitem>

       <listitem>
         <para><link xlink:href="http://www.dtek.chalmers.se/groups/dvd/">Ogle</link>,
	   también en la colección de  ports: <package>multimedia/ogle</package>.</para>
       </listitem>

       <listitem>
         <para><link xlink:href="http://xtheater.sourceforge.net/">Xtheater</link></para>
       </listitem>

	<listitem>
         <para><package>multimedia/dvdauthor</package>, una aplicación
           libre para la producción de contenidos en DVD.</para>
        </listitem>
    </itemizedlist>

  </sect2>
 </sect1>


  <sect1 xml:id="tvcard">
    <info><title>Configuración de tarjetas de TV</title>
      <authorgroup>
	<author><personname><firstname>Josef</firstname><surname>El-Rayes</surname></personname><contrib>Texto original de </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Ampliado y adaptado por </contrib></author>
      </authorgroup>
    </info>

    
    <indexterm>
      <primary>TV cards</primary>
    </indexterm>

    <sect2>
      <title>Introducción</title>

      <para>Las tarjetas de TV le permiten ver en su sistema
        emisiones de TV tradicionales o incluso por cable.  La
	mayoría aceptan vídeo compuesto mediante
	RCA o una entrada de S-video; algunas de estas tarjetas
	incorporan también un sintonizador de radio FM.</para>

      <para>&os; puede utilizar tarjetas de TV PCI que tengan el chip
	Brooktree Bt848/849/878/879 o el chip de captura de vídeo
	Conexant CN-878/Fusion 878a gracias al controlador
	&man.bktr.4;.  Asegúrese de que la tarjeta tiene un
	sintonizador que esté soportado: consulte la lista de
	sintonizadores soportados que encontrará en la página
	de manual de &man.bktr.4;.</para>
    </sect2>

    <sect2>
      <title>Añadir el controlador</title>

      <para>Poder usar la tarjeta tendrá que cargar el
        controlador &man.bktr.4;.  Una forma de hacerlo es
	añdir la siguiente línea al fichero
	<filename>/boot/loader.conf</filename>:</para>

      <programlisting>bktr_load="YES"</programlisting>

      <para>También puede hacerlo compilando estáticamente
        el soporte para la tarjeta de TV en su kernel;  añada
	las siguientes líneas al fichero de configuración
	de su kernel:</para>

      <programlisting>device	 bktr
device	iicbus
device	iicbb
device	smbus</programlisting>

      <para>Es necesario incluir todas esas lineas adicionales porque
        los componentes de la tarjeta están conectados entre
	sí por un bus I2C.  Hecho esto compile e instale su
	nuevo kernel.</para>

      <para>Una vez añadido el soporte de la tarjeta al sistema
        tendrá que reiniciar.  Durante el arranque deberían
	aparecer rastros de su tarjeta de TV. Veamos un ejemplo:</para>

      <programlisting>bktr0: &lt;BrookTree 848A&gt; mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: &lt;I2C bit-banging driver&gt; on bti2c0
iicbus0: &lt;Philips I2C bus&gt; on iicbb0 master-only
iicbus1: &lt;Philips I2C bus&gt; on iicbb0 master-only
smbus0: &lt;System Management Bus&gt; on bti2c0
bktr0: Pinnacle/Miro TV, Philips SECAM tuner.</programlisting>

      <para>Es obvio que estos mensajes serán distintos
        según sea el hardware del que se trate.
	Asegúrese de que el sistema detecta correctamente
	el sintonizador.  Se puede sobreescribir alguno de los
	parámetros detectados por el sistema mediante
	MIB &man.sysctl.8; y opciones del fichero de configuración
	del kernel.  Si por ejemplo quiere obligar al sintonizador
	para que se comporte como un Phillips SECAM añada
	lo siguiente al fichero de configuración de su
	kernel:</para>

      <programlisting>options OVERRIDE_TUNER=6</programlisting>

      <para>Puede utilizar directamente &man.sysctl.8;:</para>

      <screen>&prompt.root; <userinput>sysctl hw.bt848.tuner=6</userinput></screen>

      <para>Consulte en &man.bktr.4; y en
	<filename>/usr/src/sys/conf/NOTES</filename> si necesita
	más detalles sobre las opciones disponibles.</para>
    </sect2>

    <sect2>
      <title>Aplicaciones útiles</title>

      <para>Tendrá que instalar una de estas aplicaciones
        para poder utilizar su tarjeta de TV:</para>

      <itemizedlist>
	<listitem>
	  <para><package>multimedia/fxtv</package>
	    ofrece «TV en una ventana» y captura de
	    imagen/sonido/vídeo.</para>
	</listitem>
	<listitem>
	  <para><package>multimedia/xawtv</package>:
	    otra aplicación de TV; ofrece lo mismo que
	    <application>fxtv</application>.</para>
	</listitem>
	<listitem>
	  <para><package>misc/alevt</package> decodifica
	    y reproduce videotexto y teletexto.</para>
	</listitem>
	<listitem>
	  <para><package>audio/xmradio</package> permite
	    utilizar el sintonizador de radio FM que incorporan algunas
	    tarjetas de TV.</para>
	</listitem>
	<listitem>
	  <para><package>audio/wmtune</package>, una
	    aplicación de escritorio muy útil para
	    el uso de sintonizadores de radio.</para>
	</listitem>
      </itemizedlist>

      <para>Hay más aplicaciones útiles en la Colección de
        de Ports de &os;.</para>
    </sect2>

    <sect2>
      <title>Solución de problemas</title>

      <para>Si tiene algún problema con su tarjeta de TV compruebe
        en primer lugar que el chip de captura de vídeo y el
	sintonizador realmente funcionan con el controlador
	&man.bktr.4; y si ha utilizado las opciones de configuración
	más adecuadas.  Si necesita más ayuda o necesita
	respuestas sobre su tarjeta de TV puede recurrir a la lista
	de correo &a.multimedia.name;.</para>
    </sect2>
  </sect1>


  <sect1 xml:id="scanners">
    <info><title>Escáneres de imágenes</title>
      <authorgroup>
	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Escrito por </contrib></author>
      </authorgroup>
    </info>

    
    <indexterm>
      <primary>image scanners</primary>
    </indexterm>

    <sect2>
      <title>Introducción</title>

      <para>El acceso a escáneres de imágenes en &os;
        funciona gracias a la  <acronym role="Application Programming  Interface">API</acronym>
	<application>SANE</application> (siglas de «Scanner Access Now
	Easy», «el acceso a escáneres ahora es
	fácil»), disponible en la Colección de Ports
	de &os;.  <application>SANE</application> utiliza también
	ciertos controladores de &os; para acceder al hardware del
	escáner.</para>

      <para>&os; puede utilizar tanto escáneres SCSI como USB.
        Asegúrese de que el suyo funciona con
	<application>SANE</application> antes de intentar ningún
	tipo de configuración.  <application>SANE</application>
	tiene una lista de <link xlink:href="http://www.sane-project.org/sane-supported-devices.html">dispositivos
	soportados</link> donde encontrará información
	actualizada sobre hasta dónde funciona el escáner
	y su estatus.  La página de manual de &man.uscanner.4;
	incluye una listas de escáneres USB que funcionan con
	<application>SANE</application>.</para>
    </sect2>

    <sect2>
      <title>Configuración del kernel</title>

      <para>Como ya se ha dicho tanto los interfaces USB como las
         SCSI funcionan.  Según sea el interfaz de su
	 escáner necesitará un tipo diferente de
	 controlador:</para>

      <sect3 xml:id="scanners-kernel-usb">
	<title>Interfaz USB</title>

	<para>El kernel <filename>GENERIC</filename> incluye por
	  omisión los controladores de dispositivo necesarios
	  para poder usar escáneres USB.  Si va a personalizar
	  su kernel asegúrese de que esto está en el
	  fichero de configuración del mismo:</para>

	<programlisting>device usb
device uhci
device ohci
device uscanner</programlisting>

	<para>Según cual sea el chipset de su placa base
	  tendrá que usar <literal>device uhci</literal> o
	  <literal>device ohci</literal>, aunque si tiene ambos
	  no tendrá problemas por eso.</para>

	<para>Si por cualquier motivo no quiere recompilar su
	  kernel y su kernel no es el
	  <filename>GENERIC</filename> puede cargar el módulo
	  controlador de dispositivo &man.uscanner.4; con
	  &man.kldload.8;:</para>

	<screen>&prompt.root; <userinput>kldload uscanner</userinput></screen>

	<para>Si quiere cargar este módulo cada vez que arranque
	  el sistema debe añadir la siguiente
	  línea a
	  <filename>/boot/loader.conf</filename>:</para>

	<programlisting>uscanner_load="YES"</programlisting>

	<para>Tras reiniciar con el kernel correcto (o una vez
	  que el módulo esté cargado) conecte su
	  escáner USB.  Debe aparecer en el «buffer»
	  de mensajes del sistema (&man.dmesg.8;) un mensaje una
	  línea como la siguiente:</para>

	<screen>uscanner0: EPSON EPSON Scanner, rev 1.10/3.02, addr 2</screen>

	<para>La línea del ejemplo muestra que nuestro
	  escáner está utilizando el nodo de
	  dispositivo<filename>/dev/uscanner0</filename>.</para>
      </sect3>

      <sect3>
	<title>Interfaz SCSI</title>

	<para>Si su escáner tiene un interfaz SCSI es importante
	  saber qué controladora SCSI incorpora.
	  El chipset SCSI que tenga influirá en la
	  configuración del kernel que tenga que
	  personalizar.  El kernel <filename>GENERIC</filename>
	  tiene controladores de dispositivo para las controladoras
	  SCSI más comunes.  Consulte el fichero
	  <filename>NOTES</filename> y añada la
	  línea correcta al fichero de configuración
	  de su kernel.  Tendrá que añadir
	  también la siguiente línea:</para>

	<programlisting>device scbus
device pass</programlisting>

	<para>Una vez compilado e instalado el kernel correctamente
	  tiene ya que ver sus nuevos dispositivos en el
	  «buffer» de mensajes del sistema:</para>

	<screen>pass2 at aic0 bus 0 target 2 lun 0
pass2: &lt;AGFA SNAPSCAN 600 1.10&gt; Fixed Scanner SCSI-2 device
pass2: 3.300MB/s transfers</screen>

	<para>Si su escáner estaba apagado durante el arranque
	  puede forzar manualmente la detección si ejecuta una
	  búsqueda de buses SCSI con &man.camcontrol.8;:</para>

	<screen>&prompt.root; <userinput>camcontrol rescan all</userinput>
Re-scan of bus 0 was successful
Re-scan of bus 1 was successful
Re-scan of bus 2 was successful
Re-scan of bus 3 was successful</screen>

	<para>El escáner aparecerá en la lista de
	  dispositivos SCSI:</para>

	<screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 5 lun 0 (pass0,da0)
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 6 lun 0 (pass1,da1)
&lt;AGFA SNAPSCAN 600 1.10&gt;           at scbus1 target 2 lun 0 (pass3)
&lt;PHILIPS CDD3610 CD-R/RW 1.00&gt;     at scbus2 target 0 lun 0 (pass2,cd0)</screen>

	<para>Tiene todos los detalles sobre los dispositivos
	  SCSI en las páginas de manual de
	  &man.scsi.4; y &man.camcontrol.8;.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Configuración de SANE</title>

      <para>El sistema <application>SANE</application> se divide
	en dos partes: los «backends» (<package>graphics/sane-backends</package>) y los
	«frontends» (<package>graphics/sane-frontends</package>).  Los
	 «backends» facilitan el acceso al escáner
	 propiamente dicho.  La
	<link xlink:href="http://www.sane-project.org/sane-supported-devices.html">lista
	de dispositivos que funcionan con </link>
	<application>SANE</application> le dirá qué
	«backend» hará funcionar su escáner
	de imágenes.  No hay más remedio que identificar
	correctamente el «backend» de su escáner
	para poder usarlo.  Los «frontends» ofrecen
	una interfaz gráfica para escanear
	(<application>xscanimage</application>).</para>

      <para>Lo primero que hay que hacer es instalar el port
        o package de <package>graphics/sane-backends</package>.  Después
	ejecute la orden <command>sane-find-scanner</command>
	para comprobar el funcionamiento de la detección
	de escáneres del sistema
	<application>SANE</application>:</para>

      <screen>&prompt.root; <userinput>sane-find-scanner -q</userinput>
found SCSI scanner "AGFA SNAPSCAN 600 1.10" at /dev/pass3</screen>

      <para>En la salida de la orden anterior se le mostrará
        el tipo de interfaz del escáner y el nodo de dispositivo
	a través del cual el sistema accede a él.  Es
	posible que no aparezcan la marca y el modelo, pero eso no
	tiene importancia.</para>

      <note>
	<para>Algunos escáneres USB necesitan que les instale un
	  «firmware»; esto se explica en la página
	  de manual del «backend» correspondiente.  También
	  debe leer las páginas de manual &man.sane-find-scanner.1;
	  y &man.sane.7;.</para>
      </note>

      <para>Ahora hay que comprobar que el «frontend» de
        escaneo puede identificar el escáner.  Por omisión
	los «backends» de
	<application>SANE</application> incorporan una herramienta de
	línea de órdenes llamada &man.scanimage.1;, que
	le mostrará una lista de dispositivos e incluso una
	captura de imagen desde la shell.  La opción
	<option>-L</option> muestra una lista de escáners:</para>

      <screen>&prompt.root; <userinput>scanimage -L</userinput>
device `snapscan:/dev/pass3' is a AGFA SNAPSCAN 600 flatbed scanner</screen>

      <para>Si el software no lanza ningún mensaje, o si
        el mensaje indica que no se han encontrado escáneres
	significa que &man.scanimage.1; no puede identificar su
	escáner.  Si este es el caso tendrá que
	editar el fichero de configuración del
	«backend»y definir en él el
	escáner que quiera utilizar.  Encontrará
	todos los ficheros de configuración de los
	«backends» en el directorio <filename>/usr/local/etc/sane.d/</filename>.  Este
	problema con la identificación del hardware
	es relativamente frecuente con ciertos modelos de
	escáneres USB.</para>

      <para>Por ejemplo, con el escáner que hemos usado en
        la <xref linkend="scanners-kernel-usb"/> la orden
	<command>sane-find-scanner</command> nos da la siguiente
	información:</para>

      <screen>&prompt.root; <userinput>sane-find-scanner -q</userinput>
found USB scanner (UNKNOWN vendor and product) at device /dev/uscanner0</screen>

      <para>El escáner ha sido detectado sin problemas, utiliza el
        interfaz USB y está conectado al nodo de dispositivo
	<filename>/dev/uscanner0</filename> .  Ahora comprobaremos
	que podemos identificar correctamente el escáner:</para>

      <screen>&prompt.root; <userinput>scanimage -L</userinput>

No scanners were identified. If you were expecting something different,
check that the scanner is plugged in, turned on and detected by the
sane-find-scanner tool (if appropriate). Please read the documentation
which came with this software (README, FAQ, manpages).</screen>

      <para>No hemos podido identificar el escáner, así
        que hemos de editar el fichero
	<filename>/usr/local/etc/sane.d/epson.conf</filename>.  Estamos
	usando el modelo de escáner &epson.perfection; 1650,
	así que ya sabemos que el escáner utilizará
	el «backend» <literal>epson</literal>.  Lea
	atentamente los comentarios que hay en los ficheros de
	configuración de los «backends».  Lo que
	hay que hacer es muy sencillo: basta con comentar las
	líneas en las que aparecen interfaces que no sean el
	perfecto para su escáner.  En nuestro caso comentaremos
	todas las líneas que comiencen por
	<literal>scsi</literal> puesto que nuestro escáner
	tiene interfaz USB.  Después de esto hay que
	añadir una lína al final del fichero declarando
	el interfaz y el nodo de dispositivo que se van a usar.  En
	el caso del ejemplo esto es lo que añadimos:</para>

      <programlisting>usb /dev/uscanner0</programlisting>

      <para>Por favor, lea los comentarios que encontrará
        en el fichero de configuración del «backend»
	y la pángina de manual de del «backend»
	si necesita más información sobre la
	sintaxis que debe usar.  Hecho esto podemos verificar si
	ya podemos identificar el escáner:</para>

      <screen>&prompt.root; <userinput>scanimage -L</userinput>
device `epson:/dev/uscanner0' is a Epson GT-8200 flatbed scanner</screen>

      <para>Hemos identificado nuestro escáner USB.  Ni tiene
        importancia si la marca y modelo que hemos visto no coinciden
	con nuestro escáner.  Lo único realmente
	importante es el campo
	<literal>`epson:/dev/uscanner0'</literal>, que nos da
	el nombre correcto del «backend» y el
	nodo de dispositivo correcto.</para>

      <para>Una vez que <command>scanimage -L</command> llega a ver
        al escáner hemos terminado con la configuración.
	El dispositivo está listo para escanear
	imángenes.</para>

      <para>&man.scanimage.1; permite ejecutar una captura de
        imágen desde la línea de órdenes,
	pero siempre es mejor utilizar un interfaz gráfico de
	usuario para estas tareas.
	<application>SANE</application> ofrece un interfaz
	gráfico simple pero eficiente:
	<application>xscanimage</application>
	(<package>graphics/sane-frontends</package>).</para>

      <para>Otro «frontend» gráfico para
        escanear que se ha hecho muy popular es
	<application>Xsane</application> (<package>graphics/xsane</package>).  Este
	«frontend» tiene características muy
	avanzadas como varios modos de escaneo (fotocopia, fax, etc.),
	corrección de color, escaneo de imágenes por
	lotes, etc.  Ambas aplicaciones pueden utilizarse además
	como «plugins» de
	<application>GIMP</application>.</para>
    </sect2>

    <sect2>
      <title>Dar acceso al escáner a otros usuarios</title>

      <para>Todo lo que se ha mostrado en esta sección
        se ha ejecutado con privilegios de
	<systemitem class="username">root</systemitem>.  Lo normal es que haya otros usuarios
	que tengan que tener acceso al escáner.  Un usuario
	que quiera usar el escáner tiene que tener acceso
	de lectura y escritura al nodo de dispositivo que usa
	el escáner.  Por ejemplo, nuestro escáner
	USB utiliza el nodo de dispositivo
	<filename>/dev/uscanner0</filename> propiedad del grupo
	<systemitem class="groupname">operator</systemitem>.  Al añadir al usuario
	<systemitem class="username"><replaceable>joe</replaceable></systemitem> al
	grupo <systemitem class="groupname">operator</systemitem> éste podrá
	acceder al esc&acute;ner:</para>

      <screen>&prompt.root; <userinput>pw groupmod operator -m joe</userinput></screen>

      <para>Para más información sobre el uso de
        &man.pw.8; lea su página de manual.  Tendrá
	también que configurar correctamente los permisos de
	escritura (0660 o 0664) en el nodo de dispositivo
	<filename>/dev/uscanner0</filename>; por omisión los
	miembros del grupo <systemitem class="groupname">operator</systemitem> sólo
	tienen acceso de lectura en este nodo de dispositivo.
	Añada las siguientes líneas al fichero
	lines to the <filename>/etc/devfs.rules</filename>:</para>

      <programlisting>[system=5]
add path uscanner0 mode 660</programlisting>

      <para>Ahora añada lo siguiente a
	<filename>/etc/rc.conf</filename> y reinicie la
	máquina:</para>

      <programlisting>devfs_system_ruleset="system"</programlisting>

      <para>Para más información sobre lo que acaba de
        leer consulte la página de manual de
	&man.devfs.8;.</para>

      <note>
	<para>Por seguridad debería pensarse dos veces
	  el hecho mismo de añadir cualquier usuario
	  a un grupo y muy especialmente al grupo
	  <systemitem class="groupname">operator</systemitem>.</para>
      </note>
    </sect2>
  </sect1>



</chapter>
