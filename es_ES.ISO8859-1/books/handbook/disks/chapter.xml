<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project

     The FreeBSD Spanish Documentation Project

     %SOURCE% en_US.ISO8859-1/books/handbook/disks/chapter.xml
     %SRCID%    0.0

     $FreeBSD$
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="disks">
  <title>Almacenamiento</title>

  <sect1 xml:id="disks-synopsis">
    <title>Sinopsis</title>


    <para>Este capítulo trata sobre el uso de discos en &os;.
      Esto incluye discos basados en memoria, discos conectados
      a través de la red, dispositivos de almacenamiento SCSI/IDE
      estándar y dispositivos que utilizan el interfaz
      USB.</para>

    <para>Tras leer este capítulo:</para>
    <itemizedlist>
      <listitem><para>Conocerá la terminología que se usa en
        &os; para describir la organización de datos en un disco
        físico (particiones y porciones).</para>
      </listitem>
      <listitem><para>Sabrá cómo añadir discos duros
        a su sistema.</para>
      </listitem>
      <listitem>
        <para>Sabrá cómo configurar &os; para utilizar
          dispositivos de almacenamiento USB.</para>
      </listitem>
      <listitem><para>Sabrá cómo configurar sistemas virtuales
        de ficheros, como los discos de memoria.
        </para></listitem>
      <listitem>
        <para>Sabrá cómo usar cuotas para limitar el uso del
          espacio en disco.</para>
      </listitem>
      <listitem>
        <para>Sabrá cómo cifrar discos para hacerlos más
          seguros ante un atacante.</para>
      </listitem>
      <listitem>
        <para>Sabrá cómo se crean y graban los CD y DVD en
          &os;.</para>
      </listitem>
      <listitem>
        <para>Conocerá diversas opciones de almacenamiento de copias
          de seguridad.</para>
      </listitem>
      <listitem>
        <para>Sabrá cómo usar diversos programas de respaldo
          que pueden utilizarse en &os;.</para>
      </listitem>
      <listitem>
        <para>Sabrá cómo hacer copias de seguridad utilizando
          disquetes (floppy).</para>
      </listitem>
      <listitem>
        <para>Sabrá en qué consiste una instantánea
          (<quote>snapshot</quote>) y cómo utilizarla
          de forma eficiente.</para>
      </listitem>
    </itemizedlist>

    <para>Antes de leer este capítulo:</para>

    <itemizedlist>
      <listitem>
        <para>Debe saber cómo configurar e instalar un nuevo kernel
          en &os; (<xref linkend="kernelconfig"/>).</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 xml:id="disks-naming">
    <title>Nombres de dispositivo</title>

    <para>A continuación le mostraremos una lista de dispositivos
      de físicos almacenamiento soportados por &os;
      y los nombres de dispositivo asociados con ellos.</para>

    <table xml:id="disk-naming-physical-table" frame="none">
      <title>Convenciones para nombrar discos físicos</title>

      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Tipo de unidad</entry>
	    <entry>Nombre de dispositivo de la unidad</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>Discos duros IDE</entry>
	    <entry><literal>ad</literal></entry>
	  </row>
	  <row>
	    <entry>Unidades CDROM IDE</entry>
	    <entry><literal>acd</literal></entry>
	  </row>
	  <row>
	    <entry>Discos duros SCSI y dispositivos de almacenamiento masivo
              USB</entry>
	    <entry><literal>da</literal></entry>
	  </row>
	  <row>
	    <entry>Unidades CDROM SCSI</entry>
	    <entry><literal>cd</literal></entry>
	  </row>
	  <row>
	    <entry>Diferentes tipos de unidades CDROM no estándares</entry>
	    <entry><literal>mcd</literal> para CD-ROM Mitsumi,
	      <literal>scd</literal> para CD-ROM Sony,
	      <literal>matcd</literal> para CD-ROM Matsushita/Panasonic
	    </entry>
	  </row>
	  <row>
	    <entry>Unidades de disquete (floppy)</entry>
	    <entry><literal>fd</literal></entry>
	  </row>
	  <row>
	    <entry>Unidades de cinta SCSI</entry>
	    <entry><literal>sa</literal></entry>
            </row>
	  <row>
	    <entry>Unidades de cinta IDE</entry>
	    <entry><literal>ast</literal></entry>
	  </row>
	  <row>
	    <entry>Unidades Flash</entry>
	    <entry><literal>fla</literal> para dispositivos &diskonchip;</entry>
	  </row>
	  <row>
	    <entry>Unidades RAID</entry>
	    <entry><literal>aacd</literal> para &adaptec; AdvancedRAID,
	      <literal>mlxd</literal> y <literal>mlyd</literal>
	      para &mylex;,
	      <literal>amrd</literal> para AMI &megaraid;,
	      <literal>idad</literal> para Compaq Smart RAID,
	      <literal>twed</literal> para &tm.3ware; RAID.</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>
  </sect1>

  <sect1 xml:id="disks-adding">
    <info><title>Añadir discos</title>
      <authorgroup>
	<author><personname><firstname>David</firstname><surname>O'Brien</surname></personname><contrib>Texto original de </contrib></author>
      </authorgroup>
      
    </info>

    

    <indexterm>
      <primary>discos</primary>
      <secondary>añadir</secondary>
    </indexterm>

    <para>Digamos que queremos añadir un nuevo disco SCSI a una
      máquina que solo tiene un disco.  Comience por apagar el
      sistema e instale el disco siguiendo las instrucciones del fabricante
      de la computadora, del disco y de la controladora.  Debido a la gran
      variedad de procedimientos posibles los detalles están más
      allá del alcance de este texto.</para>

    <para>Entre como usuario <systemitem class="username">root</systemitem>.  Una vez instalado el
      disco inspeccione <filename>/var/run/dmesg.boot</filename>
      para asegurarse de que el sistema encontró el nuevo disco.
      Continuando con nuestro ejemplo, el disco recién añadido
      será
      <filename>da1</filename> y queremos montarlo en
      <filename>/1</filename> (si está añadiendo un disco IDE,
      el nombre de dispositivo será
      <filename>wd1</filename> en sistemas anteriores a 4.0, y
      <filename>ad1</filename> en sistemas 4.X y 5.X).</para>

    <indexterm><primary>particiones</primary></indexterm>
    <indexterm><primary>slices</primary></indexterm>
    <indexterm>
      <primary><command>fdisk</command></primary>
    </indexterm>

    <para>&os; funciona en computadoras IBM-PC y compatibles, por lo tanto
      tendrá en cuenta las particiones de la BIOS del PC, que son
      diferentes del tipo de partición que se ha venido usando en
      BSD.  Un disco para PC puede contener hasta cuatro entradas de
      particiones BIOS.  Si el disco va a utilizarse íntegramente
      con &os; puede usar el modo
      <emphasis>dedicado</emphasis>.  Si no, &os; tendrá que
      instalarse dentro de una las particiones BIOS.  En &os; se llama
      slices (<quote>porciones</quote> o <quote>rebanadas</quote>) a las
      particiones de PC BIOS para no confundirlas con las particiones BSD.
      También puede utilizar slices en un disco dedicado a
      &os; pero que se está usando en un sistema que también
      tiene otro sistema operativo instalado.
      Esta es una buena manera de evitar confundir la versión de
      <command>fdisk</command> de otros sistemas operativos.</para>

    <para>Desde el punto de vista de las slices el disco se
      añadirá como <filename>/dev/da1s1e</filename>.
      Se interpreta del siguiente modo: disco SCSI, unidad
      número 1 (segundo disco SCSI), slice 1 (partición 1
      de PC BIOS), y partición BSD <filename>e</filename>.
      Si es un disco dedicado, el disco se añadirá como
      <filename>/dev/da1e</filename>.</para>


    <para>Debido al uso de enteros de 32-bits para almacenar el número
      de sectores, &man.bsdlabel.8; (llamado &man.disklabel.8; en
      &os;&nbsp;4.X) está limitado a 2^32-1 sectores por disco
      ó 2TB (en la mayoría de los casos).  El formato de
      &man.fdisk.8; permite un sector de arranque de un máximo de
      más de 2^32-1 y no más de 2^32-1 de longitud, limitando
      las particiones a 2TB y los discos a 4TB (también en
      la mayoría de los casos).  El formato &man.sunlabel.8; tiene
      una limitación de 2^32-1 sectores por partición y 8
      particiones en un espacio máximo de 16TB.  Si va a usar discos
      mayores puede usar particiones &man.gpt.8;.</para>

    <sect2>
      <title>Uso de &man.sysinstall.8;</title>
      <indexterm>
        <primary><application>sysinstall</application></primary>
        <secondary>añadir discos</secondary>
      </indexterm>
      <indexterm>
	<primary>su</primary>
      </indexterm>
      <procedure>
	<step>
	  <title>Navegar en <application>Sysinstall</application></title>


          <para>Puede utilizar <command>sysinstall</command>
            (<command>/stand/sysinstall</command> en versiones de &os;
            anteriores a 5.2) para particionar y etiquetar un
            disco nuevo usando sus intuitivos menús.
            Entre como el usuario <systemitem class="username">root</systemitem> o utilice
            <command>su</command>.  Ejecute
            <command>sysinstall</command> y entre al menú
            <literal>Configure</literal>.  Dentro de
            <literal>FreeBSD Configuration Menu</literal>, descienda
            y seleccione la opción <literal>Fdisk</literal>.</para>
	</step>

	<step>
	  <title>Editor de particiones <application>fdisk</application></title>

          <para>Una vez dentro de <application>fdisk</application>,
            teclée <userinput>A</userinput> si quiere usar el
            disco entero con &os;  Cuando se le pregunte
            <quote>remain cooperative with any future
            possible operating systems</quote>
            <footnote><para>
            Mantener el disco accesible a sistemas operativos que pudieran
            necesitar acceder al mismo en algún momento.
            </para></footnote>, responda <literal>YES</literal>.
            Escriba los cambios al disco pulsando <userinput>W</userinput>.
            Salga del editor FDISK pulsando <userinput>q</userinput>.
            A continuación se le preguntará sobre el
            <quote>Master Boot Record</quote>.  Debido a que está
            añadiendo un nuevo disco a un sistema que ya está
            instalado, tendrá que seleccionar
            <literal>None</literal>.</para>
	</step>

	<step>
	  <title>Editor de etiquetas de disco</title>

	  <indexterm><primary>particiones BSD</primary></indexterm>

          <para>A continuación, debe salir de
            <application>sysinstall</application> e iniciarlo de nuevo.
            Siga las instrucciones arriba expuestas, pero esta vez elija la
            opción <literal>Label</literal>.  De este modo
            accederá al
            <literal>editor de etiquetas de disco</literal>.
            En él  creará las particiones BSD
            tradicionales.  Un disco puede tener hasta ocho particiones,
            etiquetadas desde la <literal>a</literal> a la
            <literal>h</literal>.
            Algunas de las etiquetas de las particiones tienen
            usos especiales.  La partición <literal>a</literal>
            se utiliza para la partición raíz
            (<filename>/</filename>), por lo tanto sólo su disco
            de sistema (esto es, el disco desde el cual arranca)
            tendrá una partición <literal>a</literal>.
            La partición <literal>b</literal> se usa como
            partición swap; puede tener más de una
            partición swap y puede alojarlas en más de un
            disco.  La partición <literal>c</literal>
            hace referencia al disco entero en modo dedicado, o a
            la slice de &os; completa en modo slice.  Las demás
            particiones son para el resto de los usos típicos.</para>

          <para>El editor de etiquetas de
            <application>sysinstall</application>
            creará la partición <literal>e</literal> como
            partición <quote>ni raíz, ni swap</quote>.
            En el editor de etiquetas crée un solo sistema de
            ficheros tecleando <userinput>C</userinput>.  Cuando se
            le pregunte si debe etiquetarse como FS (sistema de ficheros) o
            swap, elija <literal>FS</literal> y teclée un punto de
            montaje (por ejemplo <filename>/mnt</filename>).  Al
            añadir un disco en modo
            <quote>post-instalación</quote>
            <application>sysinstall</application> no creará
            automáticamente las entradas correspondientes en
            <filename>/etc/fstab</filename>, por lo que el punto de
            montaje que usted especifique no tiene importancia.</para>

          <para>Ahora puede escribir la nueva etiqueta al disco y
            crear un sistema de ficheros en él tecleando
            <userinput>W</userinput>.  Ignore cualquier error que
            pudiera generar <application>sysinstall</application> acerca
            de dificultades para montar la nueva partición.  Salga del
            editor de etiquetas y de <application>sysinstall</application>.
            </para>
	</step>

	<step>
	  <title>Terminar</title>

          <para>El último paso es editar
            <filename>/etc/fstab</filename>
            y añadir una entrada para su nuevo disco.</para>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title>Uso de utilidades de línea de comandos</title>

      <sect3>
	<title>Uso de slices</title>

        <para>Esta configuración le permitirá a su
          disco convivir sin sobresaltos con otro sistema operativo
          que pueda estar instalado en su sistema y no
          confundirá a las utilidades <command>fdisk</command> de
          esos otros sistemas operativos.  Se recomienda utilizar este
          método para instalar discos nuevos.
          <emphasis>Utilice el modo dedicado sólamente si tiene
          un buen motivo para hacerlo</emphasis>.</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 bs=1k count=1</userinput>
&prompt.root; <userinput>fdisk -BI da1</userinput> #Initialice el nuevo disco.
&prompt.root; <userinput>disklabel -B -w -r da1s1 auto</userinput> #Etiquételo.
&prompt.root; <userinput>disklabel -e da1s1</userinput> # Edite la etiqueta de disco que acaba de crear y añada particiones.
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>newfs /dev/da1s1e</userinput> # Repita este paso por cada partición que crée.
&prompt.root; <userinput>mount /dev/da1s1e /1</userinput> # Monte la partición o particiones.
&prompt.root; <userinput>vi /etc/fstab</userinput> # Añada la/s entrada/s apropiadas en <filename>/etc/fstab</filename>.</screen>

        <para>Si tiene un disco IDE, sustituya <filename>ad</filename>
          por <filename>da</filename>.  En sistemas anteriores a 4.X
          utilice <filename>wd</filename>.</para>
      </sect3>

      <sect3>
	<title>Dedicado</title>
	<indexterm><primary>OS/2</primary></indexterm>

        <para>Si no va a compartir el nuevo disco con otro sistema
          operativo puede utilizar el modo <literal>dedicado</literal>.
          Recuerde que este modo puede confundir a los sistemas operativos
          de Microsoft, aunque no podrán dañar por ello el
          disco o su contenido.  Tenga en cuenta que &os; (de IBM)
          se <quote>apropiará</quote> de cualquier partición
          que encuentre y no entienda.</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 bs=1k count=1</userinput>
&prompt.root; <userinput>disklabel -Brw da1 auto</userinput>
&prompt.root; <userinput>disklabel -e da1</userinput>				# crear partición `e'
&prompt.root; <userinput>newfs -d0 /dev/da1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput>				# agregar una entrada para /dev/da1e
&prompt.root; <userinput>mount /1</userinput></screen>

        <para>Una forma alternativa de hacerlo sería:</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 count=2</userinput>
&prompt.root; <userinput>disklabel /dev/da1 | disklabel -BrR da1 /dev/stdin</userinput>
&prompt.root; <userinput>newfs /dev/da1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput>					# añadir una entrada para /dev/da1e
&prompt.root; <userinput>mount /1</userinput></screen>

        <note><para>A partir de &os;&nbsp;5.1-RELEASE, la utilidad
          &man.bsdlabel.8; reemplazó al antiguo programa
          &man.disklabel.8;.  En &man.bsdlabel.8; se han eliminado muchos
          parámetros y opciones obsoletas;
          en los ejemplos de arriba la opción <option>-r</option>
          debe eliminarse si se usa &man.bsdlabel.8;.  Para más
          información diríjase al manual
          de &man.bsdlabel.8;.</para></note>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="raid">
    <title>RAID</title>

    <sect2 xml:id="raid-soft">
      <title>Software RAID</title>

      <sect3 xml:id="ccd">
	<info><title>Configuración de controlador de disco
	  concatenado (CCD)</title>
	  <authorgroup>
	    <author><personname><firstname>Christopher</firstname><surname>Shumway</surname></personname><contrib>Texto original de </contrib></author>
	  </authorgroup>
	  <authorgroup>
	    <author><personname><firstname>Jim</firstname><surname>Brown</surname></personname><contrib>Revisado por </contrib></author>
	  </authorgroup>
	</info>

	

<indexterm><primary>RAID</primary><secondary>software</secondary></indexterm>
<indexterm>
  <primary>RAID</primary><secondary>CCD</secondary>
</indexterm>

        <para>Al escoger una solución de almacenamiento masivo
          los factores más importantes a considerar son velocidad,
          fiabilidad y coste.  Es raro tener los tres por igual;
          normalmente un dispositivo de almacenamiento masivo veloz y
          fiable es caro, y para recortar los costes suele sacrificarse
          la velocidad o la fiabilidad.</para>

        <para>Al diseñar el sistema descrito más adelante se
          eligió el coste como el factor más importante,
          seguido de la velocidad, y luego la fiabilidad.
          La velocidad de transferencia de datos para este sistema está,
          en última instancia, limitada por la red.  Y mientras que la
          confiabilidad es muy importante, el controlador CCD descrito
          más adelante sirve datos que están respaldados
          en CD-R y pueden ser reemplazados sin dificultad.</para>

        <para>Al escoger una solución de almacenamiento masivo el
          primer paso es definir sus necesidades.  Si prefiere velocidad o
          fiabilidad por encima del coste, el resultado será
          distinto del que vamos a describir en esta sección.
          </para>


	<sect4 xml:id="ccd-installhw">
	  <title>Instalación del hardware</title>

          <para>Además del disco IDE, el núcleo del
            disco CCD está compuesto por tres discos IDE
            discos IDE Western Digital de 30GB y 5400 RPM, que
            ofrecen aproximadamente 90GB de almacenamiento.
            Lo ideal sería que cada disco IDE tuviera
            su propio cable y controlador, pero para minimizar
            costes no se utilizaron controladores IDE adicionales.
            En lugar de eso se configuraron los discos
            con <quote>jumpers</quote> para que cada controlador IDE
            tuviera un maestro y un esclavo.</para>

          <para>Despues de reiniciar la BIOS se configuró
            para que detectara automáticamente los discos
            conectados.
            &os; los detectó al reiniciar:</para>

	  <programlisting>ad0: 19574MB &lt;WDC WD205BA&gt; [39770/16/63] at ata0-master UDMA33
ad1: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata0-slave UDMA33
ad2: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata1-master UDMA33
ad3: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata1-slave UDMA33</programlisting>

          <note><para>Si &os; no detecta todos los discos
            asegúrese de que ha colocado correctamente los
            <quote>jumpers</quote>.  La mayoría de los discos IDE
            tienen  un <quote>jumper</quote> <quote>Cable Select</quote>.
            Este <emphasis>no</emphasis> es el
            <quote>jumper</quote> que define la relación
            maestro/esclavo.  Consulte la documentación
            del disco para identificar el <quote>jumper</quote>
            correcto.</para></note>

          <para>El siguiente paso es estudiar cómo conectarlos
            para que formen parte del sistema de ficheros.  Investigue
            Debe investigar &man.vinum.8;
            (<xref linkend="vinum-vinum"/>) y &man.ccd.4;. Nosotros
            elegimos &man.ccd.4; para nuestra
            configuración.</para>
	</sect4>

	<sect4 xml:id="ccd-setup">
	  <title>Configuración de CCD</title>

          <para>El controlador &man.ccd.4; le permite tomar
            varios discos idénticos y concatenarlos
            en un solo sistema lógico de ficheros.
            Para poder usar &man.ccd.4; necesita un
            kernel compilado con soporte de &man.ccd.4;.
            Añada esta línea al fichero de
            configuración de su kernel, recompile y
            reinstale su kernel:</para>

	  <programlisting>pseudo-device   ccd     4</programlisting>

          <para>En sistemas 5.X, use la siguiente línea:</para>

	  <programlisting>device   ccd</programlisting>

          <note><para>En FreeBSD&nbsp;5.X no es necesario especificar
            un número de dispositivos &man.ccd.4;, ya que el controlador
            de dispositivo &man.ccd.4; es capaz de clonarse a sí
            mismo (se crearán nuevas instancias de dispositivo
            automáticamente según vayan haciendo falta).
            </para></note>

          <para>El soporte de &man.ccd.4; también puede
            cargarse como módulo en &os; 3.0 y
            posteriores.</para>

          <para>Para configurar &man.ccd.4; tendrá que
            usar &man.disklabel.8; para etiquetar los
            discos:</para>

	  <programlisting>disklabel -r -w ad1 auto
disklabel -r -w ad2 auto
disklabel -r -w ad3 auto</programlisting>

          <para>Esto crea una etiqueta de disco para
            <filename>ad1c</filename>,
            <filename>ad2c</filename> y
            <filename>ad3c</filename> que abarcan
            el disco completo.</para>

        <note><para>A partir de &os;&nbsp;5.1-RELEASE
          &man.bsdlabel.8; reemplazó al antiguo programa
          &man.disklabel.8;.  En &man.bsdlabel.8; se eliminaron muchas
          opciones y parámetros obsoletos;
          en los ejemplos de arriba la opción <option>-r</option>
          deben obviarse.  Para más información consulte
          &man.bsdlabel.8;.</para></note>

          <para>El siguiente paso es cambiar el tipo de etiqueta
            de disco.  Edite los discos con &man.disklabel.8;:
            </para>

	  <programlisting>disklabel -e ad1
disklabel -e ad2
disklabel -e ad3</programlisting>

          <para>Esto abre la etiqueta de disco de cada disco
            con el editor declarado en la variable de
            entorno <envar>EDITOR</envar>, por defecto &man.vi.1;.</para>

          <para>Esta es una etiqueta de disco sin modificar:</para>

	  <programlisting>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)</programlisting>

          <para>&man.ccd.4; necesita que añada una nueva
            partición <literal>e</literal>.  Puede copiarla desde la
            partición <literal>c</literal>, pero el tipo de sistema de
            ficheros (la opción <option>fstype</option>) debe ser
            <userinput>4.2BSD</userinput>.  La etiqueta del disco
            debería tener este aspecto:</para>

	  <programlisting>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)
  e: 60074784        0    4.2BSD        0     0     0   # (Cyl.    0 - 59597)</programlisting>

	</sect4>

	<sect4 xml:id="ccd-buildingfs">
	  <title>Contrucción del sistema de ficheros</title>

            <para>Puede que todavía no exista el
              nodo de dispositivo para <filename>ccd0c</filename>.
              Si es así, ejecute lo siguiente:
              </para>

	  <programlisting>cd /dev
sh MAKEDEV ccd0</programlisting>

          <note><para>En FreeBSD 5.0 &man.devfs.5; administrará
            automáticamente los nodos de dispositivos en
            <filename>/dev</filename>, así que no tendrá que
            usar <command>MAKEDEV</command>.</para></note>

          <para>Una vez etiquetados todos los discos construya
            el &man.ccd.4;. Utilice
            &man.ccdconfig.8; con opciones similares a las siguientes:</para>

	    <programlisting>ccdconfig ccd0<co xml:id="co-ccd-dev"/> 32<co xml:id="co-ccd-interleave"/> 0<co xml:id="co-ccd-flags"/> /dev/ad1e<co xml:id="co-ccd-devs"/> /dev/ad2e /dev/ad3e</programlisting>

          <para>El uso y el significado de cada una de las opciones se
            muestra más abajo:</para>

          <calloutlist>
            <callout arearefs="co-ccd-dev">
            <para>El primer argumento es el dispositivo a configurar, en este
              caso <filename>/dev/ccd0c</filename>.  La parte
              <filename>/dev/</filename> es opcional.</para>
            </callout>

            <callout arearefs="co-ccd-interleave">

            <para>El intervalo para el sistema de ficheros.  El intervalo
              define el tamaño de una banda en bloques de disco,
              normalmente 512 bytes.  Por lo tanto, un intervalo
              de 32 equivaldría 16.384 bytes.</para>
            </callout>

            <callout arearefs="co-ccd-flags">
            <para>Banderas para &man.ccdconfig.8;. Si desea disponer
              sus discos en espejo use aquí una bandera.
              Esta configuración no necesita discos en espejo,
              por lo que está dispuesta a 0 (cero).</para>
            </callout>

            <callout arearefs="co-ccd-devs">
            <para>Los últimos argumentos de &man.ccdconfig.8;
              son los dispositivos a colocar en el array.  Utilice
              la ruta completa para cada dispositivo.</para>
            </callout>
          </calloutlist>


          <para>Despues de ejecutar &man.ccdconfig.8; el &man.ccd.4;
            estará configurado y podrá instalar un sistema
            de ficheros.  Consulte las opciones de &man.newfs.8; y
            ejecute:</para>

	  <programlisting>newfs /dev/ccd0c</programlisting>


	</sect4>

	<sect4 xml:id="ccd-auto">
	  <title>Automatización</title>

          <para>Seguramente querrá que
            &man.ccd.4; esté dispuesto tras cada reinicio.  Para
            ello, debe configurarlo.  Guarde su configuración
            en <filename>/etc/ccd.conf</filename> mediante lo
            siguiente:</para>

	  <programlisting>ccdconfig -g &gt; /etc/ccd.conf</programlisting>

          <para>Durante el reinicio, el <quote>script</quote>
            <command>/etc/rc</command>
            ejecuta <command>ccdconfig -C</command> si encuentra
            el fichero <filename>/etc/ccd.conf</filename>.  De este modo
            &man.ccd.4; queda configurado automáticamente para que
            pueda montarse.</para>

          <note><para>Si ha arrancando en modo mono usuario necesita
            ejecutar el siguiente comando antes de que pueda montar
            el &man.ccd.4; para configurar el array:</para>

	  <programlisting>ccdconfig -C</programlisting>
          </note>

          <para>Para montar automaticamente el &man.ccd.4;
            coloque una entrada para &man.ccd.4; en
            <filename>/etc/fstab</filename> para que se monte
            durante el arranque:</para>

	  <programlisting>/dev/ccd0c              /media       ufs     rw      2       2</programlisting>
	</sect4>
      </sect3>

      <sect3 xml:id="vinum">
	<title>El administrador de volúmenes Vinum</title>

<indexterm><primary>RAID</primary><secondary>software</secondary></indexterm>
<indexterm>
  <primary>RAID</primary>
  <secondary>Vinum</secondary>
</indexterm>

        <para>El administrador de volúmenes Vinum es un
          controlador de dispositivos de bloque que implementa
          unidades de disco virtuales.  Aísla los discos hardware de
          la interfaz de dispositivos de bloque y mapea datos de
          modo que revierta en un incremento de flexibilidad,
          rendimiento y fiabilidad comparados con el sistema de slices
          de almacenamiento de disco tradicional.
          &man.vinum.8; implementa los modelos RAID-0, RAID-1 y
          RAID-5, individualmente o combinados.</para>

	<para>Consulte el <xref linkend="vinum-vinum"/> para mayor
          información sobre &man.vinum.8;.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="raid-hard">
      <title>RAID por Hardware</title>

      <indexterm>
	<primary>RAID</primary>
	<secondary>hardware</secondary>
      </indexterm>

      <para>FreeBSD admite una gran variedad de controladores
        <acronym>RAID</acronym> por hardware.  Estos dispositivos
        controlan un subsistema <acronym>RAID</acronym> sin necesidad
        de software específico para &os; que administre el
        array.</para>

      <para>Puede controlar la mayoría de las operaciones de disco con
        una tarjeta que incorpore <acronym>BIOS</acronym>.
        El siguiente texto es una breve
        descripción de configuración utilizando una
        controladora Promise <acronym>RAID</acronym> <acronym>IDE</acronym>.
        Cuando se instala esta tarjeta e inicia el sistema despliega
        un <quote>prompt</quote> pidiendo información.  Siga las
        instrucciones para entrar a la pantalla de configuración de la
        tarjeta.  Ahí tendrá posibilidad de combinar todos los
        discos que haya conectado.  Hecho esto el disco (o discos)
        aparecerán como una sola unidad en &os;.  Pueden configurarse
        otros niveles de
        <acronym>RAID</acronym>.</para>
    </sect2>

    <sect2>
      <title>Reconstrucción de arrays ATA RAID1</title>

      <para>&os; le permite reemplazar en caliente un disco dañado.
        Esto requiere que lo intercepte antes de reiniciar.</para>

      <para>Probablemente vea algo como lo siguiente en
        <filename>/var/log/messages</filename> o en la salida de
        &man.dmesg.8;:</para>

      <programlisting>ad6 on monster1 suffered a hard error.
ad6: READ command timeout tag=0 serv=0 - resetting
ad6: trying fallback to PIO mode
ata3: resetting devices .. done
ad6: hard error reading fsbn 1116119 of 0-7 (ad6 bn 1116119; cn 1107 tn 4 sn 11)\\
status=59 error=40
ar0: WARNING - mirror lost</programlisting>

      <para>Consulte &man.atacontrol.8; para más
        información:</para>

      <screen>&prompt.root; <userinput>atacontrol list</userinput>
ATA channel 0:
	Master:      no device present
	Slave:   acd0 &lt;HL-DT-ST CD-ROM GCR-8520B/1.00&gt; ATA/ATAPI rev 0

ATA channel 1:
	Master:      no device present
	Slave:       no device present

ATA channel 2:
	Master:  ad4 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

ATA channel 3:
	Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

&prompt.root; <userinput>atacontrol status ar0</userinput>
ar0: ATA RAID1 subdisks: ad4 ad6 status: DEGRADED</screen>

      <procedure>
	<step>
          <para>Primero debe desconectar el disco del array para
            que pueda retirarlo con seguridad:</para>

	  <screen>&prompt.root; <userinput>atacontrol detach 3</userinput></screen>
	</step>

	<step>
	  <para>Reemplace el disco.</para>
	</step>

	<step>
	  <para>Conecte el disco de repuesto:</para>

	  <screen>&prompt.root; <userinput>atacontrol attach 3</userinput>
Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
Slave:   no device present</screen>
	</step>

	<step>
	  <para>Reconstruya el array:</para>

	  <screen>&prompt.root; <userinput>atacontrol rebuild ar0</userinput></screen>
	</step>

	<step>

          <para>El comando de reconstrucción no responderá hasta
            que termine la tarea.  Puede abrir otra terminal (mediante
            <keycombo action="simul"><keycap>Alt</keycap> <keycap>F<replaceable>n</replaceable></keycap></keycombo>)
            y revisar el progreso ejecutando lo siguiente:</para>

	  <screen>&prompt.root; <userinput>dmesg | tail -10</userinput>
[texto eliminado]
ad6: removed from configuration
ad6: deleted from ar0 disk1
ad6: inserted into ar0 disk1 as spare

&prompt.root; <userinput>atacontrol status ar0</userinput>
ar0: ATA RAID1 subdisks: ad4 ad6 status: REBUILDING 0% completed</screen>
	</step>

	<step>
          <para>Espere hasta que termine la operación.</para>
	</step>
      </procedure>
    </sect2>
  </sect1>

  <sect1 xml:id="usb-disks">
    <info><title>Dispositivos de almacenamiento USB</title>
      <authorgroup>
	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Texto de </contrib></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>USB</primary>
      <secondary>discos</secondary>
    </indexterm>

    <para>Hoy día hay una enorme cantidad de soluciones de
      almacenamiento externoque usan el bus serie universal (USB):
      discos duros, <quote>mecheros</quote> (o
      <quote>lápices</quote>) USB, grabadoras de
      CD-R, etc. &os; puede usar estos dispositivos.</para>

    <sect2>
      <title>Configuración</title>

      <para>El controlador de dispositivos de almacenamiento masivo
        USB, &man.umass.4;, ofrece soporte para dispositivos de
        almacenamiento USB.  Si usa el kernel <filename>GENERIC</filename>
        no necesita cambiar nada en su configuración.  Si
        utiliza un kernel personalizado asegúrese de que su
        fichero de configuración del kernel contiene las
        siguientes líneas:</para>

      <programlisting>device scbus
device da
device pass
device uhci
device ohci
device usb
device umass</programlisting>

      <para>El controlador &man.umass.4; usa el subsistema SCSI para
        acceder a los dispositivos de almacenamiento USB y su
        dispositivo USB aparecerá en el sistema como
        dispositivo SCSI.  Dependiendo del chipset USB de su
        placa base sólamente necesitará
        <literal>device uhci</literal> o
        <literal>device ohci</literal>;  en cualquier caso tener
        los dos en el fichero de configuración del kernel
        no provocará ningún daño.  No olvide
        compilar e instalar el nuevo kernel si hizo alguna
        modificación.</para>

      <note>
        <para>Si su dispositivo USB es una grabadora CD-R o DVD el
          controlador SCSI CD-ROM, &man.cd.4;, debe ser añadirse al
          kernel mediante la siguiente línea:</para>

	<programlisting>device cd</programlisting>

        <para>Dado que la grabadora aparece como una unidad
          SCSI no tiene que usar el controlador &man.atapicam.4;
          en la configuración del kernel.</para>
      </note>

      <para>En &os;&nbsp;5.X y en la rama 4.X desde &os;&nbsp;4.10-RELEASE
        el soporte para controladores USB 2.0 se incorpora al sistema del
        siguiente modo:</para>

      <programlisting>device ehci</programlisting>

      <para>Tenga en cuenta que &man.uhci.4; y
        &man.ohci.4; siguen siendo necesarios si quiere disponer de
        soporte para USB 1.X.</para>

      <note>
        <para>En &os;&nbsp;4.X, El d&aelig;mon USB (&man.usbd.8;) debe
          ejecutarse para poder ver ciertos tipos de dispositivo USB.
          Para habilitarlo, añada
          <literal>usbd_enable="YES"</literal> en
          <filename>/etc/rc.conf</filename> y reinicie la
          máquina.</para>
      </note>
    </sect2>

    <sect2>
      <title>Prueba de la configuración</title>

      <para>La configuración está lista para probarse:
        conecte su dispositivo USB; en el búfer de mensajes del
        sistema (&man.dmesg.8;), la unidad debe aparecer como algo
        similar a esto:</para>

      <screen>umass0: USB Solid state disk, rev 1.10/1.00, addr 2
GEOM: create disk da0 dp=0xc2d74850
da0 at umass-sim0 bus 0 target 0 lun 0
da0: &lt;Generic Traveling Disk 1.11&gt; Removable Direct Access SCSI-2 device
da0: 1.000MB/s transfers
da0: 126MB (258048 512 byte sectors: 64H 32S/T 126C)</screen>

      <para>Obviamente la marca, el nodo de dispositivo
        (<filename>da0</filename>) y otros detalles
        pueden diferir dependiendo de su hardware.</para>

      <para>Ya que el dispositivo USB aparece como uno SCSI,
        puede usar <command>camcontrol</command> para ver una lista
        de dispositivos USB conectados al
        sistema:</para>

      <screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;Generic Traveling Disk 1.11&gt;      at scbus0 target 0 lun 0 (da0,pass0)</screen>

      <para>Si la unidad tiene un sistema de ficheros puede montarla.
        La <xref linkend="disks-adding"/> contiene información que
        le resultará muy útil para formatear y crear
        particiones en el disco USB en caso de necesitarlo.</para>

      <para>Si desconecta el dispositivo (el disco debe desmontarse
        previamente), debería ver en el búfer de mensajes
        del sistema algo parecido a esto:</para>

      <screen>umass0: at uhub0 port 1 (addr 2) disconnected
(da0:umass-sim0:0:0:0): lost device
(da0:umass-sim0:0:0:0): removing device entry
GEOM: destroy disk da0 dp=0xc2d74850
umass0: detached</screen>
    </sect2>

    <sect2>
      <title>Lecturas recomendadas</title>

      <para>Ademas de las secciones
        <link linkend="disks-adding">Cómo añadir discos</link>
        y <link linkend="mount-unmount">Montado y desmontado de sistemas
        ficheros</link>, consulte las siguientes páginas man:
        &man.umass.4;, &man.camcontrol.8; y
        &man.usbdevs.8;.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="creating-cds">
    <info><title>Creación y uso de medios ópticos (CD)</title>
      <authorgroup>
	<author><personname><firstname>Mike</firstname><surname>Meyer</surname></personname><contrib>Texto de </contrib></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>CDROM</primary>
      <secondary>creación</secondary>
    </indexterm>

    <sect2>
      <title>Introducción</title>

      <para>Los CD tienen muchas opciones que los hacen distintos de
        los discos convencionales.  Al principio los usuarios no
        podían escribirlos.  Su diseño permite que leamos
        en ellos sin el retardo del movimiento de una cabeza lectora
        de una pista a otra.
        También son mucho más fáciles de transportar
        de un sistema a otro que muchos otros soportes de
        información.</para>

      <para>Los CD tienen pistas, pero son una sección de los
        que permiten lectura contínua, no una propiedad
        física del disco.  Para crear un CD en &os; debe
        preparar los ficheros de datos que van a constituir las pistas
        del CD y luego escribir las pistas al CD.</para>

      <indexterm><primary>ISO 9660</primary></indexterm>
      <indexterm>
        <primary>sistema de ficheros</primary>
        <secondary>ISO 9660</secondary>
      </indexterm>
      <para>El sistema de ficheros ISO 9660 se diseñó
        para gestionar estas diferencias.  Por desgracia implementa
        límites de sistema de ficheros que eran comunes en la
        época en que se diseñó.
        Por suerte también proporciona un mecanismo de extensiones
        que permite que CD escritos excediendo dichos límites
        funcionen en sistemas que no soportan esas extensiones.</para>

      <indexterm>
        <primary><package>sysutils/cdrtools</package></primary>
      </indexterm>
      <para>El port <package>sysutils/cdrtools</package>
        incluye &man.mkisofs.8;, un programa que le permitirá
        crear un fichero de datos que contenga un sistema de
        ficheros ISO 9660.  Incorpora opciones que soportan varias
        extensiones.  Se describe más adelante.</para>

      <indexterm>
        <primary>grabadora de CD</primary>
        <secondary>ATAPI</secondary>
      </indexterm>
      <para>Qué herramienta usar para grabar el CD depende de si
        su grabadora es ATAPI o no.  Las grabadoras de CD ATAPI usan el
        programa <command>burncd</command>,
        que forma parte del sistema base.  Las grabadoras SCSI y USB usan
        <command>cdrecord</command>, del
        port <package>sysutils/cdrtools</package>.</para>

      <para><command>burncd</command> no soporta cualquier unidad de
        grabación.  Para saber si una unidad está
        soportada consulte la siguiente lista de
        <link xlink:href="http://www.freebsd.dk/ata/">unidades CD-R/RW soportadas</link>.</para>

      <note>
      <indexterm>
	<primary>grabadora de CD</primary>
	<secondary>controlador ATAPI/CAM</secondary>
      </indexterm>
        <para>Si utiliza &os;&nbsp;5.X, &os;&nbsp;4.8-RELEASE
          o posteriores, puede utilizar
          <command>cdrecord</command> y
          otras herramientas para unidades SCSI en hardware ATAPI con
          el <link linkend="atapicam">módulo ATAPI/CAM</link>.</para>
      </note>

      <para>Si quiere usar un interfaz gráfico con su software
        de grabación de CD quizás le guste
        <application>X-CD-Roast</application> o
        <application>K3b</application>.  Puede instalar estas herramientas
        como paquetes o desde los ports
        <package>sysutils/xcdroast</package> y
        <package>sysutils/k3b</package>, respectivamente.
        <application>X-CD-Roast</application> y
        <application>K3b</application> requieren el
        <link linkend="atapicam">módulo ATAPI/CAM</link>
        si usa hardware ATAPI.</para>
    </sect2>

    <sect2 xml:id="mkisofs">
      <title>mkisofs</title>

      <para>El programa &man.mkisofs.8; (que forma parte del
        port <package>sysutils/cdrtools</package>)
        genera un sistema de ficheros ISO 9660 que es una imagen
        de un árbol de directorios en el espacio de nombres
        del sistema de ficheros &unix;.  Esta es la forma más simple
        de usarlo:</para>

      <screen>&prompt.root; <userinput>mkisofs -o ficherodeimagen.iso /ruta/del/árbol</userinput></screen>

      <indexterm>
        <primary>sistemas de ficheros</primary>
        <secondary>ISO 9660</secondary>
      </indexterm>
      <para>Este comando creará un
        <replaceable>ficherodeimagen.iso</replaceable>
        que contenga un sistema de ficheros ISO 9660 que es una copia del
        árbol ubicado en
        <replaceable>/ruta/al/árbol</replaceable>. En el
        proceso, mapeará los nombres de fichero a nombres que
        se ajusten a las limitaciones del estándar del sistema
        de ficheros ISO 9660, y excluirá ficheros que posean
        nombres no característicos de sistemas de ficheros
        ISO.</para>

      <indexterm>
        <primary>sistemas de ficheros</primary>
        <secondary>HFS</secondary>
      </indexterm>
      <indexterm>
        <primary>sistemas de ficheros</primary>
        <secondary>Joliet</secondary>
      </indexterm>

      <para>Existe gran cantidad de opciones que permiten superar
        esas restricciones.  En particular, <option>-R</option>
        habilita las extensiones Rock Ridge comunes para sistemas
        &unix;, <option>-J</option> habilita las extensiones Joliet
        usadas por sistemas Microsoft y <option>-hfs</option> puede
        usarse para crear sistemas de ficheros utilizados por
        &macos;.</para>

      <para>Puede utilizar <option>-U</option> para deshabilitar
        todas las restricciones de nombres de fichero si quiere crear un
        CD que se vaya a usar exclusivamente en sistemas &os;.  Cuando se
        usa con <option>-R</option> produce una imagen de sistema
        de ficheros que es idéntica al árbol &os;
        origen, aunque puede violar el estándar ISO 9660
        de múltiples formas.</para>

      <indexterm>
        <primary>CDROMs</primary>
        <secondary>creación cd CD arrancables</secondary>
      </indexterm>
      <para>La última opción de uso general es
        <option>-b</option>.  Se usa para configurar la ubicación
        de la imagen de arranque que se usará al crear un CD
        arrancable <quote>El Torito</quote>.
        Esta opción usa como argumento la ruta a la imagen de
        arranque desde la raíz del árbol de directorios que
        se va a escribir en el CD.  Por defecto &man.mkisofs.8;
        crea una imagen ISO en un modo llamado <quote>de emulación
        de disquete (floppy)</quote>, y por lo tanto espera que
        la imagen de arranque sea exactamente de 1.200, 1.440 o
        2880&nbsp;KB de tamaño.  Algunos cargadores de arranque,
        como el que se usa en los discos de la distribución &os;,
        no utilizan modo de emulación: se usa la opción
        <option>-no-emul-boot</option>.  Por tanto, si
        <filename>/tmp/miarranque</filename> tiene un sistema &os;
        arrancable con la imagen de arranque en
        <filename>/tmp/miarranque/boot/cdboot</filename> podría
        crear la imagen en un sistema de ficheros ISO 9660 en
        <filename>/tmp/arrancable.iso</filename> de la siguiente manera:</para>

      <screen>&prompt.root; <userinput>mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/arrancable.iso /tmp/miarranque</userinput></screen>

      <para>Hecho esto, si tiene <filename>vn</filename>
        (FreeBSD&nbsp;4.X), o <filename>md</filename>
        (FreeBSD&nbsp;5.X)
        configurado en su kernel, puede montar el sistema de
        ficheros del siguiente modo:</para>

      <screen>&prompt.root; <userinput>vnconfig -e vn0c /tmp/arrancable.iso</userinput>
&prompt.root; <userinput>mount -t cd9660 /dev/vn0c /mnt</userinput></screen>

      <para>En FreeBSD&nbsp;4.X y FreeBSD&nbsp;5.X proceda del siguiente
        modo:</para>

      <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /tmp/arrancable.iso -u 0</userinput>
&prompt.root; <userinput>mount -t cd9660 /dev/md0 /mnt</userinput></screen>

      <para>Ahora puede verificar que <filename>/mnt</filename>
        y <filename>/tmp/miarranque</filename> sean idénticos.</para>

      <para>Existen muchas otras opciones que puede usar para depurar el
        comportamiento de &man.mkisofs.8;, sobre todo en lo que se refiere
        al esquema ISO 9660 y la creación de discos Joliet y HFS.
        Consulte el manual de &man.mkisofs.8;.</para>
    </sect2>

    <sect2 xml:id="burncd">
      <title>burncd</title>
      <indexterm>
        <primary>CDROM</primary>
        <secondary>grabar</secondary>
      </indexterm>
      <para>Si tiene una grabadora ATAPI puede usar
        <command>burncd</command> para grabar una imagen ISO en un
        CD.  <command>burncd</command> forma parte del sistema base, y
        está en <filename>/usr/sbin/burncd</filename>.  Su uso
        es muy sencillo, ya que tiene pocas opciones:</para>

      <screen>&prompt.root; <userinput>burncd -f unidaddecd data ficheroimagen.iso fixate</userinput></screen>

      <para>Esto grabará una copia de <replaceable>ficheroimagen.iso</replaceable>
        en <replaceable>unidadcd</replaceable>.  El dispositivo por
        defecto es <filename>/dev/acd0</filename>
        (o <filename>/dev/acd0c</filename> en &os;&nbsp;4.X).
        Consulte &man.burncd.8; para ver las opciones de configuración
        de velocidad de escritura, expulsión de CD una vez grabado, y
        escritura de datos de audio.</para>
    </sect2>

    <sect2 xml:id="cdrecord">
      <title>cdrecord</title>

      <para>Si no dispone de una grabadora ATAPI de CD, tendrá que
        usar <command>cdrecord</command> para grabar sus CD.
        <command>cdrecord</command> no forma parte del sistema
        base; instálelo  desde el port
        <package>sysutils/cdrtools</package> o
        como paquete.  Los cambios en el sistema base pueden
        hacer que las versiones binarias del programa fallen.
        Tendrá que actualizar el port cuando actualice su sistema
        o, si está
        <link linkend="stable">siguiendo la rama -STABLE</link>,
        actualizar el port cuando haya una nueva versión
        disponible.</para>

      <para>Aunque <command>cdrecord</command> tiene muchas opciones, el
        uso básico es incluso más simple que
        el de <command>burncd</command>.  Así se graba una imagen
        ISO 9660:</para>

      <screen>&prompt.root; <userinput>cdrecord dev=dispositivo ficheroimagen.iso</userinput></screen>

      <para>La parte complicada de utilizar <command>cdrecord</command> es
        encontrar qué <option>dev</option> usar.  Utilice la
        bandera <option>-scanbus</option> para dar con la
        configuración apropiada.  La salida será parecida a
        la siguiente:</para>
      <indexterm>
        <primary>CDROMs</primary>
        <secondary>grabar</secondary>
      </indexterm>
      <screen>&prompt.root; <userinput>cdrecord -scanbus</userinput>
Cdrecord 1.9 (i386-unknown-freebsd4.2) Copyright (C) 1995-2000 J&ouml;rg Schilling
Using libscg version 'schily-0.1'
scsibus0:
        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk
        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk
        0,2,0     2) *
        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk
        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM
        0,5,0     5) *
        0,6,0     6) *
        0,7,0     7) *
scsibus1:
        1,0,0   100) *
        1,1,0   101) *
        1,2,0   102) *
        1,3,0   103) *
        1,4,0   104) *
        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM
        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner
        1,7,0   107) *</screen>

      <para>Esta lista muestra los valores <option>dev</option> apropiados para
        los dispositivos de la lista.  Localice su grabadora de CD y
        utilice los tres números separados por comas como valor
        para <option>dev</option>.  En este caso, el dispositivo CDW
        es 1,5,0 y por tanto la entrada apropiada sería
        <option>dev=1,5,0</option>.  Hay modos más
        fáciles de especificar este valor; consulte &man.cdrecord.1;
        para más detalles.  También es el lugar donde buscar
        información sobre la escritura de pistas de audio,
        controlar la velocidad de escritura y muchas más cosas.</para>
    </sect2>

    <sect2 xml:id="duplicating-audiocds">
      <title>Copiar CD de audio</title>

      <para>Puede duplicar un CD de audio extrayendo los datos de audio del
        CD a ficheros y escribir estos ficheros en un CD virgen.
        El proceso es ligeramente diferente en unidades ATAPI y
        SCSI.</para>

      <procedure>
	<title>Unidades SCSI</title>

	<step>
          <para>Use <command>cdda2wav</command> para extraer el audio.</para>

	  <screen>&prompt.user; <userinput>cdda2wav -v255 -D2,0 -B -Owav</userinput></screen>
	</step>

	<step>
          <para>Use <command>cdrecord</command> para escribir
            los ficheros <filename>.wav</filename>.</para>

	  <screen>&prompt.user; <userinput>cdrecord -v dev=2,0 -dao -useinfo  *.wav</userinput></screen>

          <para>Asegúrese de que <replaceable>2,0</replaceable>
            este configurado apropiadamente, como se describe en la
            <xref linkend="cdrecord"/>.</para>
	</step>
      </procedure>

      <procedure>
	<title>Unidades ATAPI</title>

	<step>
          <para>El controlador de CD ATAPI hace que cada pista sea
            accesible como
            <filename>/dev/acddtnn</filename>,
            donde <replaceable>d</replaceable> es el número
            de unidad y <replaceable>nn</replaceable> es el
            número de pista expresado con dos dígitos
            decimales, precedido por un cero si es necesario.
            La primera pista del primer disco es
            <filename>/dev/acd0t01</filename>, la segunda es
            <filename>/dev/acd0t02</filename>, la tercera es
            <filename>/dev/acd0t03</filename> y así
            sucesivamente.</para>

          <para>Asegúrese de que existen los ficheros apropiados
            en <filename>/dev</filename>.</para>

	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV acd0t99</userinput></screen>

          <note><para>En FreeBSD 5.0 &man.devfs.5; creará
            y gestionará automáticamente las entradas
            necesarias en <filename>/dev</filename>, así que
            no será necesario usar
            <command>MAKEDEV</command>.</para></note>
	</step>

	<step>
          <para>Extraer cada pista con &man.dd.1;.  También
            deberá declarar un tamaño específico de
            bloque al extraer los ficheros.</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/acd0t01 of=pista1.cdr bs=2352</userinput>
&prompt.root; <userinput>dd if=/dev/acd0t02 of=pista2.cdr bs=2352</userinput>
...
</screen>
	</step>

	<step>
          <para>Grabar los ficheros extraídos a disco con
            <command>burncd</command>.  Debe declarar que son
            ficheros de audio y que <command>burncd</command> debe cerrar
            (<quote>fixate</quote>) el disco al terminar la
            grabación.</para>

	  <screen>&prompt.root; <userinput>burncd -f /dev/acd0 audio pista1.cdr pista2.cdr ... fixate</userinput></screen>
	</step>
      </procedure>
    </sect2>

    <sect2 xml:id="imaging-cd">
      <title>Duplicar CDs de datos</title>

      <para>Puede copiar un CD de datos a un fichero de
        imagen que será funcionalmente equivalente al fichero
        de imagen creado con &man.mkisofs.8;, y puede usarlo
        para duplicar cualquier CD de datos.  El ejemplo dado
        aquí asume que su dispositivo CDROM es
        <filename>acd0</filename>.  Sustitúyalo por el
        dispositivo CDROM correcto para su configuración.
        Bajo &os;&nbsp;4.X, se debe añadir una
        <literal>c</literal> al final del nombre del dispositivo para
        indicar la partición entera o, en el caso de los CDROM,
        el disco entero.</para>

      <screen>&prompt.root; <userinput>dd if=/dev/acd0 of=fichero.iso bs=2048</userinput></screen>

      <para>Hecha la imagen puede garbarla en un CD como se
        describió anteriormente.</para>
    </sect2>

    <sect2 xml:id="mounting-cd">
      <title>Uso de CD de datos</title>

      <para>Ahora que ha creado un CDROM de datos estándar
        tal vez quiera montarlo y leer los datos que contiene.  Por
        defecto &man.mount.8; asume que los sistemas de ficheros
        son de tipo <literal>ufs</literal>.  Si trata de
        hacer algo como</para>

      <screen>&prompt.root; <userinput>mount /dev/cd0 /mnt</userinput></screen>

      <para>recibirá un error como este:
        <errorname>Incorrect super block</errorname> y no se
        montará.  Un CDROM no es un sistema de ficheros
        <literal>UFS</literal> así que los intentos de montarlo
        como tal fallarán. Tendrá que decirle a &man.mount.8;
        que el sistema de ficheros es de tipo <literal>ISO9660</literal>
        y funcionará.  Puede hacerlo mediante la
        opción <option>-t cd9660</option>.
        Por ejemplo, si quiere montar el dispositivo CDROM
        <filename>/dev/cd0</filename>  en
        <filename>/mnt</filename> ejecute:</para>

          <screen>&prompt.root; <userinput>mount -t cd9660 /dev/cd0 /mnt</userinput></screen>

      <para>Tenga en cuenta que el nombre de su dispositivo
        (<filename>/dev/cd0</filename> en este ejemplo) puede
        ser diferente, dependiendo de la interfaz que su CDROM
        utilice.  Además la opción <option>-t cd9660</option>
        sólo ejecuta &man.mount.cd9660.8;.  El ejemplo de arriba
        puede resumirse del siguiente modo:</para>

<screen>&prompt.root; <userinput>mount_cd9660 /dev/cd0 /mnt</userinput></screen>

      <para>En general puede usar CDROM de datos de cualquier
        fabricante, aunque los discos con ciertas extensiones
        ISO 9660 pueden mostrar un comportamiento extraño.
        Por ejemplo, los discos Joliet almacenan todos los nombres
        de fichero en caracteres unicode de dos-bytes.  El kernel
        de &os; no comprende unicode
        (<emphasis>todavía</emphasis>) así que
        los caracteres que no están en inglés aparecen
        como signos de interrogación.  (Si utiliza &os; 4.3
        o alguna versión posterior, el controlador CD9660 incluye
        unas estructuras llamadas <quote>ganchos</quote>, que le
        permitirán cargar una tabla de conversión unicode
        apropiada cuando haga falta.  Hay módulos para algunas
        de las codificaciones más comunes en el port
        <package>sysutils/cd9660_unicode</package>.)</para>

      <para>Es posible que reciba un error <errorname>Device not
        configured</errorname> al tratar de montar un CDROM.
        Generalmente esto significa que la unidad de CDROM piensa que no
        hay disco en la bandeja, o que la unidad no es visible
        en el bus.  Puede llevar un par de segundos el que una
        unidad de CDROM se dé cuenta de que ha sido alimentada,
        por lo tanto sea paciente.</para>

      <para>Algunas veces un CDROM SCSI puede <quote>perdido</quote> debido
        a que no tuvo tiempo suficiente para responder al reset del
        bus.  Si tiene un CDROM SCSI añada la siguiente opción
        a su fichero de  configuración del kernel y
        <link linkend="kernelconfig-building">recompile su kernel</link>.</para>

      <programlisting>options SCSI_DELAY=15000</programlisting>

      <para>Esto le indica a su bus SCSI que haga una pausa de 15
        segundos durante el arranque para darle ocasión
        a su unidad de CDROM de responder al reset del bus.</para>
    </sect2>

    <sect2 xml:id="rawdata-cd">
      <title>Grabar CD de datos <quote>crudos</quote> (Raw)</title>

      <para>Puede guardar un fichero directamente a CD
        sin crear un sistema de ficheros ISO 9660.  Algunas
        personas hacen esto al crear respaldos.  Es un proceso
        más rápido que grabar un CD
        estándar:</para>

      <screen>&prompt.root; <userinput>burncd -f /dev/acd1 -s 12 data fichero.tar.gz fixate</userinput></screen>

      <para>Para recuperar los datos guardardados de este modo en un CD,
        debe leer los datos desde el nodo de dispositivo
        <quote>crudo</quote>:</para>

      <screen>&prompt.root; <userinput>tar xzvf /dev/acd1</userinput></screen>

      <para>No puede montar este disco como lo haría con un
        CDROM normal.  Estos CDROM no pueden leerse en ningún
        sistema operativo que no sea &os;.  Si quiere montar el CD
        o compartir los datos con otro sistema operativo debe utilizar
        &man.mkisofs.8; como se describió previamente.</para>
    </sect2>

    <sect2 xml:id="atapicam">
      <info><title>Uso del controlador ATAPI/CAM</title>
	<authorgroup>
	  <author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Original de </contrib></author>
	</authorgroup>
      </info>

      

      <indexterm>
	<primary>Grabadora de CD</primary>
	<secondary>controlador ATAPI/CAM</secondary>
      </indexterm>

      <para>Este controlador permite que dispositivos ATAPI
        (CD-ROM, CD-RW, unidades DVD, etc) sean accesibles  a través
        del subsistema SCSI y por lo tanto permite el uso de
        aplicaciones como
        <package>sysutils/cdrdao</package> o
	&man.cdrecord.1;.</para>

      <para>Para usar este controlador necesitará añadir
        la siguiente línea al fichero de configuración
        de su kernel:</para>

      <programlisting>device atapicam</programlisting>

      <para>Es posible que necesite también las siguientes
        líneas en el fichero de configuración
        de su kernel:</para>

      <programlisting>device ata
device scbus
device cd
device pass</programlisting>

      <para>(que, por otra parte, ya deberín estar presentes).</para>

      <para>Recompile, instale su nuevo kernel y reinicie
        su máquina.  Durante el proceso de arranque su
        grabadora debe ser detectada; veamos un ejemplo:</para>

      <screen>acd0: CD-RW &lt;MATSHITA CD-RW/DVD-ROM UJDA740&gt; at ata1-master PIO4
cd0 at ata1 bus 0 target 0 lun 0
cd0: &lt;MATSHITA CDRW/DVD UJDA740 1.00&gt; Removable CD-ROM SCSI-0 device
cd0: 16.000MB/s transfers
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed</screen>

      <para>Puede acceder a la unidad a través del
        del nombre de dispositivo <filename>/dev/cd0</filename>;
        por ejemplo, para montar un CDROM en <filename>/mnt</filename>,
        teclée lo siguiente:</para>

      <screen>&prompt.root; <userinput>mount -t cd9660 /dev/cd0 /mnt</userinput></screen>

      <para>Como <systemitem class="username">root</systemitem>, puede ejecutar el
        siguiente comando para obtener las direcciones SCSI
        del dispositivo:</para>

      <screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;MATSHITA CDRW/DVD UJDA740 1.00&gt;   at scbus1 target 0 lun 0 (pass0,cd0)</screen>

      <para>Según esto, <literal>1,0,0</literal> será la
        dirección SCSI a utilizar con &man.cdrecord.1;
        y otras aplicaciones SCSI.</para>

      <para>Para mayor información sobre sistemas
        ATAPI/CAM y SCSI, diríjase a las páginas
        de manual &man.atapicam.4; y &man.cam.4;.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="creating-dvds">
    <info><title>Crear y utilizar medios ópticos (DVDs)</title>
      <authorgroup>
	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Texto de </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Andy</firstname><surname>Polyakov</surname></personname><contrib>Con colaboraciones de </contrib></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>DVD</primary>
      <secondary>grabar</secondary>
    </indexterm>

    <sect2>
      <title>Introducción</title>

      <para>Comparado con el CD, el DVD es la nueva generación
        de tecnología de almacenamiento en medios ópticos.
        El DVD puede almacenar más datos que cualquier CD y
        hoy día es el estándar para publicación
        de vídeo.</para>

      <para>Se pueden definir cinco formatos de grabación para
        lo que llamamos un DVD grabable:</para>

      <itemizedlist>
	<listitem>
          <para>DVD-R: Este fué el primer formato de grabación
            de DVD.  El DVD-R estándar fué definido por el
            <link xlink:href="http://www.dvdforum.com/forum.shtml">DVD Forum</link>.
            Este formato es de una sola escritura.</para>
	</listitem>

	<listitem>
          <para>DVD-RW: Esta es la versión reescribible
            del DVD-R estándar.  Un DVD-RW puede reescribirse
            unas 1.000 veces.</para>
	</listitem>

	<listitem>
          <para>DVD-RAM: Este es también un formato
            reescribible soportado por el DVD Forum.  Un
            DVD-RAM puede verse como un disco duro extraíble.
            Este medio no es compatible con la
            mayoría de las unidades DVD-ROM y reproductores
            de video DVD; hay muy pocas grabadoras de DVD que soporten
            el formato DVD-RAM.</para>
	</listitem>

	<listitem>
          <para>DVD+RW: Este es un formato reescribible definido
            por la
            <link xlink:href="http://www.dvdrw.com/">DVD+RW Alliance</link>.
            Un DVD+RW puede reescribirse unas 1000 veces.</para>
	</listitem>

	<listitem>
          <para>DVD+R: Este un formato es la versión
            de una sola escritura del formato DVD+RW.</para>
	</listitem>
      </itemizedlist>

      <para>Un DVD grabable de una capa puede almacenar hasta
        4.700.000.000&nbsp;bytes, es decir, 4'38&nbsp;GB o
        4485&nbsp;MB (1 kilobyte son 1.024 bytes).</para>

      <note>
        <para>Debemos hacer una distinción entre medio físico
          y aplicación.  Un DVD de vídeo es una estructura
          de fichero específica que puede escribirse en cualquier
          medio físico consistente en un DVD grabable: DVD-R, DVD+R,
          DVD-RW, etc.  Antes de elegir el tipo de medio, debe
          asegurarse que la grabadora y el reproductor de DVD de
          vídeo (un reproductor independiente o una unidad DVD-ROM
          en una computadora) son compatibles con el medio que
          pretende utilizar.</para></note>
    </sect2>

    <sect2>
      <title>Configuración</title>

      <para>Utilice &man.growisofs.1; para grabar el DVD.  Forma parte
        de las herramientas <application>dvd+rw-tools</application>
        (<package>sysutils/dvd+rw-tools</package>).
        Las <application>dvd+rw-tools</application> permiten usar todos
        los tipos de DVD.</para>

      <para>Estas herramientas utilizan el subsistema SCSI para
        acceder a los dispositivos, por lo tanto el
        <link linkend="atapicam">soporte ATAPI/CAM</link> debe estar
        presente en su kernel.  Si su grabadora usa el interfaz
        USB no tendrá que hacerlo, pero tendrá que leer
        la
        <xref linkend="usb-disks"/> para más información sobre
        la configuración de dispositivos USB.</para>

      <para>También debe que habilitar el acceso DMA para
        dispositivos ATAPI. Para ello añada la siguiente
        línea a
        <filename>/boot/loader.conf</filename>:</para>

      <programlisting>hw.ata.atapi_dma="1"</programlisting>

      <para>Antes de intentar utilizar
        <application>dvd+rw-tools</application> debe consultar las
        <link xlink:href="http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html">notas
        de compatibilidad de hardware de dvd+rw-tools</link> por si
        apareciera cualquier información relacionada con su
        grabadora de DVD.</para>

      <note>
        <para>Si desea un interfaz gráfico debería
          echar un vistazo a <application>K3b</application>
          (<package>sysutils/k3b</package>),  que ofrece
          un interfaz de usuario amigable para &man.growisofs.1;
          y muchas otras herramientas de grabación.</para>
      </note>
    </sect2>

    <sect2>
      <title>Quemado de DVD de datos</title>

      <para>&man.growisofs.1; es un <quote>frontend</quote> de
        <link linkend="mkisofs">mkisofs</link>, invocará
        a &man.mkisofs.8; para crear una estructura de sistema de
        ficheros y realizará la escritura del DVD.
        Esto significa que no necesita crear una imagen de los
        datos antes del proceso de escritura.</para>

      <para>La grabación en DVD+R o DVD-R de los datos del
        directorio <filename>/ruta/a/los/datos</filename>,
        se hace del siguiente modo:</para>

      <screen>&prompt.root; <userinput>growisofs -dvd-compat -Z /dev/cd0 -J -R /ruta/a/los/datos</userinput></screen>

      <para>Las opciones <option>-J -R</option> se suministran a
        &man.mkisofs.8; para la creación del sistema de
        ficheros (en este caso: un sistema de ficheros ISO 9660
        con extensiones Joliet y Rock Ridge).  Consulte la
        página de manual &man.mkisofs.8; para más
        detalles.</para>

      <para>La opción <option>-Z</option> se usa
        la sesión inicial de grabación en todos los casos,
        sesiones múltiples o no. El dispositivo DVD del
        ejemplo,
        <replaceable>/dev/cd0</replaceable>, debe ajustarse de
        acuerdo a la configuración de su sistema.  El parámero
        <option>-dvd-compat</option> cerrar&acute; el disco (no
        se podrá añadir nada a la grabación).
        Por contra, esto le brindará una mejor compatibilidad del
        medio con unidades DVD-ROM.</para>

      <para>También es posible grabar una imagen pre-masterizada,
        por ejemplo para guardar la imagen
        <replaceable>ficheroimagen.iso</replaceable>:</para>

      <screen>&prompt.root; <userinput>growisofs -dvd-compat -Z /dev/cd0=ficheroimagen.iso</userinput></screen>

      <para>La velocidad de escritura se detecta y configura
        automáticamente según el medio y la unidad que
        se esté utilizando.  Si quiere forzar la velocidad de
        escritura utilice el
        parámetro <option>-speed=</option>.  Para más
        información consulte la página de manual
        &man.growisofs.1;.</para>
    </sect2>

    <sect2>
      <title>Grabación de un DVD de vídeo</title>

      <indexterm>
	<primary>DVD</primary>
	<secondary>DVD-Video</secondary>
      </indexterm>

      <para>Un DVD de vídeo es una estructura de ficheros
        específica basada en las especificiones ISO 9660 y
        micro-UDF (M-UDF).  El DVD de vídeo también
        dispone de una jerarquía de estructura de datos
        específica; por esta razón es necesario un
        programa especializado para crear tal DVD:
        <package>multimedia/dvdauthor</package>.
        </para>

      <para>Si ya tiene una imagen de un sistema de ficheros de DVD
        de vídeo grábelo de la misma manera que cualquier
        otra imagen; consulte la sección previa para ver un
        ejemplo.  Si ha creado el DVD y el resultado está en,
        por ejemplo, el directorio
        <filename>/ruta/al/vídeo</filename>, use
        el siguiente comando para grabar el DVD de vídeo:</para>

      <screen>&prompt.root; <userinput>growisofs -Z /dev/cd0 -dvd-video /ruta/al/vídeo</userinput></screen>

      <para>La opción <option>-dvd-video</option>
        de &man.mkisofs.8; hará posible la creación
        de una estructura de sistema de ficheros de DVD de vídeo.
        Además, la opción <option>-dvd-video</option>
        implica la opción
        <option>-dvd-compat</option> de &man.growisofs.1;.</para>
    </sect2>

    <sect2>
      <title>Uso de un DVD+RW</title>

      <indexterm>
	<primary>DVD</primary>
	<secondary>DVD+RW</secondary>
      </indexterm>

      <para>A diferencia de un CD-RW, un DVD+RW virgen necesita ser
        formateado antes de usarse por primera vez.  El programa
        &man.growisofs.1; se encargará de ello automáticamente
        cuando sea necesario, lo cual es el método
        <emphasis>recomendado</emphasis>. De todas formas puede usted
        usar el comando <command>dvd+rw-format</command> para
        formatear el DVD+RW:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format /dev/cd0</userinput></screen>

      <para>Necesita ejecutar esta operación solamente una vez,
        recuerde que sólo los DVD+RW vírgenes necesitan
        ser formateados.  Hecho eso ya puede usar el DVD+RW de la
        forma expuesta en las secciones previas.</para>

      <para>Si desea guardar nuevos datos (grabar un sistema de
        ficheros totalmente nuevo, no añadir más datos) en
        un DVD+RW no necesita borrarlo, sólo tiene que escribir
        sobre la grabación anterior (realizando una
        nueva sesión inicial):</para>

      <screen>&prompt.root; <userinput>growisofs -Z /dev/cd0 -J -R /ruta/alos/datosnuevos</userinput></screen>

      <para>El formato DVD+RW ofrece la posibilidad de añadir
        datos fácilmente a una grabación previa.
        La operación consiste en fusionar una nueva sesión
        a la existente, no es escritura multisesión;
        &man.growisofs.1; <emphasis>hará crecer</emphasis> el
        sistema de ficheros ISO 9660 presente en el medio.</para>

      <para>Si, por ejemplo, añadir datos al DVD+RW del ejemplo
        anterior tenemos que usar lo siguiente:</para>

      <screen>&prompt.root; <userinput>growisofs -M /dev/cd0 -J -R /ruta/alos/datosnuevos</userinput></screen>

      <para>Las mismas opciones de &man.mkisofs.8; que utilizamos
        para quemar la sesión inicial pueden usarse en
        ulteriores escritura.</para>

      <note>
        <para>Puede usar la opción <option>-dvd-compat</option>
          si desea mejor la compatibilidad de medios con unidades
          DVD-ROM.  Si la usa en un DVD+RW no evitará que
          pueda añadir más datos.</para>
      </note>

      <para>Si por alguna razón desea borrar el contenido del
        medio, haga lo siguiente:</para>

      <screen>&prompt.root; <userinput>growisofs -Z /dev/cd0=/dev/zero</userinput></screen>
    </sect2>

    <sect2>
      <title>Uso de un DVD-RW</title>

      <indexterm>
	<primary>DVD</primary>
	<secondary>DVD-RW</secondary>
      </indexterm>

      <para>Un DVD-RW acepta dos formatos de disco: el incremental
        secuencial y el de sobreescritura restringida.  Por defecto
        los discos DVD-RW están en formato secuencial.
        </para>

      <para>Un DVD-RW virgen puede utilizarse directamente sin
        necesidad de formateo, sin embargo un DVD-RW no virgen en
        formato secuencial necesita ser borrado antes de poder guardar
        una nueva sesión inicial.</para>

      <para>Para borrar un DVD-RW en modo secuencial, ejecute:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format -blank=full /dev/cd0</userinput></screen>

      <note>
        <para>Un borrado total (<option>-blank=full</option>) tardará
          aproximadamente una hora en un medio 1x.  Un borrado rápido
          puede realizarse con la opción <option>-blank</option>
          si el DVD-RW fué grabado en modo Disk-At-Once (DAO).
          Para grabar el DVD-RW en modo DAO use el comando:</para>

	<screen>&prompt.root; <userinput>growisofs -use-the-force-luke=dao -Z /dev/cd0=ficheroimagen.iso</userinput></screen>

        <para>La opción <option>-use-the-force-luke=dao</option>
          no es imprescindible, ya que &man.growisofs.1; trata
          de detectar el medio (borrado rápido) y entrar en
          escritura DAO.</para>

        <para>Debería usarse el modo de reescritura restringida
          en los DVD-RW, pues este formato es más flexible que el
          formato de incremento secuencial, el formato por defecto.</para>
      </note>

      <para>Para escribir datos en un DVD-RW secuencial proceda del
         mismo modo que con los demás formatos de DVD:</para>

      <screen>&prompt.root; <userinput>growisofs -Z /dev/cd0 -J -R /ruta/alos/datos</userinput></screen>

      <para>Si desea añadir datos a una grabación
        previa tendrá que usar la opción
        <option>-M</option> de &man.growisofs.1;.
        si añade datos a un DVD-RW en modo incremental secuencial
        se creará en el disco una nueva sesión
        y el resultado será un disco multisesión.</para>

      <para>Un DVD-RW en formato de sobreescritura restringido no
        necesita ser borrado antes de una nueva sesión
        inicial, sólo tiene que sobreescribir el disco con la
        opción <option>-Z</option>.  esto es similar al
        caso DVD+RW.  También es posible ampliar un sistema
        de ficheros ISO 9660 ya existente y escrito en el disco del
        mismo modo que para un DVD+RW con la opción
        <option>-M</option>.  El resultado será un DVD
        de una sesión.</para>

      <para>Para poner un DVD-RW en el formato de sobreescritura
        restringido haga lo siguiente:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format /dev/cd0</userinput></screen>

      <para>Para devolverlo al formato secuencial use:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format -blank=full /dev/cd0</userinput></screen>
    </sect2>

    <sect2>
      <title>Multisesión</title>

      <para>Muy pocas unidades DVD-ROM soportan
        DVDs multisesión.  La mayoría de las veces (y
        si tiene suerte) solamente leerán la primera
        sesión.  Los DVD+R, DVD-R y DVD-RW en formato secuencial
        pueden aceptar multisesiones.  El concepto de multisesión
        no existe en los formatos de sobreescritura restringida
        de DVD+RW y DVD-RW.</para>

      <para>Usando el siguiente comando despues de una sesión
        inicial (no-cerrada) en un DVD+R, DVD-R o DVD-RW en formato
        secuencial añadirá una nueva sesión
        al disco:</para>

      <screen>&prompt.root; <userinput>growisofs -M /dev/cd0 -J -R /ruta/alos/nuevosdatos</userinput></screen>

      <para>Usando este comando con un DVD+RW o un DVD-RW en modo
        de sobreescritura restringida, agregará datos
        fusionando la nueva sesión a la ya existente.  El
        resultado será un disco de una sola sesión.
        Este es el procedimiento habitual para añadir
        datos tras la escritura inicial.</para>

      <note>
        <para>Una cierta cantidad de espacio en el medio se usa en
          cada sesión al finalizar e iniciar sesiones;
          por tanto, se deben añadir sesiones con grandes
          cantidades de datos para optimizar el espacio del DVD.
          El número de sesiones está limitado a
          154 para un DVD+R, aproximadamente 2.000 para un DVD-R y
          127 para un DVD+R de doble capa.</para>
      </note>
    </sect2>

    <sect2>
      <title>Para mayor información</title>

      <para>Para más información sobre
        un DVD,puede ejecutar el comando
        <command>dvd+rw-mediainfo /dev/cd0</command>
        con el disco en la unidad.</para>

      <para>Tiene más información sobre
        <application>dvd+rw-tools</application> en la
        manual &man.growisofs.1;, en el
        <link xlink:href="http://fy.chalmers.se/~appro/linux/DVD+RW/">sitio
        web de dvd+rw-tools</link> y en los archivos de la
        <link xlink:href="http://lists.debian.org/cdwrite/">lista de correos
        de cdwrite</link>.</para>

      <note>
        <para>Si va a enviar un informe de problemas es imperativo que
          adjunte la salida que <command>dvd+rw-mediainfo</command> produjo
          al grabar (o no grabar) el medio.  Sin esta salida será
          prácticamente imposible ayudarle.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 xml:id="floppies">
    <info><title>Creación y uso de disquetes (floppies)</title>
      <authorgroup>
	<author><personname><firstname>Julio</firstname><surname>Merino</surname></personname><contrib>Texto original de </contrib></author>
      </authorgroup>
      
      <authorgroup>
	<author><personname><firstname>Martin</firstname><surname>Karlsson</surname></personname><contrib>Reescrito por </contrib></author>
      </authorgroup>
      
    </info>

    

    <para>Poder almacenar datos en discos flexibles es útil algunas
      veces, por ejemplo cuando no se tiene cualquier otro
      medio de almacenamiento extraible o cuando se necesita transferir
      una cantidad pequeña de datos a otro sistema.</para>

    <para>Esta sección explicará cómo usar
      disquetes en &os;.  Cubrirá principalmente el
      formateo y utilización de disquetes DOS
      de 3.5 pulgadas, pero los conceptos son similares en
      otros formatos de disquete.</para>

    <sect2>
      <title>Formateo de disquetes</title>

      <sect3>
	<title>El dispositivo</title>

        <para>El acceso a los disquetes se efectúa a través
          de entradas en <filename>/dev</filename>, igual que en
          otros dispositivos.  Para acceder al disquete
          <quote>crudo</quote> (raw) en versiones 4.X y anteriores, se usa
          <filename>/dev/fdN</filename>,
          donde <replaceable>N</replaceable> representa el
          número de unidad, generalmente 0, o
          <filename>/dev/fdNX</filename>,
          donde <replaceable>X</replaceable> representa una
          letra.</para>

        <para>En versiones 5.0 o posteriores, simplemente use
          <filename>/dev/fdN</filename>.</para>

	<sect4>
	  <title>El tamaño de disco en versiones 4.X y anteriores</title>

          <para>También existen dispositivos
            <filename>/dev/fdN.tamaño</filename>,
            donde <replaceable>tamaño</replaceable> es el
            tamaño del disquete en kilobytes.  Estas entradas se
            usan durante el formateo a bajo nivel para determinar el
            tamaño del disco.  En los siguientes ejemplos se
            usará el tamaño de 1440kB.</para>

          <para>Algunas veces las entradas bajo <filename>/dev</filename>
            tendrán que ser (re)creadas.  Para ello, ejecute:</para>

	  <screen>&prompt.root; <userinput>cd /dev &amp;&amp; ./MAKEDEV "fd*"</userinput></screen>
	</sect4>

	<sect4>
	  <title>El tamaño de disco en versiones 5.0 y
            posteriores</title>

          <para>En 5.0, &man.devfs.5; administrará
            automáticamente los nodos de dispositivo en
            <filename>/dev</filename>, así que el uso de
            <command>MAKEDEV</command> no es necesario.</para>

          <para>El tamaño de disco deseado se pasa a &man.fdformat.1;
            mediante la bandera <option>-f</option>.  Los
            tamaños soportados aparecen en
            &man.fdcontrol.8;, pero tenga muy en cuenta que
            1440kB es el que funciona mejor.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>Formatear</title>

        <para>Un disquete necesita ser formateado a bajo nivel
          antes de poder usarse.  Esto suele hacerlo el fabricante,
          pero el formateo es una buena manera de revisar
          la integridad del medio.  Aunque es posible forzar
          tamaños de disco más grandes (o pequeños),
          1440kB es para lo que la mayoría de los disquetes
          están diseñados.</para>

        <para>Para formatear un disquete a bajo nivel debe usar
          &man.fdformat.1;.  Esta utilidad espera el nombre del
          dispositivo como argumento.</para>

         <para>Tome nota de cualquier mensaje de error, ya que
           éstos pueden ayudarle a determinar si el disco está
           bien o mal.</para>

	<sect4>
	  <title>Formateo en versiones 4.X y anteriores</title>

          <para>Use el dispositivo
            <filename>/dev/fdN.tamaño</filename>
            para formatear el disquete.  Inserte un disco de
            3'5 pulgadas en su unidad y ejecute:</para>

	  <screen>&prompt.root; <userinput>/usr/sbin/fdformat /dev/fd0.1440</userinput></screen>

	</sect4>

	<sect4>
	  <title>Formateo en versiones 5.0 y posteriores</title>

          <para>Use el dispositivo
            <filename>/dev/fdN</filename>
            para formatear el disquete.  Inserte un disco de
            3'5 pulgadas en su unidad y ejecute:</para>

	  <screen>&prompt.root; <userinput>/usr/sbin/fdformat -f 1440 /dev/fd0</userinput></screen>

	</sect4>
      </sect3>
    </sect2>



    <sect2>
      <title>La etiqueta de disco</title>

      <para>Tras un formato del disco a bajo nivel necesitará
        colocar una etiqueta de disco en él.  Esta etiqueta
        de disco será destruida más tarde, pero es
        necesaria para que el sistema determine el tamaño del
        disco y su geometría.</para>

      <para>La nueva etiqueta de disco ocupará todo
        el disco, y contendrá toda la información
        apropiada sobre la geometría del disquete.
        Los valores de geometría para la etiqueta de disco
        están en
	<filename>/etc/disktab</filename>.</para>

      <para>Ejecute &man.disklabel.8; así:</para>

      <screen>&prompt.root; <userinput>/sbin/disklabel -B -r -w /dev/fd0 fd1440</userinput></screen>

      <note><para>Desde &os;&nbsp;5.1-RELEASE
        &man.bsdlabel.8; reemplazó al viejo programa
        &man.disklabel.8;.  En &man.bsdlabel.8; se eliminaron muchas
        opciones y parámetros obsoletos; en el ejemplo de arriba
        la opción <option>-r</option> no debe usarse.
        Para mayor información consulte la página de
        manual de &man.bsdlabel.8;.</para></note>

    </sect2>

    <sect2>
      <title>El sistema de ficheros</title>

      <para>Ahora el disquete está listo para ser formateado
        a alto nivel.  Esto colocará un sistema de ficheros
        nuevo en el disco y permitirá a &os; leer y escribir en
        el disco.  Después de crear el sistema de ficheros
        se destruye la etiqueta de disco, así que si desea
        reformatearlo, tendrá que recrear la etiqueta
        de disco.</para>

      <para>El sistema de ficheros del disquete puede ser UFS o
        o FAT.  FAT suele ser una mejor opción para
        disquetes.</para>

      <para>Para formatear un disquete ejecute:</para>

      <screen>&prompt.root; <userinput>/sbin/newfs_msdos /dev/fd0</userinput></screen>

      <para>El disco está para su uso.</para>
    </sect2>


    <sect2>
      <title>Uso de un disquete</title>


      <para>Para usar el disquete móntelo con &man.mount.msdos.8;
        (en versiones 4.X y anteriores) o con &man.mount.msdosfs.8;
        (en versiones 5.X o posteriores).  También se puede
        usar <package>emulators/mtools</package>.
        </para>
    </sect2>
  </sect1>

  <sect1 xml:id="backups-tapebackups">
    <title>Creación y uso de cintas de datos</title>

    <indexterm><primary>medios de cinta</primary></indexterm>

    <para>Los principales medios de cinta son 4mm, 8mm, QIC, mini-cartridge
      y DLT.</para>

    <sect2 xml:id="backups-tapebackups-4mm">
      <title>4mm (DDS: Digital Data Storage)</title>

      <indexterm>
        <primary>medios de cinta</primary>
	<secondary>cintas DDS (4mm)</secondary>
      </indexterm>
      <indexterm>
        <primary>medios de cinta</primary>
	<secondary>cintas QIC</secondary>
      </indexterm>
      <para>Las cintas de 4mm están reemplazando a las QIC como los
        medios de respaldo más frecuentes en estaciones de trabajo.
        Esta tendencia se aceleró en gran medida cuando Conner
        adquirió Archive, un fabricante líder de unidades
        QIC, y abandonó la producción de unidades QIC.
        Las unidades de 4mm son pequeñas y silenciosas pero no tienen
        la reputación de fiabilidad de la que disfrutan las
        unidades de 8mm.  Los cartuchos son más baratos  y más
        pequeños (3 x 2 x 0.5 pulgadas, 76 x 51 x 12 mm) que los
        cartuchos de 8mm. En el caso de las cintas de 4mm, igual que las
        de  8mm, tienen un cabezal con una vida comparativamente más
        corta.  Ambos utilizan el escaneado en espiral.</para>


      <para>El ancho de datos de estas unidades comienza por aprox.
        150&nbsp;kB/s,  con un pico de aprox. ~500&nbsp;kB/s.
        La capacidad de datos va de los
        1'3&nbsp;GB a 2'0&nbsp;GB.  La compresión
        por hardware, disponible con la mayoría de estas unidades,
        dobla aproximadamente la capacidad.  Existen unidades de biblioteca
        de cinta multi-unidad con 6 unidades en un solo armario y
        cambio de cinta automático.  Las capacidades de estas
        bibliotecas alcanzan los 240&nbsp;GB.</para>

      <para>El estándar DDS-3 soporta capacidades de cinta
        de hasta 12&nbsp;GB (o 24&nbsp;GB con compresión).</para>

      <para>Las unidades de 4mm, igual que las unidades de 8mm, utilizan
        escaneo en espiral.  Tanto unas como otras tienen las mismas
        ventajas y desventajas.</para>

      <para>Las cintas deben renovarse por otras después de 2,000
        pasadas ó 100 respaldos completos.</para>
    </sect2>

    <sect2 xml:id="backups-tapebackups-8mm">
      <title>8mm (Exabyte)</title>
      <indexterm>
        <primary>medios de cinta</primary>
	<secondary>cintas Exabyte (8mm)</secondary>
      </indexterm>

      <para>Las cintas de 8mm son las unidades de cinta SCSI más comunes;
        son la mejor opción de cintas reemplazables y eso hace que
        las unidades de cinta Exabyte 8mm de 2&nbsp;GB sean casi
        omnipresentes.  Las unidades de 8mm son fiables, prácticas y
        silenciosas.  Los cartuchos son baratos y bastante pequeños
        (4.8 x 3.3 x 0.6 pulgadas; 122 x 84 x 15 mm).  Una desventaja de las
        cintas de 8mm es la vida relativamente corta del cabezal y de la
        propia cinta debido a la alta tasa de movimiento relativo de la cinta
        por los cabezales.</para>

      <para>El ancho de datos varía de aprox. 250&nbsp;kB/s
        hasta los 500&nbsp;kB/s.  La capacidad va desde los
        300&nbsp;MB hasta los 7&nbsp;GB.  La compresión por
        hardware, disponible con la mayoría de estas unidades,
        dobla aproximadamente la capacidad.  Estas unidades están
        disponibles como unidades solas o como unidades de biblioteca
        de cinta multi-unidad con 6 unidades y 120 cintas en un solo
        armario.  Las cintas las cambia automáticamente la unidad.
        La capacidad de dichas bibliotecas alcanza los 840+&nbsp;GB.</para>

      <para>El modelo Exabyte <quote>Mammoth</quote> soporta 12&nbsp;GB en
        una cinta (24&nbsp;GB con compresión) y cuesta aproximadamente
        el doble que las unidades de cinta convencionales.</para>

      <para>Los datos se graban en cinta utilizando escaneo en espiral.
        Las cabezas se posicionan en ángulo en relación al
        medio (6 grados aproximadamente).  La cinta se envuelve cerca de 270
        grados en el cilindro que soporta las cabezas.  El cilindro gira
        mientras la cinta se desliza sobre el cilindro.  El resultado es
        una alta densidad de datos y pistas almacenadas muy pegadas,
        dispuestas en ángulo a través de la cinta de un
        extremo al otro.</para>
    </sect2>

    <sect2 xml:id="backups-tapebackups-qic">
      <title>QIC</title>
      <indexterm>
        <primary>medios de cinta</primary>
	<secondary>QIC-150</secondary>
      </indexterm>

      <para>Las cintas y unidades QIC-150 son, quizás, las unidades y
        medios de cinta más comunes.  Las unidades de cinta QIC son
        las unidades de respaldo <quote>serias</quote> menos caras.
        La desventaja es el coste del medio.  Las cintas QIC son caras
        comparadas con las cintas de 8mm o de 4mm, hasta 5 veces el precio de
        almacenamiento de datos por GB.  No obstante, si sus necesidades
        pueden satisfacerse con media docena de cintas, QIC tal vez sea la
        decisión correcta.  QIC es la unidad de cinta
        <emphasis>más</emphasis>  común.  Casi en todas partes
        tienen una unidad QIC de una u otra densidad.  Y ese es el problema,
        QIC ofrece un enorme número de densidades en cintas
        físicamente similares (algunas veces idénticas).
        Las unidades QIC son cualquier cosa menos silenciosas.
        Hacen bastante ruido antes de iniciar la grabación de datos
        y son claramente audibles siempre que leen, escriben o hacen una
        búsqueda.  Las cintas QIC miden 6 x 4 x 0.7 pulgadas;
        152 x 102 x 17 mm.</para>

      <para>El ancho de datos varía de aprox. 150&nbsp;kB/s a aprox.
        500&nbsp;kB/s.  La capacidad de datos varía de 40&nbsp;MB
        a 15&nbsp;GB. La compresión por hardware existe en muchas de
        las nuevas unidades QIC.  Las unidades QIC se ven con menos
        frecuencia y además están siendo suplantadas por
        unidades DAT.</para>

      <para>Los datos se graban en la cinta en pistas.  Las pistas
        discurren a lo largo del extenso eje de la cinta de un extremo
        al otro.  El número de pistas, y por lo tanto el ancho de
        una pista varía según la capacidad de la cinta.
        La mayoría, si no todas las unidades nuevas, ofrecen
        compatibilidad con modelos anteriores al menos para lectura
        (y también en muchos casos de escritura).  QIC tiene
        buena reputación en cuanto a seguridad de los datos
        (las piezas mecánicas son más simples y
        más robustas que en las unidades de búsqueda
        en espiral).</para>

      <para>Las cintas deben ser sustituirse por otras después de
        5,000 respaldos.</para>
    </sect2>

    <sect2 xml:id="backups-tapebackups-dlt">
      <title>DLT</title>
      <indexterm>
        <primary>medios de cinta</primary>
	<secondary>DLT</secondary>
      </indexterm>

      <para>DLT tiene la tasa de transferencia de datos más
        rápida de todos los tipos de unidades mostradas aquí.
        La cinta de 1/2" (12'5mm) está alojada en un cartucho
        de un solo cilindro (4 x 4 x 1 pulgadas; 100 x 100 x 25 mm).
        El cartucho tiene una puerta giratoria a lo largo de todo un
        lado del cartucho.  El mecanismo de la unidad abre esta puerta
        para extraer el <quote>líder</quote>.  El <quote>lider</quote>
        de la cinta tiene un agujero oval que la unidad utiliza para
        <quote>enganchar</quote> la cinta.  El cilindro de levantamiento
        está dentro de la unidad de cinta.  Los demás
        cartuchos descritos en este texto  (los cartuchos de 9
        pistas son la única excepción) tienen el cilindro
        proveedor alojados dentro del propio cartucho de cinta.</para>

      <para>El ancho de datos es aproximadamente de 1'5&nbsp;MB/s, tres veces
        el ancho de unidades de cinta de 4mm, de 8mm o QIC.  Las capacidades
        de datos varían entre 10&nbsp;GB y 20&nbsp;GB en una sola
        unidad.  Hay unidades multicinta y con cargadores multi-cinta,
        y bibliotecas multiunidad que pueden albergar de 5 a 900 cintas
        con una a 20 unidades, con lo que pueden alcanzar desde
        50&nbsp;GB hasta 9&nbsp;TB de almacenamiento.</para>

      <para>Con compresión, el formato DLT Type IV soporta hasta
        70&nbsp;GB de capacidad.</para>

      <para>Los datos se almacenan en cinta en pistas paralelas a la
        dirección del movimiento de la cinta (como en las cintas
        QIC).  Se escriben dos pistas al mismo tiempo.  El tiempo de vida
        de lectura/escritura es relativamente largo.  Una vez que la cinta
        no hay movimiento relativo entre las cabezas y la cinta.</para>
    </sect2>

    <sect2>
      <title xml:id="backups-tapebackups-ait">AIT</title>
      <indexterm>
        <primary>medios de cinta</primary>
	<secondary>AIT</secondary>
      </indexterm>

      <para>AIT es un nuevo formato de Sony, y puede almacenar hasta
        50&nbsp;GB (con compresión) por cinta.  Las cintas contienen
        chips de memoria que retienen un índice de los
        contenidos de la cinta.  Este índice puede ser leido
        rápidamente para determinar la posición
        de los ficheros en la cinta, en lugar de los varios minutos que
        requeriría el proceso con otras cintas.
        <application>SAMS:Alexandria</application> puede gestionar
        más de 40 bibliotecas de cinta AIT, comunicándose
        directamente con el chip de memoria de la cinta para desplegar
        el contenido en pantalla, determinar qué ficheros fueron
        respaldados a qué cinta, ubicar la cinta correcta, cargarla
        y restaurar los datos desde la cinta.</para>

      <para>Las bibliotecas como ésta cuestan alrededor de 20.000
        dólares, lo que las aleja bastante del alcance de los
        aficionados.</para>
    </sect2>

    <sect2>
      <title>Estreno de una cinta</title>

      <para>La primera vez que trate de leer o escribir una
        cinta nueva, completamente en blanco, la operación
        fallará.  El mensaje de la consola se parecerá
        al siguiente:</para>

      <screen>sa0(ncr1:4:0): NOT READY asc:4,1
sa0(ncr1:4:0):  Logical unit is in process of becoming ready</screen>

      <para>La cinta no contiene un bloque identificador (bloque número
        0).  Todas las unidades de cinta QIC desde la adopción del
        estándar QIC-525 escriben un bloque identificador en la
        cinta.  Existen dos soluciones:</para>

      <itemizedlist>
	<listitem>
          <para><command>mt fsf 1</command> hace que la unidad de cinta
            escriba un bloque identificador a la cinta.</para>
	</listitem>

	<listitem>
          <para>Use el botón del panel frontal para expulsar
            la cinta.</para>

          <para>Inserte nuevamente la cinta y haga un <command>dump</command>
            de datos a la cinta.</para>

          <para><command>dump</command> devolverá
            <errorname>DUMP: End of tape detected</errorname> y la consola
            mostrará
            <errorname>HARDWARE FAILURE info:280 asc:80,96</errorname>.</para>

          <para>Rebobine la cinta usando: <command>mt rewind</command>.</para>

          <para>A partir de ese momento podrá utilizar la cinta.</para>
	</listitem>
      </itemizedlist>

    </sect2>
  </sect1>

  <sect1 xml:id="backups-floppybackups">
    <title>Respaldos en disquetes</title>

    <sect2 xml:id="floppies-using">
      <title>?Puedo utilizar disquetes para respaldar mis datos?</title>
      <indexterm><primary>respaldo en discos flexibles</primary></indexterm>
      <indexterm><primary>discos flexibles</primary></indexterm>

      <para>Los disquetes no son realmente el medio ideal
        para hacer respaldos debido a que:</para>

      <itemizedlist>
	<listitem>
          <para>El medio no es fiable, especialmente después de
            largos periodos de tiempo.</para>
	</listitem>

	<listitem>
          <para>El respaldo y la restauración es muy lento.</para>
	</listitem>

	<listitem>
          <para>Tienen una capacidad muy limitada (los dís de
            respaldar un disco duro entero en una docena de disquetes
            pasaron hace mucho).</para>
	</listitem>
      </itemizedlist>

      <para>De todas maneras, si no tiene otro método para respaldar
        sus datos los disquetes son una mejor solución que no tener
        ningún respaldo.</para>

      <para>Si tiene que utilizar disquetes asegúrese de usar
        discos de buena calidad.  Los disquetes que han estado
        almacenados en la oficina durante un par de años son una
        mala elección.  Lo mejor sería que utilizara discos
        nuevos de un fabricante respetado.</para>
    </sect2>

    <sect2 xml:id="floppies-creating">
      <title>?Cómo respaldo mis datos a discos flexibles?</title>

      <para>La mejor manera de respaldar a un disquete
        es usar &man.tar.1; con la opción <option>-M</option>
        (multi volumen), que permite que el respaldo se guarde en
        varios disquetes.</para>

      <para>Para respaldar todos los ficheros en el directorio actual y
        sus subdirectorios use esto (como <systemitem class="username">root</systemitem>):</para>

      <screen>&prompt.root; <userinput>tar Mcvf /dev/fd0 *</userinput></screen>

      <para>Cuando el primer disquete esté lleno
        &man.tar.1; le solicitará que inserte el siguiente
        volumen (debido a que &man.tar.1; es independiente del medio
        se refiere a volúmenes; en éste contexto se refiere a
        disquetes).</para>

      <screen>Prepare volume #2 for /dev/fd0 and hit return:</screen>

      <para>Esto se repite (con el número de volumen incrementando)
        hasta que todos los ficheros especificados hayan sido archivados.</para>
    </sect2>

    <sect2 xml:id="floppies-compress">

      <title>?Puedo comprimir mis respaldos?</title>
      <indexterm>
        <primary><command>tar</command></primary>
      </indexterm>
      <indexterm>
        <primary><command>gzip</command></primary>
      </indexterm>
      <indexterm><primary>compresión</primary></indexterm>

      <para>Desafortunadamente, &man.tar.1; no permite
        el uso de la opción <option>-z</option> para archivos
        multi-volumen.  Puede, por supuesto, hacer un &man.gzip.1;
        a todos los ficheros, mandarlos con &man.tar.1; a los
        disquetes, <emphasis>y después hacer &man.gunzip.1;
        a los archivos</emphasis></para>
    </sect2>

    <sect2 xml:id="floppies-restoring">

      <title>?Cómo recupero mis respaldos?</title>

      <para>Para restaurar el archivo completo use:</para>

      <screen>&prompt.root; <userinput>tar Mxvf /dev/fd0</userinput></screen>

      <para>Hay dos maneras que puede usar para restaurar
        ficheros específicos.  La primera, puede comenzar por el
        primer disco flexible y usar:</para>

      <screen>&prompt.root; <userinput>tar Mxvf /dev/fd0 nombredefichero</userinput></screen>

      <para>La utilidad &man.tar.1; le pedirá que inserte el resto de
        disquetes hasta que encuentre el fichero requerido.</para>

      <para>La segunda manera es: si sabe en qué disco se encuentra
        el fichero puede insertar ese disco y usar el comando expuesto
        arriba.  Tenga en cuenta que si el primer fichero en el disquete
        es la continuación del anterior
        &man.tar.1; le advertirá que no puede restaurarlo
        <emphasis>incluso si no se lo ha solicitado</emphasis></para>
    </sect2>
  </sect1>

  <sect1 xml:id="backup-basics">
    <title>Bases para respaldos</title>

    <para>Los tres principales programas para respaldos son
      &man.dump.8;, &man.tar.1; y &man.cpio.1;.</para>

    <sect2>
      <title>Dump y Restore</title>
      <indexterm>
        <primary>backup software</primary>
	<secondary>dump / restore</secondary>
      </indexterm>
      <indexterm><primary><command>dump</command></primary></indexterm>
      <indexterm><primary><command>restore</command></primary></indexterm>

      <para>Los programas &unix; que se han usado durante muchos
        años para hacer copias de seguridad son
        <command>dump</command> y <command>restore</command>.
        Operan en las unidades como una colección de bloques de
        disco, bajo la abstracción de ficheros, los enlaces y
        directorios creados por el sistema de ficheros.
        <command>dump</command> respalda un sistema de ficheros completo
        en un dispositivo.  No es capaz de respaldar solamente parte
        de un sistema de ficheros o un árbol de directorios
        que se extienda por más de un sistema de ficheros.
        <command>dump</command> no escribe ficheros y directorios a
        cinta, escribe los bloques de datos <quote>crudos</quote> (raw)
        que conforman los ficheros y directorios.</para>

      <note><para>Si utiliza <command>dump</command> en su directorio
        raíz, no respaldará
        <filename>/home</filename>, <filename>/usr</filename> ni
        muchos otros directorios, ya que suelen ser puntos de montaje
        de otros sistemas de ficheros o enlaces simbólicos hacia
        dichos sistemas de ficheros.</para></note>

      <para><command>dump</command> tiene peculiaridades que se mantienen
        desde sus primeros días en la Version 6 de AT&amp;T UNIX
        (alrededor de 1975).  Los parámetros por defecto
        son los adecuados para cintas de 9 pistas (6250 bpi), pero no para
        los medios de alta densidad disponibles hoy en día
        (hasta 62,182 ftpi).  Estos valores por defecto deben
        obviarse en la línea de comandos para aprovechar la
        capacidad de las unidades de cinta actuales.</para>

      <indexterm><primary><filename>.rhosts</filename></primary></indexterm>

      <para>También es posible respaldar datos a través de
        la red a una unidad de cinta conectada a otra computadora con
        <command>rdump</command> y <command>rrestore</command>.  Ambos
        programas dependen de &man.rcmd.3; y &man.ruserok.3; para
        acceder a la unidad de cinta remota.  Por consiguiente, el usuario
        que realiza el respaldo debe estar listado en el fichero
        <filename>.rhosts</filename> de la computadora remota.  Los
        argumentos para <command>rdump</command> y <command>rrestore</command>
        deben ser adecuados para usarse en la computadora remota.
        Cuando realice un <command>rdump</command> desde &os;
        a una unidad de cinta Exabyte conectada a una Sun llamada
        <systemitem>komodo</systemitem>, use:</para>

      <screen>&prompt.root; <userinput>/sbin/rdump 0dsbfu 54000 13000 126 komodo:/dev/nsa8 /dev/da0a 2&gt;&amp;1</userinput></screen>

      <para>Advertencia: existen implicaciones de seguridad al
        permitir autentificación mediante
        <filename>.rhosts</filename>.  Le recomendamos que
        evalúe la situación cuidadosamente.</para>

      <para>También es posible usar <command>dump</command> y
        <command>restore</command> de una forma más segura
        a través de <command>ssh</command>.</para>

      <example>
	<title>Utilizando <command>dump</command> a través de
          <application>ssh</application></title>

	<screen>&prompt.root; <userinput>/sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \
          usuario@maquinaobjetivo.ejemplo.com dd of=/misficherosgrandes/dump-usr-l0.gz</userinput></screen>

      </example>

      <para>Uso del método integrado de <command>dump</command>,
        configurando la variable de ambiente <envar>RSH</envar>:</para>

      <example>
	<title>Uso de <command>dump</command> a través de
           <application>ssh</application> con <envar>RSH</envar>
           configurada</title>

	<screen>&prompt.root; <userinput>RSH=/usr/bin/ssh /sbin/dump -0uan -f usuario@maquinaobjetivo.ejemplo.com:/dev/sa0 /usr</userinput></screen>

      </example>

    </sect2>

    <sect2>
      <title><command>tar</command></title>
      <indexterm>
        <primary>software de respaldo</primary>
        <secondary><command>tar</command></secondary>
      </indexterm>

      <para>&man.tar.1; también es de la época de
        la Version 6 de AT&amp;T UNIX (alrededor de 1975).
        <command>tar</command> trabaja en cooperación con el
        sistema de ficheros; escribe ficheros y directorios a
        cinta.  <command>tar</command> no soporta el rango completo
        de opciones que ofrece &man.cpio.1;, pero no requiere el
        inusual comando de pipeline que utiliza
        <command>cpio</command>.</para>

      <indexterm><primary><command>tar</command></primary></indexterm>

      <para>En FreeBSD 5.3 y posteriores, tiene a su disposición
        GNU <command>tar</command>
        y el comando por defecto <command>bsdtar</command>.
        La versión GNU puede ser invocada mediante
        <command>gtar</command>.  Soporta dispositivos remotos mediante
        la misma sintaxis que <command>rdump</command>.  Para hacer un
        <command>tar</command> a una unidad de cinta conectada a una
        Sun llamada <systemitem>komodo</systemitem>, use:</para>

      <screen>&prompt.root; <userinput>/usr/bin/gtar cf komodo:/dev/nsa8 . 2&gt;&amp;1</userinput></screen>

      <para>Puede hacer lo mismo con o con
        <command>bsdtar</command> usando un <quote>pipe</quote> y
        <command>rsh</command> para mandar los datos a una unidad
        de cinta remota.</para>

      <screen>&prompt.root; <userinput>tar cf - . | rsh nombredemaquina dd of=dispositivo-de-cinta obs=20b</userinput></screen>

      <para>Si le preocupa la seguridad del proceso de hacer un
        respaldo a través de una red debe usar
        <command>ssh</command> en lugar de <command>rsh</command>.
        </para>
    </sect2>

    <sect2>
      <title><command>cpio</command></title>
      <indexterm>
        <primary>software de respaldo</primary>
        <secondary><command>cpio</command></secondary>
      </indexterm>

      <para>&man.cpio.1; es el programa de intercambio de archivos de
        cinta para medios magnéticos.  <command>cpio</command>
        tiene opciones (entre muchas otras) para realizar intercambio de
        bytes, escribir un número diferente de formatos de
        archivo y hacer <quote>pipe</quote> de datos hacia otros programas.
        Esta última opción hace de <command>cpio</command>
        una elección excelente para medios de instalación.
        <command>cpio</command> no sabe cómo recorrer el árbol
        de directorios, así que debe facilitarle una lista de
        directorios a través de
        <filename>stdin</filename>.</para>

      <indexterm><primary><command>cpio</command></primary></indexterm>

      <para><command>cpio</command> no permite respaldos a través
        de la red.  Puede usar un pipe y <command>rsh</command>
        para mandar los datos a una unidad de cinta remota.</para>

      <screen>&prompt.root; <userinput>for f in lista_directorios; do</userinput>
<userinput>find $f &lt;&lt; backup.list</userinput>
<userinput>done</userinput>
&prompt.root; <userinput>cpio -v -o --format=newc &lt; backup.list | ssh usuario@máquina "cat &gt; dispositivo_de_respaldo"</userinput></screen>

      <para>Donde <replaceable>lista_directorios</replaceable> es la lista de
        directorios que desea respaldar,
        <replaceable>usuario</replaceable>@<replaceable>máquina</replaceable>
        es la combinación  usuario/nombre de equipo que realizará
        el respaldo y <replaceable>dispositivo_de_respaldo</replaceable>
        es donde el respaldo se escribirá efectivamente (por ejemplo
        <filename>/dev/nsa0</filename>).</para>
    </sect2>

    <sect2>
      <title><command>pax</command></title>
      <indexterm>
        <primary>software de respaldo</primary>
        <secondary><command>pax</command></secondary>
      </indexterm>
      <indexterm><primary><command>pax</command></primary></indexterm>
      <indexterm><primary>POSIX</primary></indexterm>
      <indexterm><primary>IEEE</primary></indexterm>

      <para>&man.pax.1; es la respuesta IEEE/&posix; a
        <command>tar</command> y <command>cpio</command>.
        A través de los años las diversas versiones
        de <command>tar</command> y <command>cpio</command> se han
        vuelto ligeramente incompatibles, así que en lugar
        de pelear por hacerlo completamente estándar,
        &posix; creó una nueva utilidad de archivado.
        <command>pax</command> trata de leer y escribir muchos de
        los diversos formatos de <command>cpio</command> y
        <command>tar</command>, además de nuevos formatos
        propios.  Su conjunto de comandos se parece más a
        <command>cpio</command> que a
	<command>tar</command>.</para>
    </sect2>

    <sect2 xml:id="backups-programs-amanda">

      <title><application>Amanda</application></title>

      <indexterm>
        <primary>software de respaldo</primary>
        <secondary><application>Amanda</application></secondary>
      </indexterm>

      <indexterm><primary><application>Amanda</application></primary></indexterm>

      <!-- Remove link until <port> tag is available -->

      <para><application>Amanda</application> (Advanced Maryland
        Network Disk Archiver) es un sistema de respaldos cliente/servidor,
        en lugar de un solo programa.  Un servidor
        <application>Amanda</application>
        respaldará a una sola unidad de cinta cualquier cantidad de
        computadoras que tengan clientes <application>Amanda</application>
        y una conexión de red al servidor
        <application>Amanda</application>.
        Un problema común en sitios con gran cantidad de discos
        grandes es que la cantidad de tiempo requerida para respaldar los
        datos directamente a cinta excede la cantidad de tiempo disponible
        para la tarea.  <application>Amanda</application> resuelve este
        problema.  <application>Amanda</application> puede usar un
        <quote>disco intermedio</quote> para respaldar varios sistemas de
        ficheros al mismo tiempo.
        <application>Amanda</application> crea
        <quote>conjuntos de archivo</quote>, esto es, un grupo de cintas
        usadas durante un periodo de tiempo para crear respaldos completos
        de todos los sistemas de ficheros listados en el fichero de
        configuración de <application>Amanda</application>.
        El <quote>conjunto de archivo</quote> también contiene
        respaldos incrementales nocturnos (o diferenciales) de todos los
        sistemas de ficheros.  Para restaurar un sistema de ficheros
        dañado hace falta el respaldo completo más reciente
        y los respaldos incrementales.</para>

     <para>El fichero de configuración ofrece un control
       exhaustivo de los respaldos y del tráfico de red que
       <application>Amanda</application> genera.
       <application>Amanda</application> usará cualquiera de
       los programas de respaldo mencionados arriba para escribir los
       datos a cinta.  Puede instalar <application>Amanda</application>
       como paquete y como port.  No forma parte del sistema base.</para>
      </sect2>

    <sect2>
      <title>No hacer nada</title>

      <para><quote>No hacer nada</quote> no es un programa, pero
        es la estrategia de respaldo más extendida.  No tiene
        coste.  No hay un calendario de respaldos a seguir.  Simplemente
        hay que decir <emphasis>que no</emphasis>.  Si algo le sucediera a
        sus datos <emphasis>sonría y acostúmbrese a su nueva
        situación</emphasis>.</para>

      <para>Si su tiempo y sus datos valen poco o nada, entonces
        <quote>no hacer nada</quote> es el programa de respaldo más
        adecuado para usted.  Pero cuidado, &unix; es una herramienta
        muy poderosa y puede suceder que dentro de seis meses
        tenga un montón de ficheros que sean valiosos para
        usted.</para>

      <para><quote>No hacer nada</quote> es el método correcto de
        respaldo para <filename>/usr/obj</filename> y otros árboles
        de directorios que pueden ser fácilmente recreados por su
        computadora.  Un ejemplo son los archivos que forman la
        versión HTML o &postscript; de este manual.
        Estos documentos han sido generados desde ficheros SGML.
        Crear respaldos de los archivos HTML o &postscript; no es
        necesario dado que los ficheros SGML se respaldan regularmente.
        </para>
    </sect2>

    <sect2>
      <title>?Cuál es el mejor programa de respaldos?</title>
      <indexterm>
        <primary>LISA</primary>
      </indexterm>

      <para>&man.dump.8;.
        <emphasis>Y no hay más que hablar.</emphasis>
        Elizabeth D. Zwicky realizó pruebas de estrés a
        a todos los programas de copia de seguridad aquí
        expuestos.  La elección clarísima para preservar
        todos sus datos y todas las peculiaridades de sus sistemas de
        ficheros &unix; es <command>dump</command>.
        Elizabeth creó sistemas de ficheros conteniendo una gran
        variedad de condiciones inusuales (y algunos no tan inusuales)
        y probó cada programa haciendo un respaldo y restaurando
        esos sistemas de ficheros.  Esas peculiaridades incluían:
        ficheros con y un bloque nulo, ficheros con caracteres
        extraños en sus nombres, ficheros que no se podían
        leer ni escribir, dispositivos, ficheros que cambiaban de
        tamaño durante el respaldo, ficheros que eran creados/borrados
        durante el respaldo y cosas así.  Elizabeth presentó los
        resultados en LISA V en octubre de 1991.
        Consulte <link xlink:href="http://berdmann.dyndns.org/zwicky/testdump.doc.html">torture-testing
        Backup and Archive Programs</link>.</para>
    </sect2>

    <sect2>
      <title>Procedimiento de restauración de emergencia</title>

      <sect3>
	<title>Antes del desastre</title>

        <para>Solamente existen cuatro pasos que debe realizar
          en preparación de cualquier desastre que pudiera
          ocurrir.</para>
	<indexterm>
    <primary><command>disklabel</command></primary>
  </indexterm>

        <para>Primero, imprima la etiqueta de disco de cada uno
          de sus discos (<command>disklabel da0 | lpr</command>),
          su tabla de sistemas de ficheros
          (<filename>/etc/fstab</filename>) y todos los mensajes de
          arranque, dos copias de cada uno.</para>

	<indexterm><primary>fix-it floppies</primary></indexterm>
        <para>Segundo, asegúrese que los disquetes de rescate
          (<filename>boot.flp</filename> y <filename>fixit.flp</filename>)
          tienen todos sus dispositivos.  La manera más fácil
          de revisarlo es reiniciar su máquina con el disquete
          en la unidad y revisar los mensajes de arranque.  Si todos sus
          dispositivos aparecen en la lista y funcionan, pase al tercer
          paso.</para>

        <para>Si ha habido algún problema tiene que crear dos
          disquetes de arranque personalizados, que deben tener un
          kernel que pueda montar todos sus discos y acceder a su
          unidad de cinta.  Estos discos deben contener:
          <command>fdisk</command>, <command>disklabel</command>,
          <command>newfs</command>, <command>mount</command> y
          cualquier programa de respaldo que utilice.  Estos
          programas deben estar enlazados estáticamente.  Si
          usa <command>dump</command>, el disquete debe
          contener <command>restore</command>.</para>

        <para>Tercero, use cintas de respaldo regularmente.  Cualquier
          cambio que haga después de su último respaldo puede
          perderse irremediablemente.  Proteja contra escritura las cintas
          de respaldo.</para>

        <para>Cuarto, pruebe los disquetes (ya sea <filename>boot.flp</filename>
          y <filename>fixit.flp</filename> o los dos discos personalizados
          que creó en el segundo paso) y las cintas de respaldo.
          Documente el procedimiento.  Almacene estas notas con los
          discos de arranque, las impresiones y las cintas de respaldo.
          Estará tan perturbado cuando restaure su sistema  que las
          notas pueden pueden evitar que destruya sus cintas de respaldo.
          (?Como? en lugar de <command>tar xvf /dev/sa0</command>,
          puede teclear accidentalmente <command>tar cvf /dev/sa0</command>
          y sobreescribir su cinta).</para>

        <para>Como medida adicional de seguridad haga discos de inicio
          y dos cintas de respaldo cada vez.  Almacene una de cada
          en una ubicación remota.  Una ubicación remota
          <emphasis>NO</emphasis> es el sótano del mismo edificio.
          Muchas firmas alojadas en el World Trade Center aprendieron esta
          leccón de la manera más difícil.  Esa
          ubicación remota debe estar separada físicamente
          de sus computadoras y unidades de disco por una distancia
          significativa.</para>

	<example>
	  <title>Un <quote>script</quote> para la creación de discos
            flexibles de arranque</title>

	<programlisting><![CDATA[#!/bin/sh
#
# create a restore floppy
#
# format the floppy
#
PATH=/bin:/sbin:/usr/sbin:/usr/bin

fdformat -q fd0
if [ $? -ne 0 ]
then
	 echo "Bad floppy, please use a new one"
	 exit 1
fi

# place boot blocks on the floppy
#
disklabel -w -B /dev/fd0c fd1440

#
# newfs the one and only partition
#
newfs -t 2 -u 18 -l 1 -c 40 -i 5120 -m 5 -o space /dev/fd0a

#
# mount the new floppy
#
mount /dev/fd0a /mnt

#
# create required directories
#
mkdir /mnt/dev
mkdir /mnt/bin
mkdir /mnt/sbin
mkdir /mnt/etc
mkdir /mnt/root
mkdir /mnt/mnt			# for the root partition
mkdir /mnt/tmp
mkdir /mnt/var

#
# populate the directories
#
if [ ! -x /sys/compile/MINI/kernel ]
then
	 cat &lt;&lt; EOM
The MINI kernel does not exist, please create one.
Here is an example config file:
#
# MINI - A kernel to get FreeBSD onto a disk.
#
machine         "i386"
cpu             "I486_CPU"
ident           MINI
maxusers        5

options         INET                    # needed for _tcp _icmpstat _ipstat
                                        #            _udpstat _tcpstat _udb
options         FFS                     #Berkeley Fast File System
options         FAT_CURSOR              #block cursor in syscons or pccons
options         SCSI_DELAY=15           #Be pessimistic about Joe SCSI device
options         NCONS=2                 #1 virtual consoles
options         USERCONFIG              #Allow user configuration with -c XXX

config          kernel	root on da0 swap on da0 and da1 dumps on da0

device          isa0
device          pci0

device          fdc0	at isa? port "IO_FD1" bio irq 6 drq 2 vector fdintr
device          fd0	at fdc0 drive 0

device          ncr0

device          scbus0

device          sc0	at isa? port "IO_KBD" tty irq 1 vector scintr
device          npx0	at isa? port "IO_NPX" irq 13 vector npxintr

device          da0
device          da1
device          da2

device          sa0

pseudo-device   loop            # required by INET
pseudo-device   gzip            # Exec gzipped a.out's
EOM
	 exit 1
fi

cp -f /sys/compile/MINI/kernel /mnt

gzip -c -best /sbin/init > /mnt/sbin/init
gzip -c -best /sbin/fsck > /mnt/sbin/fsck
gzip -c -best /sbin/mount > /mnt/sbin/mount
gzip -c -best /sbin/halt > /mnt/sbin/halt
gzip -c -best /sbin/restore > /mnt/sbin/restore

gzip -c -best /bin/sh > /mnt/bin/sh
gzip -c -best /bin/sync > /mnt/bin/sync

cp /root/.profile /mnt/root

cp -f /dev/MAKEDEV /mnt/dev
chmod 755 /mnt/dev/MAKEDEV

chmod 500 /mnt/sbin/init
chmod 555 /mnt/sbin/fsck /mnt/sbin/mount /mnt/sbin/halt
chmod 555 /mnt/bin/sh /mnt/bin/sync
chmod 6555 /mnt/sbin/restore

#
# create the devices nodes
#
cd /mnt/dev
./MAKEDEV std
./MAKEDEV da0
./MAKEDEV da1
./MAKEDEV da2
./MAKEDEV sa0
./MAKEDEV pty0
cd /

#
# create minimum file system table
#
cat > /mnt/etc/fstab &lt;&lt;EOM
/dev/fd0a    /    ufs    rw  1  1
EOM

#
# create minimum passwd file
#
cat > /mnt/etc/passwd &lt;&lt;EOM
root:*:0:0:Charlie &amp;:/root:/bin/sh
EOM

cat > /mnt/etc/master.passwd &lt;&lt;EOM
root::0:0::0:0:Charlie &amp;:/root:/bin/sh
EOM

chmod 600 /mnt/etc/master.passwd
chmod 644 /mnt/etc/passwd
/usr/sbin/pwd_mkdb -d/mnt/etc /mnt/etc/master.passwd

#
# umount the floppy and inform the user
#
/sbin/umount /mnt
echo "The floppy has been unmounted and is now ready."]]></programlisting>

        </example>

      </sect3>

      <sect3>
	<title>Después del desastre</title>

        <para>La pregunta clave es: ?sobrevivió su hardware?
          Ha estado haciendo respaldos regularmente, así que no hay
          necesidad de preocuparse por el software.</para>

        <para>Si el hardware ha sufrido daños los componentes deben
          reemplazarse antes de intentar de usar su sistema.</para>

        <para>Si su hardware está bien revise sus discos de arranque.
          Si usa disquetes de arranque personalizados arranque en modo
          monousuario (teclée <literal>-s</literal> en el
          en el <quote>prompt</quote> de arranque <prompt>boot:</prompt>).
          Sáltese el siguiente párrafo.</para>

        <para>Si utiliza usando los discos <filename>boot.flp</filename>
          y <filename>fixit.flp</filename>, siga leyendo.  Inserte el disco
          <filename>boot.flp</filename> en la primera unidad de disquete
          y arranque la máquina.  El menú de instalación
          original se desplegará en pantalla.  Seleccione la
          opción <literal>Fixit--Repair mode with CDROM or
          floppy.</literal>.  Inserte el disco <filename>fixit.flp</filename>
          cuando se le pida.  Tanto <command>restore</command> como los
          demás programas que necesitará están en
          <filename>/mnt2/rescue</filename>
          (<filename>/mnt2/stand</filename> para versiones
          de &os; anteriores a 5.2).</para>

	<para>Recupere cada sistema de ficheros por separado.</para>

	<indexterm>
    <primary><command>mount</command></primary>
  </indexterm>
	<indexterm><primary>partición raíz</primary></indexterm>
	<indexterm>
    <primary><command>disklabel</command></primary>
  </indexterm>
	<indexterm>
    <primary><command>newfs</command></primary>
  </indexterm>
        <para>Trate de montar (por ejemplo
          <command>mount /dev/da0a /mnt</command>) la partición
          raíz de su primer disco.  Si la etiqueta del disco
          ha sufrido daños use <command>disklabel</command>
          para reparticionar y etiquetar el disco de forma que coincida con
          la etiqueta que imprimió y guardó previamente.   Use
          <command>newfs</command> para crear de nuevo sus sistemas de
          ficheros.  Monte de nuevo la partición raíz del
          disquete en modo lectura/escritura
          (<command>mount -u -o rw /mnt</command>).  Ejecute su programa de
          respaldo y utilice las cintas de respaldo para restaurar sus datos
          en este sistema de ficheros
          (<command>restore vrf /dev/sa0</command>).
          Desmonte el sistema de ficheros (<command>umount /mnt</command>).
          Repita el proceso con cada sistema de ficheros que sufrió
          daños.</para>

        <para>Una vez que su sistema esté en marcha respalde sus
          datos en cintas nuevas.  Cualquiera que haya sido la causa de
          la caída o pérdida de datos puede suceder de nuevo.
          Una hora más que gaste ahora puede ahorrarle mucho
          sufrimiento más adelante.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="disks-virtual">
    <info><title>Sistemas de ficheros en red, memoria y respaldados en fichero</title>
      <authorgroup>
	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Reorganizado y mejorado por </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>discos virtuales</primary></indexterm>
    <indexterm>
      <primary>discos</primary>
      <secondary>virtuales</secondary>
    </indexterm>

    <para>Además de los discos que conecta físicamente en
      su máquina (discos flexibles, CDs, discos duros, etc.)
      &os; permite usar otro tipo de discos:
      <firstterm>los discos virtuales</firstterm>.</para>

    <indexterm><primary>NFS</primary></indexterm>
    <indexterm><primary>Coda</primary></indexterm>
    <indexterm>
      <primary>discos</primary>
      <secondary>memoria</secondary>
    </indexterm>
    <para>Esto incluye sistemas de ficheros en red como
      <link linkend="network-nfs">NFS</link> y Coda, sistemas de
      ficheros basados en memoria y sistemas de ficheros basados en
      fichero.</para>

    <para>Según la versión de &os; que utilice tendrá
      que utilizar diferentes herramientas para la creación y
      uso de sistemas de ficheros en memoria y sistemas de ficheros
      basados en fichero.</para>

    <note>
      <para>Los usuarios de FreeBSD&nbsp;4.X tendrán que usar
        &man.MAKEDEV.8; para crear los dispositivos requeridos.
        FreeBSD&nbsp;5.0 y posteriores usan &man.devfs.5; para
        gestionar los nodos de dispositivo correspondientes de forma
        transparente para el usuario.</para>
    </note>

    <sect2 xml:id="disks-vnconfig">

      <title>Sistema de ficheros basado en fichero en FreeBSD&nbsp;4.X</title>
      <indexterm>
        <primary>discos</primary>
        <secondary>file-backed (4.X)</secondary>
      </indexterm>

      <para>La utilidad &man.vnconfig.8; configura y habilita vnodes
        de dispositivos de pseudodisco.  Un <firstterm>vnode</firstterm>
        es una representación de un fichero y es el enfoque de
        la actividad de fichero.  Esto significa que &man.vnconfig.8;
        utiliza ficheros para crear y operar un sistema de ficheros.
        Un uso posible es el montaje de imágenes de disquetes o CD
        almacenadas como ficheros.</para>

      <para>Para poder usar &man.vnconfig.8; necesitará tener
        &man.vn.4; en el fichero de configuración de su
        kernel:</para>

      <programlisting>pseudo-device vn</programlisting>

      <para>Para montar una imagen de un sistema de ficheros:</para>

      <example>
	<title>Uso de vnconfig para montar una imagen de un sistema de
          ficheros bajo &os;&nbsp;4.X</title>

	<screen>&prompt.root; <userinput>vnconfig vn0 imagendedisco</userinput>
&prompt.root; <userinput>mount /dev/vn0c /mnt</userinput></screen>
      </example>

      <para>Para crear una nueva imagen de un sistema de ficheros con
        &man.vnconfig.8;:</para>

      <example>
	<title>Creación de una imagen nueva de un sistema de ficheros
          respaldado en un archivo con <command>vnconfig</command></title>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=nuevaimagen bs=1k count=5k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>vnconfig -s labels -c vn0 nuevaimagen</userinput>
&prompt.root; <userinput>disklabel -r -w vn0 auto</userinput>
&prompt.root; <userinput>newfs vn0c</userinput>
Warning: 2048 sector(s) in last cylinder unallocated
/dev/vn0c:     10240 sectors in 3 cylinders of 1 tracks, 4096 sectors
        5.0MB in 1 cyl groups (16 c/g, 32.00MB/g, 1280 i/g)
super-block backups (for fsck -b #) at:
 32
&prompt.root; <userinput>mount /dev/vn0c /mnt</userinput>
&prompt.root; <userinput>df /mnt</userinput>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/vn0c        4927        1     4532     0%    /mnt</screen>
      </example>
    </sect2>

    <sect2 xml:id="disks-mdconfig">
      <title>Sistemas de ficheros basados en fichero en
        FreeBSD&nbsp;5.X</title>
      <indexterm>
        <primary>discos</primary>
        <secondary>file-backed (5.X)</secondary>
      </indexterm>

      <para>&man.mdconfig.8; se usa para configurar y habilitar discos
        habilitar discos de memoria, &man.md.4;, en FreeBSD&nbsp;5.X.
        Para usar &man.mdconfig.8;, tendrá que cargar el módulo
        &man.md.4; o añadir soporte para el mismo el el fichero de
        configuración del kernel:</para>

      <programlisting>device md</programlisting>

      <para>&man.mdconfig.8; soporta tres tipos de discos virtuales
        en memoria: discos de memoria asignados mediante
        &man.malloc.9;, discos de memoria usando un fichero o
        espacio de swap como respaldo.  Un uso posible es
        montar imágenes de disquetes o CD archivadas.
        </para>

      <para>Para montar una imagen de un sistema de ficheros:</para>

      <example>
	<title>Uso de <command>mdconfig</command> para montar una imagen
          de un sistema de ficheros en &os;&nbsp;5.X</title>

	<screen>&prompt.root; <userinput>mdconfig -a -t vnode -f imagendedisco -u 0</userinput>
&prompt.root; <userinput>mount /dev/md0 /mnt</userinput></screen>
      </example>

      <para>Para crear una imagen nueva de un sistema de ficheros
        con &man.mdconfig.8;:</para>

      <example>
	<title>Creación de un disco respaldado en fichero
          con <command>mdconfig</command></title>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=nuevaimagen bs=1k count=5k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mdconfig -a -t vnode -f nuevaimagen -u 0</userinput>
&prompt.root; <userinput>disklabel -r -w md0 auto</userinput>
&prompt.root; <userinput>newfs md0c</userinput>
/dev/md0c: 5.0MB (10240 sectors) block size 16384, fragment size 2048
	using 4 cylinder groups of 1.27MB, 81 blks, 256 inodes.
super-block backups (for fsck -b #) at:
 32, 2624, 5216, 7808
&prompt.root; <userinput>mount /dev/md0c /mnt</userinput>
&prompt.root; <userinput>df /mnt</userinput>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/md0c        4846        2     4458     0%    /mnt</screen>
      </example>

      <para>Si no especifica el número de unidad con la
        opción <option>-u</option> &man.mdconfig.8;
        usará la designación automática de
        &man.md.4; para seleccionar un dispositivo sin usar.
        El nombre de la unidad designada se enviará a la salida
        esándar como <filename>md4</filename>.  Para más
        información sobre &man.mdconfig.8; consulte su página
        de manual.</para>

      <note><para>A partir de &os;&nbsp;5.1-RELEASE
        &man.bsdlabel.8; reemplazó a
        &man.disklabel.8;.  En &man.bsdlabel.8; se eliminaron muchas
        opciones y parámetros obsoletos.  En el ejemplo de
        arriba ignore la opción <option>-r</option>.
        Para más información consulte la página
        de manual de &man.bsdlabel.8;.</para></note>

      <para>&man.mdconfig.8; es muy útil, aunque requiere
        muchas líneas de comando para crear un sistema de ficheros
        basado en un fichero.  FreeBSD&nbsp;5.0 incorpora &man.mdmfs.8;,
        que configura un disco &man.md.4; utilizando
        &man.mdconfig.8;, pone un sistema de ficheros UFS en él
        mediante &man.newfs.8; y lo monta usando &man.mount.8;.
        Por ejemplo, si desea crear y montar la misma imagen de
        sistema de ficheros de arriba, simplemente teclée
        lo siguiente:</para>

      <example>
        <title>Configurar y montar un disco basado en un fichero con
          <command>mdmfs</command></title>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=nuevaimagen bs=1k count=5k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mdmfs -F newimage -s 5m md0 /mnt</userinput>
&prompt.root; <userinput>df /mnt</userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0        4846    2  4458     0%    /mnt</screen>
      </example>

      <para>Si utiliza la opción <option>md</option> sin
        número de unidad, &man.mdmfs.8; usará la
        opción de auto unidad de &man.md.4; para
        selecionar automáticamente un dispositivo sin usar.  Para
        más información sobre &man.mdmfs.8;
        diríjase a la página de manual.</para>

    </sect2>

    <sect2 xml:id="disks-md-freebsd4">

      <title>Sistemas de ficheros basados en memoria en FreeBSD&nbsp;4.X</title>

      <indexterm>
        <primary>discos</primary>
        <secondary>sistemas de ficheros en memoria (4.X)</secondary>
      </indexterm>

      <para>El controlador &man.md.4; es un modo sencillo y eficiente de
        crear sistemas de ficheros basados en memoria en FreeBSD&nbsp;4.X.
        &man.malloc.9; se usa para ubicar la memoria.</para>

      <para>Sencillamete toma un sistema de ficheros que usted ha
        preparado con, por ejemplo, &man.vnconfig.8;, y:</para>

      <example>
	<title>Disco de memoria md en FreeBSD&nbsp;4.X</title>

	<screen>&prompt.root; <userinput>dd if=nuevaimagen of=/dev/md0</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mount /dev/md0c /mnt</userinput>
&prompt.root; <userinput>df /mnt</userinput>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/md0c        4927        1     4532     0%    /mnt</screen>
      </example>

      <para>Para más información por favor consulte
        la página de manual de &man.md.4;.</para>
    </sect2>

    <sect2 xml:id="disks-md-freebsd5">
      <title>sistemas de ficheros basados en memoria en
        FreeBSD&nbsp;5.X</title>
      <indexterm>
        <primary>discos</primary>
        <secondary>sistemas de ficheros en memoria (5.X)</secondary>
      </indexterm>

      <para>Se usan las mismas herramientas para tratar con sistemas
        de ficheros basados en memoria o en ficheros:
        &man.mdconfig.8; o &man.mdmfs.8;.  El almacenamiento de
        sistemas de ficheros basados en memoria requiere el uso de
	&man.malloc.9;.</para>

      <example>
	<title>Creación de un nuevo disco basado en memoria con
	  <command>mdconfig</command></title>

	<screen>&prompt.root; <userinput>mdconfig -a -t malloc -s 5m -u 1</userinput>
&prompt.root; <userinput>newfs -U md1</userinput>
/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048
	using 4 cylinder groups of 1.27MB, 81 blks, 256 inodes.
	with soft updates
super-block backups (for fsck -b #) at:
 32, 2624, 5216, 7808
&prompt.root; <userinput>mount /dev/md1 /mnt</userinput>
&prompt.root; <userinput>df /mnt</userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4846    2  4458     0%    /mnt</screen>
      </example>

      <example>
	<title>Creación de un nuevo disco basado en memoria con
	  <command>mdmfs</command></title>
	<screen>&prompt.root; <userinput>mdmfs -M -s 5m md2 /mnt</userinput>
&prompt.root; <userinput>df /mnt</userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md2        4846    2  4458     0%    /mnt</screen>
      </example>

      <para>En lugar de usar un sistema de ficheros respaldado en
        &man.malloc.9;, es posible utilizar swap; lo único que
        debe hacer es sustituir <option>malloc</option> por
        <option>swap</option> en la línea de comando de
        &man.mdconfig.8;.  &man.mdmfs.8; por defecto
        (sin <option>-M</option>) crea un disco basado en swap).  Para
        más información, consulte las
        páginas de manual de &man.mdconfig.8; y de
        &man.mdmfs.8;.</para>
    </sect2>

    <sect2>
      <title>Desconexión del sistema de un disco de memoria</title>
      <indexterm>
        <primary>discos</primary>
        <secondary>desconectar un disco de memoria</secondary>
      </indexterm>

      <para>Cuando un sistema de ficheros basado en memoria o
        basado en fichero no se usa puede liberar recursos del sistema.
        Lo primero es desmontar el sistema de ficheros: use
        &man.mdconfig.8; para desconectar el disco del sistema y liberar
        dichos recursos.</para>

      <para>Por ejemplo, para desconectar y liberar todos los
        recursos usados por <filename>/dev/md4</filename>:</para>

      <screen>&prompt.root; <userinput>mdconfig -d -u 4</userinput></screen>

      <para>Es posible listar información sobre dispositivos
        &man.md.4; configurados en el sistema mediante
        <command>mdconfig -l</command>.</para>

      <para>En FreeBSD&nbsp;4.X se usa &man.vnconfig.8; para desconectar
        el dispositivo.  Por ejemplo, para desconectar y
        liberar todos los recursos usados por
        <filename>/dev/vn4</filename>:</para>

      <screen>&prompt.root; <userinput>vnconfig -u vn4</userinput></screen>


    </sect2>
  </sect1>

  <sect1 xml:id="snapshots">
    <info><title>Instantáneas (<quote>snapshots</quote>) de sistemas
      de ficheros</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Escrito por </contrib></author>
      </authorgroup>
      
    </info>

    

    <indexterm>
      <primary>sistemas de ficheros</primary>
      <secondary>snapshots</secondary>
    </indexterm>

      <para>FreeBSD&nbsp;5.0 ofrece una característica relacionada
        con
        <link linkend="soft-updates">Soft Updates</link>: las
        instantáneas del sistema de ficheros.</para>

      <para>Las instantáneas permiten a un usuario crear
        imágenes de uno o más sistemas de ficheros dados, y
        tratarlas como un fichero.  Los ficheros de instantánea
        deben crearse en el sistema de ficheros en el que se realiza la
        acción, y un usuario puede crear hasta 20 (veinte)
        instantáneas por sistema de ficheros.  Las
        instantáneas activas se graban en el superbloque, lo que
        hace que sigan ahí independientemente de montajes,
        remontajes y reinicios del sistema.  Cuando ya no necesite
        una instantánea puede borrarla con &man.rm.1;.
        Las instantáneas pueden borrarse en cualquier orden pero
        puede que no pueda recuperar todo el espacio debido a que otra
        instantánea puede reclamar algunos bloques liberados.</para>

      <para>La bandera inalterable de fichero <option>snapshot</option>
        se activa con &man.mksnap.ffs.8; después de la creación
        inicial de un fichero de instantánea.  &man.unlink.1;
        hace una excepción con los ficheros de instantánea,
        ya que permite que se les borre.</para>

      <para>Las instantáneas se crean con &man.mount.8;.
        Veamos un ejemplo.  Vamos a colocar una instantánea de
        <filename>/var</filename> en
        <filename>/var/snapshot/snap</filename>:</para>

<screen>&prompt.root; <userinput>mount -u -o snapshot /var/snapshot/snap /var</userinput></screen>

      <para>También puede usar &man.mksnap.ffs.8; para
        crear una instantánea:</para>

<screen>&prompt.root; <userinput>mksnap_ffs /var /var/snapshot/snap</userinput></screen>

      <para>Si busca ficheros de instantánea en un sistema de
        de ficheros (por ejemplo <filename>/var</filename>) puede usar
        &man.find.1;:</para>

<screen>&prompt.root; <userinput>find /var -flags snapshot</userinput></screen>

      <para>Una instantánea tiene distintos usos:</para>

      <itemizedlist>
	<listitem>
          <para>Algunos administradores usan un fichero de
            instantánea como respaldo, puesto que la instantánea
            puede guardarse en CD o cinta.</para>
	</listitem>

	<listitem>
          <para>Integridad de ficheros; &man.fsck.8; puede ejecutarse
            en una instantánea.  Asumiendo que el sistema de
            ficheros estuviera limpio cuando se montó se debe
            obtener un resultado limpio (e intacto).  En esencia el
            proceso &man.fsck.8; hace esto mismo en segundo plano.</para>
	</listitem>

	<listitem>
          <para>Ejecución de &man.dump.8; en la instantánea.
            Se obtendrá un dump consistente con el sistema de
            ficheros y los sellos de hora de la instantánea.
            &man.dump.8; también puede leer una instantánea,
            crear una imagen dump y eliminar la instantánea en
            un comando usando la opción
            <option>-L</option>.</para>
	</listitem>

	<listitem>
          <para>Ejecutar un &man.mount.8; contra la instantánea
            como una imagen congelada del sistema de ficheros.
            Para montar la instantánea
            <filename>/var/snapshot/snap</filename> ejecute:</para>

<screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /var/snapshot/snap -u 4</userinput>
&prompt.root; <userinput>mount -r /dev/md4 /mnt</userinput></screen>

	</listitem>
      </itemizedlist>

      <para>Podrá recorrer la jerarquía de su sistema de
        ficheros <filename>/var</filename> congelado montado en
        <filename>/mnt</filename>.  Todo estará en el mismo estado
        en el que estaba cuando creó la instantánea.
        La única excepción es que cualquier
        instantánea anterior aparecerá como un fichero
        de longitud cero.  Cuando haya acabado de usar una
        instantánea puede desmontarla con:</para>

<screen>&prompt.root; <userinput>umount /mnt</userinput>
&prompt.root; <userinput>mdconfig -d -u 4</userinput></screen>

      <para>Para más información sobre
        <option>softupdates</option> e instantáneas de sistemas
        ficheros, incluyendo textos técnicos, visite el sitio
        web de Marshall Kirk McKusick:
	<uri xlink:href="http://www.mckusick.com/">http://www.mckusick.com/</uri>.</para>
  </sect1>

  <sect1 xml:id="quotas">
    <title>Cuotas en sistemas de ficheros</title>
    <indexterm>
      <primary>contabilidad</primary>
      <secondary>espacio en disco</secondary>
    </indexterm>
    <indexterm><primary>cuotas de disco</primary></indexterm>

    <para>Las cuotas son una opción del sistema
      operativo que le permite limitar la cantidad de espacio en
      disco y/o el número de fichero que un usuario o
      miembros de un grupo pueden crear en el sistema, pudiendo
      además hacerlo de forma independiente en cada sistema de
      ficheros.
      Suele usarse principalmente en sistemas de tiempo compartido,
      donde se busca limitar la cantidad de recursos que cualquier
      usuario o grupo pueden utilizar.
      Esto evitará que un usuario o un grupo de usuarios
      consuma todos el espacio disponible en disco.</para>

    <sect2>
      <title>Configuración del sistema para habilitar
       cuotas de disco</title>

      <para>Antes de intentar configurar el uso de cuotas de disco
        hay que asegurarse de que las cuotas están activadas en el
        kernel.  La siguiente línea debe estar en el fichero de
        de configuración del kernel:</para>

      <programlisting>options QUOTA</programlisting>

      <para>El kernel <filename>GENERIC</filename> no lo tiene activado
        por defecto, así que tendrá que configurar,
        compilar e instalar un kernel personalizado para
        poder usar cuotas de disco.  Por favor, consulte el
        <xref linkend="kernelconfig"/> para más información
        sobre la configuración del kernel.</para>

      <para>A continuación tendrá que habilitar
        las cuotas de disco en <filename>/etc/rc.conf</filename>.
        Añadale la siguiente línea:</para>

      <programlisting>enable_quotas="YES"</programlisting>
      <indexterm>
        <primary>cuotas de disco</primary>
        <secondary>revisión</secondary>
      </indexterm>

      <para>Hay una variable que le permitirá efectuar un
        control más exhaustivo sobre el arranque de cuotas.
        Normalmente se revisa la integridad de cuotas de cada sistema
        de ficheros en el arranque; el responsable es
        &man.quotacheck.8;.  &man.quotacheck.8; se asegura de que los
        datos que hay en su base de datos de cuotas reflejen
        realmente los datos del sistema de ficheros.  Es un proceso
        que lleva mucho tiempo y que afectará significativamente
        al tiempo que tardará su sistema en arrancar.  Si desea
        saltarse ese paso puede usar una variable al efecto en
        <filename>/etc/rc.conf</filename>:</para>

      <programlisting>check_quotas="NO"</programlisting>

      <para>Para concluir tendrá que editar
        <filename>/etc/fstab</filename> para habilitar las cuotas de disco
        para cada sistema de ficheros.  Es aquí donde podrá
        habilitar cuotas por usuario, por grupo, o ambos en todos sus
        sistemas de ficheros.</para>

      <para>Para habilitar cuotas por usuario en un sistema de
        ficheros añada la opción <option>userquota</option> al
        campo de opciones en la entrada de <filename>/etc/fstab</filename>
        que corresponda al sistema de ficheros en el que quiere habilitar
        las cuotas.  Veamos un ejemplo:</para>

      <programlisting>/dev/da1s2g   /home    ufs rw,userquota 1 2</programlisting>

      <para>En el caso de las cuotas de grupo es muy similar.
        Use la opción <option>groupquota</option> en lugar
        de <option>userquota</option>.  Para habilitar
        cuotas por usuario y por grupo modifique la entrada
        de este modo:</para>

      <programlisting>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</programlisting>

      <para>Por defecto los ficheros de cuota se guardan en
        el directorio raíz del sistema de ficheros con los
        nombres <filename>quota.user</filename> y
        <filename>quota.group</filename>
        para cuotas de usuario y grupo respectivamente.
        Consulte &man.fstab.5; para más información.
        Aunque la página de manual de &man.fstab.5; diga que puede
        especificar otra ubicación para los ficheros de
        cuota, no se recomienda hacerlo debido a que las diversas herramientas
        de gestió cuotas no parecen sobrellevar esto
        adecuadamente.</para>

      <para>Hecho todo esto puede reiniciar su sistema con el nuevo
        kernel.  <filename>/etc/rc</filename> ejecutará
        automáticamente los comandos apropiados para crear los
        ficheros de cuota iniciales que requieran todas las entradas en
        en <filename>/etc/fstab</filename>, así que no hay
        necesidad de crear ficheros de cuota de longitud cero.</para>

      <para>En el curso normal de operaciones no se le debería
        pedir que ejecute &man.quotacheck.8;, &man.quotaon.8; o
        &man.quotaoff.8; manualmente.  Sin embargo, tal vez quiera leer
        sus páginas de manual para familiarizarse con su
        funcionamiento.</para>
    </sect2>

    <sect2>
      <title>Configuración de límites de cuota</title>
      <indexterm>
        <primary>cuotas de disco</primary>
        <secondary>límites</secondary>
      </indexterm>

      <para>Una vez que tenga configurado su sistema para usar cuotas
        verifique que en realidad estén habilitadas.  Una manera
        sencilla de hacer esto es ejecutar:</para>

      <screen>&prompt.root; <userinput>quota -v</userinput></screen>

      <para>Debe ver un resumen de una sola línea de uso del
        disco y los límites de cuota actuales para cada sistema
        de ficheros donde estén habilitadas las cuotas.</para>

      <para>Ahora puede iniciar la asignación
        de límites de cuota con &man.edquota.8;.</para>

      <para>Tiene varias opciones para imponer límites en el
        espacio de disco que un usuario o grupo puede ocupar, y
        cuántos ficheros pueden crear.  Puede limitar el uso de
        disco basándose en el espacio en disco (cuotas de bloque) o
        en el número de ficheros (cuotas de inodo) o una
        combinación de ambas.  Cada uno de estos límites
        a su vez se divide en dos categorías: límites
        duros y suaves.</para>

      <indexterm><primary>límite duro</primary></indexterm>
      <para>Un límite duro no puede ser excedido.  Una vez que
        un usuario alcanza su límite duro no puede realizar
        más ubicaciones en el sistema de ficheros en cuestión.
        Por ejemplo, si el usuario tiene un límite duro de
        500 kbytes en un sistema de ficheros y está utilizando
        490 kbytes, el usuario solo puede ocupar
        otros 10 kbytes.  Un intento de ocupar 11 kbytes más
        fallará.</para>

      <indexterm><primary>límite suave</primary></indexterm>
      <para>Los límites suaves pueden excederse por un periodo
        Este periodo de tiempo recibe el nombre de periodo de gracia, que
        por defecto es una semana.  Si un usuario sobrepasa su periodo de
        gracia el límite suave se convertirá en
        un límite duro y no se permitir&acute;n usos de disco
        adicionales.  Cuando el usuario devuelve su cuota de uso de
        recursos a un punto por debajo de su límite suave
        el periodo de gracia se reinicia.</para>

      <para>Veamos un ejemplo de uso de &man.edquota.8;.
        Si se usa &man.edquota.8; se entra en el el editor declarado en
        la variable de entorno
        <envar>EDITOR</envar>, o en el editor <application>vi</application>
        si no ha modificado el valor por defecto de la variable
        <envar>EDITOR</envar>, para que pueda editar los
        límites de cuota.</para>

      <screen>&prompt.root; <userinput>edquota -u test</userinput></screen>

      <programlisting>Quotas for user test:
/usr: kbytes in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)</programlisting>

      <para>Debería ver dos líneas por cada sistema
        de ficheros que tenga habilitadas las cuotas.  Una línea
        para los límites de bloque y una línea para
        límites de inodo. Por ejemplo, para elevar los límites
        de este usuario de un límite suave de 50 y un límite
        duro de 75 a un límite suave de 500 y un límite
        duro de 600, cambie:</para>

      <programlisting>/usr: kbytes in use: 65, limits (soft = 50, hard = 75)</programlisting>

      <para>por:</para>

      <programlisting>/usr: kbytes in use: 65, limits (soft = 500, hard = 600)</programlisting>

      <para>Los nuevos límites de cuota se aplicarán en
        cuanto salga del editor.</para>

      <para>Algunas veces se quieren activar límites de cuota
        en un rango de UIDs. Esto puede realizarse con la opción
        <option>-p</option> de &man.edquota.8;. Primero asigne el
        límite de cuota deseado a un usuario y luego
        ejecute
        <command>edquota -p protouser startuid-enduid</command>.  Por
        ejemplo, si el usuario <systemitem class="username">test</systemitem> tiene el
        límite de cuota deseado, el siguiente comando puede
        usarse para duplicar esos límites de cuota para los
        UIDs de 10,000 hasta 19,999:</para>

      <screen>&prompt.root; <userinput>edquota -p test 10000-19999</userinput></screen>

      <para>Para más información consulte la página de
        manual &man.edquota.8;.</para>
    </sect2>

    <sect2>
      <title>Revisión de los límites de cuota y
        uso de disco</title>
      <indexterm>
        <primary>cuotas de disco</primary>
        <secondary>revisando</secondary>
      </indexterm>

      <para>Puede usar &man.quota.1; o
        &man.repquota.8; para revisar los límites de
        cuota y uso del disco.  El comando &man.quota.1;
        le permitirá revisar cuotas individuales de
        usuario o grupo y uso del disco.  Un usuario puede
        sólamente examinar su propia cuota y la cuota de un
        grupo al que pertenezca.  Sólamente el superusuario
        puede ver las cuotas de todos los usuarios y grupos.
        &man.repquota.8; permite obtener
        un resumen de todas las cuotas y uso del disco de todos los
        sistemas de ficheros con cuotas habilitadas.</para>

      <para>En el siguiente ejemplo vemos la salida de
        <command>quota -v</command> para un usuario
        que tiene límites de cuota en dos sistemas
        de ficheros.</para>

      <programlisting>Disk quotas for user test (uid 1002):
     Filesystem  usage    quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</programlisting>

      <indexterm><primary>periodo de gracia</primary></indexterm>
      <para>En el sistema de ficheros <filename>/usr</filename> del
        ejemplo este usuario está actualmente
        15 kbytes sobre su límite suave de 50 kbytes y le quedan 5
        días de su periodo de gracia.  Observe el asterisco,
        <literal>*</literal> que indica que el usuario está
        actualmente por encima de su límite de cuota.</para>

      <para>Normalmente los sistemas de ficheros en los que el usuario
        no esté utilizando espacio en disco no se mostrarán
        en la salida del comando &man.quota.1;, incluso si tiene
        un límite de cuota asignado para esos sistemas
        de fichero.  La opción <option>-v</option>
        desplegará esos sistemas de ficheros, en nuestro ejemplo
        el sistema de ficheros <filename>/usr/var</filename>.</para>
    </sect2>

    <sect2>
      <title>Cuotas en NFS</title>
      <indexterm><primary>NFS</primary></indexterm>

      <para>Las cuotas son impuestas por el subsistema de cuotas en el
        servidor NFS.  El d&aelig;mon &man.rpc.rquotad.8; facilita la
        información a &man.quota.1; en los clientes
        NFS, permitiéndoles a los usuarios de esas máquinas
        ver sus estadísticas de cuota.</para>

      <para>Habilite  <command>rpc.rquotad</command> en
	<filename>/etc/inetd.conf</filename> del siguiente modo:</para>

      <programlisting>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</programlisting>

      <para>Y reinicie <command>inetd</command>:</para>

      <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/inetd.pid`</userinput></screen>
    </sect2>
  </sect1>


  <sect1 xml:id="disks-encrypting">
    <info><title>Cifrado de particiones de disco</title>
      <authorgroup>
	<author><personname><firstname>Lucky</firstname><surname>Green</surname></personname><contrib>Escrito por </contrib><affiliation>
	    <address><email>shamrock@cypherpunks.to</email></address>
	  </affiliation></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>discos</primary>
      <secondary>cifrado</secondary></indexterm>

    <para>&os; ofrece un alto grado de protección
      contra el acceso no autorizado a los datos.  Los Permisos de fichero
      y MAC (Mandatory Access Control, controles de acceso obligatorio,
      consulte el <xref linkend="mac"/>) ayudan a evitar que otros
      tengan acceso no autorizado a los datos mientras el sistema
      operativo está funcionando y la computadora está
      encendida.  Sin embargo los permisos impuestos por el
      sistema operativo son irrelevantes si un atacante tiene acceso
      físico al sistema y puede simplemente mover el disco
      duro de la computadora a otro sistema para copiar
      y analizar datos sensibles.</para>

    <para>Independientemente de cómo un atacante pueda
      conseguir acceso a un disco duro a a un sistema apagado,
      <application>el cifrado de disco basado en GEOM
      (GEOM Based Disk Encryption, gbde)</application> puede proteger
      los datos de los sistemas de ficheros del sistema incluso
      contra atacantes muy decididos y con recursos adecuados a
      su disposición.   A diferencia de otros métodos de
      cifrado más difíciles de usar, que cifran
      únicamente ficheos individuales,
      <application>gbde</application> cifra sistemas de ficheros
      completos de forma transparente.  Ni un solo texto en limpio
      llega a tocar el disco duro.</para>

    <sect2>
      <title>Habilitar gbde en el kernel</title>

      <procedure>
	<step>
	  <title>Conviértase en <systemitem class="username">root</systemitem></title>

          <para>La configuración de <application>gbde</application>
            requiere privilegios de superusuario.</para>

	  <screen>&prompt.user; <userinput>su -</userinput>
Password:</screen>
	</step>

	<step>
          <title>Verifique la versión del sistema operativo</title>

	  <para>&man.gbde.4; requiere FreeBSD 5.0 o posterior.</para>

	  <screen>&prompt.root; <userinput>uname -r</userinput>
5.0-RELEASE</screen>
	</step>

	<step>
          <title>Añada soporte de &man.gbde.4; al fichero de
            configuración de su kernel</title>

          <para>Añada la siguiente línea al fichero de
            configuración de su kernel con el editor que
            prefiera:</para>

	  <para><literal>options GEOM_BDE</literal></para>

          <para>Configure, recompile e instale el kernel de &os;.
            Este proceso se detalla en el
            <xref linkend="kernelconfig"/>.</para>

	  <para>Reinicie con el nuevo kernel.</para>
	</step>
      </procedure>
    </sect2>


    <sect2>
      <title>Preparación del disco duro cifrado</title>

      <para>El siguiente ejemplo asume que añade a su sistema
        un disco duro nuevo que contendrá una sola
        partición cifrada.  Esta partición se
        montará como <filename>/private</filename>.
        <application>gbde</application> puede usarse también
        para cifrar <filename>/home</filename> y
        <filename>/var/mail</filename>,
        pero esto requeriría instrucciones más complejas que
        las que se pretenden dar en esta introducción.</para>

      <procedure>
	<step>
	  <title>Añada el nuevo disco</title>

          <para>Instale el nuevo disco en el sistema como se explicó
            en la <xref linkend="disks-adding"/>.  En nuestro ejemplo hemos
            añadido una nueva partición de disco como
            <filename>/dev/ad4s1c</filename>.  Los dispositivos
            <filename>/dev/ad0s1*</filename>
            representan particiones &os; estándar que i
            existían previamente en el sistema.</para>

	  <screen>&prompt.root; <userinput>ls /dev/ad*</userinput>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4</screen>
	</step>

	<step>
          <title>Crée un directorio para los ficheros
            <quote>lock</quote> de gbde</title>

	  <screen>&prompt.root; <userinput>mkdir /etc/gbde</userinput></screen>

          <para>Los ficheros <quote>lock</quote> de
            <application>gbde</application>
            contienen información que <application>gbde</application>
            requiere para acceder a las particiones cifradas.   Sin el
            acceso a los ficheros <quote>lock</quote>
            <application>gbde</application> no podrá descifrar los
            datos alojados en la partición cifrada sin una cantidad
            significativa de trabajo, tarea para la que además
            no le resultará de ayuda este software.  Cada
            partición cifrada utiliza un fichero
            <quote>lock</quote> separado.</para>
	</step>

	<step>
	  <title>Inicialice la partición gbde</title>

          <para>Una partición <application>gbde</application>
            debe inicializarse antes de que pueda utilizarse.
            Esta inicialización sólo debe hacerse
            una vez:</para>

	  <screen>&prompt.root; <userinput>gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c</userinput></screen>

          <para>&man.gbde.8; abrirá su editor para que pueda
            configurar las opciones de configuración que se
            le presentarán en una plantilla.
            Para utilizar UFS1 o UFS2, ponga el sector_size a 2048:</para>

	  <programlisting>$<!-- This is not the space you are looking
for-->FreeBSD: src/sbin/gbde/template.txt,v 1.1 2002/10/20 11:16:13 phk Exp $
#
# El tamaño de sector (sector size) es la unidad de datos más
# pequeña que podrá leer o escribir.  Si la elige demasiado
# pequeña reducirá el rendimiento y la cantidad de espacio
# útil.  Si la elige demasiado grande puede hacer que los sistemas
# de ficheros no funcionen.  512 es el tamaño mínimo y
# siempre funciona.  Si va a usar UFS utilice
#
sector_size     =       2048
[...]
</programlisting>

          <para>&man.gbde.8; le pedirá dos veces que escriba la
            contraseña que debe usarse para asegurar los datos.
            La contraseña debe ser la misma las dos veces.  La
            capacidad de <application>gbde</application> de proteger sus
            datos depende íntegramente de la calidad de la
            contraseña que elija.
	  <footnote>
          <para>Si quiere ayuda para seleccionar una contraseña
            segura que además sea fácil de recordar visite
            el sitio web
            <link xlink:href="http://world.std.com/~reinhold/diceware.html">Diceware
            Passphrase</link>.</para></footnote></para>

          <para>El fichero <command>gbde init</command> crea un fichero
            <quote>lock</quote> para su partición
            <application>gbde</application>, que en nuestro ejemplo
            está en
	    <filename>/etc/gbde/ad4s1c</filename>.</para>

	  <caution>
            <para>Es imprescindible que los ficheros <quote>lock</quote>
              de <application>gbde</application>
              <emphasis>deben</emphasis> respaldarse junto con
              el contenido de cualquier partición cifrada.
              Aunque la sola acció de borrar
              un fichero <quote>lock</quote> no puede evitar que un atacante
              motivado descifre una partición
              <application>gbde</application> sin el fichero
              <quote>lock</quote>, el propietario legítimo
              no podrá acceder a los datos en la partición
              cifrada sin una cantidad notable de trabajo, que es
              necesario señalar que no entra dentro de las funciones
              de &man.gbde.8; ni de su diseñador.</para>
	  </caution>
	</step>

	<step>
          <title>Conecte al kernel la partición cifrada</title>

	  <screen>&prompt.root; <userinput>gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c</userinput></screen>

          <para>Se le pedirá la contraseña que elijió
            al inicializar la partición cifrada.  El
            nuevo dispositivo cifrado aparecerá en
            <filename>/dev</filename> como
	    <filename>/dev/nombre_de_dispositivo.bde</filename>:</para>

	  <screen>&prompt.root; <userinput>ls /dev/ad*</userinput>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde</screen>
	</step>

	<step>
          <title>Crée un sistema de ficheros en el dispositivo
            cifrado</title>

          <para>Una vez el dispositivo cifrado está conectado
            al kernel puede crear un sistema de ficheros en el
            dispositivo con &man.newfs.8;.  Dado que es más
            rápido inicializar un sistema de ficheros del
            nuevo UFS2 que un sistema de ficheros del tradicional
            UFS1, le recomendamos encarecidamente usar
            &man.newfs.8; con la opción
            <option>-O2</option>.</para>

          <note><para>La opción <option>-O2</option> es el
            valor por defecto en &os;&nbsp;5.1-RELEASE
            y siguientes.</para></note>

	  <screen>&prompt.root; <userinput>newfs -U -O2 /dev/ad4s1c.bde</userinput></screen>

	  <note>
            <para>&man.newfs.8; debe ejecutarse en una
              partición <application>gbde</application>
              conectada, que podrá identificar por la extensión
	      <filename>*.bde</filename>
              del nombre del dispositivo.</para>
	  </note>
	</step>

	<step>
          <title>Montar la partición cifrada</title>

          <para>Crée un punto de montaje para el sistema cifrado
            de ficheros.</para>

	  <screen>&prompt.root; <userinput>mkdir /private</userinput></screen>

          <para>Montar el sistema cifrado de ficheros.</para>

	  <screen>&prompt.root; <userinput>mount /dev/ad4s1c.bde /private</userinput></screen>
	</step>

	<step>
          <title>Verificar que el sistema cifrado de ficheros esté
            disponible</title>

          <para>el sistema cifrado de ficheros debería ser visible
            para &man.df.1; y estar listo para su uso.</para>

	  <screen>&prompt.user; <userinput>df -H</userinput>
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private</screen>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title>Montaje de sistemas cifrados de ficheros</title>

      <para>Todos los sistemas cifrados de ficheros deben reconectarse al
        kernel después de cada arranque.  Además, antes de
        poder utilizarlo debe revisarlo por si contuviera errores y montarlo.
        Todo el proceso debe ser ejecutado por el usuario
        <systemitem class="username">root</systemitem>.</para>

      <procedure>
	<step>
          <title>Conectar la partición gbde al kernel</title>

	  <screen>&prompt.root; <userinput>gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c</userinput></screen>

          <para>Se le pedirá la contraseña que
            elijió en la inicialización
            de la partición cifrada gbde.</para>
	</step>

	<step>
          <title>Revisión de errores en el sistema de ficheros</title>

          <para>Como que los sistemas cifrados de ficheros no pueden
            aparecer en <filename>/etc/fstab</filename> (lo que haría
            que fueran montados automáticamente), los sistemas
            de ficheros deben revisarse manualmente mediante &man.fsck.8;
            antes de montarlos.</para>

	  <screen>&prompt.root; <userinput>fsck -p -t ffs /dev/ad4s1c.bde</userinput></screen>
	</step>

	<step>
          <title>Montar los sistemas cifrados de ficheros</title>

	  <screen>&prompt.root; <userinput>mount /dev/ad4s1c.bde /private</userinput></screen>

          <para>El sistema cifrado de ficheros está listo para su
            uso.</para>
	</step>
      </procedure>

      <sect3>
        <title>Montar automáticamente particiones cifradas</title>

        <para>Es posible usar un <quote>script</quote> para automatizar
          la conexión, revisión y el montaje de una
          partición cifrada, pero por razones de seguridad el
          <quote>script</quote> no debe contener la
          contraseña de &man.gbde.8;.  Se recomienda
          ejecutar esos <quote>scripts</quote> se ejecuten de forma manual
          proporcionando la contraseña vía consola o
          &man.ssh.1;.</para>
      </sect3>
    </sect2>

      <sect2>
        <title>Protección criptográfica que usa gbde</title>

        <para>&man.gbde.8; cifra el XXX sector payload usando AES de 128 bits
          en modo CBC.  Cada sector en el disco se cifra con una clave
          AES diferente.  Para más información sobre el
          diseño criptográfico de
          <application>gbde</application>, incluyendo cómo se
          derivan las claves de sector a partir de la contraseña
          consulte &man.gbde.4;.</para>
      </sect2>

      <sect2>
        <title>Problemas de compatibilidad</title>

        <para>&man.sysinstall.8; es incompatible con dispositivos
          <application>gbde</application> cifrados.  Todos los
          dispositivos <filename>*.bde</filename>
          deben desconectarse del kernel antes de iniciar
          &man.sysinstall.8; o se <quote>congelará</quote> durante
          la prueba inicial de dispositivos.  Para desconectar el
          el dispositivo cifrado de nuestro ejemplo haga lo siguiente:
          </para>

	<screen>&prompt.root; <userinput>gbde detach /dev/ad4s1c</userinput></screen>

      <para>Tenga en cuenta también que, como &man.vinum.4; no
        utiliza el subsistema &man.geom.4;, no es posible usar
        <application>gbde</application> en volúmenes
	<application>vinum</application>.</para>
      </sect2>

  </sect1>
</chapter>
