<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project

     The FreeBSD Spanish Documentation Project
     %SOURCE% en_US.ISO8859-1/books/handbook/users/chapter.xml
     %SRCID%    0.0

     $FreeBSD$
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="users">
  <info><title>Usuarios y administración básica de cuentas</title>
    <authorgroup>
      <author><personname><firstname>Neil</firstname><surname>Blakey-Milner</surname></personname><contrib>Contributed by </contrib></author>
    </authorgroup>
    
  </info>

  

  <sect1 xml:id="users-synopsis">
    <title>Sinopsis</title>

    <para>FreeBSD permite que varios usuarios usen el mismo ordenador.
      Obviamente, sólo uno de estos usuarios puede sentarse frente al
      monitor y al teclado en un momento dado
      <footnote>
        <para>Bueno, a menos que conectes múltiples terminales, pero
          dejaremos ese tema para el <xref linkend="serialcomms"/>.</para>
      </footnote>
      , pero cualquier número de usuarios puede entrar por la red para
      hacer su trabajo.  Para usar el sistema cada usuario ha de tener
      una cuenta.</para>

    <para>Después de leer este capítulo sabrás:</para>

    <itemizedlist>
      <listitem>
        <para>Cuáles son las diferencias entre las distintas cuentas de
          usuario en sistemas FreeBSD.</para>
      </listitem>

      <listitem>
        <para>Cómo añadir cuentas.</para>
      </listitem>

      <listitem>
        <para>Cómo eliminar cuentas.</para>
      </listitem>

      <listitem>
        <para>Cómo cambiar detalles de las cuentas, como el nombre
          completo del usuario, o su shell preferida.</para>
      </listitem>

      <listitem>
        <para>Cómo establecer límites por cuenta, para controlar los
          recursos como memoria o tiempo de CPU que las cuentas y grupos
          de cuentas pueden emplear.</para>
      </listitem>

      <listitem>
        <para>Cómo usar grupos para facilitar la administración de
          cuentas.</para>
      </listitem>
    </itemizedlist>

    <para>Antes de leer este capítulo deberías:</para>

    <itemizedlist>
      <listitem>
        <para>Entender los conceptos básicos de Unix y FreeBSD (<xref linkend="basics"/>).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="users-introduction">
    <title>Introducción</title>

    <para>Todos los accesos al sistema se consiguen vía cuentas, y todos
      los procesos son ejecutados por usuarios, por ello la
      administración de usuarios y cuentas es de una gran importancia
      en sistemas FreeBSD.</para>

    <para>Cada cuenta en un sistema FreeBSD tiene cierta información
      asociada que la identifica.</para>

    <variablelist>
      <varlistentry>
        <term>Nombre de usuario</term>

        <listitem>
          <para>El nombre de usuario como se le entraría al prompt
            <prompt>login:</prompt>.  Los nombres de usuario han de ser
            únicos en la computadora; no puede haber dos usuarios con el
            mismo nombre de usuario.  Existen algunas reglas para la
            creación de nombres de usuario válidos documentadas en
            &man.passwd.5;; típicamente se usarían nombres de usuario de
            a lo sumo ocho caracteres, todos ellos en minúscula.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Contraseña</term>

        <listitem>
          <para>Cada cuenta tiene una contraseña asociada.  La
            contraseña puede ser vacía, en cuyo caso no se requerirá
            ninguna para acceder al sistema.  Esto normalmente es una
            mala idea; cada cuenta debería tener una constraseña no
            vacía.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Identificador de usuario (UID)</term>

        <listitem>
          <para>El UID es un numero entre 0 y 65536 que sirve para
            identificar unívocamente al usuario en el sistema.
            Internamente, FreeBSD usa el UID para identificar usuarios y
            cualquier comando de FreeBSD que permita especificar un
            nombre de usuario convertirá éste al UID antes de trabajar
            con él.  Esto significa que puedes tener varias cuentas con
            nombres de usuario distintos pero con el mismo UID.  En lo
            que a FreeBSD respecta, tales cuentas son un solo usuario.
            Es improbable que alguna vez tengas que hacer algo
            así.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Identificador de grupo (GID)</term>

        <listitem>
          <para>El GID es un número entre 0 y 65536 que sirve para
            identificar unívocamente el grupo principal al cual
            pertenece un usuario.  Los grupos son un mecanismo para
            controlar el acceso a recursos del sistema en base al GID,
            en vez del UID.  Esto puede reducir significativamente el
            tamaño de algunos ficheros de configuración.  Un usuario
            puede pertencer a más de un grupo.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Clase de login</term>

        <listitem>
          <para>Las clases de login son una extensión al mecanismo de
            grupos que ofrecen una mayor flexibilidad a la hora de
            adaptar el sistema a distintos usuarios.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Tiempo de cambio de contraseña</term>

        <listitem>
          <para>Por defecto FreeBSD no obliga a los usuarios a cambiar
            su contraseña periódicamente.  Se puede requerir esto a
            determinados usuarios, haciendo que algunos o todos deban
            cambiar sus contraseñas al cabo de cierto periodo de
            tiempo.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Tiempo de expiración de cuentas</term>

        <listitem>
          <para>Por defecto las cuentas en FreeBSD no expiran.  Si estás
            creando cuentas que sabes que van a tener un tiempo limitado
            de vida, por ejemplo, las cuentas de los estudiantes de una
            escuela, entonces puedes especificar cuándo expiran.  Una
            vez vencido su tiempo de expiración una cuenta no puede ser
            usada para entrar en el sistema, si bien sus directorios y
            archivos serán conservados.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Nombre completo de usuario</term>

        <listitem>
          <para>El nombre de usuario identifica unívocamente a una
            cuenta para FreeBSD, pero no refleja su verdadero nombre
            necesariamente.  Esta información puede ser asociada a la
            cuenta. </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Directorio home</term>

        <listitem>
          <para>El directorio home es el camino completo de un
            directorio en el sistema en el que el usuario se hallará
            cuando entre.  Una convención usual consiste en poner todos
            los directorios home en
            <filename>/home/nombre_de_usuario</filename>
            o en
            <filename>/usr/home/nombre_de_usuario</filename>.
            Los usuarios guardarían sus archivos personales en sus
            directorios home, y en cualquier directorio que creasen
            allí.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Shell de usuario</term>

        <listitem>
          <para>La shell provee el entorno por defecto mediante el cual
            los usuarios interactúan con el sistema.  Existen varios
            tipos de shell y los usuarios experimentados tendrán sus
            propias preferencias, que pueden expresarse en la
            configuración de su cuenta.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Existen principalmente tres tipos de cuentas; la cuenta de
      <link linkend="users-superuser">superusuario</link>, las cuentas
      de <link linkend="users-system">usuarios del sistema</link>, y las
      de <link linkend="users-user">usuarios</link>.  La cuenta de
      superusuario, normalmente llamada <systemitem class="username">root</systemitem>, se
      usa para administrar el sistema sin limitaciones en los
      privilegios.  Los usuarios del sistema utilizan servicios del
      mismo.  Finalmente, las cuentas de usuarios son usadas por gente
      real, aquellos que entran, leen correo, etcétera.</para>
  </sect1>

  <sect1 xml:id="users-superuser">
    <title>La cuenta superusuario</title>

    <indexterm>
      <primary>cuentas</primary>
      <secondary>superusuario (root)</secondary>
    </indexterm>
    <para>La cuenta superusuario, normalmente llamada
      <systemitem class="username">root</systemitem>, viene preconfigurada para facilitar la
      administración del sistema, y no debería ser utilizada para tareas
      cotidianas como enviar o recibir correo, exploración general del
      sistema, o programación.</para>

    <para>Esto es así porque el superusuario, a diferencia de las
      cuentas de usuario, puede operar sin límites, y un mal uso de la
      cuenta de superusuario puede conllevar desastres espectaculares.
      Las cuentas de usuario no pueden destruir el sistema por un error,
      por ello es generalmente mejor utilizar cuentas de usuario
      normales cuando sea posible, a no ser que especialmente necesites
      privilegios extra.</para>

    <para>Deberías comprobar siempre un par o tres de veces los comandos
      que ejecutas como superusuario, ya que un espacio de más o un
      carácter omitido pueden significar una pérdida de datos
      irreparable.</para>

    <para>Así pues, lo primero que deberías hacer después de leer este
      capítulo es crear una cuenta sin privilegios de uso general para
      ti si aún no la tienes.  Esto aplica tanto si trabajas en una
      máquina con varios usuarios como si trabajas en una máquina con un
      solo usuario.  Más adelante, en este mismo capítulo, explicamos
      cómo crear cuentas adicionales, y cómo cambiar de usuario normal a
      superusuario.</para>
  </sect1>

  <sect1 xml:id="users-system">
    <title>Cuentas de sistema</title>

    <indexterm>
      <primary>cuentas</primary>
      <secondary>sistema</secondary>
    </indexterm>
    <para>Los usuarios de sistema son aquéllos que corren servicios como
      DNS, correo, servidores web, etc.  Esto es así por seguridad; si
      todos los servicios corrieran como superusuario podrían actuar sin
      ninguna restricción.</para>

    <indexterm>
      <primary>cuentas</primary>
      <secondary><systemitem class="username">daemon</systemitem></secondary>
    </indexterm>
    <indexterm>
      <primary>cuentas</primary>
      <secondary><systemitem class="username">operator</systemitem></secondary>
    </indexterm>
    <para>Algunos ejemplos de usuarios de sistema son
      <systemitem class="username">daemon</systemitem>, <systemitem class="username">operator</systemitem>,
      <systemitem class="username">bind</systemitem> (para el DNS), y
      <systemitem class="username">news</systemitem>.  Con frecuencia, los administradores de
      sistemas crean el usuario <systemitem class="username">httpd</systemitem> para que
      ejecute los servidores web que instalan.</para>

    <indexterm>
      <primary>cuentas</primary>
      <secondary><systemitem class="username">nobody</systemitem></secondary>
    </indexterm>
    <para><systemitem class="username">nobody</systemitem> es el usuario de sistema sin
      privelegios genérico.  No obstante, es importante tener en cuenta
      que cuantos más servicios use <systemitem class="username">nobody</systemitem>, más
      ficheros y procesos estarán asociados con dicho usuario, y en
      consecuencia más privilegiado será.</para>
  </sect1>

  <sect1 xml:id="users-user">
    <title>Cuentas de usuario</title>

    <indexterm>
      <primary>cuentas</primary>
      <secondary>usuario</secondary>
    </indexterm>
    <para>Las cuentas de usuario constituyen la principal vía de acceso
      al sistema para la gente real.  Estas cuentas aíslan al usuario
      del entorno, impidiendo que pueda dañar al sistema o a otros
      usuarios, y permitiendo a su vez que pueda personalizar su entorno
      sin que esto afecte a otros.</para>

    <para>Cada persona que acceda a tu sistema debería tener una sola
      cuenta de usuario.  Esto te permite averiguar quién está haciendo
      qué, evita que interfieran las configuraciones de distintos
      usuarios, que unos puedan leer el correo de otros,
      etcétera.</para>

    <para>Cada usuario puede configurar su entorno para acomodarlo al
      uso que hace del sistema, utilizando shells, editores, atajos de
      teclado e idioma alternativos.</para>
  </sect1>

  <sect1 xml:id="users-modifying">
    <title>Modificación de cuentas</title>

    <indexterm>
      <primary>cuentas</primary>
      <secondary>modificar</secondary>
    </indexterm>

    <para>Existe una variedad de comandos disponible en el entorno Unix
      para modificar cuentas de usuario.  Los comandos más comunes se
      hallan resumidos a continuación, seguidos de ejemplos más
      detallados de su uso.</para>

    <informaltable>
      <tgroup cols="2">
    <thead>
      <row>
        <entry>Comando</entry>
        <entry>Resumen</entry>
      </row>
    </thead>
    <tbody>
      <row>
        <entry><command>adduser</command></entry>
        <entry>La aplicación de línea de comandos recomendada para
          añadir nuevos usuarios.</entry>
      </row>
      <row>
        <entry><command>rmuser</command></entry>
        <entry>La aplicación de línea de comandos recomendada para
          eliminar usuarios.</entry>
      </row>
      <row>
        <entry><command>chpass</command></entry>
        <entry>Una herramienta flexible para modificar la base de datos
          de usuarios.</entry>
      </row>
      <row>
        <entry><command>passwd</command></entry>
        <entry>Una herramienta de línea de comandos simple para cambiar
          contraseñas de usuario.</entry>
      </row>
      <row>
        <entry><command>pw</command></entry>
        <entry>Una herramienta potente y flexible para modificar
          cualquier aspecto de las cuentas de usuario.</entry>
      </row>
    </tbody>
      </tgroup>
    </informaltable>

    <sect2 xml:id="users-adduser">
      <title>adduser</title>

      <indexterm>
        <primary>cuentas</primary>
        <secondary>añadir</secondary>
      </indexterm>
      <indexterm>
        <primary><command>adduser</command></primary>
      </indexterm>
      <indexterm>
        <primary><filename>/usr/share/skel</filename></primary>
      </indexterm>
      <indexterm><primary>directorio esqueleto</primary></indexterm>
      <para><command>adduser</command> es un programa simple para añadir
        usuarios.  Crea entradas en los archivos de sistema
        <filename>passwd</filename> y <filename>group</filename>.
        También crea un directorio home para el nuevo usuario, copia
        allí ficheros de configuración por defecto
        (<quote>dotfiles</quote>) de
        <filename>/usr/share/skel</filename>, y opcionalmente puede
        enviar al usuario un mensaje de bienvenida.</para>

      <para>Para crear el fichero inicial de configuración usa
        <command>adduser -s -config_create</command>.
        <footnote>
          <para>La <option>-s</option> hace que <command>adduser</command>
            sea silencioso por defecto.  Más tarde usamos <option>-v</option>
            cuando queremos cambiar valores por defecto.</para>
        </footnote>
        A continuación configuramos valores por defecto para
        <application>adduser</application> y creamos nuestra primera
        cuenta de usuario, dado que utilizar <systemitem class="username">root</systemitem>
        para uso normal del sistema es pernicioso y peligroso.</para>

      <example>
        <title>Configuración de adduser</title>

        <screen>&prompt.root; <userinput>adduser -v</userinput>
Use option ``-silent'' if you don't want to see all warnings and questions.
Check /etc/shells
Check /etc/master.passwd
Check /etc/group
Enter your default shell: csh date no sh tcsh zsh [sh]: <userinput>zsh</userinput>
Your default shell is: zsh -&gt; /usr/local/bin/zsh
Enter your default HOME partition: [/home]:
Copy dotfiles from: /usr/share/skel no [/usr/share/skel]:
Send message from file: /etc/adduser.message no
[/etc/adduser.message]: <userinput>no</userinput>
Do not send message
Use passwords (y/n) [y]: <userinput>y</userinput>

Write your changes to /etc/adduser.conf? (y/n) [n]: <userinput>y</userinput>

Ok, let's go.
Don't worry about mistakes. I will give you the chance later to correct any input.
Enter username [a-z0-9_-]: <userinput>jru</userinput>
Enter full name []: <userinput>J. Random User</userinput>
Enter shell csh date no sh tcsh zsh [zsh]:
Enter home directory (full path) [/home/jru]:
Uid [1001]:
Enter login class: default []:
Login group jru [jru]:
Login group is ``jru''. Invite jru into other groups: guest no
[no]: <userinput>wheel</userinput>
Enter password []:
Enter password again []:

Name:     jru
Password: ****
Fullname: J. Random User
Uid:      1001
Gid:      1001 (jru)
Class:
Groups:   jru wheel
HOME:     /home/jru
Shell:    /usr/local/bin/zsh
OK? (y/n) [y]: <userinput>y</userinput>
Added user ``jru''
Copy files from /usr/share/skel to /home/jru
Add another user? (y/n) [y]: <userinput>n</userinput>
Goodbye!
&prompt.root;</screen>
      </example>

      <para>En resumen, cambiamos la shell por defecto a
        <application>zsh</application> (una shell alternativa incluida
        en la colección de ports), y deshabilitamos el envío de un
        mensaje de bienvenida a nuevos usuarios.  Luego grabamos la
        configuración, creamos una cuenta para <systemitem class="username">jru</systemitem>,
        y nos aseguramos de que <systemitem class="username">jru</systemitem> esté en el
        grupo <systemitem class="username">wheel</systemitem> (de modo que puede asumir el
        papel de <systemitem class="username">root</systemitem> vía el comando
        <command>su</command>).</para>

      <note>
        <para>La contraseña que escribes no se muestra, tampoco se
          muestran asteriscos.  Asegúrate de no entrar dos veces una
          contraseña equivocada.</para>
      </note>

      <note>
        <para>Usa <command>adduser</command> sin argumentos en adelante,
          no necesitarás cambiar las opciones por defecto.  Si el
          programa te pide modificarlas sal y prueba con la opción
          <option>-s</option>.</para>
      </note>
    </sect2>

    <sect2 xml:id="users-rmuser">
      <title><application>rmuser</application></title>

      <indexterm><primary><command>rmuser</command></primary></indexterm>
      <indexterm>
        <primary>cuentas</primary>
        <secondary>eliminar</secondary>
      </indexterm>

      <para>Puedes usar <command>rmuser</command> para eliminar
        completamente del sistema a un usuario.
        <command>rmuser</command> efectúa los siguientes pasos:</para>

      <procedure>
        <step>
          <para>Elimina la entrada del usuario en &man.crontab.1; (si
            tiene alguna).</para>
        </step>
        <step>
          <para>Elimina las tareas &man.at.1; pertenecientes al
            usuario.</para>
        </step>
        <step>
          <para>Mata todos los procesos pertenecientes al
            usuario.</para>
        </step>
        <step>
          <para>Elimina al usuario del fichero local de contraseñas del
            sistema.</para>
        </step>
        <step>
          <para>Borra el directorio home del usuario (si le
            pertenece).</para>
        </step>
        <step>
          <para>Elimina los archivos de correo entrante del usuario de
            <filename>/var/mail</filename>.</para>
        </step>
        <step>
          <para>Borra todos los ficheros del usuario de áreas en las que
            se guardan archivos temporales como
            <filename>/tmp</filename>.</para>
        </step>
        <step>
          <para>Finalmente, elimina el nombre de usuario de todos
            aquellos grupos a los que pertenece en
            <filename>/etc/group</filename>.

            <note>
              <para>Si un grupo queda vacío y el nombre del grupo
                coincide con el del usuario, el grupo es eliminado; esto
                complementa la creación de grupos por usuario de
                &man.adduser.8;.</para>
            </note>
          </para>
        </step>
      </procedure>

      <para><command>rmuser</command> no puede ser usado para eliminar
        cuentas de superusuario, dado que algo así es casi siempre señal
        de masiva destrucción.</para>

      <para>Por defecto existe un modo interactivo que intenta asegurar
        que uno sabe lo que hace.</para>

      <example>
        <title>Eliminación interactiva de cuenta con rmuser</title>

        <screen>&prompt.root; <userinput>rmuser jru</userinput>
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/tcsh
Is this the entry you wish to remove? <userinput>y</userinput>
Remove user's home directory (/home/jru)? <userinput>y</userinput>
Updating password file, updating databases, done.
Updating group file: trusted (removing group jru -- personal group is empty) done.
Removing user's incoming mail file /var/mail/jru: done.
Removing files belonging to jru from /tmp: done.
Removing files belonging to jru from /var/tmp: done.
Removing files belonging to jru from /var/tmp/vi.recover: done.
&prompt.root;</screen>
      </example>
    </sect2>

    <sect2 xml:id="users-chpass">
      <title><application>chpass</application></title>

      <indexterm><primary><command>chpass</command></primary></indexterm>
      <para><command>chpass</command> cambia información de los usuarios
        en base de datos como contraseñas, shells y datos
        personales.</para>

      <para>Los administradores del sistema, como el superusuario, son
        los únicos que pueden modificar la información y contraseñas de
        otros usuarios con <command>chpass</command>.</para>

      <para>Cuando no le pasamos más opciones, salvo un nombre de
        usuario opcional, <command>chpass</command> muestra un editor
        con información de usuario.  Cuando se sale del editor la base
        de datos de usuarios se actualiza con la nueva
        información.</para>

      <example>
        <title>chpass interactivo ejecutado por el superusuario</title>

        <screen>#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1000
Gid [# or name]: 1000
Change [month day year]:

Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/tcsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <para>Un usuario normal puede modificar un pequeño subconjunto de
        esta información, y sólo para sí mismo.</para>

      <example>
        <title>chpass interactivo ejecutado por un usuario normal</title>

      <screen>#Changing user database information for jru.
Shell: /usr/local/bin/tcsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <note>
        <para><command>chfn</command> y <command>chsh</command> son
          enlaces a <command>chpass</command>, como también lo son
          <command>ypchpass</command>, <command>ypchfn</command>, e
          <command>ypchsh</command>.  El soporte para NIS es automático,
          por lo que no es necesario especificar el
          <literal>yp</literal> antes del comando.  Si esto te resulta
          algo confuso no te preocupes, NIS será tratado en el <xref linkend="advanced-networking"/>.</para>
      </note>
    </sect2>

    <sect2 xml:id="users-passwd">
      <title>passwd</title>

      <indexterm><primary><command>passwd</command></primary></indexterm>
      <indexterm>
        <primary>cuentas</primary>
        <secondary>cambiar contraseña</secondary>
      </indexterm>
      <para><command>passwd</command> es el comando que se usa
        normalmente para cambiar tu propia contraseña como usuario o,
        como superusuario, la de otros usuarios.</para>

      <note>
        <para>Los usuarios han de introducir su contraseña original
          antes de cambiarla para prevenir que gente no autorizada pueda
          hacerlo cuando no se encuentren en la consola.</para>
      </note>

      <example>
        <title>Cambio de tu contraseña</title>

        <screen>&prompt.user; <userinput>passwd</userinput>
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <example>
        <title>Cambio de la contraseña de otro usuario como superusuario</title>

        <screen>&prompt.root; <userinput>passwd jru</userinput>
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <note>
        <para>Como ocurre con <command>chpass</command>,
          <command>yppasswd</command> es un enlace a
          <command>passwd</command>, de manera que NIS funciona con
          ambos comandos.</para>
      </note>
    </sect2>

    <sect2 xml:id="users-pw">
      <title><application>pw</application></title>
      <indexterm><primary><command>pw</command></primary></indexterm>

      <para>&man.pw.8; es una utilidad de línea de comandos para crear,
        eliminar, modificar, y mostrar usuarios y grupos.  Hace de
        interfaz a los archivos del sistema de usuarios y grupos.
        <command>pw</command> tiene un conjunto de opciones de línea de
        comandos bastante potente que lo hacen adecuado para su uso en
        scripts de shell, aunque los nuevos usuarios puede que lo
        encuentren algo más complicado que el resto de comandos que
        presentamos aquí.</para>
    </sect2>

  </sect1>

  <sect1 xml:id="users-limiting">
    <title>Limitar a los usuarios</title>

    <indexterm><primary>limitar a los usuarios</primary></indexterm>
    <indexterm>
      <primary>cuentas</primary>
      <secondary>limitar</secondary>
    </indexterm>
    <para>En un sistema multiusuario es probable que no confíes en que
      el sistema no vaya a ser dañado por ningún usuario.</para>

    <indexterm><primary>cuotas</primary></indexterm>
    <indexterm>
      <primary>limitar a los usuarios</primary>
      <secondary>cuotas</secondary>
    </indexterm>
    <indexterm><primary>cuotas de disco</primary></indexterm>
    <para>Las cuotas de disco permiten al administrador decirle al
      sistema de ficheros qué cantidad de espacio de disco puede
      utilizar un usuario; además, ofrecen una manera rápida de
      comprobar el uso de disco de un usuario sin tener que calcularlo
      cada vez.  Las cuotas se estudian en el capítulo de quotas.</para>

    <para>El resto de límites de recursos incluyen cantidad de CPU,
      memoria, y otros recursos que el usuario puede utilizar.</para>

    <indexterm>
      <primary><filename>/etc/login.conf</filename></primary>
    </indexterm>
    <para>Las clases de login se definen en
      <filename>/etc/login.conf</filename>.  La semántica precisa está
      fuera del alcance de esta sección, pero se describe con detalle en
      la página de manual &man.login.conf.5;.  Es suficiente decir que
      cada usuario es asignado a una clase de login
      (<literal>default</literal> por defecto), y que cada clase de
      login tiene un conjunto de capacidades asociado.  Una capacidad
      de login es un par
      <literal>nombre=valor</literal>,
      donde <replaceable>nombre</replaceable> es un identificador
      conocido y <replaceable>valor</replaceable> una cadena de texto
      arbitraria que se procesa en función del nombre.  Establecer
      clases y capacidades de login es bastante sencillo y también se
      describe en &man.login.conf.5;.</para>

    <para>Los límites de recursos son diferentes de las capacidades de
      login en dos sentidos.  En primer lugar, para cada límite existe
      un límite blando (actual) y uno duro.  Un límite blando puede ser
      ajustado por el usuario o una aplicación, pero no puede ser más
      alto que el límite duro.  Éste último puede ser disminuido por el
      usuario pero nunca aumentado.  En segundo lugar, la mayoría de los
      límites de recursos aplican a un usuario concreto por proceso, no
      globalmente.  Nótese, no obstante, que estas diferencias vienen
      impuestas por cómo se tratan los límites específicamente, no por
      la implementación del marco de capacidades de login (es decir, en
      realidad no constituyen un caso especial de capacidades de
      login).</para>

    <para>Sin más, a continuación veremos los límites de recursos más
      comúnmente usados (el resto, junto con el resto de capacidades de
      login, puede encontrarse en &man.login.conf.5;).</para>

    <variablelist>
      <varlistentry>
        <term><literal>coredumpsize</literal></term>

        <listitem>
          <indexterm><primary>coredumpsize</primary></indexterm>
          <indexterm>
            <primary>limitar a los usuarios</primary>
            <secondary>coredumpsize</secondary>
          </indexterm>
          <para>El tamaño de un fichero core generado por un programa
            está, por razones obvias, subordinado a otros límites sobre
            uso de disco (p. ej., <literal>filesize</literal>, o cuotas
            de disco).  Aun y así, se usa frecuentemente como un método
            menos severo de controlar consumo de espacio de disco, dado
            que los usuarios no generan ficheros core por ellos mismos,
            y a menudo no los borran, activar este límite puede evitar
            que agoten el espacio de disco de que disponen si algún
            programa grande (p. ej., <application>emacs</application>)
            deja de funcionar abruptamente.</para>
          </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>cputime</literal></term>

        <listitem>
          <indexterm><primary>cputime</primary></indexterm>
          <indexterm>
            <primary>limitar a los usuarios</primary>
            <secondary>cputime</secondary>
          </indexterm>
          <para>Ésta es la máxima cantidad de tiempo de CPU que los
            procesos de un usuario pueden consumir.

            <note>
              <para>Éste es un límite sobre el
                <emphasis>tiempo</emphasis> de CPU consumido, no el
                porcentaje de uso de CPU que se muestra en algunos
                campos de &man.top.1; y &man.ps.1;.  Un límite de ese
                tipo no es posible a día de hoy, y sería bastante
                inútil: un compilador &mdash;probablemente una tarea
                legítima&mdash; puede usar prácticamente el 100% de la
                CPU durante algún tiempo con facilidad.</para>
            </note>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>filesize</literal></term>

        <listitem>
          <indexterm><primary>filesize</primary></indexterm>
          <indexterm>
            <primary>limitar a los usuarios</primary>
            <secondary>filesize</secondary>
          </indexterm>
          <para>Éste es el tamaño máximo que puede llegar a tener un
            fichero del usuario.  A diferencia de las cuotas de disco, este
            límite se especifica para ficheros individuales, no para
            el conjunto de todos los archivos que posee.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>maxproc</literal></term>

        <listitem>
          <indexterm><primary>maxproc</primary></indexterm>
          <indexterm>
            <primary>limitar a los usuarios</primary>
            <secondary>maxproc</secondary>
          </indexterm>
          <para>Éste es el máximo número de procesos que un usuario
            puede ejecutar a la vez, incluidos tanto los procesos en
            primer plano como los procesos en segundo plano.  Por
            razones obvias, este límite no puede ser mayor que el límite
            de sistema especificado por <varname>kern.maxproc</varname>
            <command>sysctl</command>.  Obsérvese también que si
            asignamos un valor demasiado bajo a este límite podemos
            mermar la productividad de un usuario: frecuentemente es
            útil entrar múltiples veces en el sistema o ejecutar
            pipelines.  Algunas tareas, como compilar largos programas,
            lanzan múltiples procesos (p. ej., &man.make.1;, &man.cc.1;,
            y demás preprocesadores intermedios).</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>memorylocked</literal></term>

        <listitem>
          <indexterm><primary>memorylocked</primary></indexterm>
          <indexterm>
            <primary>limitar a los usuarios</primary>
            <secondary>memorylocked</secondary>
          </indexterm>
          <para>Ésta es la máxima cantidad de memoria que un proceso
            puede haber solicitado tener bloqueada en memoria principal
            (p. ej., ver &man.mlock.2;).  Algunos programas críticos
            para el sistema, como &man.amd.8;, se quedan bloqueados en
            la memoria principal de manera que en caso de ser llevados a
            swap no contribuyan a la basura del sistema si hay algún
            problema.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>memoryuse</literal></term>

        <listitem>
          <indexterm><primary>memoryuse</primary></indexterm>
          <indexterm>
            <primary>limitar a los usuarios</primary>
            <secondary>memoryuse</secondary>
          </indexterm>
          <para>Ésta es la mayor cantidad de memoria que un proceso
            puede consumir en todo momento.  Incluye tanto memoria
            normal como uso de swap.  No se trata de un límite para
            restringir el consumo de memoria en general, pero es un buen
            comienzo.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>openfiles</literal></term>

        <listitem>
          <indexterm><primary>openfiles</primary></indexterm>
          <indexterm>
            <primary>limitar a los usuarios</primary>
            <secondary>openfiles</secondary>
          </indexterm>
          <para>Ésta es la máxima cantidad de archivos que un proceso
            puede tener abiertos.  En FreeBSD, los archivos se usan
            tambien para representar sockets y canales IPC; así, cuida
            de no poner este límite demasiado bajo.  A nivel de sistema,
            el límite para esto lo define
            <varname>kern.maxfiles</varname>
            <command>sysctl</command>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>sbsize</literal></term>

        <listitem>
          <indexterm><primary>sbsize</primary></indexterm>
          <indexterm>
            <primary>limitar a los usuarios</primary>
            <secondary>sbsize</secondary>
          </indexterm>
          <para>Éste es el límite de cantidad de memoria de red, y por
            lo tanto mbufs, que un usuario puede consumir.  Se originó
            como respuesta a un viejo ataque DoS que creaba muchos
            sockets, pero puede ser usado en general para limitar las
            comunicaciones por red.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>stacksize</literal></term>

        <listitem>
          <indexterm><primary>stacksize</primary></indexterm>
          <indexterm>
            <primary>limitar a los usuarios</primary>
            <secondary>stacksize</secondary>
          </indexterm>
            <para>Éste es el tamaño máximo que puede alcanzar la pila de
              un proceso.  Por sí solo no es suficiente para limitar la
              cantidad de memoria que puede usar un programa; en
              consecuencia, debería ser usado junto con otros
              límites.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Hay unas pocas cosas más a recordar cuando establecemos
      límites de recursos.  A continuación vienen algunas
      recomendaciones, sugerencias, y comentarios varios.</para>

    <itemizedlist>
      <listitem>
        <para>Los procesos que se ponen en marcha cuando arranca el
          sistema por <filename>/etc/rc</filename> están asignados a la
          clase de login <literal>daemon</literal>.</para>
      </listitem>

      <listitem>
        <para>Aunque el <filename>/etc/login.conf</filename> que viene
          con el sistema tiene valores razonables para la mayoría de los
          límites, sólo tú, el administrador, puedes saber lo que es
          apropiado para tu sistema.</para>
      </listitem>

      <listitem>
        <para>A los usuarios del X Window System (X11) probablemente se
          les debería conceder más recursos que al resto.  X11 de por sí
          consume muchos recursos, pero además contribuye a que los
          usuarios ejecuten más programas simultáneamente.</para>
      </listitem>

      <listitem>
        <para>Recuerda que hay muchos límites que aplican a procesos
          individuales, no al usuario en general.  Por ejemplo, poner
          <varname>openfiles</varname> a 50 significa que cada uno de
          los procesos que ejecute un usuario puede abrir a lo máximo 50
          ficheros.  Así, la cantidad de ficheros que un usuario puede
          abrir es el valor de <literal>openfiles</literal> multiplicado
          por el valor de <literal>maxproc</literal>.  Esto también
          aplica al uso de memoria.</para>
      </listitem>
    </itemizedlist>

    <para>Para más información acerca de límites de recursos y clases y
      capacidades de login en general, consulta las páginas de manual
      relevantes: &man.cap.mkdb.1;, &man.getrlimit.2;,
      &man.login.conf.5;.</para>
  </sect1>

  <sect1 xml:id="users-personalizing">
    <title>Personalizar a los usuarios</title>

    <para>La localización es un entorno establecido por el administrador
      o el usuario para dar soporte a distintos lenguajes, juegos de
      caracteres, estándares sobre fechas y horas, etcétera.  Éste tema
      se trata en el capítulo <link linkend="l10n">Localización</link>.</para>
  </sect1>

  <sect1 xml:id="users-groups">
    <title>Grupos</title>

    <indexterm><primary>grupos</primary></indexterm>
    <indexterm>
      <primary><filename>/etc/group</filename></primary>
    </indexterm>
    <indexterm>
      <primary>cuentas</primary>
      <secondary>grupos</secondary>
    </indexterm>
    <para>Un grupo es simplemente una lista de usuarios.  Los grupos se
      identifican por su nombre de grupo y gid (ID de grupo).  En
      FreeBSD (y en la mayoría de sistemas Unix), los dos factores que
      tiene en cuenta el núcleo para decidir si un proceso puede hacer
      algo es su ID de usuario y la lista de grupos a los que pertenece.
      A diferencia del ID de usuario, un proceso tiene una lista de
      grupos asociados.  En ocasiones encontrarás menciones al "ID de
      grupo" de un usuario o de un proceso; la mayoría de las veces
      referirán simplemente al primero de los grupos de la lista.</para>

    <para>La correspondencia entre nombres e IDs de grupo está en
      <filename>/etc/group</filename>.  Se trata de un fichero de texto
      plano con cuatro campos separados por el signo dos puntos.  El
      primer campo es el nombre de grupo, el segundo la contraseña
      encriptada, el tercero el ID de grupo, y el cuarto la lista de
      miembros separados por comas.  Puede ser editado a mano sin
      peligro (¡suponiendo, por supuesto, que no se cometan errores de
      sintaxis!).  Para una descripción más completa de la sintaxis, ver
      la página de manual &man.group.5;.</para>

    <para>Si no quieres editar <filename>/etc/group</filename>
      manualmente, puedes usar el comando &man.pw.8; para añadir y
      modificar grupos.  Por ejemplo, para añadir un grupo llamado
      <systemitem class="groupname">teamtwo</systemitem> y luego confirmar que existe puedes
      usar:</para>

    <example>
      <title>Añadir un grupo usando &man.pw.8;</title>

      <screen>&prompt.root; <userinput>pw groupadd teamtwo</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:</screen>
    </example>

    <para>El número <literal>1100</literal> en el ejemplo anterior es el
      ID de grupo del grupo <systemitem class="groupname">teamtwo</systemitem>.  Ahora mismo
      <systemitem class="groupname">teamtwo</systemitem> no tiene miembros, y es por tanto
      bastante inútil.  Cambiemos eso invitando a
      <systemitem class="username">jru</systemitem> a formar parte del grupo
      <systemitem class="groupname">teamtwo</systemitem>.</para>

    <example>
      <title>Añadir a alguien a un grupo usando &man.pw.8;</title>

      <screen>&prompt.root; <userinput>pw groupmod teamtwo -M jru</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:jru</screen>
    </example>

    <para>El argumento de la opción <option>-M</option> es una lista con
      los usuarios que son miembros del grupo separados por comas.
      Sabemos de secciones anteriores que el fichero de contraseñas
      también contiene un grupo para cada usuario.  El usuario es
      automáticamente añadido a la lista de grupos por el sistema; no
      constará como miembro cuando usemos el comando
      <command>groupshow</command> con &man.pw.8;, pero sí cuando la
      información se consulte con &man.id.1; u otra herramienta similar.
      En otras palabras, &man.pw.8; sólo manipula el fichero
      <filename>/etc/group</filename>; nunca tratará de leer datos
      adicionales de <filename>/etc/passwd</filename>.</para>

    <example>
      <title>Determinar pertenencia a grupos con &man.id.1;</title>

      <screen>&prompt.user; <userinput>id jru</userinput>
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)</screen>
    </example>

    <para>Como puedes ver, <systemitem class="username">jru</systemitem> es miembro de los
      grupos <systemitem class="groupname">jru</systemitem> y
      <systemitem class="groupname">teamtwo</systemitem>.</para>

    <para>Para más información acerca de &man.pw.8;, consulta su página
      de manual, y para más información acerca del formato de
      <filename>/etc/group</filename>, consulta la página de manual de
      &man.group.5;.</para>
  </sect1>
</chapter>
