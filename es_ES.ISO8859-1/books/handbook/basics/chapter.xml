<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project

     The FreeBSD Spanish Documentation Project
     %SOURCE% en_US.ISO8859-1/books/handbook/basics/chapter.xml
     %SRCID%    1.154


     $FreeBSD$
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="basics">
  <info><title>Conceptos básicos de Unix</title>
    <authorgroup>
      <author><personname><firstname>Chris</firstname><surname>Shumway</surname></personname><contrib>Reescrito por </contrib></author>
    </authorgroup>
    
  </info>

  

  <sect1 xml:id="basics-synopsis">
    <title>Sinopsis</title>

  <para>El siguiente capítulo comprende la funcionalidad y
    órdenes básicas del sistema operativo &os;.
    Gran parte de este material es relevante para cualquier sistema
    operativo tipo &unix;.
    Puede saltarse este capítulo si considera que ya conoce
    el funcionamiento de &unix;.
    Si no tiene experiencia previa con &os; debería leer este
    capítulo con mucha atención.</para>

    <para>Después de leer este capítulo, usted
      sabrá:</para>

    <itemizedlist>
      <listitem>
        <para>Cómo usar las «consolas virtuales» de
            FreeBSD.</para>
      </listitem>
      <listitem>
        <para>Cómo funcionan los permisos de fichero &unix; en
          relación con las banderas de fichero en &os;.</para>
      </listitem>
      <listitem>
	<para>La disposición de sistemas de ficheros por
	  omisión en &os;.</para>
      </listitem>
      <listitem>
	<para>La organización de disco de &os;.</para>
      </listitem>
      <listitem>
	<para>Cómo montar y desmontar sistemas de ficheros.</para>
      </listitem>
      <listitem>
	<para>Qué son los procesos, d&aelig;mons y señales.</para>
      </listitem>
      <listitem>
	<para>Qué es una shell, cómo modificar sus variables
	  de entorno por omisión.</para>
      </listitem>
      <listitem>
	<para>Cómo utilizar editores de texto básicos.</para>
      </listitem>
      <listitem>
	<para>Qué son los dispositivos y nodos de dispositivos.</para>
      </listitem>
      <listitem>
	<para>Qué formato binario se usa en &os;.</para>
      </listitem>
      <listitem>
	<para>Cómo buscar información en las  páginas
	  de manual.</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 xml:id="consoles">
    <title>Consolas virtuales y terminales</title>
    <indexterm><primary>consola virtual</primary></indexterm>
    <indexterm><primary>terminales</primary></indexterm>

    <para>&os; puede utilizarse de muchas maneras.  Una de ellas es
      tecleando órdenes en una terminal de texto.  De este modo, mucha
      de la flexibilidad y poder de un sistema operativo &unix; está
      inmediatamente en sus manos cuando usa &os;.  Esta sección
      describe qué son «terminales» y
      «consolas» y cómo puede usarlas en &os;.</para>

    <sect2 xml:id="consoles-intro">
      <title>La consola</title>
      <indexterm><primary>consola</primary></indexterm>

      <para>Si no ha configurado &os; para ejecutar automáticamente
        un entorno gráfico en el arranque, el sistema le
        presentará un «prompt» de entrada después
        del arranque, inmediatamente después de que los
        «scripts» de inicio terminen de ejecutarse.
        Verá algo similar a esto:</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.ejemplo.org) (ttyv0)

login:</screen>

      <para>Los mensajes pueden ser un poco diferentes en su sistema, pero
        verá algo similar. Las últimas dos líneas son
        las que nos interesan por el momento. La penúltima línea
        dice:</para>

      <programlisting>FreeBSD/i386 (pc3.ejemplo.org) (ttyv0)</programlisting>

      <para>Esta línea contiene información
        acerca del sistema que acaba de arrancar.  Esta usted ante una
        consola «FreeBSD» que se ejecuta en un procesador Intel
        o compatible de la arquitectura x86<footnote>
          <para>Esto es lo que <literal>i386</literal> significa.  Tenga en
            cuenta que incluso si no está ejecutando &os; en una CPU
            Intel 386, éste va a ser <literal>i386</literal>.
            No es el tipo de su procesador, sino la
            «arquitectura» la que se muestra aquí.</para>
	</footnote>.
        El nombre de esta máquina (todas las  máquinas &unix;
        tiene un nombre) es <systemitem>pc3.ejemplo.org</systemitem>, y usted
        está ahora ante su consola de sistema (la
        terminal <filename>ttyv0</filename>).</para>

      <para>Para acabar, la última línea siempre es:</para>

      <programlisting>login:</programlisting>

      <para>Este es el lugar donde se usted tecleará su
        «nombre de usuario» para entrar en &os;.
        La siguiente sección describe cómo hacerlo.</para>
    </sect2>

    <sect2 xml:id="consoles-login">
      <title>La entrada a &os;</title>

      <para>&os; es un sistema multiusuario multiprocesador. Esta
        es la descripción formal que se suele dar a un
        sistema que puede ser utilizado por muchas personas diferentes,
        que simultáneamente ejecutan muchos programas en un sola
        máquina.</para>

      <para>Cada sistema multiusuario necesita algún modo de
        distinguir a un «usuario» del resto. En &os;
        (y en todos los sistemas operativos de tipo &unix;) esto se
        logra requiriendo que cada usuario «acceda»
        al sistema antes de poder ejecutar programas.  Cada usuario
        tiene un nombre único (el «nombre de usuario»)
        y una clave secreta, personal (la «contraseña»).
        &os; preguntará por ambos antes de permitirle a
        un usuario ejecutar cualquier programa.</para>

      <indexterm><primary>scripts de inicio</primary></indexterm>
      <para>Justo después de que &os; arranque y termine de
        ejecutar sus «scripts» de inicio
        <footnote>
          <para>Los «scripts» de inicio son programas que &os;
            ejecuta automáticamente cuando arranca.  Su función
            principal es preparar todo lo necesario para que todo lo demás
            se ejecute, e iniciar cualquier servicio que tenga configurado
            para ejecutarse en segundo plano algo
            útiles.</para>
        </footnote>, le presentará un «prompt» y
        solicitará un nombre válido de usuario:</para>

      <screen>login:</screen>

      <para>En este ejemplo vamos a asumir que su nombre de
        usuario es <systemitem class="username">john</systemitem>.  Teclée
        <literal>john</literal> en el «prompt» y pulse
        <keycap>Intro</keycap>.  Debería presentársele un
        «prompt» donde introducir una
        «contraseña»:</para>

      <screen>login: <userinput>john</userinput>
Password:</screen>

      <para>Teclée ahora la contraseña de <systemitem class="username">john</systemitem>
        y pulse <keycap>Enter</keycap>. La contraseña
        <emphasis>no se muestra en pantalla</emphasis>, pero no debe
        preocuparse por ello.  Esto se hace así por motivos de
        seguridad.</para>

      <para>Si ha tecleado su contraseña correctamente ya está
        usted en un sistema &os;, listo para probar todas las
        órdenes disponibles.</para>

      <para>Verá el <acronym>MOTD</acronym> (mensaje del día)
        seguido por un «prompt» (un caracter <literal>#</literal>,
        <literal>$</literal> o <literal>%</literal>).  Esto confirma
        que ha validado con éxito su usuario en &os;.</para>
    </sect2>

    <sect2 xml:id="consoles-virtual">
      <title>Consolas múltiples</title>

      <para>Ejecutar órdenes &unix; en una consola está bien,
        pero &os; puede ejecutar muchos programas a la vez.  Tener una consola
        donde se pueden teclear órdenes puede ser un desperdicio
        cuando un sistema operativo como &os; puede ejecutar docenas de
        programas al mismo tiempo.  Aquí es donde las
        «consolas virtuales» muestran su potencial.</para>

      <para>&os; puede configurarse para presentarle diferentes
        consolas virtuales.  Puede cambiar de una de ellas a cualquier
        otra consola virtual pulsando un par de teclas en su teclado.
        Cada consola tiene su propio canal de salida, y &os;
        se ocupa de redirigir correctamente la entrada del teclado y
        la salida al monitor cuando cambia de una consola virtual a la
        siguiente.</para>

      <para>Se han reservado ciertas combinaciones especiales de teclas
        para pasar de unas consolas virtuales a otras en &os; <footnote>
        <para>Tiene una descripción bastante técnica y correcta
          de todos los detalles de la consola &os; y los controladores de
          teclado pueden encontrarse en las páginas de manual de
          &man.syscons.4;, &man.atkbd.4;, &man.vidcontrol.1; y
          &man.kbdcontrol.1;. No nos extenderemos en los detalles aquí,
          pero el lector interesado siempre puede consultar dichas
          páginas de manual si quiere una explicación
          más detallada y profunda de cómo funcionan
          estas cosas.</para>
	</footnote>. Puede utilizar
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo> y
         así sucesivamente hasta
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo> para
         cambiar a una consola virtual diferente en &os;.</para>

      <para>Mientras está cambiando de una consola a la siguiente,
        &os; se ocupa de guardar y restaurar la salida de pantalla. El
        resultado es la «ilusión» de tener varias
        pantallas y teclados «virtuales» que puede utilizar
        para teclear órdenes para que &os; los ejecute.  El programa que
        usted lanza en una consola virtual no deja de ejecutarse cuando la
        consola no está visible.  Continúan ejecutándose
        cuando se cambia a una consola virtual diferente.</para>
    </sect2>

    <sect2 xml:id="consoles-ttys">
      <title>El fichero <filename>/etc/ttys</filename></title>

      <para>La configuración por omisión de &os; iniciará
        con ocho consolas virtuales.  No es una configuración
        estática por hardware, así que puede personalizar
        fácilmente su sistema para arrancar con más o menos
        consolas virtuales.  El número y propiedades de las consolas
        virtuales están detallados en
        <filename>/etc/ttys</filename>.</para>

      <para>En <filename>/etc/ttys</filename> es donde se configuran
        las consolas virtuales de &os;.  Cada línea no
        comentada de este fichero (líneas que no comienzan con un
        caracter <literal>#</literal>) contiene propiedades para una sola
        terminal o consola virtual.  La versión por omisión de
        este fichero en &os; configura nueve consolas
        virtuales y habilita ocho de ellas.  Son las líneas que
        comienzan con <literal>ttyv</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>Consulte &man.ttys.5; si quiere una descripción detallada
        de cada columna en este fichero y todas las opciones que puede usar
        para configurar las consolas virtuales.</para>
    </sect2>

    <sect2 xml:id="consoles-singleuser">
      <title>Consola en modo monousuario</title>

      <para>En la <xref linkend="boot-singleuser"/> encontrará una
        descripción detallada de lo que es «modo
        monousuario».
        No importa que sólo exista una consola cuando ejecuta &os; en
        modo monousuario.  No hay otra consola virtual disponible.  Las
        configuraciones de la consola en modo monousuario se pueden encontrar
        también en <filename>/etc/ttys</filename>.  Busque la
        línea que comienza por <literal>console</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
# Si la consola está marcada como "insecure", entonces init
# le pedirá la contraseña de root al entrar a modo monousuario.
console none                            unknown off secure</programlisting>

      <note>
        <para>Tal y como indican los comentarios por encima de la
          línea <literal>console</literal>, puede editar esta
          línea y cambiar <literal>secure</literal> por
          <literal>insecure</literal>.  Si lo hace, cuando &os; arranque
          en modo monousuario el sistema le pedirá la
          contraseña de <systemitem class="username">root</systemitem>.</para>

        <para><emphasis>Tenga cuidado si cambia esto a
          <literal>insecure</literal></emphasis>.  Si olvida la
          contraseña de <systemitem class="username">root</systemitem> arrancar
          en modo monousuario será con seguridad más
          complicado.  Sigue siendo posible, pero será un poco
          difícil para alguien que no esté familiarizado
          con le proceso de arranque de &os; y los programas involucrados
          en dicho proceso.</para>
      </note>
    </sect2>



    <sect2 xml:id="consoles-vidcontrol">
      <title>Cambio del modo de video de la consola</title>

      <para>La consola &os; por omisión tiene un modo de video que
	puede ajustarse a 1024x768, 1280x1024 o cualquier otra resolución
	que admita su chip gráfico y su monitor.  Si quiere utilizar
	uno diferente tendrá que recompilar su kernel con estas dos
	opciones añadidas:</para>

      <programlisting>options VESA
options SC_PIXEL_MODE</programlisting>

      <para>Una vez recompilado el kernel con esas dos opciones en él
        determine qué modos de video admite su hardware; para ello
	use &man.vidcontrol.1;.  Con lo siguiente le mostrará una
	lista de modos de video soportados:</para>

      <screen>&prompt.root; <userinput>vidcontrol -i mode</userinput></screen>

      <para>La salida de esta orden es una lista de los modos de
        que admite su tarjeta.  Para elegir uno de ellos tendrá
	que ejecutar &man.vidcontrol.1; en una consola como
	<systemitem class="username">root</systemitem>:</para>

      <screen>&prompt.root; <userinput>vidcontrol MODE_279</userinput></screen>

      <para>Si el modo de video que ha elegido le parece adecuado puede
	configurarlo de forma permanente haciendo que funcione desde el
	momento del arranque; para ello debe editar <filename>/etc/rc.conf</filename>
	file:</para>

      <programlisting>allscreens_flags="MODE_279"</programlisting>
    </sect2>


  </sect1>

  <sect1 xml:id="permissions">
    <title>Permisos</title>
    <indexterm><primary>UNIX</primary></indexterm>

    <para>&os;, cuya raíz histórica es el &unix; BSD,
      se fundamenta en varios conceptos clave de UNIX. El primero y
      más importante es que &os; es un sistema operativo
      multi-usuario.  El sistema puede gestionar múltiples usuarios
      trabajando simultáneamente y en tareas que no guarden relación
      entre sí.  El sistema se encarga de compartir y administrar
      peticiones de dispositivos de hardware, periféricos, memoria y
      tiempo de CPU de manera equitativa para cada usuario.</para>

    <para>Debido a que el sistema es capaz de soportar múltiples
      usuarios, todo lo que el sistema administra tiene un conjunto de
      permisos que usa para decidir quién puede leer, escribir y
      ejecutar un recurso.  Estos permisos se guardan como octetos
      divididos en tres partes: una para el propietario del fichero, otra
      para el grupo al que el fichero pertenece, y otra para todos los
      demás grupos y usuarios.  Veamos una
      representación numérica de esto:</para>

    <indexterm><primary>permisos</primary></indexterm>
    <indexterm>
      <primary>permisos de fichero</primary>
    </indexterm>
    <informaltable frame="none" pgwide="1">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Valor</entry>
	    <entry>Permiso</entry>
	    <entry>Listado de directorio</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>No leer, no escribir, no ejecutar</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>No leer, no escribir, ejecutar</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>No leer, escribir, no ejecutar</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>No leer, escribir, ejecutar</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Leer, no escribir, no ejecutar</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Leer, no escribir, ejecutar</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Leer, escribir, no ejecutar</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Leer, escribir, ejecutar</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>directorios</primary></indexterm>

    <para>Puede utilizar el parámetro de línea de órdenes
      <option>-l</option> de &man.ls.1; para ver un listado
      largo que incluya una columna con información acerca
      de los permisos de fichero para el propietario, grupo y
      los demás.  Por ejemplo, un <command>ls -l</command> en
      un directorio puede mostrar algo como esto:</para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 mifichero
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otrofichero
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...</screen>

    <para>Aquí está como se divide la primera columna
      de <command>ls -l</command>:</para>

    <screen>-rw-r--r--</screen>

    <para>El primer caracter (más a la izquierda) indica si
      este fichero es un fichero regular, un directorio, un
      dispositivo especial de caracter, un socket o cualquier otro
      dispositivo especial pseudo-ficheroa . En este caso, el
      <literal>-</literal> un fichero regular.  Los siguientes tres
      caracteres, <literal>rw-</literal> en este ejemplo, dan los permisos
      para el propietario del fichero.  Los siguientes tres caracteres,
      <literal>r--</literal>, dan los permisos para el grupo al que
      el fichero pertenece.  Los últimos tres caracteres,
      <literal>r--</literal>, dan los permisos para el resto del
      mundo.  Un guión indica que el permiso está desactivado.
      En el caso de este fichero, los permisos están
      asignados de tal manera que el propietario puede leer y escribir
      en el fichero, el grupo puede leer el fichero, y el resto del
      mundo sólo puede leer el fichero.  De acuerdo con la tabla
      de arriba, los permisos para este fichero serían
      <literal>644</literal>,
      donde cada dígito representa las tres partes de los
      permisos del fichero.</para>

    <para>Todo ésto está muy bien, pero ?cómo
      controla el sistema los permisos de los dispositivos? &os; en
      realidad trata la mayoría de los dispositivos hardware como un
      fichero que los programas pueden abrir, leer y en los que pueden
      escribir datos como si de cualquier otro fichero se tratara.  Estos
      ficheros especiales de dispositivo se encuentran en el directorio
      <filename>/dev</filename>.</para>

    <para>Los directorios también son tratados como ficheros.  Tienen
      permisos de lectura, escritura y ejecución.  El bit de
      ejecución en un directorio tiene un significado
      ligeramente distinto que para los ficheros.  Cuando un directorio
      está marcado como ejecutable significa que se puede mirar dentro,
      se puede hacer un «cd» (cambiar directorio) a él.
      Esto también significa que dentro del directorio es posible
      acceder a ficheros cuyos nombres son conocidos (sujeto, claro está,
      a los permisos de los ficheros mismos).</para>

    <para>En particular, para poder realizar un listado de directorio,
      el permiso de lectura debe ser activado en el directorio,
      mientras que para borrar un fichero del que se conoce el
      nombre es necesario tener permisos de escritura <emphasis>y</emphasis>
      ejecución en el directorio que contiene el fichero.</para>

    <para>Existen más permisos, pero se usan principalmente en
      circunstancias especiales como los binarios ejecutables de tipo setuid
      y los los directorios de tipo «sticky».  Si desea más
      información acerca de los permisos de ficheros y cómo
      establecerlos, consulte &man.chmod.1;.
      </para>

    <sect2>
      <info><title>Permisos simbólicos</title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Escrito por </contrib></author>
	</authorgroup>
      </info>

      
      <indexterm><primary>permisos</primary><secondary>symbolic</secondary></indexterm>

      <para>Los permisos simbólicos, también conocidos como
        expresiones simbólicas, utilizan caracteres en lugar de valores
        octales para asignar permisos a ficheros o directorios.  Las expresiones
        simbólicas utilizan la sintaxis de (quién) (acción)
        (permisos) mediante los siguientes valores:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Opción</entry>
	      <entry>Letra</entry>
	      <entry>Representa</entry>
	    </row>
	  </thead>

	<tbody>
	  <row>
	    <entry>(quién)</entry>
	    <entry>u</entry>
	    <entry>Usuario</entry>
	  </row>

	  <row>
	    <entry>(quién)</entry>
	    <entry>g</entry>
	    <entry>Grupo propietario</entry>
	  </row>

	  <row>
	    <entry>(quién)</entry>
	    <entry>o</entry>
	    <entry>Otro</entry>
	  </row>

	  <row>
	    <entry>(quién)</entry>
	    <entry>a</entry>
	    <entry>Todos («todo el mundo»)</entry>
	  </row>

	  <row>
	    <entry>(acción)</entry>
	    <entry>+</entry>
	    <entry>Añadir permisos</entry>
	  </row>

	  <row>
	    <entry>(acción)</entry>
	    <entry>-</entry>
	    <entry>Quitar permisos</entry>
	  </row>

	  <row>
	    <entry>(acción)</entry>
	    <entry>=</entry>
	    <entry>Activar permisos explícitamente</entry>
	  </row>

	  <row>
	    <entry>(permisos)</entry>
	    <entry>r</entry>
	    <entry>Lectura</entry>
	  </row>

	  <row>
	    <entry>(permisos)</entry>
	    <entry>w</entry>
	    <entry>Escritura</entry>
	  </row>

	  <row>
	    <entry>(permisos)</entry>
	    <entry>x</entry>
	    <entry>Ejecución</entry>
	  </row>

	  <row>
	    <entry>(permisos)</entry>
	    <entry>t</entry>
	    <entry>Bit Sticky («pegajoso»)</entry>
	  </row>

	  <row>
	    <entry>(permisos)</entry>
	    <entry>s</entry>
	    <entry>Activar UID o GID</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Estos valores se aplican con &man.chmod.1;
      de la misma manera que los anteriores, pero con letras.  Por
      ejemplo, podría usar la siguiente orden para
      bloquear a otros usuarios el acceso a <replaceable>FICHERO</replaceable>:</para>

    <screen>&prompt.user; <userinput>chmod go= FICHERO</userinput></screen>

    <para>Puede usarse una lista separada por comas cuando
      se quiera aplicar más de un conjunto de cambios a un fichero.
      Por ejemplo la siguiente orden eliminará los permisos de
      escritura de grupo y «mundo» a
      <replaceable>FICHERO</replaceable>, y añade permisos de
      ejecución para todos:</para>

    <screen>&prompt.user; <userinput>chmod go-w,a+x FILE</userinput></screen>

<!--
    <para>Most users will not notice this, but it should be pointed out
      that using the octal method will only set or assign permissions to
      a file; it does not add or delete them.</para>
-->
    </sect2>

    <sect2>
      <info><title>Banderas de fichero en &os;</title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Escrito por </contrib></author>
	</authorgroup>
      </info>

      

      <para>Además de los permisos de fichero previamente
        expuestos, &os; permite el uso de «banderas de
        fichero». Estas banderas añaden un nivel de seguridad
        y control adicional a los ficheros, pero no a los directorios.</para>

      <para>Las banderas de fichero añaden un nivel adicional
        de control sobre los ficheros ayudando a asegurar que en algunos
        casos ni siquiera <systemitem class="username">root</systemitem> pueda eliminar
        o alterar ficheros.</para>

      <para>Las banderas de fichero se modifican mediante
        &man.chflags.1;, gracias a una interfaz muy sencilla. Por ejemplo,
        para habilitar la bandera imborrable de sistema en
        <filename>fichero1</filename>, escriba lo siguiente:</para>

      <screen>&prompt.root; <userinput>chflags sunlink fichero1</userinput></screen>

      <para>Y para dehabilitar la bandera imborrable de sistema,
        simplemente escriba la orden previa con «no»
        antes de <option>sunlink</option>. Observe:</para>

      <screen>&prompt.root; <userinput>chflags nosunlink fichero1</userinput></screen>

      <para>Para ver las banderas de este fichero, utilice
        &man.ls.1; con las opciones <option>-lo</option>:</para>

      <screen>&prompt.root; <userinput>ls -lo fichero1
	</userinput></screen>

      <para>La salida debería ser como esta:</para>

      <programlisting>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 fichero1</programlisting>

      <para>Varias banderas solo pueden ser añadidas o retiradas
        de ficheros por el usuario <systemitem class="username">root</systemitem>. En
        otros casos, el propietario del fichero puede activar estas
        banderas. Se recomienda que para más información
        la persona encargada de la administración del sistema
        consulte las  páginas de manual &man.chflags.1; y
        &man.chflags.2;.</para>
    </sect2>


    <sect2>
      <info><title>Los permisos <literal>setuid</literal>,
        <literal>setgid</literal> y <literal>sticky</literal></title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Escrito por </contrib></author>
	</authorgroup>
      </info>

      

      <para>Además de los permisos que se han explicado hay
        más, hay tres tipos más que todos los administradores
	deberían conocer.  Son los permisos
	<literal>setuid</literal>,
	<literal>setgid</literal> y <literal>sticky</literal>.</para>

      <para>Estos permisos juegan un papel clave en ciertas operaciones
        &unix; puesto que facilitan funcionalidades que no se suelen
	permitir a los usuarios normales.  Para comprenderlas
	totalmente hay que comprender la diferencia entre el ID real
	del usuario y el ID efectivo.</para>

      <para>El ID del usuario real es el
        <acronym>UID</acronym> que arranca (y el propietario) del
	proceso.   El <acronym>UID</acronym> efectivo es el ID bajo
	el que se ejecuta el proceso.  Veamos un ejemplo; el programa
	&man.passwd.1; se ejecuta con el ID real del usuario puesto que
	el usuario está cambiando su contraseña.  Pero para
	poder manipular la base de datos de contraseñas debe
	ejecutarse con el ID efectivo del usuario
	<systemitem class="username">root</systemitem>.  De este modo es posible que los usuarios
	cambien su contraseña sin llegar a ver un error de
	<errorname>Permission Denied</errorname> (permiso denegado).</para>

      <note>
	<para>La opción <literal>nosuid</literal> de &man.mount.8;
	  hace que estos binarios den errores silenciosos, es decir,
	  fallarán pero el usuario no recibirá ningún
	  mensaje de error por ello.  Esta opción no funciona
	  siempre, pues, según la página man de
	  &man.mount.8;, un «wrapper»
	  <literal>nosuid</literal> puede sortear esta limitación.</para>
      </note>

      <para>El permiso setuid puede asignarse colocando un número
         cuatro (4) antes de los permisos.  Se ve mejor con un ejemplo:</para>

      <screen>&prompt.root; <userinput>chmod 4755 ejemplosuid.sh</userinput></screen>

      <para>Los permisos de
	<filename>ejemplosuid.sh</filename>
	deberían ser así:</para>

      <programlisting>-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 ejemplosuid.sh</programlisting>

      <para>Fíjese atentamente en la
	<literal>s</literal> que ha aparecido en los permisos
	del fichero, en la parte de los permisos del propietario;
	esa <literal>s</literal> está en donde estaría
	el bit de ejecución.  Gracias a esto el funcionamiento
	de aplicaciones que necesitan permisos elevados, como
	<command>passwd</command>, pueden funcionar.</para>

      <para>Si quiere ver un ejemplo con sus propios ojos abra dos
        terminales.  En una arranque un proceso (ejecute)
	<command>passwd</command> con un usuario normal.  Mientras la
	aplicación espera a que le de una nueva contraseña
	busque la información de usuario del proceso
	<command>passwd</command> en la tabla de procesos.</para>

      <para>En la terminal A:</para>

      <screen>Changing local password for trhodes
Old Password:</screen>

      <para>En la terminal B:</para>

      <screen>&prompt.root; <userinput>ps aux | grep passwd</userinput></screen>

      <screen>trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd</screen>

      <para>Tal y como se ha dicho, un usuario normal puede ejecutar
        <command>passwd</command>, pero en realidad está
	utilizando el <acronym>UID</acronym> efectivo de
	<systemitem class="username">root</systemitem>.</para>

      <para>El permiso <literal>setgid</literal> actúa del mismo
        modo que el <literal>setuid</literal>, pero afecta a los permisos
	del grupo.  Cuando una aplicación funciona con esta
	configuración lo hace con los permisos del grupo al
	que pertenece el fichero, no los del usuario que ha
	arrancado el proceso.</para>

      <para>Si quiere utilizar el permiso <literal>setgid</literal>
        debe situar un núnmero dos (2) al principio de los
	permisos que vaya a asignar mediante
	<command>chmod</command>.</para>

      <screen>&prompt.root; <userinput>chmod 2755 ejemplosuid.sh</userinput></screen>

      <para>La nueva configuración tiene un aspecto muy
        similar a la que tenía antes, pero observe que la
	<literal>s</literal> de antes está ahora en el campo
	de los permisos de grupo:</para>

      <screen>-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 ejemplosuid.sh</screen>

      <note>
	<para>En ambos ejemplos, incluso si el «script»
	  en cuestión es ejecutable, no se va a ejecutar
	  con un
	  <acronym>EUID</acronym> distinto o un ID efectivo de
	  usuario porque los «scripts» de shell no
	  pueden acceder a la llama del sistema
	  &man.setuid.2;.</para>
      </note>

      <para>Los dos permisos que acabamos de mostrar
	los bits de permisos (<literal>setuid</literal>
	y <literal>setgid</literal>) pueden reducir el nivel
	de seguridad haciendo que se escalen los permisos.
	Pero hay un tercer bit especial de permisos que puede
	ser de mucha ayuda para reforzar la seguridad del
	sistema:
	el <literal>sticky bit</literal>.</para>

      <para>El <literal>sticky bit</literal>( que podríamos
        traducir como «bit pegajoso») aplicado a un
	directorio hace que solamente el propietario de un fichero
	pueda borrarlo.  Esto evita el borrado de ficheros ajenos
	en directorios públicos como
	<filename>/tmp</filename>.  Si quiere
	usarlo coloque un uno (1) antes de los permisos. Veamos
	un ejemplo:</para>

      <screen>&prompt.root; <userinput>chmod 1777 /tmp</userinput></screen>

      <para>Para ver el <literal>;sticky bit</literal> en acción usamos
	<command>ls</command>:</para>

      <screen>&prompt.root; <userinput>ls -al / | grep tmp</userinput></screen>

      <screen>drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp</screen>

      <para>El <literal>sticky bit</literal> es la letra
	<literal>t</literal> al final de los permisos.</para>
    </sect2>
  </sect1>



  <sect1 xml:id="dirstructure">
    <title>Estructura de directorios</title>
    <indexterm><primary>jerarquía de directorios</primary></indexterm>

    <para>La jerarquía del sistema de ficheros de &os; es
      fundamental para obtener una compresión completa del
      sistema.  El concepto más importante a entender es el
      del directorio raíz, «/».  Este directorio
      es el primero en ser montado en el arranque y contiene
      el sistema básico necesario para preparar el sistema
      operativo para su funcionamiento en modo multiusuario.
      El directorio raíz también contiene puntos de montaje
      para cualquier otro sistema de ficheros que se pretenda montar.</para>

    <para>Un punto de montaje es un directorio del que se pueden
      colgar sistemas de ficheros adicionales en un sistema padre
      (que suele ser el directorio raíz).
      Esto se explica con detalle en la <xref linkend="disk-organization"/>.
      Los puntos de montaje estándar son, por ejemplo,
      <filename>/usr</filename>, <filename>/var</filename>,
      <filename>/tmp</filename>,
      <filename>/mnt</filename> y <filename>/cdrom</filename>.  Estos
      directorios suelen corresponderse con entradas en
      <filename>/etc/fstab</filename>.  <filename>/etc/fstab</filename>
      es una tabla que sirve de referencia al sistema y contiene
      los diferentes sistemas de ficheros y sus respectivos
      puntos de montaje.  La mayoría de los sistemas de ficheros
      en <filename>/etc/fstab</filename> se montan automáticamente
      en el arranque gracias al «script» &man.rc.8;,
      a menos que contengan la opción <option>noauto</option>.
      Si quiere más información consulte la <xref linkend="disks-fstab"/>.</para>

    <para>Veremos ahora una descripción de los directorios
      más comunes.  Si desea información más
      completa consulte &man.hier.7;.</para>

    <para>
      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Directorio</entry>
	      <entry>Descripción</entry>
	    </row>
	  </thead>
	  <tbody valign="top">
            <row>
	      <entry><filename>/</filename></entry>
	      <entry>Directorio raíz del sistema de ficheros.</entry>
            </row>

	    <row>
	      <entry><filename>/bin/</filename></entry>
              <entry>Utilidades de usuario fundamentales tanto para el
                ambiente monousuario como para el multiusuario.</entry>
	    </row>

	    <row>
	      <entry><filename>/boot/</filename></entry>
              <entry>Programas y ficheros de configuración necesarios
                durante el arranque del sistema operativo.</entry>
	    </row>

	    <row>
	      <entry><filename>/boot/defaults/</filename></entry>
              <entry>Ficheros de configuración por omisión del
                arranque; ver &man.loader.conf.5;.</entry>
	    </row>

	    <row>
	      <entry><filename>/dev/</filename></entry>
	      <entry>Nodos de dispositivo; ver &man.intro.4;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/</filename></entry>
	      <entry>Ficheros de configuración y
               «scripts» del sistema.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/defaults/</filename></entry>
	      <entry>Ficheros de configuración por omisión del sistema;
                ver &man.rc.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/mail/</filename></entry>
              <entry>Ficheros de configuración para agentes de
                transporte de correo como &man.sendmail.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb/</filename></entry>
              <entry>Ficheros de configuración de <command>named</command>;
                ver &man.named.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/periodic/</filename></entry>
              <entry>«Scripts» que se ejecutan diariamente,
                semanalmente y mensualmente mediante &man.cron.8;;
                ver &man.periodic.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/ppp/</filename></entry>
              <entry>Ficheros de configuración de <command>ppp</command>;
                ver &man.ppp.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/mnt/</filename></entry>
              <entry>Directorio vacío utilizado de forma habitual por
                administradores de sistemas como punto de montaje
                temporal.</entry>
	    </row>

	    <row>
	      <entry><filename>/proc/</filename></entry>
              <entry>Sistema de ficheros de procesos; ver &man.procfs.5;,
	      &man.mount.procfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/rescue/</filename></entry>
              <entry>Programas enlazados estáticamente para
                restauraciones de emergencia; ver &man.rescue.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/root/</filename></entry>
              <entry>Directorio local para la cuenta <systemitem class="username">root</systemitem>.</entry>
	    </row>

	    <row>
	      <entry><filename>/sbin/</filename></entry>
              <entry>Programas del sistema y utilidades fundamentales de
                administración para ambientes monousuario y
                multiusuario.</entry>
	    </row>


	    <row>
	      <entry><filename>/tmp/</filename></entry>
              <entry>Ficheros temporales. El contenido de
                <filename>/tmp</filename>
                <emphasis>NO</emphasis> suelen conservarse después
                de un reinicio del sistema.
                Los sistemas de ficheros basados en memoria suelen montarse
                en <filename>/tmp</filename>
                Puede automatizarse mediante variables de
                tmpmfs en &man.rc.conf.5; (o con una entrada en
                <filename>/etc/fstab</filename>; ver &man.mdmfs.8;,
                o para FreeBSD&nbsp;4.X, &man.mfs.8;).</entry>
	    </row>


	    <row>
	      <entry><filename>/usr/</filename></entry>
              <entry>La mayoría de utilidades y aplicaciones de usuario.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/bin/</filename></entry>
              <entry>Aplicaciones comunes, herramientas de programación y
                otras aplicaciones.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/include/</filename></entry>
              <entry>Ficheros «include» estándar de C.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/lib/</filename></entry>
              <entry>Bibliotecas.</entry>
	    </row>


	    <row>
	      <entry><filename>/usr/libdata/</filename></entry>
	      <entry>Ficheros de datos con diversas funciones.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/libexec/</filename></entry>
              <entry>D&aelig;mons del sistema y utilidades del sistema
                (ejecutados por otros programas).</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/local/</filename></entry>

              <entry>Ejecutables locales, bibliotecas, etc.
                también se usa como destino por omisión
                de la infraestructura de ports de &os;.  Dentro de
                <filename>/usr/local</filename> debe seguirse el esquema
                general definido en &man.hier.7; para
                <filename>/usr</filename>. Las
                excepciones son el directorio man, que está
                directamente bajo <filename>/usr/local</filename> en
                lugar de debajo de <filename>/usr/local/share</filename>,
                y la documentación de los ports está en
                <filename>share/doc/port</filename>.
 	      </entry>
	    </row>

	    <row>
	      <entry><filename>/usr/obj/</filename></entry>
              <entry>Arbol destino dependiente de arquitectura fruto de
                la compilación del árbol
                <filename>/usr/src</filename>.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/ports</filename></entry>
              <entry>La colección de Ports de &os; (opcional).</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/sbin/</filename></entry>
              <entry>D&aelig;mons del sistema y utilidades del sistema
                (ejecutados por usuarios del sistema).</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/share/</filename></entry>
              <entry>Ficheros independientes de arquitectura.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/src/</filename></entry>
              <entry>Ficheros fuente BSD y/o local.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/X11R6/</filename></entry>
              <entry>Ejecutables de la distribución X11R6,
                bibliotecas, etc (opcional).</entry>
	    </row>

	    <row>
	      <entry><filename>/var/</filename></entry>
              <entry>Ficheros multipropósito de log, temporales, en
                tránsito y de «spool».
                En ocasiones se monta en
                <filename>/var</filename> un sistema de
                ficheros basado en memoria.</entry>
	    </row>


	    <row>
	      <entry><filename>/var/log/</filename></entry>
              <entry>Diversos ficheros de log del sistema.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/mail/</filename></entry>
              <entry>Ficheros de buzones de correo de usuarios.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/spool/</filename></entry>
              <entry>Directorios diversos del sistema de spool de impresora
                y correo.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/tmp/</filename></entry>
              <entry>Ficheros temporales.  Suelen conservarse tras el
                Estos ficheros suelen conservarse tras el reinicio del
		sistema, a menos que
                <filename>/var</filename> sea un
                sistema de ficheros basado en memoria.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/yp</filename></entry>
	      <entry>Mapas NIS.</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>

  </sect1>

  <sect1 xml:id="disk-organization">
      <title>Organización de disco</title>

      <para>La unidad más pequeña que &os; utiliza para
        ubicar ficheros es el nombre de fichero.  Los nombres de fichero
        son sensibles a las mayúsculas, lo que significa que
        <filename>readme.txt</filename> y <filename>README.TXT</filename>
        son dos ficheros distintos. &os; no utiliza la extensión
        (<filename>.txt</filename>) de un fichero para determinar si
        es un programa, o un documento o alguna otra forma de datos.</para>

      <para>Los ficheros se almacenan en directorios. Un directorio puede
        estar vacío, o puede contener cientos de ficheros.  Un
        directorio también puede contener otros directorios,
        permitiéndole contruir una jerarquía de directorios
        dentro de otro.  Esto hace mucho más fácil la
        organización de sus datos.</para>

      <para>Para referirse a ficheros o directorios se usa el nombre
        de archivo o de directorio, seguido por una barra,
        <literal>/</literal>, seguido por cualquier otro nombre de
        directorio que sea necesario. Si tiene un directorio
        <filename>tal</filename>, el cual contiene el directorio
        <filename>cual</filename>, el cual contiene el fichero
        <filename>readme.txt</filename>, entonces el nombre completo
        o <firstterm>ruta</firstterm> al fichero es
        <filename>tal/cual/readme.txt</filename>.</para>

      <para>Los directorios y ficheros se almacenan en un sistema de ficheros.
        Cada sistema de ficheros contiene un sólo directorio en el nivel
        más elevado, que es el
        <firstterm>directorio raíz</firstterm>
        de ese sistema de ficheros.  Este directorio raíz puede
        contener otros directorios.</para>

      <para>Lo visto hasta ahora probablemente sea similar a cualquier otro
        sistema operativo que pueda haber utilizado, pero hay unas cuantas
        diferencias; por ejemplo, &ms-dos; utiliza <literal>\</literal> para
        separar nombres de fichero y directorio, mientras que &macos; usa
        <literal>:</literal>.</para>

      <para>&os; no utiliza letras de unidades, u otro nombre de unidad
        en la ruta. Por tanto, no podrá escribir
        <filename>c:/tal/cual/readme.txt</filename>
        en &os;.</para>

      <para>En &os;, en cambio, un sistema de ficheros recibe el nombre de
        <firstterm>sistema de ficheros raíz</firstterm>.  El
        directorio raíz del sistema de ficheros raíz se
        representa como <literal>/</literal>. Cualquier otro sistema
        de ficheros, por tanto, se <firstterm>monta</firstterm> bajo el
        sistema de ficheros raíz.  No importa cuántos discos
        tenga en su sistema &os;, cada directorio parecerá ser parte del
        mismo disco.</para>

      <para>Suponga que tiene tres sistemas de ficheros, denominados
        <literal>A</literal>,
        <literal>B</literal> y <literal>C</literal>. Cada sistema de
        ficheros tiene un directorio raíz, el cual contiene
        otros dos directorios, llamados
        <literal>A1</literal>, <literal>A2</literal> (y de la misma manera
        <literal>B1</literal>, <literal>B2</literal> y
	<literal>C1</literal>, <literal>C2</literal>).</para>

      <para>Usaremos <literal>A</literal> como sistema de ficheros
        raíz.  Si usara <command>ls</command> para ver el contenido de
        este directorio vería dos subdirectorios, <literal>A1</literal>
        y <literal>A2</literal>.  El árbol de directorios sería
        como este:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir1"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Un sistema de ficheros debe montarse en un directorio
        de otro sistema de ficheros.  Ahora suponga que monta el
        sistema de ficheros <literal>B</literal> en el directorio
        <literal>A1</literal>.  El directorio raíz de
        <literal>B</literal> reemplaza a <literal>A1</literal>,
        y los directorios en <literal>B</literal> aparecen de
        esta manera:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir2"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Cualquier fichero que esté en el directorio
        <literal>B1</literal> o <literal>B2</literal> puede
        encontrarse con la ruta <filename>/A1/B1</filename> o
        <filename>/A1/B2</filename> según sea necesario.
        Cualquier fichero que esté en <filename>/A1</filename>
        ha desaparecido temporalmente.  Aparecerán de nuevo
        si <literal>B</literal> se <firstterm>desmonta</firstterm>
        de A.</para>

      <para>Si <literal>B</literal> se monta en <literal>A2</literal>
        entonces el diagrama se vería así:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir3"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>y las rutas serían <filename>/A2/B1</filename> y
        <filename>/A2/B2</filename> respectivamente.</para>

      <para>Pueden montarse sistemas de ficheros uno sobre otro.  Continuando
        con el ejemplo anterior, el sistema de ficheros <literal>C</literal>
        podría montarse en el directorio <literal>B1</literal>
        en el sistema de ficheros <literal>B</literal>, lo que nos
        llevaría a esto:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir4"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>O <literal>C</literal> podría montarse directamente
        en el sistema de ficheros <literal>A</literal>, bajo el directorio
        <literal>A1</literal>:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir5"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Si está familiarizado con &ms-dos; esto es similar,
        aunque no idéntico, a utilizar <command>join</command>.</para>

      <para>Esto no es algo a lo deba usted dedicar tiempo de forma habitual.
        Normalmente creará sistemas de ficheros al instalar &os;
        y decidirá dónde montarlos; lo más habitual es que
        no los cambie de sitio a menos que agregue un disco nuevo.</para>

      <para>Es perfectamente posible tener un sistema de ficheros raíz
        extenso y no necesitar crear otros.  Este esquema tiene unos cuantos
        inconvenientes y una ventaja:
        </para>

      <itemizedlist>
	<title>Ventajas de disponer de múltiples sistemas de
         ficheros</title>

	<listitem>
          <para>Si dispone de varios sistemas de ficheros puede optar por
            usar distintas <firstterm>opciones de montaje</firstterm>.
            Por ejemplo, gracias a una planificación cuidadosa, el
            sistema de ficheros raíz puede montarse como
            sólo-lectura, haciendo imposible borrar sin querer o
            editar un fichero crítico.  Al mantener separados
            sistemas de ficheros en los que los usuarios pueden escribir,
            como <filename>/home</filename>, de otros sistemas de ficheros
            también le permite montar con la opción
            <firstterm>nosuid</firstterm>; dicha opción previene
            que los bits <firstterm>suid</firstterm>/<firstterm>guid</firstterm>
            en los ejecutables almacenados en el sistema de ficheros
            tengan efecto, mejorando en cierto modo la seguridad.</para>
	</listitem>

	<listitem>
          <para>&os; optimiza automáticamente el esquema de ficheros
            en un sistema de ficheros, dependiendo de cómo el sistema
            de ficheros esté siendo utilizado.
            Uno que contenga muchos ficheros pequeños tendrá
            una optimización distinta de uno que contenga menos ficheros
	    y más grandes.  Si sólo tiene un gran sistema de
            ficheros no hay manera de aplicar esta optimización.</para>
	</listitem>

	<listitem>
          <para>Los sistemas de ficheros de &os; son muy robustos en caso
            de sufrir un caída eléctrica.  De todas maneras, un fallo
            eléctrico en un momento crítico puede
            dañar la estructura del sistema de ficheros.  Si reparte
            sus datos en múltiples sistemas de ficheros hará
            que sea más probable que el sistema arranque después
            de uno de esos fallos, haciéndole además
            más fácil la tarea de restaurarlo desde
            un respaldo si fuera necesario.</para>
	</listitem>
      </itemizedlist>

      <itemizedlist>
	<title>Ventajas de un sólo sistema de ficheros</title>

	<listitem>
          <para>Los sistemas de ficheros son de un tamaño fijo. Si crea
            un sistema de ficheros cuando instala &os; y le da un tamaño
            específico, tal vez descubra más tarde que necesita
            hacer la partición más grande.  Esto no es
            fácil de realizar sin hacer una copia de seguridad, crear
            de nuevo el sistema de ficheros con el nuevo
            tamaño y entonces restaurar los datos respaldados.</para>

	  <important>
            <para>&os; dispone de &man.growfs.8;, que permite incrementar el
              tamanño de un sistema de ficheros «al vuelo»,
              eliminando esta limitación.</para>
	  </important>
	</listitem>
      </itemizedlist>

      <para>Los sistemas de ficheros están alojados en particiones.
        Este es un detalle muy importante, puesto que el
        término <emphasis>partición</emphasis> no significa
        aquí lo mismo que en otros entornos (por ejemplo, en &ms-dos;)
        debido a la herencia &unix; de &os;. Cada partición se
        identifica con una letra desde <literal>a</literal> hasta
        <literal>h</literal>.  Cada partición puede contener solamente
        un sistema de ficheros, lo que significa que los sistemas de
        ficheros suelen definirse mediante su punto de montaje en la
        jerarquía del sistema de ficheros o por la letra de la
        partición en la que están alojados.</para>

      <para>&os; también utiliza espacio de disco
        como <firstterm>espacio de intercambio (swap)</firstterm>.
        El espacio de intercambio le brinda a &os;
        <firstterm>memoria virtual</firstterm>.  Esto permite al
        su sistema comportarse como si tuviera más memoria de
        la que realmente tiene.  Cuando a &os; se le agota la memoria
        mueve algunos de los datos que no está utilizando en
        ese momento al espacio de intercambio, y los vuelve a poner
        donde estaban (desplazando alguna otra cosa) cuando
        los necesita.</para>

      <para>Algunas particiones tienen ciertas convenciones heredadas.</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*"/>
	  <colspec colwidth="5*"/>

	  <thead>
	    <row>
	      <entry>Partición</entry>

	      <entry>Representación</entry>
	    </row>
	  </thead>

	  <tbody valign="top">
	    <row>
	      <entry><literal>a</literal></entry>

	      <entry>Normalmente contiene el sistema de ficheros raíz</entry>
	    </row>

	    <row>
	      <entry><literal>b</literal></entry>

	      <entry>Normalmente contiene el espacio de intercambio (swap)</entry>
	    </row>

	    <row>
	      <entry><literal>c</literal></entry>

              <entry>Suele tener el mismo tamaño de la
	        «slice» que la encierra.  Esto permite
                a las utilidades que necesitan trabajar en toda la
                «slice»  entera (por ejemplo durante una
                búsqueda de bloques dañados) trabajar en
                la partición <literal>c</literal>. Normalmente no
                debería usted crear un sistema de ficheros en esta
                partición.</entry>
	    </row>

	    <row>
	      <entry><literal>d</literal></entry>

              <entry>La partición <literal>d</literal> solía
                tuvo un significado especial asociado pero ya no lo
		tiene.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Cada partición que contiene un sistema de ficheros
        se almacena en lo que &os; llama una «slice».
        «slice» es en &os; lo que en otros ámbitos se
	denomina partición; es un hecho que deriva de los orígenes
	de &os; como ya sabemos basado en &unix;.</para>

	<indexterm><primary>slices</primary></indexterm>
	<indexterm><primary>particiones</primary></indexterm>
	<indexterm><primary>peligrosamente dedicadas</primary></indexterm>

      <para>Los números de «slice» muestran
        el nombre de dispositivo, al que precede una
        <literal>s</literal> y un número que puede ser un
	1 u otro número mayor.  Por lo tanto
        «da0<emphasis>s1</emphasis>» es la
        primera slice en la primera unidad SCSI.  Sólo
        puede haber cuatro «slice» físicas en un
        disco, pero puede haber «slice» lógicas dentro
        «slice» físicas del tipo apropiado.  Estas
        «slice»extendidas se numeran a partir de 5,
        así que «ad0<emphasis>s5</emphasis>»
        es la primera «slice» extendida en el primer
        disco IDE. Estos dispositivos se usan en sistemas de ficheros
        que se preve que ocupen una slice.</para>

      <para>Tanto las «slice» y las unidades físicas
        «peligrosamente dedicadas», como otras unidades
        contienen <firstterm>particiones</firstterm>, que se designan
        mediante letras desde la <literal>a</literal>
        hasta <literal>h</literal>.  Esta letra se añade al nombre
        del dispositivo.  Se verá mucho mejor mediante ejemplos:
        «da0<emphasis>a</emphasis>» es la partición
        a en la primera unidad da y es una de esas a las que llamamos
        «peligrosamente dedicada».
        «ad1s3<emphasis>e</emphasis>» es la quinta
        partición en la tercera slice de la segunda
        unidad de disco IDE.</para>

      <para>Para terminar, cada disco en el sistema tiene también
        su designación.
        El nombre de disco comienza por un código que indica
        el tipo de disco, luego un número, que indica qué disco
        es.  A diferencia de las «slice», la numeración de
        discos comienza desde 0.  Puede las numeraciones más comunes en
	el <xref linkend="basics-dev-codes"/>.</para>

      <para>Cuando se hace referencia a una partición, &os;
        necesita que también se nombre la «slice»
	y el disco que contiene la partició.  Esto se hace
        con el nombre de disco, <literal>s</literal>, el número
        «slice» y por último la letra de la
        partición.  Tiene varios casos en el
	<xref linkend="basics-disk-slice-part"/>.</para>

      <para>En el <xref linkend="basics-concept-disk-model"/> muestra un modelo
        conceptual del esquema de un disco que debería ayudarle a
        aclarar las cosas.</para>

      <para>Antes de instalar &os; tendrá que configurar las
        «slice» de disco, después crear particiones
	dentro de las «slice» que vaya a usar en &os; y luego
	crear un sistema de ficheros (o swap) en cada partición y
	luego decidir cuál va a ser el punto de montaje del sistema
	de ficheros.</para>

      <table frame="none" pgwide="1" xml:id="basics-dev-codes">
	<title>Códigos de dispositivos de disco</title>

	<tgroup cols="2">
          <colspec colwidth="1*"/>
          <colspec colwidth="5*"/>

	  <thead>
	    <row>
	      <entry>Código</entry>

	      <entry>Significado</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><filename>ad</filename></entry>

	      <entry>Disco ATAPI (IDE)</entry>
	    </row>

	    <row>
	      <entry><filename>da</filename></entry>

	      <entry>Disco de acceso directo SCSI</entry>
	    </row>

	    <row>
	      <entry><filename>acd</filename></entry>

	      <entry>CDROM ATAPI (IDE)</entry>
	    </row>

	    <row>
	      <entry><filename>cd</filename></entry>

	      <entry>CDROM SCSI</entry>
	    </row>

	    <row>
	      <entry><filename>fd</filename></entry>

	      <entry>Disquete (floppy)</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <example xml:id="basics-disk-slice-part">
	<title>Ejemplo de nombres de disco, «slice» y partición</title>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
            <colspec colwidth="1*"/>
            <colspec colwidth="5*"/>

	    <thead>
	      <row>
		<entry>Nombre</entry>

		<entry>Significado</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><literal>ad0s1a</literal></entry>

                <entry>La primera partición (<literal>a</literal>) en
                  la primera slice (<literal>s1</literal>) en el
                  primer disco IDE (<literal>ad0</literal>).</entry>
	      </row>

	      <row>
		<entry><literal>da1s2e</literal></entry>

                <entry>La quinta partición (<literal>e</literal>) en
                  la segunda slice (<literal>s2</literal>) en el
                  segundo disco SCSI (<literal>da1</literal>).</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </example>

      <example xml:id="basics-concept-disk-model">
	<title>Modelo conceptual de un disco</title>

        <para>Este diagrama muestra cómo ve &os; el primer disco IDE
          en el sistema.  Se asume que el disco es de 4&nbsp;GB,
          y contiene dos «slices» de 2&nbsp;GB (particiones &ms-dos;).
          La primera partición contiene un disco &ms-dos;,
          <filename>C:</filename>,
          y la segunda partición contiene una instalación  de &os;.
          Esta instalación de ejemplo tiene tres particiones, y una
          partición swap.</para>

        <para>Cada una de las tres particiones tiene un sistema de ficheros.
          La partición <literal>a</literal> se utilizará
          para el sistema de ficheros raíz, <literal>e</literal>
          para la jerarquía del directorio <filename>/var</filename>,
          y <literal>f</literal> para la jerarquía del directorio
          <filename>/usr</filename>.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="install/disk-layout"/>
          </imageobject>

          <textobject>
	    <literallayout class="monospaced">.-----------------.  --.
|                 |    |
|  DOS / Windows  |    |
:                 :     &gt;  Primera partición, ad0s1
:                 :    |
|                 |    |
:=================:  ==:                               --.
|                 |    |  Partición a, montada como /      |
|                 |     &gt; recibe el nombre de  ad0s2a          |
|                 |    |                                 |
:-----------------:  ==:                                 |
|                 |    |  Partición b, usada como swap      |
|                 |     &gt; recibe el nombre de ad0s2b          |
|                 |    |                                 |
:-----------------:  ==:                                 |  Partición c, sin
|                 |    |  Partición e, usada como /var       &gt; sistema de archivos, la
|                 |     &gt; recibe el nombre de ad0s2e          |  porción completa de FreeBSD,
|                 |    |                                 |  ad0s2c
:-----------------:  ==:                                 |
|                 |    |                                 |
:                 :    |  Partición f, usada como /usr      |
:                 :     &gt; referida como ad0s2f          |
:                 :    |                                 |
|                 |    |                                 |
|                 |  --'                                 |
`-----------------'                                    --'</literallayout>
          </textobject>
        </mediaobject>
      </example>
  </sect1>



  <sect1 xml:id="mount-unmount">
    <title>Montaje y desmontaje de sistemas de ficheros</title>

    <para>El sistema de ficheros se visualiza mejor como un
      árbol enraizado, tal y como esá, en
      <filename>/</filename>.
      <filename>/dev</filename>, <filename>/usr</filename> y todos
      los demás directorios en el directorio raíz son
      raamas, las cuales pueden tener sus propias ramas, como
      <filename>/usr/local</filename> y así sucesivamente.</para>

    <indexterm><primary>sistema de ficheros raíz</primary></indexterm>

    <para>Existen varias razones para albergar algunos de
      estos directorios en sistemas de ficheros separados.
      <filename>/var</filename> contiene los directorios
      <filename>log/</filename>, <filename>spool/</filename> y
      varios tipos de ficheros temporales y pueden llegar a desbordarse.
      Agotar el espacio del sistema de ficheros raíz
      no es nada bueno desde cualquier  punto de vista, así que
      separar <filename>/var</filename> de
      de <filename>/</filename> es algo que debería
      hacerse siempre que sea posible.</para>

    <para>Otra razón para meter ciertos árboles
      de directorios en otros sistemas de ficheros es si van a estar
      albergados en discos físicos separados, o si son discos
      virtuales separados, como un montaje por
      <link linkend="network-nfs">NFS</link> en el caso de unidades
      de CDROM.</para>

    <sect2 xml:id="disks-fstab">
      <title>El fichero <filename>fstab</filename></title>
      <indexterm>
	<primary>sistemas de ficheros</primary>
	<secondary>montaje con fstab</secondary>
      </indexterm>

      <para>Durante el <link linkend="boot">proceso de arranque</link>
        los sistemas de ficheros listados en <filename>/etc/fstab</filename>
        se montan automáticamente (a menos que estén
        listados con la opción <option>noauto</option>).</para>

      <para><filename>/etc/fstab</filename> contiene una
        lista de líneas con el siguiente formato:</para>

      <programlisting><replaceable>dispositivo</replaceable>       <replaceable>/punto-de-montaje</replaceable> <replaceable>punto de montaje</replaceable>     <replaceable>opciones</replaceable>      <replaceable>dumpfreq</replaceable>     <replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>dispositivo</literal></term>
	  <listitem>
            <para>Un nombre de dispositivo (<emphasis>debe existir</emphasis>).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>punto-de-montaje</literal></term>

	  <listitem><para>Un directorio (que debe existir) en
              el que montar el sistema de ficheros.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>tipo de sistema ficheros</literal></term>

          <listitem><para>El tipo de sistema de ficheros es un parámetro
                que interpretará &man.mount.8;.  El sistema de
                ficheros por omisión de &os; es
                <literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>opciones</literal></term>

          <listitem><para>Ya sea <option>rw</option> para sistemas
              de ficheros de lectura-escritura, o <option>ro</option>
              para sistemas de ficheros de sólo lectura, seguido
              de cualquier otra opción que sea necesaria.
              Una opción muy habitual es <option>noauto</option>,
              que se suele usar en sistemas de ficheros que no se deben
              montar durante la secuencia de arranque.  Tiene otras
              opciones en la página de manual de
              &man.mount.8;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>dumpfreq</literal></term>

         <listitem><para>&man.dump.8; la usa para determinar qué
             sistema de ficheros requieren volcado.  Si el campo no
             está declarado se asume un valor de cero.</para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>passno</literal></term>

         <listitem>
           <para>Determina el orden en el cual los sistemas de
             ficheros deben revisarse.  Los sistemas de ficheros
             que hayan de saltarse deben tener su <literal>passno</literal>
             a cero.  El sistema de ficheros raíz (que obviamente
             debe ser revisado antes que cualquier otro) debe tener
             su <literal>passno</literal> puesto a uno, y los demás
             sistemas de ficheros deben tener valores mayores que uno.
             Si más de un sistema de ficheros tiene el mismo
             <literal>passno</literal> &man.fsck.8; tratará
             de revisarlos en paralelo en caso de ser posible.
             </para>
         </listitem>
	</varlistentry>
      </variablelist>

      <para>Consulte la página de manual de &man.fstab.5; para
        mayor información sobre el formato del fichero
        <filename>/etc/fstab</filename> y las opciones que contiene.</para>
    </sect2>

    <sect2 xml:id="disks-mount">
      <title>La orden <command>mount</command></title>
      <indexterm>
	<primary>sistemas de ficheros</primary>
	<secondary>montaje</secondary>
      </indexterm>

      <para>&man.mount.8; es al fin y al cabo quien monta los sistemas
        de ficheros.</para>

      <para>En su forma más básica se usa lo siguiente:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount dispositivo punto-de-montaje</userinput></screen>
      </informalexample>

      <para>Existe una gran cantidad de opciones (las encontrará
        todas en &man.mount.8;) pero las más comunes son:</para>

      <variablelist>
	<title>Opciones de montaje</title>

	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
            <para>Montar todos los sistemas de ficheros
              que aparezcan en <filename>/etc/fstab</filename>,
              excepto aquellos marcados como «noauto»,
              excluidos por el parámetro <option>-t</option> o
              aquellos que ya estén montados.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

	  <listitem>
            <para>Realizar todo excepto la llamada real de montaje del
              sistema.  Esta opción es muy útil en caso
	      de problemas si se combina con la  opción
              <option>-v</option> para determinar qué es lo que
              &man.mount.8; está haciendo realmente.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
            <para>Forzar el montaje de un sistema de ficheros inestable
              (por ejemplo uno que da errores tras un reinicio súbito,
	      algo que es bastante <emphasis>peligroso</emphasis>), o forzar
              la revocación de accesos de escritura cuando se cambia
              el estado de un sistema de ficheros de lectura-escritura
              a solo lectura.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
          <term><option>-r</option></term>

	  <listitem>
            <para>Montar el sistema de ficheros como sólo lectura.
              Esto es idéntico a utilizar el argumento
              <option>ro</option>
              (<option>rdonly</option> para versiones anteriores a
              &os;&nbsp;5.2) en la opción <option>-o</option>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>tipo de sistema de ficheros</replaceable></term>

	  <listitem>
            <para>Montar un sistema de ficheros dado con el tipo de
              sistema de ficheros, o montar solamente sistemas
              de ficheros del tipo dado si se proporciona la
              opción <option>-a</option>.</para>

            <para>«ufs» es el sistema de ficheros
              por omisión.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
            <para>Actualizar puntos de montaje en el sistema
              de ficheros.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Mostrar mayor información.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>Montar el sistema de ficheros como lectura-escritura.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>La opción <option>-o</option> toma una lista las siguientes
        opciones separada por comas:</para>

      <variablelist>
	<varlistentry>
	  <term>nodev</term>

	  <listitem>
            <para>No interpretar dispositivos especiales en el sistema
              ficheros.  Es una opción de seguridad que puede
              ser muy útil.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>noexec</term>

	  <listitem>
              <para>No permitir la ejecución de binarios
                en este sistema de ficheros.  Esta también
                es una opción de seguridad útil.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
            <para>No interpretar bits setuid o setgid en el
              sistema de ficheros.  Esta también es una
              opción de seguridad útil.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 xml:id="disks-umount">
      <title>La orden <command>umount</command></title>
      <indexterm>
	<primary>sistemas de ficheros</primary>
	<secondary>desmontar</secondary>
      </indexterm>

      <para>&man.umount.8; toma como parámetro un
        punto de montaje, un nombre de dispositivo, o la opción
        <option>-a</option> o <option>-A</option>.</para>

      <para>Todas las formas toman <option>-f</option> para forzar
        el desmontaje y <option>-v</option> para mostrar más
        información.  Tenga muy en cuenta que usar <option>-f</option>
        no suele ser una forma recomendable de proceder.  Desmontar a la
        fuerza los sistemas de ficheros puede acarrear el congelar la
        máquina o dañar los datos en el sistema de
        ficheros.</para>

      <para><option>-a</option> y <option>-A</option> se usan para
        desmontar todos los sistemas de ficheros montados,
        con la ventaja de poder elegir el tipo de sistema de ficheros
        que se use tras <option>-t</option>.  De todas maneras
        <option>-A</option> no trata de desmontar el sistema de
        ficheros raíz.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="basics-processes">
    <title>Procesos</title>

    <para>&os; es un sistema operativo multitarea.  Esto significa que
      parece como si más de un programa se estuviera ejecutando al
      mismo tiempo.  Cada programa uno de esos programas que se está
      ejecutando en un momento dado se denomina
      <firstterm>proceso</firstterm>.  Cada orden que ejecuta iniciará
      al menos un proceso nuevo, y hay muchos procesos que se están
      que se están ejecutando en todo momento, manteniendo
      el sistema en funcionamiento.</para>

    <para>Cada proceso tiene un identificador individual consistente en
      un número llamado <firstterm>ID del proceso</firstterm>,
      o <firstterm>PID</firstterm>, y al igual que sucede con los
      ficheros, cada proceso tiene un propietario y un grupo.  La
      información de propietario y grupo se usa para determinar
      qué ficheros y dispositivos puede abrir el proceso
      mediante los permisos de fichero explicados anteriormente.  La
      mayoría de los procesos también tiene un proceso
      padre.  El proceso padre es el proceso que los inició.  Por
      ejemplo, si está tecleando órdenes en la shell,
      la shell es un proceso, y cualquier orden que usted ejecute
      también lo será.  De este modo cada proceso que ejecute
      tendrá como proceso padre a su shell.   La excepción
      es un proceso especial llamado &man.init.8;.  <command>init</command>
      es siempre el primer proceso, así que su PID siempre es 1.
      El kernel arranca automáticamente <command>init</command>
      en el arranque de &os;.</para>

    <para>Hay dos órdenes particularmente útiles para ver
      los procesos en el sistema, &man.ps.1; y &man.top.1;.
      <command>ps</command> se usa para mostrar una lista estática
      de los procesos que se ejecutan en el sistema en es momento, y
      puede mostrar sus PID, cuánta memoria está usando,
      la línea de órdenes con la que fueron iniciados y
      muchas más cosas.  <command>top</command> despliega todos
      los procesos que se están ejecutando y actualiza la
      pantalla cada pocos segundos para que pueda ver lo que
      está haciendo su sistema.</para>

    <para>Por omisión <command>ps</command> solo le muestra las
      órdenes que están ejecutando
      <emphasis>y</emphasis> que sean propiedad de su usuario.
      Por ejemplo:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Como puede ver en este ejemplo la salida de &man.ps.1; está
      organizada en columnas.  <literal>PID</literal>
      es el ID de proceso anteriormente expuesto.  Los PIDs se asignan
      a partir del 1 y hasta 99999, y vuelven a comenzar desde el 1 otra
      cuando se terminan los números.  La columna
      <literal>TT</literal> muestra la tty en la que el programa se está
      ejecutando; podemos ignorarla tranquilamente por el momento.
      <literal>STAT</literal> muestra el estado del programa; de momento
      también podemos ignorarlo.  <literal>TIME</literal> es la
      cantidad de tiempo que el programa ha se ha estado ejecutando en la
      CPU (generalmente no es el tiempo transcurrido desde que se
      inició el programa, ya que la mayoría de los
      programas pasan mucho tiempo esperando antes
      de que necesiten gastar tiempo en la CPU.  Finalmente,
      <literal>COMMAND</literal> es la línea de órdenes que
      se empleó para ejecutar el programa.</para>

    <para>&man.ps.1; admite muchas opciones sobre la información
      que se desea ver.  Uno de los conjuntos más
      útiles es <literal>auxww</literal>.  <option>a</option>
      muestra información acerca de todos los procesos
      ejecutándose, no solamente los suyos.  <option>u</option>
      despliega el nombre de usuario del propietario del proceso, así
      como el uso de memoria.  <option>x</option> despliega información
      acerca de los procesos d&aelig;mon y <option>ww</option> hace que
      &man.ps.1; despliegue la línea de órdenes completa, en lugar
      de truncarla cuando es demasiado larga para caber en la pantalla.</para>

    <para>La salida de &man.top.1; es similar.  Veamos un ejemplo:
      </para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>La salida está dividida en dos secciones. La cabecera (las
      primeras cinco líneas) muestra el PID del último proceso
      en ejecutarse, la carga promedio del sistema (una medida de la carga
      del sistema), el «uptime» del sistema (tiempo
      desde el último reinicio) y la hora actual.  Las otras cifras
      en la cabecera se relacionan con cuántos procesos hay en
      ejecución en el sistema (47 en este caso), cuánta
      memoria y espacio de intercambio (swap) está en uso, y
      cuánto tiempo está el sistema en diferentes estados de
      CPU.</para>

    <para>Más abajo hay una serie de columnas con información
      similar a la salida de &man.ps.1;. Igual que antes, puede usted
      ver el PID, el nombre de usuario, la cantidad de tiempo de CPU
      en uso y la orden que se ejecutó.  &man.top.1;
      también mostrará por omisión la cantidad de espacio
      de memoria que emplea cada proceso.  Está dividido en dos
      columnas, una para el tamaño total y otra para el tamaño
      residente (el tamaño total es cuánta memoria
      ha necesitado la aplicación y el tamaño residente
      es cuánta se está usando en ese momento concreto).
      En este ejemplo puede verse que <application>&netscape;</application>
      requerido casi 30&nbsp;MB de RAM, pero actualmente solo está usando
      9&nbsp;MB.</para>

    <para>&man.top.1; actualiza automáticamente el listado cada
      dos segundos, pero este lapso puede cambiarse mediante la
      opción <option>s</option>.</para>
  </sect1>

  <sect1 xml:id="basics-daemons">
    <title>D&aelig;mons, señales y cómo matar procesos</title>

    <para>cuando ejecuta un editor es fácil controlarlo,
      decirle que cargue ficheros y demás.  Puede hacerse
      porque el editor permite ese control y porque el editor
      depende de una <firstterm>terminal</firstterm>.  Algunos
      programas no están diseñados para ejecutarse
      entradas continuas por parte del usuario, así que se desconectan
      de la terminal a la primera oportunidad.  Por ejemplo, un servidor
      web pasa todo el dia respondiendo peticiones web y normalmente
      no necesita que usted le haga caso.  Los programas que transportan
      correo electrónico de un sitio a otro son otro ejemplo de
      esta clase de aplicación.</para>

    <para>Llamamos a estos programas <firstterm>d&aelig;mons</firstterm>.
      Los D&aelig;mons eran personajes de la mitología griega;
      no eran ni buenos ni malos, eran pequeños espíritus
      sirvientes que, en gran medida, hacían cosas útiles por
      la humanidad. Algo muy parecido a cómo los servidores web y
      los servidores de correo hacen hoy día tantas cosas
      útiles para nosotros.  Por eso, desde hace mucho tiempo la
      mascota de BSD es ese d&aelig;mon de aspecto tan ufano con su tridente
      y su cómodo calzado deportivo.</para>

    <para>Hay una norma según la cual se da nombre a los programas que
      suelen ejecutarse como d&aelig;mons con una «d» final.
      <application>BIND</application> es el d&aelig;mon de nombres de
      Berkeley (y el programa que en realidad se ejecuta se llama
      <command>named</command>); el servidor web
      <application>Apache</application> se llama
      <command>httpd</command>, el d&aelig;mon de «spool» de
      impresora de línea es <command>lpd</command> y así
      sucesivamente.  Se trata de un acuerdo,  no una ley férrea; por
      ejemplo el d&aelig;mon principal de correo de
      <application>Sendmail</application> se llama
      <command>sendmail</command>, y no <command>maild</command>,
      como podría suponerse visto lo precedente.</para>

    <para>Algunas veces necesitará comunicarse con un d&aelig;mon.
      Estas comunicaciones se denominan <firstterm>señales</firstterm>;
      es posible comunicarse con un d&aelig;mon (o con cualquier otro proceso
      ejecutándose) mandándole una señal.  Existen
      diversos tipos de señales diferentes que puede mandar: algunas
      tienen un significado especial, otras son interpretadas por
      la aplicación y la documentación de la aplicación
      le dirá cómo interpreta la señal esa
      aplicación).  Solamente puede enviar una señal a un
      del que sea usted propietario.  Si manda una señal a un proceso
      de otro usuario con &man.kill.1; o &man.kill.2; verá un mensaje
      del sistema en el que se le comunica que no tiene permiso para hacer
      tal cosa.  La excepción a esto es el usuario
      <systemitem class="username">root</systemitem>, que puede mandar señales a los
      procesos de cualquier usuario del sistema.</para>

    <para>&os; también enviará señales de
      aplicación en determinados casos.  Si una aplicación
      está mal escrita y trata de acceder a  memoria a la que no
      está previsto que acceda &os; manda al proceso la señal
      <firstterm>Violación de segmento</firstterm>
      (<literal>SIGSEGV</literal>).  Si una aplicación ha utilizado
      la llamada de sistema &man.alarm.3; para ser avisada después
      de que un periodo de tiempo haya transcurrido se le
      mandará la señal de alarma (<literal>SIGALRM</literal>),
      y así sucesivamente.</para>

    <para>Hay dos señales que pueden usarse para detener un proceso,
      <literal>SIGTERM</literal> y <literal>SIGKILL</literal>.
      <literal>SIGTERM</literal> es la manera amable de matar un proceso;
      el proceso puede <emphasis>recibir</emphasis> la señal,
      darse cuenta que usted quiere que se apague, cerrar cualquier
      fichero de log que pueda tener abierto y generalmente terminar
      cualquier tarea que esté realizando en ese momento antes
      de apagarse.  En algunos casos un proceso puede incluso ignorar
      <literal>SIGTERM</literal> si se encuentra inmerso en una
      tarea que no puede ser interrumpida.</para>

    <para>Por el contrario, un proceso no puede ignorar una señal
    <literal>SIGKILL</literal>.
      Esta es la señal «No me importa lo que estás
      haciendo, detente ahora mismo».  Si manda un
      <literal>SIGKILL</literal> a un proceso &os; detendrá ese
      proceso inmediatamente.<footnote>
      <para>Esto no es del todo cierto (ciertas cosas no pueden
        ser interrumpidas.  Por ejemplo, si el proceso está tratando
        de leer desde un fichero que está en otro sistema de
        la red, y el otro sistema no está disponible por
        alguna razón (por estar apagada, o que la red tenga un fallo),
        tenemos un caso de lo que llamamos
        «proceso ininterrumpible».
        Más tarde, al proceso se le acabará el tiempo de
        espera, generalmente pasados dos minutos.  Tan pronto como esto
        ocurra el proceso será liquidado.</para>
      </footnote>.</para>

    <para>Otras señales que puede usar:
      <literal>SIGHUP</literal>, <literal>SIGUSR1</literal> y
      <literal>SIGUSR2</literal>.  Son señales de propósito
      general, y aplicaciones diferentes pueden hacer cosas diferentes
      cuando se utilicen.</para>

    <para>Suponga que ha cambiado el fichero de configuración de su
      servidor web; es un buen momento para decirle al servidor
      web que lea y aplique la  configuración.  Podría detener y
      reiniciar <command>httpd</command>, pero esto implicaría
      un período breve de suspensión del servicio de su
      servidor web, lo cual puede no ser asumible.  La mayoría de
      los d&aelig;mons fueron creados pensando en que fueran capaces de
      responder a la señal
      <literal>SIGHUP</literal> releyendo su fichero de configuración.
      En lugar de matar y reiniciar <command>httpd</command>
      le podría mandar la  señal <literal>SIGHUP</literal>.
      Dado que no hay una manera estándar para responder a estas
      señales, diferentes d&aelig;mons tendrán diferente
      comportamiento, así que asegúrese de leer la
      documentación del d&aelig;mon en cuestión.</para>

    <para>Las señales se envian mediante &man.kill.1;,
      como puede verse en el siguiente ejemplo.</para>

    <procedure>
      <title>Envío de una señal a un proceso</title>

      <para>Este ejemplo muestra como enviar una señal a
        &man.inetd.8;.  El fichero de configuración de
        <command>inetd</command> es
        <filename>/etc/inetd.conf</filename> e <command>inetd</command>
        releerá dicho fichero de configuración cuando
        se le envíe un <literal>SIGHUP</literal>.</para>

      <step>
        <para>Identifique el ID de proceso del proceso al que quiere
          enviarle la señal mediante &man.ps.1; y
          &man.grep.1;.  &man.grep.1; se usa para buscar cadenas de
          texto de su elección en la salida estándar.
          Puede ejecutarse como un usuario normal, mientras que
          &man.inetd.8; se ejecuta como <systemitem class="username">root</systemitem>,
          así que debe pasarle los parámetros
          <option>ax</option> a &man.ps.1;.</para>

	<screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

        <para>Vemos que el PID de &man.inetd.8; es 198.  En algunos casos
          <literal>grep inetd</literal> también
          puede aparecer en esta salida.  Esto se debe a la manera en que
          &man.ps.1; tiene que encontrar la lista de procesos
          ejecutándose.</para>
      </step>

      <step>
        <para>Utilice &man.kill.1; para enviar la señal.  Debido a que
          &man.inetd.8; está siendo ejecutado po
          <systemitem class="username">root</systemitem> tendrá que usar primero
          &man.su.1; para volverse <systemitem class="username">root</systemitem>.</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

        <para>Del mismo modo que la mayoría de órdenes &unix;
          &man.kill.1; no imprimirá ninguna salida si ha funcionado
          bien.
          Si envía una señal a un proceso del que no es
          el propietario verá lo siguiente: <errorname>kill:
          <replaceable>PID</replaceable>: Operation not permitted</errorname>.
          Si no teclea bien el PID puede enviar la señal a un
          proceso equivocado, lo cual puede ser malo, o si tiene suerte,
          habrá enviado la señal a un proceso que no está
          en uso y verá el sistema le dir&acute; <errorname>kill:
          <replaceable>PID</replaceable>: No such process</errorname>.</para>

	<note>
	  <title>¿Por qué utilizar <command>/bin/kill</command>?</title>

          <para>Muchas shells incorporan su propio <command>kill</command>;
            esto es, el shell mandará la señal directamente,
            en lugar de ejecutar
            <filename>/bin/kill</filename>.  Esto puede ser útil
            pero las diferentes shells tienen diferentes sintaxis para
            especificar el nombre de la señal que envían.  En
            lugar de tratar de aprederse todas ellas, es más
            fácil simplemente usar
            <command>/bin/kill ...</command>
            sea la que sea la shell que prefiera usar.</para>
	</note>
      </step>
    </procedure>

    <para>El envío de otras señales es muy similar;
      sustituya <literal>TERM</literal> o <literal>KILL</literal>
      en la línea de órdenes según sea necesario.</para>

    <important>
      <para>Matar procesos aleatorios en el sistema es una mala
        idea.  En particular, &man.init.8;, ID de proceso 1, es muy
        especial.  Ejecutar <command>/bin/kill -s KILL 1</command> es
        una manera rápida de apagar su sistema.
        <emphasis>Siempre</emphasis> revise dos veces los argumentos con
        los que ejecuta &man.kill.1; <emphasis>antes</emphasis>
	de pulsar <keycap>Intro</keycap>.</para>
    </important>
  </sect1>

  <sect1 xml:id="shells">
    <title>Shells</title>
    <indexterm><primary>shells</primary></indexterm>
    <indexterm><primary>línea de órdenes</primary></indexterm>

    <para>En &os; gran parte del trabajo diario se hace en una
      interfaz de línea de órdenes llamada shell.  El trabajo
      principal de la shell es ir recibiendo órdenes mediante un
      canal de entrada y ejecutarlos.
      Muchas shells también tienen funciones integradas para ayudar
      ayudar con las tareas diarias como manipulación de ficheros,
      gestión de archivos con expresiones regulares,
      edición en la propia línea de órdenes, macros de
      órdenes y variables de entorno.
      &os; incluye diversas shells, como <command>sh</command>,
      el shell Bourne y <command>tcsh</command>, el shell C mejorado.
      Hay muchas otras shells disponibles en la colección de
      ports de &os;, como <command>zsh</command> y
      <command>bash</command>.</para>

    <para>?Qué shell usar? es una cuestión
      de gustos.  Si va a programar en C puede preferir usar una shell
      tipo C, como <command>tcsh</command>.
      Si viene del mundo Linux o si es nuevo en la interfaz de línea
      de órdenes de &unix; puede probar con <command>bash</command>.
      Tenga en cuenta que cada shell posee unas propiedades únicas que
      pueden o no funcionar con su entorno de trabajo preferido y que
      puede usted elegir qué shell usar.</para>

    <para>Una de las propiedades comunes de las shell es que completan los
      nombres de fichero.  Una vez que ha introducido las primeras letras
      de una orden o del nombre de un fichero, se puede hacer que la shell
      complete automáticamente el resto de la orden o nombre de fichero
      pulsando la tecla <keycap>Tab</keycap>.
      Veamos un ejemplo.  Suponga que tiene dos ficheros
      llamados <filename>talcual</filename> y <filename>tal.cual</filename>.
      Usted quiere borrar <filename>tal.cual</filename>.  Lo que
      habría que teclear es:
      <command>rm ta[tabulador].[tabulador]</command>.</para>

    <para>La shell mostraría en pantalla <command>rm
      ta[BIP].cual</command>.</para>

    <para>El [BIP] es la campana de la consola, es decir, la shell
      está diciéndome que no pudo completar totalmente el nombre
      de fichero porque hay más de una coincidencia.
      Tanto <filename>talcual</filename> como <filename>tal.cual</filename>
      comienzan por <literal>ta</literal>, pero solo se pudo completar
      hasta <literal>tal</literal>.  Si se teclea <literal>.</literal>,
      y de nuevo <keycap>tabulador</keycap> la shell es capaz de
      añadir el resto del nombre de fichero.</para>
    <indexterm><primary>variables de entorno</primary></indexterm>

    <para>Otra función de  la shell son las variables de entorno.
      Las variables de entorno son parejas de valores clave almacenados
      en el espacio de entorno del shell.  Este espacio puede ser leído
      por cualquier programa invocado por la shell y por lo tanto
      contiene mucha configuración de programas. Esta es una lista
      de las variables de entorno más comunes y su
      significado:</para>
    <indexterm><primary>variables de entorno</primary></indexterm>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Variable</entry>
	    <entry>Descripción</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
            <entry>Nombre de usuario en el sistema.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
            <entry>Lista de directorios, separados por punto y coma, en los que
              se buscan ejecutables.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
            <entry>Nombre de red de la pantalla X11 a la que conectarse,
              si está disponible.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
            <entry>La shell actual.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
            <entry>El nombre de la terminal del usuario. Se usa para determinar
              las características de la terminal.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
            <entry>Base de datos donde encontrar los códigos de
              escape necesarios para realizar diferentes funciones en la
              terminal.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
            <entry>Tipo de sistema operativo.  Por ejemplo, &os;.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
            <entry>Arquitectura de CPU en la que se está ejecutando
              el sistema.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
            <entry>El editor de texto preferido por el usuario.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
            <entry>El paginador de texto preferido por el usuario.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
            <entry>Lista de directorios separados por punto y coma
              en los que se buscan páginas de manual.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>Shells Bourne</primary></indexterm>
    <para>Establecer una variable de entorno difiere ligeramente
      de shell a shell. Por ejemplo, en las shells al estilo C
      como <command>tcsh</command> y <command>csh</command>,
      se usa <command>setenv</command> para establecer
      las variables de entorno.  Bajo shells Bourne como
      <command>sh</command> y <command>bash</command>, se
      usa <command>export</command> para establecer
      las variables de entorno actuales.  Por ejemplo, para
      establecer o modificar la variable de entorno
      <envar>EDITOR</envar> (bajo <command>csh</command> o
      <command>tcsh</command>) la siguiente orden establece
      <envar>EDITOR</envar> como
      <filename>/usr/local/bin/emacs</filename>:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Bajo shells Bourne:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>También se puede hacer que la mayoría de las shells
      muestren el contenido de una variable de entorno situando el
      carácter <literal>$</literal> delante del nombre de la variable
      en la línea de órdenes.  Por ejemplo,
      <command>echo $TERM</command>
      mostrará cualquiera que sea el valor que
      haya establecido para <envar>$TERM</envar>, porque la shell
      expande el valor  de <envar>$TERM</envar> y se lo pasa al
      programa <command>echo</command>.</para>

    <para>Las shells manejan muchos caracteres especiales, llamados
      metacaracteres, como representaciones especiales de datos.  El más
      común es el caracter <literal>*</literal>, que representa
      cualquier número de caracteres en un nombre de fichero.  Estos
      metacaracteres especiales se pueden usar para la expansión de
      nombres de fichero.  Por ejemplo, teclear <command>echo *</command> es
      casi lo mismo que introducir <command>ls</command> porque la shell
      toma todos los ficheros que coinciden con <command>*</command> y se
      los pone en la línea de órdenes para que
      <command>echo</command> los vea.</para>

    <para>Para evitar que la shell interprete estos caracteres especiales
      pueden escamotearse anteponiéndoles una contrabarra
      (<literal>\</literal>).  <command>echo $TERM</command> imprime
      el nombre de terminal que esté usando.
      <command>echo \$TERM</command> imprime <envar>$TERM</envar>,
      literalmente.</para>

    <sect2 xml:id="changing-shells">
      <title>Cómo cambiar su shell</title>

      <para>La manera más fácil de cambiar de shell es
        mediante <command>chsh</command>.  <command>chsh</command>
        le colocará dentro del editor que esté configurado en
        la variable de entorno <envar>EDITOR</envar>; si no la ha modificado,
        el sistema ejecutará <command>vi</command>, el editor por
        omisión.  Cambie la línea «Shell:» según
        sus gustos.</para>

      <para>También se le puede suministrar a <command>chsh</command>
        la opción <option>-s</option>; ésto establecerá la
        shell sin necesidad de entrar en el editor de texto.
        Si por ejemplo quiere que <command>bash</command> sea su shell por
        omisión puede configurarlo del siguiente modo:</para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <para>Ejecutar <command>chsh</command> sin parámetros y
        editar la shell desde ahí también funciona.</para>

      <note>
        <para>La shell que se desee usar <emphasis>debe</emphasis> estar
          incluida en <filename>/etc/shells</filename>.
          Si se ha instalado una shell desde la
          <link linkend="ports">colección de ports</link>
          esto deberí estar hecho automáticamente.  Si ha
          instalado la shell manualmente, tendrá usted que
          realizar el cambio oportuno en
          <filename>/etc/shells</filename>.</para>

      <para>Por ejemplo, si instaló manualmente <command>bash</command>
        y lo ubicó en <filename>/usr/local/bin</filename>
        debería hacer lo siguiente:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Hecho esto vuelva a ejecutar <command>chsh</command>.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 xml:id="editors">
    <title>Editores de texto</title>
    <indexterm><primary>editores de texto</primary></indexterm>
    <indexterm><primary>editores</primary></indexterm>

    <para>Gran parte de la configuración de &os; se realiza
      modificando ficheros de texto, así que le conviene
      familiarizarse con alguno de ellos.  &os; viene con unos cuantos
      como parte del sistema base y encontrará muchos más
      en la colección de ports.</para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>ee</command></secondary>
    </indexterm>
    <para>El editor de textos más sencillo y fácil de
      aprender es uno llamado <application>ee</application>, cuyo nombre
      proviene del inglés «easy editor» (editor fácil).
      Para iniciar <application>ee</application> se debe teclear en la
      línea de órdenes
      <command>ee nombre-de-fichero</command>,
      donde <replaceable>nombre-de-fichero</replaceable> es el nombre
      del fichero que se quiere editar.  Por ejemplo, para editar
      <filename>/etc/rc.conf</filename>
      teclée <command>ee /etc/rc.conf</command>.  Una vez dentro
      de <command>ee</command> todas las órdenes para manipular
      las funciones del editor están listadas en la parte
      superior de la pantalla.  El caracter <literal>^</literal> representa
      la tecla <keycap>Ctrl</keycap> del teclado, por lo tanto
      <literal>^e</literal> significa  la combinación de teclas
      <keycombo action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>.
      Para salir de <application>ee</application> pulse la tecla
      <keycap>Esc</keycap> y elija abandonar («leave») el editor.
      El editor preguntará entonces si quiere conservar los
      cambios si el fichero hubiera sido modificado.</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>
    <para>&os; viene también con editores de texto mucho más
      potentes, como <application>vi</application>, como parte del
      sistema base, mientras que otros editores, como
      <application>Emacs</application>
      y <application>vim</application> son parte de la colección
      de ports de &os;
      (<package>editors/emacs</package> y
      <package>editors/vim</package>).
      Estos editores son muchísimo más poderosos, pero tienen
      la desventaja de ser un poco más complicados de aprender a
      manejar.
      De cualquier manera si planea hacer mucho trabajo de edición
      de texto, aprender a usar un editor de texto más poderoso
      como <application>vim</application> o <application>Emacs</application>
      le ahorrará muchísimo más tiempo a la larga.</para>
  </sect1>

  <sect1 xml:id="basics-devices">
    <title>Dispositivos y nodos de dispositivos</title>

    <para>Dispositivo es un término utilizado
      la mayoría de las veces para actividades relacionadas
      con hardware del sistema, como discos, impresoras, tarjetas
      gráficas y teclados.  Cuando &os; arranca, la
      mayoría de lo que &os; despliega son dispositivos
      en el momento de ser detectados.  Si lo desea, puede volver a
      ver todos los mensajes que el sistema emite durante el arranque
      consultando
      <filename>/var/run/dmesg.boot</filename>.</para>

    <para>Por ejemplo, <filename>acd0</filename> es la
      primera unidad CDROM IDE, mientras que <filename>kbd0</filename>
      representa el teclado.</para>

    <para>En un sistema operativo &unix; debe accederse a la mayoría
      de estos dispositivos a través de ficheros especiales llamados
      nodos de dispositivo, que se encuentran en el directorio
      <filename>/dev</filename>.</para>

    <sect2>
      <title>Creación de nodos de dispositivo</title>
      <para>Cuando agregue un nuevo dispositivo a su sistema, o
        compile soporte para dispositivos adicionales, puede que
        necesite crear uno o más nodos de dispositivo.
        </para>

      <sect3>
	<title><literal>DEVFS</literal> Dispositivo de sistema de ficheros (DEVice File System)</title>

        <para>El dispositivo de sistema de ficheros, o <literal>DEVFS</literal>,
          ofrece acceso a dispositivos del espacio de nombres del kernel en el
          espacio de nombres del sistema de ficheros global.
          En lugar de tener que crear y modificar nodos de dispositivo,
          <literal>DEVFS</literal> se encarga del mantenimiento
          dinámico de este sistema de fichero.</para>

        <para>Consulte  &man.devfs.5; si quiere más
          información.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="binary-formats">

    <title>Formatos binarios</title>

    <para>Para poder entender por qué &os; utiliza el formato
      &man.elf.5; primero debe saber ciertas cosas sobre los tres
      formatos de ejecutables «dominantes» en &unix;:</para>

    <itemizedlist>
      <listitem>
        <para>&man.a.out.5;</para>

        <para>El formato objeto de &unix; más antiguo y
          «clásico». Utiliza una cabecera
          corta y compacta con un número mágico al
          inicio que se usa frecuentemente para identificar el
          formato (vea &man.a.out.5; para más información).
          Contiene tres segmentos cargados: .text, .data, y .bss
          además de una tabla de símbolos y una tabla
          de cadena («strings»).</para>
      </listitem>

      <listitem>
        <para><acronym>COFF</acronym></para>

        <para>El formato objeto de SVR3.  La cabecera consiste
          en una tabla de sección, para que pueda tener más
          contenido además de las secciones .text, .data,
          y .bss.</para>
      </listitem>

      <listitem>
        <para>&man.elf.5;</para>

        <para>Es el sucesor de <acronym>COFF</acronym>; dispone de
          secciones múltiples y valores posibles de 32-bits
          o 64-bits.  Una gran desventaja: <acronym>ELF</acronym>
          fué también diseñado asumiendo que
          solamente existiría una ABI por cada arquitectura
          de sistema.  Esa suposición es en realidad bastante
          incorrecta y ni siquiera en el mundo comercial SYSV (el
          cual tiene al menos tres ABIs:  SVR4, Solaris y SCO) se
          puede dar por buena.</para>

        <para>&os; trata de solucionar este problema de alguna
          manera ofreciendo una herramienta para <emphasis>marcar</emphasis>
          un ejecutable <acronym>ELF</acronym> conocido con
          información acerca de la ABI con la que funciona.
          Si quiere más información consulte
          la página de manual de &man.brandelf.1;.
          </para>
      </listitem>
    </itemizedlist>

    <para>&os; viene del campo «clásico» y ha
      utilizado el formato &man.a.out.5;, una tecnología usada
      y probada en muchas de muchas generaciones de versiones de
      BSD hasta el inicio de la rama 3.X.  Aunque era posible
      compilar y ejecutar binarios nativos <acronym>ELF</acronym>
      (y kernels) en un sistema &os; desde algún tiempo
      antes de esto, &os; al principio se mantuvo
      «contra corriente» y no cambió a
      <acronym>ELF</acronym> como formato por defecto.
      ?Por qué?  Bueno, cuando el mundo Linux
      efectuó su dolorosa transición a
      <acronym>ELF</acronym> no fué tanto por huir del formato
      <filename>a.out</filename> como por su inflexible mecanismo de
      bibliotecas compartidas basado en tablas de saltos, que
      hacía igual de difícil la construcción de
      bibliotecas compartidas tanto para los desarrolladores como para
      los proveedores.
      Ya que las herramientas <acronym>ELF</acronym>
      disponibles ofrecían una solución al problema de
      las bibliotecas compartidas y eran vistas por mucha gente como
      «la manera de avanzar», el costo
      de migración fué aceptado como necesario y se
      realizó la transición.  El mecanismo de
      bibliotecas compartidas de &os; está diseñado de
      manera más cercana al estilo del sistema de
      bibliotecas compartidas de &sunos; de Sun y, como tal, es
      muy sencillo de utilizar.</para>

    <para>Entonces, ?por qué existen tantos formatos
      diferentes?</para>

    <para>En un tiempo muy, muy lejano, existía hardware simple.
      Este hardware tan simple soportaba un sistema pequeño, simple.
      <filename>a.out</filename> era idóneo para el trabajo
      de representar binarios en este sistema tan simple (un PDP-11). A
      medida que la gente portaba &unix; desde este sistema simple,
      retuvieron el formato <filename>a.out</filename> debido a que
      era suficiente para los primeros portes de &unix; a arquitecturas
      como 68k de Motorola, VAXen, etc.</para>

    <para>Entonces algún brillante ingeniero de hardware decidió
      que si podía forzar al software a hacer algunos trucos
      sucios podría sortear ciertos obstáculos del
      diseño y permitir al núcleo de su CPU correr más
      rápidamente.  Aunque estaba hecho para trabajar con este nuevo
      tipo de hardware (conocido entonces como <acronym>RISC</acronym>),
      <filename>a.out</filename> no estaba bien adaptado para este
      hardware, así que varios formatos fueron desarrollados
      para obtener un rendimiento mayor de este hardware que el
      podía extraerse del limitado y simple formato
      <filename>a.out</filename>.
      Así fué cómo <acronym>COFF</acronym>,
      <acronym>ECOFF</acronym> y algunos otros formatos más
      extraños fueron inventados y sus limitaciones exploradas hasta
      que se fué llegando a la elección de
      <acronym>ELF</acronym>.</para>

    <para>Además, el tamaño de los programas estaba
      volviendose gigante y los discos (y la memoria física)
      eran relativamente pequeños,  así que el concepto
      de una biblioteca compartida nació.  El sistema
      VM también se volvió más sofisticado.
      A pesar de que todos estos avances se hicieron utilizando
      el formato <filename>a.out</filename>, su utilidad se iba reduciendo
      paulatinamente con cada nueva opción.  Además,
      la gente quería cargar cosas dinámicamente en el momento
      de ejecución, o descartar partes de su programa después de
      que el código de inicio se ejecutara para ahorrar memoria
      principal y espacio de swap.  Al volverse más sofisticados los
      lenguajes, la gente empezó a ver la necesidad de introducir
      código antes del inicio del programa de forma automática.
      Se hicieron muchos hacks al formato <filename>a.out</filename> para
      permitir que todas estas cosas sucedieran y lo cierto es que por un
      tiempo funcionaron.  Pero <filename>a.out</filename> no estaba
      para solucionar todos estos problemas sin incrementar la carga
      y complejidad del código.  Aunque <acronym>ELF</acronym>
      resolvía muchos de estos problemas, en ese momento hubiera sido
      terrible dejar de lado un sistema que funcionaba,
      así que
      <acronym>ELF</acronym> tuvo que esperar hasta que fué más
      doloroso permanecer con <filename>a.out</filename> que migrar a
      <acronym>ELF</acronym>.</para>

    <para>De todas maneras, con el paso del tiempo las herramientas
      de compilación de las que &os; derivó
      las suyas (en especial el ensamblador y el cargador) evolucionaron
      en dos árboles paralelos.  El árbol &os;
      &os; añadió bibliotecas compartidas y corrigió
      algunos errores.  La gente de GNU (que fueron quienes escribieron
      estos programas) los reescribió y añadieron una forma
      más simple de disponer de compiladores cruzados
      («cross compilers»), el uso de diferentes formatos, etc.
      Aunque mucha gente quería compiladores cruzados con &os;
      como «blanco» no hubo suerte, porque los fuentes que
      que &os; tenía para <application>as</application> y
      <application>ld</application> no estaban listos para cumplir esa
      tarea.  La nueva cadena de herramientas
      GNU (<application>binutils</application>) soporta compilación
      cruzada, <acronym>ELF</acronym>, bibliotecas compartidas,
      extensiones C++, etc.  Además, muchos proveedores están
      liberando binarios <acronym>ELF</acronym> y es algo muy bueno
      que &os; los pueda ejecutar.</para>

    <para><acronym>ELF</acronym> es más expresivo que
      <filename>a.out</filename>
      y permite un sistema base más extensible.
      Las herramientas <acronym>ELF</acronym> están mejor
      mantenidas y ofrecen soporte de compilación cruzada,
      muy importante para mucha gente.
      <acronym>ELF</acronym> puede ser un poco más lento que
      <filename>a.out</filename>, pero tratar de medirlo puede ser
      difícil. También existen numerosos detalles
      que son diferentes entre los dos en cómo gestionan páginas,
      cómo gestionan código de inicio, etc. Ninguna
      es muy importante, pero las diferencias existen. Con el tiempo,
      el soporte para <filename>a.out</filename> será eliminado
      del kernel <filename>GENERIC</filename> y es muy posible que
      se elimine del kernel la posibilidad de ejecutar tales binarios
      una vez que la necesidad de usar programas
      <filename>a.out</filename> haya pasado.</para>
  </sect1>

  <sect1 xml:id="basics-more-information">
    <title>Más información</title>

    <sect2 xml:id="basics-man">
      <title>Páginas de manual</title>
      <indexterm><primary>páginas de manual</primary></indexterm>

      <para>La documentación más exhaustiva de &os;
        está en las páginas de manual. Casi todos los
        programas del sistema vienen con un breve manual de referencia
        explicando el funcionamiento básico y sus diferentes argumentos.
        Estos manuales pueden revisarse mediante <command>man</command>.
        El uso de <command>man</command> es simple:</para>

      <screen>&prompt.user; <userinput>man orden</userinput></screen>

      <para><literal>orden</literal> es el nombre de la orden sobre la que
        que desea saber más. Por ejemplo, para más información
        sobre <command>ls</command> escriba:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>El manual en línea está dividido en secciones
        numeradas:</para>

      <orderedlist>
	<listitem>
	  <para>Comandos de usuario.</para>
	</listitem>

	<listitem>
	  <para>Llamadas al sistema y números de error.</para>
	</listitem>

	<listitem>
	  <para>Funciones en las bibliotecas de C.</para>
	</listitem>

	<listitem>
	  <para>Controladores de dispositivo.</para>
	</listitem>

	<listitem>
	  <para>Formatos de fichero.</para>
	</listitem>

	<listitem>
	  <para>Juegos y demás pasatiempos.</para>
	</listitem>

	<listitem>
	  <para>Información sobre temas diversos.</para>
	</listitem>

	<listitem>
	  <para>Comandos relacionados con el mantenimiento del sistema y
           su funcionamiento.</para>
	</listitem>

	<listitem>
	  <para>Desarrolladores del Kernel.</para>
	</listitem>
      </orderedlist>

      <para>En algunos casos, el mismo tema puede aparecer en más de
        una sección del manual en línea.  Por ejemplo,
        existe una orden de usuario <command>chmod</command> y una
        llamada del sistema <function>chmod()</function>.  En este caso
        se le puede decir a <command>man</command>
        cuál  desea consultar especificando la sección:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>Esto desplegará la página de manual de la
        orden de usuario <command>chmod</command>. Las referencias
        a una sección concreta del manual en línea
        tradicionalmente suelen colocarse entre paréntesis
        en la documentación escrita, por lo tanto &man.chmod.1;
        se refiere a la orden de usuario <command>chmod</command> y
        &man.chmod.2; se refiere a la llamada de sistema.</para>

      <para>Esto está muy bien si se conoce el nombre del programa y
        simplemente se quiere saber como usarlo.  Pero ?y si no
        puede recordar el nombre de la orden? Se puede usar man para que
        realice una búsqueda mediante palabras clave en las descripciones
        de programas utilizando el argumento <option>-k</option>:</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>Dicha orden mostrará una lista de
        órdenes que contengan la palabra clave «mail»
        en sus descripciones.  Esto es funcionalmente
        equivalente a usar <command>apropos</command>.</para>

      <para>Así que, ¿está viendo todos esos programas
        tan atractivos en <filename>/usr/bin</filename> pero no tiene
        ni la menor idea de lo que la mayoría de ellos hace?
        Haga lo siguiente:</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

	<para>o</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

	<para>que hace exactamente lo mismo.</para>
    </sect2>

    <sect2 xml:id="basics-info">
      <title>Ficheros de información GNU: info</title>
      <indexterm><primary>Free Software Foundation</primary></indexterm>

      <para>&os; incluye muchas aplicaciones y utilidades producidas
        por la FSF (Free Software Foundation).  Además de con
        las correspondientes páginas de manual, estos programas
        vienen con documentos de hipertexto más detallados,
        llamados ficheros <literal>info</literal>, los
        cuales pueden ser visualizados con <command>info</command>,
        o si tiene instalado <application>emacs</application>, con
        el modo info de <application>emacs</application>.</para>

      <para>Si quiere utilizar la orden &man.info.1;
        teclée:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>Para una breve introducción teclée <literal>h</literal>.
        Cuando necesite una referencia rápida, teclée
	<literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>
