<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project

     The FreeBSD Spanish Documentation Project

     %SOURCE% en_US.ISO8859-1/books/handbook/kernelconfig/chapter.xml
     %SRCID%    1.186


     $FreeBSD$
     $FreeBSDes: doc/es_ES.ISO8859-1/books/handbook/kernelconfig/chapter.xml,v 1.2 2004/10/08 22:14:25 jesusr Exp $
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="kernelconfig">
  <info><title>Configuración del kernel de &os;</title>
    <authorgroup>
      <author><personname><firstname>Jim</firstname><surname>Mock</surname></personname><contrib>Actualizado y reestructurado por </contrib></author>
    </authorgroup>
    <authorgroup>
      <author><personname><firstname>Jake</firstname><surname>Hamby</surname></personname><contrib>Texto original por </contrib></author>
    </authorgroup>
  </info>

  

  <sect1>
    <title>Sinopsis</title>

    <indexterm>
      <primary>kernel</primary>
      <secondary>Compilar un kernel a medida</secondary>
    </indexterm>

    <para>El kernel de &os; es el corazón del sistema
      operativo.  Es el responsable de la gestión y control de la
      memoria, reforzamiento de los controles de seguridad, gestión
      de redes, acceso a dispositivos y muchas cosas más.  &os;
      es un sistema dinámico y configurable, pero a veces
      sigue siendo necesario reconfigurar y recompilar
      un kernel hecho a la medida de nuestras necesidades.</para>

    <para>Una vez leido este capítulo sabrá usted:</para>

    <itemizedlist>
      <listitem>
	<para>Por qué puede ser necesario que compile un kernel
	  personalizado.</para>
      </listitem>

      <listitem>
	<para>Cómo crear un fichero de configuración del kernel,
	  o bien editar un fichero existente.</para>
      </listitem>

      <listitem>
	<para>Cómo utilizar el fichero de configuración
	  para crear
	  y compilar un nuevo kernel.</para>
      </listitem>

      <listitem>
	<para>Cómo instalar su nuevo kernel.</para>
      </listitem>

      <listitem>
	<para>Cómo resolver algunos problemas si algo sale mal.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1>
    <title>?Qué razones hay para compilar un kernel personalizado?</title>

    <para>Tradicionalmente &os; ha contado con lo que se conoce como
      un kernel <quote>monolítico</quote>.  Esto quiere decir que
      el kernel era un gran y único programa que se comunicaba con una lista
      previa de dispositivos, y que si se deseaba modificar el comportamiento
      del kernel se debía compilar un nuevo kernel y reiniciar el sistema
      con el nuevo kernel.</para>

    <para>Hoy en día &os; evoluciona muy rápidamente
      hacia un modelo donde la funcionalidad del kernel se
      basa en módulos, los cuales pueden cargarse y
      descargarse dinámicamente de acuerdo a las necesidades del
      kernel. Esto permite al kernel adaptarse al nuevo hardware que
      sale al mercado (como las tarjetas PCMCIA en sistemas
      portátiles), o bien
      añadir nuevas funcionalidades al kernel que no eran
      al compilarlo la vez anterior.  Esto es lo que conocemos como
      kernel modular.</para>

    <para>A pesar de lo dicho aún es necesario llevar a cabo cierta
      configuración estática en la configuración
      del kernel.  A veces se debe a que la funcionalidad del
      sistema está tan ligada al kernel que no puede hacerse
      mediante carga dinámica de módulos.  En otros casos puede
      tratarse simplemente de que nadie ha programado un módulo
      para esa funcionalidad concreta que pueda cargarse
      dinámicamente en el kernel.</para>

    <para>Compilar un kernel personalizado es uno de los ritos de
      iniciación más importantes a los que los usuarios de
      casi todos los BSD han de enfrentarse.  Este proceso lleva su
      tiempo, pero le aportará grandes beneficios a su
      sistema &os;.  A diferencia del kernel
      <filename>GENERIC</filename>, con el que puede funcionar una cantidad
      apabullante de hardware disponible en el mercado, un kernel personalizado
      contiene únicamente lo necesario para que funcione el hardware de
      <emphasis>su</emphasis> sistema.  Obviamente esto tiene sus
      ventajas:</para>

    <itemizedlist>
      <listitem>
	<para>Mayor rapidez en el arranque del sistema.  Dado que el
	  kernel sólo tiene que probar el hardware que realmente está
	  en el sistema el tiempo que necesitará para arrancar se
	  reducirá visiblemente.</para>
      </listitem>

      <listitem>
	<para>Menor uso de memoria.  Generalmente un kernel personalizado
	  utiliza menos memoria que un kernel
	  <literal>GENERIC</literal>,  lo cual es importante ya que el
	  kernel debe encontrarse siempre en memoria real.  Por ésta
	  razón un kernel personalizado puede ser de gran utilidad
	  en sistemas con una cantidad limitada de memoria RAM.</para>
      </listitem>

      <listitem>
	<para>Hacer funcionar hardware específico.  Un kernel personalizado
	  le permite añadir al sistema dispositivos como tarjetas de sonido,
	  que no están incluidas en el kernel <literal>GENERIC</literal>.
	  </para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="kernelconfig-devices">
    <info><title>Inventario de hardware del sistema</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Escrito por </contrib></author>
      </authorgroup>
    </info>
    

    <para>Antes de aventurarnos en la configuración del kernel
      nunca está de más disponer de un inventario
      completo del hardware que hay en
      la máquina.  En los casos en los que &os; no es el
      sistema operativo principal de la máquina puede
      conseguir el inventario consultando la configuración
      de otro sistema operativo.  Por ejemplo, el
      <application>Gestor de dispositivos</application> de &microsoft;
      suele contener información importante sobre los
      dispositivos que haya en la máquina.  El
      <application>Gestor de dispositivos</application> está
      en el panel de control.</para>

    <note>
      <para>Algunas versiones de &microsoft.windows; tienen un icono
	de <application>Sistema</application> con forma de pantalla
	desde el que se puede acceder al <application>Gestor de
	dispositivos</application>.</para>
    </note>

    <para>Si no hay otro sistema operativo en la máquina el
      administrador tendrá que conseguir la información
      por su cuenta.  Una forma de hacerlo es mediante &man.dmesg.8; y
      &man.man.1;.  La mayoría de los controladores de dispositivo
      que hay en &os; tienen una página de manual, que suele
      incluir una lista del hardware que puede hacer funcionar.  En
      la prueba del sistema durante el arranque va apareciendo una
      lista del harware que hay en la máquina.  Por ejemplo,
      las siguientes líneas indican que el controlador
      <filename>psm</filename> ha encontrado un ratón:</para>

    <programlisting>psm0: &lt;PS/2 Mouse&gt; irq 12 on atkbdc0
psm0: [GIANT-LOCKED]
psm0: [ITHREAD]
psm0: model Generic PS/2 mouse, device ID 0</programlisting>

    <para>Puede añadir este controlador al fichero de
      configuración de su kernel personalizado o cargarlo
      utilizando &man.loader.conf.5;.</para>

    <para>A veces los datos que muestra <command>dmesg</command>
      solamente muestran mensajes del sistema en lugar de la
      salida de la prueba de arranque.  En esos casos puede
      ver la verdadera salida de <command>dmesg</command> en el
      fichero <filename>/var/run/dmesg.boot</filename>.</para>

    <para>Otro método para identificar el hardware del sistema
      es usar &man.pciconf.8;, que tiene una salida mucho más
      verbosa.  Veamos un ejemplo:</para>

    <programlisting>ath0@pci0:3:0:0:        class=0x020000 card=0x058a1014 chip=0x1014168c rev=0x01 hdr=0x00
    vendor     = 'Atheros Communications Inc.'
    device     = 'AR5212 Atheros AR5212 802.11abg wireless'
    class      = network
    subclass   = ethernet</programlisting>

    <para>Este fragmento, obtenido con
      <command>pciconf -lv</command> muestra cómo
      el controlador <filename>ath</filename> ha encontrado un
      dispositivo Ethernet inalámbrico.  Escriba
      <command>man ath</command> para
      consultar la página de manual de &man.ath.4;.</para>

    <para>La opción <option>-k</option> de &man.man.1; le
      suministrará valiosa información.  Sigamos
      con el ejemplo anterior:</para>

    <screen>&prompt.root; man -k <replaceable>Atheros</replaceable></screen>

    <para>Con esto obtendremos una lista de páginas de manual que
      contienen esa palabra en particular:</para>

    <programlisting>ath(4)                   - Atheros IEEE 802.11 wireless network driver
ath_hal(4)               - Atheros Hardware Access Layer (HAL)</programlisting>

    <para>Una vez que tenemos nuestra flamante lista de hardware del sistema
      el proceso de compilar un kernel personalizado debería parecer
      un poco menos inquietante.</para>
  </sect1>


  <sect1 xml:id="kernelconfig-modules">
    <title>Controladores del kernel, subsistemas y módulos</title>
    <indexterm>
      <primary>kernel</primary>
      <secondary>drivers / modules / subsystems</secondary>
    </indexterm>

    <para>Antes de compilar un kernel personalizado conviene
      pensar antes los motivos.  Si lo que se necesita es
      añadir hardware específico al sistema es
      posible que sea posible utilizarlo mediante un
      módulo.</para>

    <para>Los módulos del kernel están en el directorio
      <filename>/boot/kernel</filename> y se
      pueden cargar dinámicamente en un kernel en funcionamiento
      con &man.kldload.8;.  La mayoría, por no decir todos, los
      controladores del kernel tienen un módulo específico
      y una página de manual.  Por ejemplo, en la sección
      anterior hablábamos del controlador Ethernet inalámbrico
      <filename>ath</filename>.  La página de manual
      de este dispositivo contiene la siguiente
      información:</para>

    <programlisting>Alternatively, to load the driver as a module at boot time, place the
     following line in &man.loader.conf.5;:

           if_ath_load="YES"</programlisting>

    <para>Si hace lo que dice ahí, es decir, añadir
      la línea <literal>if_ath_load="YES"</literal> al fichero
      <filename>/boot/loader.conf</filename> hará que el
      módulo se cargue dinámicamente cada vez
      que el sistema arranque.</para>

    <para>Hay casos, no obstante, en los que no existe el módulo
      correspondiente.  Esto sucede con ciertos subsistemas y con
      controladores muy importantes, como por ejemplo el de
      <acronym>FFS</acronym>, que necesita el kernel.  Igual sucede con
      la posibilidad de utilizar redes (INET).  Por desgracia, en estos
      casos la única forma de saber si hace falta un controlador
      es buscar el módulo.</para>

    <warning>
      <para>Es sumamente fácil quitar un dispositivo o una
        opción del kernel y encontrarse de manos a boca con
	un kernel que no funciona.  Por ejemplo, si elimina el
        controlador &man.ata.4; del fichero de configuración
	del kernel un sistema que utilice unidades de disco
        <acronym>ATA</acronym> no podrá arrancar a menos que
	se añada la línea correspondiente al fichero
        <filename>loader.conf</filename>.  Si tiene dudas busque el
	módulo y deje el kernel como está.</para>
    </warning>
  </sect1>

  <sect1 xml:id="kernelconfig-building">
    <title>Compilación e instalación de un kernel personalizado</title>
    <indexterm>
      <primary>kernel</primary>
      <secondary>compilación / instalación</secondary>
    </indexterm>

    <para>En primer lugar, hagamos un breve recorrido por el directorio
      donde se lleva a cabo la compilación del kernel.  Todos los
      directorios mencionados hacen referencia al directorio principal,
      que es <filename>/usr/src/sys</filename>, al que también
      podemos acceder desde <filename>/sys</filename>.  Existen gran
      cantidad de subdirectorios que representan diferentes partes del
      kernel, pero el más importante para lo que deseamos hacer son
      <filename>arch</filename> y
      <filename>/conf</filename>, que es donde se llevara a cabo la
      edición del fichero de configuración y la
      compilación propiamente dicha del mismo,
      el punto de partida para la personalización del kernel. El
      directorio <filename>arch</filename>
      representa la arquitectura del sistema, por lo que puede ser
      <filename>i386</filename>, <filename>alpha</filename>,
      <filename>amd64</filename>, <filename>ia64</filename>,
      <filename>powerpc</filename>, <filename>sparc64</filename> o
      <filename>pc98</filename> (una arquitectura alternativa, similar a PC
      y muy popular en Japón).  Todo lo que existe dentro de un
      directorio de una arquitectura en particular, es específico
      para dicha arquitectura; el resto del código es común
      para todas las plataformas en las que &os; puede funcionar.
      Observe la organización lógica de la estructura
      de los directorios, con cada dispositivo utilizable en el sistema,
      sistema de ficheros y opciones, cada cosa en su propio
      subdirectorio.</para>

    <para>A lo largo de este capítulo asumiremos que está
       utilizando la arquitectura i386, puesto que sobre ella son los
       ejemplos que vamos a ir exponiendo.  Si no es este su caso debe
       hacer los cambios adecuados a su arquitectura de hardware en las
       rutas que vayamos utilizando.</para>


    <note>
      <para>Si <emphasis>no existe</emphasis> el directorio
        <filename>/usr/src/sys</filename> en su sistema quiere
        decir que no están instaladas las fuentes del
	kernel.  La forma más sencilla de tenerlas es
        mediante <command>/stand/sysinstall</command>.  Como
        usuario <systemitem class="username">root</systemitem> seleccione
        <literal>Configure</literal>, luego
        <literal>Distributions</literal>, después
        <literal>src</literal> y finalmente <literal>sys</literal>.
        Si no le gusta mucho
        <application>sysinstall</application> y tiene acceso a un
        CDROM <quote>oficial</quote> de &os; puede
        instalar las fuentes por medio de la siguiente línea
        de órdenes:</para>

      <screen>&prompt.root; <userinput>mount</userinput> /cdrom
&prompt.root; <userinput>mkdir -p</userinput> <filename>/usr/src/sys</filename>
&prompt.root; <userinput>ln -s</userinput> /usr/src/sys /sys
&prompt.root; <userinput>cat /cdrom/sys/ssys.[a-d]* | tar -xzvf</userinput></screen>
    </note>

    <para>Ahora vaya al al directorio
      <filename>arch/conf</filename>
      y copie el fichero de configuración <filename>GENERIC</filename>
      con el nombre que desee.  Por ejemplo:</para>

    <screen>&prompt.root; <userinput>cd /usr/src/sys/i386/conf</userinput>
&prompt.root; <userinput>cp GENERIC MIKERNEL</userinput></screen>

    <para>Por tradición el nombre se escribe con mayúsuculas y
      si tiene varias maquinas &os;, con diferente hardware es recomendable
      darle a cada kernel el mismo nombre que la máquina en la que va
      a ejecutarse.  En este ejemplo usaremos el nombre de
      <filename>MIKERNEL</filename> .</para>

    <tip>
      <para>Guardar su fichero de configuración directamente bajo
        el directorio <filename>/usr/src</filename>, puede que no sea una
        idea muy astuta.  Si empieza a tener problemas puede ser muy tentador
        borrar <filename>/usr/src</filename> y comenzar desde cero.
        Cinco segundos después de haber hecho esto se dará
        cuenta de que ha eliminado el fichero de configuración de
        su kernel, en el que quizás llevaba horas trabajando.</para>

      <para>Le proponemos una alternativa: guardar su fichero de configuración
        cualquier otro sitio y crear un enlace simbólico al fichero
        que hay en el directorio <filename>i386</filename>.</para>

      <para>Por ejemplo:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/sys/i386/conf</userinput>
&prompt.root; <userinput>mkdir /root/kernels</userinput>
&prompt.root; <userinput>cp GENERIC /root/kernels/MIKERNEL</userinput>
&prompt.root; <userinput>ln -s /root/kernels/MIKERNEL</userinput></screen>
    </tip>


    <para>Ahora edite el fichero de configuración
      <filename>MIKERNEL</filename> con su editor de textos favorito.
      Si se trata de una instalación reciente probablemente el
      único editor disponible sea <application>vi</application>,
      del cual es complicado explicar su uso detallado en este
      documento, pero existen bastantes libros que detallan su uso; puede
      ver algunos en la <link linkend="bibliography">bibliografía</link>.
      &os; dispone de un editor de uso muy sencillo, llamado
      <application>ee</application>; si es usted principiante le será
      de mucha ayuda.  Cambie los comentarios al principio del fichero
      con algo que refleje los cambios realizados o al menos para
      diferenciarlo del fichero <filename>GENERIC</filename>.</para>

    <para>Si ha compilado un kernel en &sunos; o algún otro sistema operativo
      BSD seguramente la mayor parte de fichero le será muy
      familiar.  Si viene usted de otros sistemas
      operativos como DOS, el fichero <filename>GENERIC</filename> puede
      parecerle intimidante, así que siga las instrucciones descritas
      en <link linkend="kernelconfig-config">El Fichero de Configuración
      </link> detenidamente y con sumo cuidado.</para>

    <note>
      <para>Asegúrese siempre de verificar el fichero
        <filename>/usr/src/UPDATING</filename> antes de realizar cualquier
        actualización del sistema si ha
        <link linkend="cutting-edge">sincronizado sus fuentes</link>
        para disponer de la última versión de los mismos.
        En el fichero <filename>/usr/src/UPDATING</filename> está toda
        la información importante sobre las actualizaciones.
        Al distribuirse con &os; dicha información deberá
        estar más actualizada que la que hay en este mismo
	texto.</para>
    </note>

    <para>Ahora es momento de llevar a cabo la compilación del
      código fuente del kernel.</para>

    <procedure>
      <title>Compilación del kernel</title>

      <step>
	<para>Vaya al directorio <filename>/usr/src</filename>:</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>
      </step>

      <step>
	<para>Compile el kernel:</para>

	<screen>&prompt.root; <userinput>make buildkernel KERNCONF=MIKERNEL</userinput></screen>
      </step>

      <step>
	<para>Instale el nuevo kernel:</para>

	<screen>&prompt.root; <userinput>make installkernel KERNCONF=MIKERNEL</userinput></screen>
      </step>
    </procedure>

    <note>
      <para>Es imprescindible que disponga del código fuente completo de &os;
        para poder compilar el kernel.</para>
    </note>


    <tip>
      <para>Por omisión, si compila un kernel personalizado
	<emphasis>todos</emphasis> los módulos del kernel
	serán recompilados también.  Si quiere
	que la actualización de su kernel sea mucho más
	rápida o compilar solamente ciertos módulos
	personalizados, edite kernel modules will be rebuilt as well.
	<filename>/etc/make.conf</filename> antes de compilar el
	kernel:</para>

      <programlisting>MODULES_OVERRIDE = linux acpi sound/sound sound/driver/ds1 ntfs</programlisting>

      <para>Esta variable crea una lista de módulos listos para
      ser compilados, sin tocar los demás.</para>

      <programlisting>WITHOUT_MODULES = linux acpi sound/sound sound/driver/ds1 ntfs</programlisting>

      <para>Esta variable crea una lista de módulos que serán
        excluidos del proceso de compilación.  Hay otras variables que
	pueden resultarle útiles durante este proceso; consulte la
	página de manual de &man.make.conf.5;.</para>
    </tip>

    <indexterm>
      <primary><filename>/boot/kernel.old</filename></primary>
    </indexterm>


    <para>El nuevo kernel se copiará al directorio raíz
      como <filename>/kernel</filename> y el kernel viejo tendrá
      el nombre de <filename>/kernel.old</filename>.  Ahora
      reinicie su sistema para poder probar su nuevo kernel.  En caso de que se
      presente algun problema hay algunos consejos para la <link linkend="kernelconfig-trouble">resolución de problemas</link> al
      final de este capítulo.  Asegúrese de leer la sección
      que explica cómo recuperar el sistema en caso de que su kernel <link linkend="kernelconfig-noboot">no quiera arrancar</link>.</para>


    <note>
      <para>Ciertos ficheros relacionados con el proceso de
	arranque, como &man.loader.8;y su configuración,
	se guardan en <filename>/boot</filename>.  Los módulos
	personalizados o de terceros se suelen guardar en
	<filename>/boot/kernel</filename>,
	aunque debe tener presente que es muy importante que
	los módulos y el kernel estén
	sincronizados.  Si intenta usar módulos con un
	kernel para el que no están destinados puede
	haber errores o incluso producirse intesatabilidades.</para>
    </note>

  </sect1>
<!-- hemendik -->


  <sect1 xml:id="kernelconfig-config">
    <info><title>El fichero de configuración</title>
      <authorgroup>
	<author><personname><firstname>Joel</firstname><surname>Dahl</surname></personname><contrib>Actualizado a &os; 6.X por </contrib></author>
      </authorgroup>
    </info>
    
    <indexterm>
      <primary>kernel</primary>
      <secondary>NOTES</secondary>
    </indexterm>
    <indexterm><primary>NOTES</primary></indexterm>
    <indexterm>
      <primary>kernel</primary>
      <secondary>configuration file</secondary>
    </indexterm>

    <para>El formato de un fichero de configuración es
      bastante simple.  Cada línea contiene una palabra
      clave con uno o más argumentos.  Para simplificar,
      hay muchas líneas que solamente contienen un
      argumento.  Cualquier cosa detrás de un
      <literal>#</literal> se considerará un comentario y
      en consecuencia será ignorado.  Las siguientes
      secciones describen todas las palabras clave en el orden
      en el que aparecen en
      <filename>GENERIC</filename>.
      <anchor xml:id="kernelconfig-options"/> Si quiere una lista exhaustiva de
      de opciones dependientes de arquitectura y de dispositivos
      puede consultar el fichero <filename>NOTES</filename>
      en el mismo directorio donde está el fichero
      <filename>GENERIC</filename>.  Si quiere ver las
      opciones independientes de arquitectura consulte
      <filename>/usr/src/sys/conf/NOTES</filename>.</para>

    <note>
      <para>Puede generar un fichero que contenga todas las opciones
        disponibles en un kernel.  Esto es algo que solamente se
	usa para hacer pruebas.  Si quiere generarlo ejecute, como
	<systemitem class="username">root</systemitem>, lo siguiente:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/sys/i386/conf &amp;&amp; make LINT</userinput></screen>
    </note>

    <indexterm>
      <primary>kernel</primary>
      <secondary>configuration file</secondary>
    </indexterm>

    <para>A continuación veremos un ejemplo de fichero de
      configuración de un kernel <filename>GENERIC</filename>
      al que se han añadido comentarios adicionales donde se
      ha visto que era necesario abundar un poco para mayor
      claridad.  Este ejemplo es igual (o, en el
      peor de los casos, casi igual) que la copia del mismo
      que tiene usted en
      <filename>/usr/src/sys/i386/conf/GENERIC</filename>.
      </para>

    <indexterm>
      <primary>kernel options</primary>
      <secondary>machine</secondary>
    </indexterm>

    <programlisting>machine		i386</programlisting>

    <para>Esta es la arquitectura de la máquina.  Debe ser
      <literal>alpha</literal>, <literal>amd64</literal>,
      <literal>i386</literal>, <literal>ia64</literal>,
      <literal>pc98</literal>, <literal>powerpc</literal> o
      <literal>sparc64</literal>.</para>

    <indexterm>
      <primary>kernel options</primary>
      <secondary>cpu</secondary>
    </indexterm>
    <programlisting>cpu          I486_CPU
cpu          I586_CPU
cpu          I686_CPU</programlisting>

    <para>Las opciones anteriores definen el tipo de CPU que
      haya en su sistema.  Puede dejar varias líneas
      de CPU (si, por ejemplo, no está seguro de usar
      <literal>I586_CPU</literal> o <literal>I686_CPU</literal>),
      pero si está personalizando su kernel es mucho mejor
      que solamente ponga la CPU que tenga.  Si no está
      seguro de la CPU que tiene busque en los mensajes de arranque
      que se guardan en
      <filename>/var/run/dmesg.boot</filename>.</para>

    <indexterm>
      <primary>kernel options</primary>
      <secondary>ident</secondary>
    </indexterm>

    <programlisting>ident          GENERIC</programlisting>

    <para>Este es el identificador del kernel.  Modifíquelo
      para que cuadre con el nombre que le haya dado a su kernel,
      es decir, <literal>MIKERNEL</literal>
      si ha seguido los ejemplos anteriores.  El valor que asigne
      a la cadena <literal>ident</literal> será el que
      se muestre cuando arranque con su kernel, así que
      es útil darle a su kernel un nombre distintivo que
      permita distinguirlo fácilmente de otros, por ejemplo,
      si está compilando un kernel experimental.</para>

    <programlisting>#To statically compile in device wiring instead of /boot/device.hints
#hints          "GENERIC.hints"         # Default places to look for devices.</programlisting>

    <para>&man.device.hints.5; se usa para configurar opciones
      de controladores de dispositivo.  La ubicación por
      defecto en la que &man.loader.8; buscará durante
      el arranque es <filename>/boot/device.hints</filename>.  Si usa
      la opción <literal>hints</literal> puede compilar el
      contenido de <filename>device.hints</filename> en su kernel,
      lo que hará innecesario crear ese fichero en
      <filename>/boot</filename>.</para>

    <!-- XXX: Add a comment here that explains when compiling hints into
      the kernel is a good idea and why. -->

    <programlisting>makeoptions     DEBUG=-g          # Build kernel with gdb(1) debug symbols</programlisting>

    <para>El proceso normal de compilación en &os;
      incluye información de depuración de
      errores si se compila un kernel con la opción
      <option>-g</option>, que activa la información
      de depuración de errores al pasar a
      &man.gcc.1;.</para>

    <programlisting>options          SCHED_4BSD         # 4BSD scheduler</programlisting>

    <para>El planificador de tareas tradicional y por omisión
      de &os;.  Déjelo como está.</para>

    <programlisting>options          PREEMPTION         # Enable kernel thread preemption</programlisting>

    <para>Permite que hilos que están en el kernel
      puedan asociarse con hilos cuya prioridad sea más
      alta.  Ayuda con la interactividad y permite que los hilos
      interrumpidos puedan ejecutarse antes en lugar de tener
      que esperar.</para>

    <programlisting>options          INET              # InterNETworking</programlisting>

    <para>Networking.  Deje esto como está, incluso si no
      tiene en mente conectar la máquina a una red.  Muchos
      programas necesitan al menos disponer de lo que se llama
      «loopback networking» (esto es, poder efectuar
      conexiones de red con su propia máquina) así
      que tener esto es obligatorio.</para>

    <programlisting>options          INET6             # IPv6 communications protocols</programlisting>

    <para>Activa los protocolos de comunicación IPv6.</para>

    <programlisting>options          FFS               # Berkeley Fast Filesystem</programlisting>

    <para>El sistema de ficheros básico para discos
      duros.  Debe dejarlo como está si pretende
      poder arrancar desde disco duro.</para>

    <programlisting>options          SOFTUPDATES       # Enable FFS Soft Updates support</programlisting>

    <para>Activa Soft Updates en el kernel, lo que acelerará
      los accesos de escritura a sus discos.  Esta funcionalidad
      la facilita el kernel, pero debe activarse para cada disco
      de forma específica.  Revise la salida de
      &man.mount.8; y verá si Soft Updates está
      activado en los discos de su sistema.  Si no aparece la
      opción <literal>soft-updates</literal> actívela
      mediante &man.tunefs.8; (para sistemas de ficheros ya
      existentes) o &man.newfs.8; (en el caso de sistemas
      de ficheros nuevos).</para>

    <programlisting>options          UFS_ACL           # Support for access control lists</programlisting>

    <para>Esta opción activa en el kernel las listas
      de control de acceso.  Consiste en el uso de atributos
      extendidos y <acronym>UFS2</acronym> junto con las
      características que se describen detalladamente
      en la <xref linkend="fs-acl"/>.  Las <acronym>ACL</acronym>
      por omisión están activadas, y no deben
      desactivarse del kernel una vez que hayan sido usadas
      en un sistema de ficheros puesto que eliminará
      las listas de control de acceso y el modo en el que
      se protegen esos ficheros de un modo totalmente
      fuera de control.</para>

    <programlisting>options          UFS_DIRHASH       # Improve performance on big directories</programlisting>

    <para>This option includes functionality to speed up disk
      operations on large directories, at the expense of using
      additional memory.  You would normally keep this for a large
      server, or interactive workstation, and remove it if you are
      using &os; on a smaller system where memory is at a premium and
      disk access speed is less important, such as a firewall.</para>

    <programlisting>options          MD_ROOT           # MD is a potential root device</programlisting>

    <para>Esta opción permite que la partición
      raíz esté en un disco virtual basado en
      memoria.</para>

    <indexterm>
      <primary>kernel options</primary>
      <secondary>NFS</secondary>
    </indexterm>
    <indexterm>
      <primary>kernel options</primary>
      <secondary>NFS_ROOT</secondary>
    </indexterm>
    <programlisting>options          NFSCLIENT         # Network Filesystem Client
options          NFSSERVER         # Network Filesystem Server
options          NFS_ROOT          # NFS usable as /, requires NFSCLIENT</programlisting>

    <para>NFS, el sistema de ficheros en red.  Salvo que tenga
      intención de montar particiones de sistemas de ficheros
      &unix; de un servidor a través de TCP/IP puede
      comentar estas opciones.</para>

    <indexterm>
      <primary>kernel options</primary>
      <secondary>MSDOSFS</secondary>
    </indexterm>
    <programlisting>options          MSDOSFS           # MSDOS Filesystem</programlisting>

    <para>El sistema de ficheros &ms-dos;.  Salvo que tenga en mente
      montar particiones de disco duro con formato DOS durante el
      arranque puede comentar esta opción.  En caso de
      necesidad esta funcionalidad se cargará
      automáticamente.  También tiene a su
      <package>emulators/mtools</package>,
      que le permitirá acceder a disquetes DOS sin tener
      que montarlos y desmontarlos (y ni siquiera requiere
      <literal>MSDOSFS</literal>).</para>

    <programlisting>options          CD9660            # ISO 9660 Filesystem</programlisting>

    <para>El sistema de ficheros ISO 9660 para CDROM.  Coméntelo
      si no tiene unidad CDROM o solamente monta CD muy de
      vez en cuando; cuando lo necesite el sistema lo cargará
      dinámicamente.  Los CD de sonido no utilizan este
      sistema de ficheros.</para>

    <programlisting>options          PROCFS            # Process filesystem (requires PSEUDOFS)</programlisting>

    <para>El sistema de ficheros de procesos.  Es un sistema
      de ficheros <quote>simulado</quote> que se monta en
      <filename>/proc</filename> y permite a programas como
      &man.ps.1; suministrar más información
      sobre qué procesos están
      ejecutándose.  En la mayoaría de los casos
      no es necesario usar <literal>PROCFS</literal>,
      puesto que la mayoría de las herramientas de
      monitorización y depuración han sido
      adaptadas para que funcionen sin
      <literal>PROCFS</literal>.  De hecho aunque lo instale
      el sistema no lo montará por omisión.</para>

    <programlisting>options          PSEUDOFS          # Pseudo-filesystem framework</programlisting>

      <para>Los kernel 6.X pueden usar <literal>PSEUDOFS</literal>
        al utilizar <literal>PROCFS</literal>.</para>

    <programlisting>options          GEOM_GPT          # GUID Partition Tables.</programlisting>

    <para>Con esta opción se puede tener una gran cantidad
      de particiones en un único disco.</para>

    <programlisting>options          COMPAT_43         # Compatible with BSD 4.3 [KEEP THIS!]</programlisting>

    <para>Compatibilidad con 4.3BSD.  Déjelo como está;
      ciertos programas pueden comportarse de formas muy
      extrañas si comenta esta opción.</para>

    <programlisting>options          COMPAT_FREEBSD4   # Compatible with &os;4</programlisting>

    <para>&os;&nbsp;5.X en sistemas &i386; y Alpha necesita
      esta opción para poder usar aplicaciones compiladas
      en versiones antiguas de &os; que utilizan, por tanto,
      llamadas al sistema más antiguas.  Esta opción
      no es necesaria en plataformas en las que funciona &os;
      desde 5.X, como ia64 y &sparc64;.</para>

    <programlisting>options          COMPAT_FREEBSD5   # Compatible with &os;5</programlisting>

    <para>Esta opción hace falta en sistemas &os;&nbsp;6.X
      y versiones posteriores para poder ejecutar aplicaciones
      compiladas en &os;&nbsp;5.X, que usan interfaces de llamada
      al sistema &os;&nbsp;5.X.</para>

    <programlisting>options          SCSI_DELAY=5000  # Delay (in ms) before probing SCSI</programlisting>

    <para>Hace que el kernel haga una pausa de 5 segundos antes de
      probar los dispositivos SCSI del sistema.  Si solamente tiene
      discos IDE puede ignorar esta opción, o también
      puede asignarle un valor menos para evitar el retardo en el
      arranque.  Si lo hace y &os; tiene problemas para reconocer
      dispositivos SCSI en el sistema es obvio que tendrá
      que incrementar el valor.</para>

    <programlisting>options          KTRACE            # ktrace(1) support</programlisting>

    <para>Activa las trazas en el kernel, algo muy útil para
      la depuración de errores.</para>

    <programlisting>options          SYSVSHM           # SYSV-style shared memory</programlisting>

    <para>Facilita memoria compartida System&nbsp;V.  El uso
      más habitual es la extensión XSHM de X, que
      utiliza la mayoría de programas que hacen uso
      intensivo de los gráficos para incrementar la
      velocidad.  Si usa X es casi seguro que le vendrá bien
      esta opción.</para>

    <programlisting>options          SYSVMSG           # SYSV-style message queues</programlisting>

    <para>Mensajes System&nbsp;V.  Esta opción añade
      solamente unos cuantos bytes al kernel.</para>

    <programlisting>options          SYSVSEM           # SYSV-style semaphores</programlisting>

    <para>Semáforos System&nbsp;V.  No es demasiado frecuente
      que se utilicen, pero solamente añaden unos
      cuantos cientos de bytes al kernel.</para>

    <note>
      <para>La opción <option>-p</option> de &man.ipcs.1;
        le mostrará una lista de procesos que estén
	utilizando características
	System&nbsp;V.</para>
    </note>

    <programlisting>options 	     _KPOSIX_PRIORITY_SCHEDULING # POSIX P1003_1B real-time extensions</programlisting>

    <para>Extensiones en tiempo real añadidas en 1993
      &posix;.  Ciertas aplicaciones de la Colección de
      Ports las utilizan, por ejemplo
      <application>&staroffice;</application>.</para>

    <programlisting>options          KBD_INSTALL_CDEV  # install a CDEV entry in /dev</programlisting>

    <para>This option is required to allow the creation of keyboard device
      nodes in <filename>/dev</filename>.</para>

    <programlisting>options          ADAPTIVE_GIANT    # Giant mutex is adaptive.</programlisting>

    <para>Giant es un mecanismo de exclusión mutua
      («sleep mutex») que protege un gran conjunto
      de recursos del kernel.  Hoy en dia no es asumible tener
      un cuello de botella así por el impacto que tiene
      en el rendimiento, así que está siendo
      reemplazado por bloqueos que protegen los recursos de
      manera individual.  <literal>ADAPTIVE_GIANT</literal>
      hace que Giant sea incluido en un conjunto de
      «mutextes» que va rotando
      Esto es, cuando un hilo quiere
      bloquear el Giant mutex (pero ya está bloqueado
      por un hilo de otra CPU) el primer hilo seguirá
      ejecutándose a la espera de que se libere el
      bloqueo.  Generalmente el hilo volverá al estado
      de reposo y esperará hasta que aparezca otra
      oportunidad de ejecutarse.  Si no está seguro de
      lo que está haciendo es mejor que deje esta
      opción tal y como está.</para>

    <note>

      <para>Tenga en cuenta que en &os;&nbsp;8.0-CURRENT y
        versiones siguientes todos los «mutexes»
	son adaptables por omisión, salvo que se use
	la opción
	<literal>NO_ADAPTIVE_MUTEXES</literal>.  El resultado
	evidente que es Giant es adaptable por omisión,
	así que la opción
	<literal>ADAPTIVE_GIANT</literal> ha sido eliminada de
	la configuración.</para>
    </note>

    <indexterm>
      <primary>kernel options</primary>
      <secondary>SMP</secondary>
    </indexterm>
    <programlisting>device          apic               # I/O APIC</programlisting>

    <para>El dispositivo apic activa la E/S APIC en la entrega
      de interrupciones.  El dispositivo apic puede usarse tanto en
      kernels para un procesador (UP) como para sistemas
      multiprocesador (SMP).  Si añada
      <literal>options SMP</literal> funcionará en
      sistemas multiprocesador.</para>

    <note>
      <para>El dispositivo apic existe solamente en la
        arquitectura i386, de modo que no debe usarse
	esta línea en otras arquitecturas.</para>
    </note>

    <programlisting>device          eisa</programlisting>

    <para>Use esta opción si tiene una placa base
      EISA.  Activa la detección automática y
      permite la configuración de todos los dispositivos
      que estén en el bus EISA.</para>

    <programlisting>device          pci</programlisting>

    <para>Use esta opción si tiene una placa PCI.  Permite
      la detección automática de tarjetas PCI y
      permite la configuración entre el bus ISA y el
      PCI.</para>

    <programlisting># Floppy drives
device          fdc</programlisting>

    <para>Este dispositivo es el controlador de la unidad de
      disquetes.</para>

    <programlisting># ATA and ATAPI devices
device          ata</programlisting>

    <para>Este controlador permite utilizar dispositivos ATA
      y ATAPI.  Si añade al kernel
      one <literal>device ata</literal> éste detectará
      cualquier dispositivo ATA/ATAPI PCI que conecte a una
      máquina moderna.</para>

    <programlisting>device          atadisk                 # ATA disk drives</programlisting>

    <para>Si usa <literal>device ata</literal> tendrá que
      añadir también esto para poder usar unidades
      de disco ATA.</para>

    <programlisting>device          ataraid                 # ATA RAID drives</programlisting>

    <para>Si usa <literal>device ata</literal> tendrá que
      añadir también esto para poder usar unidades
      de disco ATA RAID.</para>

    <programlisting><anchor xml:id="kernelconfig-atapi"/>
device          atapicd                 # ATAPI CDROM drives</programlisting>

     <para>Si usa <literal>device ata</literal> tendrá que
      añadir también esto para poder usar unidades
      ATAPI CDROM.</para>

    <programlisting>device          atapifd                 # ATAPI floppy drives</programlisting>

     <para>Si usa <literal>device ata</literal> tendrá que
      añadir también esto para poder usar unidades
      de disquete ATAPI.</para>

    <programlisting>device          atapist                 # ATAPI tape drives</programlisting>

    <para>Si usa <literal>device ata</literal> tendrá que
      añadir también esto para poder usar unidades
      de cinta ATAPI.</para>

    <programlisting>options         ATA_STATIC_ID           # Static device numbering</programlisting>

    <para>Con esta opción hace que el número de
      controladores sea estático; si no se usa los
      números de dispositivo se asignan
      dinámicamente.</para>

    <programlisting># SCSI Controllers
device          ahb        # EISA AHA1742 family
device          ahc        # AHA2940 and onboard AIC7xxx devices
options         AHC_REG_PRETTY_PRINT    # Print register bitfields in debug
                                        # output.  Adds ~128k to driver.
device          ahd        # AHA39320/29320 and onboard AIC79xx devices
options         AHD_REG_PRETTY_PRINT    # Print register bitfields in debug
                                        # output.  Adds ~215k to driver.
device          amd        # AMD 53C974 (Teckram DC-390(T))
device          isp        # Qlogic family
#device         ispfw      # Firmware for QLogic HBAs- normally a module
device          mpt        # LSI-Logic MPT-Fusion
#device         ncr        # NCR/Symbios Logic
device          sym        # NCR/Symbios Logic (newer chipsets + those of `ncr')
device          trm        # Tekram DC395U/UW/F DC315U adapters

device          adv        # Advansys SCSI adapters
device          adw        # Advansys wide SCSI adapters
device          aha        # Adaptec 154x SCSI adapters
device          aic        # Adaptec 15[012]x SCSI adapters, AIC-6[23]60.
device          bt         # Buslogic/Mylex MultiMaster SCSI adapters

device          ncv        # NCR 53C500
device          nsp        # Workbit Ninja SCSI-3
device          stg        # TMC 18C30/18C50</programlisting>

    <para>Controladoras SCSI.  Coméntelas si no las tiene
      en su sistema.  Si en su sistema tiene solamente unidades IDE
      puede borrarlas todas.
      Las líneas <literal>*_REG_PRETTY_PRINT</literal> son
      opciones de depuración de errores de sus
      respectivos controladores de dispositivo.</para>

    <programlisting># SCSI peripherals
device          scbus      # SCSI bus (required for SCSI)
device          ch         # SCSI media changers
device          da         # Direct Access (disks)
device          sa         # Sequential Access (tape etc)
device          cd         # CD
device          pass       # Passthrough device (direct SCSI access)
device          ses        # SCSI Environmental Services (and SAF-TE)</programlisting>

    <para>Periféricos SCSI.  Estos también puede
      borrarlos sin problemas si no los tiene en su sistema o
      si solamente tiene hardware IDE.</para>

    <note>
      <para>El controlador USB &man.umass.4; (y unos cuantos
        controladores más) utilizan el subsistema
	SCSI aunque no sean dispositivos SCSI reales.  No elimine
	el subsistema SCSI del kernel si va a utilizar cualquiera
	de estos controladores.</para>
    </note>

    <programlisting># RAID controllers interfaced to the SCSI subsystem
device          amr        # AMI MegaRAID
device          arcmsr     # Areca SATA II RAID
device          asr        # DPT SmartRAID V, VI and Adaptec SCSI RAID
device          ciss       # Compaq Smart RAID 5*
device          dpt        # DPT Smartcache III, IV - See NOTES for options
device          hptmv      # Highpoint RocketRAID 182x
device          rr232x     # Highpoint RocketRAID 232x
device          iir        # Intel Integrated RAID
device          ips        # IBM (Adaptec) ServeRAID
device          mly        # Mylex AcceleRAID/eXtremeRAID
device          twa        # 3ware 9000 series PATA/SATA RAID

# RAID controllers
device          aac        # Adaptec FSA RAID
device          aacp       # SCSI passthrough for aac (requires CAM)
device          ida        # Compaq Smart RAID
device          mfi        # LSI MegaRAID SAS
device          mlx        # Mylex DAC960 family
device          pst        # Promise Supertrak SX6000
device          twe        # 3ware ATA RAID</programlisting>

    <para>Controladoras RAID que pueden utilizarse en &os;.  Si no las
      tiene en su sistema puede borrarlas.</para>

    <programlisting># atkbdc0 controls both the keyboard and the PS/2 mouse
device          atkbdc     # AT keyboard controller</programlisting>

    <para>El controlador de teclado (<literal>atkbdc</literal>)
      ofrece servicios de E/S con teclados AT y ratones PS/2.  El
      controlador de teclado
      (<literal>atkbd</literal>) y el controlador de ratón PS/2
      (<literal>psm</literal>) necesitan este dispositivo.</para>

    <programlisting>device          atkbd      # AT keyboard</programlisting>

    <para>El controlador <literal>atkbd</literal>, junto con el
      controlador <literal>atkbdc</literal>, permiten utilizar el
      teclado AT 84 u otros tipos de teclados AT mejorados que se
      conecten mediante el controlador de teclado AT.</para>

    <programlisting>device          psm        # PS/2 mouse</programlisting>

    <para>Utilice este dispositivo si conecta su ratón en el
      puerto PS/2.</para>

    <programlisting>device          kbdmux        # keyboard multiplexer</programlisting>

    <para>Funcionalidad básica para múltiples
      teclados.  Si no tiene en mente usar más de un
      teclado en el sistema puede borrar esta línea
      sin mayor problema.</para>

    <programlisting>device          vga        # VGA video card driver</programlisting>

    <para>El controlador de la tarjeta gráfica.</para>

    <programlisting>
device          splash     # Splash screen and screen saver support</programlisting>

    <para>«Splash screen» en el arranque.  Los salvapantallas
      necesitan este dispositivo.</para>

    <programlisting># syscons is the default console driver, resembling an SCO console
device          sc</programlisting>

    <para><literal>sc</literal> por omisión es el controlador
      de dispositivo de la consola; se parece mucho a una consola de
      SCO.  Dado que muchos programas de pantalla completa acceden
      a la consola a través de la biblioteca de bases de datos
      de terminal
      <filename>termcap</filename> no tiene demasiada importancia si
      usa <literal>vt</literal>, el controlador de consola compatible
      <literal>VT220</literal>.  Cuando acceda al sistema asigne a
      su variable <envar>TERM</envar> el valor
      <literal>scoansi</literal>si los programas a pantalla completa
      tienen algún problema para acceder a la consola.</para>

    <programlisting># Enable this for the pcvt (VT220 compatible) console driver
#device          vt
#options         XSERVER          # support for X server on a vt console
#options         FAT_CURSOR       # start with block cursor</programlisting>

    <para>El controlador de dispositivo VT220-compatible;
      es compatible con VT100/102, anterior a él.  Funciona
      bien en ciertos sistemas portátiles que adolecen de
      incompatibilidad de harware con
      <literal>sc</literal>.  Asigne a su variable de entorno
      <envar>TERM</envar> el valor <literal>vt100</literal> o
      <literal>vt220</literal> cuando acceda al sistema.  Este
      controlador le puede ser de utilidad si tiene que acceder
      a gran cantidad de máquinas a través de una
      red, una situación en la que suele suceder que
      <filename>termcap</filename> o
      <filename>terminfo</filename> no están ahí
      para que las use <literal>sc</literal>.
      <literal>vt100</literal>, por el contrario, debería
      aparecer en práticamente cualquier
      plataforma.</para>

    <programlisting>device          agp</programlisting>

    <para>Utilice esta opción si tiene en el sistema una
      tarjeta AGP.  Activará AGP y también AGP GART
      si su tarjeta puede usarla.</para>

    <indexterm>
      <primary>APM</primary>
    </indexterm>

    <programlisting># Power management support (see NOTES for more options)
#device          apm</programlisting>

    <para>Gestión avanzada de la energía.  Muy
      útil en sistemas portátiles.  Viene
      desactivada por omisión en el kernel
      <filename>GENERIC</filename> .</para>

    <programlisting># Add suspend/resume support for the i8254.
device           pmtimer</programlisting>

    <para>Controlador del reloj para eventos de gestión de la
      energía, como APM y ACPI.</para>

    <programlisting># PCCARD (PCMCIA) support
# PCMCIA and cardbus bridge support
device          cbb               # cardbus (yenta) bridge
device          pccard            # PC Card (16-bit) bus
device          cardbus           # CardBus (32-bit) bus</programlisting>

    <para>Dispositivos PCMCIA.  Si el sistema es portátil
      necesita tener esto activado.</para>

    <programlisting># Serial (COM) ports
device          sio               # 8250, 16[45]50 based serial ports</programlisting>

    <para>Estos son los puertos serie a los que se conoce como
      puertos <filename>COM</filename> en entornos
      &ms-dos;/&windows;.</para>

    <note>
      <para>Si tiene un módem interno en
        <filename>COM4</filename> un puerto serie en
	<filename>COM2</filename> tendrá que
	asignar a la IRQ del módem el 2 (por razones
	técnicas ignotas IRQ2 = IRQ 9) para que pueda
	acceder al dispositivo desde &os;.  Si tiene una tarjeta
	serie multipuerto consulte la página de manual de
	&man.sio.4; si quiere más detalles sobre los
	valores que debe añadir a
	<filename>/boot/device.hints</filename>.  Algunas tarjetas
	gráficas (sobre todo las que usan chips S3) utilizan
	direcciones IO del tipo
	<literal>0x*2e8</literal> y dado que muchas tarjetas serie
	de baja calidad no decodifican correctamente el espacio de
	direcciones de 16 bits chocan con estas tarjetas, haciendo
	que el puerto <filename>COM4</filename> sea
	prácticamente inútil.</para>

      <para>Es necesario que cada puerto serie tenga una IRQ
        única (salvo que use una tarjeta multipuerto que
	permita compartir interrupciones), así que las
	IRQ de <filename>COM3</filename> y de
	<filename>COM4</filename> no se pueden
	utilizar.</para>
    </note>

    <programlisting># Parallel port
device          ppc</programlisting>

    <para>El interfaz del puerto paralelo de bus ISA.</para>

    <programlisting>device          ppbus      # Parallel port bus (required)</programlisting>

    <para>El bus del puerto paralelo.</para>

    <programlisting>device          lpt        # Printer</programlisting>

    <para>Permite usar el puerto paralelo para conectar impresoras.</para>

    <note>
      <para>Necesitará disponer de los tres anteriores para
        poder utilizar impresoras mediante el puerto paralelo.</para>
    </note>

    <programlisting>device          plip       # TCP/IP over parallel</programlisting>

    <para>Este controlador es para la interfaz de red a través
      del puerto paralelo.</para>

    <programlisting>device          ppi        # Parallel port interface device</programlisting>

    <para>La E/S de propósito general (conocida
      también como <quote>puerto geek</quote>) + E/S
      IEEE1284.</para>

    <programlisting>#device         vpo        # Requires scbus and da</programlisting>

    <indexterm><primary>zip drive</primary></indexterm>
    <para>Este dispositivo se usa con unidades Iomega Zip.  Necesita
      <literal>scbus</literal> y <literal>da</literal> .  El mejor
      rendimiento se alcanza con el uso de los puertos en modo
      EPP 1.9.</para>

    <programlisting>#device         puc</programlisting>

    <para>Puede utilizar este dispositivo si tiene una tarjeta
      PCI <quote>tonta</quote> (por puerto serie o paralelo)
      que funcione mediante el controlador &man.puc.4;.</para>

    <programlisting># PCI Ethernet NICs.
device          de         # DEC/Intel DC21x4x (<quote>Tulip</quote>)
device          em         # Intel PRO/1000 adapter Gigabit Ethernet Card
device          ixgb       # Intel PRO/10GbE Ethernet Card
device          txp        # 3Com 3cR990 (<quote>Typhoon</quote>)
device          vx         # 3Com 3c590, 3c595 (<quote>Vortex</quote>)</programlisting>

    <para>Diversos controladores para tarjetas de red PCI.  Puede borrar
      todas las que no estén en su sistema.</para>

    <programlisting># PCI Ethernet NICs that use the common MII bus controller code.
# NOTE: Be sure to keep the 'device miibus' line in order to use these NICs!
device          miibus     # MII bus support</programlisting>

    <para>El poder utilizar bus MII es necesario para ciertas tarjetas
      Ethernet PCI 10/100, más concretamente las que usan
      transceptores compatibles con MII o implementan interfaces
      de control de transceptores que funcionan como si fueran
      MII.  Si incluye <literal>device miibus</literal> al kernel
      dispondrá de la API miibus genérica  y todos los
      controladores PHY, incluyendo uno que hará funcionar
      hardware que, siendo del tipo PHY, no está bajo ninguno
      de los controladores PHY específicos.</para>

    <programlisting>device          bce        # Broadcom BCM5706/BCM5708 Gigabit Ethernet
device          bfe        # Broadcom BCM440x 10/100 Ethernet
device          bge        # Broadcom BCM570xx Gigabit Ethernet
device          dc         # DEC/Intel 21143 and various workalikes
device          fxp        # Intel EtherExpress PRO/100B (82557, 82558)
device          lge        # Level 1 LXT1001 gigabit ethernet
device          msk        # Marvell/SysKonnect Yukon II Gigabit Ethernet
device          nge        # NatSemi DP83820 gigabit ethernet
device          nve        # nVidia nForce MCP on-board Ethernet Networking
device          pcn        # AMD Am79C97x PCI 10/100 (precedence over 'lnc')
device          re         # RealTek 8139C+/8169/8169S/8110S
device          rl         # RealTek 8129/8139
device          sf         # Adaptec AIC-6915 (<quote>Starfire</quote>)
device          sis        # Silicon Integrated Systems SiS 900/SiS 7016
device          sk         # SysKonnect SK-984x &amp; SK-982x gigabit Ethernet
device          ste        # Sundance ST201 (D-Link DFE-550TX)
device          stge       # Sundance/Tamarack TC9021 gigabit Ethernet
device          ti         # Alteon Networks Tigon I/II gigabit Ethernet
device          tl         # Texas Instruments ThunderLAN
device          tx         # SMC EtherPower II (83c170 <quote>EPIC</quote>)
device          vge        # VIA VT612x gigabit ethernet
device          vr         # VIA Rhine, Rhine II
device          wb         # Winbond W89C840F
device          xl         # 3Com 3c90x (<quote>Boomerang</quote>, <quote>Cyclone</quote>)</programlisting>

    <para>Controladores que utilizan el código del controlador
      de bus MII.</para>

    <programlisting># ISA Ethernet NICs.  pccard NICs included.
device          cs         # Crystal Semiconductor CS89x0 NIC
# 'device ed' requires 'device miibus'
device          ed         # NE[12]000, SMC Ultra, 3c503, DS8390 cards
device          ex         # Intel EtherExpress Pro/10 and Pro/10+
device          ep         # Etherlink III based cards
device          fe         # Fujitsu MB8696x based cards
device          ie         # EtherExpress 8/16, 3C507, StarLAN 10 etc.
device          lnc        # NE2100, NE32-VL Lance Ethernet cards
device          sn         # SMC's 9000 series of Ethernet chips
device          xe         # Xircom pccard Ethernet

# ISA devices that use the old ISA shims
#device         le</programlisting>

    <para>Controladores Ethernet ISA.  Consulte
      <filename>/usr/src/sys/i386/conf/NOTES</filename>
      para más detalles sobre qué tarjetas hace funcionar
      qué controlador.</para>

    <programlisting># Wireless NIC cards
device          wlan            # 802.11 support</programlisting>

    <para>802.11 genérico.  Necesitará esta línea
      si va a usar redes inalámbricas.</para>

    <programlisting>device          wlan_wep        # 802.11 WEP support
device          wlan_ccmp       # 802.11 CCMP support
device          wlan_tkip       # 802.11 TKIP support</programlisting>

    <para>Criptografía en dispositivos 802.11.  Necesita
      estas líneas si quiere utilizar criptografía
      y protocolos de seguridad 802.11.</para>

    <programlisting>device          an         # Aironet 4500/4800 802.11 wireless NICs.
device          ath             # Atheros pci/cardbus NIC's
device          ath_hal         # Atheros HAL (Hardware Access Layer)
device          ath_rate_sample # SampleRate tx rate control for ath
device          awi        # BayStack 660 and others
device          ral        # Ralink Technology RT2500 wireless NICs.
device          wi         # WaveLAN/Intersil/Symbol 802.11 wireless NICs.
#device         wl         # Older non 802.11 Wavelan wireless NIC.</programlisting>

    <para>Diversas tarjetas inalámbricas.</para>

    <programlisting># Pseudo devices
device   loop          # Network loopback</programlisting>

    <para>El dispositivo de «loopback» para
      TCP/IP.  Si accede por telnet o FTP
      or FTP to <systemitem>localhost</systemitem> también
      conocido como <systemitem class="ipaddress">127.0.0.1</systemitem>) lo hará a
      través de este dispositivo.  Es
      <emphasis>imprescindible</emphasis> tenerlo en el
      sistema.</para>

    <programlisting>device   random        # Entropy device</programlisting>

    <para>Generador de números criptográficamente
      seguro.</para>

    <programlisting>device   ether         # Ethernet support</programlisting>

    <para><literal>ether</literal> solo es necesario si tiene
      alguna tarjeta Ethernet.  Incluye código
      genérico del protocolo Ethernet.</para>

    <programlisting>device   sl            # Kernel SLIP</programlisting>

    <para><literal>sl</literal> permite utilizar SLIP.  Ha sido
      sustituido casi totalmente por PPP, que es más
      fácil de usar, está mejor capacitado para
      la conexión de módem a módem y es,
      en general, claramente mejor.</para>

    <programlisting>device   ppp           # Kernel PPP</programlisting>

    <para>Este dispositivo incluye en el kernel la capacidad de
      gestionar conexiones de llamada entrante
      «dial-up».  Hay también una versión
      de PPP implementada como aplicación de usuario; utiliza
      <literal>tun</literal> y ofrece más flexibilidad y
      características como la llamada bajo
      petición.</para>

    <programlisting>device   tun           # Packet tunnel.</programlisting>

    <para>Este dispositivo lo usa el software PPP de usuario.
      Consulte la sección sobre
      <link linkend="userppp">PPP</link> de este mismo libro.</para>

    <programlisting><anchor xml:id="kernelconfig-ptys"/>
device   pty           # Pseudo-ttys (telnet etc)</programlisting>

    <para>Este dispositivo es una <quote>pseudoterminal</quote>,
      o un puerto de entrada al sistema simulado.  Se usa en
      sesiones entrantes de <command>telnet</command> y
      <command>rlogin</command>; también lo usan
      <application>xterm</application> y otras aplicaciones, entre
      las que encontramos a <application>Emacs</application>.</para>

    <programlisting>device   md            # Memory <quote>disks</quote></programlisting>

    <para>Pseudodispositivos de disco basados en memoria.</para>

    <programlisting>device   gif           # IPv6 and IPv4 tunneling</programlisting>

    <para>Este dispositivo implementa túneles de IPv6
      sobre IPv4, IPv4 sobre IPv6, IPv4 sobre IPv4 e
      IPv6 sobre IPv6.  El dispositivo
      <literal>gif</literal> se puede clonar a sí mismo,
      así que los nodos de dispositivo se van creando a
      medida que van haciendo falta.</para>

    <programlisting>device   faith         # IPv6-to-IPv4 relaying (translation)</programlisting>

    <para>Este pseudodispositivo captura paquetes que se le
      hayan enviado y los dirige hacia el d&aelig;mon de
      traducción IPv4/IPv6.</para>

    <programlisting># The `bpf' device enables the Berkeley Packet Filter.
# Be aware of the administrative consequences of enabling this!
# Note that 'bpf' is required for DHCP.
device   bpf           # Berkeley packet filter</programlisting>

    <para>El filtro de paquetes de Berkeley. Este pseudodispositivo
      permite poner interfaces de red en modo promíscuo, lo que
      significa que capturan todos los paquetes que circulen por una
      red broadcast (por ejemplo una Ethernet).  Dichos paquetes
      pueden guardarse en disco para su posterior examen mediante
      &man.tcpdump.1; (el análisis con &man.tcpdump.1; no
      puede hacerse directamente también).</para>

    <note>
      <para>El dispositivo &man.bpf.4; también lo usa
	&man.dhclient.8; para obtener direcciones IP del
	encaminador (gateway) por omisión.  Si usa
	DHCP deje esta opción como está.</para>
    </note>

    <programlisting># USB support
device          uhci          # UHCI PCI-&gt;USB interface
device          ohci          # OHCI PCI-&gt;USB interface
device          ehci          # EHCI PCI-&gt;USB interface (USB 2.0)
device          usb           # USB Bus (required)
#device         udbp          # USB Double Bulk Pipe devices
device          ugen          # Generic
device          uhid          # <quote>Human Interface Devices</quote>
device          ukbd          # Keyboard
device          ulpt          # Printer
device          umass         # Disks/Mass storage - Requires scbus and da
device          ums           # Mouse
device          ural          # Ralink Technology RT2500USB wireless NICs
device          urio          # Diamond Rio 500 MP3 player
device          uscanner      # Scanners
# USB Ethernet, requires mii
device          aue           # ADMtek USB Ethernet
device          axe           # ASIX Electronics USB Ethernet
device          cdce          # Generic USB over Ethernet
device          cue           # CATC USB Ethernet
device          kue           # Kawasaki LSI USB Ethernet
device          rue           # RealTek RTL8150 USB Ethernet</programlisting>

    <para>Diversos dispositivos USB.</para>

    <programlisting># FireWire support
device          firewire      # FireWire bus code
device          sbp           # SCSI over FireWire (Requires scbus and da)
device          fwe           # Ethernet over FireWire (non-standard!)</programlisting>

    <para>Diversos dispositivos Firewire.</para>

    <para>Tiene más información y una lista
      con más dispositivos que funcionan en &os;
      consulte
      <filename>/usr/src/sys/i386/conf/NOTES</filename>.</para>

      <sect2>
        <title>Configuraciones con grandes cantidades de memoria
	  (<acronym>PAE</acronym>)</title>
	<indexterm>
	  <primary>Physical Address Extensions
	    (<acronym>PAE</acronym>)</primary>
	  <secondary>large memory</secondary>
	</indexterm>

	<para>Las máquinas que tienen configuraciones
	  con grandes cantidades de memoria necesitan acceder
	  a más de 4 gigabytes de espacio de direcciones
	  <acronym>KVA</acronym> (User+Kernel Virtual
	  Address).  Debido a esta limitación Intel
	  añadió a las CPU &pentium; Pro y modelos
	  posteriores la posibilidad de acceso al espacio de
	  direcciones físicas de 36 bits.</para>

	<para><acronym>PAE</acronym> (Physical Address Extension)
	  a las CPU &intel; &pentium; Pro y los modelos posteriores
	  configuraciones de memoria de hasta 64 gigabytes.
	  Para poder aprovechar esto en &os; existe la
	  opción del kernel
	  <option>PAE</option>, disponible en todas las versiones
	  modernas de &os;.  A causa de esta limitación de
	  memoria en los Intel no hay nada que distinga de
	  algún modo la memoria situada por debajo del
	  límite de los 4 gigabytes.  La memoria que
	  esté por encima de los 4 gigabytes se coloca
	  en el «pool» de memoria disponible.</para>

	<para>Si quiere activar <acronym>PAE</acronym> en el kernel
	  tiene que añadir la siguiente liínea al
	  fichero de configuración del kernel:</para>

	<programlisting>options		    PAE</programlisting>

	<note>
	  <para>En &os; <acronym>PAE</acronym> solamente existe
	    en procesadores &intel; IA-32.  Hemos de advertirle
	    de que <acronym>PAE</acronym> no ha sido probado
	    todo lo necesario, así que debe considerarse
	    de calidad beta, sobre todo si se le compara con
	    otras características de &os;.</para>
	</note>

	<para><acronym>PAE</acronym> en &os; tiene varias
	  limitaciones:</para>

	<itemizedlist>
	  <listitem>
	    <para>Un solo proceso no puede acceder a más
	      de 4 gigabytes de espacio VM.</para>
	  </listitem>

	  <listitem>
	    <para>No puede cargar módulos
	      <acronym>KLD</acronym> en un kernel que tenga
	      <acronym>PAE</acronym> activado debido a las diferencias
	      existentes entre el «framework» de
	      compilación del módulo y el del
	      kernel mismo.</para>
	  </listitem>

	  <listitem>
	    <para>Los controladores de dispositivo que utilizan
	      el interfaz &man.bus.dma.9; pueden provocar
	      corrupción de datos en un kernel con
	      <acronym>PAE</acronym> activado, una excelente
	      razón para no utilizarlos.  Esta es
	      la razón de que &os; incorpore un fichero
	      de configuración de un kernel
	      <filename>PAE</filename> del que se han
	      extraído todos los módulos que
	      se sabe que no funcionan en un kernel con
	      <acronym>PAE</acronym> activado.</para>
	  </listitem>

	  <listitem>
	    <para>Algunos «system tunables» determinan el
	      uso de recursos de memoria basándose en la
	      memoria física disponible.  Estos «tunables»
	      pueden asignar más memoria de la que realmente
	      debieran debido a que el sistema <acronym>PAE</acronym>
	      está íntimamente ligado a cantidades
	      bastante importantes de memoria.  Un ejemplo de esto
	      es la sysctl <option>kern.maxvnodes</option>, que
	      controla el número máximo de vnodes
	      permitidos en el kernel.  Le recomendamos que
	      ajuste este y otros tunables dentro valores
	      razonables.</para>
	  </listitem>

	  <listitem>
	    <para>Es posible que tenga que aumentar el espacio virtual
	      de direcciones del kernel (el <acronym>KVA</acronym>)
	      o reducir la cantidad de recursos exclusivos del kernel
	      que se utilicen exhaustivamente (ver más
	      arriba) para evitar que <acronym>KVA</acronym> literalmente
	      se ahogue.  La opción del kernel
	      <option>KVA_PAGES</option> permite incrementar el
	      espacio <acronym>KVA</acronym>.</para>
	  </listitem>
	</itemizedlist>

	<para>Si quiere saber más sobre la estabilidad
	  del sistema consulte la página de manual de
	  &man.tuning.7;.  La página de manual de &man.pae.4;
	  contiene información actualizada sobre
	  <acronym>PAE</acronym> y &os;.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="kernelconfig-trouble">
    <title>Qué hacer si algo va mal</title>

    <para>Hay cuatro categorías de problemas que
      podemos encontrarnos en el proceso de compilación
      de un kernel personalizado:</para>

    <variablelist>
      <varlistentry>
	<term>Fallo de <command>config</command>:</term>

	<listitem>
	  <para>Si &man.config.8; falla cuando le pasa la
	    descripción de su kernel seguramente ha
	    cometido algún pequeño error.  Por
	    suerte &man.config.8; les mostrará el
	    número de la línea que le está
	    dando problemas, así que no tendrá
	    mayor problema para localizarla. Veamos un
	    ejemplo:</para>

	  <screen>config: line 17: syntax error</screen>

	  <para>Si ve algo así asegúrese de que
	     ha tecleado la palabra clave que hay en esa
	     lína.  Compare la de su fichero de
	     configuración del kernel con la de
	    <filename>GENERIC</filename>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Fallo de <command>make</command>:</term>

	<listitem>
	  <para>If the <command>make</command> command fails, it usually
	    signals an error in your kernel description which is not severe
	    enough for &man.config.8; to catch.  Again, look
	    over your configuration, and if you still cannot resolve the
	    problem, send mail to the &a.questions; with your kernel
	    configuration, and it should be diagnosed quickly.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>El kernel no arranca:<anchor xml:id="kernelconfig-noboot"/></term>

	<listitem>
	  <para>Si su nuevo kernel no arranca o no reconoce sus
	    dispositivos de hardware no desespere.  &os;
	    dispone de excelentes mecanismos de
	    recuperación ante kernels defectuosos.  Elija
	    el kernel con el que quiere arrancar en el gestor
	    de arranque de &os;.  Puede acceder al gestor de
	    arranque en el momento en el que aparece el
	    menú de arranque.  Elija la opción
	    número seis, <quote>Escape to a loader
	    prompt</quote> option, Escriba en el prompt
	    <command>unload kernel</command>
            y después escriba
	    <command>boot /boot/kernel.old/kernel</command>,
            o el nombre de cualquier otro kernel que tenga en el sistema
	    y del que sepa que puede fiarse.  Si va a reconfigurar un
	    kernel es una buenísima idea guardar un kernel
	    que sepa que funciona.</para>

	  <para>Tras arrancar con un kernel de fiar verifique el
	    fichero de configuración e intente de nuevo
	    una compilación.  El fichero
	    <filename>/var/log/messages</filename> es una fuente de
	    información muy valiosa puesto que registra, entre
	    otras cosas, todos los mensajes que deja el kernel cada
	    vez que hay un arranque satisfactorio.  &man.dmesg.8;
	    le mostrará los mensajes que el kernel ha
	    generado durante el último arranque.</para>

	  <note>
	    <para>Si tiene problemas compilando un kernel recuerde que
	      es de vital importancia que guarde una copia de un kernel
	      <filename>GENERIC</filename> u otro del que pueda fiarse
	      y que (esto es muy importante) tenga un nombre distinto de
	      <filename>kernel.old</filename> para evitar que el sistema
	      lo borre una vez que termine una nueva
	      compilación.  No puede confiar en su kernel
	      <filename>kernel.old</filename> porque al instalar un nuevo
	      kernel (que aún no sabe si será el que
	      funcione tal y como espera de él) el kernel
	      <filename>kernel.old</filename> se sobreescribe con el
	      kernel que instale.  Otra cosa importante es que copie
	      ese kernel de fiar a
	      <filename>/boot/kernel</filename>, o
	      ciertas herramientas como &man.ps.1; no
	      funcionarán.  Basta con que haga lo
	      siguiente:</para>

	    <screen>&prompt.root; <userinput>mv /boot/kernel /boot/kernel.malo</userinput>
&prompt.root; <userinput>mv /boot/kernel.bueno /boot/kernel</userinput></screen>

	  </note>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>El kernel funciona, pero &man.ps.1; no:</term>

	<listitem>
	  <para>Si el kernel que tiene instalado es de una
	    versión de &os; y las utilidades del sistema
	    son de otra, por ejemplo un kernel -CURRENT en una
	    -RELEASE, hay muchas herramientas de monitorización
	    del sistema como &man.ps.1; y &man.vmstat.8; no
	    funcionarán.
	    Ejecute un <link linkend="makeworld">make buildworld y un
	    make install world</link> con la misma versión de
	    código fuente con la que ha compilado su
	    kernel.  Esta es una de las razones por las que no
	    es una idea demasiado buena utilizar versiones
	    diferentes de kernel y de sistema operativo.</para>
	</listitem>
      </varlistentry>
    </variablelist>
  </sect1>
</chapter>
