<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE book PUBLIC "-//FreeBSD//DTD DocBook XML V5.0-Based Extension//EN"
	"http://www.FreeBSD.org/XML/share/xml/freebsd50.dtd">
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="es">
  <info><title>Preguntas más frecuentes de FreeBSD 4.X, 5.X y 6.X</title>
    

    <author><orgname>Proyecto de documentación de FreeBSD</orgname></author>

    <copyright>
      <year>1995</year>
      <year>1996</year>
      <year>1997</year>
      <year>1998</year>
      <year>1999</year>
      <year>2000</year>
      <year>2001</year>
      <year>2002</year>
      <year>2003</year>
      <year>2004</year>
      <year>2005</year>
      <holder>The FreeBSD Documentation Project</holder>
    </copyright>

    &legalnotice;

    <releaseinfo>$FreeBSD$</releaseinfo>

    <abstract>
      <para>Ésta es la FAQ de FreeBSD versión 4.X, 5.X y 6.X.
        Todas las secciones están dirigidas a FreeBSD 4.0 y
	superiores.  Los capítulos con &lt;XXX&gt; están bajo
        construcción.  Si estás interesado en colaborar en este
        proyecto, envía un e-mail a la lista de distribución del
        proyecto de documentación de FreeBSD (en inglés)
        &a.doc; o a la dirección
        <link xlink:href="mailto:doc@es.FreeBSD.org">doc@es.FreeBSD.org</link> en
        castellano. La última versión de este documento
	está siempre disponible en el <link xlink:href="http://www.es.FreeBSD.org/es/">Mirror en español de
	FreeBSD</link>.
        Puede obtenerse como un único archivo en formato
        <link xlink:href="book.html">HTML</link> vía HTTP o en formato
	texto, PostScript o PDF desde el <link xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc">servidor FTP de FreeBSD</link>.
        También se pueden hacer <link xlink:href="http://www.FreeBSD.org/search/search.html">búsquedas
        en las FAQ</link>.</para>
    </abstract>
  </info>

  <chapter xml:id="introduction">
    <title>Introducción</title>

    <para>¡Bienvenido a la FAQ de FreeBSD 4.X-6.X!</para>

    <para>Como es habitual con las FAQ de los grupos de noticias (USENET),
    este documento pretende abarcar las preguntas más frecuentes
    referentes al sistema operativo FreeBSD (¡y por supuesto
    contestarlas!).  Pensadas en un principio para reducir el tráfico
    y evitar que se hagan las mismas preguntas una y otra vez, las FAQ se han
    convertido en un valorado recurso de obtención de
    información.</para>

    <para>Todo el esfuerzo se ha hecho en intentar que esta FAQ sea lo
    más informativa posible; si tienes cualquier comentario o
    sugerencia, por favor, envía un correo a &a.doc;.</para>


    <qandaset>
      <qandaentry>
        <question xml:id="what-is-FreeBSD">
          <para>?Qué es FreeBSD?</para>
        </question>

        <answer>
	  <para>De manera resumida, FreeBSD es un sistema operativo tipo &unix; para
	  plataformas Alpha/AXP, AMD64 e Intel EM64T, i386 IA-64, PC-98 y UltraSPARC
	  basado en <quote>4.4BSD-Lite</quote> de la Universidad de Berkeley en
	  California.  También está indirectamente basado en el
	  port de Net/2 para i386 de Berkeley, conocido como
	  <quote>386BSD</quote>, realizado por William Jolitz's. Una
	  descripción más detallada de FreeBSD y de
          cómo puede trabajar, se encuentra en
	  <link xlink:href="http://www.FreeBSD.org/">FreeBSD home page</link>.
	  </para>

	  <para>FreeBSD es usado por compañías, proveedores de
	  Internet, profesionales de la informática, estudiantes y
	  usuarios particulares de todo el mundo en su trabajo,
	  educación y ocio.  Puedes ver a algunos de ellos en
	  <link xlink:href="http://www.FreeBSD.org/gallery.html">FreeBSD Gallery.</link></para>

          <para>Para información más detallada sobre FreeBSD,
	  por favor mira en
          <link xlink:href="../../handbook/index.html">FreeBSD Handbook</link>.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question xml:id="FreeBSD-goals">
          <para>?Cuál es el objetivo del Proyecto FreeBSD?
	    </para>
        </question>

        <answer>
	  <para>El objetivo del Proyecto FreeBSD es proveer software que pueda
	  ser usado en todos los ámbitos sin ningún tipo de
	  atadura.  Muchos de nosotros estamos significativamente involucrados
	  en el desarrollo del código (y del proyecto) y no
	  sería cierto decir que no esperábamos o esperamos
	  algún tipo de financiación, pero definitivamente no
	  estamos preparados para insistir en ello. Creemos que nuestra
	  primera y principal <quote>misión</quote> es proporcionar el
	  código libremente, y en cualquier ámbito, para que el
	  código se difunda lo más posible y genere los mayores
	  beneficios.  Esto es, creemos en uno de los objetivos fundamentales
	  del Software Libre y lo apoyamos de manera incondicional.</para>

	  <para>El código fuente de los programas registrados bajo la
	  <link xlink:href="http://www.FreeBSD.org/copyright/COPYING">
	  GNU General Public License (GPL)</link> o la
	  <link xlink:href="http://www.FreeBSD.org/copyright/COPYING.LIB">
	  GNU Library General Public License (LGPL)</link>, se proporciona
	  bajo las condiciones fijadas por esas licencias. Debido a
	  complicaciones adicionales en el uso comercial de Software GPL,
	  intentamos reemplazar ese software por otros registrados bajo la
	  <link xlink:href="http://www.FreeBSD.org/copyright/freebsd-license.html">
	  licencia FreeBSD</link>,menos estricta y más
	  permisiva.</para>
        </answer>
      </qandaentry>

       <qandaentry>
         <question xml:id="bsd-license-restrictions">
           <para>?Tiene la licencia FreeBSD alguna restricción?
	     </para>
         </question>

         <answer>
           <para>Si. Las restricciones no controlan el uso del código.
             Cualquier duda puede ser contestada leyendo la
             <link xlink:href="http:// www.FreeBSD.org/copyright/freebsd-license.html">
	     licencia</link>. Esta misma puede ser resumida de la siguiente
             manera:</para>

           <itemizedlist>
             <listitem>
               <para>No establecerse asi mismo como autor.</para>
             </listitem>

             <listitem>
               <para>No culpar al proyecto en caso de no funcionar.</para>
             </listitem>
           </itemizedlist>
         </answer>
       </qandaentry>

      <qandaentry>
	<question xml:id="replace-current-OS">
	  <para>?Puede FreeBSD remplazar mi sistema operativo
	    actual?</para>
	</question>

	<answer>
	  <para>Para la mayor parte de la gente, si.  Aunqué
	    esta pregunta no se contesta tan fácilmente.</para>

	  <para>La mayoría de las personas no usa realmente un sistema
	    operativo.  Usan aplicaciones.  Las aplicaciones son las que
	    en realidad usan el sistema operativo.  FreeBSD esta
	    diseñado para proveer un ambiente robusto y listo para
	    aplicaciones.  Soporta una gran variedad de exploradores de web,
	    suites de oficina, lectores de correo electrónico,
	    programas de gráficos, ambientes de programación,
	    servidores y casi todo lo que se desee.  La mayor parte de estas
	    aplicaciones pueden ser encontrádas en la <link xlink:href="http://www.FreeBSD.org/ports/">Colección de
	    Ports</link>.</para>

	  <para>Si se requiere de una aplicación solamente disponible
	    para un sistema operativo, simplemente no puede cambiar ese
	    sistema operativo.  Aunqué muy probablemente encuentre una
	    aplicación  muy parecida en FreeBSD.  Si lo que se desea
	    es una sólida oficina o un servidor de Internet, una
	    estación de trabajo confiable, o solamente la habilidad
	    de trabajar sin interrupciones, FreeBSD seguramente hará
	    lo que usted necesita.  Una gran cantidad de usuarios alrededor
	    del mundo, incluyendo novatos y usuarios de &unix; experimentados
	    usan FreeBSD como su sistema operativo.</para>

	  <para>Si se desea migrar a FreeBSD desde algún otro ambiente
	    &unix;, usted ya sabe mas de lo que se necesita.  Si su constumbre
	    es un sistema operativo gráfico como Windows o viejas
	    versiones de Mac OS, usted tendrá que invertir mas tiempo
	    aprendiendo la forma en la que &unix; hace las cosas.  Este FAQ
	    y el <link xlink:href="../handbook/index.html">FreeBSD Handbook</link>
	    son excelentes lugares donde empezar.</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question xml:id="why-called-FreeBSD">
          <para>?Por qué se llama FreeBSD?</para>
        </question>

        <answer>
          <para>
            <itemizedlist>

              <listitem>
                <para>Este sistema debe ser usado libremente, sin coste alguno
                incluso para fines comerciales.</para>
              </listitem>

              <listitem>
		<para>El código fuente completo del sistema operativo
		es de libre distribución, y se han establecido el menor
		número posible de restricciones para su uso,
		distribución e incorporación a otras
		aplicaciones (comerciales o no).</para>
              </listitem>

              <listitem>
		<para>Cualquier persona que tenga alguna sugerencia de mejora
		y/o <quote>parche</quote> de algún <quote>bug</quote>,
		es libre de enviar el código y que éste sea
		añadido al código fuente de la
		distribución original (sujeto a una o dos condiciones
		obvias).</para>
              </listitem>
            </itemizedlist>
          </para>

	  <para>Para todos nuestros lectores cuyo primer lenguaje no sea el
	  inglés, aclaremos que la palabra <quote>free</quote> es
	  usada en dos sentidos, uno significando <quote>sin coste</quote> y
	  el otro <quote>puedes hacer lo que quieras</quote>. Aparte de una o
	  dos cosas que no puedes hacer con el código de FreeBSD, por
	  ejemplo decir que lo has escrito, realmente puedes hacer lo que
	  quieras con él.</para>
        </answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="differences-to-other-bsds">
	  <para>?Cuales son las diferencias entre FreeBSD y NetBSD,
	    OpenBSD y otros sistemas operativos BSD libres?</para>
	</question>

	<answer>
	  <para>James Howard escribió una buena explicación
	    para <link xlink:href="http://www.daemonnews.org/">DaemonNews</link>,
	    acerca de la historia y las diferencias entre los diferentes
	    proyectos, llamada <link xlink:href="http://www.daemonnews.org/200104/bsd_family.html">The BSD
	    Family Tree</link>, la cual puede contestar esta pregunta.</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question xml:id="lastest-version">
          <para>?Cuál es la última versión de
	    FreeBSD?</para>
        </question>

        <answer>
          <para>La versión
          <link xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/4.9-RELEASE">4.9R</link>
	  es la última <emphasis>-STABLE</emphasis>; fue declarada
	  definitiva (a partir de ahora <quote>release</quote>) en Diciembre
	  de 2003.</para>

	  <para>Brevemente explicado, <option>-STABLE</option> está
	  dirigido a proveedores de Internet y otros usuarios corporativos que
	  quieren estabilidad y una sucesión tranquila en los cambios y
	  actualizaciones a las nuevas versiones y sus mejoras. Sólo
	  debes usar la rama <emphasis>-CURRENT</emphasis> si estás
	  seguro de estar preparado para su mayor <quote>volatilidad</quote>
	  (relativa a <emphasis>-STABLE</emphasis>).</para>

	  <para>Las versiones Release se hacen cada
	  <link linkend="release-freq">varios meses</link>.  Aunque mucha
	  gente mantiene más al día los fuentes de FreeBSD
	  (lee las preguntas en <link linkend="current">
	  FreeBSD-CURRENT</link> y <link linkend="stable">
	  FreeBSD-STABLE</link>, ello está pensado para gente que se
	  considere preparada para seguir el desarrollo continuo del
	  código fuente.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question xml:id="current">
          <para>?Qué es FreeBSD-CURRENT?</para>
        </question>

        <answer>
	  <para><link xlink:href="../../handbook/cutting-edge.html#CURRENT">FreeBSD-CURRENT</link>
	  es la versión de desarrollo del sistema operativo, la cual
	  acabará siendo la versión &os.stable;. Como es de
	  suponer, esta versión es de interés sólo para
	  los desarrolladores que trabajan en el sistema y
	  <quote>masoquistas</quote> de la programación.  Mira la
	  <link xlink:href="../../handbook/cutting-edge.html#CURRENT">
	  sección correspondiente</link> en el
	  <link xlink:href="../../handbook/index.html">handbook</link>
	  para saber cómo funciona esta opción.</para>

	  <para>Si no estás familiarizado con el sistema operativo o no
	  eres capaz de identificar la diferencia entre un problema real y un
	  problema temporal, no deberías usar FreeBSD-CURRENT. Esta
	  rama a veces avanza muy rápidamente y puede no ser compilable
	  durante unos días.  La gente que usa FreeBSD-CURRENT es capaz
	  de analizar los problemas y sólo comunicarlos si son motivo
	  de errores. Preguntas como <quote>al ejecutar make world obtengo un
	  error referente a grupos</quote> en la lista de distribución
	  -CURRENT pueden quedar fuera de lugar.</para>

          <para>Una release
	  <link xlink:href="../releases/snapshots.html">snapshot</link> corresponde
	  al desarrollo de la rama -CURRENT; distribuciones en CDROM de esta
	  versión están disponibles. Los objetivos de cada
	  release snapshot son:</para>

          <para>
            <itemizedlist>
              <listitem>
		<para>Comprobar la última versión del software
		de instalación.</para>
              </listitem>

              <listitem>
		<para>Dar a la gente que le gustaría usar la
		versión -CURRENT, pero que no tiene el tiempo
		suficiente para seguir el ritmo diario de actualizaciones,
		una manera fácil de poder instalarla en su sistema.
		</para>
              </listitem>

              <listitem>
		<para>Preservar un punto de referencia fijado en el
		código en cuestión, sólo en caso de que
		``rompamos'' algo realmente importante. (De todas maneras, el
		 CVS normalmente previene de que cosas tan horribles como
		éstas puedean suceder :)</para>
              </listitem>

              <listitem>
		<para>Asegurar que las nuevas características
		desarrolladas puedan ser comprobadas suficientemente por el
		mayor número de gente.</para>
              </listitem>

            </itemizedlist>
          </para>

	  <para>No se garantiza que ningún snapshot pueda ser
	  considerado <quote>calidad de producción</quote>. Para
	  conseguir estabilidad y un sistema garantizado, tendrás que
	  usar las versiones release.</para>

          <para>Las release snapshot están directamente disponibles en
          <link xlink:href="ftp://current.FreeBSD.org/pub/FreeBSD/">ftp://current.FreeBSD.org/pub/FreeBSD/</link>
	  y son generadas un promedio de una vez por día para las ramas
	  4.0-CURRENT y 3.0-STABLE.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question xml:id="stable">
          <para>?Qué significa FreeBSD-STABLE?</para>
        </question>

        <answer>
	  <para>Cuando la versión de FreeBSD 2.0.5 fue declarada
	  release, decidimos dividir el desarrollo de FreeBSD en dos ramas.
	  Una rama fue llamada
	  <link xlink:href="../handbook/current-stable#STABLE.html">-STABLE</link>,
	  otra <link xlink:href="../handbook/current-sable#CURRENT.HTML">-CURRENT</link>.
	  FreeBSD-STABLE está previsto para provedores de Internet y
	  otras empresas para las que no resultan deseables cambios
	  repentinos o experimentales.  FreeBSD-CURRENT, por otra parte, ha
	  sido la línea común desde la release 2.0, llegando
	  hasta 5.2.1-RELEASE (y más allá).  Se espera que
	  5-STABLE sea creado a la salida de 5.3-RELEASE y es entoncés
	  cuando &os.current; pasará a ser 6-CURRENT.  Aquí hay
	  un pequeño gráfico ASCII para ayudar a entender este
	  sistema de desarrollo:</para>

          <programlisting>                 2.0
                  |
                  |
                  |  [2.1-STABLE]
 *BRANCH*       2.0.5 -&gt; 2.1 -&gt; 2.1.5 -&gt; 2.1.6 -&gt; 2.1.7.1  [2.1-STABLE termina]
                  |                            (Mar 1997)
                  |
                  |
                  |  [2.2-STABLE]
 *BRANCH*       2.2.1 -&gt; 2.2.2-RELEASE -&gt; 2.2.5 -&gt; 2.2.6 -&gt; 2.2.7 -&gt; 2.2.8 [termina]
                  |       (Mar 1997)    (Oct 97) (Abr 98) (Jul 98) (Dic 98)
                  |
                  |
               3.0-SNAPs  (comenzado Q1 1997)
                  |
                  |
               3.0-RELEASE (Oct 1998)
                  |
                  |  [3.0-STABLE]
 *BRANCH*      3.1-RELEASE  (Feb 1999) -&gt; 3.2 -&gt; 3.3 -&gt; 3.4 -&gt; 3.5 -&gt; 3.5.1
                  |                     (May 1999) (Sep 1999) (Dic 1999) (Junio 2000) (Julio 2000)
                  |
                  |  [4.0-STABLE]
 *BRANCH*        4.0  (Mar 2000) -&gt; 4.1 -&gt; 4.1.1 -&gt; 4.2 -&gt; 4.3 -&gt; 4.4 -&gt; ... later 4.X releases ...
                  |
                  |              (Julio 2000)   (Sep 2000)   (Nov 2000)
               5.0-RELEASE (Enero 2003)
                  |
                  |
               5.1-RELEASE (Junio 2003)
                  |
                  |
               5.2-RELEASE
                  |
                  |
               5.2.1-RELEASE (Febrero 2004)
                 \|/
                  +
          [5-CURRENT continua]</programlisting>

	  <para>La version 2.2-STABLE fue retirada con el release 2.2.8.  La
	    rama 3-STABLE  fue terminada con la release 3.5.1, la
	    última release de 3.X.  Los únicos cambios que se
	    le podrían hacer son arreglos en la seguridad.</para>

	  <para>4-STABLE es actualmente el branch -STABLE en desarrollo.
	    El ultimo release en branch 4-STABLE es &rel2.current;-RELEASE,
	    el cual fue hecho en &rel2.current.date;.</para>

	  <para>La rama 5-CURRENT progresa lentamente hacia la
	    creación de la rama 5-STABLE.  Ver
	    <link linkend="current">?Qué es
	    FreeBSD-CURRENT?</link> para mas información sobre esta
	    rama.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question xml:id="release-freq">
          <para>?Cuando se realizan las releases de FreeBSD?</para>
        </question>

        <answer>
	  <para>El &a.re; publica una nueva versión de FreeBSD cada 4
	    meses aproximadamente.  Las fechas de las nuevas versiones se
	    anuncian por adelantado, con la finalidad de que los
	    desarrolladores trabajando en el sistema sepan cuando deben
	    terminar sus  proyectos para ser probados e integrados en el
	    sistema.  Hay un periodo de prueba para cada release, para
	    asegurar que los nuevos cambios introducidos en el sistema no
	    comprometan la estabilidad de la versión.  Algunos
	    usuarios califican esta precaución como una de las mejores
	    características de FreeBSD, aunque esperar el alcance de
	    -STABLE puede ser un poco frustrante.</para>

	  <para>Mas información en el proceso de las releases
	    (incluyendo fechas y releases futuras) puede ser encontrada en
	    la página de
	    <link xlink:href="http://www.FreeBSD.org/releng/index.html">release
	    engineering</link>.</para>

	  <para>Para personas que quieran o necesiten más
	    emoción, diariamente se crean snapshots binarios de la
	    misma manera.</para>
        </answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="responsible">
          <para> ?Quién es responsable de FreeBSD?</para>
        </question>

        <answer>
	  <para>Las decisiones clave concernientes al proyecto FreeBSD como la
	  dirección a seguir y quién está autorizado a
	  añadir código a la distribución original, se
	  hace a través de un grupo de unas 17 personas llamado
	  <link xlink:href="../../handbook/staff.html#STAFF-CORE">core team</link>.
	  Existe también un grupo de unas 150 personas o
	  <link xlink:href="../../handbook/staff-committers.html">committers</link>
	  que también están autorizadas a realizar cambios
	  directamente sobre la distribución original.</para>

	  <para>De todas maneras, la cambios importantes son discutidos en las
	  <link linkend="mailing">listas de distribución</link> en las
	  que no existen restricciones sobre quién participa en las
	  discusiones.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question xml:id="where-get">
          <para>?Dónde puedo conseguir FreeBSD?</para>
        </question>

        <answer>
	  <para>Todas las versiones release de FreeBSD están
	  disponibles via ftp anónimo en
	  <link xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/">el servidor FTP de
	  FreeBSD</link>:</para>

            <itemizedlist>
              <listitem>
                <para>Para la actual 3.X-STABLE release, 3.5.1-RELEASE  mira
		  en
                <link xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/3.4-RELEASE/">3.5.1-RELEASE</link>.
                </para>
              </listitem>

              <listitem>
		<para>La ultima 5.X release, &rel.current;-RELEASE puedes
		  encontrarla en el
		  <link xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/&rel.current;-RELEASE/">directorio &rel.current;-RELEASE</link>.</para>
	      </listitem>

	      <listitem>
                <para>Para la actual 4-STABLE release, &rel.current;-RELEASE,
		  mira en
                <link xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/&rel2.current;-RELEASE/">directorio &rel2.current;-RELEASE</link>.</para>
              </listitem>

              <listitem>
		<para><link xlink:href="ftp://releng4.FreeBSD.org/pub/FreeBSD/">4.X
		snapshots</link> son construidos diariamente.</para>
              </listitem>

              <listitem>
		<para><link xlink:href="ftp://current.FreeBSD.org/pub/FreeBSD/">5.0
		Snapshot</link> releases son hechas una vez al día a
		partir de la rama <link linkend="current">-CURRENT</link>,
		siendo éste un servicio puramente para
		desarrolladores.</para>
              </listitem>
            </itemizedlist>

	  <para>Más información acerca de como obtener FreeBSD
	    en CD, DVD, y otros medios en
	    <link xlink:href="../handbook/mirrors.html">el Handbook
	    </link>.</para>
	  </answer>
      </qandaentry>

      <qandaentry>
	<question xml:id="howto-mirror">
	  <para>?Cómo puedo instalar un mirror de FreeBSD?
	    </para>
      </question>

	<answer>
	  <para>Puedes encontrar información acerca de como instalar un
	    mirror de FreeBSD en el artículo <link xlink:href="../../articles/hubs/">
	    Mirroring FreeBSD</link>.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question xml:id="mailing">
	  <para>?Dónde encuentro información sobre las
	  listas de distribución de FreeBSD?</para>
        </question>

        <answer>
	  <para>Puedes encontrar toda la información en
	  <link xlink:href="../../handbook/eresources.html#ERESOURCES-MAIL">la
	  sección de listas del Handbook.</link></para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
	  <para>?Qué grupos de noticias están disponibles
	  sobre FreeBSD?</para>
        </question>

        <answer>
	  <para>Puedes encontrar toda la información en <link xlink:href="../../handbook/eresources-news.html">la sección de news
	  del Handbook.</link></para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
	  <para>?Hay algun canal IRC (Internet Relay Chat) sobre
	  FreeBSD?</para>
        </question>

        <answer>
          <para>Sí, muchas de las grandes redes de IRC tienen canales
	  de chat de FreeBSD.</para>

            <itemizedlist>
              <listitem>
		<para>El canal <literal>#FreeBSD</literal> en <link xlink:href="http://www.efnet.org/index.php">EFNet</link>
		es un fórum de FreeBSD, pero no acudas allí para
		obtener soporte técnico o contar tus penas sobre como
		leer las páginas man ;).  Es un canal de chat, de
		principio a fín, y los temas que se tratan suelen ser
		cosas como sexo, deportes o armas nucleares.
		¡Estás avisado!.  Disponible en el servidor
		  <systemitem>irc.chat.org</systemitem>.</para>
              </listitem>

              <listitem>
		<para>El canal <literal>#FreeBSD</literal> en
		  <link xlink:href="http://www.dal.net/">DALNET</link>
		  está disponible en el servidor
		  <systemitem>irc.dal.net</systemitem> en USA y
		  <systemitem>irc.eu.dal.net</systemitem> en Europa.</para>
              </listitem>

              <listitem>
		<para>El canal <literal>#FreeBSD</literal> en
		  <link xlink:href="http://www.undernet.org/">UNDERNET</link>
		  está disponible en
		  <systemitem>us.undernet.org</systemitem> en USA y
		  <systemitem>eu.undernet.org</systemitem> en Europa. Igual que en
		EFNET, no hagas preguntas técnicas. Es un canal de
		chat, no de soporte.</para>
              </listitem>

              <listitem>
		<para>El canal <literal>#FreeBSD</literal> en <link xlink:href="http://www.hybnet.net/">HybNet</link>.  Este
		  canal <emphasis>es</emphasis> un canal de ayuda.  Puedes
		  encontrar la lista de servidores en el <link xlink:href="http://www.hybnet.net/">website de HybNet</link>.
		  </para>
              </listitem>
            </itemizedlist>

	  <para>Cada uno de estos canales es diferente y no están
	  conectados entre ellos. Sus estilos de chat difieren, por lo que
	  podrís probarlos todos para ver cuál te gusta
	  más.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>Libros sobre FreeBSD</para>
        </question>

        <answer>
	  <para>El libro de Greg Lehey's ``Installing and Running FreeBSD''
	  está disponible en Walnut Creek y se vende con el CDROM
	  2.2.5.  Hay también un libro más completo titulado
	  ``The Complete FreeBSD'', el cual tiene manuales adicionales e
	  incluye el CDROM 2.2.6. Debería estar disponible en las
	  mejores librerías.</para>

	  <para>Hay un proyecto de documentación de FreeBSD con el que
	  puedes contactar (o mejor, participar), en la lista de
	  distribución <emphasis remap="tt">doc</emphasis>:
	  <link xlink:href="mailto:doc@FreeBSD.org">&lt;doc@FreeBSD.org&gt;</link>.
	  En esta lista se tratan todos los temas referentes a la
	  documentación de FreeBSD. Para verdaderas preguntas sobre
	  FreeBSD, existe la lista <emphasis remap="tt">question</emphasis>:
	  <link xlink:href="mailto:questions@FreeBSD.org">&lt;questions@FreeBSD.org&gt;</link>.
	  </para>

	  <para>Está disponible un ``manual'' (handbook a patir de
	  ahora) de FreeBSD, y se puede encontrar en:
	  <link xlink:href="../../handbook/index.html">El Handbook de FreeBSD</link>.
	  Ten en cuenta que éste es un trabajo en constante desarrollo
	  y actualización, por lo que algunas secciones podrían
	  estar incompletas.</para>

	  <para>Teniendo en cuenta que FreeBSD 2.2.x está basado en la
	  versión Berkeley 4.4BSD-Lite2, la mayoría de manuales
	  de 4.4BSD con aplicables a FreeBSD 2.2.x. O'Reilly y Asociados
	  publican estos manuales:</para>

          <para>
            <itemizedlist>
              <listitem>
                <para>4.4BSD System Manager's Manual <!-- <br> -->
                By Computer Systems Research Group, UC Berkeley <!-- <br> -->
                1st Edition June 1994, 804 pages <!-- <br> -->
                ISBN: 1-56592-080-5 <!-- <br> -->
                </para>
              </listitem>

              <listitem>
                <para>4.4BSD User's Reference Manual <!-- <br> -->
                By Computer Systems Research Group, UC Berkeley <!-- <br> -->
                1st Edition June 1994, 905 pages <!-- <br> -->
                ISBN: 1-56592-075-9 <!-- <br> -->
                </para>
              </listitem>

              <listitem>
                <para>4.4BSD User's Supplementary Documents <!-- <br> -->
                By Computer Systems Research Group, UC Berkeley <!-- <br> -->
                1st Edition July 1994, 712 pages <!-- <br> -->
                ISBN: 1-56592-076-7 <!-- <br> -->
                </para>
              </listitem>

              <listitem>
                <para>4.4BSD Programmer's Reference Manual <!-- <br> -->
                By Computer Systems Research Group, UC Berkeley <!-- <br> -->
                1st Edition June 1994, 886 pages <!-- <br> -->
                ISBN: 1-56592-078-3 <!-- <br> -->
                </para>
              </listitem>

              <listitem>
                <para>4.4BSD Programmer's Supplementary Documents
                By Computer Systems Research Group, UC Berkeley <!-- <br> -->
                1st Edition July 1994, 596 pages <!-- <br> -->
                ISBN: 1-56592-079-1 <!-- <br> --></para>
              </listitem>
            </itemizedlist>
          </para>

	  <para>Una descripción de éstos puede ser encontrada
	  vía WWW en:</para>

	  <para><link xlink:href="http://gnn.com/gnn/bus/ora/category/bsd.html">Descripción de libros sobre 4.4BSD</link></para>

	  <para>Para profundizar más en la organizacion del kernel de
	  4.4BSD, no puedes ir mal con los siguientes:</para>

          <para>McKusick, Marshall Kirk, Keith Bostic, Michael J Karels,
          and John Quarterman.<!-- <br> --></para>

          <para><emphasis>The Design and Implementation of the 4.4BSD
	  Operating System</emphasis>.  Reading, Mass. : Addison-Wesley, 1996.<!-- <br> -->
          ISBN 0-201-54979-4<!-- <br> --></para>

          <para>Un buen libro en administración de sistemas es:</para>

          <para>Evi Nemeth, Garth Snyder, Scott Seebass &amp; Trent R. Hein,<!-- <br> -->
          ``Unix System Administration Handbook'', Prentice-Hall, 1995<!-- <br> -->
          ISBN: 0-13-151051-7<!-- <br> --></para>

          <para><acronym>NOTA</acronym> Asegurate de conseguir la segunda
	  edición, con cubierta roja y no la primera.</para>

	  <para>Este libro cubre las necesidades básicas, así
	  como TCP/IP, DNS, NFS,SLIP/PPP, sendmail, INN/NNTP,
	  impresión, etc,.  Es caro, (aproximadamente unos
	  US&dollar;45-&dollar;55), pero vale la pena.  También incluye un
	  CD-ROM con los fuentes de varias herramientas, muchas de las cuales
	  están incluidas, también, en la versión 2.2.6R
	  (CDROM) de FreeBSD, incluso incluyendo versiones más
	  modernas.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
	  <para>?Cómo accedo a la base de datos de Problem
	  Report?</para>
        </question>

        <answer>
	  <para>La base de datos de Problem Report puede ser consultada
	  vía web a traves de la dirección
	  <link xlink:href="http://www.FreeBSD.org/cgi/query-pr-summary.cgi">query</link>.
	  También pueden ser enviados vía web a través de
	  la dirección
	  <link xlink:href="http://www.FreeBSD.org/send-pr.html">envio</link>.
	  El comando <command>send-pr(1)</command> también puede ser
	  usado para el envío de reporte de problemas.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
	  <para>?Dónde puedo obtener versiones ASCII/PostScript
	  de la FAQ?</para>
        </question>

        <answer>
          <para>La FAQ actualizada está disponible en el servidor Web
	  de FreeBSD o en cualquiera de los mirrors en formato PostScript y
	  texto (7 bits ASCII y 8 bits Latin-1).</para>

          <para>Formato PostScript (unos 370KB):
            <itemizedlist>
              <listitem>
                <para><link xlink:href="http://www.FreeBSD.org/FAQ/FAQ.ps">http://www.FreeBSD.org/FAQ/FAQ.ps</link></para>
              </listitem>
            </itemizedlist>
          </para>

          <para>Formato ASCII (unos 220KB):
            <itemizedlist>
              <listitem>
                <para><link xlink:href="http://www.FreeBSD.org/FAQ/FAQ.ascii">http://www.FreeBSD.org/FAQ/FAQ.ascii</link></para>
              </listitem>
            </itemizedlist>
          </para>

          <para>Formato texto ISO 8859-1 (unos 220KB):
            <itemizedlist>
              <listitem>
                <para><link xlink:href="http://www.FreeBSD.org/FAQ/FAQ.latin1">http://www.FreeBSD.org/FAQ/FAQ.latin1</link></para>
              </listitem>
            </itemizedlist>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
	  <para>?Dónde puedo obtener versiones ASCII/PostScript
	  del Handbook?</para>
        </question>

      <answer>
	<para>El Hansbook actualizado está disponible en el servidor
	  Web de FreeBSD o en cualquiera de los mirrors en formato PostScript
	  y texto (7 bits ASCII y 8 bits Latin-1).</para>

        <para>Formato PostScript (unos 1.7MB):
          <itemizedlist>
            <listitem>
              <para><link xlink:href="http://www.FreeBSD.org/handbook/handbook.ps">http://www.FreeBSD.org/handbook/handbook.ps</link></para>
            </listitem>
          </itemizedlist>
        </para>

        <para>Formato ASCII (unos 1080KB):
          <itemizedlist>
            <listitem>
              <para><link xlink:href="http://www.FreeBSD.org/handbook/handbook.ascii">http://www.FreeBSD.org/handbook/handbook.ascii</link></para>
            </listitem>
          </itemizedlist>
        </para>

        <para>Formato texto ISO 8859-1 (unos 1080KB):
          <itemizedlist>
            <listitem>
              <para><link xlink:href="http://www.FreeBSD.org/handbook/handbook.latin1">http://www.FreeBSD.org/handbook/handbook.latin1</link></para>
            </listitem>
          </itemizedlist>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>El Handbook en ASCII no está en texto plano!</para>
      </question>

      <answer>
        <para>Cierto, las versiones ASCII y Latin1 del Handbook no
	  están estrictamente en formato de texto plano; contienen
	  carácteres de control de impresión asumiendo que el
	  documento será enviado a una impresora. Si necesitas
	  tenerlos en un formato leible, pasa el archivo por el programa col:
	  </para>

        <para>
          <literallayout>
$ col -b &lt; inputfile &gt; outputfile
          </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Me gustaría ser Mirror del web de FreeBSD!</para>
      </question>

      <answer>
        <para>Hay múltiples maneras de hacer mirror de las
	  páginas web.</para>
        <para>
          <itemizedlist>
            <listitem>
	      <para>Usando CVSUP: Puedes obtener todo el contenido del web
	      usando el programa CVSUP desde el servidor cvsup.FreeBSD.org.
	      Añade esta línea a tu archivo de
	      configuración de cvsup:

              <literallayout>
www release=current hostname=/home base=/usr/local/etc/cvsup
prefix=/usr/local/www/data/www.FreeBSD.org delete old use-rel-suffix
              </literallayout>

              </para>
            </listitem>

            <listitem>
	      <para>Usando rsync: Mira en
	      <link xlink:href="http://www.FreeBSD.org/internal/mirror.html">la
	      página de mirrors</link> para más
	      información.</para>
            </listitem>

            <listitem>
	      <para>Usando mirror de FTP: Puedes bajarte la copia de los
	      contenidos del web usando tu herramienta favorita de mirror de
	      FTP. Simplemente empieza en
	      ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-current/www.</para>
            </listitem>
          </itemizedlist>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Me gustaría traducir la documentación.</para>
      </question>

      <answer>
	<para>Bueno, no podemos pagar, pero quizás te enviemos un
	  CD-ROM o una camiseta y añadiremos tu nombre en la
	  sección ``Contributors'' del Handbook si nos envías
	  una traducción de la documentación.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Otras fuentes de información.</para>
      </question>

      <answer>
        <para>Los siguientes grupos de news contienen temas relacionados con
        FreeBSD y sus usuarios:</para>

        <para>
          <itemizedlist>
            <listitem>
              <para><link xlink:href="news:comp.unix.bsd.FreeBSD.announce">comp.unix.bsd.FreeBSD.announce</link> (moderada)
              </para>
            </listitem>

            <listitem>
              <para><link xlink:href="news:comp.unix.bsd.FreeBSD.misc">comp.unix.bsd.FreeBSD.misc</link>
              </para>
            </listitem>

            <listitem>
              <para><link xlink:href="comp.unix.bsd.misc">comp.unix.bsd.misc</link>
	        </para>
            </listitem>
          </itemizedlist>
        </para>

        <para>Recursos Web:</para>

        <para>
          <itemizedlist>
            <listitem>
              <para>The <link xlink:href="http://www.FreeBSD.org/">FreeBSD Home Page</link>.
	        </para>
            </listitem>

            <listitem>
	      <para><anchor xml:id="pao"/>Si tienes un portátil asegurate de
	      pasar por <link xlink:href="http://www.jp.FreeBSD.org/PAO/">Tatsumi
	      Hosokawa's Mobile Computing page</link>.</para>
            </listitem>

            <listitem>
	      <para><anchor xml:id="smp"/>Información sobre SMP (Symmetric
	      MultiProcessing),
	      <link xlink:href="http://www.FreeBSD.org/~fsmp/SMP/SMP.html">soporte
	      de SMP</link>.</para>
            </listitem>

            <listitem>
	      <para><anchor xml:id="multimedia"/>Información sobre
	      aplicaciones <link xlink:href="http://www.FreeBSD.org/~faulkner/multimedia/mm.html">multimedia</link>.
	      Si estás interesado específicamente en el chip
	      <link xlink:href="http://www.FreeBSD.org/~ahasty/Bt848.html">Bt848</link>
	      de vídeo captura, entonces sigue este link.</para>
            </listitem>
          </itemizedlist>
        </para>

	<para>El handbook de FreeBSD tiene una completa bibliografía en
	la sección <link xlink:href="../../handbook/bibliography.html">bibliografía</link>
	la cual recomendamos leer si estás interesado en comprar libros
	actuales relacionados con estos temas.</para>
      </answer>
    </qandaentry>
  </qandaset>
</chapter>

<chapter xml:id="install">
  <title>Instalación</title>

  <qandaset>
    <qandaentry>
      <question>
        <para>?Qué archivo necesito para instalar FreeBSD?
	  </para>
      </question>

      <answer>
	<para>Generalmente sólo es necesario un disco de 1,44Mb con una
	imgen del archivo <filename>floppies/boot.flp</filename>. Arranca con
	este disco para comenzar con el programa de instalación, el
	cual se encargará de realizar todas las operaciones necesarias
	(gestión de TCP/IP, cintas, CDROMs, floppies, particiones DOS y
	cualquier cosa necesaria para realizar la instalación).</para>

	<para>Si necesitas bajarte las distribuciones (para una
	instalación desde una partición DOS por ejemplo), estas
	son las distribuciones mínimas que necesitarás:</para>

        <para>
          <itemizedlist>
            <listitem>
              <para> bin/<!-- <br> --></para>
            </listitem>

            <listitem>
              <para> manpages/<!-- <br> --></para>
            </listitem>

            <listitem>
              <para> compat*/<!-- <br> --></para>
            </listitem>

            <listitem>
              <para> doc/ <!-- <br> --></para>
            </listitem>

            <listitem>
              <para> src/ssys.* <!-- <br> --></para>
            </listitem>
          </itemizedlist>
        </para>

        <para>Todas las instrucciones sobre este procedimiento y una
        ampliación de la documentación se puede encontrar en
        <link xlink:href="../../handbook/install.html">Instalación de FreeBSD.</link>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>¡Ayuda!, La imagen del disco de arranque no cabe en un
	floppy</para>
      </question>

      <answer>
	<para>Un floppy de 1.44MB puede contener hasta 1474560 bytes de datos.
	La imagen de arranque es exactamente de 1474560 bytes.</para>

	<para>Los errores más comunes en la preparación de disco
	de arranque son:
        <itemizedlist>
          <listitem>
	    <para>No bajarse la imagen en modo
	    <emphasis remap="tt">binario</emphasis> cuando se usa
	    <acronym>FTP</acronym>.</para>

	    <para>Algunos clientes FTP intentan bajar por defecto los archivos
	    en modo <acronym>ASCII</acronym> e intentan cambiar los caracteres
	    de final de línea recibidos por el que utilice el sistema
	    cliente.  Esto corromperá inevitablemente la imagen de
	    arranque. Revisa el tamaño de la imagen: si no es
	    <emphasis>exactamente</emphasis> el mismo tamaño del
	    archivo existente en el servidor, la imagen no servirá.
	    </para>

	    <para>Solución: teclea <emphasis remap="tt">binary</emphasis>
	    en la línea de comandos del FTP después de conectar
	    y antes de empezar a bajar la imágen.</para>

	    <para/>
          </listitem>

          <listitem>
	    <para>Usando el comando <emphasis remap="tt">copy</emphasis> de DOS
	    (o cualquier herramienta GUI equivalente) para transferir la
	    imagen a un disquete.</para>

	    <para>Programas como <emphasis remap="tt">copy</emphasis> no
	    funcionarán para la transferencia de la imagen a un
	    disco. La imagen tiene el contenido completo del disco,
	    pista por pista, y no está pensada para ser trasladada a un
	    disquete como un archivo normal. Tienes que hacer una
	    transferencia ``raw'' usando herramientas de bajo nivel como
	    <emphasis remap="tt">fdimage</emphasis> o
	    <emphasis remap="tt">rawrite</emphasis>, descritas en
	    <link xlink:href="../../handbook/install.html">la guía de
	    instalación de FreeBSD</link>.</para>
          </listitem>
        </itemizedlist>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>?Dónde puedo encontrar las instrucciones de
	instalación de FreeBSD?</para>
      </question>

      <answer>
        <para>Las instrucciones de instalación están en
        <link xlink:href="../../handbook/install.html">Instalación de FreeBSD.</link></para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Qué necesito para poder ejecutar FreeBSD?</para>
      </question>

      <answer>
	<para>Necesitarás un PC con 386 o superior, 5 Mb o más
	de memoria RAM y al menos 60 Mb de espacio en disco duro. Puede
	funcionar con tarjetas gráficas de bajo nivel (Hercules), pero
	para poder ejecutar X11R6 es necesario una tarjeta VGA o superior.
	</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>Sólo tengo 4Mb de RAM. ?Puedo instalar
	FreeBSD?</para>
      </question>

      <answer>
	<para>FreeBSD 2.1.7 fue la última version de FreeBSD que
	podía ser instalada en un sistema de 4Mb. Las nuevas versiones
	de FreeBSD, como la 2.2, necesitan al menos 5Mb para poder ser
	instaladas.</para>

	<para>Todas las versiones de FreeBSD, incluyendo la 3.0,
	funcionarán en sistemas con 4Mb de RAM, lo que no puedes
	ejecutar es la instalación en sistemas con 4Mb. Puedes
	añadir memoria extra para el proceso de instalación, y
	una vez instalado, volver a los 4Mb. Tambien puedes instalar tu disco
	en una máquina con más de 4Mb, realizar la
	instalación y reponer el disco en su máquina con
	4Mb.</para>

	<para>Hay algunas situaciones en las que FreeBSD 2.1.7 no se
	instalará en sistemas con 4Mb. Para ser exactos: no se
	instalará con 640Kb de memoria base + 3Mb de memoria extendida.
	Si tu placa base puede remapear algo de la memoria ``perdida'' fuera
	de los 640Kb a la región de 1Mb, entonces aun podrás
	instalar FreeBSD 2.1.7.</para>

	<para>Intenta entrar en el setup de tu BIOS y busca la opción
	``remap''.  Actívala. Quizás tendrás que
	desactivar la opción de ROM shadowing.</para>

	<para>Es más fácil añadir en la máquina
	4Mb de memoria para la instalación. Crea un kernel unicamente
	con las opciones que necesites y vuelve a quitar los 4Mb
	añadidos.</para>

	<para>También puedes instalar la versión 2.0.5 y a
	continuación actualizar tu sistema a la 2.1.7 con la
	opción ``upgrade'' del programa de instalación de la
	versión 2.1.7.</para>

	<para>Después de la instalación, si te creas un kernel
	personalizado, funcionará en 4Mb. Algunos fueron capaces de
	arrancar con 2Mb (aunque después el sistema era incapaz de
	hacer nada más :-)) </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>?Cómo puedo hacer mi propio disco de
	instalación?</para>
      </question>

      <answer>
	<para>Realmente, no hay una manera para
	<emphasis>sólo</emphasis> hacer un disco de instalación
	personalizado. Hay algún código en
	<filename>/usr/src/release/floppies/Makefile</filename> que
	supuestamente es para hacer <emphasis>sólo</emphasis> un disco
	de instalación personalizado, pero no está realmente
	testeado todavía.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>?Puedo tener más de un sistema operativo en mi
	PC?</para>
      </question>

      <answer>
	<para>Echa un vistazo en
	<link xlink:href="../tutorials/multios/multios.html">La página
	multi-OS.</link></para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Puede Windows 95 coexistir con FreeBSD?</para>
      </question>

      <answer>
	<para>Instala primero Windows 95 y después FreeBSD. El boot
	manager de FreeBSD se encargará de darte la opción de
	arrancar con cualquiera de los dos sistemas. Si lo haces al
	revés, Windows 95 borrará el boot manager sin hacer
	ninguna pregunta previa. Si ocurre esto, pasa a la siguiente
	sección.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>Windows 95 desinstaló mi boot manager!
	  ?Cómo lo recupero?
        </para>
      </question>

      <answer>
        <para>Puedes reinstalar el boot manager que viene con FreeBSD de dos
        maneras:</para>

        <para>
          <itemizedlist>
            <listitem>
	      <para>Ejecutando el DOS, entra en el directorio
	      <filename>tools/</filename> de tu distribución de FreeBSD
	      y busca el archivo <filename>bootinst.exe</filename>.
	      Ejecútalo de la siguiente manera:</para>

              <para><emphasis remap="bf">bootinst.exe boot.bin</emphasis></para>

              <para/>

              <para>Y el boot manager estará reinstalado.</para>

	      <para>Arranca con el disco de instalación de FreeBSD y
	      entra en la sección ``Custom Installation''. Selecciona
	      ``Partition''. Escoge el disco en el cual debe estar instalado
	      el boot manager, y cuando entres en el editor de particiones,
	      sin hacer ningún cambio, selecciona (W)rite. Serás
	      preguntado para confirmar la acción, responde
	      ``sí'', y cuando estés en la ventana de ``Boot
	      manager selection'' asegúrate de seleccionar ``Boot
	      Manager''. Esto reescribirá el boot manager en el disco.
	      Ahora, sal del programa de instalación y rearranca el
	      computador de la manera habitual.</para>
            </listitem>
          </itemizedlist>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>?Puedo instalar FreeBSD en un disco con sectores
	erróneos?</para>
      </question>

      <answer>
	<para>La gestión de sectores erróneos por parte de
	FreeBSD no está desarrollada todavía al 100% y
	desgraciadamente debemos decirte que si tienes discos IDE o ESDI con
	gran cantidad de sectores erróneos, FreeBSD no es para
	tí. De todas maneras, te aconsejamos que antes de descartar la
	instalación, hagas un intento.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>Ocurren cosas extrañas cuando arranco con el disco de
	instalación
        </para>
      </question>

      <answer>
	<para>Si observas cosas como que la maquina se ``cuelga'' o se
	reinicializa espontáneamente cuando intentas arrancar con el
	disco de instalación, aquí tienes tres preguntas que
	debes responder tu mismo:</para>

        <para>
          <orderedlist>
            <listitem>
	      <para>?Estás usando un disco nuevo, recién
	      formateado y libre de errores, o estás usando el disco de
	      publicidad que venía con la revista que lleva guardada
	      varios meses debajo de la cama?</para>
            </listitem>

            <listitem>
	      <para>?Descargaste por ftp la imagen del disco en modo
	      binario?...  (no te preocupes ya que hasta el mejor de nosotros,
	      por lo menos una vez, ha descargado un archivo en modo
	      ASCII).</para>
            </listitem>

            <listitem>
	      <para>Si estás usando uno de esos nuevos sistemas
	      operativos como Windows 95 o Windows NT, debes arrancar la
	      máquina en modo DOS puro, ya que parece ser que los
	      Windows no se llevan bien con los programas que escriben
	      directamente sobre los dispositivos hardware, como hace el
	      programa de creación de discos de instalación de
	      FreeBSD.</para>
            </listitem>
          </orderedlist>
        </para>

	<para>Han habido informaciones referentes a problemas al bajar el
	  disco de instalación con Netscape, por lo que te
	  recomendamos que uses un programa diferente como cliente de ftp.
	  </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>¡Ayuda! ¡No puedo instalar desde una cinta!</para>
      </question>

      <answer>
	<para>Si estás instalando la versión 2.1.7R desde una
	cinta, debes crear esa cinta con un tamaño de bloque de tar de
	10 (5120 bytes). El tamaño por defecto de los bloques tar es de
	20 (10240 bytes), y las cintas creadas con este tamaño por
	defecto no pueden ser usadas para instalar FreeBSD 2.1.7R; con estas
	cintas tendrás un error referente a un tamaño de
	registro demasiado grande.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>Conexión de dos máquinas FreeBSD vía puerto
	paralelo (PLIP)
        </para>
      </question>

      <answer>
	<para>Coge un cable de laplink y asegurate que ambos computadores
	  tienen un kernel que soporta el puerto paralelo.</para>

        <para>
          <literallayout>
$ dmesg | grep lp
lpt0 at 0x378-0x37f irq 7 on isa
lpt0: Interrupt-driven port
lp0: TCP/IP capable interface
          </literallayout>
        </para>

        <para>Conecta el cable en los dos puertos paralelos.</para>

	<para>Configura los parámetros de red para el interfaz lp0
	  (como root) en ambas máquinas. Por ejemplo, si quieres
	  conectar la máquina max y moritz:</para>

        <para>
          <literallayout>
max &lt;-----&gt; moritz
Direccion IP   10.0.0.1      10.0.0.2
          </literallayout>
        </para>

        <para>En el arranque de max
          <literallayout>
# ifconfig lp0 10.0.0.1 10.0.0.2
          </literallayout>
        </para>

        <para>En el arranque de moritz</para>

        <para>
          <literallayout>
# ifconfig lp0 10.0.0.2 10.0.0.1
          </literallayout>
        </para>

        <para>Esto es todo!!. Por favor, lee los man de lp(4) y lpt(4).</para>

	<para>También deberías añadir las máquinas
	en el archivo /etc/hosts:</para>

        <para>
          <literallayout>
127.0.0.1               localhost.my.domain localhost
10.0.0.1                max.my.domain max
10.0.0.2                moritz.my.domain moritz
          </literallayout>
        </para>

        <para>Para asegurarte que funciona haz:</para>

        <para>en max:</para>

        <para>
          <literallayout>
$ ifconfig lp0
lp0: flags=8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 --&gt; 10.0.0.2 netmask 0xff000000
          </literallayout>
        </para>

        <para>
          <literallayout>
$ netstat -r
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use     Netif Expire
moritz              max              UH          4   127592       lp0
          </literallayout>
        </para>

        <para>
          <literallayout>
$ ping -c 4 moritz
PING moritz (10.0.0.2): 56 data bytes
64 bytes from 10.0.0.2: icmp_seq=0 ttl=255 time=2.774 ms
64 bytes from 10.0.0.2: icmp_seq=1 ttl=255 time=2.530 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=255 time=2.556 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=255 time=2.714 ms

--- moritz ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 2.530/2.643/2.774/0.103 ms
          </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>?Puedo instalar FreeBSD en mi portátil sobre PLIP
	(Parallel Line IP)?</para>
      </question>

      <answer>
	<para>Conecta los dos computadores usando Laplink mediante el puerto
	paralelo y usa las siguientes características:</para>

        <para>
          <literallayout>
+----------------------------------------+
|A-name A-End   B-End   Descr.  Port/Bit |
+----------------------------------------+
|DATA0  2       15      Data    0/0x01   |
|-ERROR 15      2               1/0x08   |
+----------------------------------------+
|DATA1  3       13      Data    0/0x02   |
|+SLCT  13      3               1/0x10   |
+----------------------------------------+
|DATA2  4       12      Data    0/0x04   |
|+PE    12      4               1/0x20   |
+----------------------------------------+
|DATA3  5       10      Strobe  0/0x08   |
|-ACK   10      5               1/0x40   |
+----------------------------------------+
|DATA4  6       11      Data    0/0x10   |
|BUSY   11      6               1/0x80   |
+----------------------------------------+
|GND    18-25   18-25   GND -            |
+----------------------------------------+
          </literallayout>
        </para>

	<para>Mira también <link linkend="pao">esta nota</link> en la
	página de informática móvil.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question xml:id="geometry">
        <para>?Que geometría debo usar para mis discos?</para>
      </question>

      <answer>
	<para>(Por geometría de un disco, entendemos el número
	de cilindros, cabezales y sectores por pista en el disco - de ahora en
	adelante nos referiremos por conveniencia a estos parámetros
	como C/H/S.  Así es como trabaja el BIOS de los PC's para
	gestionar la lectura/escritura.</para>

	<para>Por alguna razón, esto parece crear mucha
	confusión.  Ante todo, la geometría
	<emphasis remap="tt">física</emphasis> de un disco SCSI es
	totalmente irrelevante ya que FreeBSD trabaja en términos de
	bloques de disco. Con discos IDE, FreeBSD trabaja en términos
	de C/H/S, pero todos los discos modernos convierten estos datos en
	referencias internas de bloques.</para>

	<para>Para discos SCSI, la geometría a usar depende de si
	tenemos activado en la controladora el soporte de translación
	(comunmente conocido como "soporte para discos mayores de 1GB" o
	algo similar). Si esta opción está desactivada, entonces
	usa N cilindros, 64 cabezales y 32 sectores por pista, donde N es la
	capacidad del disco en MB. Por ejemplo, para un disco de 2GB, los
	parámetros correctos serían 2048 cilindros, 64 cabezales
	y 32 sectores.</para>

	<para>Si el soporte de translación está activado y la
	capacidad del disco es mayor de 1GB, usa M cilindros, 63 cabezales
	(*no* 64), y 255 sectores, donde M es la capacidad del disco en MB
	dividida por 7.844238. Para nuestro ejemplo de un disco de 2GB, los
	parámetros serían 261 cilindros, 62 cabezales y 255
	sectores.</para>

	<para>Si no estás seguro sobre los parámetros a usar, o
	FreeBSD falla al detectar la geometría correcta del disco
	durante la instalación, el método más simple para
	solucionar este problema es crear una pequeña partición
	DOS en el disco.  Entonces, la geometría debería ser
	detectada correctamente (y siempre puedes borrar esa partición
	desde el ``editor de particiones'' si no quieres mantenerla).</para>

	<para>Alternativamente, existe una utilidad de libre
	distribución incluida en FreeBSD llamada
	<filename>pfdisk.exe</filename> (situada en el directorio
	<emphasis remap="tt">tools</emphasis> del CD-ROM de distribución
	o en cualquiera de los servidores ftp) que nos dice la
	geometría del disco usada por el sistema operativo DOS. Lo
	único que tenemos que hacer es introducir los datos obtenidos
	en el editor de particiones de FreeBSD.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>?Existe alguna restricción en cómo dividir
	el disco?</para>
      </question>

      <answer>
	<para>Sí. Debes asegurarte de que la partición raiz esta
	por debajo del cilindro 1024, para que el BIOS pueda arrancar el
	kernel desde ella.  (Ésta es una limitación del BIOS de
	los PCs, no de FreeBSD).</para>

	<para>Para discos SCSI, esto implica que la partición
	raíz debe estar instalada en los primeros 1024MB (o en los
	primeros 4096MB si la translación extendida esta activada).
	Para discos IDE, la partición raíz debe estar en los
	primeros 504MB.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Qué hay sobre los ``disk managers''?</para>
      </question>

      <answer>
        <para>FreeBSD reconoce el disk manager Ontrack. Otros disk managers no
        están soportados.</para>

	<para>Si quieres usar el disco solo con FreeBSD no necesitas el disk
	manager. Solo configura el disco para el espacio máximo que
	pueda manejar el BIOS (usualmente 504MB), y FreeBSD se
	encargará de averiguar cuánto espacio tienes realmente.
	Si estás usando un disco antiguo con controladora MFM,
	necesitarás decirle explícitamente a FreeBSD
	cuántos cilindros puede usar.</para>

	<para>Si quieres usar el disco con FreeBSD y otro sistema operativo,
	todavía puedes hacerlo sin necesitar un disk manager;
	sólo asegúrate de que la partición raíz de
	FreeBSD y la partición de arranque del otro sistema operativo
	están en los primeros 1024 cilindros. Si eres cuidadoso, una
	partición raiz de 20MB debería ser suficiente.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question xml:id="missing-os">
        <para>Cuando arranco FreeBSD obtengo ``Missing Operating System''
	</para>
      </question>

      <answer>
	<para>Esto es un clásico conflicto entre FreeBSD y DOS u otro
	sistema operativo sobre sus ideas de
	<link linkend="geometry">geometría.</link>.  Tendrás que
	reinstalar FreeBSD, pero teniendo en cuenta la información que
	te damos más arriba sobre este asunto.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>No puedo pasar del prompt `F?'.</para>
      </question>

      <answer>
	<para>Éste es otro problema descrito en el párrafo
	anterior. La geometría de tu BIOS y los datos de
	configuración de FreeBSD no coinciden. Si tu controladora o
	BIOS soporta la translación de cilindros (también
	conocido como "soporte para discos de más de 1GB"), intenta
	activar/desactivar esta opción y reinstala FreeBSD.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question xml:id="bigram">
        <para>Tengo &gt;16MB de RAM. ?Puede causar esto problemas?
	</para>
      </question>

      <answer>
	<para>Aparte del rendimiento, no. FreeBSD 2.X tiene buffers que
	permiten al ``bus mastering controller'' acceder a más de 16MB.
	(Esto sólo es aplicable si estás usando dispositivos
	ISA).</para>

        <para>También mira la sección
	<link linkend="reallybigram">máquinas con &gt;64M</link> si
	tienes esta cantidad de memoria o si usas máquinas Compaq u
	otro BIOS que no da correctamente la cantidad de memoria disponible.
	</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Necesito instalar todo el código fuente?</para>
      </question>

      <answer>
	<para>En general, no. De todas maneras, te recomendamos que instales,
	por lo menos, el kit de código fuente
	<emphasis remap="tt">base</emphasis>, el cual incluye muchos de los
	archivos aquí mencionados, y el kit
	<emphasis remap="tt">sys</emphasis>, que incluye el código fuente
	del kernel. No hay nada en el sistema que requiera el código
	fuente para funcionar, a excepción del programa de
	configuración de kernel
	<link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?config">config</link>.
	Con la excepción de las fuentes del kernel, nuestra estructura
	esta diseñada para que puedas montar una unidad en solo lectura
	via NFS en la que exista el código fuente, y aun así,
	ser capaz de compilar los nuevos binarios. (Debido a las restriciones
	de los fuentes del kernel, recomendamos que no montes estos en
	<filename>/usr/src</filename> directamente, sino en cualquier otra
	parte del disco con los links simbólicos apropiados para
	duplicar la estructura principal del árbol de directorios
	original),</para> <para>Teniendo los fuentes on-line y sabiendo como
	crear un sistema con ellas (compilar), te haremos mucho mas
	fácil la actualización a futuras versiones de
	FreeBSD.</para>

	<para>Para seleccionar auténticamente un subconjunto del
	código fuente, usa la opción Custom del menú
	desde el menú Distributions de la herramienta de
	instalación.  El script <filename>src/install.sh</filename>
	instalará sólo partes de la distribución del
	código fuente dependiendo de los parámetros (argumentos)
	que se le pasen.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Necesito crear un nuevo kernel?</para>
      </question>

      <answer>
	<para>La creación de un nuevo kernel era, originariamente, un
	paso requerido en la instalación de FreeBSD, pero en las
	versiones más recientes nos hemos beneficiado de la
	introducción de una herramienta de configuración de
	kernel mucho más amigable. Cuando en el prompt de arranque de
	FreeBSD (boot:), usamos el parámetro "-c", llegamos a una
	pantalla de configuración visual la cual permite configurar las
	opciones del kernel para la mayoría de tarjetas ISA.</para>

	<para>Todavía es recomendable la creación de un nuevo
	kernel conteniendo sólo los drivers que nos sean necesarios
	para ahorrar un poco de RAM, pero no es estrictamente necesario para
	la mayoría de sistemas.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>Vivo fuera de USA. ?Puedo usar la encriptación
	DES?</para>
      </question>

      <answer>
	<para>Si no es absolutamente necesario que uses la encriptación
	DES, puedes usar la encriptación por defecto de FreeBSD para
	una <emphasis remap="bf">mejor</emphasis> seguridad, y sin restricciones
	de importación. La encriptación por defecto de los
	passwords en FreeBSD está basada en
	<emphasis remap="bf">MD5</emphasis>, y es necesario un mayor uso
	intensivo de CPU con programas de descubrimiento de passwords que en
	DES. La única razón para no usar hoy en día la
	encriptación <emphasis remap="bf">MD5</emphasis> sería
	usar un sistema de passwords compartidos entre sistemas FreeBSD y no
	FreeBSD.</para>

	<para>Puesto que el algoritmo de encriptación DES no puede ser
	legalmente exportado fuera de USA, los usuarios externos a USA NO
	deberían descargar este software desde los servidores FTP
	situados en USA.</para>

	<para>Existe una alternativa para la biblioteca de
	encriptación, basada en el código escrito en Australia
	por David Burren. Este código está disponible en algunos
	mirrors de FreeBSD fuera de USA. El código fuente de la
	biblioteca de encriptación, y los binarios de los programas
	que la usan pueden encontrarse en los siguientes servidores FTP:
	</para>

        <para>
          <variablelist>
            <varlistentry>
              <term>
                South Africa
              </term>
              <listitem>
                <para><filename>ftp://ftp.internat.FreeBSD.org/pub/FreeBSD</filename>
                <filename>ftp://storm.sea.uct.ac.za/pub/FreeBSD</filename>
		</para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                Brazil
              </term>
              <listitem>
                <para><filename>ftp://ftp.iqm.unicamp.br/pub/FreeBSD</filename>
		</para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                Finland
              </term>
              <listitem>
                <para><filename>ftp://nic.funet.fi/pub/unix/FreeBSD/eurocrypt</filename></para>
              </listitem>
            </varlistentry>
          </variablelist>
        </para>

	<para>Los usuarios de fuera de USA no deben descargar ningún
	software de encriptación de servidores situados en USA, ya que
	de no seguir esta norma los responsables de esos servidores
	podrían verse envueltos en importantes problemas legales.
	</para>

	<para>Se está desarrollando una distribución no
	estadounidense de Kerberos, cuyas versiones actuales pueden obtenerse
	vía ftp anónimo en
	<filename>braae.ru.ac.za</filename>.</para>

	<para>Existe también una <link linkend="mailing">lista de
	distribución</link> para la discusión de software de
	encriptación externo a USA. Para más información
	envía un e-mail con una simple línea diciendo "<emphasis remap="tt">help</emphasis> en el cuerpo del mensaje a:</para>

        <para><email>majordomo@braae.ru.ac.za</email>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>El ``boot disc'' arranca pero se cuelga en la pantalla ``Probing
	Devices...''</para>
      </question>

      <answer>
	<para>Si tienes instalado un ZIP o un Jaz IDE, desconéctalo e
	inténtalo de nuevo. El disco de arranque puede haberse
	confundido con los discos.  Una vez el sistema esté instalado,
	puedes volver a conectar los dispositivos. Esperamos que esto sea
	arreglado en las próximas releases.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>Aparece el siguiente error ``panic: can't mount root'' al
	reiniciar el computador después de la instalación</para>
      </question>

      <answer>
	<para>Este error proviene de la confusión entre los bloques de
	arranque y lo que ve el kernel en los discos. El error se suele
	manifestar en sistemas con dos discos IDE, con los discos duros
	dispuestos como máster o ''single'' en controladoras
	diferentes, estando FreeBSD instalado en la controladora IDE
	secundaria. Los bloques de arranque piensan que el sistema
	está instalado en wd1 (el segundo disco en el BIOS) mientras
	el kernel asigna el primer disco de la controladora secundaria wd2.
	Después de la detección de dispositivos, el kernel
	intenta montar lo que los bloques de arranque piensan que es el disco
	de arranque, wd1, cuando realmente es el wd2, y falla.</para>

	<para>Para solucionar el problema, haz una de las siguientes
	cosas:</para>

        <para>
          <orderedlist>
            <listitem>
              <para>En el prompt de arranque (boot:), pon
	      <emphasis remap="tt">1:wd(2,a)kernel</emphasis> y presiona Enter.
	      Si el sistema arranca, ejecuta el comando:
              <literallayout>
echo "1:wd(2,a)kernel" &gt; /boot.config
              </literallayout>
              para actualizar la cadena de arranque por defecto.</para>
            </listitem>

            <listitem>
	      <para>Mueve el disco de FreeBSD a la controladora IDE primaria
	      para que los discos sean consecutivos.</para>
            </listitem>

            <listitem>
	      <para><link xlink:href="../../handbook/kernelconfig.html">Crea un
	      nuevo kernel,</link> modifica las líneas de
	      configuración de wd de la siguiente manera:
              <literallayout>
controller      wdc0    at isa? port "IO_WD1" bio irq 14 vector wdintr
disk            wd0     at wdc0 drive 0
# disk          wd1     at wdc0 drive 1 # comment out this line

controller      wdc1    at isa? port "IO_WD2" bio irq 15 vector wdintr
disk            wd1     at wdc1 drive 0 # change from wd2 to wd1
disk            wd2     at wdc1 drive 1 # change from wd3 to wd2
              </literallayout>
	      Instala el nuevo kernel: Si moviste los discos y quieres
	      recuperar la configuración previa, reemplaza los discos
	      en la configuración deseada y rearranca el sistema. Tu
	      sistema debería arrancar sin problemas.</para>
            </listitem>
          </orderedlist>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cuál es el límite de memoria?.</para>
      </question>

      <answer>
	<para>Para memoria, el límite (teórico) es de 4
	gigabytes. Un gigabyte ha sido comprobado y funciona sin problemas:
	generalmente no se pueden comprar equipos i386 que soporten más
	cantidad de memoria.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>?Cuál es el límite del sistema de archivos
	FFS?</para>
      </question>

      <answer>
	<para>Para sistemas de archivos FFS, el máximo teórico
	está en 8 terabytes (bloques de 2G), o 16TB para el
	tamaño de bloque por defecto de 8K. En la práctica hay
	un límite ``blando'' de 1 terabyte, pero con pequeáas
	modificaciones son posibles (y existen) sistemas de archivos de 4
	terabytes.</para>

	<para>El tamaño máximo de un único archivo FFS es
	aproximadamente de 1 Gbloque (4TB) si el tamaño del bloque es
	de 4K.</para>

        <para>
          <literallayout>
maxfilesize
----------------------------------
                2.2.7    3.0
fs block size   -stable  -current  works  should-work
-------------   -------  --------  -----  -----------
4K              4T-1       4T-1    4T-1   4+T
8K              32+G       8T-1    32+G   16T-1
16K             128+G      16T-1   128+G  32T-1
32K             512+G      32T-1   512+G  64T-1
64K             2048+G     64T-1   2048+G 128T-1
          </literallayout>
        </para>

	<para>Cuando el tamaño del bloque del sistema de archivos es de
	4K, los bloques triple-indirectos funcionan y el límite total
	debería venir determinado por el número máximo de
	bloques que puede ser representado usando los bloques
	triple-indirectos (aproximadamente 1K^3 + 1K^2 + 1K), pero el
	límite total lo establece un límite (incorrecto) de
	1G-1 en el número de bloques. El límite en el
	número de bloques debería ser de 2G-1, pero estos
	números de bloque son inalcanzables cuando los bloques del
	sistema de archivos son de 4K.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>?Cómo puedo poner archivos de 1TB en un
	disquete?</para>
      </question>

      <answer>
	<para>El tamaño máximo de un archivo no depende
	directamente del tamaño máximo del disco. El
	tamaño máximo del disco es de 1TB. Es una ventaja que el
	tamaño del archivo pueda ser mayor que el tamaño del
	disco.</para>

	<para>El siguiente ejemplo crea un archivo con un tamaño de 1TB
	usando 32K de espacio de disco (3 bloques indirectos y 1 bloque de
	datos) en una pequeña partición raíz.</para>

        <para>
          <literallayout>
ttyv0:bde@alphplex:/tmp/q&gt; cat foo
df .
dd if=/dev/zero of=z bs=1 seek=`echo 2^43 - 2 | bc` count=1
ls -l z
du z
df .
ttyv0:bde@alphplex:/tmp/q&gt; sh foo
Filesystem  1024-blocks     Used    Avail Capacity  Mounted on
/dev/sd0a         64479    27702    31619    47%    /
1+0 records in
1+0 records out
1 bytes transferred in 0.000187 secs (5346 bytes/sec)
-rw-r--r--  1 bde  bin  8796093022207 Sep  7 16:04 z
32      z
Filesystem  1024-blocks     Used    Avail Capacity  Mounted on
/dev/sd0a         64479    27734    31587    47%    /
ttyv0:bde@alphplex:/tmp/q&gt; exit
          </literallayout>
        </para>

        <para>Bruce Evans, septiembre de 1998</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>He compilado un nuevo kernel y al arrancar aparece el error
	"archsw.readin.failed".</para></question><answer>

	<para>Puedes arrancar especificando el kernel directamente en la
	segunda fase del boot, pulsando cualquier tecla cuando veas el
	símbolo | justo antes de que se arranque el cargador (loader).
	Más específicamente, has actualizado los fuentes para tu
	kernel, y lo has creado y actualizado a partir de ellos
	<emphasis>sín hacer un ``make world''</emphasis>. Así no
	funciona. Haz un ``make world''.</para>
      </answer>
    </qandaentry>
  </qandaset>
</chapter>

<chapter xml:id="hardware">
  <title>Compatibilidad hardware </title>
  <qandaset>
    <qandaentry>
      <question>
        <para>?Qué tipo de discos duros soporta FreeBSD?</para>
      </question>

      <answer>
        <para>FreeBSD soporta discos duros EIDE y SCSI (con controladoras
        compatibles; mira en la siguiente sección), y todos los discos
        que usen el interface original ``Western Digital'' (MFM, RLL, ESDI y
        por supuesto IDE). Algunas controladoras ESDI que usan interfaces
        propietarios quizá no funcionen correctamente.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>?Qué controladoras SCSI están
	soportadas?</para>
      </question>

      <answer>
        <para>FreeBSD soporta las siguientes controladoras SCSI:</para>
        <para>
          <variablelist>
            <varlistentry>
              <term>
                Adaptec
              </term>
              <listitem>
                <para>
                  AH-1505 &lt;ISA&gt;
                  AH-152x Series &lt;ISA&gt;
                  AH-154x Series &lt;ISA&gt;
                  AH-174x Series &lt;EISA&gt;
                  Sound Blaster SCSI (AH-152x compat) &lt;ISA&gt;
                  AH-2742/2842 Series &lt;ISA/EISA&gt;
                  AH-2820/2822/2825 Series (Narrow/Twin/Wide) &lt;VLB&gt;
                  AH-294x and aic7870 MB controllers (Narrow/Twin/Wide) &lt;PCI&gt;
                  AH-394x (Narrow/Twin/Wide)
                </para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry><term>Buslogic</term>
              <listitem>
                <para>
                  BT-445 Series &lt;VLB&gt;
                  BT-545 Series &lt;ISA&gt;
                  BT-742 Series &lt;EISA&gt;
                  BT-747 Series &lt;EISA&gt;
                  BT-946 Series &lt;PCI&gt;
                  BT-956 Series &lt;PCI&gt;
                </para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                Future Domain
              </term>
              <listitem>
                <para>
                  TMC-950 Series &lt;ISA&gt;
                </para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                PCI Generic
              </term>
              <listitem>
                <para>
                  NCR 53C81x based controllers &lt;PCI&gt;
                  NCR 53C82x based controllers &lt;PCI&gt;
                  NCR 53C860/75 based controllers &lt;PCI&gt;
                </para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                ProAudioSpectrum
              </term>
              <listitem>
                <para>
                  Zilog 5380 based controllers &lt;ISA&gt;
                  Trantor 130 based controllers &lt;ISA&gt;
                </para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                DTC
              </term>
              <listitem>
                <para>
                  DTC 3290 EISA SCSI in AHA-154x emulation.
                </para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                Seagate
              </term>
              <listitem>
                <para>
                  ST-01/02 Series &lt;ISA&gt;
                </para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                UltraStor
              </term>
              <listitem>
                <para>
                  UH-14f Series &lt;ISA&gt;
                  UH-24f Series &lt;EISA&gt;
                  UH-34f Series &lt;VLB&gt;
                </para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                Western Digital
              </term>
              <listitem>
                <para>
                  WD7000 &lt;ISA&gt; &lt;No scatter/gather&gt;
                </para>
              </listitem>
            </varlistentry>
          </variablelist>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Qué lectores CD-ROM soporta FreeBSD?</para>
      </question>

      <answer>
	<para>Está soportado cualquier disco SCSI conectado a una
	controladora soportada</para>

	<para>Los siguientes interfaces de CD-ROM propietarios también
	están soportados:</para>

        <para>
          <itemizedlist>
            <listitem>
	      <para>Mitsumi LU002 (8bit), LU005 (16bit) and FX001D (16bit 2x
	      Speed).</para>
            </listitem>

            <listitem>
              <para>Sony CDU 31/33A<!-- <br> --></para>
            </listitem>

            <listitem>
              <para>Sound Blaster Non-SCSI CD-ROM<!-- <br> --></para>
            </listitem>

            <listitem>
              <para>Matsushita/Panasonic CD-ROM<!-- <br> --></para>
            </listitem>

            <listitem>
              <para>ATAPI compatible IDE CD-ROMs<!-- <br> --></para>
            </listitem>
          </itemizedlist>
        </para>

	<para>Todas las tarjetas no SCSI son conocidas por ser extremadamente
	lentas comparadas con los discos SCSI, y algunos CDROM ATAPI
	quizá no funcionen correctamente.</para>

	<para>A partir de la versión 2.2 de FreeBSD en CDROM de Walnut
	Creek se soporta el arranque directo (boot) desde el propio CD.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Soporta FreeBSD discos ZIP?</para>
      </question>

      <answer>
	<para>FreeBSD soporta los ZIP SCSI externos. Las unidades ZIP
	sólo pueden funcionar en los ID's SCSI 5 y 6, pero si el BIOS
	de tu controladora lo soporta, puedes arrancar desde él. No
	sabemos qué controladoras dejan arrancar desde ID's diferentes
	de la 0 o 1...  mira en tu documentación y házmelo
	saber si te funciona.</para>

	<para>Los discos Zip ATAPI (IDE) están soportados en FreeBSD
	2.2.6 y releases posteriores.</para>

	<para>FreeBSD ha incluido el soporte de discos ZIP por puerto paralelo
	desde la versión 3.0. Si estás usando una versión
	actualizada, debes asegurarte de que tu configuración del
	kernel incluye los drivers <emphasis remap="tt">scbus0</emphasis>,
	<emphasis remap="tt">da0</emphasis>,
	<emphasis remap="tt">ppbus0</emphasis> y
	<emphasis remap="tt">vp0</emphasis> (el kernel GENERIC los contiene
	todos excepto vp0).  Con todos estos drivers presentes, el disco por
	puerto paralelo debería estar disponible como /dev/da0s4. Los
	discos se pueden montar usando
	<command>mount /dev/da0s4 /mnt</command> o (para discos dos)
	<emphasis remap="tt">mount_msdos /dev/da0s4 /mnt</emphasis>.</para>

	<para>También mira en <link linkend="jaz">discos
	removibles</link>, y <link linkend="disklabel">esta nota en
	'formatting'</link>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Soporta FreeBSD JAZ, EZ y otros discos removibles?
	</para>
      </question>

      <answer>
	<para>Aparte de la versión IDE de EZ, todos estos son
	dispositivos SCSI, por lo que deberían funcionar sin problemas
	ya que FreeBSD los toma como discos SCSI y el IDE EZ también
	debería funcionar sin problemas ya que se toma como un disco
	IDE estándar.</para>

	<para><anchor xml:id="jaz"/>No estoy seguro de cómo soporta FreeBSD
	el cambio de soporte mientras está funcionando. Deberás,
	desde luego, desmontar la unidad antes de poder cambiar el soporte, y
	estar seguro de que todas las unidades externas están
	encendidas antes de arrancar el computador con FreeBSD para que
	éste pueda reconocerlas.</para>

	<para>Mira <link linkend="disklabel">esta nota en
	'formatting'</link>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>?Qué tarjetas serie multipuerto están
	soportadas por FreeBSD?</para>
      </question>

      <answer>
        <para>Hay una lista de ellas en la sección
        <link xlink:href="../../handbook/install.html#INSTALL-HW">dispositivos varios</link>
        del manual (handbook).</para>

        <para>Algunas tarjetas ``sin nombre'' también han funcionado,
        especialmente las que dicen ser compatibles AST.</para>

        <para>Mira la página
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?sio">sio</link>
	para obtener más información sobre la
	configuración de estas tarjetas.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question xml:id="busmouse">
        <para>Tengo un tipo de ratón no habitual. ?Cómo
	lo configuro?</para>
      </question>

      <answer>
	<para>FreeBSD soporta el ``bus mouse'' y el ``InPort bus mouse'' de
	fabricantes como Microsoft, Logitech y ATI. El driver de mouse
	estiá compilado en el kernel GENERIC (kernel por defecto que
	carga el sistema). Si estás haciéndote un kernel a
	medida que incluya el driver de ratón, asegúrate de
	añadir la siguiente línea en el archivo de
	configuración del kernel:</para>

        <para>
          <literallayout>
device mse0 at isa? port 0x23c tty irq5 vector mseintr
          </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question xml:id="ps2mouse">
	<para>?Cómo uso mi ratón PS/2 (``mouse port'' o
	``teclado'')?</para>
      </question>

      <answer>
	<para>Si estás usando una versión reciente de FreeBSD,
	el driver necesario, psm, está incluido y activado en el
	kernel. El propio kernel debería detectar tu ratón PS/2
	en el momento de arrancar.</para>

	<para>Si estás usando una versión antigua, sólo
	tienes que activarlo en la configuración del kernel en el
	momento de la instalación del sistema. Si éste ya
	está instalado, escribe -c en el prompt boot: y
	actívalo.  Por defecto, este driver está desactivado.
	</para>

	<para>Si estás usando alguna de las versiones más
	antiguas, tendras que añadir la siguiente línea en el
	archivo de configuración del kernel y compilar uno nuevo:
	</para>

        <para>
          <literallayout>
device psm0 at isa? port "IO_KBD" conflicts tty irq 12 vector psmintr
          </literallayout>
        </para>

        <para>Mira la sección
        <link xlink:href="../../handbook/kernelconfig.html">configuración del kernel</link>
        si no tienes experiencia en la creación de nuevos kernel.
	</para>

	<para>Una vez que el kernel detecta correctamente el dispositivo psm0
	al arrancar, asegúrate de que existe una entrada en /dev para
	este dispositivo. Puedes hacerlo tecleando:</para>

        <para>
          <literallayout>
cd /dev; sh MAKEDEV psm0
          </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question xml:id="moused">
	<para>?Es posible hacer uso del ratón fuera de X
	Windows?</para>
      </question>

      <answer>
	<para>Si estás usando el driver por defecto de la consola,
	syscons, puedes usar el ratón en las consolas de texto para
	realizar ``cut &amp; paste''. Ejecuta el demonio (daemon) de
	ratón moused y arranca el ratón en la consola
	virtual:</para>

        <para>
          <literallayout>
moused -p /dev/xxxx -t yyyy
vidcontrol -m on
          </literallayout>
        </para>

	<para>donde <emphasis remap="tt">xxxx</emphasis> es el nombre del
	dispositivo del ratón e <emphasis remap="tt">yyyy</emphasis> es
	un tipo de protocolo para el ratón. Mira en
	<link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?moused">moused</link>
	para saber los tipos de protocolo soportados.</para>

	<para>Si quieres ejecutar el demonio moused automáticamente al
	arrancar el sistema, activa las siguientes variables en
	<filename>/etc/sysconfig</filename> (para versión 2.2.1).
	</para>

        <para>
          <literallayout>
mousedtype="yyyy"
mousedport="xxxx"
mousedflags=""
          </literallayout>
        </para>

	<para>En versiones 2.2.2 o superiores, activa las siguientes variables
	en <filename>/etc/rc.conf</filename>.</para>

        <para>
          <literallayout>
moused_type="yyyy"
moused_port="xxxx"
moused_flags=""
          </literallayout>
        </para>

	<para>A partir de la versión 2.2.6, el demonio del ratón
	es capaz de determinar automáticamente el protocolo correcto a
	utilizar. Sólo tienes que especificar
	<emphasis remap="tt">auto</emphasis> como el protocolo a usar.</para>

	<para>Cuando el demonio de ratón está funcionando, el
	acceso al ratón necesita coordinarse con otros programas como
	X Window. Mira en <link linkend="x-and-moused">esta
	sección</link> para más información.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>?Cómo hago un cut &amp; paste con el ratón
	en una consola de texto?</para>
      </question>

      <answer>
	<para>Una vez que tengas el demonio del ratón funcionando (mira
	<link linkend="moused">la sección anterior</link>, pulsa el
	botón 1 (izquierdo) y mueve el ratón para seleccionar la
	región de texto. A continuación, pulsa el botón 2
	(medio) o 3 (derecho) para hacer un paste (pegar) de la región
	seleccionada en el lugar en el que tengamos situado el cursor.</para>

	<para>En versiones 2.2.6 o superiores, pulsando el botón 2 hara
	un paste del texto seleccionado. Pulsando el botón 3
	extenderemos la región seleccionada de texto. Si tu
	ratón no tiene el botón medio, puedes emularlo o
	``remapear'' (reconfigurar) los botones de tu ratón con las
	opciones del demonio moused. Mira en
	<link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?moused">moused</link>
	para más información.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>Mi ratón tiene una rueda de desplazamiento y botones.
	?Puedo usarlo?</para>
      </question>

      <answer>
	<para>La respuesta es, desafortunadamente, ``depende''. Estos ratones
	con características adicionales requieren en muchos casos
	drivers propios y especializados. A no ser que el driver de
	dispositivo o el programa de usuario tenga soporte específico,
	el ratón se comportará como un ratón normal y
	corriente.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>?Cómo uso el mouse/trackball/touchpad en mi
	portátil?</para>
      </question>

      <answer>
	<para>Por favor, <link linkend="ps2mouse">mira en la respuesta
	anterior</link>.  Mira también <link linkend="pao">esta
	nota</link> en la sección de computadores
	portátiles.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>?Qué tipo de dispositivos de cinta están
	soportados?</para>
      </question>

      <answer>
	<para>FreeBSD soporta unidades SCSI, QIC-36 (con interfaz QIC-02) y
	QIC-40/80 (interfaz floppy).  Esto inclye dispositivos de 8mm
	(conocidos como Exabyte) y dispositivos DAT. Los QIC-40/80 son
	conocidos por su lentitud.</para>

	<para>Algunos de los dispositivos de 8mm primitivos no son totalmente
	compatibles con SCSI2 por lo que puede que no funcionen correctamente
	en FreeBSD.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Soporta FreeBSD ``tape changers''?</para>
      </question>

      <answer>
        <para>FreeBSD 2.2 soporta SCSI changers usando el dispositivo
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ch(4)">ch</link>
	y el comando
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?chio">chio</link>.
	Los detalles acerca de cómo controlar realmente el changer se
	encuentran en
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?chio">chio</link>.
	</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>?Qué tarjetas de sonido están soportadas
	  por FreeBSD?</para>
      </question>

      <answer>
	<para>FreeBSD soporta las tarjetas SoundBlaster, SoundBlaster Pro,
	SoundBlaster 16, Pro Audio Spectrum 16, AdLib y Gravis Ultrasound.
	Hay también soporte limitado para la tarjeta MPU-401 y
	compatibles midi. Las tarjetas SoundBlaster 16 ASP todavía no
	son soportadas.  El Microsoft Sound System sí está
	soportado.</para>

	<para><acronym>NOTA</acronym>: ¡Esto es solo para sonido! Este
	driver no soporta CD-ROMs, SCSI o joysticks en estas tarjetas, a
	excepción de la SoundBlaster. El interface SCSI de SoundBlaster
	y algunos CD-ROMs no SCSI están soportados, pero no
	podrás arrancar el sistema desde ellos.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>No obtengo sonido de la tarjeta es1370 con driver pcm</para>
      </question>

      <answer>
        <para>Puedes ejecutar el siguiente mandato cada vez que arranques el
        sistema:</para>

        <para><literallayout>
mixer pcm 100 vol 100 cd 100
	</literallayout></para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Qué tarjetas de red soporta FreeBSD?</para>
      </question>

      <answer>
        <para>Mira la sección de
        <link xlink:href="../../handbook/install:nics.html">tarjetas Ethernet</link>
        en el manual para una lista más completa.</para>

        <para>
          <variablelist>
            <varlistentry>
              <term>
                <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?de(4)">de</link> driver
              </term>
              <listitem>
                <para>DEC DC21x40 and compatible PCI controllers (including
		  21140 100bT cards)
                </para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ed(4)">ed</link> driver
              </term>
              <listitem>
                <para>NE2000 and 1000
                WD/SMC 8003, 8013 and Elite Ultra (8216)
                3Com 3c503
                HP 27247B and 27252A
                And clones of the above</para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?le(4)">le</link> driver
              </term>
              <listitem>
                <para>DEC EtherWORKS II and EtherWORKS III controllers</para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ie(4)">ie</link> driver
              </term>
              <listitem>
                <para>AT&amp;T EN100/StarLAN 10
                3COM 3c507 Etherlink 16/TP
                NI5210
                Intel EtherExpress</para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?is(4)">is</link> driver
              </term>
              <listitem>
                <para>Isolan AT 4141-0
                Isolink 4110</para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?el(4)">el</link> driver
              </term>
              <listitem>
                <para>3com 3c501 (does not support Multicast or DMA)</para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?eg(4)">eg</link> driver
              </term>
              <listitem>
                <para>3com 3c505 Etherlink/+</para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ze(4)">ze</link> driver
              </term>
              <listitem>
                <para>IBM PCMCIA credit card adapter</para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?lnc(4)">lnc</link> drive
              </term>
              <listitem>
                <para>Lance/PCnet cards (Isolan, Novell NE2100, NE32-VL)(*)</para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ep(4)">ep</link> driver
              </term>
              <listitem>
                <para>3com 3c509 (Must disable PNP support on card)</para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?cx(4)">cx</link> driver
              </term>
              <listitem>
                <para>Cronyx/Sigma multiport Sync/Async (Cisco and PPP framing)</para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?zp(4)">zp</link> driver
              </term>
              <listitem>
                <para>3Com PCMCIA Etherlink III (aka 3c589)(A-C only)</para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?fea(4)">fea</link> driver
              </term>
              <listitem>
                <para>DEC DEFEA EISA FDDI controller</para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?fpa(4)">fpa</link> driver
              </term>
              <listitem>
                <para>DEC DEFPA PCI FDDI controller</para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?fe(4)">fe</link> driver
              </term>
              <listitem>
                <para>Fujitsu MB86960A/MB86965A Ethernet cards</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </para>

        <para><acronym>NOTA</acronym> Los drivers marcados con (*) pueden
	tener problemas.</para>

	<para><acronym>NOTA</acronym>: 3C598D NO está soportada
	todavía.</para>

	<para><acronym>NOTA</acronym>: FreeBSD también soporta TCP/IP
	sobre líneas paralelo.  En estos momentos, no somos compatibles
	con otras versiones, pero esperamos corregirlo en un futuro cercano.
	Encontrarás más información sobre este tema en la
	página man de lp(4).</para>

        <para><acronym>NOTA</acronym>: Algunas de estas tarjetas requieren una
        partición DOS en el disco duro para ejecutar el programa de
        configuración.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>No tengo coprocesador matemático - ?es malo?
	</para>
      </question>

      <answer>
	<para><acronym>NOTA</acronym>: Esto sólo afectará a los
	computadores 386/486SX/486SLC.  El resto de los microprocesadores
	tienen un coprocesador integrado.</para>

	<para>En general, esto no causará problemas, pero hay
	circunstancias en las que pudieras echarlo de menos, especialmente
	si trabajas en entorno X Window. Si puedes, te recomendamos que
	compres uno y lo instales en tu computador.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Qué otros dispositivos soporta FreeBSD 2.X?
	  </para>
      </question>

      <answer>
	<para>Aquí hay una lista de drivers que no se han podido
	catalogar en las categorías anteriores.</para>

        <para>
        <variablelist>
          <varlistentry>
            <term>
              <filename>b004.c</filename>
            </term>
            <listitem>
              <para>Driver for B004 compatible Transputer boards</para>
              <para/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              ``ctx'' driver
            </term>
            <listitem>
              <para>Driver for CORTEX-I Frame grabber</para>
              <para/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              ``gp'' driver
            </term>
            <listitem>
              <para>Driver for National Instruments AT-GPIB and
              AT-GPIB/TNT boards</para>
              <para/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              ``pca'' driver
            </term>
            <listitem>
              <para>Driver for PC speakers to allow the playing of audio
	        files</para>
              <para/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              ``spigot'' driver
            </term>
            <listitem>
              <para>Driver for the Creative Labs Video Spigot</para>
              <para/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?gsc(4)">gsc</link> driver
            </term>
            <listitem>
              <para>Driver for the Genuis GS-4500 Hand scanner</para>
              <para/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?joy(4)">joy</link> driver
            </term>
            <listitem>
              <para>Driver for a joystick</para>
              <para/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?labpc(4)">labpc</link> driver
            </term>
            <listitem>
              <para>Driver for National Instrument's Lab-PC and Lab-PC+</para>
              <para/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              ``uart'' driver
            </term>
            <listitem>
              <para>Stand-alone 6850 UART for MIDI</para>
              <para/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?psm(4)">psm</link> driver
            </term>
            <listitem>
              <para>PS/2 mouse port</para>
              <para/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <filename>tw.c</filename>
            </term>
            <listitem>
              <para>Driver for the X-10 POWERHOUSE</para>
            </listitem>
          </varlistentry>
        </variablelist>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>?Soporta FreeBSD la administración de
	energía en mi portátil?</para>
      </question>

      <answer>
	<para>FreeBSD soporta APM en algunas máquinas. Por favor, mira
	en el archivo de configuración del kernel
	<acronym>LINT</acronym> y busca la parabra <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?apm">APM</link></para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Los sistemas Micron se bloquean al arrancar</para>
      </question>

      <answer>
	<para>Algunas placas base Micron tienen una implementación de
	PCI en el BIOS que no es estándar, lo que provoca que FreeBSD
	no pueda encontrar los dispositivos PCI en las direcciones en las que
	deberían estar.</para>

	<para>Desactiva la opción ``Plug and Play Operating System'' en
	el BIOS para solucionar el problema. Puedes encontrar más
	información en:
	<link xlink:href="http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron">http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron</link></para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>Tengo una de las controladoras Adaptec más modernas y
	FreeBSD no puede encontrarla</para>
      </question>

      <answer>
	<para>Las nuevas controladoras Adaptec con chipset de la serie AIC789x
	están soportados bajo la nueva CAM SCSI que hace su debut en la
	version 3.0 de FreeBSD. Los parches para las versiones 3.0-CURRENT y
	2.2-STABLE están en:
	<link xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/development/cam/">ftp://ftp.FreeBSD.org/pub/FreeBSD/development/cam/</link>.
	Un disco de arranque con soporte CAM está disponible en:
	<link xlink:href="http://www.FreeBSD.org/~abial/cam-boot/">http://www.FreeBSD.org/~abial/cam-boot/</link>.
	En ambos casos lee el archivo README antes de empezar.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>Tengo un módem interno Plug &amp; Play y FreeBSD no lo
	encuentra</para>
      </question>

      <answer>
	<para>Necesitarás añadir el ID del modem PnP a la lista
	de ID PnP en el driver serie. Para activar el soporte PnP, compila un
	nuevo kernel con <emphasis remap="tt">controller pnp0</emphasis> en el
	archivo de configuración y rearranca el sistema. El kernel
	mostrará en pantalla los IDs de todos los dispositivos PnP que
	encuentre. Copia el ID del módem en la tabla del archivo
	<filename>/sys/i386/isa/sio.c</filename>, sobre la línea 2777.
	Busca la cadena "SUP1310" en la estructura "siopnp_ids[]" para
	encontrar la tabla. Genera un nuevo kernel, instálalo y
	rearranca. Tu módem debería ser encontrado.</para>

	<para>Quizá tengas que configurar manualmente los dispositivos
	PnP usando el comando ``pnp'' en la configuración de arranque
	usandolo de la siguiente manera:
        <literallayout>
pnp 1 0 enable os irq0 3 drq0 0 port0 0x2f8
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>?Cómo obtengo el prompt ``boot:'' en una consola
	serie?</para>
      </question>

      <answer>
        <para>
          <orderedlist>
            <listitem>
	      <para>Crea un nuevo kernel con <emphasis remap="tt">options
	      COMCONSOLE</emphasis>.</para>
            </listitem>

            <listitem>
              <para>Crea el archivo /boot.config y pon <option>-P</option>
	        como único texto en el archivo.</para>
            </listitem>

            <listitem>
              <para>Desconecta el teclado del computador.</para>
            </listitem>
          </orderedlist>
        </para>

	<para>Mira el archivo
	<filename>/usr/src/sys/i386/boot/biosboot/README.serial</filename>
	  para más información.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>?Por qué no funciona mi tarjeta de red PCI 3Com
	  con mi computador Micron?</para>
      </question>

      <answer>
	<para>Algunas placas base Micron tienen una implementación de
	  PCI en el BIOS que no es estándar, lo que provoca que FreeBSD
	  no pueda encontrar los dispositivos PCI en las direcciones en las
	  que debieran estar.</para>

        <para>Para solucionar el problema, desactiva la opción
        ``Plug and Play Operating System'' en el BIOS.</para>

	<para>Puedes encontrar más información sobre este
	problema en
        <link xlink:href="http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron">http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron</link>
	</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
	<para>?Soporta FreeBSD el multiprocesamiento simétrico
	(SMP)?</para>
      </question>

      <answer>
	<para>SMP sólo está soportado a partir de la
	versión 3.0-STABLE</para>
      </answer>
    </qandaentry>
  </qandaset>
</chapter>

<chapter xml:id="troubleshoot">

<title>Problemas</title>

  <qandaset>
    <qandaentry>
      <question xml:id="awre">
        <para>Tengo bloques erróneos en mi disco duro!</para>
      </question>

      <answer>
        <para>Los discos SCSI deberían ser capaces de marcar estos
	  bloques erróneos automaticamente para que no presenten
	  problemas. Algunos discos, por alguna razón desconocida, se
	  venden con esta característica desactivada.</para>

        <para>Para activar esta opción, tendrás que editar una
	de las opciones del dispositivo, lo que puede ser hecho con FreeBSD
	tecleando el siguiente comando (como root):</para>

        <para>
          <literallayout>
scsi -f /dev/rsd0c -m 1 -e -P 3
          </literallayout>
        </para>

        <para>y cambiando los valores de AWRE y ARRE de 0 a 1:-</para>

        <para>
          <literallayout>
AWRE (Auto Write Reallocation Enbld):  1
ARRE (Auto Read Reallocation Enbld):  1
          </literallayout>
        </para>

        <para>Para otros tipos de discos, dependes de las
	características de los sistemas operativos.
	Desafortunadamente, el comando "bad144" que se incluye en FreeBSD,
	necesita ser desarrollado más en profundidad. </para>

        <para>Se <emphasis>supone</emphasis> que los discos IDE incluyen de
	serie la posibilidad de "remapear" los bloques dañados; si
	tienes documentación de tu disco, podrás ver si esta
	opción está activada o desactivada.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>FreeBSD no reconoce mi Bustek 742a EISA SCSI!</para>
      </question>

      <answer>
        <para>Esta información es específica para la tarjeta
	742a, pero puede ser aplicable a otras tarjetas Buslogic. (Bustek =
	Buslogic)</para>

        <para>Existen dos versiones de la tarjeta 742a. Son revisiones de
        hardware A-G y H. La letra de revisión está situada
        después del número de ensamblaje. La 742a tiene 2 ROMs,
        una es el BIOS y la otra es el Firmware. FreeBSD no se fija en la
        versión de BIOS de la tarjeta, pero si en la de Firmware.
        Buslogic te enviará una actualización de de las ROMs si
	te pones en contacto con su departamento técnico. La BIOS y el
        Firmware son distribuidas de manera inseparable. Deberías tener
        la versión de Firmware más actualizada para la
        revisión de hardware de tu tarjeta.</para>

        <para>Las tarjetas con revisión A-G solo pueden aceptar
	BIOS/Firmware 2.41/2.21. La revisión H y superiores pueden
	aceptar las versiones más actuales 4.70/3.37. La diferencia
	entre las versiones de Firmware es que la 3.38 soporta "round robin".
	</para>

        <para>Las tarjetas Buslogic tienen un número de serie
	serigrafiado en ellas. Si tienes una revisión de hardware
	antigua, puedes llamar al departamento de RMA de Buslogic y darles el
	número de serie de la tarjeta para intentar cambiarla por una
	revisión superior del hardware.</para>

        <para>FreeBSD 2.1 solo soporta revisiones de Firmware 2.21 o
	superiores.  Si tienes una versión inferior, tu tarjeta no
	será reconocida como Buslogic. Quizás sea reconocida
	como una Adaptec 1540. Las primeras versiones de Firmware de Buslogic
	contienen una modo de emulación de la AHA1540.</para>

        <para>Si tienes una revisión de hardware antigua y consigues
	una más actual (2.21), necesitarás chequear la
	posición del jumper W1 y asegurarte que está en la
	posición B-C (por defecto esta en B-C).</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Mi controladora SCSI HP Netserver's no es detectada!</para>
      </question>

      <answer>
        <para>Este es un problema ya conocido. Las controladoras SCSI EISA
        integradas en la placa base en las máquinas HP Netserver,
	ocupan el slot numero 11. El espacio de direcciones  para los slots
        EISA &gt;=10 colisionan con los espacios de direcciones asignados
        para los dispositivos PCI, y la autoconfiguración de FreeBSD no
        maneja esta situación demasiado bien.</para>

        <para>Lo mejor que puedes hacer es pretender que no existan clases
        de rangos de direcciones :), cambiando el valor de la opción
	del kernel <symbol>EISA_SLOTS</symbol> a un valor de 12.
        Configura y compila un nuevo kernel como se describe en la
        <link xlink:href="../../handbook/kernelconfig.html">entrada correspondiente del manual</link>.
        </para>

        <para>Por supuesto, esto presenta un pequeño problema. Para
	poder solucionarlo, es necesario un truco en la utilidad de
        configuración. No uses el interface "visual", simplemente
	teclea lo siguiente en la línea de comando de la utilidad
	</para>

        <para>
          <literallayout>
eisa 12
quit
          </literallayout>
        </para>

        <para>Esperamos que en las próximas versiones tengamos
	solucionados estos temas.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Qué ocurre con la controladora IDE CMD640?</para>
      </question>

      <answer>
        <para>No funciona. No puede manejar comandos en los dos canales
        simultáneamente.</para>

        <para>Hay una solución posible y se activa
	automáticamente si tu sistema usa este chip. Para más
	detalles, referirse al man del driver de discos (man 4 wd).</para>

        <para>Si todavía estás usando FreeBSD 2.2.1 o 2.2.2 con
	una controladora IDE CMD640 y quieres usar el segundo canal, crea un
	nuevo kernel con <emphasis remap="tt">options "CMD640"</emphasis>
	activada. Esta es la opción por defecto en la versión
	2.2.5 y superiores.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Tengo mensajes como
	``<emphasis remap="tt">ed1: timeout</emphasis>''.</para>
      </question>

      <answer>
        <para>Esto, normalmente es causado por conflictos de interrupciones
	(por ejemplo, dos tarjetas usando la misma IRQ). Las versiones
        anteriores a la 2.0.5R eran tolerantes con los problemas de
        conflictos de IRQ. A partir de esa versión, los conflictos de
	IRQ ya no son tolerados. Arranca con la opción -c y cambia la
	entrada correspondiente a tu tarjeta.</para>

        <para>Si estás usando conectores BCN en tu tarjeta de red, el
	mensaje de error puede ser debido a una mala terminación de la
	red. Para chequear esto, conecta un terminador directamente a la
	salida BNC de la tarjeta (sin cable) y mira si el mensaje desaparece.
	</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Cuando monto el CDROM, obtengo ``Incorrect super block''.</para>
      </question>

      <answer>
        <para>Tienes que indicar el tipo de dispositivo que quieres montar.
	Por defecto
	<link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?mount">mount</link>
        asumirá que el dispositivo que quieres montar es
        ``<emphasis remap="tt">ufs</emphasis>''. Si quieres montar un CDROM,
	tienes que especificar <option>-t cd9660</option>. Esto hace que el
	sistema asuma que tiene que montar un sistema de archivos con formato
	ISO 9660 que es lo que los CDROM deben tener.</para>

        <para>Como ejemplo, si quieres montar una unidad CDROM,
        <filename>/dev/cd0c</filename>, bajo <filename>/mnt</filename>,
	tienes que ejecutar</para>

        <para>
          <literallayout>
mount -t cd9660 /dev/cd0c /mnt
          </literallayout>
        </para>

        <para>Ten en cuenta que el nombre de tu dispositivo
        (<filename>/dev/cd0c</filename> en este ejemplo) puede ser diferente
        dependiendo del interface que estés usando. El comando anterior
        puede ser acortado tecleando:</para>

        <para>
          <literallayout>
mount_cd9660 /dev/cd0c /mnt
          </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Cuando monto un CDROM, obtengo ``Device not configured''.</para>
      </question>

      <answer>
        <para>Esto, generalmente, significa que no hay ningún disco en
	el lector de CDROM. También puede significar que el lector no
	es visible para el bus. Chequea que está bién
	configurado en lo referente a master/slave si es IDE (ATAPI).</para>

        <para>Algunas veces un CDROM SCSI puede "desaparecer" por que no ha
	tenido tiempo suficiente para responder a un reset del bus. Si tienes
	un CDROM SCSI, añade la siguiente línea en el archivo
	de configuración del kernel y recompílalo.</para>

        <para>
          <literallayout>
options "SCSI_DELAY=15"
          </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Mi impresora es ridiculamente lenta. ?Qué puedo
	hacer?</para>
      </question>

      <answer>
        <para>Si es paralelo, y el único problema es la lentitud,
	intenta configurar el puero de impresora en modo "polled":</para>

        <para>
          <literallayout>
lptcontrol -p
          </literallayout>
        </para>

        <para>Algunas impresoras nuevas de HP son conocidas por no trabajar
        correctamente en modo de interrupción, aparentemente debido (y
        todavía no exactamente entendido), a un problema de "timing".
	</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Mis programas ocasionalmente mueren con errores ``Signal 11''.</para>
      </question>

      <answer>
        <para>Esto puede ser por hardware erróneo (memoria, placa base, etc).
        Intenta ejecutar algún programa de test de memoria. Ten en cuenta
        que es posible que tu memoria pase el test del programa que uses,
        pero que falle en algunas condiciones de uso, como en compilación
        de kernel.</para>

        <para>La FAQ SIG11 (listada más abajo) apunta a problemas de
        lentitud de memoria. Incrementa el número de "wait states" en tu
        BIOS o instala una memoria más rápida.</para>

        <para>También puedes intentar desactivar el caché de placa
        base en el BIOS y comprueba si se resuelve el problema.</para>

        <para>Hay una extensa FAQ en
        <link xlink:href="http://www.bitwizard.nl/sig11/">the SIG11 problem FAQ</link></para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Cuando arranco, la pantalla queda negra!</para>
      </question>

      <answer>
        <para>Este es un problema conocido con las tarjetas de vídeo ATI
        Mach 64. El problema es que esta tarjeta usa la dirección
        <emphasis remap="tt">2e8</emphasis>, también usada por el puerto
        serie 4. Debido a un bug (feature?) en el driver
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?sio">sio.c</link>
        , éste "tocará" este puerto aunque no esté instalado
        o esté desactivado.</para>

        <para>Hasta que el problema sea fijado, puedes hacer esto:</para>

        <para>
          <orderedlist>
            <listitem>
              <para>Teclea <option>-c</option> en el prompt de arranque. Esto te
              llevará a la sección de configuración del kernel.
              </para>
            </listitem>

            <listitem>
              <para>Desactiva <emphasis remap="tt">sio0</emphasis>,
              <emphasis remap="tt">sio1</emphasis>, <emphasis remap="tt">sio2</emphasis> y
              <emphasis remap="tt">sio3</emphasis> (todos ellos).  De esta manera, el
              driver sio no se activa.</para>
            </listitem>

            <listitem>
              <para>Teclea exit para seguir arrancando.</para>
            </listitem>
          </orderedlist>
        </para>

        <para>Si quieres ser capaz de usar tus puertos serie, tendrás que
        compilar un nuevo kernel con la siguiente modificación:
        <filename>/usr/src/sys/i386/isa/sio.c</filename>. Busca la cadena
        <literal>0x2e8</literal> y borra esta cadena y la coma anterior
        (mantén la coma siguiente). Ahora, compila un nuevo kernel de
        la manera habitual.</para>

        <para>Después de realizar estos cambios, puedes encontrarte aun que
        las X Window no funcionan correctamente. Algunas tarjetas de
        vídeo modernas ATI Mach 64 (especialmente la ATI Mach Xpression)
        no funcionan con la versión actual de <emphasis remap="tt">XFree86</emphasis>;
        la pantalla se queda negra cuando arrancas las X o ocurren cosas extrañas en
        su funcionamiento. Puedes instalar una versión beta del nuevo
        servidor X que trabaja mejor, situada en
        <link xlink:href="http://www.xfree86.org/">el servidor XFree86</link>
        y seguir los links hasta el download. Coge los siguientes archivos:</para>

        <para><emphasis remap="tt">AccelCards, BetaReport, Cards, Devices, FILES, README.ati,
        README.FreeBSD, README.Mach64, RELNOTES, VGADriver.Doc,
        X312BMa64.tgz</emphasis></para>

        <para>Reemplaza los viejos archivos por las nuevas versiones y
        asegúrate de ejecutar de nuevo
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xf86config">xf86config</link>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question xml:id="reallybigram">
        <para>Tengo 128MB de RAM pero el sistema solo usa 64MB.</para>
      </question>

      <answer>
        <para>Debido a la forma que tiene FreeBSD de "ver" el tamaño de
        memoria en el BIOS, solo puede detectar 16 bits
        (65535 Kbytes = 64MB) (o menos... algunas BIOS fijan el tamaño de
        la memoria a 16MB).</para>

        <para>Para solucionar este problema, tienes que usar la opción del
        kernel indicada más adelante. Hay una manera de ver la
        información completa sobre memoria en el BIOS, pero no tenemos
        espacio en los bloques de arranque (bootblocks) para hacerlo. Por ahora,
        tenemos que trabajar con la opción del kernel.</para>

        <para><literal>options "MAXMEM=&lt;n&gt;"</literal></para>

        <para>Donde <emphasis remap="tt">n</emphasis> es tu memoria en Kilobytes.
        Para 128MB, tendrías que usar <emphasis remap="tt">131072</emphasis>.
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>FreeBSD 2.0 aborta con ``kmem_map too small!''</para>
      </question>

      <answer>
        <para><emphasis remap="tt">Nota</emphasis> El mensaje debería ser
        ``mb_map too small!''</para>

        <para>La parada indica que el sistema no tiene memoria virtual
        suficiente para los buffers de red (específicamente,
        clusters mbuf). Puedes incrementar la cantidad de memoria virtual
        disponible para los clusters mbuf añadiendo:</para>

        <para><literal>options "NMBCLUSTERS=&lt;n&gt;"</literal></para>

        <para>al archivo de configuración del kernel, donde &lt;n&gt; es un
        número en el rango 512-4096, dependiendo del número de
        conexiones tcp simultáneas que necesites soportar. Te recomendamos
        intentar con 2048. Puedes monitorizar el número de clusters mbuf
        en uso con la orden
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?netstat">netstat -m</link>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>``CMAP busy panic'' al arrancar con un nuevo kernel.</para>
      </question>

      <answer>
        <para>El programa que intenta detectar archivos
        <filename>/var/db/kvm_*.db</filename> puede fallar y provocar el "panic"
        en el arranque.</para>

        <para>Si esto ocurre, arranca en mono-usuario y haz:</para>

        <para>
          <literallayout>
rm /var/db/kvm_*.db
          </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>ahc0: brkadrint,  Illegal Host Access at seqaddr 0x0</para>
      </question>

      <answer>
        <para>Esto significa un conflicto con una controladora Ultrastor SCSI.</para>

        <para>Durante el proceso de arranque, entra en el menú de
        configuración del kernel y desactiva el dispositivo
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?uha(4)">uha0</link>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Sendmail dice ``mail loops back to myself''</para>
      </question>

      <answer>
        <para>Esto está contestado en la FAQ de sendmail de la siguiente
        manera:</para>

        <para>
          <literallayout>
            * Tengo el error "Local configuration error" :

            553 relay.domain.net config error: mail loops back to myself
            554 &lt;user@domain.net&gt;... Local configuration error

            Cómo puedo solventar el problema?

            Has intentado enviar un mail al dominio domain.net y que sea
            reenviado a un host específico (en este caso relay.domain.net)
            usando un registro MX, pero la máquina que tiene que aceptar
            ese mail, no reconoce el domimio como propio. Añade
            domain.net al archivo /etc/sendmail.cw (si estás usando
            FEATURE(use_cw_file) o añade "Cw domain.net" al archivo
            sendmail.cf
          </literallayout>
        </para>

        <para>La versión actual de la
        <link xlink:href="ftp://rtfm.mit.edu/pub/usenet/news.answers/mail/sendmail-faq">FAQ de sendmail</link>
        puede ser encontrada en
        <link xlink:href="news:comp.mail.sendmail">comp.mail.sendmail</link>,
        <link xlink:href="news:comp.mail.misc">comp.mail.misc</link>,
        <link xlink:href="news:comp.mail.smail">comp.mail.smail</link>,
        <link xlink:href="news:comp.answers">comp.answers</link>, y
        <link xlink:href="news:news.answers">news.answers</link>.
        Tambien puedes recibir una copia enviando un mail a
        <link xlink:href="mailto:mail-server@rtfm.mit.edu">mail-server@rtfm.mit.edu</link>
        con el comando "send usenet/news.answers/mail/sendmail-faq" en el
        cuerpo del mensaje.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>No funcionan correctamente las aplicaciones a pantalla completa
        en máquinas remotas</para>
      </question>

      <answer>
        <para>Quizás la máquina remota tiene el tipo de terminal
        diferente de <emphasis remap="tt">cons25</emphasis> que es el usado por la consola de
        FreeBSD.</para>

        <para>Hay diferentes maneras de solucionar este problema:
        <itemizedlist>
          <listitem>
            <para>Después de hacer el login en la máquina remota,
            configura la variable SHELL como <acronym>ANSI</acronym> o
            <emphasis remap="tt">sco</emphasis>.</para>
          </listitem>

          <listitem>
            <para>Usa el emulador VT100 como
            <link xlink:href="http://www.FreeBSD.org/cgi/ports.cgi?screen-">screen</link>
            local. <emphasis remap="tt">screen</emphasis> te permite la posibilidad de ejecutar
            múltiples y concurrentes sesiones desde un terminal.</para>
          </listitem>

          <listitem>
            <para>Instala la base de datos del terminal <emphasis remap="tt">cons25</emphasis>
            en la máquina remota.</para>
          </listitem>

          <listitem>
            <para>Lanza las X y haz el login en la máquina remota desde
            <emphasis remap="tt">xterm</emphasis>.</para>
          </listitem>
        </itemizedlist>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Aparece el mensaje de error "calcru: negative time..."</para>
      </question>

      <answer>
        <para>Esto puede ser causado por varios problemas de hardware o software
        relacionados con las interrupciones. Utilizar TCP/IP sobre el puerto
        paralelo con un MTU muy grande es una buena manera de provocar este error.
        Las tarjetas gráficas aceleradoras también lo pueden
        provocar, teniendo que revisar la interrupción utilizada
        por la tarjeta.</para>

        <para>El efecto de este error es que los procesos mueren con el mensaje
        "SIGXCPU exceeded cpu time limit".</para>

        <para>Para FreeBSD 3.0 y posteriores desde el 29 de Noviembre de 1998: si
        el problema no puede fijarse de otra manera, la solución es
        poner la variable sysctl a:
          <literallayout>
sysctl -w kern.timecounter.method=1
          </literallayout>
        </para>

        <para>Esto puede significar un impacto en el rendimiento del sistema, pero
        considerando la causa del problema, probablemente no lo notarás. Si
        el problema persiste, mantén la variable sysctl a uno y
        añade la opción "NTIMECOUNTER" en tu kernel para aumentar
        su valor. Si finalmente llegas a un valor de "NTIMECOUNTER=20" el problema
        no está resuelto, y las interrupciones están demasiado
        saturadas para ofrecer un buén rendimiento.</para>
      </answer>
    </qandaentry>
  </qandaset>
</chapter>

<chapter xml:id="commercial">
  <title>Aplicaciones Comerciales</title>

  <para><acronym>NOTA</acronym> Esta sección está todavía poco
  desarrollada, por lo que esperamos que las compañías nos
  ayuden a completarla :) . El grupo de FreeBSD no tiene ningún
  interés financiero en ninguna de las empresas aquí listadas,
  simplemente están como servicio público (y creemos que el
  interés comercial por FreeBSD puede tener efectos
  muy positivos en la viabilidad a largo término). Animamos a las
  empresas desarrolladoras de software que nos envíen su
  información para ser incluidas en esta lista.</para>

  <qandaset>
    <qandaentry>
      <question>
        <para>?Dónde puedo obtener Motif para FreeBSD?</para>
      </question>

      <answer>
        <para>Contacta con <link linkend="apps2go">Apps2go</link> para una
        distribución de Motif ELF 2.1 para FreeBSD.<anchor xml:id="apps2go"/></para>

        <para>Esta distribución incluye:
        <itemizedlist>
          <listitem>
            <para>OSF/Motif manager, xmbind, panner, wsm.</para>
          </listitem>

          <listitem>
            <para>Kit de desarrollo con uil, mrm, xm, xmcxx, includes y
            archivos Imake.</para>
          </listitem>

          <listitem>
            <para>Librerías ELF estáticas y dinámicas
            (para usar con FreeBSD 3.0 y posteriores).</para>
          </listitem>

          <listitem>
            <para>Applets demostrativos.</para>
          </listitem>
        </itemizedlist>
        </para>

        <para>Asegúrate de especificar que deseas la distribución
        para FreeBSD cuando hagas el pedido. También se distribuyen
        versiones para NetBSD y OpenBSD  por <emphasis>Apps2go</emphasis>. La
        distribución sólo está disponible por FTP.</para>

        <para>
        <variablelist>
          <varlistentry>
            <term>
              Más información
            </term>
            <listitem>
              <para><link xlink:href="http://www.apps2go.com/">Página web de Apps2go</link></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              o
            </term>
            <listitem>
              <para><link xlink:href="mailto:sales@apps2go.com">Ventas</link> o
              <link xlink:href="mailto:support@apps2go.com">Soporte</link></para>
              <para/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              o
            </term>
            <listitem>
              <para>teléfono (817) 431 8775 o +1 817 431-8775</para>
            </listitem>
          </varlistentry>
        </variablelist>
        </para>

        <para>Contacta con <link linkend="metrox">Metro Link</link> para obtener una
        distribución de Motif 2.1 ELF o a.out para FreeBSD.</para>

        <para>Esta distribución incluye:
        <itemizedlist>
          <listitem>
            <para>OSF/Motif manager, xmbind, panner, wsm.</para>
          </listitem>

          <listitem>
            <para>Kit de desarrollo con uil, mrm, xm, xmcxx, includes y
            archivos Imake. </para>
          </listitem>

          <listitem>
            <para>Librerías estáticas y dinámicas (especifica
            ELF para FreeBSD 3.0 y superior o a.out para FreeBSD 2.2.8 o
            anterior).</para>
          </listitem>

          <listitem>
            <para>Applets demostrativos.</para>
          </listitem>

          <listitem>
            <para>Páginas man preformateadas.</para>
          </listitem>
        </itemizedlist>
        </para>

        <para>Asegúrate de especificar que deseas la distribución
        para FreeBSD cuando hagas el pedido. También se distribuyen
        versiones para Linux por <emphasis>Metro Link</emphasis>. La distribución
        está disponible en CDROM o vía FTP.</para>

        <para>Contacta con <link linkend="xig">Xi Graphics</link> para una
        distribución de Motif a.out 2.0 para FreeBSD.</para>

        <para>Esta distribución incluye:
        <itemizedlist>
          <listitem>
            <para>OSF/Motif manager, xmbind, panner, wsm.</para>
          </listitem>

          <listitem>
            <para>Kit de desarrollo con uil, mrm, xm, xmcxx, includes y
            archivos Imake.</para>
          </listitem>

          <listitem>
            <para>Librerías estáticas y dinámicas
            (para usar con FreeBSD 2.2.8 y anteriores).</para>
          </listitem>

          <listitem>
            <para>Applets demostrativos.</para>
          </listitem>

          <listitem>
            <para>Páginas man preformateadas.</para>
          </listitem>
        </itemizedlist>
        </para>

        <para>Asegúrate de especificar que deseas la distribución
        para FreeBSD cuando hagas el pedido. También se distribuyen
        versiones para BSDI y Linux por <emphasis>Xi Graphics</emphasis>. La
        distribución se hace en cuatro disquetes... en el futuro esto
        se cambiará por una versión en CDROM unificada.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Dónde puedo conseguir CDE para FreeBSD?</para>
      </question>

      <answer>
        <para>Contacta con <link linkend="xig">Xi Graphics</link> para la
        distribucion CDE 1.0.10 para FreeBSD. Incluye Motif 1.2.5,
        y puede ser usada con Motif 2.0.</para>

        <para>Este es un CDROM unificado para FreeBSD y Linux.</para>

        <para><link linkend="xig">Xi Graphics</link> ya no vende el CDE
        para FreeBSD.</para>

        <para><link xlink:href="http://www.kde.org/">KDE</link> es un entorno
        gráfico "open source" similar a CDE en muchos aspectos.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Hay algún servidor X comercial de altas prestaciones?</para>
      </question>

      <answer>
        <para>Sí, <link xlink:href="http://www.xig.com/">Xi Graphics</link> y
        <link xlink:href="http://www.metrolink.com/">Metro Link</link> venden el
        producto Accelerated-X para FreeBSD y otros sistemas basados en Intel.
        <anchor xml:id="xig"/></para>

        <para>La oferta de Metro Link es un servidor X de altas prestaciones que
        ofrece una fácil configuración usando el conjunto de
        herramientas "FreeBSD Package", soporte de múltiples tarjetas
        de vídeo concurrentes y sólo se distribuye en formato
        binario desde su FTP. Mencionar que la oferta de Metro Link está
        disponible por el razonable precio de $39.
        <anchor xml:id="metrox"/> </para>

        <para>Metro Link también vende el Motif ELF y a.out para
        FreeBSD.</para>

        <para>
        <variablelist>
          <varlistentry>
            <term>
              Más información
            </term>
            <listitem>
              <para><link xlink:href="http://www.metrolink.com/">Web de Metro Link</link></para>
              <para/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              o
            </term>
            <listitem>
              <para><link xlink:href="mailto:sales@metrolink.com">Ventas</link> o
              <link xlink:href="mailto:tech@metrolink.com">Soporte</link>.</para>
              <para/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              o
            </term>
            <listitem>
              <para>Teléfono (954) 938-0283 o +1 954 938-0283</para>
            </listitem>
          </varlistentry>
        </variablelist>
        </para>

        <para>La oferta de Xi Graphics es un servidor X de altas prestaciones que
        ofrece una fácil configuración, soporte para
        múltiples tarjetas de vídeo concurrentes, y sólo
        se distribuye en formato binario, en una distribución en
        disquetes unificada para FreeBSD y Linux. Xi Graphics también
        ofrece un servidor X de altas prestaciones para computadores
        portátiles.</para>

        <para>Hay una distribución demo para testear (versión 5.0).</para>

        <para>Xi Graphics también vende el Motif y CDE para FreeBSD.</para>

        <para>
        <variablelist>
          <varlistentry>
            <term>
              Máss información
            </term>
            <listitem>
              <para><link xlink:href="http://www.xig.com/">Web de Xi Graphics WWW</link></para>
              <para/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              o
            </term>
            <listitem>
              <para><link xlink:href="mailto:sales@xig.com">ventas</link> o
              <link xlink:href="mailto:support@xig.com">Soporte</link></para>
              <para/>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              o
            </term>
            <listitem>
              <para>Teléfono (800) 946 7433  o +1 303 298-7478.</para>
            </listitem>
          </varlistentry>
        </variablelist>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Hay algún sistema de base de datos para FreeBSD?</para>
      </question>

      <answer>
        <para>Sí!. Mira en la sección
        <link xlink:href="../commercial/software_bycat.html#CATEGORY_DATABASE">Productos Comerciales</link>
        del web de FreeBSD.</para>

        <para>También te recomendamos que mires en la sección
        <link xlink:href="../ports/databases.html">Bases de Datos</link> de la
        colección de Ports.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Puedo usar Oracle en FreeBSD?</para>
      </question>

      <answer>
        <para>Sí. Las siguientes páginas te explican como configurar
        el Oracle de Linux en FreeBSD:</para>

        <para>
        <itemizedlist>
          <listitem>
            <para><link xlink:href="http://www.scc.nl/~marcel/howto-oracle.html">http://www.scc.nl/~marcel/howto-oracle.html</link></para>
          </listitem>

          <listitem>
            <para><link xlink:href="http://www.lf.net/lf/pi/oracle/install-linux-oracle-on-FreeBSD">http://www.lf.net/lf/pi/oracle/install-linux-oracle-on-FreeBSD</link></para>
          </listitem>
         </itemizedlist>
         </para>
      </answer>
    </qandaentry>
  </qandaset>
</chapter>

<chapter xml:id="applications">
<title>Aplicaciones de usuario</title>

  <qandaset>
    <qandaentry>
      <question>
        <para>?Dónde están las aplicaciones?</para>
      </question>

      <answer>
        <para>Por favor, mira en <link xlink:href="http://www.FreeBSD.org/ports/">la sección
        de ports</link> para obtener información sobre
        programas y aplicaciones que han sido portados a FreeBSD. En estos
        momentos la lista llega a los 1800 creciendo día a día,
        por lo que te recomendamos que la visites habitualmente o te subscribas
        a la <link linkend="mailing">lista de distribución</link>
        <emphasis remap="tt">FreeBSD-announce</emphasis> para las actualizaciones
        periódicas de nuevas aportaciones.</para>

        <para>La mayoría de programas están disponibles tanto para la
        rama 2.2 como para la 3.x y 4.0, y muchos de ellos deberían
        funcionar en sistemas 2.1.x. Cada vez que se realiza una release de
        FreeBSD, se incluye un snapshot del arbol de aplicaciones en el
        directorio <filename>ports/</filename>.</para>

        <para>También trabajamos con el concepto de "package", que es,
        esencialmente una distribución binaria "zipada" con una
        pequeña información extra que realiza la instalación
        del programa automaticamente. Un package puede ser instalado y
        desinstalado fácilmente sin tener que saber los detalles de
        archivos o configuraciones que esto conlleva.</para>

        <para>Usa el menú de instalación de "packages" en
        <filename>/stand/sysinstall</filename> (bajo la opción post-configuration del
        menú principal) o ejecuta el comando <command>pkg_add(1)</command> con el
        package que estás interesado en instalar. Los package pueden ser
        identificados por su extensión <filename>.tgz</filename>. En la
        distribución de CDROM existe un directorio <filename>packages/All</filename>
        en la que se encuentran todos los packages disponibles. También
        pueden conseguirse en la red en los siguientes servidores:</para>

        <para>
          <variablelist>
            <varlistentry><term>para 2.2.8-RELEASE/2.2-stable</term>
              <listitem>
                <para><link xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-2.2.8/">ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-2.2.8/</link></para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry><term>para 3.4-release/3.4-stable</term>
              <listitem>
                <para><link xlink:href="ftp://ftp.FreeBSD.ORG/pub/FreeBSD/ports/i386/packages-3-stable/">ftp://ftp.FreeBSD.ORG/pub/FreeBSD/ports/i386/packages-3-stable/</link></para>
                <para/>
              </listitem>
            </varlistentry>

            <varlistentry><term>para 4.0-current</term>
              <listitem>
                <para><link xlink:href="ftp://ftp.FreeBSD.ORG/pub/FreeBSD/ports/i386/packages-4-current/">ftp://ftp.FreeBSD.ORG/pub/FreeBSD/ports/i386/packages-4-current/</link></para>
              </listitem>
            </varlistentry>
          </variablelist>
        </para>

        <para>o en tu mirror más cercano.</para>

        <para>Ten en cuenta que no todos los ports están disponibles como
        packages. Es siempre buena idea visitar periodicamente la
        dirección <link xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/">ftp.FreeBSD.org</link>.
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Dónde encuentro la librería libc.so.3.0?</para>
      </question>

      <answer>
        <para>Estás intentando ejecutar un package para versión
        2.2/3.x/4.0 en un sistema de versión 2.1.x. Por favor, mira en la
        sección anterior y usa el package adecuado para tu sistema.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question xml:id="emul">
        <para>Ghostscript tiene muchos errores con mi 386/486SX.</para>
      </question>

      <answer>
        <para>No tienes coprocesador matemático, verdad?
        Necesitarás añadir el emulador matemático en tu
        kernel; puedes hacerlo añadiendo lo siguiente en el archivo de
        configuración del kernel:</para>

        <para>
          <literallayout>
options GPL_MATH_EMULATE
          </literallayout>
        </para>

        <para><acronym>NOTA</acronym> Necesitarás eliminar la opción
        <symbol>MATH_EMULATE</symbol>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Cuando ejecuto una aplicación SCO/iBCS2, falla en
        <emphasis remap="tt">socksys</emphasis>.</para>
      </question>

      <answer>
        <para>Primero necesitas editar el archivo <filename>/etc/sysconfig</filename>
        (o <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?rc.conf(5)">/etc/rc.conf</link>)
        y en la última sección cambiar la siguiente variable a
        <acronym>YES</acronym>:</para>

        <para>
          <literallayout>
# Set to YES if you want ibcs2 (SCO) emulation loaded at startup
ibcs2=NO
          </literallayout>
        </para>

        <para>El kernel caragará el módulo
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ibcs2">ibcs2</link>
        al arrancar.</para>

        <para>A continuación necesitarás configurar /compat/ibcs2/dev
        de la siguiente manera</para>

        <para>
          <literallayout>
lrwxr-xr-x  1 root  wheel         9 Oct 15 22:20 X0R@ -&gt; /dev/null
lrwxr-xr-x  1 root  wheel         7 Oct 15 22:20 nfsd@ -&gt; socksys
-rw-rw-r--  1 root  wheel         0 Oct 28 12:02 null
lrwxr-xr-x  1 root  wheel         9 Oct 15 22:20 socksys@ -&gt; /dev/null
crw-rw-rw-  1 root  wheel   41,   1 Oct 15 22:14 spx
          </literallayout>
        </para>

        <para>Solo necesitas el socksys para ir a
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?null(4)">/dev/null</link>
        e imitar la apertura y cierre de archivos. El código en -current
        gestionará el resto. Esto es mucho más limpio que la
        manera en la que se hacía antes. Si quieres el driver
        <emphasis remap="tt">spx</emphasis> para un conexión, define
        <symbol>SPX_HACK</symbol> cuando compiles el kernel.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo configuro INN (Internet News) para mi máquina?</para>
      </question>

      <answer>
        <para>Después de la instalación del package o port de inn,
        un excelente lugar para empezar es
        <link xlink:href="http://www.cis.ohio-state.edu/~barr/INN.html">Dave Barr's INN Page</link>
        donde encontrarás las FAQ de INN.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Qué versión de Microsoft FrontPage debo usar?</para>
      </question>

      <answer>
        <para>Usa el Port. Una versión pre-parcheada para Apache está
        disponible en la colección de ports.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?FreeBSD soporta Java?</para>
      </question>

      <answer>
        <para>Sí. Por favor, mira en
        <link xlink:href="http://www.FreeBSD.org/java/">http://www.FreeBSD.org/java/</link>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Porqué no puedo compilar este port en mi máquina
        3.x-stable?</para></question><answer>

        <para>Si utilizas una versión de FreeBSD que ha quedado ligeramente anticuada
        con respecto a -stable o -current necesitarás el kit de actualización
        de ports disponible en
        <link xlink:href="http://www.FreeBSD.org/ports/">http://www.FreeBSD.org/ports/</link>.
        Si tienes una versión actualizada, es posible que alguien haya modificado
        el port de manera que éste compile en -current pero no en -stable. Por favor,
        envía un informe de error con el comando <command>send-pr(1)</command> ya que
        la colección de ports está pensada para que funcione tanto en las ramas
        -stable como -current.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Dónde encuentro ld.so?</para>
      </question>

      <answer>
        <para>Si quieres ejecutar aplicaciones a.out como Netscape en sistemas con
        formato de ejecución ELF como FreeBSD 3.1-RELEASE o posteriores,
        necesitarás la librería /usr/libexec/ld.so y algunas otras
        en formato a.out. Estas librerías están incluidas en la
        distribución compat22. Usa /stand/sysinstall o el script install.sh
        en el subdirectorio compat22 e instalala. También deberían
        consultarse los archivos ERRATA de FreeBSD 3.1-R y 3.2-R.</para>
      </answer>
    </qandaentry>
  </qandaset>
</chapter>

<chapter xml:id="kernelconfig">
  <title>Configuración del Kernel</title>

  <qandaset>
    <qandaentry>
      <question xml:id="make-kernel">
        <para>Me gustaría personalizar mi kernel. ?Es difícil?</para>
      </question>

      <answer>
        <para>No!, primero, necesitas la distribución completa de fuentes o,
        por lo menos, la distribución de fuentes del kernel. De esta manera
        tienes los fuentes necesarios para crearte un nuevo kernel. Al
        contrario que muchos Unix comerciales, nosotros tenemos la política
        de <acronym>NO</acronym> vender nuestro kernel en formato binario.</para>

        <para>La instalación de los fuentes ocupa un poco más de
        espacio, pero te permite consultar los fuentes del kernel en caso de
        dificultad o entender que está ocurriendo realmente en la
        ejecución del sistema.</para>

        <para>Una vez tienes instalada la distribución completa de fuentes, o
        por lo menos la del kernel, haz lo siguiente como root:</para>

        <para>
        <orderedlist>
          <listitem>
            <para> <command>cd /usr/src/sys/i386/conf</command></para>
          </listitem>

          <listitem>
            <para> <emphasis remap="tt">cp GENERIC MYKERNEL</emphasis></para>
          </listitem>

          <listitem>
            <para> <emphasis remap="tt">vi MYKERNEL</emphasis></para>
          </listitem>

          <listitem>
            <para> <emphasis remap="tt">config MYKERNEL</emphasis></para>
          </listitem>

          <listitem>
            <para> <emphasis remap="tt">cd ../../compile/MYKERNEL</emphasis></para>
          </listitem>

          <listitem>
            <para> <emphasis remap="tt">make depend</emphasis></para>
          </listitem>

          <listitem>
            <para> <emphasis remap="tt">make all</emphasis></para>
          </listitem>

          <listitem>
            <para> <emphasis remap="tt">make install</emphasis></para>
          </listitem>

          <listitem>
            <para> <emphasis remap="tt">reboot</emphasis></para>
          </listitem>
        </orderedlist>
        </para>

        <para>El paso 2 no es necesario si todavía tienes un archivo de
        configuración del kernel de una release anterior de FreeBSD
        2.X. - simplemente, copia el archivo antiguo y examínalo
        cuidadosamente para asegurar que no haya cambiado la sintaxis
        da algún driver, o haya alguno anticuado.</para>

        <para>Un buen archivo de configuración para consultar es <acronym>LINT</acronym>,
        el cual contiene ejemplos documentados para todas las posibles
        opciones del kernel. El archivo de configuración <acronym>GENERIC</acronym> se
        usa para crear el kernel "por defacto" que es el que estarás
        usando si no has creado ninguno nuevo.</para>

        <para>Si no necesitas hacer ningún cambio al archivo <acronym>GENERIC</acronym>,
        puedes saltar al paso 3, donde personalizas el kernel para tu
        sistema. El paso 8 solo debe ejecutarse si los pasos 6 y 7 se
        han realizado de manera satisfactoria. Esto copiará una
        imágen del nuevo kernel a <filename>/kernel</filename> y
        <emphasis remap="bf">realizará una copia del antiguo kernel en</emphasis>
        <filename>/kernel.old</filename>. Es muy importante recordar esto por si el
        nuevo kernel falla en algun momento - puedes seleccionar <filename>kernel.old</filename>
        en el prompt de arranque. Al hacer un reboot, por defecto se cargará el
        nuevo kernel.</para>

        <para>Si la compilación en el paso 7 falla por alguna razón, es
        recomendable que empieces desde el paso 4 substituyendo
        <acronym>GENERIC</acronym> por <acronym>MYKERNEL</acronym>. Si puedes generar el kernel
        <acronym>GENERIC</acronym>, significa que algo en tu archivo de configuración
        es incorrecto (o has decubierto un bug). Si la compilación del
        kernel <acronym>GENERIC</acronym> falla, posiblemente tengas los fuentes
        corruptos.</para>

        <para>Finalmente, si necesitas ver los mensajes originales de arranque
        del sistema para compilar un nuevo kernel, ejecuta el comando
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?dmesg">dmesg</link>. Este
        comando debe imprimir en pantalla todos los
        mensajes producidos por el kernel al arrancar, los cuales te
        pueden servir en la configuración de tu nuevo kernel.</para>

        <para><acronym>NOTA</acronym> Recomendamos hacer un historial fechado de los kernel
        que vayas creando, de la manera <filename>kernel.YYMMDD</filename> una vez estén
        funcionando correctamente. De esta manera, si la próxima vez que
        juegues con el kernel algo no funciona, puedes arrancar desde el
        último kernel correcto. Esto es especialmente importante si ahora
        estás arrancando desde una controladora no soportada por el kernel
        GENERIC (si, experiencia personal).</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>La compilación del kernel falla por "<symbol>_hw_float</symbol> is
        missing."</para>
      </question>

      <answer>
        <para>Dejame adivinar. Has borrado
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?npx(4)">npx0</link>
        de tu archivo de configuración porque no tienes coprocesador
        matemático, no? Mal hecho :-) El dispositivo <emphasis remap="tt">npx0</emphasis> es
        <acronym>OBLIGATORIO</acronym>. Aunque no tengas coprocesador, debes incluir
        el dispositivo <emphasis remap="tt">npx0</emphasis></para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Conflicto de interrupciones con tarjeta serie multi-port.</para>
      </question>

      <answer>
        <para>Cuando compilo el kernel con drivers para tarjetas serie
        multipuerto, el sistema me dice que sólo el primer puerto es
        testeado y el resto son obviados debido a conflictos de
        interrupción. Cómo soluciono esto?</para>

        <para>El problema en este caso es que FreeBSD tiene código interno que
        evita caidas del sistema por conflictos de hardware o software. La
        manera de solucionar esto es dejar en blanco la entrada correspondiente
        a la irq en todos los puertos excepto en uno. Aquí tienes un
        ejemplo:</para>

        <para>
        <literallayout>        #
        # Multiport high-speed serial line - 16550 UARTS
        #
        device sio2 at isa? port 0x2a0 tty irq 5 flags 0x501 vector siointr
        device sio3 at isa? port 0x2a8 tty flags 0x501 vector siointr
        device sio4 at isa? port 0x2b0 tty flags 0x501 vector siointr
        device sio5 at isa? port 0x2b8 tty flags 0x501 vector siointr
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo activo el soporte para discos QIC-40/80?</para>
      </question>

      <answer>
        <para>Necesitas "descomentar" la siguiente línea en el archivo
        genérico de configuración (o añadirla en tu propio
        archivo), añade un <literal>flags 0x1</literal> en la línea
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?fdc(4)">fdc</link>
        y recompila.</para>

        <para>
        <literallayout>
controller  fdc0  at isa? port "IO_FD1" bio irq 6 drq 2 flags 0x1 vector fdintr
disk        fd0   at fdc0 drive 0                       ^^^^^^^^^
disk        fd1   at fdc0 drive 1
#tape       ft0   at fdc0 drive 2
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        </literallayout>
        </para>

        <para>A continuación, crea un nuevo dispositivo llamado
        <filename>/dev/ft0</filename> entrando en el directorio <filename>/dev</filename>
        y ejecutando el comando:</para>

        <para>
        <literallayout>        sh ./MAKEDEV ft0
        </literallayout>
        </para>

        <para>Para el primer dispositivo. <emphasis remap="tt">ft1</emphasis> para el
        segundo y así para todos los dispositivos de este tipo que tengas.</para>

        <para>Tendrás un dispositivo llamado <filename>/dev/ft0</filename>, al cual puedes
        escribir a través de un programa especial de manejo llamado
        <emphasis remap="tt">ft</emphasis> - mira el man en
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ft">ft</link>
        para más detalles.</para>

        <para>Versiones anteriores a la <option>-current</option> tenían algunos problemas
        al encontrase con cintas en mal estado; si tienes problemas en los
        que parece que la cinta se rebovina siempre al llegar al mismo
        lugar, intenta utilizar la última versión del programa
        <emphasis remap="tt">ft</emphasis> que encontrarás en
        <filename>/usr/src/sbin/ft</filename> en <option>-current</option>.</para>
      </answer>
    </qandaentry>
  </qandaset>
</chapter>

<chapter xml:id="admin">
  <title>Administración de sistema</title>

  <qandaset>
    <qandaentry>
      <question>
        <para>?Dónde están los archivos de configuración
        de arranque del sistema?</para>
      </question>

      <answer>
        <para>De la versión 2.0.5R a la 2.2.1R, el archivo principal de
        configuración es <filename>/etc/sysconfig</filename>. Todas las opciones son
        especificadas en este archivo y otros como
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?rc">/etc/rc</link> y
        <filename>/etc/netstart</filename>.</para>

        <para>Mira en el archivo <filename>/etc/sysconfig</filename> y cambia los valores
        para tu sistema. Este archivo está comentado para ayudar en la
        configuración</para>

        <para>En versiones posteriores a la 2.2.1 y 3.0 el archivo
        <filename>/etc/sysconfig</filename> fue renombrado como
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?rc.conf(5)">rc.conf</link>.
        La sintaxis también fue retocada para ser más descriptiva. El
        archivo <filename>/etc/netstart</filename> también fue renombrado como
        <filename>/etc/rc.network</filename> para que todos los archivos de
        configuración puedan ser copiados con el comando
        <command>cp
        /usr/src/etc/rc* /etc</command>.</para>

        <para><filename>/etc/rc.local</filename> existe como siempre y debería ser usado
        para arrancar servicios locales adicionales como
        <link xlink:href="http://www.FreeBSD.org/cgi/ports.cgi?^inn">INN</link> o
        programas propios.</para>

        <para>El archivo <filename>/etc/rc.serial</filename> es para la inicialización
        de puertos serie.</para>

        <para>El archivo <filename>/etc/rc.i386</filename> es para especificaciones propias
        de Intel, como la emulación iBCS2 o la configuración de la
        consola del sistema.</para>

        <para>A partir de la versión 2.1.0R, también puedes tener un
        directorio en el que instalar archivos de arranque locales especificado en
        <filename>/etc/sysconfig</filename> (o <filename>/etc/rc.conf</filename>):</para>

        <para>
        <literallayout>        # Localización de los archivos de arranque locales.
        local_startup=/usr/local/etc/rc.local.d
        </literallayout>
        </para>

        <para>Cada archivo acabado en <filename>.sh</filename> será ejecutado en orden
        alfabético.</para>

        <para>Si quieres asegurarte de un cierto orden en la ejecución sin
        tener que cambiar todos los nombres de los archivos, puedes usar un
        esquema similar al siguiente con dígitos al principio del nombre
        de cada archivo:</para>

        <para>
        <literallayout>        10news.sh
        15httpd.sh
        20ssh.sh
        </literallayout>
        </para>

        <para>Puede ser visto como "malo" (o SysV :-)) pero nos provee de un
        esquema regular para programas añadidos localmente sin tener que
        hacer ediciones complicadas del archivo <filename>/etc/rc.local</filename>.
        Muchos de los ports/packages asumen que <filename>/usr/local/etc/rc.d</filename>
        es un directorio de arranque local.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo añado un usuario facilmente?</para>
      </question>

      <answer>
        <para>Usa el comando
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?adduser">adduser</link>.
        Para opciones más avanzadas, usa el comando
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?pw">pw</link></para>

        <para>Para borrar a un usuario, usa el comando
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?rmuser">rmuser</link>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo puedo añadir mi nuevo disco a FreeBSD?</para>
      </question>

      <answer>
        <para>Consultar el Tutorial de Formateo de Discos en
        <link xlink:href="../../tutorials/diskformat/">www.FreeBSD.org</link>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Tengo un nuevo disco removible, ?como lo uso?</para>
      </question>

      <answer>
        <para>Se trate de un disco removible como un ZIP o EA (o un floppy,
        si quieres usarlo de esta manera), o un nuevo disco duro, una vez
        instalado y reconocido por el sistema, y tengas tu
        cartridge/floppy/etc en su interior, las cosas son como para la
        mayoría de dispositivos.</para>

        <para><anchor xml:id="disklabel"/>(esta sección esta basada en
        <link xlink:href="http://vinyl.quickweb.com/mark/FreeBSD/ZIP-FAQ.html">Mark Mayo's ZIP FAQ</link>)</para>

        <para>Si es un disco ZIP o floppy, y está formateado en DOS, puedes
        usar el comando:</para>

        <para>
        <literallayout>
mount -t msdos /dev/fd0c /floppy
        </literallayout>
        </para>

        <para>Si es un floppy, o este:</para>

        <para>
        <literallayout>
mount -t msdos /dev/da2s4 /zip
        </literallayout>
        </para>

        <para>para un disco ZIP con la configuración de fábrica.</para>

        <para>Para otros discos, mira como configurarlos usando
        <emphasis remap="tt">fdisk</emphasis> o
        <filename>/stand/sysinstall</filename>.</para>

        <para>El resto de ejemplos serán para un disco ZIP en da2, el tercer
        disco SCSI.</para>

        <para>A no ser que se trate de un floppy o disco removible, lo que
        planeas compartir con otros usuarios, es aconsejable convertir
        el formato de archivos a BSD. Obtendrás nombre de archivos largos,
        como mínimo doblarás la velocidad de acceso del disco, y
        mucha más estabilidad. Antes, necesitas rehacer las particiones.
        Puedes usar el comando
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?fdisk">fdisk</link>
        o la utilidad <filename>/stand/sysinstall</filename>. Si es un
        disco pequeño que quieres dedicar enteramente a FreeBSD, solo
        tienes que eliminar la FAT y tabla de particiones, y usar el sistema
        de particiones de FreeBSD:</para>

        <para>
        <literallayout>
dd if=/dev/zero of=/dev/rda2 count=2
disklabel -Brw da2 auto
        </literallayout>
        </para>

        <para>Puedes usar el comando disklabel o
        <filename>/stand/sysinstall</filename> para crear múltiples
        particiones BSD.</para>

        <para>Finalmente, crea un nuevo sistema de archivos:</para>

        <para>
        <literallayout>
newfs /dev/rda2c
        </literallayout>
        </para>

        <para>y montalo:</para>

        <para>
        <literallayout>
mount /dev/da2c /zip
        </literallayout>
        </para>

        <para>Sería una buena idea añadir una línea como esta
        en el archivo
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?fstab">/etc/fstab</link>
        para que solo tengas que teclear "mount /zip" las siguientes veces.</para>

        <para>
        <literallayout>
/dev/da2c /zip ffs rw,noauto 0 0
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo monto una partición secundaria DOS?</para>
      </question>

      <answer>
        <para>Las particiones DOS secundarias se encuentran después de TODAS
        las particiones primarias. Por ejemplo, si tienes una partición
        "E" como la segunda partición DOS en el segundo disco SCSI,
        necesitas crear los archivos especiales para el dispositivo 5 en /dev, y
        después montar /dev/da1s5:</para>

        <para>
        <literallayout>
# cd /dev
# ./MAKEDEV da1s5
# mount -t msdos /dev/da1s5 /dos/e
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Puedo montar otros sistemas de archivos bajo FreeBSD?</para>
      </question>

      <answer>
        <para><emphasis remap="bf">Digital UNIX</emphasis> UFS CDROMs pueden ser
        montados directamente en FreeBSD. Montar particiones de disco de
        Digital UNIX y otros sistemas que soportan UFS puede ser más complejo,
        dependiendo de los detalles de la partición de disco del sistema
        operativo en cuestión.</para>

        <para><emphasis remap="bf"> Linux</emphasis>: 2.2 y posteriores soportan
        particiones <emphasis remap="bf">ext2fs</emphasis>. Mira
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?mount_ext2fs">mount_ext2fs</link>
        para más información.</para>

        <para><emphasis remap="bf"> NT</emphasis>: Existe un driver de solo lectura
        de NTFS para FreeBSD. Para más información, mira este tutorial
        de Mark Ovens en
        <link xlink:href="http://www.users.globalnet.co.uk/~markov/ntfs_install.html">http://www.users.globalnet.co.uk/~markov/ntfs_install.html</link>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo puedo usar el "NT loader" para arrancar FreeBSD?</para>
      </question>

      <answer>
        <para>La idea general es que copies el primer sector de la partición
        root nativa de FreeBSD en un archivo en la partición DOS/NT.
        Asumiento que nombras a ese archivo como <filename>c:\bootsect.bsd</filename>
        puedes editar el archivo <filename>c:\boot.ini</filename> para conseguir
        algo como esto:</para>

        <para>
        <literallayout>
[boot loader]
timeout=30
default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
[operating systems]
multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Windows NT"
C:\BOOTSECT.BSD="FreeBSD"
C:\="DOS"
        </literallayout>
        </para>

        <para>Este proceso asume que DOS, NT, FreeBSD o cualquier otro sistema
        ha sido instalado en sus respectivas particiones en el mismo disco.
        En nuestro caso, DOS y NT están en la primera partición
        y FreeBSD en la segunda. Instalamos FreeBSD para arrancarlo desde su
        partición nativa y no desde el disco MBR.</para>

        <para>Monta un floppy formateado en DOS bajo la partición
        <filename>/mnt</filename>.</para>

        <para>
        <literallayout>
dd if=/dev/rda0a of=/mnt/bootsect.bsd bs=512 count=1
        </literallayout>
        </para>

        <para>Rearranca en DOS o NT. Copia el archivo
        <filename>bootsect.bsd</filename> y/o el archivo
        <filename>bootsect.lnx</filename> del floppy a
        <emphasis remap="tt">C:\</emphasis>. Modifica los atributos a
        <filename>boot.ini</filename> con:</para>

        <para>
        <literallayout>
attrib -s -r c:\boot.ini
        </literallayout>
        </para>

        <para>Edita y añade las líneas apropiadas del boot.ini mostrado
        enteriormente de ejemplo, y vuelve a poner los atributos originales:</para>

        <para>
        <literallayout>
attrib +s +r c:\boot.ini
        </literallayout>
        </para>

        <para>Si FreeBSD está arrancando desde el MBR, restauralo desde el
        comando <emphasis remap="tt">fdisk</emphasis> después de reconfigurarlos
        para arrancar desde sus particiones nativas.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo arranco FreeBSD y Linux desde LILO?</para>
      </question>

      <answer>
        <para>Si tienes FreeBSD y Linux en el mismo disco, solo tienes que seguir
        las instrucciones de instalación de LILO para arrancar un sistema
        operativo no Linux. Brevemente, son estas:</para>

        <para>Arranca Linux, y añade las siguientes líneas en el
        archivo <filename>/etc/lilo.conf</filename>:
        <literallayout>
other=/dev/hda2
table=/dev/hda
label=FreeBSD
        </literallayout>

        (Asumiendo que tu partición FreeBSD es conocida por Linux como
        <filename>/dev/hda2</filename>). A continuación, ejecuta
        <emphasis remap="tt">lilo</emphasis> como root y ya debería
        estar.</para>

        <para>Si FreeBSD está en otro disco, necesitas añadir
        ``<literal>loader=/boot/chain.b</literal>'' al archivo
        <filename>lilo.conf</filename>. Por ejemplo:
        <literallayout>
other=/dev/sdb4
table=/dev/sdb
loader=/boot/chain.b
label=FreeBSD
        </literallayout>
        </para>

        <para>En algunos casos necesitarás especificar el número de
        disco en BIOS para que el cargador del boot funcione correctamente desde
        el segundo disco. Por ejemplo, si tu disco SCSI con FreeBSD es visto por
        el BIOS como disco 1, en el prompt del cargador de arranque
        necesitarás especificar:
        <literallayout>
Boot: 1:da(0,a)/kernel
        </literallayout>
        </para>

        <para>En FreeBSD 2.2.5 y posteriores, puedes configurar
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?boot(8)">boot(8)</link>
        para que haga esto automaticamente.</para>

        <para>El
        <link xlink:href="http://sunsite.unc.edu/LDP/HOWTO/mini/Linux+FreeBSD.html">Linux+FreeBSD mini-HOWTO</link>
        es una buena referencia para las opciones de interoperabilidad entre
        FreeBSD y Linux.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo arranco FreeBSD y Linux usando BootEasy?</para>
      </question>

      <answer>
        <para>Instala el LILO al inicio de la partición de arranque del
        Linux en lugar de hacerlo en el "Master Boot Record". Así
        podrás arrancar el LILO desde BootEasy.</para>

        <para>Si estas usando Windows-95 y Linux, también es recomendable
        hacer esto para simplificar el arranque de Linux en caso de que sea
        necesaria una reinstalación del Windows-95 (ya que no quiere
        convivir con otros sistemas operativos en el mismo Master Boot Record).</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Puede un disco "dedicado" provocar problemas?</para>
      </question>

      <answer>
        <para><anchor xml:id="dedicate"/>El proceso de instalación nos permite
        elegir dos métodos diferentes de particionar un disco. El sistema
        por defecto hace que el disco sea compatible con otros sistemas
        operativos en la misma máquina, usando las tablas de entrada de
        fdisk (llamadas "slices" en FreeBSD). Opcionalmente, podemos instalar un
        boot-selector que nos permite seleccionar el sistema operativo con
        el que queremos arrancar.</para>

        <para>Mientras este es el caso más com&amp;ún para gente
        proveniente del mundo de PC, para la gente proveniente del mundo Unix y
        quienes quieren instalar una máquina para funcionar con FreeBSD y
        solo FreeBSD, es más habitual usar el sistema de reservar todo el
        espacio del disco para un solo sistema operativo.
        Si seleccionas "A)ll FreeBSD" en el editor de fdisk de la utilidad
        sysinstall, y respondes la siguiente pregunta con "No", usarás
        este último sistema. Ten en cuenta que usando este sistema no te
        permitirá la instalación de ningún otro sistema
        operativo o selector de arranque (boot manager).</para>

        <para>Entonces, ?por qué se llama "peligroso"?. Un disco en
        este modo no contiene lo que las utilidades normales de un PC
        considerarían una tabla de partición de archivos válida.
        Dependiendo del diseño de estas aplicaciones, puede que dañen
        el sector de arranque una vez entren en contacto con el disco. Por lo menos una
        BIOS Award usada por máquinas HP Netservers (pero no sólo
        por ellos) es concocida por ignorar los disco duros que no contengan lo
        que el BIOS entiende por una tabla de archivos válida.</para>

        <para>Para volver un disco "peligrosamente dedicado" a formato
        estándar de PC, hay básicamente dos opciones. La primera es,
        escribes suficientes bytes NULL sobre el MBR para hacer que
        las siguientes instalaciones crean que están en un disco sín
        usar. Puedes hacer esto así:</para>

        <para>
        <literallayout>
dd if=/dev/zero of=/dev/rda0 count=15
        </literallayout>
        </para>

        <para>Alternativamente, puedes hacer:</para>

        <para>
        <literallayout>
fdisk /mbr
        </literallayout>
        </para>

        <para>que instalará un nuevo master boot record.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo puedo añadir más espacio de swap?</para>
      </question>

      <answer>
        <para>La mejor manera es incrementar el tamaño de tu partición
        de swap, o usar esta excusa para añadir un otro disco nuevo.</para>

        <para>Añadir swap en discos separados hace las cosas más
        rápidas que simplemente añadir swap en el mismo disco.
        Como ejemplo, si estás compilando código fuente en un
        disco, y el swap está en otro disco, es mucho más
        rápido que si el swap y la compilación se realizaran en el
        mismo disco. Esto es cierto específicamente para discos SCSI.</para>

        <para>Los discos IDE no son capaces de permitir el acceso a ambos discos
        en el mismo canal al mismo tiempo (FreeBSD no soporta el modo 4, ya
        que todas las I/O de discos IDE son "programadas").</para>

        <para>Es realmente muy mala idea instalar el swap sobre NFS a no ser que
        trabajes en una red muy rápida con un muy buen servidor.</para>

        <para>Aquí hay un ejemplo para un archivo de swap de 64Mb
        <filename>/usr/swap0</filename>, piensa que puedes usar el nombre que quieras).</para>

        <para>Asegurate que el kernel está compilado con la línea</para>

        <para>
        <literallayout>
pseudo-device   vn 1   #Vnode driver (turns a file into a device)
        </literallayout>
        </para>

        <para>en tu archivo de configuración. El kernel GENERIC la contiene. </para>

        <para>
        <orderedlist>
          <listitem>
            <para>crea un vn-device
            <literallayout>
cd /dev
sh ./MAKEDEV vn0
            </literallayout>
            </para>
          </listitem>

          <listitem>
            <para>crea un swapfile (<filename>/usr/swap0</filename>)
            <literallayout>
dd if=/dev/zero of=/usr/swap0 bs=1024k count=64
            </literallayout>
            </para>
          </listitem>

          <listitem>
            <para>activa el archivo de swap en <filename>/etc/rc.conf</filename>
            <literallayout>
swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.
            </literallayout>
            </para>
          </listitem>

          <listitem>
            <para>rearranca la máquina.</para>
          </listitem>
        </orderedlist>
        </para>

        <para>Para activar el archivo de swap inmediatamente teclea</para>

        <para>
        <literallayout>
vnconfig -ce /dev/vn0c /usr/swap0 swap
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Tengo problemas para poner en marcha mi impresora.</para>
      </question>

      <answer>
        <para>Por favor, revisa la sección de impresoras del manual. Cubre la
        mayoría de posibles problemas. Pásate por
        <link xlink:href="../../handbook/printing.html">esta sección.</link></para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Mi teclado no coincide con los carácteres de pantalla.</para>
     </question>

     <answer>
        <para>El programa de control de teclado tiene una opción para cargar
        el mapa de teclado. En el directorio <filename>/usr/share/syscons/keymaps</filename>
        hay diferentes archivos de mapas de teclado. Selecciona el que
        corresponde a tu sistema y cárgalo.</para>

        <para>
        <literallayout>
kbdcontrol -l uk.iso
        </literallayout>
        </para>

        <para>Tanto el directorio <filename>/usr/share/syscons/keymaps</filename> como la
        extensión <filename>.kbd</filename> son asumidas por la orden
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?kbdcontrol">kbdcontrol</link>.</para>

        <para>Esto puede ser configurado en <filename>/etc/sysconfig</filename>
        (o <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?rc.conf(5)">rc.conf</link>).
        Mira los comentarios correspondientes en el propio archivo.</para>

        <para>En la versión 2.0.5R y posteriores, todo lo referente a fuentes,
        teclado, etc está en <filename>/usr/share/examples/syscons</filename>.</para>

        <para>Actualmente se soportan los siguientes mapas de teclado:</para>

        <para>
        <itemizedlist>
          <listitem>
            <para>Belgian ISO-8859-1 </para>
          </listitem>

          <listitem>
            <para>Brazilian 275 keyboard Codepage 850 </para>
          </listitem>

          <listitem>
            <para>Brazilian 275 keyboard ISO-8859-1 </para>
          </listitem>

          <listitem>
            <para>Danish Codepage 865 </para>
          </listitem>

          <listitem>
            <para>Danish ISO-8859-1 </para>
          </listitem>

          <listitem>
            <para>French ISO-8859-1 </para>
          </listitem>

          <listitem>
            <para>German Codepage 850 </para>
          </listitem>

          <listitem>
            <para>German ISO-8859-1 </para>
          </listitem>

          <listitem>
            <para>Italian ISO-8859-1 </para>
          </listitem>

          <listitem>
            <para>Japanese 106 </para>
          </listitem>

          <listitem>
            <para>Japanese 106x </para>
          </listitem>

          <listitem>
            <para>Latin American </para>
          </listitem>

          <listitem>
            <para>Norwegian ISO-8859-1 </para>
          </listitem>

          <listitem>
            <para>Polish ISO-8859-2 (programmer's) </para>
          </listitem>

          <listitem>
            <para>Russian Codepage 866 (alternative) </para>
          </listitem>

          <listitem>
            <para>Russian koi8-r (shift) </para>
          </listitem>

          <listitem>
            <para>Russian koi8-r </para>
          </listitem>

          <listitem>
            <para>Spanish ISO-8859-1 </para>
          </listitem>

          <listitem>
            <para>Swedish Codepage 850 </para>
          </listitem>

          <listitem>
            <para>Swedish ISO-8859-1 </para>
          </listitem>

          <listitem>
            <para>Swiss-German ISO-8859-1 </para>
          </listitem>

          <listitem>
            <para>United Kingdom Codepage 850 </para>
          </listitem>

          <listitem>
            <para>United Kingdom ISO-8859-1 </para>
          </listitem>

          <listitem>
            <para>United States of America ISO-8859-1 </para>
          </listitem>

          <listitem>
            <para>United States of America dvorak </para>
          </listitem>

          <listitem>
            <para>United States of America dvorakx </para>
          </listitem>
        </itemizedlist>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Las cuotas de usuario no funcionan correctamente.</para>
      </question>

      <answer>
        <para>
        <orderedlist>
          <listitem>
            <para>No actives las cuotas en '/',</para>
          </listitem>

          <listitem>
            <para>Pon el archivo de cuotas en el sistema de archivos en el que
          se vayan a forzar las cuotas de usuario:

            <literallayout>
FS      QUOTA FILE
/usr    /usr/admin/quotas
/home   /home/admin/quotas
          ...
            </literallayout>
            </para>
          </listitem>
        </orderedlist>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Mi ccd no funciona correctamente</para>
      </question>

      <answer>
        <para>El síntoma es:</para>
        <para>
        <literallayout>
# ccdconfig -C
ccdconfig: ioctl (CCDIOCSET): /dev/ccd0c: Inappropriate file type or format
#
        </literallayout>
        </para>

        <para>Esto actualmente ocurre cuando estás intentando concatenar las
        particiones c'. El driver ccd requiere que la partición sea del
        tipo FS_BSDFFS. Edita la etiqueta del disco (disklabel) que estás
        intentando concatenar y cambia el tipo de partición a '4.2BSD'.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Porqué no puedo editar el disklabel en mi ccd?</para>
      </question>

      <answer>
        <para>El síntoma es:</para>
        <para>
        <literallayout>
# disklabel ccd0
(it prints something sensible here, so let's try to edit it)
# disklabel -e ccd0
(edit, save, quit)
disklabel: ioctl DIOCWDINFO: No disk label on disk;
use "disklabel -r" to install initial label
#
        </literallayout>
        </para>

        <para>Esto es porque el disklabel retornado por el ccd es actualmente
        uno que no corresponde con el real. Puedes resolver este problema
        escribiendo explícitamente:</para>

        <para>
        <literallayout>
# disklabel ccd0 &gt; /tmp/disklabel.tmp
# disklabel -Rr ccd0 /tmp/disklabel.tmp
# disklabel -e ccd0
(ahora funcionara)
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Soporta FreeBSD primitivas IPC System V?</para>
      </question>

      <answer>
        <para>Sí, FreeBSD las soporta. Estas incluyen memoria compartida,
        mensajes y semáforos. Necesitas añadir las siguientes
        líneas en la configuración de tu kernel para activarlas.</para>

        <para>
        <literallayout>
options    SYSVSHM
options    "SHMMAXPGS=64"   # 256Kb of sharable memory
options    SYSVSEM          # enable for semaphores
options    SYSVMSG          # enable for messaging
        </literallayout>
        </para>

        <para>Recompila e instala.</para>

        <para><emphasis remap="bf">NOTA:</emphasis> Quizás necesites incrementar
        SHMMAXPGS a un número como 4096 (16M) si quieres usar GIMP. 256K es
        suficiente para la memoria compartida en X11R6.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question xml:id="uucpmail">
        <para>?Cómo uso sendmail para envio de mail UUCP?</para>
      </question>

      <answer>
        <para>La configuración de sendmail incluida en FreeBSD está
        preparada para sistemas que conectan directamente con Internet. Los
        sistemas que quieran usar UUCP para el envío de mail deben
        utilizar otro archivo de configuración.</para>

        <para>Retocar <filename>/etc/sendmail.cf</filename> manualmente está considerado
        algo para puristas. La versión 8 de sendmail incluye un nuevo
        sistema de configuración llamado
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?m4">m4</link>, en
        el cual la configuración se realiza en un nivel más alto.
        Deberías usar los archivos de configuración situados en</para>

        <para>
        <literallayout>
/usr/src/usr.sbin/sendmail/cf
        </literallayout>
        </para>

        <para>Si no instalaste tu sistema con el código fuente completo, el
        paquete de configuración de sendmail está en una
        distribución aparte. Asumiendo que tienes tu CD-ROM montado, haz:</para>

        <para>
        <literallayout>
cd /usr/src
tar -xvzf /cdrom/dists/src/ssmailcf.aa
        </literallayout>
        </para>

        <para>No te preocupes, solo son unos cientos de kilobytes de tamaño.
        El archivo <acronym>README</acronym> en el directorio
        <emphasis remap="tt">cf</emphasis> puede servir como introducción a
        la configuración del m4.</para>

        <para>Para envío y recepción va UUCP, te aconsejamos usar la
        opción <emphasis>mailertable</emphasis>. Se basa en una base de datos
        que sendmail puede usar como base para tomar las decisiones
        de enrutado del mail.</para>

        <para>Primero tienes que crear tu archivo <filename>.mc</filename>. Estos archivos
        se encuentran en el directorio
        <filename>/usr/src/usr.sbin/sendmail/cf/cf</filename>. Si miras, encontrarás
        algunos ejemplos. Asumiendo que tu archivo se llama <filename>foo.com</filename>,
        todo lo que necesitas hacer para convertirlo en un archivo
        <filename>sendmail.cf</filename> válido es:</para>

        <para>
        <literallayout>
cd /usr/src/usr.sbin/sendmail/cf/cf
make foo.cf
cp foo.cf /etc/sendmail.cf
        </literallayout>
        </para>

        <para>Un archivo típico <filename>.mc</filename> sería algo como:</para>

        <para>
        <literallayout>
          include(`../m4/cf.m4')
          VERSIONID(`Your version number')
          OSTYPE(bsd4.4)

          FEATURE(nodns)
          FEATURE(nocanonify)
          FEATURE(mailertable)

          define(`UUCP_RELAY', your.uucp.relay)
          define(`UUCP_MAX_SIZE', 200000)

          MAILER(local)
          MAILER(smtp)
          MAILER(uucp)

          Cw    your.alias.host.name
          Cw    youruucpnodename.UUCP
        </literallayout>
        </para>

        <para>Las opciones <emphasis>nodns</emphasis> y <emphasis>nocanonify</emphasis> previenen
        del uso del DNS durante el tráfico de correo. La cláusula
        <symbol>UUCP_RELAY</symbol> se necesita por razones imperiosas, no
        preguntes :). Simplemente pon un nombre de máquina de Internet que
        sea capaz de gestionar pseudo-dominios .UUCP; más sencillo,
        entrarás el mail relay de tu ISP.</para>

        <para>Una vez hayas hecho esto, necesitas el archivo llamado
        <filename>/etc/mailtertable</filename>. Un ejemplo típico sería:</para>

        <para>
        <literallayout>
          #
          # makemap hash /etc/mailertable.db &lt; /etc/mailertable
          #
          horus.interface-business.de   uucp-dom:horus
          .interface-business.de        uucp-dom:if-bus
          interface-business.de         uucp-dom:if-bus
          .heep.sax.de                  smtp8:%1
          horus.UUCP                    uucp-dom:horus
          if-bus.UUCP                   uucp-dom:if-bus
          .                             uucp-dom:sax
        </literallayout>
        </para>

        <para>Como puedes ver, esto es parte de un archivo real. Las tres
        primeras líneas manejan casos especiales donde el correo dirigido
        a un dominio no debe ser enviado a través de la ruta por defecto,
        si no a través de un UUCP vecino para acortar el path de
        envío.  La siguiente línea gestiona el mail del dominio
        local para que sea enviado vía SMTP. Finalmente, los vecinos UUCP
        son anotados en la parte .UUCP pseudo-domains, para poder sobreescribir
        las reglas por defecto. La última línea es siempre un
        punto, que indica el mail gateway hacia el resto del mundo. Todos los
        nombres de nodos detrás de <emphasis remap="tt">uucp-dom:</emphasis>
        deben ser vecinos válidos UUCP.</para>

        <para>Como recordatorio de que este archivo debe ser convertido a
        una base de datos DBM antes de ser usada, la línea de comandos
        para realizar esta operación esta puesta como un comentario al
        inicio del archivo. Siempre tienes que ejecutar este comando
        cada vez que realices algún cambio en tu mailtertable.</para>

        <para>Si no tienes la seguridad de que una ruta de correo vaya a
        funcionar correctamente, recuerda la opción <option>-bt</option> de
        sendmail. Esta opción arranca el sendmail en <emphasis>modo test</emphasis>;
        simplemente entra 0, seguido por la dirección de mail sobre la que
        quieres testear la ruta. La última línea te indica el agente
        interno, el host de destino y la dirección (posiblemente
        traducido). Sal de este modo tecleando Control-D.</para>

        <para>
        <literallayout>
          j@uriah 191% sendmail -bt
          ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
          Enter &lt;ruleset&gt; &lt;address&gt;
          &gt; 0 foo@interface-business.de
          rewrite: ruleset  0   input: foo @ interface-business . de
          ...
          rewrite: ruleset  0 returns: $# uucp-dom $@ if-bus $: foo \
          &lt; @ interface-business . de &gt;
          &gt; ^D
          j@uriah 192%
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question xml:id="ispmail">
        <para>?Cómo configuro el correo para conexiones NO
        permanentes a Internet?</para>
      </question>

      <answer>
        <para>Si tienes una dirección IP fija en la conexión, no
        necesitarás ajustar nada de lo que ya viene por defecto.
        Configura tu hostname como el nombre asignado a tu IP de Internet y
        sendmail hará el resto.</para>

        <para>Si tienes direcciones IP asignadas dinamicamente y usas una
        conexión <emphasis remap="bf">ppp</emphasis> a Internet, probablemente
        tendrás un buzón en el servidor de correo de tu proveedor.
        Supongamos que el dominio de tu proveedor es <filename>myisp.com</filename>,
        y tu nombre de usuario es <emphasis remap="tt">user</emphasis>. Supongamos
        también que has llamado a tu máquina <filename>bsd.home</filename>
        y que tu proveedor te ha indicado que uses la máaquina
        <filename>relay.myISP.com</filename> como mail realy (gateway).</para>

        <para>Para poder recoger el correo de tu buzón necesitarás
        instalar un agente de recogida de correo. <emphasis remap="bf">Fetchmail</emphasis>
        es una buena opción ya que soporta diferentes protocolos. Normalmente se usa
        POP3.  Puedes recoger automaticamente tu correo al realizar la
        conexión añadiendo la siguiente línea en el archivo
        <filename>/etc+ppp/ppp.linkup</filename>:</para>

        <para>
        <literallayout>
            MYADDR:
            !bg su user -c fetchmail
        </literallayout>
        </para>

        <para>Asumimos que tienes una cuenta para <emphasis remap="tt">user</emphasis>
        en <filename>bsd.home</filename>. En el home directory de
        <emphasis remap="tt">user</emphasis> en <filename>bsd.home</filename>, crea el
        archivo <filename>.fetchmailrc</filename>:</para>

        <para>
        <literallayout>
          poll myISP.com protocol pop3 fetchall pass MySecret;
        </literallayout>
        </para>

        <para>No hace falta decir que este archivo no debe ser "leible" por nadie
        excepto <emphasis remap="tt">user</emphasis> ya que contiene el password
        <emphasis remap="tt">MySecret</emphasis>.</para>

        <para>Para enviar el correo con la cabecera <emphasis remap="bf">from:</emphasis>
        correcta, debes decirle al sendmail que use <email>user@myISP.com</email> en lugar de
        <email>user@bsd.home</email>. También deberías decirle al sendmail
        que envie todo el correo saliente a traves de <filename>relay.myISP.com</filename>, para
        una transmisión mucho más rápida.</para>

        <para>El siguiente archivo <filename>.mc</filename> debe ser suficiente:</para>

        <para>
        <literallayout>
          VERSIONID(`bsd.home.mc version 1.0')
          OSTYPE(bsd4.4)dnl
          FEATURE(nouucp)dnl
          MAILER(local)dnl
          MAILER(smtp)dnl
          Cwlocalhost
          Cwbsd.home
          CwmyISP.com
          MASQUERADE_AS(`myISP.com')dnl
          FEATURE(allmasquerade)dnl
          FEATURE(masquerade_envelope)dnl
          FEATURE(nocanonify)dnl
          FEATURE(nodns)dnl
          define(SMART_HOST, `relay.myISP.com')
          DmmyISP.com
          define(`confDOMAIN_NAME',`myISP.com')dnl
          define(`confDELIVERY_MODE',`deferred')dnl
       </literallayout>
       </para>

        <para>Mira en la sección anterior para los detalles de como convertir
        este archivo <filename>.mc</filename> en un <filename>sendmail.cf</filename>.
        No te olvides de rearrancar sendmail después de cada actualización del
        archivo sendmail.cf.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Olvidé el password de Root!!</para>
      </question>

      <answer>
        <para>Tranquilo!!!. Simplemenre rearranca tu sistema, teclea -s en el
        prompt de arranque para entrar en modo monousuario. En la pregunta
        sobre el shell a usar, pulsa ENTER. Aparecerá un prompt #. Teclea
        <command>mount -u /</command> para remontar tu sistema de archivos en modo
        de lectura/escritura y a continuación teclea <command>mount -a</command> para
        montar todos los sistemas de archivos. Ejecura <emphasis remap="tt">passwd root</emphasis>
        para cambiar el password de root. Teclea <emphasis remap="tt">exit</emphasis> para continuar
        normalmente con el arranque.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo mantengo el control sobre Control-Alt-Delete?</para>
      </question>

      <answer>
        <para>Edita el mapa de teclado que estás usando para la
        consola y reemplaza las palabras <emphasis remap="tt">boot</emphasis> por
        <emphasis remap="tt">nop</emphasis>. El mapa de teclado por defecto es
        <filename>/usr/share/syscons/keymaps/us.iso.kbd</filename>. Por supuesto si
        usas otro mapa de teclado adecuado a tu país, tendrías que
        editarlo.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo reformateo archivos de texto DOS a UNIX?</para>
      </question>

      <answer>
        <para>Simplemente usando este comando de perl:</para>

        <para>
        <literallayout>
          perl -i.bak -npe 's/\r\n/\n/g' file ...
        </literallayout>
        </para>

        <para>file es el archivo a procesar. La modificación se hace en el
        propio archivo dejando el original grabado con extensión .bak.</para>

        <para>Alternativamente puedes usar el comando
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?tr">tr(1)</link></para>

        <para>
        <literallayout>tr -d '\r' &lt; dos-text-file &gt; unix-file</literallayout>
        </para>

        <para>dos-text-file es el archivo que contiene el texto DOS mientras que
        unix-file contendrá la salida convertida. Este sistema puede
        ser más rápido que usar perl.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo puedo hace "kill" de procesos por nombre?</para>
      </question>

      <answer>
        <para>Usa <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?killall">killall(1)</link>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Porque el su no me dejar ser root al no estar en el ACL?</para>
      </question>

      <answer>
        <para>El error proviene de sistema del autentificación distribuida
        Kerberos.  El problema no es fatal pero si molesto. Puedes ejecutar el
        comando su con la opcion -K, o desinstalar Kerberos como se describe en
        la siguiente sección.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo desinstalo Kerberos?</para>
      </question>

      <answer>
        <para>Para eliminar Kerberos del sistema, reinstala la distribución
        bin de la release que estés usando. Si tienes el CDROM, puedes
        montar el cd (asumiremos que esta en /cdrom) y ejecutar:</para>

        <para>
        <literallayout>
          cd /cdrom/bin
          ./install.sh
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo añado pseudoterminales a mi sistema?</para>
      </question>

      <answer>
        <para>Si tienes muchos usuarios de telnet, ssh, X, o de consola,
        probablemente terminarás desbordando el número de
        pseudoterminales del sistema. Aquí tienes como añadir
        más:</para>

        <para>
        <orderedlist>
          <listitem>
            <para>Compila e instala un nuevo kernel com la línea

            <literallayout>
              pseudo-device pty 256
            </literallayout>
            </para>
            <para>en el archivo de configuración.</para>
            <para/>
          </listitem>

          <listitem>
            <para>Ejecuta el comando

            <literallayout>
              # cd /dev
              # ./MAKEDEV pty{1,2,3,4,5,6,7}
            </literallayout>
            </para>
            <para>para crear 256 nodos de dispositivo para los nuevos terminales.</para>
            <para/>
          </listitem>

          <listitem>
            <para>Edita el archivo <filename>/etc/ttys</filename> y añade una
            línea para cada uno de los 256 terminales. Estas líneas deben
            seguir la estructura de las entradas existentes, algo como esto:

            <literallayout>
              ttyqc none network
            </literallayout>
            </para>
            <para>El órden de la designación de letras es
            <emphasis remap="tt">tty[pqrsPQRS][0-9a-v]</emphasis>, usando una
            expresión regular.</para>
            <para/>
          </listitem>

          <listitem>
            <para>Rearranca el sistema con el nuevo kernel, y lo tendrás listo
            para funcionar.</para>
          </listitem>
        </orderedlist>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo puedo releer el archivo /etc/rc.conf y relanzar /etc/rc
        sin tener que hacer un reboot?</para>
      </question>

      <answer>
        <para>Entra en modo monousuario y a continuación vuelve a modo
        multiusuario.</para>

        <para>En la consola haz:
        <literallayout>
          # shutdown now
          (Nota: sin -r o -h)

          # return
          # exit
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Qué es un sandbox?</para>
      </question>

      <answer>
        <para>Sandbox es un término de seguridad. Puede significar dos
        cosas:</para>

        <para>
        <itemizedlist>
          <listitem>
            <para/>

            <para>Un proceso que es situado en el interior de una serie de muros
            virtuales diseñados como prevención e imposibilitar
            el acceso al sistema principal en caso de que alguien comprometa
            la seguridad de ese proceso.</para>

            <para/>

            <para>Se dice que el proceso es capaz de "jugar" entre los muros.
            Esto significa que se supone que nada de lo que haga el proceso
            referente a la ejecución de código, puede ser capaz
            de romper los muros, así no es necesario  hacer
            auditorías detalladas de su código para poder conocer
            todo lo referente a los riesgos de seguridad del proceso.</para>

            <para/>

            <para>Los muros pueden, por ejemplo, un userid. Esta es la
            definición usada en las páginas man de seguridad y del
            programa named.</para>

            <para/>

            <para>Veamos como ejemplo el servicio 'ntalk' (consultar /etc/inetd.conf).
            Este servicio solía ejecutarse con el userid de root. Ahora se
            ejecuta con el userid tty. El usuario tty esta diseñado para ser
            usado como usuario sandbox, dificultando así la tarea de un
            intruso que haya conseguido penetrar en el sistema a través del
            servicio ntalk. De esta manera, el intruso solo puede afectar a los
            servicios, programas o procesos propiedad del usuario tty.</para>
          </listitem>

          <listitem>
            <para/>

            <para>Un proceso que se ha situado en el interior de una simulación
            de la máquina. Esto es más hard-core. Básicamente,
            significa que alguien que sea capaz de penetrar en el proceso,
            creerá que ha penetrado en el sistema principal, pero de hecho,
            ha penetrado en una simulación de esa máquina y no puede
            modificar ningún dato real.</para>

            <para/>

            <para>El sistema más común de conseguir esto es crear un
            entorno simulado en un subdirectorio y ejecutar los procesos en ese
            subdirectorio mediante chroot (la raiz "/" para ese proceso es este
            directorio, no la raiz "/" real del sistema).</para>

            <para/>

            <para>Otro sistema habitual es montar un sistema de archivos de solo
            lectura y a continuació,n crear un nivel de sistema de archivos
            por encima del anterior que dé al proceso la sensación
            de encontrarse en un sistema de archivos de lectura/escritura. El
            proceso creerá que es capaz de escribir esos archivos, pero
            sólo el proceso ve los efectos; otros procesos del sistema
            no ven absolutamente nada.</para>

            <para/>

            <para>Se intenta crear este tipo de sandbox totalmente transparentes para
            que el usuario (o intruso) no se de cuenta que está en él.</para>
          </listitem>
        </itemizedlist>
        </para>

        <para>UNIX implementa dos tipos de sandboxes. Uno es a nivel de procesos,
        y el otro es a nivel de usuarios (userid).</para>

        <para>Cada proceso UNIX es totalmente independiente de cualquier otro proceso
        UNIX. Un proceso no puede modificar el espacio de direcciones de otro. Es
        diferente a los sistemas Windows en los que un proceso puede sobreescribir
        facilmente el espacio de direcciones de otro proceso, probocando una caida
        de la máquina.</para>

        <para>Un proceso UNIX es propiedad de un userid determinado. Si el userid no
        es el usuario root, éste solo podrá acceder a los procesos
        de su propiedad, evitando la intrusión en procesos ajenos. El
        userid también se usa como sistema de protección para datos
        grabados en disco.</para>
      </answer>
    </qandaentry>
  </qandaset>
</chapter>

<chapter xml:id="x">
  <title>El sistema X Windows y las consolas virtuales</title>

  <qandaset>
    <qandaentry>
      <question>
        <para>Quiero ejecutar las X, ?cómo lo hago?</para>
      </question>

      <answer>
        <para>La manera más fácil es, simplemente, especificar que
        quieres usar las X durante el proceso de instalación.</para>

        <para>Entonces, lee y sigue la documentación de la herramienta
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xf86config">xf86config</link>,
        la cual te ayuda a configurar el sistema XFree86 sobre
        las características propias de tu sistema (tarjeta de vídeo
        , ratón, etc).</para>

        <para>Quizás te interesaría investigar y probar el servidor
        Xaccel, disponible a un precio muy razonable. Mira en la sección
        <link linkend="xig">Xi Graphics</link>  o
        <link linkend="metrox">Metro Link</link> para más detalles.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question xml:id="x-and-moused">
        <para>?Porqué no funciona mi ratón con las X?</para>
      </question>

      <answer>
        <para>Si estás usando syscons (el driver de consola por
        defecto), puedes configurar FreeBSD para soportar un ratón en cada
        consola virtual. Para evitar conflictos con las X, syscons soporta
        un dispositivo virtual llamado <filename>/dev/sysmouse</filename>. Todos los
        eventos recibidos desde el mouse real son escritos en el dispositivo sysmouse,
        usando el protocolo MouseSystems. Si quieres usar el ratón en una o
        más consolas virtuales <emphasis remap="bf">y</emphasis> usar las X,
        te recomendamos la siguiente configuración:</para>

        <para>
        <literallayout>
          /etc/rc.conf:
            moused_type=ps/2          # or whatever your actual type is
            moused_port=/dev/psm0     # or whatever your real port is
            moused_flags=

          /etc/XF86Config
            Section Pointer
                Protocol "MouseSystems"
                Device   "/dev/sysmouse"
                 .....
        </literallayout>
        </para>

        <para>Hay gente que prefiere usar <filename>/dev/mouse</filename> bajo X. Para que
        esto funcione, <filename>/dev/mouse</filename> debe estar lincado a
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?sysmouse">/dev/sysmouse</link>:</para>

        <para>
        <literallayout>
          # cd /dev
          # rm -f mouse
          # ln -s sysmouse mouse
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Los menus de X Window  y cajas de diálogo no funcionan bien.</para>
      </question>

      <answer>
        <para>Intenta desactivar la tecla Num Lock.</para>

        <para>Si tu tecla Num Lock está activada por defecto al arrancar el
        sistema, deberías añadir la siguiente línea en la
        sección <emphasis remap="tt">Keyboard</emphasis> del archivo
        <emphasis remap="tt">XF86Config</emphasis>.</para>

        <para>
        <literallayout>
          # Let the server do the NumLock processing.  This should only be
          # required when using pre-R6 clients
              ServerNumLock
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Qué es una consola virtual y como creo más?</para>
      </question>

      <answer>
        <para>Las consolas virtuales te permiten tener sesiones
        simultáneas en la misma máquina sin necesidad de tener
        montajes complicados como una red o ejecución de X.</para>

        <para>Cuando el sistema arranca, mostrará el prompt de login en el
        monitor una vez finalizado el mismo. Puedes entonces teclear
        tu login y password y empezar a trabajar (o jugar), en la primera
        consola virtual.</para>

        <para>En algun momento, es probablemente querras iniciar otra sesion
        , por ejemplo, para mirar la documentación de un programa que
        estás ejecutando, o para leer el correo mientras esperas que
        termine una sesión ftp que tienes establecida. Solo haz Alt-F2 y
        encontrarás un prompt un prompt de login esperandote en la segunda
        "consola virtual". Cuando quieras volver a la sesión
        original, sólo tienes que pulsar Alt-F1.</para>

        <para>La instalación por defecto de FreeBSD tiene tres consolas
        virtuales activadas, y Alt-F1, Alt-F2 y Alt-F3 cambian entre ellas.</para>

        <para>Para activar más consolas virtuales, edita
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ttys">/etc/ttys</link>
        y añade tantas entradas como consolas virtuales quieras a
        partir de <emphasis remap="tt">ttyv4</emphasis>, después del
        comentario "Virtual Terminals":</para>

        <para>
        <literallayout>
        # Edit the existing entry for ttyv3 in /etc/ttys and change
        # "off" to "on".
        ttyv3   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv4   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv5   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv6   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv7   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv8   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv9   "/usr/libexec/getty Pc"         cons25  on secure
        ttyva   "/usr/libexec/getty Pc"         cons25  on secure
        ttyvb   "/usr/libexec/getty Pc"         cons25  on secure
        </literallayout>
        </para>

        <para>Utiliza tantas consolas como quieras o necesites. Cuantas
        más consolas tengas, más recursos utilizas; esto
        puede ser importante si tienes 8MB de RAM o menos. También te
        puede interesar cambiar el modo <emphasis remap="tt">secure</emphasis> a
        <emphasis remap="tt">insecure</emphasis>.</para>

        <para><emphasis remap="bf">NOTA IMPORTANTE</emphasis> si quieres usar un
        servidor X <acronym>DEBES</acronym> dejar, al menos, un terminal virtual
        sin usar (o desactivado).</para>

        <para>La manera más fácil de desactivar una consola
        es "apagarla". Por ejemplo, para desactivar el terminal 12, cambia esto:</para>

        <para>
        <literallayout>
          ttyvb   "/usr/libexec/getty Pc"         cons25  on secure
        </literallayout>
        </para>

        <para>por esto:</para>

        <para>
        <literallayout>
          ttyvb   "/usr/libexec/getty Pc"         cons25  off secure
        </literallayout>
        </para>

        <para>Si tu teclado solo tiene 10 teclas de función, tendras que
        acabar con:</para>

        <para>
        <literallayout>
          ttyv9   "/usr/libexec/getty Pc"         cons25  off secure
          ttyva   "/usr/libexec/getty Pc"         cons25  off secure
          ttyvb   "/usr/libexec/getty Pc"         cons25  off secure
        </literallayout>
        </para>

        <para>(También puedes, simplemente, borrar estas líneas.)</para>

        <para>Una vez has editado el archivo
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ttys">/etc/ttys</link>,
        el siguiente paso es asegurarte de que tienes suficientes
        dispositivos de terminales virtuales. La manera más fácil
        de hacerlo es:</para>

        <para>
        <literallayout>
          # cd /dev
          # ./MAKEDEV vty12                 # For 12 devices
        </literallayout>
        </para>

        <para>A continuación, la manera más fácil de activar
        las consolas virtuales es rearrancar el sistema. Si, realmente no
        quieres rearrancarlo, puedes para el servidor de X Window y ejecutar
        (como <emphasis remap="tt">root</emphasis>):</para>

        <para>
        <literallayout>
          kill -HUP 1
        </literallayout>
        </para>

        <para>Es imperativo que pares el servidor de X Window si está
        funcionando, antes de ejecutar este comando. Si no lo haces,
        parecerá que tu sistema está parado/colgado después
        de ejecutar el comando kill.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo accedo a las consolas virtuales desde X?</para>
      </question>

      <answer>
        <para>Si la consola está actualmente mostrando X Window,
        puedes usar Ctrl-Alt-F1, etc, para cambiar entre las consolas
        virtuales. Ten en cuenta que una vez pases de una consola X Window
        a un terminal virtual, solo tienes que usar la tecla Alf- para volver a
        conmutar entre terminales virtuales o volver a las X. No necesitas pulsar
        la tecla Ctrl. Si usas la tecla Ctrl para volver a las X en alguna
        de las releases antiguas, puedes encontrarte que la consola de
        texto está bloqueada. Pulsa la tecla Ctrl de nuevo para
        desbloquearla.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo arranco XDM desde el archivo
        <filename>/etc/ttys</filename>?</para>
      </question>

      <answer>
        <para>Existen dos escuelas sobre como arrancar el
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xdm">xdm</link>
        . Una escuela arranca el xdm desde el archivo
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ttys">/etc/ttys</link>
        usando el ejemplo dado, mientras que la otra simplemente arranca el xdm
        desde el archivo
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?rc">rc.local</link> o
        desde un script <filename>X.sh</filename> en
        <filename>/usr/local/etc/rc.d</filename>.
        Ambos métodos son igualmente válidos, y uno puede funcionar
        en situaciones que el otro no. En ambos casos el resultado es el mismo:
        el sistema X Window lanzará un prompt de login gráfico.</para>

        <para>El método ttys tiene la ventaja de documentar en que vty se
        lanzarán las X pasando la responsabilidad de rearrancar el
        servidor X al hacer el logout al proceso init. El método
        rc.local hace más fácil terminar con el proceso xdm
        en caso de problemas con el servidor X.</para>

        <para>Si arrancamos desde rc.local, <emphasis remap="tt">xdm</emphasis> debe ser
        arrancado sin argumentos (como un daemon). xdm debe arrancar DESPUES del proceso
        getty, o ambos entrarán en conflicto bloqueando la
        consola. La mejor manera de evitar este problema es tener un
        script que retrase el arranque de xdm durante 10 segundos.</para>

        <para>Una versión previa de esta FAQ decía que debías
        añadir el <emphasis remap="tt">terminal virtual</emphasis> usado por las
        X al archivo <filename>/usr/X11R6/lib/X11/xdm/Xservers</filename>. Esto no
        es necesario: las X
        usarán el primer <emphasis remap="tt">terminal virtual</emphasis> que
        encuentre libre.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Cuando arranco xconsole obtengo "Couldn't open console".</para>
      </question>

      <answer>
        <para>Si arrancas las
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=X">X</link>
        con
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=startx">startx</link>,
        los permisos en /dev/console no serán cambiados, resultando en cosas
        como que
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xterm">xterm -C</link>
        y <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xconsole">xconsole</link>
        no funcionen.</para>

        <para>Esto se debe a la manera en que son fijados los permisos de la
        consola. En un sistema multiusuario, podemos no querer que
        cualquier usuario pueda escribir en la consola de sistema. Para
        usuarios que realizan logins directamente desde una máquina con
        un VTY, existe el archivo
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?fbtab">fbtab</link>
        para resolver estos problemas.</para>

        <para>Asegúrate de que existe al menos una línea como esta
        sin comentar:</para>

        <para>
        <literallayout>
          /dev/ttyv0 0600 /dev/console
        </literallayout>
        </para>

        <para>Está en
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?fbtab(5)">/etc/fbtab</link>
        y asegurará que cualquiera que realice un login en
        <filename>/dev/ttyv0</filename> será el propietario de la
        consola.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Mi ratón PS/2 no funciona bien en X.</para>
      </question>

      <answer>
        <para>Tu ratón y el driver de ratón quizás estén
        fuera de sincronización.</para>

        <para>En versiones 2.2.5 y anteriores, conmutando entre sesiones X y
        sesiones de terminales virtuales, podía provocar una
        desincronización. Si el problema ocurre muy amenudo,
        deberías añadir la siguiente opción en el archivo
        de configuración de tu kernel y recompilarlo.</para>

        <para>
        <literallayout>
          options PSM_CHECKSYNC
        </literallayout>
        </para>

        <para>Mira la sección <link linkend="make-kernel">creando un kernel</link>
        si no tienes experiencia en compilar nuevos kernels.</para>

        <para>En versiones 2.2.6 y posteriores, el chequeo de sincronización
        es realizado de otra manera, y es estándar en el driver de ratón
        PS/2. Aun así, en casos extraños puedes llegar a ver
        mensajes de error de sincronización como este:</para>

        <para>
        <literallayout>
          psmintr: out of sync (xxxx != yyyy)
        </literallayout>
        </para>

        <para>y parecer que tu ratón no funciona adecuadamente.</para>

        <para>Si esto ocurre, desactiva el código de chequeo de
        sincronización poniendo los flags del driver PS/2 a 0x100. Entra
        en <emphasis>UserConfig</emphasis> poniendo la opción <option>-c</option>
        en el prompt de arranque:</para>

        <para>
        <literallayout>
          boot: -c
        </literallayout>
        </para>

        <para>Entonces, en la línea de comando de <emphasis>UserConfig</emphasis>,
        teclea:</para>

        <para>
        <literallayout>
          UserConfig&gt; flags psm0 0x100
          UserConfig&gt; quit
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Mi ratón PS/2 de MouseSystems no funciona.</para>
      </question>

      <answer>
        <para>Hemos recibido reportes de que algunos modelos de ratones PS/2 de
        MouseSystems solo trabajan si están configurados en modo "alta
        resolución".</para>

        <para>Desafortunadamente no hay solución para versiones 2.0.x y 2.1.x.
        En versiones 2.2.x, aplica el siguiente parche en
        <filename>/sys/i386/isa/psm.c</filename> y compila un nuevo kernel.</para>

        <para>
        <literallayout>
diff -u psm.c.orig psm.c
@@ -766,6 +766,8 @@
     if (verbose &gt;= 2)
 	log(LOG_DEBUG, "psm%d: SET_DEFAULTS return code:%04x\n",
 	    unit, i);
+    set_mouse_resolution(sc-&gt;kbdc, PSMD_RES_HIGH);
+
 #if 0
     set_mouse_scaling(sc-&gt;kbdc); 	/* 1:1 scaling */
     set_mouse_mode(sc-&gt;kbdc);		/* stream mode */
        </literallayout>
        </para>

        <para>En versiones 2.2.6 o posteriores, especifica el flag 0x04 al
        driver PS/2 para poner el ratón en modo de alta resolución.
        Entra en <emphasis>UserConfig</emphasis>:</para>

        <para>
        <literallayout>
          boot: -c
        </literallayout>
        </para>

        <para>y en la línea de comandos teclea:</para>

        <para>
        <literallayout>
          UserConfig&gt; flags psm0 0x04
          UserConfig&gt; quit
        </literallayout>
        </para>

        <para>Mira en la sección anterior para posibles causas de problemas
        con los ratones.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Cuando compilo una aplicación X. <emphasis remap="tt">imake</emphasis>
        no puede encontrar el archivo <filename>imake.tmpl</filename>. ?Dónde
        está?</para>
      </question>

      <answer>
        <para>Imake.tmpl es parte del package Imake, una aplicación
        estándar de compilación de X. Tanto Imake como headers y otros
        archivos necesarios para compilar aplicaciones X están en la
        distribución de programación X. Puedes instalarla desde
        el sysinstall o manualmente desde los archivos de la distribución
        X.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo invierto los botones del ratón?</para>
      </question>

      <answer>
        <para>Ejecuta el comando <literal> xmodmap -e "pointer = 3 2 1"</literal> desde el
        archivo .xinitrc o .xsession.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo instalo un "splash screen" y donde los consigo?</para>
      </question>

      <answer>
        <para>Justo antes de la publicación de FreeBSD 3.1 se añadió
        una nueva característica que permite mostrar "splash screens" durante los
        mensajes de arranque del sistema. Los "splash screen" deben ser un bitmap de
        256 colores (<filename>*.BMP</filename>) o ZSoft PCX (<filename>*.PCX</filename>).
        Además, deben tener una resolución de 320x200 o inferior para poder
        trabajar en controladoras VGA estándares. Si se compila el soporte VESA
        en el kernel, se pueden usar bitmaps de hasta 1024x768. Recordar que el soporte
        de VESA requiere que la opción <emphasis remap="tt">VM86</emphasis> sea
        compilada en el kernel. El soporte actual de VESA puede ser compilado
        directamente en el kernel con la opción de configuración
        <acronym>VESA</acronym> o cargando el módulo kld VESA durante el arranque.</para>

        <para>Para usar un "splash screen" necesitas modificar los archivos de
        inicio que controlan el proceso de arranque de FreeBSD. Estos archivos cambiaron
        con FreeBSD 3.2, así que ahora existen dos maneras de cargar un
        "splash screen":</para>

        <para>
        <itemizedlist>
          <listitem>
            <para>FreeBSD 3.1</para>

            <para>El primer paso es encontrar una versión bitmap de tu "splash
            screen". La release 3.1 sólo soporta bitmaps de Windows. Una
            vez hayas elegido tu "splash screen" copiala en
            <filename>/boot/splash.bmp</filename>. A continuación necesitas tener
            un archivo <filename>/boot/loader.rc</filename> que contenga las siguientes
            líneas:</para>

            <para>
            <literallayout>
              load kernel
              load -t splash_image_data /boot/splash.bmp
              load splash_bmp
              autoboot
            </literallayout>
            </para>
          </listitem>

          <listitem>
            <para>FreeBSD 3.2+</para>

            <para>Además de soportar los "splash screens" en formato PCX,
            FreeBSD 3.2 incluye un mejor sistema de configuración
            del proceso de arranque. Si quieres, puedes usar el método
            señalado para FreeBSD 3.1. Si lo haces, y quieres usar PCX,
            reemplaza <symbol>splash_bmp</symbol> con <symbol>splash_pcx</symbol>. Si por el
            contrario quieres usar la nueva configuración de arranque,
            necesitas crear un archivo <filename>/boot/loader.rc</filename> que contenga
            las siguientes líneas:</para>

            <para>
            <literallayout>
              include /boot/loader.4th
              start
            </literallayout>
            </para>

            <para/>

            <para>y otro archivo <filename>/boot/loader.conf</filename> que contenga lo
            siguiente:</para>

            <para>
            <literallayout>
              splash_bmp_load="YES"
             bitmap_load="YES"
            </literallayout>
            </para>

            <para/>

            <para>Esto asume que estás usando <filename>/boot/splash.bmp</filename>
            como tu "splash screen". Si quieres usar un archivo PCX,
            copialo a <filename>/boot/splash.pcx</filename>, crea un archivo
            <filename>/boot/loader.rc</filename> como se ha indicado anteriormente, y
            crea un <filename>/boot/loader.conf</filename> que contenga:</para>

            <para>
            <literallayout>
              splash_pcx_load="YES"
              bitmap_load="YES"
              bitmap_name="/boot/splash.pcx"
            </literallayout>
            </para>
          </listitem>
        </itemizedlist>
      </para>

      <para>Ahora todo lo que necesitas es un "splash screen". Puedes navegar
      por una inmejorable galería en
      <link xlink:href="http://www.cslab.vt.edu/~jobaldwi/splash/">http://www.cslab.vt.edu/~jobaldwi/splash/</link>.</para>
      </answer>
    </qandaentry>
  </qandaset>
</chapter>

<chapter xml:id="networking">
<title>Networking</title>

  <qandaset>
    <qandaentry>
      <question>
        <para>?Dónde puedo encontrar información sobre
        "diskless booting"?</para>
      </question>

      <answer>
        <para>"Diskless booting" significa que una máquina FreeBSD sea
        arrancada sobre una red, y lea los archivos necesarios de un servidor y no
        desde su disco duro. Para más detalles, por favor, lee la
        sección
        <link xlink:href="../../handbook/diskless.html">diskless booting del manual</link></para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Puede una máquina FreeBSD ser usada como router dedicado?</para>
      </question>

      <answer>
        <para>Los estándares de Internet y las buenas prácticas de
        ingeniería nos prohiben proveer el forward de paquetes en la
        distribución estándar. Aun así, puedes activar esta
        opción cambiando la siguiente variable a <acronym>YES</acronym> en el archivo
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?rc.conf">rc.conf</link>:</para>

        <para>
        <literallayout>
          gateway_enable=YES          # Set to YES if this host will be a gateway
        </literallayout>
        </para>

        <para>Esta opción pondrá la variable
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?sysctl">sysctl</link>
        <filename>net.inet.ip.forwarding</filename> a <emphasis remap="tt">1</emphasis>.</para>

        <para>En muchos casos también necesitarás ejecutar un proceso
        de rutado para indicar la existencia en la red de tu router; FreeBSD
        incluye el daemon estándar de rutado BSD
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?routed">routed</link>,
        aunque en situaciones más complejas quizás quieras usar
        <emphasis>GaTeD</emphasis> disponible en
        <link xlink:href="http://www.gated.org/">http://www.gated.org/</link></para>

        <para>Es nuestro deber advertirte que estando FreeBSD configurado de esta
        manera, no cumple completamente con todos los estandares de routers
        de Internet, pero es suficiente para uso ordinario.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Puedo conectar mi Win95 con Internet a través de
        FreeBSD?</para>
      </question>

      <answer>
        <para>Típicamente, la gente que pregunta esto tiene dos pc's en casa,
        uno con FreeBSD y otro con Win95; la idea es usar FreeBSD para conectar
        a Internet y luego ser capaz de acceder a Internet desde el
        computador con Windows 95. Este es realmente un caso especial de la
        pregunta anterior.</para>

        <para>Hay un útil documento disponible que explica como configurar
        FreeBSD como un
        <link xlink:href="http://www.ssimicro.com/~jeremyc/ppp.html">Router PPP</link></para>

        <para><emphasis remap="bf">NOTA:</emphasis> Esto requiere, al menos, tener
        dos direcciones IP fijas disponibles, y posiblemente tres o más,
        dependiendo del número de máquinas que quieras conectar.
        Como alternativa, si no tienes una dirección IP fija, puedes usar
        una de las subredes privadas e instalar un proxy como
        <link xlink:href="http://squid.nlanr.net/Squid/">SQUID</link>
        y <link xlink:href="http://www.tis.com/">The TIS firewall toolkit</link>
        en tu FreeBSD.</para>

        <para>Mira también la sección <link linkend="direct-at">natd</link>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Por que falla la compilación del último BIND del ISC?</para>
      </question>

      <answer>
        <para>Hay un conflicto entre el archivo <filename>cdefs.h</filename> incluido en la
        distribución de BIND y el distribuido con FreeBSD. Solo tienes que
        borrar <filename>compat/include/sys/cdefs.h</filename>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Soporta FreeBSD SLIP y PPP?</para>
      </question>

      <answer>
        <para>Sí. Mira las paginas man de
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?slattach">slattach</link>,
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?sliplogin">sliplogin</link>,
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?pppd">pppd</link> y
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ppp">ppp</link>.
        <emphasis remap="tt">pppd</emphasis> y <emphasis remap="tt">ppp</emphasis> soportan
        conexiones entrantes y salientes.
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?sliplogin">Sliplogin</link>
        trabaja exclusivamente con conexiones entrantes y
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?slattach">slattach</link> con
        conexiones salientes.</para>

        <para>Estos programas son descritos en las siguientes secciones del
        <link xlink:href="../../handbook/index.html">manual</link>:</para>

        <para>
        <itemizedlist>
          <listitem>
            <para>
            <link xlink:href="../../handbook/slips.html">Handbook entry on SLIP (server side)</link>
            </para>
          </listitem>

          <listitem>
            <para>
            <link xlink:href="../../handbook/slipc.html">Handbook entry on SLIP (client side)</link>
            </para>
          </listitem>

          <listitem>
            <para>
            <link xlink:href="../../handbook/ppp.html">Handbook entry on PPP (kernel version)</link>
            </para>
          </listitem>

          <listitem>
            <para>
            <link xlink:href="../../handbook/ppp-and-slip.html#USERPPP">Handbook entry on PPP (user-mode version)</link>
            </para>
          </listitem>
        </itemizedlist>
        </para>

        <para>Si solo tienes acceso a Internet a traves de un "shell
        account", quizás quieras mirar el package
        <link xlink:href="http://www.FreeBSD.org/cgi/ports.cgi?^slirp">slirp</link>.
        Puede darte un (limitado) acceso a servicios como ftp y http.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question xml:id="natd">
        <para>?Soporta FreeBSD NAT o Masquerading?</para>
      </question>

      <answer>
        <para>Si tienes una red local (una o más máquinas), pero solo
        se te ha asignado una única dirección IP desde tu proveedor
        de Internet (o si recibes las direcciones de manera dinámica), te
        interesa mirar el programa
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?natd">natd</link>.
        <emphasis remap="tt">Natd</emphasis> te permite conectar una red entera a Internet usando
        solamente una dirección IP.</para>

        <para>El programa
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ppp">ppp</link>
        tiene una funcionalidad similar incluida, a través del
        parámetro -alias. La
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?libalias">librería alias</link>
        es usada en ambos casos.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>No puedo crear el dispositivo <filename>/dev/ed0</filename>!</para>
      </question>

      <answer>
        <para>En el sistema de trabajo de red de Berkeley, los interfaces de
        red solo son directamente accesibles por el código del kernel. Por
        favor, mira el archivo <filename>/etc/rc.network</filename> y los man de los
        programas de red allí mencionados. Si esto te deja totalmente
        confundido, entonces tendrías que conseguir algun libro de
        administración de red de cualquier sistema operativo basado en BSD;
        con algunas excepciones significativas, administrar el sistema de red
        en FreeBSD es básicamente igual que en SunOS 4.0 o Ultrix.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo puedo configurar alias de ethernets?</para>
      </question>

      <answer>
        <para>Añade ``<literal>netmask 0xffffffff</literal>'' en el comando
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ifconfig">ifconfig</link>
        como el siguiente:</para>

        <para>
        <literallayout>
          ifconfig ed0 alias 204.141.95.2 netmask 0xffffffff
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo hago para usar el otro puerto de una 3C503?</para>
      </question>

      <answer>
        <para>Si quieres usar los otros puertos, tendrás que especificar
        parámetros adicionales en el comando
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ifconfig">ifconfig</link>.
        El puerto por defecto es <emphasis remap="tt">link0</emphasis>. Para usar el
        puerto AUI en lugar del BSN, usa <emphasis remap="tt">link2</emphasis>. Estos
        flags tendrían que ser especificados usando las variable ifconfig_* en
        el archivo
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?rc.conf">/etc/rc.conf</link>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Tengo problemas con NFS desde/hacia FreeBSD.</para>
      </question>

      <answer>
        <para>Algunas tarjetas de red son mejores que otras y algunas veces
        pueden causar problemas con aplicaciones de uso intensivo de red
        como NFS</para>

        <para>Mira la <link xlink:href="../../handbook/nfs.html">entrada en el manual de NFS</link>
        para más información sobre este tema.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Porqué no puedo hacer NFS-mount desde Linux?</para>
      </question>

      <answer>
        <para>Algunas versiones de NFS para Linux solo aceptan peticiones
        para montar unidades hechas desde un puerto privilegiado; intenta:</para>

        <para>
        <literallayout>
          mount -o -P linuxbox:/blah /mnt
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Porqué no puedo hacer NFS-mount desde una Sun?</para>
      </question>

      <answer>
        <para>Las estaciones de trabajo Sun con SunOS 4.x solo aceptan peticiones
        de montar unidades hechas desde puertos privilegiados; intenta</para>

        <para>
        <literallayout>
          mount -o -P sunbox:/blah /mnt
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Tengo problemas usando ppp contra máquinas NeXTStep.</para>
      </question>

      <answer>
        <para>Intenta desactivar las extensiones TCP en
        url="http://www.FreeBSD.org/cgi/man.cgi?rc.conf" name="/etc/rc.conf"&gt;
        cambiando la siguiente variable a NO:</para>

        <para>
        <literallayout>
          tcp_extensions=NO
        </literallayout>
        </para>

        <para>Las máquinas Xylogic's Annex también tienen este
        problema, por lo que tienes que hacer el mismo cambio para conectar con
        ellas.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo activo soporte de IP multicast?</para>
      </question>

      <answer>
        <para>Las operaciones multicast están totalmente soportadas en FreeBSD
        2.0 y superiores. Si quieres usar tu máquina como router multicast,
        necesitarás cargar el módulo de kernel <symbol>ip_mrouted_mod</symbol> y
        ejecutar el programa <emphasis remap="tt">mrouted</emphasis>.</para>

        <para>Para más información:</para>

        <para>
        <literallayout>
Producto        Descripcion             Donde
--------------- ----------------------- ---------------------------------------
faq.txt		Mbone FAQ		ftp.isi.edu:/mbone/faq.txt
imm/immserv	IMage Multicast 	ftp.hawaii.edu:/paccom/imm.src.tar.Z
        	for jpg/gif images.
nv		Network Video.		ftp.parc.xerox.com:
        				/pub/net-reseach/exp/nv3.3alpha.tar.Z
vat		LBL Visual Audio Tool.	ftp.ee.lbl.gov:
        				/conferencing/vat/i386-vat.tar.Z
wb		LBL White Board.	ftp.ee.lbl.gov:
        				/conferencing/wb/i386-wb.tar.Z
mmcc		MultiMedia Conference	ftp.isi.edu:
        	Control program		/confctrl/mmcc/mmcc-intel.tar.Z
rtpqual		Tools for testing the	ftp.psc.edu:/pub/net_tools/rtpqual.c
        	quality of RTP packets.
vat_nv_record	Recording tools for vat ftp.sics.se:archive/vat_nv_record.tar.Z
        	and nv.
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Qué tarjetas de red están basadas en el chipset DEC PCI?</para>
      </question>

      <answer>
        <para>Aquí tienes una lista hecha por
        <link xlink:href="mailto:gfoster@driver.nsta.org">Glen Foster</link>:</para>

        <para>
        <literallayout>
        Fabricante      Modelo
        ----------------------------------------------
        ASUS            PCI-L101-TB
        Accton          ENI1203
        Cogent          EM960PCI
        Compex          ENET32-PCI
        D-Link          DE-530
        Dayna           DP1203, DP2100
        DEC             DE435, DE450
        Danpex          EN-9400P3
        JCIS            Condor JC1260
        Linksys         EtherPCI
        Mylex           LNP101
        SMC             EtherPower 10/100 (Model 9332)
        SMC             EtherPower (Model 8432)
        TopWare         TE-3500P
        Zynx            ZX342
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Porqué tengo que usar el FQDN para hosts en mi servidor?</para>
      </question>

      <answer>
        <para>Probablemente el host estará en un dominio diferente; por
        ejemplo, si estás en el dominio foo.bar.edu y quieres encontrar
        un host llamado "mumble" en el dominio bar.edu, tendrás que
        llamarlo por su nombre de dominio, "mumble.bar.edu", en vez de solo
        "mumble".</para>

        <para>Tradicionalmente, esto era permitido por los resolvers BIND BSD.
        La versión actual de
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?named">bind</link> que
        se incluye en FreeBSD no resuelve abreviaciones de nombres para
        hosts fuera de nuestro dominio.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>``Permission denied'' para todas las operaciones de red.</para>
      </question>

      <answer>
        <para>Si tienes el kernel compilado con la opción <acronym>IPFIREWALL</acronym>
        . debes tener en cuenta que la política por defecto es denegar
        explícitamente todos los paquetes que no están
        explícitamente permitidos.</para>

        <para>Si involuntariamente has desconfigurado el firewall de tu sistema,
        puedes restaurar la operatibilidad de la red tecleando el siguiente
        comando como usuario root:</para>

        <para>
        <literallayout>
          ipfw add 65534 allow all from any to any
        </literallayout>
        </para>

        <para>Para más información en la configuración del firewall
        de FreeBSD, mira la sección
        <link xlink:href="../../handbook/firewalls.html">del manual</link>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cuanto tiempo retrasa IPFW el tráfico?</para>
      </question>

      <answer>
        <para>Esta respuesta depende mucho en las reglas definidas y en la
        versión del procesador. Para la mayoría de aplicaciones
        que tienen que ver con la ethernet y pequeñas reglas, la
        respuesta es, prácticamente nada.</para>

        <para>Aquí tienes una lista de cosas a tener en cuenta para crear reglas
        de filtrado eficientes:</para>

        <para>
        <itemizedlist>
          <listitem>
            <para>Poner una regla "established" al inicio para manejar la
            mayoría de trafico TCP. No pongas ninguna regla
            <emphasis remap="tt">allow tcp</emphasis> antes de esta.
            </para>
          </listitem>

          <listitem>
            <para>Pon las reglas más usadas antes de las menos usadas
            (<emphasis remap="bf">sin modificar la permisividad del firewall</emphasis>).
            Puedes ver cuales son las reglas más usadas examinando los contadores
            de paquetes con la orden <command>ipfw -a l</command>.
            </para>
          </listitem>
        </itemizedlist>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo puedo redirigir peticiones de una máquina a
        otra?</para>
      </question>

      <answer>
        <para>Puedes redirigir peticiones FTP (y otros servicios) con el package
        "socket", disponible en la colección de ports categoría
        "sysutils". Simplemente tienes que reemplazar la línea del servicio
        correspondiente en el archivo /etc/services de la siguiente manera:</para>

        <para>
        <literallayout>ftp stream tcp nowait nobody /usr/local/bin/socket socket ftp.foo.com ftp
        </literallayout>
        </para>

        <para>donde "ftp.foo.com" y "ftp" son la máquina y puerto
        de destino.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Dónde puedo conseguir una herramienta de control de ancho
        de banda?.</para>
      </question>

      <answer>
        <para>Existen dos herramientas de control de ancho de banda para FreeBSD.
        <link xlink:href="http://www.csl.sony.co.jp/person/kjc/programs.html">ALTQ</link> es
        gratis; Bandwidth Manager de
        <link xlink:href="http://www.etinc.com/">Emerging Technologies</link> es un
        producto comercial.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Porqué aparece "/dev/bpf0: device not configured"?</para>
      </question>

      <answer>
        <para>El driver Berkeley Packet Filter
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?bpf">(bpf)</link> necesita ser
        activado para ejecutar programas que lo utilizan. Añade esto al
        archivo de configuración de tu kernel y crea uno nuevo:</para>

        <para>
        <literallayout>
          pseudo-device bpfilter         # Berkeley Packet Filter
        </literallayout>
        </para>

        <para>A continuación, después de rearrancar tendrás el
        dispositivo. Esto puede hacerse entrando en el directorio <filename>/dev</filename>
        y ejecutando el siguiente comando:</para>

        <para>
        <informalexample>
          <screen>
            # sh MAKEDEV bpf0
          </screen>
        </informalexample>
        </para>

        <para>Por favor, mira la <link xlink:href="../../handbook/kernelconfig-nodes.html">entrada
        correspondiente en el handbook</link> para más
        información sobre la creación de dispositivos.</para>
      </answer>
    </qandaentry>
  </qandaset>
</chapter>

<chapter xml:id="ppp">
<title>PPP</title>

  <qandaset>
    <qandaentry>
      <question xml:id="userppp">
        <para>El ppp no funciona. ?Qué estoy haciendo mal?</para>
      </question>

      <answer>
        <para>Primero deberías leer el
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ppp">man de ppp</link> y
        la <link xlink:href="../../handbook/ppp-and-slip.html#USERPPP">sección de
        PPP del handbook</link>. Activa los logs con el comando</para>

        <para>
        <literallayout>
          set log Phase Chat Connect Carrier lcp ipcp ccp command
        </literallayout>
        </para>

        <para>Este comando debería ser tecleado en el prompt del
        <emphasis remap="bf">ppp</emphasis> o incluirse en el archivo de
        configuración <filename>/etc/ppp/ppp.conf</filename>
        (al inicio de la sección <emphasis remap="bf">default</emphasis> es el mejor lugar).
        Asegurate que el archivo
        url="http://www.FreeBSD.org/cgi/man.cgi?syslog.conf"
        name="/etc/syslog.conf"&gt; contiene las siguientes líneas:</para>

        <para>
        <literallayout>        !ppp
        *.*              /var/log/ppp.log
        </literallayout>
        </para>

        <para>y que el archivo <filename>/var/log/ppp.log</filename> existe. Puedes
        encontrar mucha información sobre lo que está pasando en las
        conexiones con el archivo de log.</para>

        <para>Si tu versión de ppp no entiende el comando "set log"
        deberías bajarte la
        <link xlink:href="http://www.FreeBSD.org/~brian/">última versión</link>.
        Esta compilará sin problemas en FreeBSD 2.1.5 y superiores.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Ppp se bloquea al ejecutarlo</para>
      </question>

      <answer>

        <para>Esto ocurre normalmente por que no se puede resolver el nombre
        de la máquina. La mejor manera de solucionar este problema
        es asegurarse que el sistema use en primer lugar el archivo
        <filename>/etc/hosts</filename> para hacer la resolución de
        nombres. Para ello, basta con editar el archivo
        <filename>/etc/host.conf</filename> y poner la línea
        <emphasis remap="tt">hosts</emphasis> en primer lugar. A
        continuación, simplemente hay que añadir una
        línea para la máquina local en el archivo
        <filename>/etc/hosts</filename>. Si no existe una red local, modificar
        la línea <emphasis remap="tt">localhost</emphasis>:</para>

        <para>
        <literallayout>127.0.0.1	foo.bar.com foo localhost
        </literallayout>
        </para>

        <para>Añadir otra línea para la máquina local.
        Consultar las páginas man relevantes para más detalles.</para>

        <para>Ahora se debería poder ejecutar el siguiente mandato de
        forma satisfactoria <command>ping -c1 `hostname`</command>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>PPP no quiere marcar en modo -auto</para>
      </question>

      <answer>
        <para>Primero, asegúrate de tener una ruta por defecto. Ejecutando
        el comando url="http://www.FreeBSD.org/cgi/man.cgi?netstat"&gt;
        name="netstat -rn"&gt; deberías ver dos entradas como estas:</para>

        <para>
        <literallayout>
Destination        Gateway            Flags     Refs     Use     Netif Expire
default            10.0.0.2           UGSc        0        0      tun0
10.0.0.2           10.0.0.1           UH          0        0      tun0
        </literallayout>
        </para>

        <para>Esto es asumiendo que hayas usado las direcciones del manual,
        la página man o del archivo de ejemplo ppp.conf.sample. Si no
        tienes una ruta por defecto, puede ser por que estés usando una
        versión antigua de <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ppp">ppp</link>
        que no entiende la palabra <acronym>HISADDR</acronym> en el archivo ppp.conf. Si
        tu versión de <emphasis remap="bf">ppp</emphasis> es de antes de FreeBSD 2.2.5,
        cambia la línea</para>

        <para>
        <literallayout>          add 0 0 HISADDR
        </literallayout>
        </para>

        <para>por otra diciendo</para>

        <para>
        <literallayout>          add 0 0 10.0.0.2
        </literallayout>
        </para>

        <para>Otra razón para la inexistencia de la ruta por defecto es que
        sin darte cuenta hayas creado un default router en el archivo
        /etc/rc.conf (anteriormente llamado <filename>/etc/sysconfig</filename>) y
        hayas omitido la línea</para>

        <para>
        <literallayout>          delete ALL
        </literallayout>
        </para>

        <para>en el archivo <filename>ppp.conf</filename>.  Si es este el caso vuelve a la
        sección
        <link xlink:href="../../handbook/ppp-and-slip.html#USERPPP-FINAL.html">configuración final del sistema</link>
        en el handbook.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Qué significa "No route to host"?</para>
      </question>

      <answer>
        <para>Este error se debe normalmente a la falta de la sección</para>

        <para>
        <literallayout>
            MYADDR:
            delete ALL
            add 0 0 HISADDR
        </literallayout>
        </para>

        <para>en el archivo <filename>/etc/ppp/ppp.linkup</filename>. Esto es solo
        necesario si tienes una direccion IP dinámica o no sabes la
        dirección de tu gateway. Si estás usando el modo
        interactivo, puedes teclear lo siguiente despues de entrar en
        <emphasis remap="tt">packet mode</emphasis>:</para>

        <para>
        <literallayout>
          delete ALL
          add 0 0 HISADDR
        </literallayout>
        </para>

        <para>Pásate por la sección
        <link xlink:href="../../handbook/ppp-and-slip.html#USERPPP-DYNAMICIP">PPP y direcciones IP dinámicas</link>
        del handbook para más información.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Mi conexión se corta pasados 3 minutos</para>
      </question>

      <answer>
        <para>El timeout de ppp por defecto es de 3 minutos. Se puede ajustar
        con la línea:</para>

        <para>
        <literallayout>          set timeout NNN
        </literallayout>
        </para>

        <para>Donde <acronym>NNN</acronym> es el número de segundos de inactividad antes
        de cerrar la conexión. Si <acronym>NNN</acronym> es 0, la conexión no
        se cerrará nunca por timeout. Es posible poner este comando en
        el archivo <filename>ppp.conf</filename>, o teclearla en el prompt del modo
        interactivo. También es posible ajustarla en cualquier momento mientras la
        conexión esté activa conectando al socket del servidor
        <emphasis remap="bf">ppp</emphasis> usando
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?telnet">telnet</link>
        o <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?pppctl">pppctl</link>. Leete el man de
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ppp">ppp</link>
        para más detalles.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Mi conexión se corta en situaciones de carga</para>
      </question>

      <answer>
        <para>Si tienes la opción Link Quality Reporting (LQR) configurada
        es posible que demasiados paquetes LQR se pierdan entre tu
        máquina y el remoto. PPP deduce que la línea es mala y
        corta la conexión. En versiones anteriores a la 2.2.5 de
        FreeBSD, LQR estaba activado por defecto. Ahora está desactivado
        por defecto. LQR puede ser activado con la línea</para>

        <para>
        <literallayout>          disable lqr
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Mi conexión se corta en periodos aleatorios</para>
      </question>

      <answer>
        <para>Algunas veces, en líneas telefónicas de baja calidad
        o con mucho ruido, o líneas con la opción de llamada en
        espera activada, el módem corta la conexión por que
        piensa (erróneamente) que ha perdido la portadora.</para>

        <para>Hay una opción en muchos modems para determiar la tolerancia
        a pérdidas temporales de portadora. En un USR Sportster por
        ejemplo, esta es medida por el registro S10 en décimas de
        segundo. Para hacer que tu módem sea más resistente,
        puedes añadir la siguiente secuencia "send-expect" a la cadena
        de llamada:</para>

        <para>
        <literallayout>          set dial "...... ATS10=10 OK ......"
        </literallayout>
        </para>

        <para>Mira en el manual de tu módem para más detalles.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>No ocurre nada después del mensaje Login OK</para>
      </question>

      <answer>
        <para>En versiones anteriores a FreeBSD 2.2.5, una vez estaba la
        conexión establecida,
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ppp">ppp</link> espera a
        que el remoto inicie la negociación LCP
        (Line Control Protocol). Muchos proveedores de Internet no
        iniciarán la negociación esperando que sea el cliente el
        que lo haga. Para forzar al <emphasis remap="bf">ppp</emphasis> a iniciar el LCP, usa la
        siguiente línea:</para>

        <para>
        <literallayout>          set openmode active
        </literallayout>
        </para>

        <para><emphasis remap="bf">Nota:</emphasis> Normalmente no hay problemas si las dos partes
        inician la negocioacion LCP, ya que el modo abierto (open mode)
        está activo por defecto. De todas maneras, la siguiente
        sección explica cuando pueden haber problemas.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Sigo teniendo errores sobre el parámetro magic</para>
      </question>

      <answer>
        <para>Ocasionalmente, justo después de la conexión, puedes
        ver mensajes en el log referentes a "magic number is the same".
        Algunas veces, estos mensajes son inofensivos, y otras veces
        uno de los dos extremos finaliza la conexión. Algunas
        implementaciones de ppp no pueden solucionar este problema, y,
        aunque parezca que la conexión está establecida,
        verás repetidas peticiones y aceptaciones de
        configuración en el archivo de log hasta que una de las dos
        partes cierra la conexión.</para>

        <para>Esto ocurre normalmente en servidores con disco lentos que
        tienen problemas para gestionar eficientemente los puertos
        serie. También existen informes de problemas en conexiones
        mediante slip. La razón es que en el tiempo que tarda el
        servidor en salir del getty y ejecutar el ppp, el cliente
        manda los paquetes de inicio LCP. Al estar el ECHO todavía
        activo en el puerto del servidor, el cliente ppp lo único que
        ve son sus propios paquetes "reflejados" por el servidor.</para>

        <para>Una parte de la negociación LCP es establecer un número
        mágico para cada una de los dos extremos de las conexiones para
        que los "reflejos" puedan ser detectados. El protocolo dice que
        cuando el remoto intenta negociar el mismo "magic number", se debe
        enviar un NAK para seleccionar un nuevo "magic number". Durante el
        periodo de tiempo que el servidor tiene el ECHO activado en el
        puerto, el cliente ppp envía paquetes LCP, ve que el mismo
        "magic" vuelve en el paquete reflejado y lo da como no válido
        (envia NAK).
        Este todavía ve el paquete reflajado con NAK (lo que significa
        que el ppp debe cambiar su "magic"). Esto produce un enorme
        número de cambios de "magic number" que son introducidos en el
        buffer tty del servidor. Tan pronto como el ppp arranca en el servidor,
        es bombardeado con cambios de "magic numbers" e inmediatamente decide
        que ya ha realizado el número suficiente de negociaciones LCP y
        corta la conexión. Mientras tanto, el cliente, que ya no ve los
        paquetes reflejados, recibe sin problemas la desconexión del
        servidor y también cierra la conexión.</para>

        <para>Esto puede ser resuelto permitiendo que el remoto inicie la
        negociación, poniendo la siguiente línea en el archivo
        ppp.conf:</para>

        <para>
        <literallayout>          set openmode passive
        </literallayout>
        </para>

        <para>Esto indica al ppp que espere a que el servidor comience la
        negociación LCP. Es posible que algunos servidores nunca inicien
        la negociación. Si este es el caso, puedes hacer algo como:</para>

        <para>
        <literallayout>          set openmode active 3
        </literallayout>
        </para>

        <para>Esto le indica al ppp que sea pasivo durante 3 segundos, y
        despues comience a enviar peticiones LCP. Si el remoto envía
        peticiones durante este periodo, ppp responderá inmediatamente
        sin esperar los 3 segundos establecidos.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Las negociaciones LCP continuan hasta que se cierra la conexión</para>
      </question>

      <answer>
        <para>Existe actualmente un problema de implementación en
        <emphasis remap="bf">ppp</emphasis> en la que no asocia las respuestas LCP, CCP
        &amp; IPCP con sus peticiones originales. Como resultado, si una implementación
        <emphasis remap="bf">ppp</emphasis> es más lenta durante 6 segundos que la remota, la remota
        enviará dos peticiones de configuración LCP adicionales.
        Esto es fatal.</para>

        <para>Considera dos implementaciones, <emphasis remap="bf">A</emphasis> y
        <emphasis remap="bf">B</emphasis>. <emphasis remap="bf">A</emphasis> empieza
        a enviar peticiones LCP inmediatamente después de conectar y
        <emphasis remap="bf">B</emphasis> tarda 7 segundos en arrancar. Cuando
        <emphasis remap="bf">B</emphasis> arranca, <emphasis remap="bf">A</emphasis> ha
        enviado 3 peticiones LCP. Estamos asumiendo que la línea tiene el
        ECHO desactivado, si no, veriamos los problemas de "magic number"
        descritos en el apartado anterior. <emphasis remap="bf">B</emphasis> envía un REQ, y a
        continuación envía un ACK al primer REQ de <emphasis remap="bf">A</emphasis>. Esto
        resulta en que <emphasis remap="bf">A</emphasis> entra en modo <acronym>OPENED</acronym>
        y envía un ACK (el primero) a <emphasis remap="bf">B</emphasis>. Mientras,
        <emphasis remap="bf">B</emphasis> devuelve dos ACKs más en respuesta a los dos REQs
        adicionales enviados por <emphasis remap="bf">A</emphasis> antes de que
        <emphasis remap="bf">B</emphasis> arrancase .<emphasis remap="bf">B</emphasis> recibe
        el primer ACK de <emphasis remap="bf">A</emphasis> y entra en modo
        <acronym>OPENED</acronym>. <emphasis remap="bf">A</emphasis> recibe el segundo ACK
        de <emphasis remap="bf">B</emphasis> y vuelve al estado
        <emphasis remap="bf">REQ-SENT</emphasis>, enviando otro (el cuarto) REQ. Entonces recibe el
        tercer ACK y entra en modo <acronym>OPENED</acronym>. Mientras,
        <emphasis remap="bf">B</emphasis> recibe el cuarto REQ de <emphasis remap="bf">A</emphasis>,
        produciendo que vuelva de nuevo al estado <emphasis remap="bf">ACK-SENT</emphasis> y
        enviando otro (el segundo) REQ y (cuarto) ACK. <emphasis remap="bf">A</emphasis>
        recibe el REQ, entra en modo <emphasis remap="bf">REQ-SENT</emphasis> y envía otro REQ.
        Inmediatamente recibe el siguiente ACK y entra en <acronym>OPENED</acronym>.</para>

        <para>Esto pasa hasta que una de las partes piensa que ya ha realizado
        suficientes reintentos y corta la conexión.</para>

        <para>La mejor manera de evitar esto es configurar una de las partes
        de manera <emphasis remap="bf">pasiva</emphasis> - que es, hacer que una de las partes espere
        a que la otra comience la negociación. Esto puede realizarse
        con el comando:</para>

        <para>
        <literallayout>
          set openmode passive
        </literallayout>
        </para>

        <para>Se debe tener cuidado con esta opción. También se puede
        usar:</para>

        <para>
        <literallayout>
        set stopped N
        </literallayout>
        </para>

        <para>para limitar el número de veces que <emphasis remap="bf">ppp</emphasis>
        espera a que el remoto comience la negociación. Alternativamente, puedes user
        el comando:</para>

        <para>
        <literallayout>
          set openmode active N
        </literallayout>
        </para>

        <para>donde <emphasis remap="bf">N</emphasis> es el número de segundos que
        espera antes de empezar la negociación. Mira en el manual para más
        detalles.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Ppp se bloquea al conectar</para>
      </question>

      <answer>
        <para>Antes de la versión 2.2.5 era posible que la conexión
        se corte nada más iniciarse debido a un problema en la
        negociación de compresión Predictor1. Esto solo pasa si
        las dos partes intentan negociar con diferentes protocolos de control
        de compresión (CCP). Este problema ya está corregido, pero
        si estás usando una versión antigua de
        <emphasis remap="bf">ppp</emphasis>, el problema puede solucionarse
        con la línea</para>

        <para>
        <literallayout>
          disable pred1
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Ppp se bloqua al abrir un shell de test</para>
      </question>

      <answer>
        <para>Cuando ejecutas el comando <emphasis remap="tt">shell</emphasis> o
        <emphasis remap="tt">!</emphasis>, <emphasis remap="bf">ppp</emphasis> ejecuta
        un shell (o si has pasado argumentos, <emphasis remap="bf">ppp</emphasis> ejecutará esos
        argumentos). Ppp esperará a que se complete el comando antes de
        continuar. Si intentas usar la conexión ppp mientras se ejecuta
        el comando, parecerá que la conexión se ha colgado. Esto
        es por que <emphasis remap="bf">ppp</emphasis> está esperando a que se complete la
        ejecución del comando.</para>

        <para>Si quieres ejecutar comandos como este, usa el comando
        <emphasis remap="tt">!bg</emphasis> en su lugar. Esto ejecutará el comando
        en background, y ppp continúa sin problemas con la conexión.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Ppp sobre un cable null-modem no funciona</para>
      </question>

      <answer>
        <para>No hay manera que <emphasis remap="bf">ppp</emphasis> detecte
        automáticamente que una conexión directa se ha cortado. Es debido
        a las líneas que se usan en un cable serie null-modem. Cuando usamos este tipo de
        conexión, LQR debería estar siempre activada con el
        comando</para>

        <para>
        <literallayout>          enable lqr
        </literallayout>
        </para>

        <para>LQR es aceptado por defecto si es negociado por el remoto.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Por que llama sin motivo el ppp en modo -auto?</para>
      </question>

      <answer>
        <para>Si <emphasis remap="bf">ppp</emphasis> llama inesperadamente, debes determinar la causa, y
        poner filtros (dfilters) para prevenir esas llamadas.</para>

        <para>Para determinar la causa, usa la siguiente línea:</para>

        <para>
        <literallayout>          set log +tcp/ip
        </literallayout>
        </para>

        <para>Esto guardara todo el tráfico que pase a través de la
        conexión.
        La próxima vez que se realice una llamada no deseada,
        podrás ver la causa convenientemente guardada.</para>

        <para>Ahora puedes desactivar las llamadas producidas por esa causa.
        Usualmente, este tipo de problemas se debe a consultas de DNS. Para
        prevenir que las consultas de DNS puedan establecer conexiones usa
        la siguiente línea (esto no hará que los paquetes de DNS
        queden parados cuando la conexión está establecida):</para>

        <para>
        <literallayout>          set dfilter 1 deny udp src eq 53
          set dfilter 2 deny udp dst eq 53
          set dfilter 3 permit 0/0 0/0
        </literallayout>
        </para>

        <para>Esto no siempre es aconsejable, ya que puede afectar a la
        capacidad de realizar conexiones bajo demanda - muchos programas
        necesitan hacer una consulta al DNS antes de poder realizar
        cualquier operación.</para>

        <para>En el caso del DNS, deberías determinar que es lo que
        está intentando realizar esas consultas de DNS. Muchas veces,
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?sendmail">sendmail</link>
        es el culpable. Debes asegurarte configurar el
        sendmail de manera que no realice ninguna consulta al DNS. Mira la
        sección <link linkend="ispmail">Configuracion de correo</link> para
        tener más detalles acerca de como crear una archivo propio de
        configuración de sendmail. También deberías
        añadir la siguiente línea en tu archivo <filename>.mc</filename>:</para>

        <para>
        <literallayout>          define(`confDELIVERY_MODE', `d')dnl
        </literallayout>
        </para>

        <para>Esto hara que sendmail encole todo el correo hasta que no se
        procese la cola (usualmente, sendmail es invocado con
        "-bd -q30m", indicandole que procese la cola cada 30 minutos) o
        hasta que se ejecuta el comando "sendmail -q" (por ejemplo, desde
        el archivo ppp.linup).</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Qué significan estos errores CCP?</para>
      </question>

      <answer>
        <para>Sigo viendo los siguientes errores en el archivo de log:</para>

        <para>
        <literallayout>          CCP: CcpSendConfigReq
          CCP: Received Terminate Ack (1) state = Req-Sent (6)
        </literallayout>
        </para>

        <para>Esto es porque ppp está intentando negociar compresión
        Predictor1, y el remoto no quiere negociar ningún tipo de
        compresión. Estos mensajes son sin importancia, pero si quieres
        eliminarlos, puedes desactivar la compresión Predictor1
        localmente:</para>

        <para>
        <literallayout>          disable pred1
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>PPP se cuelga durante transferencia de archivos con errores I/OP</para>
      </question>

      <answer>
        <para>En la versión FreeBSD 2.2.2 y anteriores, había un
        problema en el driver tun que no permitía paquetes entrantes con
        un tamaño mayor que el MTU del interface. La recepción de
        un paquete mayor que el MTU resulta en un error IO que es logueado
        vía syslogd.</para>

        <para>La especificación PPP dice que un MRU de 1500
        <emphasis remap="bf">siempre</emphasis>
        debería ser aceptada como mínimo, a pesar de lo que se
        negocie mediante LCP, de todas maneras, es posible que hayas disminuido
        el MTU por debajo de 1500 y tu proveedor te esté enviando
        paquetes de 1500, haciendo que tu conexión se bloquee.</para>

        <para>El problema puede solucionarse haciendo que el tamaño del
        MTU nunca sea inferior a 1500 bajo FreeBSD 2.2.2 y anteriores.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Por que ppp no loguea la velocidad de la conexión?</para>
      </question>

      <answer>
        <para>Para loguear todas las líneas de "conversación" de tu
        módem, debes activar la siguiente opción:</para>

        <para>
        <literallayout>          set log +connect
        </literallayout>
        </para>

        <para>Esto hará que
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ppp">ppp</link>
        loguee todo hasta la última cadena "expect" pedida.</para>

        <para>Si quieres ver la velocidad de tu conexión y usas PAP o CHAP
        (y por lo tanto no tienes nada que "chatear" después del CONNECT
        en el script de marcado), debes estar seguro de indicarle al ppp que
        espera la línea "CONNECT con algo como esto:</para>

        <para>
        <literallayout>          set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 4 \"\" ATZ OK-ATZ-OK ATDT\\T TIMEOUT 60 CONNECT \\c \\n"
        </literallayout>
        </para>

        <para>Aquí, tenemos nuestro CONNECT, enviamos nada, y esperamos un
        salto de línea, forzando al <emphasis remap="bf">ppp</emphasis> que lea
        la respuesta del CONNECT.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Ppp ignora el carácter `\' en mi chat script</para>
      </question>

      <answer>
        <para>PPP lee cada línea de los archivos de configuración
        para poder interpretar cadenas como <emphasis remap="tt">set phone "123 456 789"</emphasis>
        correctamente.
        Para especificar un carácter ``"'', debes usar la contrabarra
        (``\'').</para>

        <para>Cuando el intérprete lee cada argumento, reinterpreta el
        argumento para buscar alguna secuencia especial de escape como ``\P''
        o ``\T''.
        Como resultado de esta doble lectura, recuerda que has de usar el
        número correcto de escapes (contrabarras).</para>

        <para>Si quieres enviar un caracter ``\'' a tu módem, necesitas
        hacer algo como:</para>

        <para>
        <literallayout>          set dial "\"\" ATZ OK-ATZ-OK AT\\\\X OK"
        </literallayout>
        </para>

        <para>resultando en la siguiente secuencia:</para>

        <para>
        <literallayout>          ATZ
          OK
          AT\X
          OK
        </literallayout>
        </para>

        <para>o</para>

        <para>
        <literallayout>          set phone 1234567
          set dial "\"\" ATZ OK ATDT\\T"
        </literallayout>
        </para>

        <para>resultando en la siguiente secuencia:</para>

        <para>
        <literallayout>          ATZ
          OK
          ATDT1234567
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Ppp produce un seg-fault, pero no veo el archivo
        <filename>ppp.core</filename></para>
      </question>

      <answer>
        <para>Ppp (o cualquier otro programa de este tipo), nunca deberían
        hacer un core dump. Por que ppp funciona con un id de usuario 0,
        el sistema operativo no escribirá la imagen del core en disco.
        Si ppp termina con errores de "segmentation violation" o cualquier
        otra señal que normalmente causa un core dumped, y quieres poder
        hacer un debug de ese core, asegúrate de usar la última
        versión de ppp, y haz lo siguiente:</para>

        <para>
        <literallayout>          $ tar xfz ppp-*.src.tar.gz
          $ cd ppp*/ppp
          $ echo STRIP= &gt;&gt;Makefile
          $ echo CFLAGS+=-g &gt;&gt;Makefile
          $ make clean all
          $ su
          # make install
          # chmod 555 /usr/sbin/ppp
        </literallayout>
        </para>

        <para>Ahora tendrás instalada una versión "debuggable" de
        ppp. Tendrás que ser root para poder ejecutar ppp ya que todos
        sus privilegios han sido revocados. Cuando arranques ppp, acuerdate del
        directorio en el que te encuentras.</para>

        <para>Ahora, cuando ppp recibe una violación de segmentación
        , creará un archivo core llamado ppp.core. A continuación
        , deberías hacer lo siguiente:</para>

        <para>
        <literallayout>          $ su
          # gdb /usr/sbin/ppp ppp.core
          (gdb) bt
          .....
          (gdb) f 0
          .....
          (gdb) i args
          .....
          (gdb) l
          .....
        </literallayout>
        </para>

        <para>Toda esta información puede hacer posible diagnosticar el
        problema. Si estás familiarizado con gdb, puedes encontrar otras
        pistas como que causó el dump y las direcciones y valores de las
        variables más relevantes.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>El proceso que fuerza una llamada en modo auto nunca funciona</para>
      </question>

      <answer>
        <para>Este es un problema conocido cuando <emphasis remap="bf">ppp</emphasis>
        está configurado para negociar una IP dinámica local con el
        remoto. Este problema ha sido solucionado en la última versión -
        busca en el man la palabra <emphasis remap="bf">iface</emphasis>.</para>

        <para>El problema era que cuando el programa inicial llama a
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?connect">connect(2)</link>,
        el IP del interface tun es asignado al punto
        final del socket. El kernel crea el primer paquete saliente y
        establece la conexión. Si, como resultado de la
        asignación dinámica de IP, la dirección del
        interface es cambiada, el punto final del socket original será
        invalido. Los siguientes paquetes enviados al remoto normalmente
        serán descartados. Aun si no lo son, cualquier respuesta no
        será enrutada hacia la máquina de origen por que la
        dirección IP de la máquina de origen ha cambiado.</para>

        <para>Hay varias maneras teóricas de solucionar este problema. Lo
        mejor sería que el remoto reasignase la misma IP si fuese
        posible <emphasis remap="tt">:-)</emphasis> La versión actual de
        <emphasis remap="bf">ppp</emphasis> hace esto,
        pero otras muchas implementaciones no.</para>

        <para>El método más sencillo desde nuestra parte,
        sería no cambiar nunca la IP del interface tun, pero por el
        contrario, cambiar todos los paquetes salientes de manera que la ip de
        origen es cambiada del IP del interface a la IP negociada,
        instantaneamente.
        Esto es, esencialmente, lo que hacen
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?libalias">libalias(3)</link>
        y el parámetro <option>-alias</option> de ppp.</para>

        <para>Otra alternativa (y probablemente la más eficaz) es implementar
        una llamada al sistema que cambie todos los sockets de una IP a
        otra. <emphasis remap="bf">Ppp</emphasis> debería usar esta llamada para modificar los
        sockets de todos los programas existentes cuando una nueva
        dirección IP es negociada. La misma llamada de sistema
        podría ser usada para clientes dhcp cuando son forzados
        a rehacer sus sockets.</para>

        <para>Una tercera opción es permitir que un interface se active sin
        IP. Los paquetes salientes tendrían un IP de 255.255.255.255
        hasta que el primer SIOCAIFADDR ioctl este hecho. Esto
        permitiría que ppp cambiase el IP de origen, pero solo si el
        socket es 255.255.255.255 y solo el IP y el checksum necesitan cambiar. Esto, de
        todas maneras, requiere tocar el kernel para que puede enviar
        paquetes incorrectos a un interface mal configurado.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Porqué muchos juegos no funcionan con el
        parámetro -alias?</para>
      </question>

      <answer>
        <para>La razón por la que muchos de los juegos no funcionan es
        por que la máquina externa intentará abrir una
        conexión o enviar paquetes UDP (no solicitados) a la
        máquina interna. El software "alias" no sabe que esos paquetes
        debrín enviarse a la máquina interna.</para>

        <para>Para que las cosas funcionen, asegúrate que la única
        cosa que está funcionando es el software con el que tienes
        problemas, entonces ejecuta tcpdump en el interface tun del
        gateway o ejecuta el log tcp/ip del ppp ("set log +tcp/ip" en el
        gateway.</para>

        <para>Cuando arrancas el software que no funciona, deberís ver
        paquetes que pasan a través del gateway. Cuando algo
        vuelve del exterior, será rechazado (ese es el problema).
        Apunta el número de puerto de esos paquetes y cierra el
        software que no funciona. Haz esto varias veces para comprobar si
        el número de puerto se repite. Si es así, la siguiente
        línea en el archivo de configuración del ppp
        /etc/ppp/ppp.conf hará que las cosas funcionen:</para>

        <para>
        <literallayout>         alias port proto internalmachine:port port
       </literallayout>
        </para>

        <para>donde "proto" puede ser "tcp" o "udp", "internalmachine" es la
        máquina a la que quieres que los paquetes sean enviados y
        "port" es el número de puerto de destino de los paquetes.</para>

        <para>No podrás usar ese software en otras máquinas sin
        modificar el comando anterior, y ejecutar el software
        simultaneamente en dos máquinas internas no será
        posible - después de todo, el mundo exterior está
        viendo a toda tu red como una sola máquina.</para>

        <para>Si los números de puertos no se repiten, hay tres opciones
        más:</para>

        <para><emphasis remap="bf">1)</emphasis> Desarrollar el soporte en libalias. Ejemplos de estos
        "casos especiales" los puedes encontrar en
        /usr/src/lib/libalias/alias_*.c (alias_ftp.c es un buén
        prototipo). Esto usualmente supone leer ciertos paquetes salientes
        conocidos, identificando la instrucción que le indica a la
        máquina exterior que inicie una conexión con la
        máquina interna en un puerto específico (aleatorio)
        y configurar un "ruta" en la tabla de alias para que los paquetes
        siguientes sepan donde ir.</para>

        <para>Esta es la solución más difícil, pero es la
        mejor y hará que el software funcione con múltiples
        máquinas.</para>

        <para><emphasis remap="bf">2)</emphasis> Usar un proxy. La aplicación debe soportar
        socks5 por ejemplo, o (como en el caso del "cvsup") debería
        tener una opción "pasiva" que evita que el remoto intente abrir
        conexiones con la maquina local.</para>

        <para><emphasis remap="bf">3)</emphasis> Redireccionar todo el tráfico
        a la máquina interna usando "alias addr". Esta es la solución más
        sencilla.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Ha hecho alguien una lista de puertos útiles?</para>
      </question>

      <answer>
        <para>Todavía no, pero se podría hacer, si hay
        interés. En cada ejemplo, <emphasis remap="tt">internal</emphasis> debe ser
        reemplazado por la dirección IP de la máquina que
        va a estar jugando.</para>

        <para>
        <itemizedlist>
          <listitem>
            <para><emphasis remap="bf">Quake</emphasis>
            </para>

            <para><emphasis remap="tt">alias port udp internal:6112 6112</emphasis></para>

            <para>Alternativamente, quizás estés interesado en
            mirar en el
            <link xlink:href="http://www.battle.net/support/proxy/">www.battle.net</link>soporte
            de Quake a través de proxy"&gt;.</para>
          </listitem>
        </itemizedlist>
        </para>

        <para>
        <itemizedlist>
          <listitem>
            <para><emphasis remap="bf">Quake 2</emphasis></para>

            <para><emphasis remap="tt">alias port udp internal:27901 27910</emphasis></para>
          </listitem>
        </itemizedlist>
        </para>

        <para>
        <itemizedlist>
          <listitem>
            <para><emphasis remap="bf">Red Alert</emphasis></para>

            <para><emphasis remap="tt">alias port udp internal:8675 8675</emphasis></para>

            <para><emphasis remap="tt">alias port udp internal:5009 5009</emphasis></para>
          </listitem>
        </itemizedlist>
        </para>

        <para>
        <itemizedlist>
          <listitem>
            <para><emphasis remap="bf">Half Life</emphasis></para>

            <para><emphasis remap="tt">alias port udp internal:27005 27015</emphasis></para>
          </listitem>
        </itemizedlist>
        </para>

        <para>
        <itemizedlist>
          <listitem>
            <para><emphasis remap="bf">PCAnywhere 8.0</emphasis></para>

            <para><emphasis remap="tt">alias port udp internal:5632 5632</emphasis></para>

            <para><emphasis remap="tt">alias port tcp internal:5631 5631</emphasis></para>
          </listitem>
        </itemizedlist>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Qué son los errores FCS?</para>
      </question>

      <answer>
        <para>FCS significa <emphasis remap="bf">F</emphasis>rame
        <emphasis remap="bf">C</emphasis>heck <emphasis remap="bf">S</emphasis>equence.
        Cada paquete ppp tiene un checksum añadido para asegurar que los datos
        que se reciben son los datos que han sido enviados. Si el FCS de un
        paquete entrante es incorrecto, el paquete es rechazado y se
        incremente el contador HDLC FCS. Los valores de error HDLC se
        pueden visualizar usando el comando <emphasis remap="tt">show hdlc</emphasis>.</para>

        <para>Si tu conexión es mala (o si tu driver serie está
        rechazando paquetes), verás errores FCS ocasionales. En general
        no tienes porque preocuparte de ellos. Si tienes un módem
        externo, asegúrate que el cable está correctamente
        aislado de interferencias - esto debería erradicar el problema.</para>

        <para>Si tu conexión se corta tan pronto como has conectado y ves
        gran cantidad de errores FCS, puede ser por que ti conexión no
        es de 8 bits. Asegúrate de que tu módem no está
        usando control de flujo (XON/XOFF) por software. Si tu conexión
        de datos <emphasis remap="bf">debe</emphasis> usar control de flujo por software, usa el
        comando <literal>set accmap 0x000a0000</literal> para indicar al
        <emphasis remap="bf">ppp</emphasis> que "escape" los carácteres ^Q y ^S.</para>

        <para>Otra razón para ver muchos errores FCS puede ser que el
        remoto haya dejado de "hablar" <acronym>PPP</acronym>. Deberís activar el
        log asíncrono para determinar si los datos entrantes son de
        un login o un prompt de shell. Si tienes un prompt de shell en el
        extremo de la conexión, es posible terminar el ppp sin
        cortar la conexión usando el comando <emphasis remap="tt">close clp</emphasis> (usando
        el comando <emphasis remap="tt">term</emphasis> podrás conectar de nuevo con el shell
        de la máquina remota.</para>

        <para>Si no hay nada en el log que indique por que se ha terminado la
        conexión, deberís preguntar al administrador del
        sistema remoto porqué ha terminado la sesión.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Nada de esto me ayuda - Estoy desesperado !</para>
      </question>

      <answer>
        <para>Si todo falla, envía toda la información que puedas,
        incluyendo los archivos de configuración, como arrancas el ppp,
        las partes relevantes del archivo de log y la salida del comando
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?netstat">netstat -rn</link>
        (antes y despues de la conexión) a la lista de distribución
        <link xlink:href="mailto:FreeBSD-questions@FreeBSD.org">FreeBSD-questions@FreeBSD.org</link>,
        a la lista de
        <link xlink:href="mailto:FreeBSD@es.FreeBSD.org">FreeBSD en castellano</link> o
        al grupo de news
        <link xlink:href="news:comp.unix.bsd.FreeBSD.misc">comp.unix.bsd.FreeBSD.misc</link>
        y alguien te ayudará a solucionar los problemas.</para>
      </answer>
    </qandaentry>
  </qandaset>
</chapter>

<chapter xml:id="serial">
<title>Comunicaciones serie</title>

  <para>Esta sección responde las preguntas más frecuentes sobre las
  comunicaciones serie con FreeBSD. PPP y SLIP se tratan en la
  sección <link linkend="networking">Networking</link>.</para>

  <qandaset>
    <qandaentry>
      <question>
        <para>?Cómo se si FreeBSD ha encontrado mis puertos serie?</para>
      </question>

      <answer>
        <para>Cuando el kernel de FreeBSD arranca, testeará los puertos serie
        del sistema que estén configurados en el kernel. Puedes estar
        atento a los mensajes de la consola o ejecutar el comando:</para>

        <para>
        <literallayout>        dmesg | grep sio
        </literallayout>
        </para>

        <para>una vez el sistema esté en funcionamiento.</para>

        <para>Aquí tienes un ejemplo del resultado de la ejecución
        del comando:</para>

        <para>
        <literallayout>        sio0 at 0x3f8-0x3ff irq 4 on isa
        sio0: type 16550A
        sio1 at 0x2f8-0x2ff irq 3 on isa
        sio1: type 16550A
        </literallayout>
        </para>

        <para>Esto muestra dos puertos serie. El primero en la irq 4 usando
        la dirección <literal>0x3f8</literal>, y tiene una UART 16550A. El segundo usa
        el mismo tipo de chip pero está en la irq 3 y usa la
        dirección <literal>0x2f8</literal>. Los módems internos son tratados
        como puertos serie, exceptuando que siempre tienen un módem
        adjuntado al puerto.</para>

        <para>El kernel <acronym>GENERIC</acronym> incluye soporte para dos puertos serie
        usando la misma irq y dirección que en el ejemplo anterior. Si
        estas opciones no son correctar para tu sistema, o si has añadido
        módems internos o tienes más puertos serie de los que
        están configurados en el kernel, solo tienes que reconfigurar el
        kernel. Mira en la sección
        <link linkend="make-kernel">about building a kernel</link> para más
        detalles.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo se si FreeBSD ha encontrado mi módem interno?</para>
      </question>

      <answer>
        <para>Respondido en la sección anterior.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>He actualizado a 2.0.5 y mi <emphasis remap="tt">tty0X</emphasis> no
        existen!</para>
      </question>

      <answer>
        <para>No te preocupes, han sido integrados en los dispositivos
        <emphasis remap="tt">ttydX</emphasis>. Tendrás que modificar algunos
        archivos antiguos de configuración.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo accedo a los puertos serie en FreeBSD?</para>
      </question>

      <answer>
        <para>El tercer puerto serie,
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?sio">sio2</link> (conocido
        como COM3 en DOS), está en <filename>/dev/cuaa2</filename> para dispositivos de
        salida (dial-out) y en <filename>/dev/ttyd2</filename> para dispositivos de
        entrada (dial-in). Cuál es la diferencia entre estas dos clases de
        dispositivos?.</para>

        <para>Usas los <emphasis remap="tt">ttydX</emphasis> para los entrantes.
        Al abrir <filename>/dev/ttydX</filename>
        en "blocking mode", un proceso esperará para que el dispositivo
        <emphasis remap="tt">cuaaX</emphasis> correspondiente se vuelva inactivo.
        Cuando abres un dispositivo <emphasis remap="tt">cuaaX</emphasis>, se asegura
        de que el puerto serie no está en uso por un dispositivo
        <emphasis remap="tt">ttydX</emphasis>. Si el puerto está disponible,
        se lo "roba" al dispositivo <emphasis remap="tt">ttydX</emphasis>. Al mismo tiempo,
        el dispositivo <emphasis remap="tt">cuaaXX</emphasis> no se preocupa de la
        detección de portadora. Con este
        esquema, y un módem en respuesta automática, puedes
        recibir usuarios remotos y puedes hacer conexiones externas con el mismo
        módem, mientras el sistema se preocupa de evitar los posible
        conflictos.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo activo el soporte de tarjetas serie multipuerto?</para>
      </question>

      <answer>
        <para>Otra vez, en la sección de configuración del kernel
        tienes la información. Para una tarjeta multipuerto, pon una
        línea <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?sio">sio</link>
        para cada puerto serie de la tarjeta en el archivo de
        configuración del kernel. Especifica la irq y vector solo en una
        de las líneas.
        Todos los puertos de la tarjeta compartirán la misma irq. Por
        consistencia, usa el último puerto serie para especificar la irq.
        De la misma manera, especifica la opción <symbol>COM_MULTIPORT</symbol>.</para>

        <para>El siguiente ejemplo es para una tarjeta AST 4-port en la irq 7:</para>

        <para>
        <literallayout>        options "COM_MULTIPORT"
        device sio4 at isa? port 0x2a0 tty flags 0x781
        device sio5 at isa? port 0x2a8 tty flags 0x781
        device sio6 at isa? port 0x2b0 tty flags 0x781
        device sio7 at isa? port 0x2b8 tty flags 0x781 irq 7 vector siointr
        </literallayout>
        </para>

        <para>Los flags indican que el puerto master tiene un número menor
        de 7 (<literal>0x700</literal>), los diagnósticos están activados durante
        el testeo (<literal>0x080</literal>), y los puertos comparten una irq
        (<literal>0x001</literal>).</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Puede manejar FreeBSD tarjetas multipuerto compartiendo irq?</para>
      </question>

      <answer>
        <para>Todavía no. Tendrás que usar una irq diferente para cada
        tarjeta.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Puedo cambiar los parámetros serie por defecto para
        un puerto?</para>
      </question>

      <answer>
        <para>El dispositivo <emphasis remap="tt">ttydX</emphasis> (o
        <emphasis remap="tt">cuaaX</emphasis>) es el que querrás abrir
        para tus aplicaciones. Cuando un proceso abre el dispositivo,
        tendrá una serie de configuraciones I/O por defecto. Puedes ver
        estas configuraciones con el comando:</para>

        <para>
        <literallayout>        stty -a -f /dev/ttyd1
        </literallayout>
        </para>

        <para>Cuando le cambias la configuración a este dispositivo, este cambio
        se mantiene hasta que el dispositivo se cierra. Cuando se reabre,
        vuelve a la configuración por defecto. Para hacer cambios sobre la
        configuración por defecto, puedes abrir y ajustar las opciones del
        "estado inicial" del dispositivo. Por ejemplo, para poner el
        dispositivo tty5 en modo <acronym>CLOCAL</acronym>, 8 bits, y contro del flujo
        <filename>XON/XOFF</filename>, haz</para>

        <para>
        <literallayout>        stty -f /dev/ttyid5 clocal cs8 ixon ixoff
        </literallayout>
        </para>

        <para>Un buen lugar para hacer esto es en <filename>/etc/rc.serial</filename>. Ahora,
        una aplicación tendrá esta configuración por
        defecto cuando abra el puerto <emphasis remap="tt">ttyd5</emphasis>.</para>

        <para>También puedes prevenir o limitar ciertos cambios que pretenda
        hacer una aplicación. Para ello, ajusta el "lock state" del
        dispostivo. Por ejemplo, para bloquear la velocidad del puerto
        <emphasis remap="tt">ttyd5</emphasis> a 57600 bps, haz:</para>

        <para>
        <literallayout>        stty -f /dev/ttyld5 57600
        </literallayout>
        </para>

        <para>Ahora, una aplicación que abre <emphasis remap="tt">ttyd5</emphasis>
        e intenta cambiar la velocidad del puerto no podrá hacerlo.</para>

        <para>Naturalmente, deberías hacer que el estado inicial y el estado
        de bloqueo sean solo de escritura para el usuario <emphasis remap="tt">root</emphasis>.
        El script
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?MAKEDEV">MAKEDEV</link>
        <acronym>NO</acronym> hace esto cuando crea el dispositivo.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo puedo activar logins de entrada en mi módem?</para>
      </question>

      <answer>
        <para>Quieres hacerte proveedor de Internet, eh?. Primero,
        necesitarás uno o más módems que puedan responder
        automáticamente. Tu módem necesitará activar el
        carrier-detect sólo cuando detecte una portadora y no tenerla
        activada continuamente. Necesitará cortar la comunicación
        y resetearse él mismo cuando la línea <acronym>DTR</acronym> pase de on
        a off.
        Probablemente usaría <filename>RTS/CTS</filename> para el control de flujo.
        Finalmente, debe usar una velocidad constante entre el computador y
        él mismo, pero debería negociar la velocidad entre
        él mismo y el módem remoto.</para>

        <para>Para muchos módems compatibles Hayes, este comando
        creará estas configuraciones y las grabará en la memoria no
        volátil:</para>

        <para>
        <literallayout>        AT &amp;C1 &amp;D3 &amp;K3 &amp;Q6 S0=1 &amp;W
        </literallayout>
        </para>

        <para>Mira la sección <link linkend="direct-at">enviar comandos AT</link>
        para saber como enviar estas configuraciones al módem sin
        necesidad de un programa terminal de DOS.</para>

        <para>A continuación, añade una línea en el archivo
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ttys">/etc/ttys</link>
        para el módem. Este archivo lista todos los puertos en los que el
        sistema operativo esperará los logins. La línea
        sería como esta:</para>

        <para>
        <literallayout>        ttyd1 "/usr/libexec/getty std.57600" dialup on insecure
        </literallayout>
        </para>

        <para>Esta línea indica que el segundo puerto serie
        <filename>/dev/ttyd1</filename> tiene un módem conectado, la velocidad es de
        57600 bps y sin paridad (<emphasis remap="tt">std.57600</emphasis>. El tipo de
        terminal para este puerto es "dialup".
        El puerto está "on" y es inseguro (lo que significa que los logins
        como root no son permitidos).</para>

        <para>Muchos usuarios, ponen un sus archivos .profile o .login un
        prompt para el tipo de terminal. El ejemplo muestra el puerto como
        inseguro. Para ser root en ese puerto, hacer el login como un usuario
        normal, y ejecutar el comando su. Si en lugar de inseguro, el terminal
        es seguro (secure), puedes hacer login como root directamente.</para>

        <para>Despues de modificar el archivo
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ttys">/etc/ttys</link>,
        necesitas lanzar una señal <acronym>HUP</acronym> al proceso
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?init">init</link>:</para>

        <para>
        <literallayout>        kill -HUP 1
        </literallayout>
        </para>

        <para>Esto fuerza al proceso init a releer el archivo
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ttys">/etc/ttys</link>.
        El proceso init arrancará los procesos getty en todos los puertos
        configurados como "on". Puedes ver si los logins están disponibles
        en los puertos tecleando:</para>

        <para>
        <literallayout>        ps -ax | grep '[t]tyd1'
        </literallayout>
        </para>

        <para>deberías ver algo como:</para>

        <para>
        <literallayout>        747 ??  I      0:00.04 /usr/libexec/getty std.57600 ttyd1
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo puedo conectar un dumb terminal a un FreeBSD?</para>
      </question>

      <answer>
        <para>Si estás usando otro computador como terminal en tu sistema
        FreeBSD, usa un cable null módem entre los dos puertos serie. Si
        ya estás usando un terminal, mira en las instrucciones del mismo.</para>

        <para>A continuación, modifica el archivo
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ttys">/etc/ttys</link>
        Por ejemplo, si estás instalando un terminal WYSE-50 en el quinto
        puerto serie, usa una línea como esta:</para>

        <para>
        <literallayout>        ttyd4 "/usr/libexec/getty std.38400" wyse50 on secure
        </literallayout>
        </para>

        <para>Este ejemplo muestra que el puerto <filename>/dev/ttyd4</filename> tiene un
        terminal Wyse50 conectado a 38400 bps sin paridad y los logins de
        root son permitidos.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Porqué no puedo ejecutar <emphasis remap="tt">tip</emphasis> o
        <emphasis remap="tt">cu</emphasis>?</para>
      </question>

      <answer>
        <para>En tu sistema, los programas
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?tip">tip</link> y
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?cu">cu</link> son probablemente
        ejecutables solo por <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?uucp">uucp</link>
        y el grupo <emphasis remap="tt">dialer</emphasis>. Puedes usar el grupo
        <emphasis remap="tt">dialer</emphasis>
        para controlar quien tiene acceso al módem o sistemas remotos.
        Sólo tienes que añadirte tu mismo al grupo dialer.</para>

        <para>Alternativamente, puedes dejar que todos los usuarios de tu sistema
        ejecuten <emphasis remap="tt">tip</emphasis> y
        <emphasis remap="tt">cu</emphasis> tecleando:</para>

        <para>
        <literallayout>        # chmod 4511 /usr/bin/cu
        # chmod 4511 /usr/bin/tip
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Mi módem hayes no está soportado. ?Que puedo hacer?</para>
      </question>

      <answer>
        <para>Actualmente, el man de
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?tip">tip</link> está
        anticuado. Hay un dialer Hayes genérico. Solo usa
        ``<literal>at=hayes</literal>'' en tu archivo
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?remote">/etc/remote</link>.</para>

        <para>El driver Hayes no es tan desarrollado como para reconocer algunas
        de las características avanzadas de los módems modernos,
        mensajes como <acronym>BUSY</acronym>, <emphasis remap="tt">NO DIALTONE</emphasis> o
        <emphasis remap="tt">CONNECT 115200</emphasis> lo pueden confundir.
        Deberías anular estos mensajes cuando uses
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?tip">tip</link> (utilizando
        la cadena <emphasis remap="tt">ATX0&amp;W</emphasis>).</para>

        <para>También, el timeout de llamada para <emphasis remap="tt">tip</emphasis>
        está en 60  segundos. Tu módem debería usar algo menor, o tip puede
        pensar que hay un problema de comunicación. Intenta con
        <literal>ATS7=45&amp;W</literal>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question xml:id="direct-at">
        <para>?Cómo puedo introducir estos comandos AT?</para>
      </question>

      <answer>
        <para>Haz lo que se llama una entrada <emphasis remap="tt">directa</emphasis> en el archivo
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?remote">/etc/remote</link>.
        Por ejemplo, si tu módem está
        conectado al primer puerto serie, <filename>/dev/cuaa0</filename>, escribe la
        siguiente línea:</para>

        <para>
        <literallayout>        cuaa0:dv=/dev/cuaa0:br#19200:pa=none
        </literallayout>
        </para>

        <para>Usa la velocidad más alta que soporte tu módem en la
        sección br.
        A continuación teclea
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?tip">tip cuaa0</link>
        y estarás conectado al módem.</para>

        <para>Si no existe el dispositivo <filename>/dev/cuaa0</filename> en tu sistema
        , teclea lo siguiente:</para>

        <para>
        <literallayout>        # cd /dev
        # ./MAKEDEV cuaa0
        </literallayout>
        </para>

        <para>O usa el comando cu como root con los siguientes parámetros:</para>

        <para>
        <literallayout>        # cu -l``line'' -s``speed''
        </literallayout>
        </para>

        <para>con line siendo el puerto serie (por ejemplo <filename>/dev/cuaa0</filename>&gt;)
        y speed siendo la velocidad (por ejemplo <emphasis remap="tt">57600</emphasis>. Cuando
        termines de entrar los comandos AT, pulsa la tecla <emphasis remap="tt">.</emphasis> para
        salir.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>El símbolo <emphasis remap="tt">@</emphasis> no funciona correctamente!</para>
      </question>

      <answer>
        <para>El símbolo <emphasis remap="tt">@</emphasis> en la opción de
        números de teléfono indica a tip que busque en el archivo
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?phones(5)">phone(5)</link> un
        número de teléfono determinado. Pero el símbolo
        <email>@</email> es también un carácter especial en otros archivos y
        opciones como <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?remote">/etc/remote</link>.
        Pon una contrabarra junto al carácter:</para>

        <para>
        <literallayout>        pn=\@
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo puedo llamar desde la línea de comandos?</para>
      </question>

      <answer>
        <para>Pon lo que se llama una entrada <emphasis remap="tt">genérica</emphasis>
        en el archivo
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?remote">/etc/remote</link>.
        Por ejemplo:</para>

        <para>
        <literallayout>        tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuaa0:br#115200:at=hayes:pa=none:du:
        tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuaa0:br#57600:at=hayes:pa=none:du:
        </literallayout>
        </para>

        <para>Entonces puedes hacer cosas como <command>tip -115200 5551234</command>. Si
        prefieres usar <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?cu">cu</link>
        antes que <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?tip">tip</link>,
        usa una entrada genérica de cu:</para>

        <para>
        <literallayout>        cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuaa1:br#57600:at=hayes:pa=none:du:
        </literallayout>
        </para>

        <para>y teclea ``<command>cu 5551234 -s 115200</command>''.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Tengo que teclear la velocidad cada vez que hago esto?</para>
      </question>

      <answer>
        <para>Pon una entrada para <emphasis remap="tt">tip1200</emphasis> o
        <emphasis remap="tt">cu1200</emphasis>, pero puedes usar
        la velocidad que mejor se amolde a tus necesidades.
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?tip">tip</link> piensa que
        una buena velocidad por defecto es 1200 bps ya que busca una entrada
        <emphasis remap="tt">tip1200</emphasis>. No tienes por que usar 1200 bps.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Accedo a diferentes hosts a través de un servidor de terminales.</para>
      </question>

      <answer>
        <para>En lugar de esperar a que estés conectado y teclear
        <emphasis remap="tt">CONNECT &lt;host&gt;</emphasis> cada vez, usa la
        opción <emphasis remap="tt">cm</emphasis> de tip.
        Por ejemplo, estas entradas en el archivo
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?remote">/etc/remote</link>:</para>

        <para>
        <literallayout>        pain|pain.deep13.com|Forrester's machine:\
        :cm=CONNECT pain\n:tc=deep13:
        muffin|muffin.deep13.com|Frank's machine:\
        :cm=CONNECT muffin\n:tc=deep13:
        deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cua02:br#38400:at=hayes:du:pa=none:pn=5551234:
        </literallayout>
        </para>

        <para>Esto hará que puedas teclear <emphasis remap="tt">tip pain</emphasis> o
        <emphasis remap="tt">tip muffin</emphasis>
        para conectarte a las máquinas pain o muffin.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Puede tip intentar más de una línea para cada lugar?</para>
      </question>

      <answer>
        <para>Este es un problema habitual en universidades con diferentes
        líneas de módem y unos cientos de usuarios intentado
        usarlas...</para>

        <para>Haz una entrada para tu universidad en el archivo
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?remote">/etc/remote</link>
        y usa <emphasis remap="tt">\@</emphasis> para la opción
        <emphasis remap="tt">pn</emphasis>:</para>

        <para>
        <literallayout>        big-university:\
        :pn=\@:tc=dialout
        dialout:\
        :dv=/dev/cuaa3:br#9600:at=courier:du:pa=none:
        </literallayout>
        </para>

        <para>Entonces, lista los números de teléfono de la
        universidad en el archivo
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?phones">/etc/phones</link>:</para>

        <para>
        <literallayout>        big-university 5551111
        big-university 5551112
        big-university 5551113
        big-university 5551114
        </literallayout>
        </para>

        <para><link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?tip">tip</link>
        intentará cada uno de estos números en el
        orden en el que estén listados. Si quieres que se realicen
        reintentos, ejecuta <emphasis remap="tt">tip</emphasis> en una bucle while.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Porqué tengo que teclea CTRL+P dos veces para enviar
        CTRL+P una vez?</para>
      </question>

      <answer>
        <para>CTRL+P es el carácter por defecto de "forzar", usado para
        indicarle al programa
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?tip">tip</link>
        que el próximo carácter es un dato literal. Puedes
        configurar el carácter "forzar" a cualquier otro carácter
        con el escape <emphasis remap="tt">~s</emphasis>, el cual significa "poner una
        variable".</para>

        <para>Teclea <literal>~sforce=&lt;single-char&gt;</literal> seguido de una nueva
        línea. <emphasis remap="tt">&lt;single-char&gt;</emphasis> es cualquier
        carácter simple. Si dejas libre <emphasis remap="tt">&lt;single-char&gt;</emphasis>
        entonces el carácter de forzar es el caracter nul, al cual puedes acceder
        tecleando CTRL+2 o CTRL+SPACE. Un valor más adecuado para
        <emphasis remap="tt">&lt;single-char&gt;</emphasis> es SHIFT+CTRL+6, el cual solo es usado en
        algunos servidores de terminales.</para>

        <para>Puedes tener el carácter de forzar donde quieras, especificando
        lo siguiente en tu archivo <filename>&dollar;HOME/.tiprc</filename></para>

        <para>
        <literallayout>        force=&lt;single-char&gt;
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>De repente, todo lo que tecleo es en mayúsculas</para>
      </question>

      <answer>
        <para>Has debido pulsar CTRL+A,
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?tip">tip</link> tiene este
        carácter especial para gente que tenga la tecla caps-lock
        estropeada. Usa <emphasis remap="tt">~s</emphasis> como en la sección anterior
        y pon la variable "raisechar" a un valor razonable. De hecho, puedes ponerla al
        mismo valor que que el carácter de forzar, si no esperas usar
        estas características.</para>

        <para>Aqui hay un ejemplo del archivo .tiprc perfecto para usuarios de
        Emacs que necesiten teclear CTRL+2 y CTRL+A muchas veces:</para>

        <para>
        <literallayout>        force=^^
        raisechar=^^
        </literallayout>
        </para>

        <para>El simbolo ^^ es SHIFT+CTRL+6.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo puedo hacer transferecia de archivos con
        <emphasis remap="tt">tip</emphasis>?</para>
      </question>

      <answer>
        <para>Si estás conectado con otro sistema UNIX, puedes enviar y
        recibir archivos con <emphasis remap="tt">~p</emphasis> (put) y
        <emphasis remap="tt">~t</emphasis> (take). Estos comandos
        ejecutan
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?cat">cat</link> y
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?echo">echo</link>
        en el sistema remoto para aceptar y enviar archivos. La sintaxis es:</para>

        <para>
        <literallayout>        ~p &lt;local-file&gt; [&lt;remote-file&gt;]
        ~t &lt;remote-file&gt; [&lt;local-file&gt;]
        </literallayout>
        </para>

        <para>No hay chequeo de errores, por lo que es mejor usar otro protocolo
        como zmodem.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo puedo usar zmodem con <emphasis remap="tt">tip</emphasis>?</para>
      </question>

      <answer>
        <para>Primero, instala uno de los programas zmodem de la colección de
        ports (por ejemplo
        <link xlink:href="http://www.FreeBSD.org/cgi/ports.cgi?^lrzsz">lrzsz</link>
        y <link xlink:href="http://www.FreeBSD.org/cgi/ports.cgi?^rzsz">rzsz</link>).</para>

        <para>Para recibir archivos, inicia el programa de envío en la parte
        remota. A continuación, pulsa enter y teclea
        <emphasis remap="tt">~C rz</emphasis>'' (or ``<emphasis remap="tt">~C lrz</emphasis>''
        si instalaste lrzsz) para empezar a recibir localmente.</para>

        <para>Para enviar archivos, inicia el programa de recepción en la
        parte remota. A continuación pulsa enter y teclea
        <emphasis remap="tt">~C sz &lt;files&gt;</emphasis>''
        (o <emphasis remap="tt">~C lsz &lt;files&gt;</emphasis>) para enviarlos
        al sistema remoto.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>FreeBSD parece que no puede encontrar mis puertos series aún
        cuando la configuración es correcta.</para>
      </question>

      <answer>
        <para>Las placas bases y tarjetas con UARTs de Acer no son detectadas
        correctamente por FreeBSD durante la fase de detección serie.
        Obten un parche de
        <link xlink:href="http://www.lemis.com/serial-port-patch.html">www.lemis.com</link>
        para solucionar el problema.</para>
      </answer>
    </qandaentry>
  </qandaset>
</chapter>

<chapter xml:id="misc">
<title>Preguntas varias</title>

  <qandaset>
    <qandaentry>
      <question>
        <para>FreeBSD usa más espacio de swap que Linux. Porqué?</para>
      </question>

      <answer>
        <para>No lo hace. Deberías pensar "Porque mi swap parece lleno?". Si
        esto es lo que realmente querías decir, es por que poniendo los
        datos en swap en luar de descartarlos, hace que sea más
        rápido recuperarlos que si el paginador tuviese que ir a
        través del sistema de archivos y usar bloques sin modificar desde
        un ejecutable.</para>

        <para>La cantidad actual de páginas que puedes tener en el core en una
        sola vez no es reducida; las páginas sin usar son desplazadas como
        sea necesario.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Porqué usar (que son) a.out y ELF como formatos
        ejecutables?</para>
      </question>

      <answer>
        <para>Para entender por que FreeBSD usa el formato <filename>a.out</filename>,
        debes saber primero un poco sobre los tres formatos dominantes actualmente
        en UNIX:</para>

        <para>
        <itemizedlist>
          <listitem>
            <para><link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?a.out(5)">a.out</link>
            </para>

            <para>El antiguo y clásico formato de objeto. Usa una corta y
            compacta cabecera con un número mágico en el inicio que
            es usado para caracterizar el formato (mira en
            <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?a.out(5)">a.out(5)</link>
            para más detalles). Contiene tres segmentos
            cargados: .text, .data y .bss más una tabla de símbolos
            y una tabla de cadenas de carácteres.</para>
          </listitem>

          <listitem>
            <para><acronym>COFF</acronym></para>

            <para>El formato de objeto SVR3. La cabecera comprime una sección de
            tablas, de manera que puedas tener más de una sola
            sección .test, .data y .bss</para>
          </listitem>

          <listitem>
            <para><acronym>ELF</acronym></para>

            <para>El sucesor de <acronym>COFF</acronym>, ofreciendo múltiples
            secciones y valores posibles de 32 o 64 bits. Un problema importante:
            <acronym>ELF</acronym> fue diseñado con la presunción de
            que solo existiría un único ABI por arquitectura de sistema.
            Esta presunción actualmente es incorrecta, incluso en el
            mundo comercial (el cual tiene al menos tres ABIs: SVR4, Solaris y SCO).</para>

            <para/>

            <para>FreeBSD intenta solucionar este problema de manera que provee
            de una utilidad para <emphasis>marcar</emphasis> un ejecutable
            <acronym>ELF</acronym> con información sobre el ABI con el que
            es compatible. Para  más información, mira el man de
            <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?brandelf">brandelf</link>.
            </para>
          </listitem>
        </itemizedlist>
        </para>

        <para>FreeBSD viene del sistema clásico y tradicionalmente ha
        utilizado el formato
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?a.out(5)">a.out</link>,
        una tecnología probada y testeada a través
        de muchas generaciones de releases de BSD. También es posible
        construir y ejecutar binarios nativos <acronym>ELF</acronym> (y kernels)
        en sistemas FreeBSD. FreeBSD inicialmente se resistió al salto de cambiar a
        <acronym>ELF</acronym> como su formato por defecto. Porqué?, bien, cuando el
        mundo Linux hizo su transición a <acronym>ELF</acronym> no era nada
        fácil abandonar el formato ejecutable <filename>a.out</filename>
        debido a su inflexible mecanismo de tablas basadas en librerías
        compartidas. Esto hizo muy difícil para los fabricantes y desarrolladores la
        creación de librerías compartidas. A partir del momento en
        el que se ofrecieron una serie de herramientas que ofrecían la
        solución al problema de las librerías compartidas, el
        coste de la migración fue aceptado como necesario y la
        transición se hizo.</para>

        <para>En el caso de FreeBSD, el mecanismo de librerías compartidas
        esta más basado en el estilo de SunOS, mucho más sencillo
        de usar. De todas maneras, empezando con la version 3.0, FreeBSD
        soportará oficialmente binarios <acronym>ELF</acronym> como el formato por
        defecto. Aunque pensamos que el formato ejecutable <filename>a.out</filename>
        nos ha servidor muy bién, la gente de GNU, que hacen las herramientas de
        compilación que usamos, ha dejado de dar soporte para el formato
        <filename>a.out</filename>. Esto nos ha forzado a mantener dos versiones
        divergentes del compilador y lincador.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Porqué chmod no puede cambiar los permisos de
        los links?</para>
      </question>

      <answer>
        <para>Tienes que usar <option>-H</option> o <option>-L</option> junto
        con la opción <option>-R</option>
        para que funcione. Para más información, mira la
        página de
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?chmod">chmod</link> y de
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?symlink">symlink</link>.</para>

        <para><acronym>CUIDADO</acronym> la opción <option>-R</option> hace un
        <emphasis remap="tt">chmod</emphasis> <acronym>RECURSIVO</acronym>. Ten cuidado
        aal especificar directorios o symlinks con
        <emphasis remap="tt">chmod</emphasis>. Si quieres cambiar los permisos de
        un directorio referenciado por un symlink, usa
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?chmod">chmod</link>
        sin ninguna opción y sigue el symlink con una barra <filename>/</filename>.
        Por ejemplo, si <emphasis remap="tt">foo</emphasis> es un symlink al directorio
        <emphasis remap="tt">bar</emphasis>, y quieres
        cambiar los permisos de <emphasis remap="tt">foo</emphasis> /actualmente
        <emphasis remap="tt">bar</emphasis>), deberías
        hacer algo como esto:</para>

        <para>
        <literallayout>
          chmod 555 foo/
        </literallayout>
        </para>

        <para>Con la barra,
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?chmod">chmod</link> seguira
        el symlink, <emphasis remap="tt">foo</emphasis>, para cambiar los permisos del
        directorio <emphasis remap="tt">bar</emphasis>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Porqué están los nombres de usuario restringidos
        a 8 caracteres?</para>
      </question>

      <answer>
        <para>Pensarás que es fácil y suficiente con cambiar
        <symbol>UT_NAMESIZE</symbol> y reconstruir el kernel, y todo volverá a
        funcionar. Desafortunadamente hay aplicaciones y programas (incluyendo
        herramientas de sistema) que tienen en el propio código (no
        siempre 8 o 9, pero si 15 o 20) en estructuras, buffers... y
        rompería los clientes de NIS de Sun y sin duda existirían
        otros problemas interactuando con otros sistemas UNIX.</para>

        <para>En FreeBSD 3.0 y superiores, se ha incrementado el número
        máxmimo de carácteres a 16 y todas esas utilidades con
        longitud de carácteres prefijada han sido encontradas y
        arregladas. El hecho de que este cambio afectase a muchas áreas
        del sistema es el motivo por el que el cambio no se ha hecho hasta
        la versión 3.0.</para>

        <para>Si eres absolutamente cuidadoso y quieres arreglas tu mismo este
        problema en versiones anteriores, edita el archivo
        /usr/include/utmp.h y cambia el parámetro UT_NAMESIZE a la
        longitud que desees. También debes editar el archivo
        /usr/include/sys/param.h y poner el valor de MAXLOGNAME al mismo que
        UT_NAMESIZE. Finalmente, recompila los fuentes, no te olvides que
        el contenido de /usr/include es actualizado cada vez!. En su lugar,
        cambia los archivos apropiados en /usr/src/..</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Puedo ejecutar binarios DOS bajo FreeBSD?</para>
      </question>

      <answer>
        <para>Sí, empezando en la versión 3.0 puedes usar la
        emulación DOS <emphasis remap="tt">rundos</emphasis> de BSDI, la cual
        ha sido integrada y mejorada. Envía un mail a la
        <link xlink:href="mailto:emulation@FreeBSD.org">Lista de discusión de emulación en FreeBSD</link>
        si estás interesado en participar en la evolución de esta
        característica.</para>

        <para>Para sistemas pre-3.0 hay una pequeña utilidad llamada
        <link xlink:href="http://www.FreeBSD.org/cgi/ports.cgi?^pcemu">pcemu</link>
        en la colección de puertos que emula un 8088 y suficientes
        servicios de BIOS para ejecutar aplicaciones de modo texto. Requiere el
        sistema de X Window.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Qué es <emphasis remap="tt">sup</emphasis>, y como
        lo uso?</para>
      </question>

      <answer>
        <para><link xlink:href="http://www.FreeBSD.org/cgi/ports.cgi?^sup">SUP</link>
        significa Software Update Protocol, y fue desarrollado por CMU para
        mantener sus árboles de desarrollo sincronizados. Nosotros lo
        usabamos para manterner el servidor central sincronizado con otros
        servidores remotos.</para>

        <para>SUP no es amigo del ancho de banda, y ha sido retirado. El
        método actual recomendado para mantener tus fuentes actualizados
        es <link xlink:href="../../handbook/synching.html#CVSUP">CVSup</link></para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Existen herramientas de ahorro de energía
        en FreeBSD?</para>
      </question>

      <answer>
        <para>FreeBSD usa la instrucción <acronym>HLT</acronym> (halt)
        cuando el sistema está (idle) para reducir el consumo de energía.
        Si tienes la opción APM (Automatic Power Management) configurado, FreeBSD
        puede poner la cpu en modo de baja energía.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Qué significa "MFC"?</para>
      </question>

      <answer>
        <para>MFC es un acrónimo para "Merges From -CURRENT". Es usado en los
        logs de CVS para indicar que un cambio se ha migrado de la rama CURRENT
        a la rama STABLE.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Qué significa "BSD"?</para>
      </question>

      <answer>
        <para>Pertenece a un lenguaje secreto que solo sus miembros conoces. No tiene
        traducción literal, pero basta con decir que su traducción
        está entre, "Equipo de Fórmula-1", "Los Pinguinos son un
        buén aperitivo", y "Tenermos mejor sentido del humor que Linux"
        :-)</para>

        <para>Seriamente, BSD es un acrónimo de "Berkeley Software
        Distribution", el cual es el nombre que el CSRG de Berkeley (Computer
        Systems Research Group) escogió para sus distribuciones de Unix.</para>
      </answer>
    </qandaentry>
  </qandaset>
</chapter>

<chapter xml:id="hackers">
<title>Sólo para hackers serios de FreeBSD</title>

  <qandaset>
    <qandaentry>
      <question>
        <para>?Qué son SNAPs y RELEASEs?</para>
      </question>

      <answer>
        <para>Hay actualmente tres ramas activas/semi-activas en el desarrollo de
        FreeBSD y en su
        <link xlink:href="http://www.FreeBSD.org/cgi/cvsweb.cgi">CVS Repository</link>:</para>

        <para>
        <itemizedlist>
          <listitem>
            <para><symbol>RELENG_2_2</symbol> AKA <emphasis remap="bf">2.2-stable</emphasis>
            AKA <emphasis remap="bf">"2.2 branch"</emphasis></para>
          </listitem>

          <listitem>
            <para><symbol>RELENG_3</symbol> AKA <emphasis remap="bf">3.x-stable</emphasis>
            AKA <emphasis remap="bf">"3.0 branch"</emphasis></para>
          </listitem>

          <listitem>
            <para><acronym>HEAD</acronym>  AKA <option>-current</option> AKA
            <emphasis remap="bf">4.0-current</emphasis></para>
          </listitem>
        </itemizedlist>
        </para>

        <para><acronym>HEAD</acronym> no es una rama actual, como las otras dos, es
        simplemente una constante simbólica para <emphasis>la versión
        de desarrollo actual</emphasis> a la cual nos referimos simplemente como
        <option>-current</option>.</para>

        <para>Actualmente, <option>-current</option> es el desarrollo de la
        versión 4.0 y la rama <emphasis remap="bf">3.0-stable</emphasis> es
        <symbol>RELENG_3</symbol>, separada de -current en Enero
        de 1999.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question xml:id="custrel">
        <para>?Cómo puedo hacerme mi propia release personalizada?</para>
      </question>

      <answer>
        <para>Para hacer una release necesitas hacer tres cosas: primero,
        necesitas usar un kernel con el driver
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?vn">vn</link> configurado.
        Añade esto a tu archivo de configuración del kernel y
        crea un nuevo kernel:</para>

        <para>
        <literallayout>
          pseudo-device vn         #Vnode driver (turns a file into a device)
        </literallayout>
        </para>

        <para>Segundo, debes tener las herramientas del CVS a mano. Para hacer
        esto, puedes usar
        <link xlink:href="../../handbook/synching.html#CVSUP">CVSUP</link>
        pero en tu supfile pon el nombre de la release a cvs y borra cualquier
        tag campo de fecha:</para>

        <para>
        <literallayout>        *default prefix=/home/ncvs
        *default base=/a
        *default host=cvsup.FreeBSD.org
        *default release=cvs
        *default delete compress use-rel-suffix

        ## Main Source Tree
        src-all
        src-eBones
        src-secure

        # Other stuff
        ports-all
        www
        doc-all
        </literallayout>
        </para>

        <para>A continuación ejecuta <command>cvsup -g supfile</command>
        para tener todos los bits correctos en tu computador.</para>

        <para>Finalmente, necesitas una buena cantidad de espacio vacío para
        crear en el la release. Digamos que está en
        <filename>/algun/disco/grande</filename> y en el ejemplo anterior has dejado los
        archivos del CVS en <filename>/home/ncvs</filename>:</para>

        <para>
        <literallayout>
        setenv CVSROOT /home/ncvs        # or export CVSROOT=/home/ncvs
        cd /usr/src/release
        make release BUILDNAME=3.0-MY-SNAP CHROOTDIR=/algun/disco/grande/release
        </literallayout>
        </para>

        <para>Una release completa será creada en
        <filename>/algun/disco/grande/</filename> y tendrás una
        instalación completa de tipo FTP en
        <filename>/algun/disco/grande/R/ftp</filename> cuando acabes.
        Si quieres crear tu SNAP usando otra rama de desarrollo diferente de
        -current, puedes añadir <literal>RELEASETAG=SOMETAG</literal> a la
        línea de comando anterior de creación de la release. Por ejemplo,
        <literal>RELEASETAG=RELENG_2_2</literal> crearía un snapshot 2.2 GAMMA.
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo creo discos de instalación personalizados?</para>
      </question>

      <answer>
        <para>El proceso completo de creacación de discos de
        instalación y archivos fuentes y binarios esta automatizado por
        varios targets en <filename>/usr/src/release/Makefile</filename>. La
        información alli contenida debería ser suficiente para que
        puedas empezar. Falta decir que este proceso necesita la ejecución
        del comando "make world" y quizás te use mucho tiempo y espacio
        en disco.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>``make world'' destruye mis binarios instalados.</para>
      </question>

      <answer>
        <para>Sí, esta es la idea general; como su nombre sugiere,
        "make world" rehace todos los binarios del sistema, de manera que puedas
        estar seguro de tener un entorno limpio y consistente al final (que es
        por lo que tarda tanto).</para>

        <para>Si la variable de entorno <acronym>DESTDIR</acronym> está
        definida mientras se ejecuta <emphasis remap="tt">make world</emphasis> o
        <emphasis remap="tt">make install</emphasis>, los binarios creados
        nuevamente seran depositados en un árbol de directorios
        idéntico al instalado, y a partir de
        <emphasis remap="tt">&dollar;{DESTDIR}</emphasis>.  Algunas combinaciones aleatorias
        de modificaciones de librerías compartidas y programas pueden
        causar que falle el <emphasis remap="tt">make world</emphasis>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Cuando mi sistema arranca, dice (bus speed defaulted).</para>
      </question>

      <answer>
        <para>Las controladoras SCSI Adaptec 1542 permiten al usuario configurar
        su velocidad de acceso al bus en software. Versiones anteriores del
        driver de la 1542 intentaban determinar la velocidad más alta
        factible y configurar la Adaptec a esta. Nos hemos encontrado con que esto
        hace fallar el sistema de algunos usuarios, por lo que tienes que
        definir la opción de configuración del kernel
        <symbol>TUNE_1542</symbol> para que esto ocurra. En algunos sistemas puede
        que puede hacer que los discos vayan más rápidos, pero en
        otros puede que los datos queden corrompidos.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question xml:id="ctm">
        <para>?Puedo seguir la rama current con acceso limitado a Internet?</para>
      </question>

      <answer>
        <para>Sí, puedes hacerlo <emphasis remap="tt">sin</emphasis> bajarte
        todo el código fuente usando la
        utilidad <link xlink:href="../../handbook/synching.html#CTM">CTM.</link></para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo partir la distribución en archivos de 240k?</para>
      </question>

      <answer>
        <para>Los sistemas BSD más modernos tienen una opción
        <option>-b</option> para partir que les permite partir los archivos en
        tamaños arbitrarios.</para>

        <para>Aqui hay un ejemplo de <filename>/usr/src/Makefile</filename>.</para>

        <para>
        <literallayout>        bin-tarball:
        (cd ${DISTDIR}; \
        tar cf - . \
        gzip --no-name -9 -c | \
        split -b 240640 - \
        ${RELEASEDIR}/tarballs/bindist/bin_tgz.)
        </literallayout>
        </para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?He escrito una extensión del kernel, a quien la
        envío?</para>
      </question>

      <answer>
        <para>Por favor, mira en
        <link xlink:href="../../handbook/contrib.html">como enviar código.</link></para>

        <para>Y gracias por pensar en nosotros!</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Cómo se detectan e inicializan las tarjetas ISA y PnP?</para>
      </question>

      <answer>
        <para>Brevemente, hay unos cuantos puertos de entrada/salida a los que
        todas las tarjetas PnP responden cuando el computador pregunta si hay
        alguien ahí. Así, cuando comienza la rutina de prueba
        de PnP, pregunta si hay alguna tarjeta PnP presente y todas las
        tarjetas responden con su número de modelo a una lectura I/O
        del mismo puerto. Así el código de prueba puede conocer
        el ID de cada tarjeta (asignado por Microsoft/Intel).</para>

        <para>Los ID's son dos campos de 32 bits (2&circ;64) + 8 bits de
        checksum. Los primeros 32 bits son el identificador del fabricante.
        No se ha dicho publicamente, pero parece estar asumido que diferentes
        tipos de tarjeta del mismo fabricante pueden tener diferentes id's de
        fabricante. La idea de necesitar 32 bits sólo para los
        fabricantes parece un poco excesiva.</para>

        <para>La parte baja de 32 bits son un número de serie,
        dirección ethernet, algo que haga a la tarjeta única. El
        fabricante no debe producir nunca una segunda tarjeta que tenga los
        mismos 32 bits de la parte baja, aunque los 32 bits de la parte alta sean
        diferentes. Así puedes tener múltiples tarjetas del mismo
        tipo en la misma máquina y los 64 bits serán únicos
        para cada tarjeta.</para>

        <para>Los grupos de 32 bits nunca pueden ser todos cero. Esto permite
        mostrar todos los bits no-cero durante la búsqueda binaria
        inicial.</para>

        <para>Una vez el sistema ha identificado todos los ID's de las tarjetas
        presentes, reactivaráa cada tarjeta, una tras otra (a
        través de los mismos puertos I/O), y encontrará los
        recursos que cada tarjeta necesita, que opciones de interrupción
        están disponibles, etc. Se realiza un escaneo sobre todas y cada
        una de las tarjetas presentes para conocer esta información.</para>

        <para>Esta información se combina con la información de los
        archivos ECU del disco y con las BIOS MLB. El soporte PnP de ECU y las
        BIOS para hardware en el MLB usualmente es sintético, y los
        periféricos no hacen PnP genuino. De todas maneras, examinando
        la información del BIOS más la información
        ECU, la rutina de prueba puede causar que los dispositivos que no son
        PnP puedan evitar a esos dispositivos que el código de prueba
        no puede volver a posicionar.</para>

        <para>Así, los dispositivos PnP son visitados una vez más
        y se les asigna su I/O, DMA, IRQ, direcciones del mapa de memoria. Los
        dispositivos aparecerán en esas direcciones y permanecerán
        en ellas hasta que se vuelva a reinicializar la máquina.</para>

        <para>Todo el proceso se ha simplificado mucho, pero espero que hayas podido
        hacerte una idea del proceso.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>?Soporta FreeBSD arquitecturas diferentes a x86?</para>
      </question>

      <answer>
        <para>Diferentes grupos de personas han expresado su interés en
        trabajar en un port multi-arquitectura de FreeBSD y FreeBSD/AXP
        (ALPHA) es un ejemplo de ese esfuerzo realizado, ahora disponible en
        forma de 3.0 SNAPshot release en
        <link xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/alpha/">ftp://ftp.FreeBSD.org/pub/FreeBSD/alpha</link>.
        El port de ALPHA funciona actualmente en diferentes tipos de máquinas ALPHA,
        entre ellas, AlphaStation, AXPpci, PC164, Miata y Multia. Este port
        todavía no se considera una release completa y no lo será
        hasta que exista una colección completa de herramientas de
        instalación y una distribución completa en cdrom para
        instalació, incluyendo un número razonable de ports y
        packages funcionales. FreeBSD/AXP debe considerarse software de
        calidad BETA en estos momentos. Para más información del
        proyecto, subscríbete a la
        <email>FreeBSD-alpha@FreeBSD.org</email>
        <link linkend="mailing">lista de correo</link>.</para>

        <para>También se ha expresado interés en un port de FreeBSD para
        arquitectura SPARC. Subscríbete a
        <email>FreeBSD-sparc@FreeBSD.org</email>
        <link linkend="mailing">la lista</link> si estás interesado en
        participar en el proyecto. Para discusiones generales en nuevas
        arquitecturas, participa en
        <link linkend="mailing">la lista</link>
        <email>FreeBSD-platforms@FreeBSD.org</email>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Necesito un numero de dispositivo para un driver propio</para>
      </question>

      <answer>
        <para>Esto depende de si quieres hacer que el driver esté
        públicamente disponible. Si la respuesta es afirmativa, por favor,
        envianos una copia del código fuente del driver y las
        modificaciones apropiadas del archivo <emphasis remap="tt">files.i386</emphasis>,
        un ejemplo de configuración y el código apropiado de
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?MAKEDEV">MAKEDEV</link> para
        crear cualquier archivo especial que use tu dispositivo. Puedes enviar
        todo lo necesario a <email>FreeBSD-hackers@FreeBSD.org</email>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Alternativas a la política de directorios</para>
      </question>

      <answer>
        <para>En respuesta a esta pregunta de políticas alternativas
        para los directorios, el esquema que está actualmente en uso
        no ha cambiado desde que lo escribí en 1983. Escribí esa
        política para el sistema de archivos rápido original, y
        nunca se ha revisado. Trabaja bién manteniendo los grupos de
        cilindros. Como muchos de vosotros habreis notado, el rendimiento es
        muy pobre con "find". Muchos sistemas de archivos son creados desde
        archivos que fueron creados por una primera búsqueda en
        profundidad (también conocido como ftw). Estos directorios
        terminan esparcidos a través de los grupos de cilindros. Si
        conociesemos el número total de directorios a crear, la
        solución sería  crear (total / fs_ncg) por grupo de
        cilindros antes de moverlos. Obviamente, tendriamos que crear
        algún tipo de heurística para adivinar este número.
        Usando un número pequeño fijo (como puede ser
        10) haría de orden de magnitud. Para diferencial restores de
        operaciones normales (cuando el algoritmo actual es probablemente
        más sensible), podrís usar el clustering hasta 10 si
        fueran todos hechos dentro de una ventana de diez segundos. De cualquier
        manera, mi conclusión es que este es un área para la
        experimentación.</para>

        <para>Kirk McKusick, Septiembre 1998</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Obtener todo lo posible de un "kernel panic"</para>
      </question>

      <answer>
        <para><emphasis>[Esta sección fue extraida de un mensaje escrito
        por <link xlink:href="mailto:wpaul@FreeBSD.org">Bill Paul</link> en la
        <link linkend="mailing">lista</link> FreeBSD-current por
        <link xlink:href="mailto:des@FreeBSD.org">Dag-Erling Co&iuml;dan Sm&oslash;rgrav</link>,
        quién a fijado algunos errores y añadido algunos comentarios
        entre corchetes]</emphasis></para>

        <para>
        <literallayout>From: Bill Paul &lt;wpaul@skynet.ctr.columbia.edu&gt;
        Subject: Re: the fs fun never stops
        To: ben@rosengart.com
        Date: Sun, 20 Sep 1998 15:22:50 -0400 (EDT)
        Cc: current@FreeBSD.org
        </literallayout>
        </para>

        <para><emphasis>[&lt;ben@rosengart.com&gt; envió el siguiente
        panic]</emphasis>
        <literallayout>&gt; Fatal trap 12: page fault while in kernel mode
        &gt; fault virtual address   = 0x40
        &gt; fault code              = supervisor read, page not present
        &gt; instruction pointer     = 0x8:0xf014a7e5
                                        ^^^^^^^^^^
        &gt; stack pointer           = 0x10:0xf4ed6f24
        &gt; frame pointer           = 0x10:0xf4ed6f28
        &gt; code segment            = base 0x0, limit 0xfffff, type 0x1b
        &gt;                         = DPL 0, pres 1, def32 1, gran 1
        &gt; processor eflags        = interrupt enabled, resume, IOPL = 0
        &gt; current process         = 80 (mount)
        &gt; interrupt mask          =
        &gt; trap number             = 12
        &gt; panic: page fault
        </literallayout>
        </para>

        <para>[Cuando] ves un mensaje como este, no es suficiente con solo
        reproducirlo y enviarlo. El valor del puntero de instrucciones que
        he marcado arriba es importante; desafortunadamente, depende de la
        configuración. En otras palabras, el valor varía
        dependiendo de la imáden de kernel exacta que se use. Si
        estás usando el kernel GENERIC de uno de los snapshots, entonces
        es posible que alguien pueda seguir la función
        problemática, pero si estás usando un kernel
        personalizado, entonces solo <emphasis>tú</emphasis> puedes decirnos donde
        ha ocurrido el fallo.</para>

        <para>Tendrías que hacer lo siguiente:</para>

        <para>
        <itemizedlist>
          <listitem>
            <para>Anotar el valor del puntero de la instrucción. Ten en
            cuenta la parte <literal>0x8:</literal> al inicio no es significante
            en este caso: es la parte <literal>0xf0xxxxxx</literal> la que queremos.</para>
          </listitem>

          <listitem>
            <para>Cuando el sistema rearranca, haz lo siguiente:
            <literallayout>
              % nm /kernel.that.caused.the.panic | grep f0xxxxxx
            </literallayout>

            donde <literal>f0xxxxxx</literal> es el valor del puntero de la
            instrucción. El problema es que no obtendrás una
            búsqueda exacta ya que los símbolos en la tabla de
            símbolos del kernel son para los puntos de entrada de las
            funciones y la dirección
            del puntero de la instrucción estará en algún
            lugar dentro de una función, no al principio. Si no obtienes
            un resultado exacto, omite el último dígito del valor
            del puntero de la instrucción e intentalo otra vez, por
            ejemplo:
            <literallayout>
              % nm /kernel.that.caused.the.panic | grep f0xxxxx
            </literallayout>

            Si esto no da ningún resultado, elimina otro dígito.
            Repite la operación hasta que obtengas algún tipo de
            salida. El resultado será una lista de posibles funciones
            que causan el panic. Este no es un sistema muy exacto de
            búsqueda de errores, pero es mejor que nada.</para>
          </listitem>
        </itemizedlist>
        </para>

        <para>Veo gente que constantemente envía mensajes de panics como
        este, pero raramente veo que alguien se tome el tiempo de buscar
        la coincidencia entre el puntero de instrucción y una
        función en la tabla de símbolos del kernel.</para>

        <para>La mejor manera de hacer el seguimiento de la causa de un panic es
        capturar un "crash dump", usando <command>gdb(1)</command> para hacer una traza del
        "crash dump". Por supuesto, esto depende de que <command>gdb(1)</command> funcione
        correctamente en -current, lo que no puedo garantizar (recuerdo que
        alguien ha comentado que el nuevo <command>gdb(1)</command> en formato ELF no
        manejaba bién los "dumps" de un crash del kernel; alguién
        debería mirar esto antes de que la 3.0 salga del estado beta).</para>

        <para>En cualquier caso, el método que normalmente uso es este:</para>

        <para>
        <itemizedlist>
          <listitem>
            <para>Crear un archivo de configuración de kernel, opcionalmente
            añadiendo 'options DDB' si piensas que necesitas el debugger
            del kernel por algún motivo. (Uso esto principalmente para
            configurar puntos de salida si sospecho que existe alguna
            condición que crea un loop infinito).</para>
          </listitem>

          <listitem>
            <para>Usar <command>config -g KERNELCONFIG</command> para crear el directorio
            de configuración del kernel.</para>
          </listitem>

          <listitem>
            <para><command>cd /sys/compile/KERNELCONFIG; make</command></para>
          </listitem>

          <listitem>
            <para>Esperar a que el kernel termine de compilar.</para>
          </listitem>

          <listitem>
            <para><emphasis remap="tt">cp kernel kernel.debug</emphasis></para>
          </listitem>

          <listitem>
            <para><command>strip -d kernel</command></para>
          </listitem>

          <listitem>
            <para><emphasis remap="tt">mv </emphasis>kernel /kernel.orig/</para>
          </listitem>

          <listitem>
            <para><command>cp kernel /</command></para>
          </listitem>

          <listitem>
            <para>reboot</para>
          </listitem>
        </itemizedlist>
        </para>

        <para><emphasis>[Nota: ahora que los kernels de FreeBSD 3.x son ELF por defecto
        debes usar <command>strip -g</command> en lugar de <command>strip -d</command>.
        Si por algún motivo tu kernel es aún a.out, usa
        <command>strip -aout -d</command>.]</emphasis></para>

        <para>Ten en cuenta que TU <acronym>NO</acronym> QUIERES ARRANCAR CON UN
        KERNEL QUE TIENE TODOS LOS SIMBOLOS DE DEBUG EN EL. Un kernel compilado
        con <option>-g</option> puede llegar facilmente a los 10MB de tamaño.
        No tienes que arrancar esta imán masiva, solo lo necesitas para poder usar
        después <command>gdb(1)</command> (<command>gdb(1)</command> quiere
        la tabla de símbolos). Al contrario, quieres mantener una copia de la
        imágen completa y crear una segunda imágen con los
        símbolos de debug desactivados usando <command>strip -d</command>. Es esta
        segunda imágen la que quieres arrancar.</para>

        <para>Para asegurarte de capturar un "crash dump", necesitas editar el
        archivo <filename>/etc/rc.conf</filename> y apuntar
        <emphasis remap="tt">dumpdev</emphasis> a tu
        partición de swap. Esto hará que el script <command>rc(8)</command>
        use el comando <command>dumpon(8)</command> para activar los "crash dumps".
        También puedes ejecutar manualmente <command>dumpon(8)</command>.
        Después de un panic, el "crash dump" puede ser recuperado usando
        <command>savecore(8)</command>; si <emphasis remap="tt">dumpdev</emphasis>
        está en <filename>/etc/rc.conf</filename>, el script
        <command>rc(8)</command> ejecutará <command>savecore(8)</command>
        automaticamente y pondrá el "crash dump" en
        <filename>/var/crash</filename>.</para>

        <para>NOTA: los "crash dumps" de FreeBSD suelen tener el mismo
        tamaño que la cantidad total de memoria física del
        sistema. Esto significa que si tienes 64MB de RAM, obtendrás
        un "crash dump" de 64MB. Debido a esto, tienes que asegurarte de tener
        suficiente espacio libre en <filename>/var/crash</filename>.
        Alternativamente puedes ejecutar <command>savecore(8)</command>
        manualmente y hacer la recuparación en otro directorio donde
        tengas más espacio libre. Es posible limitar el tamaño
        del "crash dump" usando <literal>options MAXMEM=(foo)</literal>
        para indicar la cantidad de memoria que el kernel puede ocupar. Por
        ejemplo, si tienes 128MB de RAM, puedes limitar el uso de memoria del
        kernel a 16MB para que el "crash dump" sea de 16MB y no de 128MB.</para>

        <para>Una vez hayas recuperado el "crash dump", puedes obtener una traza
        del stack con <command>gdb(1)</command> de la manera siguiente:</para>

        <para>
        <literallayout>
          % gdb -k /sys/compile/KERNELCONFIG/kernel.debug /var/crash/vmcore.0
          (gdb) where
        </literallayout>
        </para>

        <para>Es posible que aparezcan muchas líneas de información:
        es una buena idea usar el comando <command>script(1)</command> para capturarlas
        todas. Usando la imágen del kernel con todos los símbolos
        de debug deberí mostrar la línea exacta de código
        fuente del kernel donde ha ocurrido el panic. Normalmente, tienes que
        leer la traza del stack de abajo hacia arriba para poder conocer la
        secuencia exacta de eventos que han provocado el crash. También
        puedes usar <command>gdb(1)</command> para mostrar los contenidos de las diferentes
        variables o estructuras para examinar el estado del sistema en el
        momento del crash.</para>

        <para>Ahora, si eres realmente curioso y tienes un segundo computador,
        puedes configurar <command>gdb(1)</command> para hacer un debug remoto de manera
        que puedes usar <command>gdb(1)</command> en un sistema para revisar el kernel
        de otro sistema, de la misma manera que lo harías en la
        máquina local.</para>

        <para><emphasis>[Bill añade: "Olvidé mencionar una cosa: si tienes
        DDB activado, puedes forzar un panic (y un crash dump)  tecleando
        "panic" en el prompt del ddb. Es posible que el debugger se pare
        durante la fase del panic. Si esto ocurre, teclea "continue" y el
        crash dump finalizará"]</emphasis></para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>dlsym() no funciona con ejecutables ELF!</para>
      </question>

      <answer>
        <para>Las herramientas ELF no hacen por defecto que los símbolos
        definidos en un ejecutable sean visibles por el linker dinámico.
        Consecuentemente, <function>dlsym()</function> buscará en datos
        obtenidos desde llamadas a <emphasis remap="tt">dlopen(NULL, flags)</emphasis>,
        lo que provoca que no se encuentren esos símbolos.</para>

        <para>Si quieres buscar, usando <function>dlsym()</function> símbolos
        presentes en el ejecutable principal de un proceso, necesitas linkar el
        ejecutable usando la opción <option>-export-dynamic</option> en el
        <link xlink:href="http://www.FreeBSD.org/cgi/man.cgi?ld">linkador ELF</link>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
        <para>Incrementando o reduciendo el espacio de direcciones del kernel</para>
      </question>

      <answer>
        <para>Por defecto, el espacio de direcciones del kernel es de 256MB en
        FreeBSD 3.x y 1GB en FreeBSD 4.x. Si gestionas un servidor de red
        muy cargado (por ejemplo, servidores FTP o HTTP con mucho
        tráfico), es posible que notes que 256MB no es
        suficiente.</para>

        <para>Así que... como incremento el espacio de direcciones?. Hay
        dos aspectos a tener en cuenta. Primero, necesitas indicarle al kernel
        que reserve una mayor parte del espacio de direcciones para él
        mismo. Segundo, ya que el kernel se carga al inicio del espacio de
        direcciones, necesitas disminuir la dirección de carga.</para>

        <para>El primer aspecto lo solucionamos incrementando el valor de
        <acronym>NKPDE</acronym> en <filename>src/sys/i386/include/pmap.h</filename>.
        Esta es una entrada de ejemplo para 1GB de espacio de direcciones:</para>

        <para>
        <literallayout>
          #ifndef NKPDE
          #ifdef SMP
          #define NKPDE                   254     /* addressable number of page tables/pde's */
          #else
          #define NKPDE                   255     /* addressable number of page tables/pde's */
          #endif  /* SMP */
          #endif
        </literallayout>
        </para>

        <para>Para encontrar el valor correcto de <acronym>NKPDE</acronym>,
        divide el espacio de direcciones deseado (en megabytes) por cuatro,
        después resta uno por UP y dos por SMP.</para>

        <para>Para solucionar el segundo aspecto, necesitas calcular la
        dirección correcta de carga: simplemente resta el tamaño
        del espacio de direcciones (en bytes) de 0x100100000; el resultado
        es 0xc0100000 para 1GB de espacio de direcciones. Ajusta
        <symbol>LOAD_ADDRESS</symbol> en
        <filename>src/sys/i386/conf/Makefile.i386</filename> a ese
        valor; a continuación pon el contador al inicio de la
        sección listado en <filename>src/sys/i386/conf/kernel.script</filename>
        al mismo valor, como sigue:</para>

        <para>
        <literallayout>
          OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
          OUTPUT_ARCH(i386)
          ENTRY(btext)
          SEARCH_DIR(/usr/lib); SEARCH_DIR(/usr/obj/elf/home/src/tmp/usr/i386-unknown-FreeBSDelf/lib);
          SECTIONS
          {
            /* Read-only sections, merged into text segment: */
            . = 0xc0100000 + SIZEOF_HEADERS;
            .interp     : { *(.interp)    }
        </literallayout>
        </para>

        <para>Reconfigura y compila el kernel. Probablemente tengas problemas con
        <command>top(1)</command>, <command>ps(1)</command> y programas así
        haciendo un <emphasis remap="tt">make world</emphasis> deberín
        solucionarse esos problemas (o una recompilación manual de
        <emphasis remap="tt">libkvm</emphasis>, <emphasis remap="tt">ps</emphasis> y
        <emphasis remap="tt">top</emphasis> después de copiar el
        <filename>pmap.h</filename> parcheado a <filename>/usr/include/vm/</filename>.
        </para>

        <para>NOTA: el tamaño del espacio de direcciones debe ser un
        múltiplo de cuatro megabytes.</para>

        <para><emphasis>[<link xlink:href="mailto:dg@FreeBSD.org">David Greenman</link>
        añade: </emphasis>Pienso que el espacio de direcciones del kernel
        necesita ser una potencia de 2, pero no estoy totalmente seguro.]</para>
      </answer>
    </qandaentry>
  </qandaset>
</chapter>

<chapter xml:id="acknowledgments">
<title>AGRADECIMIENTOS</title>

  <para>
  <literallayout>
    Si ves algún problema o error en esta FAQ, o quieres enviar
    información para que sea añadida, por favor, envía
    un mail a la dirección faq-es@es.FreeBSD.org. Apreciamos tu
    información e interés, y no podemos hacer una FAQ mejor
    sin tu ayuda.


                                      FreeBSD Spanish Documentation Project.
  </literallayout>
  </para>

  <para>
  <variablelist>
    <varlistentry>
      <term>Cristobal Talavera (cristobal@es.FreeBSD.org)</term>
      <listitem>
        <para>Por haber obtenido la libertad :)</para>
        <para/>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>David Casademunt (david@es.FreeBSD.org)</term>
      <listitem>
        <para>No hay hardware que se le resista.</para>
        <para/>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Nik Clayton (nik@FreeBSD.org)</term>
      <listitem>
        <para>Gracias a su ayuda todo esto ha sido posible.</para>
        <para/>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Nexus Comunicacaciones (www.ncsa.es)</term>
      <listitem>
        <para>Por mantener el mirror y darme las facilidades para hacer todo esto.</para>
        <para/>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Oscar Colet (oscarc@abaforum.es)</term>
      <listitem>
        <para>Por aguantar lo que tiene que aguantar.</para>
        <para/>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Jordan Hubbard</term>
      <listitem>
        <para>Actualizaciones y entradas ocasionales.</para>
        <para/>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Doug White</term>
      <listitem>
        <para>Recopilaciones y respuestas en FreeBSD-questions.</para>
        <para/>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Joerg Wunsch</term>
      <listitem>
        <para>Recopilaciones y respuestas en las news.</para>
        <para/>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Garrett Wollman</term>
      <listitem>
        <para>Redes.</para>
        <para/>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Jim Lowe</term>
      <listitem>
        <para>Información sobre multicast.</para>
        <para/>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Peter da Silva</term>
      <listitem>
        <para>"Machaca de las teclas" de FreeBSD FAQ</para>
        <para/>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>The FreeBSD Team</term>
      <listitem>
        <para>De todo.</para>
      </listitem>
    </varlistentry>
  </variablelist>
  </para>

  <para>y para todos los que hemos olvidado, disculpas y muchas gracias por
  todo!.</para>

  <para>Jesús Rodríguez
  <link xlink:href="mailto:jesusr@FreeBSD.org">jesusr@FreeBSD.org</link></para>
</chapter>
</book>
