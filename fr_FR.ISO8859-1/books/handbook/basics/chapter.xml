<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD French Documentation Project

     $FreeBSD$
     Original revision: 1.152
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="basics">
  <info><title>Quelques bases d'UNIX</title>
    <authorgroup>
      <author><personname><firstname>Chris</firstname><surname>Shumway</surname></personname><contrib>Réécrit par </contrib></author>
    </authorgroup>
    
  </info>

  
  &trans.a.fonvieille;

  <sect1 xml:id="basics-synopsis">
    <title>Synopsis</title>

   <para>Le chapitre suivant couvrira les commandes et fonctionnalités
     de base du système d'exploitation FreeBSD.  La plupart de ces
     informations sera valable pour n'importe quel système
     d'exploitation &unix;.  Soyez libre de passer ce chapitre si vous
     êtes familier avec ces informations.  Si vous êtes nouveau
     &agrave;
     FreeBSD, alors vous voudrez certainement lire attentivement ce
     chapitre.</para>

    <para>Après la lecture de ce chapitre, vous saurez:</para>

    <itemizedlist>
      <listitem>
	<para>Comment utiliser les &ldquo;consoles virtuelles&rdquo;
	  de &os;.</para>
      </listitem>
      <listitem>
	<para>Comment les permissions des fichiers d'&unix;
	  fonctionnent ainsi que l'utilisation des indicateurs de
	  fichiers sous &os;.</para>
      </listitem>
      <listitem>
	<para>L'architecture par défaut du système de
	  fichiers sous &os;.</para>
      </listitem>
      <listitem>
	<para>L'organisation des disques sous &os;.</para>
      </listitem>
      <listitem>
	<para>Comment monter et démonter des systèmes de
	  fichier.</para>
      </listitem>
      <listitem>
	<para>Ce que sont les processus, daemons et signaux.</para>
      </listitem>
      <listitem>
	<para>Ce qu'est un interpréteur de commande, et comment
	  changer votre environnement de session par
	  défaut.</para>
      </listitem>
      <listitem>
	<para>Comment utiliser les éditeurs de texte de base.</para>
      </listitem>
      <listitem>
	<para>Ce que sont les périphériques et les
	  fichiers spéciaux de périphérique.</para>
      </listitem>
      <listitem>
	<para>Quel est le format des binaires utilisé sous
	  &os;.</para>
      </listitem>
      <listitem>
	<para>Comment lire les pages de manuel pour plus
	  d'information.</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 xml:id="consoles">
    <title>Consoles virtuelles &amp; terminaux</title>
    <indexterm><primary>consoles virtuelles</primary></indexterm>
    <indexterm><primary>terminaux</primary></indexterm>

    <para>FreeBSD peut être utilisé de diverses façons.
      L'une d'elles est en tapant des commandes sur un terminal
      texte.  Une bonne partie de la flexibilité et de la puissance
      d'un système d'exploitation &unix; est directement
      disponible sous vos mains en utilisant FreeBSD de cette manière.
      Cette section décrit ce que sont les &ldquo;terminaux&rdquo; et
      les &ldquo;consoles&rdquo;, et comment les utiliser sous
      FreeBSD.</para>

    <sect2 xml:id="consoles-intro">
      <title>La console</title>
      <indexterm><primary>console</primary></indexterm>

      <para>Si vous n'avez pas configuré FreeBSD pour lancer
	automatiquement un environnement graphique au démarrage, le
	système vous présentera une invite d'ouverture de session
	après son démarrage, juste après la fin des
	procédures de démarrage.  Vous verrez quelque chose
	de similaire &agrave;:</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:</screen>

      <para>Les messages pourront être différents sur votre
	système, mais cela devrait y ressembler.  Les deux
	dernières lignes sont celles qui nous intéressent
	actuellement.  La seconde de ces lignes nous donne:</para>

      <programlisting>FreeBSD/i386 (pc3.example.org) (ttyv0)</programlisting>

      <para>Cette ligne contient quelques éléments d'information
	sur le système que vous venez de démarrer.  Vous
	êtes en train de lire une console &ldquo;FreeBSD&rdquo;,
	tournant sur un processeur Intel ou compatible de la famille
	x86<footnote>
	  <para>C'est ce que signifie <literal>i386</literal>.  Notez
	    que même si vous ne faites pas tourner FreeBSD sur un CPU Intel
	    386, cela sera <literal>i386</literal>.  Ce n'est pas le
	    type de votre microprocesseur, mais
	    &ldquo;l'architecture&rdquo; du microprocesseur qui est
	    donnée ici.</para>
	</footnote>.  Le nom de cette machine (chaque machine &unix;
	a un nom) est <systemitem>pc3.example.org</systemitem>, et vous
	regardez actuellement sa console système&mdash;le terminal
	<filename>ttyv0</filename>.</para>

      <para>Et enfin, la dernière ligne est toujours:</para>

      <programlisting>login:</programlisting>

      <para>C'est le moment où vous êtes supposé
	taper votre &ldquo;nom d'utilisateur&rdquo; pour vous
	attacher au système FreeBSD.  La section suivante décrit
	comment procéder.</para>
    </sect2>

    <sect2 xml:id="consoles-login">
      <title>Ouvrir une session sur un système FreeBSD</title>

      <para>FreeBSD est un système multi-utilisateur,
	multi-processeur.  C'est la description formelle qui est
	habituellement donnée pour un système qui peut
	être utilisé par différentes personnes,
	qui exécutent simultanément de nombreux programmes sur une
	machine individuelle.</para>

      <para>Chaque système multi-utilisateur a besoin d'un moyen pour
	distinguer un &ldquo;utilisateur&rdquo; du reste.  Sous
	FreeBSD (et sous tous les systèmes de type &unix;),
	cela est effectué en demandant &agrave; chaque utilisateur de
	&ldquo;s'attacher&rdquo; au système avant d'être en
	mesure d'exécuter des programmes.  Chaque utilisateur
	possède un nom unique (le nom d'utilisateur) et une clé
	secrète personnelle (le mot de passe).  FreeBSD demandera ces
	deux éléments avant d'autoriser un utilisateur &agrave;
	lancer un programme.</para>

      <indexterm><primary>procédures de démarrage</primary></indexterm>
      <para>Juste après que FreeBSD ait démarré et
	en ait terminé avec l'exécution des procédures de
	démarrage<footnote>
	  <para>Les procédures de démarrage sont des programmes
	    qui sont exécutés automatiquement par FreeBSD au
	    démarrage.  Leur fonction principale est de configurer le
	    système pour permettre l'exécution de tout programme,
	    et de démarrer tout service que vous avez configuré pour
	    tourner en tâche de fond et exécuter des choses
	    utiles.</para>
	</footnote>, il présentera une invite et demandera un nom
	d'utilisateur valide:</para>

      <screen>login:</screen>

      <para>Pour cet exemple, supposons que votre nom d'utilisateur
	est <systemitem class="username">john</systemitem>.  Tapez
	<systemitem class="username">john</systemitem> &agrave; cette invite puis appuyez sur
	<keycap>Entrée</keycap>.  Alors vous devrez être
	invité &agrave; entrer un &ldquo;mot de passe&rdquo;:</para>

      <screen>login: <userinput>john</userinput>
Password:</screen>

      <para>Tapez maintenant le mot de passe de <systemitem class="username">john</systemitem>,
	et appuyez sur <keycap>Entrée</keycap>.  Le mot de passe
	<emphasis>n'est pas affiché!</emphasis>  Vous n'avez pas &agrave;
	vous préoccuper de cela maintenant.  Il suffit de penser que
	cela est fait pour des raisons de sécurité.</para>

      <para>Si vous avez tapé correctement votre mot de passe,
	vous devriez être maintenant attaché
	au système et prêt &agrave; essayer toutes les commandes
	disponibles.</para>

      <para>Vous devriez voir apparaître le <acronym>MOTD</acronym>
	ou message du jour suivi de l'invite de commande (un
	caractère <literal>#</literal>, <literal>$</literal>, ou
	<literal>%</literal>).  Cela indique que vous avez ouvert
	avec succès une session sous &os;.</para>
    </sect2>

    <sect2 xml:id="consoles-virtual">
      <title>Consoles multiples</title>

      <para>Exécuter des commandes &unix; dans une console est bien
	beau, mais FreeBSD peut exécuter plusieurs programmes
	&agrave; la fois.  Avoir une seule console sur laquelle les commandes
	peuvent être tapées serait un peu du gaspillage quand
	un système d'exploitation comme FreeBSD peut exécuter des
	dizaines de programmes en même temps.  C'est ici que des
	&ldquo;consoles virtuelles&rdquo; peuvent être vraiment
	utiles.</para>

      <para>FreeBSD peut être configuré pour présenter
	de nombreuses consoles virtuelles.  Vous pouvez basculer
	d'une console virtuelle &agrave; une autre en utilisant une
	combinaison de touches sur votre clavier.  Chaque console
	a son propre canal de sortie, et FreeBSD prend soin de
	rediriger correctement les entrées au clavier et la sortie
	vers écran quand vous basculez d'une console virtuelle &agrave;
	la suivante.</para>

      <para>Des combinaisons de touches spécifiques ont
	été réservées par FreeBSD pour le
	basculement entre consoles<footnote>
	  <para>Une description assez technique et précise de tous
	    les détails de la console FreeBSD et des pilotes de
	    clavier peut être trouvée dans les pages de manuel de
	    &man.syscons.4;, &man.atkbd.4;, &man.vidcontrol.1;
	    et &man.kbdcontrol.1;.  Nous ne nous étendrons pas
	    en détails ici, mais le lecteur intéressé peut
	    toujours consulter les pages de manuel pour explication plus
	    détaillée et plus complète sur le
	    fonctionnement des choses.</para>
	</footnote>.  Vous pouvez utiliser
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo>,
	jusqu'&agrave;
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo>
	pour basculer vers une console virtuelle différente sous
	FreeBSD.</para>

      <para>Quand vous basculez d'une console &agrave; une autre, FreeBSD
	prend soin de sauvegarder et restaurer la sortie d'écran.
	Il en résulte l'&ldquo;illusion&rdquo; d'avoir plusieurs
	écrans et claviers &ldquo;virtuels&rdquo; que vous pouvez
	utiliser pour taper des commandes pour FreeBSD.  Les
	programmes que vous lancez sur une console virtuelle ne
	cessent pas de tourner quand cette console n'est plus visible.
	Ils continuent de s'exécuter quand vous avez
	basculé vers une console virtuelle différente.</para>
    </sect2>

    <sect2 xml:id="consoles-ttys">
      <title>Le fichier <filename>/etc/ttys</filename></title>

      <para>La configuration par défaut de FreeBSD démarre avec huit
	consoles virtuelles.  Cependant ce n'est pas un paramétrage
	fixe, et vous pouvez aisément personnaliser votre installation
	pour démarrer avec plus ou moins de consoles virtuelles.  Le
	nombre et les paramétrages des consoles virtuelles sont
	configurés dans le fichier
	<filename>/etc/ttys</filename>.</para>

      <para>Vous pouvez utiliser le fichier
	<filename>/etc/ttys</filename> pour configurer les consoles
	virtuelles de FreeBSD.  Chaque ligne non-commentée dans ce fichier
	(les lignes qui ne débutent pas par le caractère
	<literal>#</literal>) contient le paramétrage d'un terminal ou
	d'une console virtuelle.  La version par défaut de ce
	fichier livrée avec FreeBSD configure neuf consoles virtuelles,
	et en active huit.  Ce sont les lignes commençant avec le terme
	<literal>ttyv</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>Pour une description détaillée de chaque colonne
	de ce fichier et toutes les options que vous pouvez utiliser
	pour configurer les consoles virtuelles, consultez la page de
	manuel &man.ttys.5;.</para>
    </sect2>

    <sect2 xml:id="consoles-singleuser">
      <title>Console en mode mono-utilisateur</title>

      <para>Une description détaillée de ce qu'est
	<quote>le mode mono-utilisateur</quote> peut être
	trouvée dans <xref linkend="boot-singleuser"/>.  Il est
	important de noter qu'il n'y a qu'une console de disponible
	quand vous exécutez FreeBSD en mode mono-utilisateur.  Il n'y
	a aucune console virtuelle de disponible.  Le paramétrage de
	la console en mode mono-utilisateur peut être
	également trouvé dans le fichier
	<filename>/etc/ttys</filename>.  Recherchez la ligne qui
	commence avec le mot <literal>console</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off secure</programlisting>

      <note>
        <para>Comme l'indiquent les commentaires au-dessus de la ligne
	  <literal>console</literal>, vous pouvez éditer cette ligne
	  et changer <literal>secure</literal> pour
	  <literal>insecure</literal>.  Si vous faites cela, quand
	  FreeBSD démarrera en mode mono-utilisateur, il demandera le
	  mot de passe de <systemitem class="username">root</systemitem>.</para>

	<para><emphasis>Cependant faites attention quand vous modifiez
	  cela pour <literal>insecure</literal>.</emphasis>  Si vous
	  oubliez le mot de passe de <systemitem class="username">root</systemitem>, le
	  démarrage en mode mono-utilisateur sera condamné.
	  Il est encore possible, mais cela pourra être relativement
	  compliqué pour quelqu'un qui n'est pas &agrave; l'aise avec le
	  processus de démarrage de FreeBSD et les programmes entrant
	  en jeu.</para>
      </note>
    </sect2>

    <sect2 xml:id="consoles-vidcontrol">
      <title>Modifier la résolution de la console</title>

      <para>La résolution (ou encore le mode vidéo) de
	la console &os; peut être réglée &agrave;
	1024x768, 1280x1024, ou tout autre résolution
	supportée par le circuit graphique et le moniteur.
	Pour utiliser une résolution vidéo
	différente vous devez en premier lieu recompiler votre
	noyau en ajoutant deux options supplémentaires:</para>

      <programlisting>options VESA
options SC_PIXEL_MODE</programlisting>

      <para>Une fois votre noyau recompilé avec ces deux
	options, vous pouvez déterminer quels sont les modes
	vidéo supportés par votre matériel en
	utilisant l'outil &man.vidcontrol.1;.  Pour obtenir une liste
	des modes supportés, tapez la ligne suivante:</para>

      <screen>&prompt.root; <userinput>vidcontrol -i mode</userinput></screen>

      <para>La sortie de cette commande est une liste des modes
	vidéo que supporte votre matériel.  Vous pouvez
	ensuite décider d'utiliser un nouveau mode en le
	passant &agrave; la commande &man.vidcontrol.1; tout en ayant
	les droits de <systemitem class="username">root</systemitem>:</para>

      <screen>&prompt.root; <userinput>vidcontrol MODE_279</userinput></screen>

      <para>Si le nouveau mode vidéo est satisfaisant, il peut
	être activé au démarrage de manière
	permanente en le configurant dans le fichier
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>allscreens_flags="MODE_279"</programlisting>
    </sect2>
  </sect1>

  <sect1 xml:id="permissions">
    <title>Permissions</title>
    <indexterm><primary>UNIX</primary></indexterm>

    <para>FreeBSD, étant un descendant direct de l'&unix; BSD, est
      basé sur plusieurs concepts clés d'&unix;.  Le premier,
      et le plus prononcé, est le fait que FreeBSD est un
      système d'exploitation multi-utilisateurs.  Le système
      peut gérer plusieurs utilisateurs travaillant tous
      simultanément sur des tâches complètement
      indépendantes.  Le système est responsable du partage
      correct et de la gestion des requêtes pour les
      périphériques matériels, la mémoire,
      et le temps CPU de façon équitable entre chaque
      utilisateur.</para>

    <para>Puisque le système est capable de supporter des utilisateurs
      multiples, tout ce que le système gère possède un
      ensemble de permissions définissant qui peut écrire, lire,
      et exécuter la ressource.  Ces permissions sont stockées
      sous forme de trois octets divisés en trois parties, une pour le
      propriétaire du fichier, une pour le groupe auquel appartient le
      fichier, et une autre pour le reste du monde.
      Cette représentation numérique fonctionne comme
      ceci:</para>

    <indexterm><primary>permissions</primary></indexterm>
    <indexterm>
      <primary>permissions de fichier</primary>
    </indexterm>
    <informaltable frame="none" pgwide="1">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Valeur</entry>
	    <entry>Permission</entry>
	    <entry>Contenu du répertoire</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>Pas d'accès en lecture, pas d'accès en
	      écriture,
	      pas d'accès en exécution</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>Pas d'accès en lecture, pas d'accès en
	      écriture, exécution</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>Pas d'accès en lecture, écriture, pas
	      d'accès en exécution</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>Pas d'accès en lecture, écriture,
	      exécution</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Lecture, pas d'accès en écriture, pas
	      d'accès en exécution</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Lecture, pas d'accès en écriture,
	      exécution</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Lecture, écriture, pas d'accès en
	      exécution</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Lecture, écriture, exécution</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>répertoires</primary></indexterm>

    <para>Vous pouvez utiliser l'option <option>-l</option> avec la
      commande &man.ls.1; pour afficher le contenu du répertoire
      sous forme une longue et détaillée qui inclut une colonne
      avec des informations sur les permissions d'accès des fichiers
      pour le propriétaire, le groupe, et le reste du monde.
      Par exemple un <command>ls -l</command> dans un répertoire
      quelconque devrait donner:</para>

   <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...</screen>

    <para>Voici
      comment est divisée la première colonne de l'affichage
      généré par <command>ls -l</command>:</para>

    <screen>-rw-r--r--</screen>

    <para>Le premier caractère (le plus &agrave; gauche) indique
      si c'est un fichier normal, un répertoire, ou
      un périphérique mode caractère,
      une socket, ou tout autre pseudo-périphérique.
      Dans ce cas, <literal>-</literal>
      indique un fichier normal.  Les trois caractères suivants,
      <literal>rw-</literal> dans cet exemple, donnent les
      permissions pour le propriétaire du fichier.  Les trois
      caractères qui suivent, <literal>r--</literal>, donnent les
      permissions pour le groupe auquel appartient le fichier.
      Les trois derniers caractères, <literal>r--</literal>,
      donnent les permissions pour le reste du
      monde. Un tiret signifie que la permission est désactivée.
      Dans le cas de ce fichier, les permissions sont telles que le
      propriétaire peut lire et écrire le fichier, le groupe
      peut lire le fichier, et le reste du monde peut seulement lire le fichier.
      D'après la table ci-dessus, les permissions pour ce fichier
      seraient <literal>644</literal>, où chaque chiffre
      représente les
      trois parties des permissions du fichier.</para>

    <para>Tout cela est bien beau, mais comment le système
      contrôle les permissions sur les périphériques?
      En fait FreeBSD traite la plupart des périphériques
      sous la forme d'un fichier que les programmes peuvent ouvrir, lire,
      et écrire des données dessus comme tout autre fichier.
      Ces périphériques spéciaux sont stockés
      dans le répertoire <filename>/dev</filename>.</para>

    <para>Les répertoires sont aussi traités comme des fichiers.
      Ils ont des droits en lecture, écriture et exécution.
      Le bit d'exécution pour un répertoire a une signification
      légèrement différente que pour les fichiers.
      Quand un répertoire est marqué exécutable, cela
      signifie qu'il peut être traversé, i.e. il est possible
      d'utiliser &ldquo;cd&rdquo; (changement de répertoire).  Ceci signifie également qu'&agrave;
      l'intérieur du répertoire il est possible d'accéder
      aux fichiers dont les noms sont connus (en fonction, bien sûr,
      des permissions sur les fichiers eux-mêmes).</para>

    <para>En particulier, afin d'obtenir la liste du
      contenu d'un répertoire, la permission de lecture doit être
      positionnée sur le répertoire, tandis que pour effacer un
      fichier dont on connaît le nom, il est nécessaire d'avoir
      les droits d'écriture <emphasis>et</emphasis> d'exécution
      sur le répertoire contenant le fichier.</para>

    <para>Il y a d'autres types de permissions, mais elles sont
      principalement employées dans des circonstances
      spéciales comme les binaires &ldquo;setuid&rdquo; et
      les répertoires &ldquo;sticky&rdquo;.  Si
      vous désirez plus d'information sur les permissions de fichier et
      comment les positionner, soyez sûr de consulter la page de manuel
      &man.chmod.1;.</para>

    <sect2>
      <info><title>Permissions symboliques</title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Contribution de </contrib></author>
	</authorgroup>
      </info>

      
      <indexterm><primary>permissions</primary><secondary>symboliques</secondary></indexterm>

      <para>Les permissions symboliques, parfois désignées
	sous le nom d'expressions symboliques, utilisent des
	caractères &agrave; la place de valeur en octal pour
	assigner les permissions aux fichiers et répertoires.
	Les expressions symboliques emploient la syntaxe: (qui)
	(action) (permissions), avec les valeurs possibles
	suivantes:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Option</entry>
	      <entry>Lettre</entry>
	      <entry>Représente</entry>
	    </row>
	  </thead>

	<tbody>
	  <row>
	    <entry>(qui)</entry>
	    <entry>u</entry>
	    <entry>Utilisateur</entry>
	  </row>

	  <row>
	    <entry>(qui)</entry>
	    <entry>g</entry>
	    <entry>Groupe</entry>
	  </row>

	  <row>
	    <entry>(qui)</entry>
	    <entry>o</entry>
	    <entry>Autre</entry>
	  </row>

	  <row>
	    <entry>(qui)</entry>
	    <entry>a</entry>
	    <entry>Tous (<quote>le monde entier</quote>)</entry>
	  </row>

	  <row>
	    <entry>(action)</entry>
	    <entry>+</entry>
	    <entry>Ajouter des permissions</entry>
	  </row>

	  <row>
	    <entry>(action)</entry>
	    <entry>-</entry>
	    <entry>Retirer des permissions</entry>
	  </row>

	  <row>
	    <entry>(action)</entry>
	    <entry>=</entry>
	    <entry>Fixe les permissions de façon explicite</entry>
	  </row>

	  <row>
	    <entry>(permissions)</entry>
	    <entry>r</entry>
	    <entry>Lecture</entry>
	  </row>

	  <row>
	    <entry>(permissions)</entry>
	    <entry>w</entry>
	    <entry>Ecriture</entry>
	  </row>

	  <row>
	    <entry>(permissions)</entry>
	    <entry>x</entry>
	    <entry>Exécution</entry>
	  </row>

	  <row>
	    <entry>(permissions)</entry>
	    <entry>t</entry>
	    <entry>bit collant (sticky)</entry>
	  </row>

	  <row>
	    <entry>(permissions)</entry>
	    <entry>s</entry>
	    <entry>Exécuter avec l'ID utilisateur (UID) ou groupe (GID)</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Ces valeurs sont utilisées avec la commande
      &man.chmod.1; comme précédemment mais avec
      des lettres.  Par exemple, vous pourriez utiliser la commande
      suivante pour refuser l'accès au fichier
      <replaceable>FICHIER</replaceable> &agrave; d'autres
      utilisateurs:</para>

    <screen>&prompt.user; <userinput>chmod go= FICHIER</userinput></screen>

    <para>Une liste séparé par des virgules peut être
      fournie quand plus d'un changement doit être effectué
      sur un fichier.  Par exemple la commande suivante retirera
      les permissions d'écriture au groupe et au &ldquo;reste du
      monde&rdquo; sur le fichier <replaceable>FICHIER</replaceable>,
      puis ajoutera la permission d'exécution pour tout le
      monde:</para>

    <screen>&prompt.user; <userinput>chmod go-w,a+x FICHIER</userinput></screen>

<!--
    <para>La plupart des utilisateurs ne relèveront pas ceci,
      mais il doit être précisé que la
      méthode avec les nombres en octal ne fera que fixer ou
      assigner des permissions &agrave; un fichier; elle n'en ajoutera
      ou n'en supprimera pas.</para>
-->
    </sect2>

    <sect2>
      <info><title>Indicateurs des fichiers sous &os;</title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Contribution de </contrib></author>
	</authorgroup>
      </info>

      

      <para>En addition des permissions sur les fichiers
	précédemment présentées, &os;
	supporte l'utilisation d'<quote>indicateurs de
	fichiers</quote>.  Ces indicateurs rajoutent un niveau de
	contrôle et de sécurité sur les fichiers,
	mais ne concernent pas les répertoires.</para>

      <para>Ces indicateurs ajoutent donc un niveau de contrôle
	supplémentaire des fichiers, permettant d'assurer que
	dans certains cas même le super-utilisateur
	<systemitem class="username">root</systemitem> ne pourra effacer ou modifier des
	fichiers.</para>

      <para>Les indicateurs de fichiers peuvent être
	modifiés avec l'utilitaire &man.chflags.1;, ce dernier
	présentant une interface simple.  Par exemple, pour
	activer l'indicateur système de suppression impossible
	sur le fichier <filename>file1</filename>, tapez la commande
	suivante:</para>

      <screen>&prompt.root; <userinput>chflags sunlink file1</userinput></screen>

      <para>Et pour désactiver l'indicateur de suppression
	impossible, utilisez la commande précédente avec
	le préfixe <quote>no</quote> devant l'option
	<option>sunlink</option>:</para>

      <screen>&prompt.root; <userinput>chflags nosunlink file1</userinput></screen>

      <para>Pour afficher les indicateurs propres &agrave; ce fichier,
	utilisez la commande &man.ls.1; avec l'option
	<option>-lo</option>:</para>

      <screen>&prompt.root; <userinput>ls -lo file1
	</userinput></screen>

      <para>La sortie de la commande devrait ressembler
	&agrave;:</para>

      <programlisting>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1</programlisting>

      <para>Plusieurs indicateurs ne peuvent être
	positionnés ou retirés que par le
	super-utilisateur <systemitem class="username">root</systemitem>.  Dans les autres
	cas, le propriétaire du fichier peut activer ces
	indicateurs.  Pour plus d'information, la lecture des pages de
	manuel &man.chflags.1; et &man.chflags.2; est
	recommandée &agrave; tout administrateur.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="dirstructure">
    <title>Organisation de l'arborescence des répertoires</title>
    <indexterm><primary>hiérarchie des répertoires</primary></indexterm>

    <para>L'organisation de l'arborescence des répertoires de FreeBSD
      est essentielle pour obtenir une compréhension globale du
      système.  Le concept le plus important &agrave; saisir est
      celui du répertoire racine, &ldquo;/&rdquo;.
      Ce répertoire est le premier a être monté au
      démarrage et il contient le système de base
      nécessaire pour préparer le système d'exploitation
      au fonctionnement multi-utilisateurs.
      Le répertoire racine contient également les
      points de montage pour les autres systèmes de fichiers qui
      sont montés lors du passage en mode multi-utilisateurs.</para>

    <para>Un point de montage est un répertoire où peuvent
      être greffés des systèmes de fichiers
      supplémentaires au système de
      fichiers parent (en général le système de fichiers racine).  Cela est décrit plus en détails dans la <xref linkend="disk-organization"/>.  Les points de montage standards incluent
      <filename>/usr</filename>, <filename>/var</filename>,
      <filename>/tmp</filename>,
      <filename>/mnt</filename>, et <filename>/cdrom</filename>.  Ces
      répertoires sont en général
      référencés par des entrées dans le
      fichier <filename>/etc/fstab</filename>.
      <filename>/etc/fstab</filename> est une table des divers systèmes
      de fichiers et de leur point de montage utilisé comme
      référence par le système.
      La plupart des systèmes de fichiers présents dans
      <filename>/etc/fstab</filename> sont montés automatiquement au
      moment du démarrage par la procédure &man.rc.8; &agrave;
      moins que
      l'option <option>noauto</option> soit présente.
      Plus de détails peuvent être trouvés dans la
      <xref linkend="disks-fstab"/>.</para>

    <para>Une description complète de l'arborescence du système de
      fichiers est disponible dans la page de manuel &man.hier.7;.  Pour
      l'instant, une brève vue d'ensemble des répertoires les plus
      courants suffira.</para>

    <para>
      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Répertoire</entry>
	      <entry>Description</entry>
	    </row>
	  </thead>
	  <tbody valign="top">
            <row>
	      <entry><filename>/</filename></entry>
	      <entry>Répertoire racine du système de
		fichiers.</entry>
            </row>

	    <row>
	      <entry><filename>/bin/</filename></entry>
	      <entry>Programmes utilisateur fondamentaux aux deux modes
		de fonctionnement mono et multi-utilisateurs.</entry>
	    </row>

	    <row>
	      <entry><filename>/boot/</filename></entry>
	      <entry>Programmes et fichiers de configuration utilisés
		durant le processus de démarrage du
		système.</entry>
	    </row>

	    <row>
	      <entry><filename>/boot/defaults/</filename></entry>
	      <entry>Fichiers de configuration par défaut du processus
		de démarrage; voir la page de manuel
		&man.loader.conf.5;.</entry>
	    </row>

	    <row>
	      <entry><filename>/dev/</filename></entry>
	      <entry>Fichiers spéciaux de périphérique;
		voir la page de manuel &man.intro.4;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/</filename></entry>
	      <entry>Procédures et fichiers de configuration du
		système.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/defaults/</filename></entry>
	      <entry>Fichiers de configuration du système par
		défaut; voir la page de manuel &man.rc.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/mail/</filename></entry>
	      <entry>Fichiers de configuration pour les agents de
		transport du courrier électronique comme
		&man.sendmail.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb/</filename></entry>
	      <entry>Fichiers de configuration de <command>named</command>;
		voir la page de manuel &man.named.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/periodic/</filename></entry>
	      <entry>Procédures qui sont exécutées de
		façon quotidienne, hebdomadaire et mensuelle par
		l'intermédiaire de &man.cron.8;;
		voir la page de manuel &man.periodic.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/ppp/</filename></entry>
	      <entry>Fichiers de configuration de <command>ppp</command>; voir
		la page de manuel &man.ppp.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/mnt/</filename></entry>
	      <entry>Répertoire vide habituellement utilisé
		par les administrateurs système comme un point de
		montage temporaire.</entry>
	    </row>

	    <row>
	      <entry><filename>/proc/</filename></entry>
	      <entry>Le système de fichiers pour les processus; voir les
		pages de manuel &man.procfs.5;, &man.mount.procfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/rescue/</filename></entry>
	      <entry>Programmes liés en statique pour les
		réparations d'urgence; consultez la page de
		manuel &man.rescue.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/root/</filename></entry>
	      <entry>Répertoire personnel du compte
		<systemitem class="username">root</systemitem>.</entry>
	    </row>

	    <row>
	      <entry><filename>/sbin/</filename></entry>
	      <entry>Programmes systèmes et utilitaires systèmes
		fondamentaux aux environnements mono et multi-utilisateurs.
		</entry>
	    </row>

	    <row>
	      <entry><filename>/tmp/</filename></entry>
	      <entry>Fichiers temporaires.
		Le contenu de <filename>/tmp</filename>
		n'est en général PAS préservé
		par un redémarrage du système.  Un
		système de fichiers en mémoire est
		souvent monté sur <filename>/tmp</filename>.  Cela peut
		être automatisé en utilisant les
		variables &man.rc.conf.5; relatives au système
		<quote>tmpmfs</quote> (ou &agrave; l'aide d'une
		entrée dans le fichier
		<filename>/etc/fstab</filename>; consultez la page de
		manuel &man.mdmfs.8;).</entry>
	    </row>


	    <row>
	      <entry><filename>/usr/</filename></entry>
	      <entry>La majorité des utilitaires et applications
		utilisateur.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/bin/</filename></entry>
	      <entry>Utilitaires généraux, outils de
		programmation, et applications.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/include/</filename></entry>
	      <entry>Fichiers d'en-tête C standard.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/lib/</filename></entry>
	      <entry>Ensemble des bibliothèques.</entry>
	    </row>


	    <row>
	      <entry><filename>/usr/libdata/</filename></entry>
	      <entry>Divers fichiers de données de service.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/libexec/</filename></entry>
	      <entry>Utilitaires et daemons système
		(exécutés par d'autres programmes).</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/local/</filename></entry>

	      <entry>Exécutables, bibliothèques, etc...  Egalement
		utilisé comme destination de défaut pour les
		logiciels portés pour FreeBSD.  Dans
		<filename>/usr/local</filename>, l'organisation
		générale
		décrite par la page de manuel &man.hier.7; pour
		<filename>/usr</filename> devrait être utilisée.
		Exceptions faites du répertoire man qui est directement
		sous <filename>/usr/local</filename> plutôt que sous
		<filename>/usr/local/share</filename>, et la
		documentation des logiciels portés est dans
		<filename>share/doc/port</filename>.
	      </entry>
	    </row>

	    <row>
	      <entry><filename>/usr/obj/</filename></entry>
	      <entry>Arborescence cible spécifique &agrave; une
		architecture produite par la compilation de l'arborescence
		<filename>/usr/src</filename>.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/ports</filename></entry>
	      <entry>Le catalogue des logiciels portés
		(optionnel).</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/sbin/</filename></entry>
	      <entry>Utilitaires et daemons système
		(exécutés par les utilisateurs).</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/share/</filename></entry>
	      <entry>Fichiers indépendants de l'architecture.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/src/</filename></entry>
	      <entry>Fichiers source FreeBSD et/ou locaux.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/X11R6/</filename></entry>
	      <entry>Exécutables, bibliothèques etc... de la
		distribution d'X11R6 (optionnel).</entry>
	    </row>

	    <row>
	      <entry><filename>/var/</filename></entry>
	      <entry>Fichiers de traces, fichiers temporaires, et
		fichiers tampons.  Un système de fichiers en
		mémoire est parfois monté sur <filename>/var</filename>.  Cela peut
		être automatisé en utilisant les
		variables &man.rc.conf.5; relatives au système
		<quote>varmfs</quote> (ou &agrave; l'aide d'une
		entrée dans le fichier
		<filename>/etc/fstab</filename>; consultez la page de
		manuel &man.mdmfs.8;).</entry>
	    </row>


	    <row>
	      <entry><filename>/var/log/</filename></entry>
	      <entry>Divers fichiers de trace du système.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/mail/</filename></entry>
	      <entry>Boîtes aux lettres des utilisateurs.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/spool/</filename></entry>
	      <entry>Divers répertoires tampons des systèmes
		de courrier électronique et d'impression.
	      </entry>
	    </row>

	    <row>
	      <entry><filename>/var/tmp/</filename></entry>
	      <entry>Fichiers temporaires.  Ces fichiers sont
		généralement conservés lors d'un
		redémarrage du système, &agrave; moins
		que <filename>/var</filename> ne
		soit un système de fichiers en
		mémoire.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/yp</filename></entry>
	      <entry>Tables NIS.</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>

  </sect1>

  <sect1 xml:id="disk-organization">
    <title>Organisation des disques</title>

    <para>Le plus petit élément qu'utilise FreeBSD pour
      retrouver des fichiers est le nom de fichier.  Les noms de
      fichiers sont sensibles &agrave; la casse des caractères,
      ce qui signifie que <filename>readme.txt</filename> et
      <filename>README.TXT</filename> sont deux fichiers
      séparés.  FreeBSD n'utilise pas l'extension
      (<filename>.txt</filename>) d'un fichier pour déterminer
      si ce fichier est un programme, un document ou une autre forme
      de donnée.</para>

    <para>Les fichiers sont stockés dans des
      répertoires.  Un répertoire peut ne contenir aucun
      fichier, ou en contenir plusieurs centaines.  Un
      répertoire peut également contenir d'autre
      répertoires, vous permettant de construire une
      hiérarchie de répertoires &agrave;
      l'intérieur d'un autre.  Cela rend plus simple
      l'organisation de vos données.</para>

    <para>Les fichiers et les répertoires sont
      référencés en donnant le nom du fichier ou
      du répertoire, suivi par un slash, <literal>/</literal>,
      suivi par tout nom de répertoire nécessaire.  Si
      vous avez un répertoire <filename>foo</filename>, qui
      contient le répertoire <filename>bar</filename>, qui
      contient le fichier <filename>readme.txt</filename>, alors le
      nom complet, ou <firstterm>chemin</firstterm>
      (&ldquo;path&rdquo;) vers le fichier est
      <filename>foo/bar/readme.txt</filename>.</para>

    <para>Les répertoires et les fichiers sont stockés
      sur un système de fichiers.  Chaque système de
      fichiers contient &agrave; son niveau le plus haut un
      répertoire appelé <firstterm>répertoire
      racine</firstterm> pour ce système de fichiers.  Ce
      répertoire racine peut alors contenir les autres
      répertoires.</para>

    <para>Jusqu'ici cela est probablement semblable &agrave; n'importe
      quel autre système d'exploitation que vous avez pu avoir
      utilisé.  Il y a quelques différences: par
      exemple, &ms-dos; utilise <literal>\</literal> pour séparer
      les noms de fichier et de répertoire, alors que MacOS
      utilise <literal>:</literal>.</para>

    <para>FreeBSD n'utilise pas de lettre pour les lecteurs, ou
      d'autres noms de disque dans le chemin.  Vous n'écrirez
      pas <filename>c:/foo/bar/readme.txt</filename> sous
      FreeBSD.</para>

    <para>Au lieu de cela, un système de fichiers est
      désigné comme <firstterm>système de
      fichiers racine</firstterm>.  La racine du système de
      fichiers racine est représentée par un
      <literal>/</literal>. Tous les autres systèmes de
      fichiers sont alors <firstterm>montés</firstterm> sous le
      système de fichiers racine.  Peu importe le nombre de
      disques que vous avez sur votre système FreeBSD, chaque
      répertoire apparaît comme faisant partie du
      même disque.</para>

    <para>Supposez que vous avez trois systèmes de fichiers,
      appelés <literal>A</literal>, <literal>B</literal>, et
      <literal>C</literal>.  Chaque système de fichiers
      possède un répertoire racine, qui contient deux
      autres répertoires, nommés <literal>A1</literal>,
      <literal>A2</literal> (et respectivement <literal>B1</literal>,
      <literal>B2</literal> et <literal>C1</literal>,
      <literal>C2</literal>).</para>

    <para>Appelons <literal>A</literal> le système de fichiers
      racine.  Si vous utilisiez la commande <command>ls</command>
      pour visualiser le contenu de ce répertoire, vous verriez
      deux sous-répertoires, <literal>A1</literal> et
      <literal>A2</literal>.  L'arborescence des répertoires
      ressemblera &agrave; ceci:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir1"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
      </textobject>
    </mediaobject>

    <para>Un système de fichiers doit être monté
      dans un répertoire d'un autre système de fichiers.
      Supposez maintenant que vous montez le système de
      fichiers <literal>B</literal> sur le répertoire
      <literal>A1</literal>.  Le répertoire racine de
      <literal>B</literal> remplace <literal>A1</literal>, et les
      répertoires de <literal>B</literal> par conséquent
      apparaissent:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir2"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
      </textobject>
    </mediaobject>

    <para>Tout fichier de <literal>B1</literal> ou
      <literal>B2</literal> peut être atteint avec le chemin
      <filename>/A1/B1</filename> ou <filename>/A1/B2</filename> si
      nécessaire.  Tous les fichiers qui étaient dans
      <filename>A1</filename> ont été temporairement
      cachés.  Ils réapparaîtront si
      <literal>B</literal> est
      <firstterm>démonté</firstterm> de A.</para>

    <para>Si <literal>B</literal> a été monté sur
      <literal>A2</literal> alors le diagramme sera semblable &agrave;
      celui-ci:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir3"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
      </textobject>
    </mediaobject>

    <para>et les chemins seront <filename>/A2/B1</filename> et
      respectivement <filename>/A2/B2</filename>.</para>

    <para>Les systèmes de fichiers peuvent être
      montés au sommet d'un autre.  En continuant l'exemple
      précédent, le système de fichiers
      <literal>C</literal> pourrait être monté au sommet
      du répertoire <literal>B1</literal> dans le
      système de fichiers <literal>B</literal>, menant &agrave;
      cet arrangement:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir4"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
      </textobject>
    </mediaobject>

    <para>Où <literal>C</literal> pourrait être
      monté directement sur le système de fichiers
      <literal>A</literal>, sous le répertoire
      <literal>A1</literal>:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir5"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
      </textobject>
    </mediaobject>

    <para>Si vous êtes familier de &ms-dos;, ceci est semblable, bien
      que pas identique, &agrave; la commande
      <command>join</command>.</para>

    <para>Ce n'est normalement pas quelque chose qui doit vous
      préoccuper.  Généralement vous créez
      des systèmes de fichiers &agrave; l'installation de
      FreeBSD et décidez où les monter, et ensuite ne
      les modifiez jamais &agrave; moins que vous ajoutiez un nouveau
      disque.</para>

    <para>Il est tout &agrave; fait possible de n'avoir qu'un seul
      grand système de fichiers racine, et de ne pas en
      créer d'autres.  Il y a quelques inconvénients
      &agrave; cette approche, et un avantage.</para>

    <itemizedlist>
      <title>Avantages des systèmes de fichiers
	multiples</title>

      <listitem>
	<para>Les différents systèmes de fichiers
	  peuvent avoir différentes <firstterm>options de
	  montage</firstterm>.  Par exemple, avec une planification
	  soigneuse, le système de fichiers racine peut
	  être monté en lecture seule, rendant impossible
	  tout effacement par inadvertance ou édition de fichier
	  critique.  La séparation des systèmes de
	  fichiers inscriptibles par l'utilisateur permet leur montage
	  en mode <firstterm>nosuid</firstterm>; cette option
	  empêche les bits
	  <firstterm>suid</firstterm>/<firstterm>guid</firstterm> des
	  exécutables stockés sur ce système de
	  fichiers de prendre effet, améliorant peut-être
	  la sécurité.</para>
      </listitem>

      <listitem>
	<para>FreeBSD optimise automatiquement la disposition des
	  fichiers sur un système de fichiers, selon la
	  façon dont est utilisé le système de
	  fichiers.  Aussi un système de fichiers contenant
	  beaucoup de petits fichiers qui sont écrits
	  fréquemment aura une optimisation différente
	  &agrave; celle d'un système contenant moins, ou de plus
	  gros fichiers.  En ayant un seul grand système de
	  fichiers cette optimisation est perdue.</para>
      </listitem>

      <listitem>
	<para>Les systèmes de fichiers de FreeBSD sont
	  très robustes même en cas de coupure secteur.
	  Cependant une coupure secteur &agrave; un moment critique
	  pourrait toujours endommager la structure d'un système
	  de fichiers.  En répartissant vos données sur
	  des systèmes de fichiers multiples il est plus probable
	  que le système redémarre, vous facilitant la
	  restauration des données &agrave; partir de sauvegardes
	  si nécessaire.</para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <title>Avantage d'un système de fichiers unique</title>

      <listitem>
	<para>Les systèmes de fichiers ont une taille fixe.  Si
	  vous créez un système de fichiers &agrave;
	  l'installation de FreeBSD et que vous lui donnez une taille
	  spécifique, vous pouvez plus tard vous apercevoir que
	  vous avez besoin d'une partition plus grande.  Cela n'est pas
	  facilement faisable sans sauvegardes, recréation du
	  système de fichiers, et enfin restauration des
	  données.</para>

	<important>
	  <para>&os; dispose d'une commande,
	    &man.growfs.8;, qui permettra d'augmenter la taille d'un
	    système de fichiers au vol, supprimant cette
	    limitation.</para>
	</important>
      </listitem>
    </itemizedlist>

    <para>Les systèmes de fichiers sont contenus dans des
      partitions.  Cela n'a pas la même signification que
      l'utilisation commune du terme partition (par exemple une
      partition
      &ms-dos;), en raison de l'héritage Unix de FreeBSD.
      Chaque partition est identifiée par une lettre de
      <literal>a</literal> &agrave; <literal>h</literal>.  Chaque
      partition ne contient qu'un seul système de fichiers,
      cela signifie que les systèmes de fichiers sont souvent
      décrits soit par leur point de montage typique dans la
      hiérarchie du système de fichiers, soit par la
      lettre de la partition qui les contient.</para>

    <para>FreeBSD utilise aussi de l'espace disque pour
      <firstterm>l'espace de pagination</firstterm>
      (&ldquo;swap&rdquo;).  L'espace de pagination fournit &agrave;
      FreeBSD la <firstterm>mémoire virtuelle</firstterm>.
      Cela permet &agrave; votre ordinateur de se comporter comme s'il
      disposait de beaucoup plus de mémoire qu'il n'en a
      réellement.  Quand FreeBSD vient &agrave; manquer de
      mémoire il déplace certaines données qui ne
      sont pas actuellement utilisées vers l'espace de
      pagination, et les rapatrie (en déplaçant quelque
      chose d'autre) quand il en a besoin.</para>

    <para>Quelques partitions sont liées &agrave; certaines
      conventions.</para>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<colspec colwidth="1*"/>
	<colspec colwidth="5*"/>

	<thead>
	  <row>
	    <entry>Partition</entry>

	    <entry>Convention</entry>
	  </row>
	</thead>

	<tbody valign="top">
	  <row>
	    <entry><literal>a</literal></entry>

	    <entry>Contient normalement le système de
	      fichiers racine</entry>
	  </row>

	  <row>
	    <entry><literal>b</literal></entry>

	    <entry>Contient normalement l'espace de pagination</entry>
	  </row>

	  <row>
	    <entry><literal>c</literal></entry>

	    <entry>Normalement de la même taille que la tranche
	      (&ldquo;slice&rdquo;) contenant les partitions.  Cela
	      permet aux utilitaires devant agir sur
	      l'intégralité de la tranche (par exemple
	      un analyseur de blocs défectueux) de travailler
	      sur la partition <literal>c</literal>.  Vous ne devriez
	      normalement pas créer de système de
	      fichiers sur cette partition.</entry>
	  </row>

	  <row>
	    <entry><literal>d</literal></entry>

	    <entry>La partition <literal>d</literal> a eu dans le
	      passé une signification particulière, ce
	      n'est plus le cas aujourd'hui, et <literal>d</literal>
	      pourra être utilisée comme une partition
	      classique.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Chaque partition contenant un système de fichiers est
      stockée dans ce que FreeBSD appelle une
      <firstterm>tranche</firstterm> (&ldquo;slice&rdquo;). Tranche -
      &ldquo;slice&rdquo; est le terme FreeBSD pour ce qui
      est communément appelé partition,
      et encore une fois, cela en raison des fondations Unix de
      FreeBSD.  Les tranches sont numérotées, en partant
      de 1, jusqu'&agrave; 4.</para>

    <indexterm><primary>slices</primary></indexterm>
    <indexterm><primary>tranches</primary></indexterm>
    <indexterm><primary>partitions</primary></indexterm>
    <indexterm><primary>mode dédié</primary></indexterm>

    <para>Les numéros de tranche suivent le nom du
      périphérique, avec le préfixe
      <literal>s</literal>, et commencent &agrave; 1.  Donc
      &ldquo;da0<emphasis>s1</emphasis>&rdquo; est la première
      tranche sur le premier disque SCSI.  Il ne peut y avoir que
      quatre tranches physiques sur un disque, mais vous pouvez avoir
      des tranches logiques dans des tranches physiques d'un type
      précis.  Ces tranches étendues sont
      numérotées &agrave; partir de 5, donc
      &ldquo;ad0<emphasis>s5</emphasis>&rdquo; est la première
      tranche étendue sur le premier disque IDE.  Elles sont
      utilisées par des systèmes de fichiers qui
      s'attendent &agrave; occuper une tranche entière.</para>

    <para>Les tranches, les disques &ldquo;en mode
      dédié&rdquo;, et les autres disques contiennent
      des <firstterm>partitions</firstterm>, qui sont
      représentées par des lettres allant de
      <literal>a</literal> &agrave; <literal>h</literal>.  Cette
      lettre est ajoutée au nom de périphérique,
      aussi &ldquo;da0<emphasis>a</emphasis>&rdquo; est la partition a
      sur le premier disque da, qui est en &ldquo;en mode
      dédié&rdquo;.
      &ldquo;ad1s3<emphasis>e</emphasis>&rdquo; est la
      cinquième partition de la troisième tranche du
      second disque IDE.</para>

    <para>En conclusion chaque disque présent sur le
      système est identifié.  Le nom d'un disque
      commence par un code qui indique le type de disque, suivi d'un
      nombre, indiquant de quel disque il s'agit.  Contrairement aux
      tranches, la numérotation des disques commence &agrave;
      0.  Les codes communs que vous risquez de rencontrer sont
      énumérés dans le <xref linkend="basics-dev-codes"/>.</para>

    <para>Quand vous faites référence &agrave; une
      partition, FreeBSD exige que vous nommiez également la
      tranche et le disque contenant la partition, et quand vous
      faites référence &agrave; une tranche vous devrez
      également faire référence au nom du disque.
      On fait donc référence &agrave; une partition en écrivant le nom du disque,
      <literal>s</literal>, le numéro de la tranche, et enfin
      la lettre de la partition.  Des exemples sont donnés dans
      l'<xref linkend="basics-disk-slice-part"/>.</para>

    <para>L'<xref linkend="basics-concept-disk-model"/> montre un
      exemple de l'organisation d'un disque qui devrait aider &agrave;
      clarifier les choses.</para>

    <para>Afin d'installer FreeBSD vous devez tout d'abord configurer
      les tranches sur votre disque, ensuite créer les
      partitions dans la tranche que vous utiliserez pour FreeBSD, et
      alors créer un système de fichiers (ou espace de
      pagination) dans chaque partition, et décider de
      l'endroit où seront montés les systèmes de
      fichiers.</para>

    <table frame="none" pgwide="1" xml:id="basics-dev-codes">
      <title>Codes des périphériques disques</title>

      <tgroup cols="2">
	<colspec colwidth="1*"/>
	<colspec colwidth="5*"/>

	<thead>
	  <row>
	    <entry>Code</entry>

	    <entry>Signification</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><filename>ad</filename></entry>

	    <entry>Disque ATAPI (IDE)</entry>
	  </row>

	  <row>
	    <entry><filename>da</filename></entry>

	    <entry>Disque SCSI</entry>
	  </row>

	  <row>
	    <entry><filename>acd</filename></entry>

	    <entry>CDROM ATAPI (IDE)</entry>
	  </row>

	  <row>
	    <entry><filename>cd</filename></entry>

	    <entry>CDROM SCSI</entry>
	  </row>

	  <row>
	    <entry><filename>fd</filename></entry>

	    <entry>Lecteur de disquette</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <example xml:id="basics-disk-slice-part">
      <title>Exemples d'appellation de disques, tranches et
      partitions</title>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*"/>
	  <colspec colwidth="5*"/>

	  <thead>
	    <row>
	      <entry>Nom</entry>

	      <entry>Signification</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><literal>ad0s1a</literal></entry>

	      <entry>Première partition (<literal>a</literal>)
		sur la première tranche (<literal>s1</literal>)
		du premier disque IDE
		(<literal>ad0</literal>).</entry>
	    </row>

	    <row>
	      <entry><literal>da1s2e</literal></entry>

	      <entry>Cinquième partition (<literal>e</literal>)
		sur la seconde tranche (<literal>s2</literal>) du
		deuxième disque SCSI
		(<literal>da1</literal>).</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </example>

    <example xml:id="basics-concept-disk-model">
      <title>Modèle conceptuel d'un disque</title>

      <para>Ce diagramme montre comment FreeBSD voit le premier disque
	IDE attaché au système.  Supposons que le disque
	a une capacité de 4&nbsp;Go, et contient deux tranches
	de 2&nbsp;Go (partitions &ms-dos;).  La première tranche
	contient un disque &ms-dos;, <filename>C:</filename>, et la
	seconde tranche contient une installation de FreeBSD.  Dans
	cet exemple l'installation de FreeBSD a trois partitions de données, et
	une partition de pagination.</para>

      <para>Les trois partitions accueilleront chacune un
	système de fichiers.  La partition <literal>a</literal>
	sera utilisée en tant que système de fichiers
	racine, la partition <literal>e</literal> pour le contenu du
	répertoire <filename>/var</filename>, et
	<literal>f</literal> pour l'arborescence du répertoire
	<filename>/usr</filename>.</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/disk-layout"/>
	</imageobject>

          <textobject>
	    <literallayout class="monospaced">.-----------------.  --.
|                 |    |
|  DOS / Windows  |    |
:                 :     &gt;  Première tranche, ad0s1
:                 :    |
|                 |    |
:=================:  ==:                                   --.
|                 |    |  Partition a, montée en tant que /  |
|                 |     &gt; référencée ad0s2a	             |
|                 |    |                                     |
:-----------------:  ==:                                     |
|                 |    |  Partition b, utilisée comme swap   |
|                 |     &gt; référencée ad0s2b	             |  Partition c,
|                 |    |                               	     |  pas de
:-----------------:  ==:                                     |  système de
|                 |    |  Partition e, utilisée en /var       &gt; fichiers
|                 |     &gt; référencée ad0s2e                  |  intégralité
|                 |    |                                     |  de la tranche
:-----------------:  ==:                                     |  FreeBSD ad0s2c
|                 |    |                                     |
:                 :    |  Partition f, utilisée en /usr      |
:                 :     &gt; référencée ad0s2f                  |
:                 :    |                                     |
|                 |    |                                     |
|                 |  --'                                     |
`-----------------'                                        --'</literallayout>
	</textobject>
      </mediaobject>
    </example>
  </sect1>

  <sect1 xml:id="mount-unmount">
    <title>Monter et démonter des systèmes de fichiers</title>

    <para>Le système de fichiers peut être vu comme un arbre
      enraciné sur le répertoire <filename>/</filename>.
      <filename>/dev</filename>, <filename>/usr</filename>, et les
      autres répertoires dans le répertoire racine sont des
      branches, qui peuvent avoir leurs propres branches, comme
      <filename>/usr/local</filename>, et ainsi de suite.</para>

    <indexterm><primary>système de fichiers racine</primary></indexterm>
    <para>Il y a diverses raisons pour héberger certains de ces
      répertoires sur des systèmes de fichiers
      séparés.
      <filename>/var</filename> contient les répertoires
      <filename>log/</filename>, <filename>spool/</filename>, et divers
      types de fichiers temporaires, et en tant que tels, peuvent voir
      leur taille augmenter de façon importante.
      Remplir le système de
      fichiers racine n'est pas une bonne idée, aussi séparer
      <filename>/var</filename> de <filename>/</filename> est souvent
      favorable.</para>

    <para>Une autre raison courante de placer certains répertoires sur
      d'autres systèmes de fichiers est s'ils doivent être
      hébergés sur
      des disques physiques séparés, ou sur des disques virtuels
      séparés, comme les <link linkend="network-nfs">systèmes de
      fichiers réseau</link>, ou les lecteurs de CDROM.</para>

    <sect2 xml:id="disks-fstab">
      <title>Le fichier <filename>fstab</filename></title>
      <indexterm>
	<primary>systèmes de fichiers</primary>
	<secondary>montés avec fstab</secondary>
      </indexterm>

      <para>Durant le <link linkend="boot">processus de
	démarrage</link>, les systèmes de fichiers listés
	dans <filename>/etc/fstab</filename> sont automatiquement
	montés (&agrave; moins qu'il ne soient listés avec
	l'option <option>noauto</option>).</para>

      <para>Le fichier <filename>/etc/fstab</filename> contient une
	liste de lignes au format suivant:</para>

      <programlisting><replaceable>device</replaceable>       <replaceable>/mount-point</replaceable> <replaceable>fstype</replaceable>     <replaceable>options</replaceable>      <replaceable>dumpfreq</replaceable>     <replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>device</literal></term>
	  <listitem>
	    <para>Un nom de périphérique (qui devrait exister),
	      comme expliqué dans la
	      <xref linkend="disks-naming"/>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>mount-point</literal></term>

	  <listitem><para>Un répertoire (qui devrait exister), sur
	    lequel sera monté le système de fichier.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>fstype</literal></term>

	  <listitem><para>Le type de système de fichiers &agrave;
	      indiquer &agrave;
	      &man.mount.8;.  Le système de fichiers par défaut de
	      FreeBSD est l'<literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options</literal></term>

	  <listitem><para>Soit <option>rw</option> pour des systèmes de
	      fichiers &agrave; lecture-écriture, soit
	      <option>ro</option> pour des systèmes de fichiers
	      &agrave; lecture seule, suivi par toute
	      option qui peut s'avérer nécessaire.  Une option
	      courante est <option>noauto</option> pour les systèmes de
	      fichiers qui ne sont normalement pas montés durant la
	      séquence de démarrage.  D'autres options sont
	      présentées dans la page de manuel &man.mount.8;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>dumpfreq</literal></term>

         <listitem><para>C'est utilisé par &man.dump.8; pour
	     déterminer quels systèmes de fichiers
	     nécessitent
	     une sauvegarde.  Si ce champ est absent, une valeur
	     de zéro est supposée.</para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>passno</literal></term>

         <listitem>
           <para>Ceci détermine l'ordre dans lequel les systèmes
	     de fichiers devront être vérifiés.
	     Les systèmes de fichiers
	     qui doivent être ignorés devraient avoir leur
	     <literal>passno</literal> positionné &agrave; zéro.
	     Le système de fichiers racine (qui doit être
	     vérifié avant tout le reste) devrait avoir son
	     <literal>passno</literal> positionné &agrave; un,
	     et les options <literal>passno</literal> des autres
	     systèmes fichiers devraient être positionnées
	     &agrave; des valeurs supérieures &agrave; un.  Si plus
	     d'un système de fichiers ont le même
	     <literal>passno</literal> alors &man.fsck.8; essaiera
	     de vérifier les systèmes de fichiers
	     en parallèle si c'est possible.</para>
         </listitem>
	</varlistentry>
      </variablelist>

      <para>Consultez la page de manuel de &man.fstab.5; pour plus
	d'information sur le format du fichier
	<filename>/etc/fstab</filename> et des options qu'il
	contient.</para>
    </sect2>

    <sect2 xml:id="disks-mount">
      <title>La commande <command>mount</command></title>
      <indexterm>
	<primary>systèmes de fichiers</primary>
	<secondary>montage</secondary>
      </indexterm>

      <para>La commande &man.mount.8; est ce qui est finalement
	utilisé pour monter des systèmes de fichiers.</para>

      <para>Dans sa forme la plus simple, vous utilisez:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount device mountpoint</userinput></screen>
      </informalexample>

      <para>Il y beaucoup d'options, comme mentionné dans la page de
	manuel &man.mount.8;, mais les plus courantes sont:</para>

      <variablelist>
	<title>Options de montage</title>

	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
	    <para>Monte tous les systèmes de fichiers listés dans
	      <filename>/etc/fstab</filename>.  Exception faite de ceux
	      marqués comme &ldquo;noauto&rdquo;, ou exclus par
	      le drapeau <option>-t</option>, ou encore ceux qui sont
	      déj&agrave; montés.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

	  <listitem>
	    <para>Tout effectuer &agrave; l'exception de l'appel
	      système de montage réel.  Cette option est utile
	      conjointement avec le drapeau <option>-v</option> pour
	      déterminer ce que &man.mount.8; est en train
	      d'essayer de faire.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Force le montage d'un système de fichiers non propre
	      (dangereux), ou force la révocation de l'accès en
	      écriture quand on modifie l'état de montage d'un
	      système de fichiers de l'accès
	      lecture-écriture &agrave; l'accès
	      lecture seule.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
          <term><option>-r</option></term>

	  <listitem>
	    <para>Monte le système de fichiers en lecture seule.  C'est
	      identique &agrave; l'utilisation de l'argument
	      <option>ro</option> (<option>rdonly</option> pour les
	      versions de &os; antérieures &agrave; la 5.2)
	      avec l'option
	      <option>-o</option>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
	    <para>Monte le système de fichiers comme étant
	    du type de système donné, ou monte
	      seulement les systèmes de fichiers du type donné,
	      si l'option <option>-a</option> est précisée.</para>
	    <para>&ldquo;ufs&rdquo; est le type de système de
	      fichiers par défaut.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
	    <para>Mets &agrave; jour les options de montage sur le
	      système de fichiers.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Rends la commande prolixe.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>Monte le système de fichiers en
	      lecture-écriture.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>L'option <option>-o</option> accepte une liste d'options
	séparées par des virgules, dont les suivantes:</para>

      <variablelist>
	<varlistentry>
	  <term>noexec</term>

	  <listitem>
              <para>Ne pas autoriser l'exécution de binaires sur ce
		système de fichiers.  C'est également une
		option de sécurité utile.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
	    <para>Ne pas prendre en compte les indicateurs setuid ou setgid
	      sur le système de fichiers.  C'est également une
	      option de sécurité utile.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 xml:id="disks-umount">
      <title>La commande <command>umount</command></title>
      <indexterm>
	<primary>systèmes de fichiers</primary>
	<secondary>démontage</secondary>
      </indexterm>

      <para>La commande &man.umount.8; prend, comme paramètre, un des
	points de montage, un nom de périphérique, ou
	l'option <option>-a</option> ou <option>-A</option>.</para>

      <para>Toutes les formes acceptent <option>-f</option> pour forcer
	de démontage, et <option>-v</option> pour le mode
	prolixe.  Soyez averti que l'utilisation de <option>-f</option>
	n'est généralement pas une bonne idée.
	Démonter de force des systèmes de fichiers pourrait
	faire planter l'ordinateur ou endommager les données sur
	le système de fichiers.</para>

      <para>Les options <option>-a</option> et <option>-A</option>
	sont utilisées pour démonter tous les systèmes
	de fichiers actuellement montés, éventuellement
	modifié par les types de systèmes de fichiers
	listés après l'option <option>-t</option>.
	Cependant l'option <option>-A</option>, n'essaye pas de
	démonter le système de fichiers racine.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="basics-processes">
    <title>Processus</title>

    <para>FreeBSD est un système d'exploitation multi-tâches.
      Cela veut dire qu'il semble qu'il y ait plus d'un programme
      fonctionnant &agrave;
      la fois.  Tout programme fonctionnant &agrave; un moment donné est
      appelé un <firstterm>processus</firstterm>.  Chaque commande que
      vous utiliserez lancera au moins un nouveau processus, et il y a
      de nombreux processus système qui tournent constamment, maintenant
      ainsi les fonctionnalités du système.</para>

    <para>Chaque processus est identifié de façon unique par
      un nombre appelé <firstterm>process ID</firstterm> (identifiant de
      processus), ou <firstterm>PID</firstterm>, et, comme pour les fichiers,
      chaque processus possède également un propriétaire
      et un groupe.  Les informations sur le propriétaire et le groupe
      sont utilisées pour déterminer quels fichiers et
      périphériques sont accessibles au processus, en utilisant le
      principe de permissions de fichiers abordé plus tôt.
      La plupart
      des processus ont également un processus parent.  Le processus
      parent est le processus qui les a lancés.  Par exemple, si vous
      tapez des commandes sous un interpréteur de commandes, alors
      l'interpréteur de commandes est un processus, et toute commande
      que vous lancez est aussi un processus.  Chaque processus que vous
      lancez de cette manière aura votre interpréteur de
      commandes comme processus parent.
      Une exception &agrave; cela est le processus spécial
      appelé &man.init.8;.  <command>init</command> est
      toujours le premier processus, donc son PID est toujours 1.
      <command>init</command> est lancé automatiquement par le noyau au
      démarrage de FreeBSD.</para>

    <para>Deux commandes sont particulièrement utiles pour voir les
      processus sur le système, &man.ps.1; et &man.top.1;.  La
      commande <command>ps</command> est utilisée pour afficher une liste statique
      des processus tournant actuellement, et peut donner leur PID, la
      quantité de mémoire qu'ils utilisent, la ligne de
      commande par l'intermédiaire de laquelle ils ont
      été lancés, et ainsi de suite.
      La commande &man.top.1; affiche tous les processus, et actualise
      l'affichage régulièrement, de sorte que vous puissiez voir
      de façon intéractive ce que fait l'ordinateur.</para>

    <para>Par défaut, &man.ps.1; n'affiche que les commandes que vous
      faites tourner et dont vous êtes le propriétaire.  Par
      exemple:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Comme vous pouvez le voir dans cet exemple, la sortie de
      &man.ps.1; est organisée en un certain nombre de colonnes.
      <literal>PID</literal> est l'identifiant de processus discuté plus
      tôt.  Les PIDs sont assignés &agrave; partir de 1, et
      vont jusqu'&agrave; 99999,
      et puis repassent &agrave; 1 quand le maximum est atteint
      (un PID n'est pas réassigné s'il est
      déj&agrave; utilisé).
      La colonne <literal>TT</literal> donne le terminal sur lequel tourne le
      programme, et peut être pour le moment ignoré sans risque.
      <literal>STAT</literal> affiche l'état du programme, peut
      être également ignoré.
      <literal>TIME</literal> est la durée d'utilisation du CPU&mdash;ce
      n'est généralement pas le temps écoulé depuis
      que vous avez lancé le programme, comme la plupart des programmes passent
      beaucoup de temps &agrave; attendre que certaines choses se produisent
      avant qu'ils n'aient besoin de dépenser du temps CPU.
      Et enfin, <literal>COMMAND</literal> est la ligne de commande qui a
      été utilisée lors du lancement du programme.</para>

    <para>&man.ps.1; supporte un certain nombre d'options différentes
      pour modifier les informations affichées.  Un des ensembles
      d'options les plus utiles est <literal>auxww</literal>.
      <option>a</option> affiche l'information au sujet de tous les
      processus tournant, et pas seulement les vôtres.
      <option>u</option> donne le nom de l'utilisateur du propriétaire
      du processus, ainsi que l'utilisation de la mémoire.
      <option>x</option> affiche des informations sur les processus
      &ldquo;daemon&rdquo;, et <option>ww</option> oblige &man.ps.1; &agrave;
      afficher la ligne de commande complète pour chaque processus, plutôt que de la
      tronquer quand elle est trop longue pour tenir &agrave;
      l'écran.</para>

    <para>La sortie de &man.top.1; est semblable.  Un extrait de session
      ressemble &agrave; ceci:</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>La sortie est divisée en deux sections.
      L'entête (les cinq premières lignes) donne le PID du
      dernier processus lancé, la charge système moyenne
      (qui est une mesure de l'occupation du système), la durée
      de fonctionnement du système (le temps écoulé
      depuis le dernier redémarrage), et l'heure actuelle.  Les autres
      éléments de l'entête concernent le nombre de
      processus en fonctionnement (47 dans notre cas), combien d'espace
      mémoire et d'espace de pagination sont occupés, et
      combien de temps le système passe dans les différents
      états du CPU.</para>

    <para>En dessous il y a une série de colonnes contenant des
      informations semblables &agrave; celles données par &man.ps.1;.
      Comme précédemment vous pouvez lire le PID, le nom
      d'utilisateur, la quantité de temps CPU consommée, et
      la commande qui a été lancée.  &man.top.1; vous
      affiche par défaut la quantité d'espace mémoire
      utilisée par chaque processus.  Cela est divisé en deux
      colonnes, une pour la quantité totale, et une autre pour la
      quantité résidente&mdash;la quantité totale
      représente l'espace mémoire dont a eu besoin l'application,
      et la quantité résidente représente
      l'espace qui est en fait utilisé actuellement.  Dans cet exemple
      vous pouvez voir que <application>&netscape;</application> a
      exigé presque 30&nbsp;Mo de RAM, mais
      utilise actuellement seulement 9Mo.</para>

    <para>&man.top.1; actualise l'affichage toutes les deux secondes;
      cela peut être modifié avec l'option
      <option>s</option>.</para>
  </sect1>

  <sect1 xml:id="basics-daemons">
    <title>Daemons, signaux, et comment tuer un processus</title>

    <para>Quand vous utilisez un éditeur il est facile de le
      contrôler, de lui dire de charger des fichiers, et ainsi de suite.
      Vous pouvez faire cela parce que l'éditeur fournit les
      possibilités de le faire, et parce qu'un éditeur est
      attaché &agrave; un <firstterm>terminal</firstterm>.
      Certains programmes ne sont pas conçus pour fonctionner avec
      un dialogue constant avec l'utilisateur, et donc ils se
      déconnectent du terminal &agrave; la première occasion.
      Par exemple, un serveur web passe son temps &agrave; répondre
      aux requêtes web, il n'attend normalement pas d'entrée de
      votre part.  Les programmes qui transportent le courrier
      électronique de site en site sont un autre exemple de cette
      classe d'application.</para>

    <para>Nous appelons ces programmes des
      <firstterm>daemons</firstterm> (démons).  Les
      &ldquo;daemons&rdquo; étaient des personnages de la mythologie
      Grecque: ni bon ni mauvais, c'étaient de petits esprits serviteurs
      qui, généralement, ont été &agrave; l'origine
      de choses utiles &agrave; l'humanité,
      un peu comme les serveurs web ou de messagerie d'aujourd'hui nous
      sont utiles.  C'est pourquoi la mascotte BSD a été, pendant
      longtemps, un démon &agrave; l'apparence joyeuse portant des
      chaussures de tennis et une fourche.</para>

    <para>Il existe une convention pour nommer les programmes qui
      fonctionnent normalement en tant que daemons qui est d'utiliser
      une terminaison en &ldquo;d&rdquo;.
      <application>BIND</application> est le &ldquo;Berkeley Internet Name
      Domain&rdquo;, mais le programme réel qui est exécuté
      s'appelle <command>named</command>); le programme
      correspondant au serveur web <application>Apache</application> est
      appelé <command>httpd</command>; le daemon de gestion de la file
      d'attente de l'imprimante est <command>lpd</command>, et ainsi de
      suite.  C'est une convention, mais pas une obligation pure et
      simple; par exemple le daemon principal de gestion du courrier
      électronique pour l'application
      <application>Sendmail</application> est appelé
      <command>sendmail</command>, et non pas <command>maild</command>,
      comme vous pourriez l'imaginer.</para>

    <para>Parfois vous devrez communiquer avec un processus daemon.
      Une manière de procéder est de lui (ou &agrave; tout processus en cours
      d'exécution) envoyer ce que l'on appelle un
      <firstterm>signal</firstterm>.  Il existe un certain
      nombre de signaux différents que vous pouvez
      envoyer&mdash;certains d'entre eux ont une signification précise,
      d'autres sont interprétés par l'application, et la
      documentation de l'application vous indiquera comment l'application
      interprète ces signaux.  Vous ne pouvez envoyer de signaux
      qu'aux processus dont vous êtes le propriétaire.
      Si vous envoyez un signal &agrave; un
      processus appartenant &agrave; quelqu'un d'autre avec &man.kill.1;
      ou &man.kill.2;, vous obtiendrez un refus de permission.  Il existe
      une exception &agrave; cela: l'utilisateur <systemitem class="username">root</systemitem>, qui
      peut envoyer des signaux aux processus de chacun.</para>

    <para>Dans certain cas FreeBSD enverra également aux applications
      des signaux.  Si une application est mal écrite, et tente
      d'accéder &agrave; une partie de mémoire &agrave;
      laquelle elle n'est pas supposée avoir accès, FreeBSD
      envoie au processus le signal de
      <firstterm>violation de segmentation</firstterm>
      (<literal>SIGSEGV</literal>).  Si une application a utilisé
      l'appel système &man.alarm.3; pour être avertie
      dès qu'une période de temps précise est
      écoulée alors lui sera envoyé le signal d'alarme
      (<literal>SIGALRM</literal>), et ainsi de suite.</para>

    <para>Deux signaux peuvent être utilisés pour arrêter
      un processus, <literal>SIGTERM</literal> et <literal>SIGKILL</literal>.
      <literal>SIGTERM</literal> est la manière polie de tuer un
      processus; le processus peut <emphasis>attraper</emphasis> le signal,
      réaliser que vous désirez qu'il se termine, fermer les
      fichiers de trace qu'il a peut-être ouvert, et
      généralement
      finir ce qu'il était en train de faire juste avant la demande
      d'arrêt.  Dans certains cas un processus peut ignorer un
      <literal>SIGTERM</literal> s'il est au milieu d'une tâche qui ne
      peut être interrompue.</para>

    <para><literal>SIGKILL</literal> ne peut être ignoré par un
      processus.  C'est le signal &ldquo;Je me fiche de ce que vous
      faites, arrêtez immédiatement&rdquo;.  Si vous envoyez un
      <literal>SIGKILL</literal> &agrave; un processus alors FreeBSD
      stoppera le processus<footnote>
	<para>Ce n'est pas tout &agrave; fait vrai&mdash;il y a quelques cas
	  où les choses ne peuvent être interrompues.  Par exemple,
	  si le processus est en train d'essayer de lire un fichier qui
	  est sur un autre ordinateur sur le réseau, et que l'autre
	  ordinateur n'est plus accessible pour quelque raison
	  (a été éteint, ou le réseau a un
	  problème),
	  alors le processus est dit &ldquo;non interruptible&rdquo;.
	  Par la suite le processus entrera en pause, typiquement après
	  deux minutes.  Dès que cette pause sera effective le processus
	  sera tué.</para>
      </footnote>.</para>

    <para>Les autres signaux que vous pourriez avoir envie d'utiliser
      sont <literal>SIGHUP</literal>, <literal>SIGUSR1</literal>, et
      <literal>SIGUSR2</literal>.  Ce sont des signaux d'usage
      général, et différentes applications se
      comporteront différemment quand ils
      sont envoyés.</para>

    <para>Supposez que vous avez modifié le fichier de configuration de
      votre serveur web&mdash;vous voudriez dire &agrave; votre serveur web de
      relire son fichier de configuration.  Vous pourriez arrêter et
      relancer <command>httpd</command>, mais il en résulterait une
      brève période d'indisponibilité de votre serveur
      web, ce qui peut être indésirable.
      La plupart des daemons sont écrits pour répondre
      au signal <literal>SIGHUP</literal> en relisant leur fichier de
      configuration.  Donc au lieu de tuer et relancer
      <command>httpd</command> vous lui enverriez le signal
      <literal>SIGHUP</literal>.  Parce qu'il n'y a pas de manière
      standard de répondre &agrave; ces signaux, différents
      daemons auront différents comportements, soyez sûr
      de ce que vous faites et lisez
      la documentation du daemon en question.</para>

    <para>Les signaux sont envoyés en utilisant la commande
      &man.kill.1;, comme cet exemple le montre:</para>

    <procedure>
      <title>Envoyer un signal &agrave; un processus</title>

      <para>Cet exemple montre comment envoyer un signal &agrave;
	&man.inetd.8;.  Le fichier de configuration d'<command>inetd</command> est
	<filename>/etc/inetd.conf</filename>, et <command>inetd</command> relira ce
	fichier de configuration quand un signal
	<literal>SIGHUP</literal> est envoyé.</para>

      <step>
	<para>Trouvez l'identifiant du processus (PID) auquel vous
	  voulez envoyer le signal.  Faites-le en employant &man.ps.1;
	  et &man.grep.1;.  La commande &man.grep.1; est utilisée pour
	  rechercher dans le résultat la chaîne de
	  caractères que
	  vous spécifiez.  Cette commande est lancée en tant
	  qu'utilisateur normal, et &man.inetd.8; est lancé en tant que
	  <systemitem class="username">root</systemitem>, donc les options <option>ax</option>
	  doivent être passées &agrave; &man.ps.1;.</para>

	<screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

	<para>Donc le PID d'&man.inetd.8; est 198.  Dans certains cas la
	  commande <literal>grep inetd</literal> pourrait aussi
	  apparaître dans le résultat.  C'est &agrave;
	  cause de la façon dont
	  &man.ps.1; recherche la liste des processus en
	  fonctionnement.</para>
      </step>

      <step>
	<para>Utilisez &man.kill.1; pour envoyer le signal.  Etant donné
	  qu'&man.inetd.8; tourne sous les droits de l'utilisateur
	  <systemitem class="username">root</systemitem> vous devez utilisez &man.su.1; pour
	  devenir, en premier lieu, <systemitem class="username">root</systemitem>.</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>Comme la plupart des commandes &unix;, &man.kill.1; n'affichera
	  rien si la commande est couronnée de succès.  Si vous
	  envoyez un signal &agrave; un processus dont vous n'êtes pas le
	  propriétaire alors vous verrez <errorname>kill:
	  <replaceable>PID</replaceable>: Operation not
	  permitted</errorname>.  Si vous avez fait une erreur dans le
	  PID, vous enverrez le signal soit &agrave; un mauvais processus, ce
	  qui peut être mauvais, soit, si vous êtes chanceux, vous
	  enverrez le signal &agrave; un PID qui n'est pas actuellement
	  utilisé, et vous verrez <errorname>kill:
	  <replaceable>PID</replaceable>: No such
	  process</errorname>.</para>

	<note>
	  <title>Pourquoi utiliser <command>/bin/kill</command>?</title>

	  <para>De nombreux interpréteurs de commandes fournissent la
	    commande <command>kill</command> comme commande interne;
	    c'est &agrave; dire, que l'interpréteur de commandes enverra
	    directement le signal, plutôt que de lancer
	    <filename>/bin/kill</filename>.  Cela peut être utile,
	    cependant les différents interpréteurs ont une syntaxe
	    différente pour spécifier le nom du signal &agrave;
	    envoyer.
	    Plutôt que de tenter de les apprendre toutes, il peut
	    être plus simple de juste employer directement la commande
	    <command>/bin/kill
	    ...</command>.</para>
	</note>
      </step>
    </procedure>

    <para>Envoyer d'autres signaux est très semblable, substituez juste
      <literal>TERM</literal> ou <literal>KILL</literal> dans la ligne
      de commande si nécessaire.</para>

    <important>
      <para>Tuer au hasard des processus sur le système peut
	être une mauvaise idée.
	En particulier, &man.init.8;, processus &agrave;
	l'identifiant 1, qui est très particulier.  Lancer la commande
	<command>/bin/kill -s KILL 1</command> est une manière
	rapide d'arrêter votre système.  Vérifiez
	<emphasis>toujours</emphasis> &agrave; deux fois les arguments que vous
	utilisez avec &man.kill.1; <emphasis>avant</emphasis> d'appuyer
	sur <keycap>Entrée</keycap>.</para>
    </important>
  </sect1>

  <sect1 xml:id="shells">
    <title>Interpréteurs de commandes - &ldquo;Shells&rdquo;</title>
    <indexterm><primary>interpréteurs de commandes</primary></indexterm>
    <indexterm><primary>ligne de commande</primary></indexterm>

    <para>Sous FreeBSD, beaucoup du travail quotidien est effectué sous
      une interface en ligne de commande appelée interpréteur de
      commandes ou &ldquo;shell&rdquo;.  Le rôle principal d'un
      interpréteur de commandes est de prendre les commandes sur le
      canal d'entrée et de les exécuter.  Beaucoup
      d'interpréteurs de commandes ont également des fonctions
      intégrées pour aider dans les tâches quotidiennes
      comme la gestion de fichiers, le mécanisme de
      remplacement et d'expansion des jokers (&ldquo;file globbing&rdquo;),
      l'édition de la ligne de commande, les macros commandes, et les
      variables d'environnement.  FreeBSD est fournit avec un ensemble
      d'interpréteurs de commandes, comme <command>sh</command>,
      l'interpréteur de commandes Bourne, et <command>tcsh</command>,
      l'interpréteur de commandes C-shell amélioré.
      Beaucoup d'autres
      interpréteurs de commandes sont disponibles dans le catalogue des
      logiciels portés, comme <command>zsh</command> et
      <command>bash</command>.</para>

    <para>Quel interpréteur de commandes utilisez-vous?  C'est vraiment
      une question de goût.  Si vous programmez en C vous pourriez vous
      sentir plus &agrave; l'aise avec un interpréteur de commandes
      proche du C
      comme <command>tcsh</command>.  Si vous venez du monde Linux ou que
      vous êtes nouveau &agrave; l'interface en ligne de commande d'&unix;
      vous pourriez essayer <command>bash</command>.  L'idée principale
      est que chaque interpréteur de commandes &agrave; des
      caractéristiques uniques qui peuvent ou ne peuvent pas
      fonctionner avec votre environnement de travail
      préféré, et que vous avez vraiment le
      choix de l'interpréteur de commandes &agrave; utiliser.</para>

    <para>Une des caractéristiques communes des interpréteurs de
      commandes est de pouvoir compléter les noms de fichiers
      (&ldquo;filename completion&rdquo;).  En tapant les premières
      lettres d'une commande ou d'un fichier, vous pouvez habituellement
      faire compléter automatiquement par l'interpréteur de
      commandes le reste de la commande ou du nom du fichier en appuyant sur la
      touche <keycap>Tab</keycap> du clavier.  Voici un exemple.
      Supposez que vous avez deux fichiers appelés respectivement
      <filename>foobar</filename> et <filename>foo.bar</filename>.
      Vous voulez effacer <filename>foo.bar</filename>.  Donc ce
      que vous devriez taper sur le clavier est: <command>rm
      fo[Tab].[Tab]</command>.</para>

    <para>L'interpréteur de commandes devrait afficher <command>rm
      foo[BEEP].bar</command>.</para>

    <para>Le [BEEP] est la sonnerie de la console, c'est l'interpréteur
      de commande indiquant qu'il n'est pas en mesure de compléter
      totalement le nom du fichier parce qu'il y a plus d'une
      possibilité.  <filename>foobar</filename> et
      <filename>foo.bar</filename> commencent tous les deux par
      <literal>fo</literal>, mais il fut capable de compléter
      jusqu'&agrave; <literal>foo</literal>.  Si vous tapez
      <literal>.</literal>, puis appuyez &agrave; nouveau sur
      <keycap>Tab</keycap>, l'interpréteur de
      commandes devrait pouvoir compléter le reste du nom du fichier
      pour vous.</para>
    <indexterm><primary>variables d'environnement</primary></indexterm>

    <para>Une autre caractéristique de l'interpréteur de
      commandes est l'utilisation de variables d'environnement.  Les variables
      d'environnement sont une paire variable/valeur stockées dans
      l'espace mémoire d'environnement de l'interpréteur de
      commandes.  Cet espace peut être lu par n'importe quel programme
      invoqué par l'interpréteur de commandes, et contient
      ainsi beaucoup d'éléments
      de configuration des programmes.  Voici une liste des variables
      d'environnement habituelles et ce qu'elles signifient:</para>
    <indexterm><primary>variables d'environnement</primary></indexterm>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Variable</entry>
	    <entry>Description</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>Le nom d'utilisateur de la personne actuellement
	      attachée au système.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>La liste des répertoires, séparés par
	      deux points, pour la recherche des programmes.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>Le nom réseau de l'affichage X11 auquel on peut se
	      connecter, si disponible.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>Le nom de l'interpréteur de commandes actuellement
	      utilisé.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>Le nom du type de terminal de l'utilisateur.  Utilisé pour
	      déterminer les capacités du terminal.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>L'entrée de la base de données des codes
	      d'échappement pour permettre l'exécution de
	      diverses fonctions du terminal.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>Type du système d'exploitation, e.g. FreeBSD.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>L'architecture du CPU sur lequel tourne actuellement
	      le système.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>L'éditeur de texte préferé de
	      l'utilisateur.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>Le visualisateur de page de texte préferré de
	      l'utilisateur.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>La liste des répertoires, séparés par
	      deux points, pour la recherche des pages de manuel.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>Bourne shells</primary></indexterm>
    <para>Fixer une variable d'environnement diffère
      légèrement d'un interpréteur de commandes
      &agrave; l'autre.  Par exemple,
      dans le style de l'interpréteur de commandes de type C-shell comme
      <command>tcsh</command> et <command>csh</command>, vous
      utiliseriez <command>setenv</command> pour fixer le
      contenu d'une variable d'environnement.  Sous les interpréteurs de
      commandes Bourne comme <command>sh</command> et
      <command>bash</command>, vous utiliseriez
      <command>export</command> pour configurer vos
      variables d'environnement.  Par exemple, pour fixer ou modifier la
      variable d'environnement <envar>EDITOR</envar>, sous
      <command>csh</command> ou <command>tcsh</command> une commande
      comme la suivante fixera <envar>EDITOR</envar> &agrave;
      <filename>/usr/local/bin/emacs</filename>:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Sous les interpréteurs de commandes Bourne:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>Vous pouvez faire afficher &agrave; la plupart des
      interpréteurs de commandes la variable d'environnement
      en plaçant un caractère
      <literal>$</literal> juste devant son nom sur la ligne
      de commande.  Par exemple, <command>echo $TERM</command> affichera
      le contenu de <envar>$TERM</envar>, car l'interpréteur de commande
      complète <envar>$TERM</envar> et passe la main &agrave;
      <command>echo</command>.</para>

    <para>Les interpréteurs de commandes traitent beaucoup de
      caractères spéciaux, appelés
      métacaractères, en tant que représentation
      particulière des données.  Le plus commun est le
      caractère <literal>*</literal>, qui représente
      zéro ou plusieurs caractères dans le nom du fichier.
      Ces métacaractères spéciaux peuvent être
      utilisés pour compléter automatiquement le nom des
      fichiers.  Par exemple, taper <command>echo *</command> est presque
      la même chose
      que taper <command>ls</command> parce que l'interpréteur de
      commandes prendra tous les fichiers qui correspondent &agrave;
      <literal>*</literal> et les passera &agrave; <command>echo</command> pour
      les afficher.</para>

    <para>Pour éviter que l'interpréteur de commande
      n'interprète les caractères spéciaux, ils peuvent
      être neutralisés en ajoutant un
      caractère antislash (<literal>\</literal>) devant.  <command>echo
      $TERM</command> affichera votre type de terminal.  <command>echo
      \$TERM</command> affichera <envar>$TERM</envar> tel quel.</para>

    <sect2 xml:id="changing-shells">
      <title>Changer d'interpréteur de commandes</title>

      <para>La méthode la plus simple pour changer votre
	interpréteur de commandes est d'utiliser la commande
	<command>chsh</command>.  En lançant <command>chsh</command>
	vous arriverez dans l'éditeur
	correspondant &agrave; votre variable d'environnement
	<envar>EDITOR</envar>; si elle n'est pas fixée, cela sera
	<command>vi</command>.  Modifiez la ligne &ldquo;Shell:&rdquo;
	en conséquence.</para>

      <para>Vous pouvez également passer le paramètre
	<option>-s</option> &agrave; <command>chsh</command>; cela modifiera
	votre interpréteur de commandes sans avoir &agrave; utiliser
	un éditeur.  Par exemple, si
	vous vouliez changer votre interpréteur de commandes pour
	<command>bash</command>,
	ce qui suit devrait faire l'affaire:</para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <note>
	<para>L'interpréteur de commandes que vous désirez
	  utiliser <emphasis>doit</emphasis> être présent dans
	  le fichier <filename>/etc/shells</filename>.  Si vous avez
	  installé l'interpréteur de commandes &agrave; partir
	  du <link linkend="ports">catalogue des logiciels portés</link>,
	  alors cela a dû déj&agrave; être fait pour vous.
	  Si vous avez installé &agrave;
	  la main l'interpréteur de commandes, vous devez alors le
	  faire.</para>

      <para>Par exemple, si vous avez installé <command>bash</command>
	&agrave; la main et l'avez placé dans
	<filename>/usr/local/bin</filename>, vous devrez faire:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Puis relancer <command>chsh</command>.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 xml:id="editors">
    <title>Editeurs de texte</title>
    <indexterm><primary>éditeurs de texte</primary></indexterm>
    <indexterm><primary>éditeurs</primary></indexterm>

    <para>Beaucoup de configurations sous FreeBSD sont faites en éditant
      des fichiers textes.  Aussi ce serait une bonne idée de se
      familiariser avec un éditeur de texte.  FreeBSD est fourni avec
      quelques-uns en tant qu'éléments du système de base,
      et beaucoup d'autres sont disponibles dans le catalogue des logiciels
      portés.</para>

    <indexterm>
      <primary>éditeurs</primary>
      <secondary><command>ee</command></secondary>
    </indexterm>
    <para>L'éditeur de plus facile et le plus simple &agrave; apprendre
      est un éditeur appelé <application>ee</application>,
      qui signifie l'éditeur facile (easy editor).  Pour lancer
      <application>ee</application>, on taperait sur la ligne de
      commande <command>ee fichier</command> où
      <replaceable>fichier</replaceable> est le nom du fichier qui doit être
      édité.  Par exemple, pour éditer
      <filename>/etc/rc.conf</filename>, tapez <command>ee
      /etc/rc.conf</command>.  Une fois sous <command>ee</command>, toutes
      les commandes pour utiliser les fonctions de l'éditeur sont
      affichées en haut de l'écran.  Le caractère
      <literal>^</literal>
      représente la touche <keycap>Ctrl</keycap> sur le clavier, donc
      <literal>^e</literal> représente la combinaison de touches
      <keycombo action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>.
      Pour quitter <application>ee</application>, appuyez sur la touche
      <keycap>Echap</keycap>, ensuite choisissez
      &ldquo;leave editor&rdquo;.  L'éditeur
      vous demandera s'il doit sauver les changements si le fichier a
      été modifié.</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>éditeurs</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>éditeurs</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>
    <para>FreeBSD est également fourni avec des éditeurs de texte
      plus puissants comme <application>vi</application> en tant
      qu'élément du
      système de base, alors que d'autres éditeurs, comme
      <application>Emacs</application> et <application>vim</application>, en tant
      qu'élément du catalogue des logiciels portés de
      FreeBSD (<package>editors/emacs</package> et <package>editors/vim</package>).  Ces éditeurs offrent beaucoup plus de
      fonctionnalités et de puissance aux dépens d'être
      un peu plus compliqués &agrave; apprendre.
      Cependant si vous projetez de faire beaucoup d'édition de texte,
      l'étude d'un éditeur plus puissant comme
      <application>vim</application> ou
      <application>Emacs</application> vous permettra d'économiser beaucoup plus
      de temps &agrave; la longue.</para>
  </sect1>

  <sect1 xml:id="basics-devices">
    <title>Périphériques et fichiers spéciaux de
      périphérique</title>

    <para>Un périphérique est un terme utilisé la plupart
      du temps pour les activités en rapport avec le matériel
      présent sur le système,
      incluant les disques, les imprimantes, les cartes graphiques, et les
      claviers.  Quand FreeBSD démarre, la majorité de ce
      qu'affiche FreeBSD est la détection des
      périphériques.  Vous pouvez &agrave; nouveau
      consulter les messages de démarrage en visualisant le fichier
      <filename>/var/run/dmesg.boot</filename>.</para>

    <para>Par exemple, <filename>acd0</filename> est le premier
      lecteur de CDROM IDE, tandis que <filename>kbd0</filename>
      représente le clavier.</para>

    <para>La plupart de ces périphériques sous un système
      d'exploitation &unix; peuvent être accédés par
      l'intermédiaire de fichiers appelés fichiers
      spéciaux de périphérique
      (&ldquo;device node&rdquo;), qui sont situés dans le
      répertoire <filename>/dev</filename>.</para>

    <sect2>
      <title>Créer des fichiers spéciaux de
	périphérique</title>
      <para>Quand vous ajoutez un nouveau périphérique
	&agrave; votre système, ou compilez le support pour des
	périphériques supplémentaires, de nouveaux
	fichiers spéciaux de périphérique doivent
	être créés.</para>

      <sect3>
	<title><literal>DEVFS</literal> (&ldquo;DEVice File System&rdquo; -
	  Système de fichiers de périphérique)</title>

	<para>Le système de fichiers de périphérique, ou
	  <literal>DEVFS</literal>, fournit un accès &agrave; l'espace
	  nom des périphériques du noyau dans l'espace nom du
	  système de fichiers global.  Au lieu d'avoir &agrave;
	  créer et modifier les fichiers spéciaux de
	  périphérique, <literal>DEVFS</literal>
	  maintient ce système de fichiers particulier pour vous.</para>

	<para>Voir la page de manuel de &man.devfs.5; pour plus
	  d'information.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="binary-formats">
    <title>Le format des fichiers binaires</title>

    <para>Afin de comprendre pourquoi &os; utilise le format
      &man.elf.5;, vous devez d'abord connaître
      quelques détails concernant les trois formats
      &ldquo;dominants&rdquo; d'exécutables actuellement en vigueur
      sous &unix;:</para>

    <itemizedlist>
      <listitem>
	<para>&man.a.out.5;</para>

	<para>Le plus vieux et le format objet &ldquo;classique&rdquo;
	  d'&unix;.  Il utilise une entête courte et compacte
	  avec un nombre magique au début qui est souvent
	  utilisé pour caractériser le format (voir la
	  page de manuel &man.a.out.5; pour plus de détails).
	  Il contient trois segments chargés: .text, .data,
	  et .bss plus une table de symboles et une table de
	  chaînes de caractères.</para>
      </listitem>

      <listitem>
        <para><acronym>COFF</acronym></para>

        <para>Le format objet SVR3.  L'entête comprend une
	  table de section, de telle sorte que vous avez plus de
	  sections qu'uniquement .text, .data et .bss.</para>
      </listitem>

      <listitem>
        <para>&man.elf.5;</para>

        <para>Le successeur de <acronym>COFF</acronym>, qui
	  permet des sections multiples et des valeurs possibles de 32
	  bits et 64 bits.  Un inconvénient majeur:
	  <acronym>ELF</acronym> a aussi été conçu
	  en supposant qu'il y aurait qu'un seul ABI par architecture
	  système.  Cette hypothèse est en fait assez
	  incorrecte, et même dans le monde SYSV (qui a
	  au moins trois ABIs: SVR4, Solaris, SCO) cela ne se
	  vérifie pas.</para>

        <para>&os; essaye de contourner ce problème en
	  fournissant un utilitaire pour <emphasis>marquer</emphasis>
	  un exécutable connu <acronym>ELF</acronym> avec
	  des informations sur l'ABI qui va avec.  Consultez la page
	  de manuel de &man.brandelf.1; pour plus
	  d'informations.</para>
      </listitem>
    </itemizedlist>

    <para>&os; vient du camp &ldquo;classique&rdquo; et a
      utilisé le format &man.a.out.5;, une technologie
      employée et éprouvée &agrave; travers des
      générations de BSDs, jusqu'aux débuts de la
      branche 3.X.  Bien qu'il fut possible de compiler et
      d'exécuter des binaires natifs <acronym>ELF</acronym> (et
      noyaux) sous &os; avant cela, &os; a initialement
      résisté &agrave; la &ldquo;pression&rdquo; de passer
      &agrave; <acronym>ELF</acronym> comme format par défaut.
      Pourquoi?  Bien, quand le camp Linux ont fait leur
      pénible transition vers <acronym>ELF</acronym>, ce n'est pas
      tant fuir le format <filename>a.out</filename> qui rendait
      difficile la construction de bibliothèques partagée
      pour les développeurs mais le mécanisme de
      bibliothèques partagées basé sur des tables de
      sauts inflexible.  Puisque les outils <acronym>ELF</acronym>
      disponibles offraient une solution au problème
      des bibliothèques partagées et étaient
      perçus comme &ldquo;le chemin &agrave; suivre&rdquo; de toute
      façon, le coût de la migration a été
      accepté comme nécessaire, et la transition a
      été réalisée.  Le mécanisme &os;
      de bibliothèques partagées se rapproche plus
      du style de mécanisme de bibliothèques
      partagées de &sunos; de Sun, et est très simple
      &agrave; utiliser.</para>

    <para>Pourquoi existe-t-il tant de formats différents?</para>

    <para>Dans un obscure et lointain passé, il y avait du
      matériel simple.  Ce matériel simple supportait
      un simple petit système.  <filename>a.out</filename>
      était complètement adapté pour
      représenter les binaires sur ce système simple
      (un PDP-11).  Au fur et &agrave; mesure que des personnes
      portaient &unix; &agrave; partir de ce système
      simple, ils ont maintenus le format <filename>a.out</filename>
      parce qu'il était suffisant pour les premiers portages
      d'&unix; sur des architectures comme le Motorola 68k, les VAX,
      etc.</para>

    <para>Alors un certain ingénieur matériel brillant
      a décidé qu'il pourrait forcer le matériel
      &agrave; faire des choses bizarre, l'autorisant ainsi &agrave;
      réduire le nombre de portes logiques et permettant
      au coeur du CPU de fonctionner plus rapidement.
      Bien qu'on l'a fait fonctionner avec ce nouveau
      type de matériel (connu de nos jour sous le nom de
      <acronym>RISC</acronym>), <filename>a.out</filename> n'était pas adapté
      &agrave; ce matériel, aussi beaucoup de formats ont
      été développés
      pour obtenir de meilleures performances de ce matériel
      que ce que pouvait offrir le simple et limité format
      qu'était <filename>a.out</filename>.  Des
      choses comme <acronym>COFF</acronym>, <acronym>ECOFF</acronym>,
      et quelques autres obscures formats ont été
      inventé et leur limites explorées avant que les choses
      ne se fixent sur <acronym>ELF</acronym>.</para>

    <para>En outre, les tailles des programmes devenaient
      énormes alors que les disques (et la mémoire
      physique) étaient toujours relativement
      petits, aussi le concept de bibliothèque partagée
      est né.  Le système de VM (mémoire virtuelle)
      est également devenu plus sophistiqué.
      Tandis que chacune de ces avancées était
      faites en utilisant le format <filename>a.out</filename>,
      son utilité a été élargie
      de plus en plus avec chaque nouvelle fonction.  De plus les
      gens ont voulu charger dynamiquement des choses &agrave;
      l'exécution, ou se débarrasser de partie de
      leur programme après l'initialisation pour économiser
      de l'espace mémoire et de pagination.  Les langages
      sont devenus plus sophistiqués et les gens ont voulu
      du code appelé automatiquement avant la partie
      principale du programme.  Beaucoup de modifications ont
      été apportées au format <filename>a.out</filename>
      pour rendre possible toutes ces choses, et cela a
      fonctionné pendant un certain temps.  Avec le temps,
      <filename>a.out</filename> n'était plus capable de
      gérer tous ces problèmes sans une augmentation
      toujours croissante du code et de sa complexité.
      Tandis <acronym>ELF</acronym> résolvait plusieurs de
      ces problèmes, il aurait été pénible
      de quitter un système qui a fonctionné.
      Ainsi <acronym>ELF</acronym> a dû attendre jusqu'au moment
      où il était plus pénible de rester avec
      <filename>a.out</filename> que d'émigrer vers
      <acronym>ELF</acronym>.</para>

    <para>Cependant, avec le temps, les outils de compilation
      desquels ceux de &os; sont dérivés (l'assembleur
      et le chargeur tout spécialement) ont
      évolué en parallèle.
      Les développeurs &os; ajoutèrent les
      bibliothèques partagées et corrigèrent
      quelques bogues.  Les gens de chez GNU qui ont &agrave;
      l'origine écrit ces programmes, les récrivirent
      et ajoutèrent un support plus simple pour la compilation
      multi-plateformes, avec différents formats
      &agrave; volonté, et ainsi de suite.  Lorsque beaucoup de personnes
      ont voulu élaborer des compilateurs multi-plateformes
      pour &os;, elles n'eurent pas beaucoup de chance puisque
      les anciennes sources que &os; avait pour
      <application>as</application> et <application>ld</application>
      n'étaient pas adaptées &agrave; cette tâche.
      Le nouvel ensemble d'outils de GNU
      (<application>binutils</application>) supporte la compilation
      multi-plateformes, <acronym>ELF</acronym>, les
      bibliothèques partagées, les extensions C++, etc.
      De plus, de nombreux vendeurs de logiciels fournissent des
      binaires <acronym>ELF</acronym>, et c'est une bonne chose pour
      permettre leur exécution sous &os;.</para>

    <para><acronym>ELF</acronym> est plus expressif
      qu'<filename>a.out</filename> et permet plus d'extensibilité
      dans le système de base.
      Les outils <acronym>ELF</acronym> sont mieux maintenus, et
      offrent un support pour la compilation multi-plateformes, ce qui
      est important pour de nombreuses personnes.
      <acronym>ELF</acronym> peut être légèrement plus lent
      qu'<filename>a.out</filename>, mais tenter de mesurer cette
      différence n'est pas aisé.  Il y a
      également de nombreux détails qui
      diffèrent entre les deux dans la façon dont
      ils mappent les pages mémoire, gère le code
      d'initialisation, etc.
      Dans le futur, le support <filename>a.out</filename> sera
      retiré du noyau <filename>GENERIC</filename>, et
      par la suite retiré des sources du noyau une fois que le
      besoin d'exécuter d'anciens programmes
      <filename>a.out</filename> aura disparu.</para>
  </sect1>

  <sect1 xml:id="basics-more-information">
    <title>Pour plus d'information</title>

    <sect2 xml:id="basics-man">
      <title>Les pages de manuel</title>
      <indexterm><primary>pages de manuel</primary></indexterm>

      <para>La documentation la plus complète sur FreeBSD est sous la
	forme de pages de manuel.  Presque chaque programme sur le
	système est fournit avec un court manuel de
	référence expliquant l'utilisation de base et les
	diverses options.  Ces manuels peuvent être visualisés
	avec la commande <command>man</command>.
	L'utilisation de la commande <command>man</command> est
	simple:</para>

      <screen>&prompt.user; <userinput>man command</userinput></screen>

      <para><literal>command</literal> est le nom de la commande
	&agrave; propos de laquelle vous désirez en savoir plus.
	Par exemple, pour en savoir plus au sujet de la commande
	<command>ls</command> tapez:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>Les manuels en ligne sont divisés en sections
	numérotées:</para>

      <orderedlist>
	<listitem>
	  <para>Commandes utilisateur.</para>
	</listitem>

	<listitem>
	  <para>Appels système et numéros d'erreur.</para>
	</listitem>

	<listitem>
	  <para>Fonctions des bibliothèques C.</para>
	</listitem>

	<listitem>
	  <para>Pilotes de périphérique.</para>
	</listitem>

	<listitem>
	  <para>Formats de fichier.</para>
	</listitem>

	<listitem>
	  <para>Jeux et autres divertissements.</para>
	</listitem>

	<listitem>
	  <para>Information diverse.</para>
	</listitem>

	<listitem>
	  <para>Commandes de maintenance et d'utilisation du
	    système.</para>
	</listitem>

	<listitem>
	  <para>Information de développement du noyau.</para>
	</listitem>
      </orderedlist>

      <para>Dans certains cas, le même sujet peut apparaître
	dans plus d'une section du manuel en ligne.  Par exemple, il existe une
	commande utilisateur <command>chmod</command> et un appel
	système <function>chmod()</function>.  Dans ce cas, vous pouvez
	préciser &agrave; la commande <command>man</command> laquelle
	vous désirez en spécifiant la section:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>Cela affichera la page de manuel de la commande utilisateur
	<command>chmod</command>.  Les références &agrave;
	une section particulière du manuel en ligne sont
	traditionnellement placées entre parenthèses, ainsi
	&man.chmod.1; se rapporte &agrave; la commande
	utilisateur <command>chmod</command> et &man.chmod.2; se
	rapporte &agrave; l'appel système.</para>

      <para>C'est parfait si vous connaissez le nom de la commande et
	vous souhaitez simplement savoir comment l'utiliser, mais qu'en
	est-il si vous ne pouvez pas vous rappelez du nom de la
	commande?  Vous pouvez utiliser <command>man</command> pour
	rechercher des mots-clés dans les descriptions de commandes en
	employant l'option <option>-k</option>:</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>Avec cette commande on vous affichera la liste des commandes
	qui ont le mot-clé &ldquo;mail&rdquo; dans leurs descriptions.
	C'est en fait équivalent &agrave; l'utilisation de la commande
	<command>apropos</command>.</para>

      <para>Ainsi, vous regardez toutes ces commandes fantaisistes
	contenues dans <filename>/usr/bin</filename> mais vous n'avez
	pas la moindre idée de ce quelles font vraiment?  Faites
	simplement:</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

	<para>ou</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

	<para>ce qui fait la même chose.</para>
    </sect2>

    <sect2 xml:id="basics-info">
      <title>Fichiers GNU Info</title>
      <indexterm><primary>Free Software Foundation</primary></indexterm>
      <indexterm><primary>Fondation pour le Logiciel Libre</primary></indexterm>

      <para>FreeBSD inclut beaucoup d'applications et d'utilitaires
	produit par la Fondation pour le Logiciel Libre ( Free Software
	Foundation).  En plus des pages de manuel, ces programmes sont
	fournis avec des documents hypertexte appelés fichiers
	<literal>info</literal> qui peuvent être lus avec la commande
	<command>info</command> ou, si vous avez installé
	<application>emacs</application>, dans le mode info
	d'<application>emacs</application>.</para>

      <para>Pour utiliser la commande &man.info.1;, tapez simplement:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>Pour une brève introduction, tapez <literal>h</literal>.
	Pour une référence rapide sur la commande, tapez
	<literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>
