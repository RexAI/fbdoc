<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD French Documentation Project

     $FreeBSD$
     Original revision: 1.176
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="kernelconfig">
  <info><title>Configurer le noyau de FreeBSD</title>
    <authorgroup>
      <author><personname><firstname>Jim</firstname><surname>Mock</surname></personname><contrib>Mis &agrave; jour et restructuré par </contrib></author>
    </authorgroup>
    <authorgroup>
      <author><personname><firstname>Jake</firstname><surname>Hamby</surname></personname><contrib>Contribution originale de </contrib></author>
    </authorgroup>
  </info>

  
  &trans.a.fonvieille;

  <sect1 xml:id="kernelconfig-synopsis">
    <title>Synopsis</title>

    <indexterm>
      <primary>noyau</primary>
      <secondary>compiler un noyau sur mesure</secondary>
    </indexterm>

    <para>Le noyau est le coeur du système d'exploitation FreeBSD.
      Il est responsable de la gestion de la mémoire, de la mise en
      application des contrôles de sécurité,
      du réseau, des accès disque, et bien plus.  Bien que
      FreeBSD devienne de plus en plus configurable dynamiquement, il est
      toujours nécessaire occasionnellement de reconfigurer
      et recompiler votre noyau.</para>

    <para>Après la lecture de ce chapitre, vous saurez:</para>

    <itemizedlist>
      <listitem>
	<para>Pourquoi vous pourriez avoir besoin de compiler un noyau
	  sur mesure.</para>
      </listitem>

      <listitem>
	<para>Comment écrire un fichier de configuration du noyau, ou
	  modifier un fichier de configuration existant.</para>
      </listitem>

      <listitem>
	<para>Comment utiliser le fichier de configuration du noyau pour
	  créer et recompiler un nouveau noyau.</para>
      </listitem>

      <listitem>
	<para>Comment installer un nouveau noyau.</para>
      </listitem>

      <listitem>
	<para>Que faire si quelque chose se passe mal.</para>
      </listitem>
    </itemizedlist>

    <para>Toutes les commandes listées dans les exemples de ce
      chapitre doivent être exécutées en tant que
      <systemitem class="username">root</systemitem> afin de fonctionner.</para>
  </sect1>

  <sect1 xml:id="kernelconfig-custom-kernel">
    <title>Pourquoi compiler un noyau sur mesure?</title>

    <para>Traditionnellement, FreeBSD a eu ce qui s'appelle un noyau
      &ldquo;monolithique&rdquo;.  Cela signifie que le noyau était
      un gros programme, supportant une liste figée de
      périphériques, et si vous vouliez modifier le
      comportement du noyau alors vous deviez compiler un nouveau noyau, et
      ensuite redémarrer votre ordinateur avec le nouveau noyau.</para>

    <para>Aujourd'hui, FreeBSD s'oriente rapidement vers un modèle
      où une grande partie des fonctions du noyau est contenue dans des
      modules qui peuvent être dynamiquement chargés
      et déchargés si nécessaire.
      Cela permet au noyau de s'adapter au nouveau matériel devenant
      soudainement disponible (comme les cartes PCMCIA dans un
      ordinateur portable), ou pour qu'une nouvelle fonctionnalité
      qui n'était pas nécessaire lors de la compilation
      du noyau y soit intégrée.  On appelle cela un noyau
      modulaire.</para>

    <para>En dépit de cela, il est encore nécessaire d'effectuer
      certaines configurations de noyau en statique.  Dans certains cas
      c'est parce que la fonctionnalité est si proche du noyau
      qu'elle ne peut être rendue dynamiquement chargeable.  Dans d'autres
      cas, cela peut tout simplement venir du fait que personne n'a
      encore pris le temps d'écrire un module dynamiquement chargeable
      pour cette fonctionnalité.</para>

    <para>Compiler un noyau sur mesure est l'un des plus importants
      rites de passage que doit endurer tout utilisateur BSD.  Cette
      opération, tout en prenant du temps, apportera de nombreuses
      améliorations &agrave; votre système FreeBSD.
      A la différence du noyau <filename>GENERIC</filename>,
      qui doit supporter une large gamme de matériels, un noyau sur
      mesure ne contient que le support pour <emphasis>votre</emphasis>
      configuration matérielle.  Cela a de nombreux avantages,
      comme:</para>

    <itemizedlist>
      <listitem>
	<para>Un temps de démarrage plus court.  Comme le noyau ne
	  recherchera que le matériel présent sur votre
	  système, le temps nécessaire au démarrage de
	  votre système peut diminuer de façon importante.</para>
      </listitem>

      <listitem>
	<para>Une utilisation plus faible de la mémoire.  Un noyau sur
	  mesure utilise souvent moins de mémoire que le noyau
	  <filename>GENERIC</filename>, ce qui est important car le noyau
	  doit toujours résider en mémoire.  Pour cette
	  raison, un noyau sur mesure est tout particulièrement utile
	  sur un système dont les ressources mémoire sont
	  limitées.</para>
      </listitem>

      <listitem>
	<para>Le support de matériels supplémentaires.  Un noyau
	  sur mesure vous permet d'intégrer le support pour des
	  périphériques, qui ne sont
	  pas présents dans le noyau
	  <filename>GENERIC</filename> comme les cartes son.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="kernelconfig-building">
    <title>Compiler et installer un noyau sur mesure</title>
    <indexterm>
      <primary>noyau</primary>
      <secondary>compiler / installer</secondary>
    </indexterm>

    <para>Commençons par passer rapidement en revue le répertoire
      de configuration du noyau.  Tous les chemins d'accès
      mentionnés seront relatifs au répertoire principal
      <filename>/usr/src/sys</filename>, qui est également
      accessible via le lien symbolique <filename>/sys</filename>.
      Il comporte un certain nombre de sous-répertoires correspondants
      &agrave; différentes parties du noyau, mais les plus
      importantes, en ce qui nous concerne, sont
      <filename>arch/conf</filename>, où vous
      éditerez votre fichier configuration personnalisé, et
      <filename>compile</filename>, qui est l'espace de travail où
      votre noyau sera compilé.  <replaceable>arch</replaceable>
      représente une des architectures suivante: <filename>i386</filename>, soit
      <filename>alpha</filename>, <filename>amd64</filename>,
      <filename>ia64</filename>, <filename>powerpc</filename>,
      <filename>sparc64</filename>, ou encore <filename>pc98</filename>
      (une branche alternative de développement de l'architecture PC,
      populaire au Japon).  Tout ce qui se trouve dans un répertoire
      particulier &agrave; une architecture est propre uniquement
      &agrave; cette architecture; le reste du code est un code indépendant du type de machine et commun &agrave;
      toutes les plates-formes sur lesquelles FreeBSD pourrait être
      potentiellement porté.  Remarquez l'organisation logique de
      l'arborescence des répertoires, où chaque
      périphérique, système de fichiers,
      et option supportés a son propre
      sous-répertoire.</para>

    <para>Les exemples de ce chapitre supposent que vous utilisez
      l'architecture i386.  Si ce n'est pas votre cas, effectuez les
      ajustements appropriés au niveau des chemins
      d'accès pour votre architecture.</para>

    <note>
      <para>S'il n'y a <emphasis>pas</emphasis> de répertoire
	<filename>/usr/src/sys</filename> sur votre système,
	alors c'est que les sources du noyau n'ont pas été
	installées.  La manière la plus facile de les installer
	est d'exécuter <command>sysinstall</command>
	en tant
	que <systemitem class="username">root</systemitem>, et sélectionner
	<guimenuitem>Configure</guimenuitem>, puis
	<guimenuitem>Distributions</guimenuitem>,
	<guimenuitem>src</guimenuitem>, puis
	<guimenuitem>base</guimenuitem> et <guimenuitem>sys</guimenuitem>.
	Si vous avez une aversion envers <application>sysinstall</application>
	et que vous disposez d'un CDROM &ldquo;officiel&rdquo; de
	FreeBSD, alors vous pouvez installer les sources depuis la
	ligne de commande:</para>

      <screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>mkdir -p /usr/src/sys</userinput>
&prompt.root; <userinput>ln -s /usr/src/sys /sys</userinput>
&prompt.root; <userinput>cat /cdrom/src/ssys.[a-d]* | tar -xzvf -</userinput>
&prompt.root; <userinput>cat /cdrom/src/sbase.[a-d]* | tar -xzvf -</userinput></screen>
    </note>

    <para>Ensuite allez dans le répertoire
      <filename>arch/conf</filename> et copiez
      le fichier de configuration <filename>GENERIC</filename> dans un
      fichier qui portera le nom que vous voulez donner &agrave; votre
      noyau.  Par exemple:</para>

    <screen>&prompt.root; <userinput>cd /usr/src/sys/i386/conf</userinput>
&prompt.root; <userinput>cp GENERIC MONNOYAU</userinput></screen>

    <para>Par tradition, c'est un nom en majuscules, et si vous maintenez
      plusieurs machines FreeBSD avec des configurations matérielles
      différentes, c'est une bonne idée de lui donner le
      même nom que la machine.  Nous l'appellerons
      <filename>MONNOYAU</filename> pour les besoins de cet
      exemple.</para>

    <tip>
      <para>Conserver votre fichier de configuration du noyau
	directement sous <filename>/usr/src</filename> peut être une
	mauvaise idée.  Si vous avez des problèmes
	il peut être tentant de juste effacer
	<filename>/usr/src</filename> et recommencer &agrave; nouveau.
	Après avoir fait cela ne prends que quelques secondes
	pour vous rendre compte que vous venez
	d'effacer votre fichier de configuration du noyau
	personnalisé.  N'éditez pas, non plus, directement le fichier
	<filename>GENERIC</filename>, il peut être
	écrasé &agrave; la prochaine <link linkend="updating-upgrading">mise &agrave; jour de l'arborescence
	des sources</link>, et vos modifications seraient
	perdues.</para>

      <para>Vous voudrez peut être conserver votre fichier de
	configuration du noyau ailleurs et alors créer un lien
	symbolique vers le fichier dans le répertoire
	<filename>i386</filename>.</para>

      <para>Par exemple:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/sys/i386/conf</userinput>
&prompt.root; <userinput>mkdir /root/noyaux</userinput>
&prompt.root; <userinput>cp GENERIC /root/noyaux/MONNOYAU</userinput>
&prompt.root; <userinput>ln -s /root/noyaux/MONNOYAU</userinput></screen>
    </tip>

    <para>Editez maintenant <filename>MONNOYAU</filename> avec votre
      éditeur de texte préféré.
      Si vous venez tout juste de finir l'installation, le seul
      éditeur disponible sera probablement
      <application>vi</application>, qui est trop complexe pour être
      décrit ici, mais est bien expliqué dans de nombreux
      ouvrages de la <link linkend="bibliography">bibliographie</link>.
      Cependant, FreeBSD offre un éditeur plus simple appelé
      <application>ee</application> qui, si vous êtes débutant,
      sera votre éditeur de choix.  N'hésitez pas &agrave;
      modifier les commentaires d'entête pour y décrire
      votre configuration ou les modifications que vous avez apportés
      par rapport au noyau <filename>GENERIC</filename>.</para>
    <indexterm><primary>SunOS</primary></indexterm>

    <para>Si vous avez déj&agrave; compilé un noyau sur &sunos;
      ou tout autre système d'exploitation BSD, l'essentiel de fichier
      vous sera familier.  Si vous venez d'un système d'exploitation
      comme DOS, &agrave; l'inverse, le fichier de configuration
      <filename>GENERIC</filename> vous paraîtra inintelligible, lisez
      alors lentement et attentivement la section sur <link linkend="kernelconfig-config">le fichier de
      configuration</link>.</para>

    <note>
      <para>Si vous <link linkend="updating-upgrading">synchronisez
	votre arborescence des sources</link> avec les toutes
	dernières sources du projet &os;, assurez-vous de
	toujours lire le fichier <filename>/usr/src/UPDATING</filename>
	avant d'effectuer une quelconque opération de mise
	&agrave; jour.  Ce fichier décrit les problèmes
	importants ou les domaines demandant une attention
	particulière dans le code mis &agrave; jour.
	<filename>/usr/src/UPDATING</filename> correspond toujours
	&agrave; votre version des sources de &os;, et est donc plus
	&agrave; jour que ce Manuel.</para>
    </note>

    <para>Vous devez maintenant compiler le code source du
      noyau.</para>

    <procedure>
      <title>Compiler un noyau</title>

      <step>
	<para>Passez dans le répertoire
	  <filename>/usr/src</filename>.</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>
      </step>

      <step>
	<para>Compilez le noyau:</para>

	<screen>&prompt.root; <userinput>make buildkernel KERNCONF=MONNOYAU</userinput></screen>
      </step>

      <step>
	<para>Installez le nouveau noyau:</para>

	<screen>&prompt.root; <userinput>make installkernel KERNCONF=MONNOYAU</userinput></screen>
      </step>
    </procedure>

    <note>
      <para>Il est indispensable d'avoir l'intégralité
	des sources du système &os; pour compiler le
	noyau.</para>
    </note>

    <tip>
      <para>Par défaut, quand vous compilez un noyau
	personnalisé, <emphasis>tous</emphasis> les modules
	seront également recompilés.  Si vous
	désirez mettre &agrave; jour un noyau plus rapidement
	ou compiler que certains modules, vous devez éditer le
	fichier <filename>/etc/make.conf</filename> avant de compiler
	le noyau:</para>

      <programlisting>MODULES_OVERRIDE = linux acpi sound/sound sound/driver/ds1 ntfs</programlisting>

      <para>Cette variable définit une liste de modules
	&agrave; compiler &agrave; la place de
	l'intégralité des modules.</para>

      <programlisting>WITHOUT_MODULES = linux acpi sound/sound sound/driver/ds1 ntfs</programlisting>

      <para>Cette variable définit une liste de modules
	&agrave; exclure du processus de compilation.  Pour d'autres
	variables qui peuvent être intéressantes pour le
	processus de compilation du noyau, consultez la page de manuel
	&man.make.conf.5;.</para>
    </tip>

    <indexterm>
      <primary><filename>/boot/kernel.old</filename></primary>
    </indexterm>

    <para>Le nouveau noyau sera copié dans le répertoire
      <filename>/boot/kernel</filename> avec le nom
      <filename>/boot/kernel/kernel</filename> et l'ancien noyau sera renommé en
      <filename>/boot/kernel.old/kernel</filename>.  Maintenant, arrêtez
      le système et redémarrez pour utiliser votre
      nouveau noyau.
      Si quelque chose se passe mal, il y a quelques instructions
      de <link linkend="kernelconfig-trouble">dépannage</link> &agrave;
      la fin de ce chapitre que vous pourrez trouver utiles.  Assurez-vous de lire la section qui
      explique comment revenir en arrière dans le cas où
      votre nouveau noyau <link linkend="kernelconfig-noboot">ne
      démarre pas</link>.</para>

    <note>
      <para>Les autres fichiers
	concernant le processus de démarrage, comme le chargeur
	(&man.loader.8;) et la configuration du démarrage
	sont conservés dans le
	répertoire <filename>/boot</filename>.
	Les modules tiers et personnalisés peuvent être
	placés dans <filename>/boot/kernel</filename>,
	bien que les utilisateurs doivent être conscients
	que garder ses modules synchronisés avec le noyau
	compilé est très important.
	Les modules qui ne sont pas destinés &agrave; fonctionner
	avec le noyau compilé peuvent être instables et
	ne pas donner les résultats escomptés.</para></note>
  </sect1>

  <sect1 xml:id="kernelconfig-config">
    <info><title>Le fichier de configuration</title>
      <authorgroup>
	<author><personname><firstname>Joel</firstname><surname>Dahl</surname></personname><contrib>Mis &agrave; jour pour &os; 6.X par </contrib></author>
      </authorgroup>
    </info>
    
    <indexterm>
      <primary>noyau</primary>
      <secondary>NOTES</secondary>
    </indexterm>
    <indexterm><primary>NOTES</primary></indexterm>
    <indexterm>
      <primary>noyau</primary>
      <secondary>fichier de configuration</secondary>
    </indexterm>

    <para>Le format général du fichier de configuration
      est assez simple.  Chaque ligne est composée d'un
      mot-clé et d'un ou plusieurs arguments.  Pour simplifier,
      la plupart des lignes ne contiennent qu'un seul argument.
      Tout ce qui suit le caractère <literal>#</literal> est
      considéré comme un commentaire et ignoré.
      Les sections suivantes décrivent chaque mot-clé,
      dans l'ordre où ils apparaissent dans le fichier
      <filename>GENERIC</filename>.
      <anchor xml:id="kernelconfig-options"/> Pour une liste exhaustive des
      options et périphériques dépendants de
      l'architecture utilisée, consultez le fichier
      <filename>NOTES</filename> présent
      dans le même répertoire que le fichier <filename>GENERIC</filename>.
      Pour les options ne dépendant pas de l'architecture,
      consultez le fichier
      <filename>/usr/src/sys/conf/NOTES</filename>.</para>

    <note>
      <para>Pour compiler un fichier contenant toutes les options
	possibles, en général pour effectuer des tests,
	exécutez la commande suivante en tant que
	<systemitem class="username">root</systemitem>:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/sys/i386/conf &amp;&amp; make LINT</userinput></screen>
    </note>

    <indexterm>
      <primary>noyau</primary>
      <secondary>fichier de configuration</secondary>
    </indexterm>

    <para>Ce qui suit est un exemple de fichier de configuration du
      noyau <filename>GENERIC</filename> avec divers commentaires aux
      endroits nécessaires pour un peu plus de clarté.
      Cet exemple devrait correspondre de façon très proche
      &agrave; votre copie du fichier
      <filename>/usr/src/sys/i386/conf/GENERIC</filename>.
    </para>

    <indexterm>
      <primary>options du noyau</primary>
      <secondary>machine</secondary>
    </indexterm>

    <programlisting>machine		i386</programlisting>

    <para>C'est l'architecture de la machine.  Elle doit être
      <literal>alpha</literal>, <literal>amd64</literal>,
      <literal>i386</literal>, <literal>ia64</literal>,
      <literal>pc98</literal>, <literal>powerpc</literal>, ou encore
      <literal>sparc64</literal>.</para>

    <indexterm>
      <primary>options du noyau</primary>
      <secondary>cpu</secondary>
    </indexterm>
    <programlisting>cpu          I486_CPU
cpu          I586_CPU
cpu          I686_CPU</programlisting>

    <para>Ce qui précède définit le type de CPU
      présent dans votre système.  Il peut y avoir plusieurs
      occurrences de la ligne CPU (si, par exemple, vous n'êtes pas sûr
      de devoir utiliser <literal>I586_CPU</literal>
      ou <literal>I686_CPU</literal>), cependant, pour un noyau
      personnalisé, il est mieux de spécifier uniquement
      le CPU que vous avez.
      Si vous n'êtes pas sûr du type, vous pouvez lister
      le fichier <filename>/var/run/dmesg.boot</filename> pour visualiser les
      messages de démarrage.</para>

    <indexterm>
      <primary>options du noyau</primary>
      <secondary>ident</secondary>
    </indexterm>

    <programlisting>ident          GENERIC</programlisting>

    <para>C'est l'identification du noyau.  Vous devriez changer cela
      pour le nom, quel qu'il soit, que vous donnez &agrave; votre noyau,
      par exemple <literal>MONNOYAU</literal> si vous avez suivi les
      instructions des exemples précédents.
      La valeur que vous donnez &agrave; la chaîne <literal>ident</literal>
      s'affichera au démarrage du noyau, il est donc utile de donner
      au nouveau noyau un nom différent si vous voulez le
      différencier de votre noyau habituel (e.g., vous voulez compiler
      un noyau expérimental).</para>

    <programlisting>#To statically compile in device wiring instead of /boot/device.hints
#hints          "GENERIC.hints"         #Default places to look for devices.</programlisting>

    <para>Le fichier
      &man.device.hints.5; est utilisé pour configurer les
      paramètres des pilotes de périphériques.
      Le &man.loader.8; recherchera le fichier
      <filename>/boot/device.hints</filename> au démarrage.
      En utilisant l'option <literal>hints</literal> vous pouvez
      compiler ces valeurs en statique dans votre noyau.  Il
      n'est alors pas utile de créer de fichier
      <filename>device.hints</filename> dans
      <filename>/boot</filename>.</para>

    <!-- XXX: Add a comment here that explains when compiling hints
into the kernel is a good idea and why. -->

    <programlisting>makeoptions     DEBUG=-g          #Build kernel with gdb(1) debug symbols</programlisting>

    <para>Le processus normal de compilation de &os; inclut
      les informations de débogage lors de la compilation
      du noyau avec l'option
      <option>-g</option>, qui autorisera les informations de
      débogage quand le noyau sera passé &agrave;
      &man.gcc.1;.</para>

    <programlisting>options          SCHED_4BSD         # 4BSD scheduler</programlisting>

    <para>L'ordonnanceur (<quote>scheduler</quote>) traditionnel et
      par défaut de &os;.  Conservez cette ligne.</para>

    <programlisting>options          PREEMPTION         # Enable kernel thread preemption</programlisting>

    <para>Permet aux processus légers présents dans le
      noyau d'être devancés par des processus de
      priorité plus élevée.  Cela améliore
      l'interactivité et permet aux processus d'interruption
      d'être exécutés le plus tôt possible
      au lieu d'attendre leur tour.</para>

    <programlisting>options          INET          #InterNETworking</programlisting>

    <para>Support réseau.  Conservez-le, même si vous
      n'envisagez pas de vous connecter &agrave; un réseau.
      La plupart des programmes utilisent le réseau &ldquo;en
      boucle&rdquo; (i.e., établissent des connexions réseau
      avec le PC lui-même), cette option est donc quasiment
      obligatoire.</para>

    <programlisting>options          INET6          #IPv6 communications protocols</programlisting>

    <para>Ceci active les protocoles de communication IPv6.</para>

    <programlisting>options          FFS          #Berkeley Fast Filesystem </programlisting>

    <para>C'est le système de fichiers de base sur disque dur.
      Gardez ces options si vous démarrez depuis le disque
      dur.</para>

    <programlisting>options          SOFTUPDATES  #Enable FFS Soft Updates support</programlisting>

    <para>Cette option rajoutera le support des <quote>Soft
      Updates</quote> dans le noyau, ce qui aidera
      l'accélération des accès en écriture
      sur les disques.  Même quand cette fonction est fournit
      par le noyau, elle doit être activée sur chaque
      disque.  Regardez le résultat de la commande
      &man.mount.8; pour voir si les <quote>Soft Updates</quote> sont
      activées sur les disques de votre système.  Si
      vous ne voyez pas apparaître l'option
      <literal>soft-updates</literal> alors vous devrez l'activer en
      utilisant les commandes &man.tunefs.8; (pour les systèmes
      de fichiers existant) ou &man.newfs.8; (pour les nouveaux
      systèmes de fichiers).</para>

    <programlisting>options          UFS_ACL      #Support for access control lists</programlisting>

    <para>Cette option
      active le support des listes de contrôle d'accès
      au système de fichiers (<acronym>ACL</acronym>).
      Elles reposent sur l'utilisation
      d'attributs étendus et d'<acronym>UFS2</acronym>,
      cette fonctionnalité est décrite dans la <xref linkend="fs-acl"/>.  Les <acronym>ACL</acronym>s sont activées
      par défaut, et leur support ne devraient pas être
      retiré du noyau si elles ont été
      précédemment utilisées sur un
      système de fichiers, étant donné que cela
      supprimera les listes de contrôle d'accès
      changeant alors la façon dont sont protégés
      les fichiers d'une manière imprévisible.</para>

    <programlisting>options          UFS_DIRHASH  #Improve performance on big directories</programlisting>

    <para>Cette option inclut certaines fonctions pour accélérer les
      opérations disque sur de gros répertoires,
      aux dépens d'employer de la mémoire supplémentaire.
      Vous conserverez normalement cela pour un gros serveur, ou une
      station de travail très active, et vous l'enlèverez
      si vous utilisez FreeBSD sur un petit système où
      la mémoire prime et la vitesse d'accès disque est moins
      importante, comme pour un coupe-feu.</para>

    <programlisting>options          MD_ROOT      #MD is a potential root device</programlisting>

    <para>Cette option active le support pour des disques virtuels en
      mémoire utilisés comme périphérique
      racine.</para>

    <indexterm>
      <primary>options du noyau</primary>
      <secondary>NFS</secondary>
    </indexterm>
    <indexterm>
      <primary>options du noyau</primary>
      <secondary>NFS_ROOT</secondary>
    </indexterm>
    <programlisting>options          NFSCLIENT         # Network Filesystem Client
options          NFSSERVER         # Network Filesystem Server
options          NFS_ROOT          # NFS usable as /, requires NFSCLIENT</programlisting>

    <para>Le système de fichiers réseau.  A moins que vous
      n'envisagiez de monter des partitions d'un serveur de fichiers
      &unix; par l'intermédiaire d'un réseau TCP/IP, vous pouvez
      mettre en commentaire ces options.</para>

    <indexterm>
      <primary>options du noyau</primary>
      <secondary>MSDOSFS</secondary>
    </indexterm>
    <programlisting>options          MSDOSFS      #MSDOS Filesystem</programlisting>

    <para>Le système de fichiers &ms-dos;.  A moins que vous
      n'envisagiez de monter une partition DOS d'un disque dur au
      démarrage, vous pouvez sans risque commenter cette option.
      Le module sera automatiquement chargé la première
      fois que vous monterez une partition DOS, comme décrit
      plus haut.  Par ailleurs, l'excellent logiciel
      <package>emulators/mtools</package>
      vous permet d'accéder &agrave; des disquettes DOS sans avoir
      besoin de les monter (et ne requiert pas non plus
      <literal>MSDOSFS</literal>).</para>

    <programlisting>options          CD9660       #ISO 9660 Filesystem</programlisting>

    <para>Le système de fichiers ISO 9660 pour les CDROMs.  Commentez
      ces options si vous n'avez pas de lecteur de CDROM ou que vous
      ne montez qu'occasionnellement des CDROMs (il sera chargé
      dynamiquement dès que vous monterez un CDROM).  Les CDROMs
      audios n'ont pas besoin de ce système de fichiers.</para>

    <programlisting>options          PROCFS            # Process filesystem (requires PSEUDOFS)</programlisting>

    <para>Le système de fichiers pour les processus.  C'est un
      &ldquo;pseudo-système&rdquo; de fichiers monté sur
      <filename>/proc</filename> qui permet &agrave; des programmes comme
      &man.ps.1; de vous fournir plus d'informations sur les processus
      qui tournent sur le système.
      L'utilisation de <literal>PROCFS</literal> n'est pas
      nécessaire la plupart du temps, comme la majeur partie
      des outils de débogage et de monitoring ont
      été adaptés pour s'exécuter sans
      <literal>PROCFS</literal>: les
      nouvelles installations ne monteront pas par
      défaut ce système de fichiers.</para>

    <programlisting>options          PSEUDOFS     #Pseudo-filesystem framework</programlisting>

    <para>Les noyaux 6.X faisant usage du système
      <literal>PROCFS</literal> doivent également inclure le
      support pour <literal>PSEUDOFS</literal>.</para>

    <programlisting>options          GEOM_GPT          # GUID Partition Tables.</programlisting>

    <para>Cette option apporte la possibilité d'avoir un grand nombre
      de partitions sur un seul disque.</para>

    <programlisting>options          COMPAT_43    #Compatible with BSD 4.3 [KEEP THIS!]</programlisting>

    <para>Compatibilité avec 4.3BSD.  Conservez cette option; certains
      programmes auront un comportement bizarre si vous la
      commentez.</para>

    <programlisting>options          COMPAT_FREEBSD4     #Compatible with FreeBSD4</programlisting>

    <para>Cette option est nécessaires aux systèmes
      &i386; et Alpha fonctionnant sous &os;&nbsp;5.X pour supporter
      les applications compilées sur d'anciennes version de &os;
      qui utilisent d'anciennes interfaces d'appel système.
      Il est recommandé d'utiliser cette option sur tous
      les systèmes &i386; et Alpha susceptibles d'exécuter
      d'anciennes applications; les plateformes apparues sous &os;&nbsp;5.0,
      comme l'ia64 et &sparc64;, n'ont pas besoin de cette
      option.</para>

    <programlisting>options          COMPAT_FREEBSD5   # Compatible with &os;5</programlisting>

    <para>Cette option est nécessaire sous &os;&nbsp;6.X et
      versions supérieures pour supporter les applications
      compilées sous &os;&nbsp;5.X et qui utilisent les
      interfaces d'appel système &os;&nbsp;5.X.</para>

    <programlisting>options          SCSI_DELAY=5000    #Delay (in ms) before probing SCSI</programlisting>

    <para>Cette option oblige le noyau &agrave; attendre 5 secondes avant
      de rechercher les périphériques SCSI présents
      sur votre système.  Si vous n'avez que des disques IDE,
      vous pouvez l'ignorer, sinon vous pouvez essayer de
      diminuer cette valeur,
      pour accélérer le démarrage du système.
      Bien sûr, si vous le faites, et que FreeBSD a du mal &agrave;
      reconnaître vos périphériques SCSI, vous
      devrez l'augmenter &agrave; nouveau.</para>

    <programlisting>options          KTRACE              #ktrace(1) support</programlisting>

    <para>Ceci permet de tracer le processus du noyau, ce qui est
      utile pour le débogage.</para>

    <programlisting>options          SYSVSHM             #SYSV-style shared memory</programlisting>

    <para>Cette option implémente la mémoire
      partagée System&nbsp;V.  L'usage le plus courant qui en est fait est
      l'extension XSHM d'X, dont de nombreux logiciels gourmants en
      graphique tireront automatiquement parti pour fonctionner plus
      vite.  Si vous utilisez X, vous utiliserez absolument cette
      option.</para>

    <programlisting>options          SYSVMSG             #SYSV-style message queues</programlisting>

    <para>Support des messages System&nbsp;V.  Cette option n'augmente
      que de quelques centaines d'octets la taille du noyau.</para>

    <programlisting>options          SYSVSEM             #SYSV-style semaphores</programlisting>

    <para>Support des sémaphores System&nbsp;V.  D'un usage moins courant,
      mais n'augmente la taille du noyau que de quelques centaines
      d'octets.</para>

    <note>
      <para>L'option <option>-p</option> de la commande &man.ipcs.1; donnera la liste des processus
	utilisant chacun de ces mécanismes System&nbsp;V.</para>
    </note>

    <programlisting>options 	     _KPOSIX_PRIORITY_SCHEDULING # POSIX P1003_1B real-time extensions</programlisting>

    <para>Extensions temps-réel ajoutées dans la norme
      &posix; 1993.  Certaines applications du catalogue des logiciels
      portés les utilisent (comme
      <application>&staroffice;</application>).</para>

    <programlisting>options          KBD_INSTALL_CDEV  # install a CDEV entry in /dev</programlisting>

    <para>Cette option concerne le clavier.  Elle installe une
      entrée CDEV dans le répertoire
      <filename>/dev</filename>.</para>

    <programlisting>options          ADAPTIVE_GIANT    # Giant mutex is adaptive.</programlisting>

    <para><quote>Giant</quote> est le nom d'un mécanisme
      d'exclusion mutuelle (un <quote>mutex</quote> dormant) qui
      protège l'accès &agrave; un ensemble important de
      ressources du noyau.  Aujourd'hui c'est un goulot
      d'étranglement des performances inacceptable que l'on est
      en train de remplacer activement par des verrous qui
      protègent les ressources individuelles.  L'option
      <literal>ADAPTIVE_GIANT</literal> permet &agrave; Giant
      d'être inclus dans l'ensemble des mutex lancés de
      manière adaptative.  C'est &agrave; dire, quand un thread
      désire verrouiller le mutex Giant, mais que ce dernier
      est déj&agrave; verrouillé par un thread sur un
      autre CPU, le premier thread continuera &agrave; fonctionner et
      attendra la libération du verrou.  Normalement, le thread
      retournera &agrave; l'état dormant et attendra une
      nouvelle chance de pouvoir s'exécuter.  Si vous
      n'êtes pas sûr, laissez la configuration en
      l'état.</para>

    <indexterm>
      <primary>options du noyau</primary>
      <secondary>SMP</secondary>
    </indexterm>
    <programlisting>device          apic               # I/O APIC</programlisting>

    <para>Le périphérique apic active l'utilisation de
      l'E/S APIC pour l'acheminement des interruptions.  Le
      périphérique apic peut être utilisé
      dans les noyaux UP (monoprocesseur) et SMP, mais est requis pour
      les noyaux SMP.  Ajoutez <literal>options SMP</literal> pour
      inclure le support pour plusieurs processeurs.</para>

    <note>
      <para>Le périphérique apic n'existe que sur
	l'architecture i386, cette ligne de configuration ne doit pas
	être utilisée sur d'autres architectures.</para>
    </note>

    <programlisting>device          eisa</programlisting>

    <para>Rajoutez cela si vous avez une carte mère EISA.
      Cela permet l'auto-détection et la configuration de tous les
      périphériques présents sur le bus
      EISA.</para>

    <programlisting>device          pci</programlisting>

    <para>Ajoutez cette option si vous avez une carte mère PCI.
      Cela permet l'auto-détection des cartes PCI et gère
      l'interface entre les bus PCI et ISA.</para>

    <programlisting># Floppy drives
device          fdc</programlisting>

    <para>C'est le contrôleur de lecteur de disquettes.</para>

    <programlisting># ATA and ATAPI devices
device          ata</programlisting>

    <para>Ce pilote supporte tous les périphériques
      ATA et ATAPI.  Vous n'avez besoin que d'une seule ligne
      <literal>device ata</literal> pour que le noyau détecte tous les
      périphériques PCI ATA/ATAPI sur les machines
      modernes.</para>

    <programlisting>device          atadisk                 # ATA disk drives</programlisting>

    <para>Ceci est requis avec <literal>device ata</literal> pour les
      disques ATA.</para>

    <programlisting>device          ataraid                 # ATA RAID drives</programlisting>

    <para>Ceci est nécessaire avec <literal>device
      ata</literal> pour les disques RAID ATA.</para>

    <programlisting><anchor xml:id="kernelconfig-atapi"/>
device          atapicd                 # ATAPI CDROM drives</programlisting>

    <para>Ceci est nécessaire avec <literal>device ata</literal>
      pour le support des lecteurs de CDROM ATAPI.</para>

    <programlisting>device          atapifd                 # ATAPI floppy drives</programlisting>

    <para>Ceci est nécessaire avec <literal>device ata</literal>
      pour le support des lecteurs de disquettes ATAPI.</para>

    <programlisting>device          atapist                 # ATAPI tape drives</programlisting>

    <para>Ceci est nécessaire avec <literal>device ata</literal>
      pour le support des lecteurs de bande ATAPI.</para>

    <programlisting>options         ATA_STATIC_ID           #Static device numbering</programlisting>

    <para>Cela rend la numérotation des périphériques
      statique, sans cela l'allocation des numéros de
      périphériques sera dynamique.</para>

    <programlisting># SCSI Controllers
device          ahb        # EISA AHA1742 family
device          ahc        # AHA2940 and onboard AIC7xxx devices
options         AHC_REG_PRETTY_PRINT    # Print register bitfields in debug
                                        # output.  Adds ~128k to driver.
device          ahd        # AHA39320/29320 and onboard AIC79xx devices
options         AHD_REG_PRETTY_PRINT    # Print register bitfields in debug
                                        # output.  Adds ~215k to driver.
device          amd        # AMD 53C974 (Teckram DC-390(T))
device          isp        # Qlogic family
#device         ispfw      # Firmware for QLogic HBAs- normally a module
device          mpt        # LSI-Logic MPT-Fusion
#device         ncr        # NCR/Symbios Logic
device          sym        # NCR/Symbios Logic (newer chipsets + those of `ncr')
device          trm        # Tekram DC395U/UW/F DC315U adapters

device          adv        # Advansys SCSI adapters
device          adw        # Advansys wide SCSI adapters
device          aha        # Adaptec 154x SCSI adapters
device          aic        # Adaptec 15[012]x SCSI adapters, AIC-6[23]60.
device          bt         # Buslogic/Mylex MultiMaster SCSI adapters

device          ncv        # NCR 53C500
device          nsp        # Workbit Ninja SCSI-3
device          stg        # TMC 18C30/18C50</programlisting>

    <para>Contrôleurs SCSI.  Mettez en commentaires ceux que vous
      n'avez pas sur votre système.  Si vous n'avez qu'un
      système IDE, vous pouvez supprimer toutes ces lignes.  Les
      lignes <literal>*_REG_PRETTY_PRINT</literal> sont des options de
      débogage pour leur pilote respectif.</para>

    <programlisting># SCSI peripherals
device          scbus      # SCSI bus (required for SCSI)
device          ch         # SCSI media changers
device          da         # Direct Access (disks)
device          sa         # Sequential Access (tape etc)
device          cd         # CD
device          pass       # Passthrough device (direct SCSI access)
device          ses        # SCSI Environmental Services (and SAF-TE)</programlisting>

    <para>Périphériques SCSI.  A nouveau, mettez en
      commentaires tous ceux que vous n'avez pas, ou si vous n'avez
      que du matériel IDE, vous pouvez tous les supprimer.</para>

    <note>
      <para>Le pilote USB &man.umass.4; et quelques autres pilotes
	utilisent le sous-système SCSI même si ce ne sont
	pas de véritables périphériques SCSI.  Par
	conséquent assurez-vous de ne pas retirer le support SCSI
	si un tel pilote fait partie de la configuration du
	noyau.</para>
    </note>

    <programlisting># RAID controllers interfaced to the SCSI subsystem
device          amr        # AMI MegaRAID
device          arcmsr     # Areca SATA II RAID
device          asr        # DPT SmartRAID V, VI and Adaptec SCSI RAID
device          ciss       # Compaq Smart RAID 5*
device          dpt        # DPT Smartcache III, IV - See NOTES for options
device          hptmv      # Highpoint RocketRAID 182x
device          rr232x     # Highpoint RocketRAID 232x
device          iir        # Intel Integrated RAID
device          ips        # IBM (Adaptec) ServeRAID
device          mly        # Mylex AcceleRAID/eXtremeRAID
device          twa        # 3ware 9000 series PATA/SATA RAID

# RAID controllers
device          aac        # Adaptec FSA RAID
device          aacp       # SCSI passthrough for aac (requires CAM)
device          ida        # Compaq Smart RAID
device          mfi        # LSI MegaRAID SAS
device          mlx        # Mylex DAC960 family
device          pst        # Promise Supertrak SX6000
device          twe        # 3ware ATA RAID</programlisting>

    <para>Contrôleurs RAID supportés.  Si vous n'avez aucun de ces
      derniers dans votre système, vous pouvez les mettre
      en commentaires ou les supprimer.</para>

    <programlisting># atkbdc0 controls both the keyboard and the PS/2 mouse
device          atkbdc     # AT keyboard controller</programlisting>

    <para>Le contrôleur du clavier (<literal>atkbdc</literal>) permet
      de gérer les E/S du clavier AT et des
      périphériques de pointage PS/2.  Ce contrôleur
      est nécessaire au pilote de périphérique
      du clavier (<literal>atkbd</literal>) et celui des
      périphériques de pointage PS/2
      (<literal>psm</literal>).</para>

    <programlisting>device          atkbd      # AT keyboard</programlisting>

    <para>Le pilote de périphérique <literal>atkbd</literal>,
      associé au contrôleur <literal>atkbdc</literal>, fournit
      un accès au clavier AT 84 touches ou au clavier AT étendu qui
      est connecté au contrôleur de clavier de la machine.</para>

    <programlisting>device          psm        # PS/2 mouse</programlisting>

    <para>Utilisez ce périphérique si votre souris se
      branche sur le port PS/2.</para>

    <programlisting>device          kbdmux        # keyboard multiplexer</programlisting>

    <para>Support de base pour le multiplexage de claviers.  Si vous
      n'avez pas l'intention d'utiliser sur le système plus
      d'un clavier, vous pouvez supprimer cette ligne sans
      risque.</para>

    <programlisting>device          vga        # VGA video card driver</programlisting>

    <para>Pilote de la carte graphique.</para>

    <programlisting>
device          splash     # Splash screen and screen saver support</programlisting>

    <para>Ecran/bannière de démarrage.  Les
      économiseurs d'écran ont également
      besoin de ce pseudo-périphérique.</para>

    <programlisting># syscons is the default console driver, resembling an SCO console
device          sc</programlisting>

    <para><literal>sc</literal> est le pilote par défaut pour la
      console, qui ressemble &agrave; une console SCO.  Comme la plupart
      des programmes en mode plein-écran accèdent
      &agrave; la console par l'intermédiaire d'une base de
      données
      de description des terminaux comme <filename>termcap</filename>,
      cela n'a guère d'importance que vous choisissiez ce pilote
      ou <literal>vt</literal>, le pilote compatible
      <literal>VT220</literal>.  Quand vous ouvrez une session,
      positionnez votre variable d'environnement <envar>TERM</envar> &agrave;
      <literal>scoansi</literal> si vous avez des problèmes pour
      utiliser des programmes en mode plein-écran avec cette
      console.</para>

    <programlisting># Enable this for the pcvt (VT220 compatible) console driver
#device          vt
#options         XSERVER          # support for X server on a vt console
#options         FAT_CURSOR       # start with block cursor</programlisting>

    <para>C'est le pilote de console compatible VT220, et,
      rétrospectivement, compatible VT100/102.  Il fonctionne
      bien sur certains ordinateurs portables qui sont matériellement
      incompatibles avec le pilote <literal>sc</literal>.  Comme
      précédemment, positionnez la variable d'environnement
      <envar>TERM</envar> lorsque que vous ouvrez une session,
      mais cette fois-ci &agrave; <literal>vt100</literal> ou
      <literal>vt220</literal>.  Ce pilote peut aussi s'avérer
      utile quand vous vous connectez &agrave; un grand nombre de
      machines différentes par le réseau sur lesquelles
      les entrées pour le périphérique
      <literal>sc</literal> ne sont souvent pas définies dans
      leurs fichiers <filename>termcap</filename> ou
      <filename>terminfo</filename> &mdash; alors que le terminal
      <literal>vt100</literal> devrait être disponible sur
      pratiquement toutes les plates-formes.</para>

    <programlisting>device          agp</programlisting>

    <para>Ajoutez cette option si vous avez une carte AGP dans votre
      système.  Cela activera le support AGP, et l'AGP GART
      pour les cartes qui ont cette fonction.</para>

    <indexterm>
      <primary>APM</primary>
    </indexterm>

    <programlisting># Power management support (see NOTES for more options)
device          apm</programlisting>

    <para>&ldquo;Advanced Power Management support&rdquo; - gestion
      avancée de l'énergie.  Utile pour les ordinateurs
      portables, ceci est cependant désactivé par
      défaut dans le noyau <filename>GENERIC</filename> sous
      &os;&nbsp;5.X et versions suivantes</para>

    <programlisting># Add suspend/resume support for the i8254.
device           pmtimer</programlisting>

    <para>Pilote du périphérique de gestion du temps pour
      les événements de la gestion de l'énergie, comme l'APM ou
      l'ACPI.</para>

    <programlisting># PCCARD (PCMCIA) support
# PCMCIA and cardbus bridge support
device          cbb               # cardbus (yenta) bridge
device          pccard            # PC Card (16-bit) bus
device          cardbus           # CardBus (32-bit) bus</programlisting>

    <para>Support PCMCIA.  Vous en avez besoin si vous utilisez un
      ordinateur portable.</para>

    <programlisting># Serial (COM) ports
device          sio               # 8250, 16[45]50 based serial ports</programlisting>

    <para>Cela représente les ports séries, appelés
      ports <filename>COM</filename> dans le monde &ms-dos;/&windows;.</para>

    <note>
      <para>Si vous avez un modem interne sur le port <filename>COM4</filename> et un port
	série <filename>COM2</filename>, vous devrez changer l'IRQ du modem en 2 (pour
	d'obscures raisons techniques, IRQ 2 = IRQ 9) pour y accéder
	avec FreeBSD.  Si vous avez une carte série multi-ports,
	consultez la page de manuel de &man.sio.4; pour plus
	d'informations sur les bonnes valeurs &agrave; ajouter &agrave; votre
	fichier <filename>/boot/device.hints</filename>.
	Certaines cartes vidéo (notamment celle &agrave; base de
	circuits S3) utilisent des adresses d'E/S sous la forme
	<literal>0x*2e8</literal>, et comme de nombreuses cartes
	séries bon marché de décodent pas
	complètement l'espace d'adresse d'E/S 16 bits, il y a
	aura des conflits avec ces cartes, rendant le port
	<filename>COM4</filename>
	pratiquement inutilisable.</para>

      <para>Chaque port série doit avoir une IRQ unique (&agrave;
	moins que vous n'utilisiez une carte multi-ports qui autorise
	le partage d'interruption), donc les IRQs par défaut pour
	les ports <filename>COM3</filename> et <filename>COM4</filename> ne peuvent être
	utilisées.</para>
    </note>

    <programlisting># Parallel port
device          ppc</programlisting>

    <para>C'est l'interface parallèle du bus ISA.</para>

    <programlisting>device          ppbus      # Parallel port bus (required)</programlisting>

    <para>Fournit le support pour le bus du port parallèle.</para>

    <programlisting>device          lpt        # Printer</programlisting>

    <para>Support pour les imprimantes parallèles.</para>

    <note>
      <para>Les trois lignes précédentes sont
	nécessaires pour permettre le support des imprimantes
	parallèles.</para>
    </note>

    <programlisting>device          plip       # TCP/IP over parallel</programlisting>

    <para>C'est le pilote pour l'interface réseau sur port
      parallèle.</para>

    <programlisting>device          ppi        # Parallel port interface device</programlisting>

    <para>Port d'E/S d'usage général (&ldquo;geek
      port&rdquo;) + port d'E/S IEEE1284.</para>

    <programlisting>#device         vpo        # Requires scbus and da</programlisting>

    <indexterm><primary>lecteur zip</primary></indexterm>
    <para>Ceci est pour le lecteur Zip de Iomega.  Les options
      <literal>scbus</literal> et <literal>da</literal> sont
      également requises.  Les meilleures performances sont
      obtenues avec les ports configurés dans le mode EPP 1.9.</para>

    <programlisting>#device         puc</programlisting>

    <para>Décommentez ce périphérique si vous
      disposez d'une carte PCI série ou parallèle
      <quote>idiote</quote> qui est supportée par le pilote
      &man.puc.4;.</para>

    <programlisting># PCI Ethernet NICs.
device          de         # DEC/Intel DC21x4x (<quote>Tulip</quote>)
device          em         # Intel PRO/1000 adapter Gigabit Ethernet Card
device          ixgb       # Intel PRO/10GbE Ethernet Card
device          txp        # 3Com 3cR990 (<quote>Typhoon</quote>)
device          vx         # 3Com 3c590, 3c595 (<quote>Vortex</quote>)</programlisting>

    <para>Divers pilotes de cartes réseaux PCI.  Mettez en
      commentaires ou supprimer les lignes de celles qui ne sont pas
      présentes sur votre système.</para>

    <programlisting># PCI Ethernet NICs that use the common MII bus controller code.
# NOTE: Be sure to keep the 'device miibus' line in order to use these NICs!
device          miibus     # MII bus support</programlisting>

    <para>Le support du bus MII est nécessaire pour certaines
      cartes Ethernet PCI 10/100, &agrave; savoir celles qui utilisent des
      interfaces compatibles MII ou implémentent une gestion de
      l'interface opérant comme le bus MII.  Ajouter
      <literal>device miibus</literal> &agrave; la configuration du noyau
      intègre le support pour l'API miibus générique et
      tous les pilotes d'interfaces PHY, incluant un pilote
      générique pour les interfaces PHYs qui ne sont pas
      spécifiquements gérées par un
      pilote individuel.</para>

    <programlisting>device          bce        # Broadcom BCM5706/BCM5708 Gigabit Ethernet
device          bfe        # Broadcom BCM440x 10/100 Ethernet
device          bge        # Broadcom BCM570xx Gigabit Ethernet
device          dc         # DEC/Intel 21143 and various workalikes
device          fxp        # Intel EtherExpress PRO/100B (82557, 82558)
device          lge        # Level 1 LXT1001 gigabit ethernet
device          msk        # Marvell/SysKonnect Yukon II Gigabit Ethernet
device          nge        # NatSemi DP83820 gigabit ethernet
device          nve        # nVidia nForce MCP on-board Ethernet Networking
device          pcn        # AMD Am79C97x PCI 10/100 (precedence over 'lnc')
device          re         # RealTek 8139C+/8169/8169S/8110S
device          rl         # RealTek 8129/8139
device          sf         # Adaptec AIC-6915 (<quote>Starfire</quote>)
device          sis        # Silicon Integrated Systems SiS 900/SiS 7016
device          sk         # SysKonnect SK-984x &amp; SK-982x gigabit Ethernet
device          ste        # Sundance ST201 (D-Link DFE-550TX)
device          stge       # Sundance/Tamarack TC9021 gigabit Ethernet
device          ti         # Alteon Networks Tigon I/II gigabit Ethernet
device          tl         # Texas Instruments ThunderLAN
device          tx         # SMC EtherPower II (83c170 <quote>EPIC</quote>)
device          vge        # VIA VT612x gigabit ethernet
device          vr         # VIA Rhine, Rhine II
device          wb         # Winbond W89C840F
device          xl         # 3Com 3c90x (<quote>Boomerang</quote>, <quote>Cyclone</quote>)</programlisting>

    <para>Pilotes qui utilisent le code du contrôleur du bus
      MII.</para>

    <programlisting># ISA Ethernet NICs.  pccard NICs included.
device          cs         # Crystal Semiconductor CS89x0 NIC
# 'device ed' requires 'device miibus'
device          ed         # NE[12]000, SMC Ultra, 3c503, DS8390 cards
device          ex         # Intel EtherExpress Pro/10 and Pro/10+
device          ep         # Etherlink III based cards
device          fe         # Fujitsu MB8696x based cards
device          ie         # EtherExpress 8/16, 3C507, StarLAN 10 etc.
device          lnc        # NE2100, NE32-VL Lance Ethernet cards
device          sn         # SMC's 9000 series of Ethernet chips
device          xe         # Xircom pccard Ethernet

# ISA devices that use the old ISA shims
#device         le</programlisting>

    <para>Pilotes pour les cartes Ethernet ISA.  Consultez le fichier
      <filename>/usr/src/sys/i386/conf/NOTES</filename> pour savoir
      quelles cartes sont supportées et par quel pilote.</para>

    <programlisting># Wireless NIC cards
device          wlan            # 802.11 support</programlisting>

    <para>Support 802.11 générique.  Cette ligne est
      nécessaire pour le réseau sans fil.</para>

    <programlisting>device          wlan_wep        # 802.11 WEP support
device          wlan_ccmp       # 802.11 CCMP support
device          wlan_tkip       # 802.11 TKIP support</programlisting>

    <para>Support pour le chiffrage pour les
      périphériques 802.11.  Ces lignes sont
      nécessaires si vous avez l'intention d'utiliser le
      chiffrage et les protocoles de sécurité
      802.11i.</para>

    <programlisting>device          an         # Aironet 4500/4800 802.11 wireless NICs.
device          ath             # Atheros pci/cardbus NIC's
device          ath_hal         # Atheros HAL (Hardware Access Layer)
device          ath_rate_sample # SampleRate tx rate control for ath
device          awi        # BayStack 660 and others
device          ral        # Ralink Technology RT2500 wireless NICs.
device          wi         # WaveLAN/Intersil/Symbol 802.11 wireless NICs.
#device         wl         # Older non 802.11 Wavelan wireless NIC.</programlisting>

    <para>Support pour diverses cartes réseau sans fil.</para>

    <programlisting># Pseudo devices
device   loop          # Network loopback</programlisting>

    <para>C'est l'interface générique en boucle de
      TCP/IP.  Si vous employez telnet ou FTP sur
      <systemitem>localhost</systemitem> (aussi connu en tant qu'adresse
      <systemitem class="ipaddress">127.0.0.1</systemitem>) la réponse vous
      parviendra via ce pseudo-périphérique.  Ceci est
      <emphasis>obligatoire</emphasis>.</para>

    <programlisting>device   random        # Entropy device</programlisting>

    <para>Générateur de nombres aléatoire
      sécurisé pour les applications de
      chiffrement.</para>

    <programlisting>device   ether         # Ethernet support</programlisting>

    <para><literal>ether</literal> ne sert que si vous avez une carte
      Ethernet.  Cela intègre le code générique
      pour le protocole Ethernet.</para>

    <programlisting>device   sl            # Kernel SLIP</programlisting>

    <para><literal>sl</literal> est le support pour le protocole SLIP.
      Il a été presque entièrement supplanté
      par le protocole PPP, plus facile &agrave; mettre en oeuvre, mieux
      adapté aux connexions par modem, et aussi plus
      puissant.</para>

    <programlisting>device   ppp           # Kernel PPP</programlisting>

    <para>C'est le support intégré au noyau du protocole PPP
      pour les connexions par modem.  Il y a aussi une version de PPP
      sous forme de programme utilisateur qui utilise
      <literal>tun</literal> et offre plus de souplesse et de
      possibilités comme la connexion &agrave; la
      demande.</para>

    <programlisting>device   tun           # Packet tunnel.</programlisting>

    <para>Ceci est utilisé par le programme PPP en mode
      utilisateur.
      Voyez la section <link linkend="userppp">PPP</link> de ce manuel pour plus
      d'informations.</para>

    <programlisting><anchor xml:id="kernelconfig-ptys"/>
device   pty           # Pseudo-ttys (telnet etc)</programlisting>

    <para>C'est un &ldquo;pseudo-terminal&rdquo; ou un port simulant
      une session.  Il est utilisé par les sessions
      <command>telnet</command> et <command>rlogin</command>
      entrantes, par <application>xterm</application>, et d'autres
      applications comme <application>Emacs</application>.</para>

    <programlisting>device   md            # Memory <quote>disks</quote></programlisting>

    <para>Pseudo-périphérique de disque
      mémoire.</para>

    <programlisting>device   gif     # IPv6 and IPv4 tunneling</programlisting>

    <para>Ceci implémente l'encapsulation du protocole IPv6 par
      dessus l'IPv4, l'IPv4 par dessus l'IPv6, l'encapsulation IPv4
      par dessus l'IPv4, et IPv6 par dessus IPv6.  Le
      périphérique <literal>gif</literal>
      <quote>s'auto-duplique</quote>, et créera les fichiers
      spéciaux de périphérique en fonction des
      besoins.</para>

    <programlisting>device   faith   # IPv6-to-IPv4 relaying (translation)</programlisting>

    <para>Ce pseudo-périphérique capture les paquets qui lui sont
      envoyés et les détourne vers le &ldquo;daemon&rdquo; de
      translation IPv4/IPv6.</para>

    <programlisting># The `bpf' device enables the Berkeley Packet Filter.
# Be aware of the administrative consequences of enabling this!
# Note that 'bpf' is required for DHCP.
device   bpf           # Berkeley packet filter</programlisting>

    <para>C'est le filtre de paquets de Berkeley.  Ce
      pseudo-périphérique permet de placer les interfaces
      en mode &ldquo;promiscuous&rdquo; (indiscret), pour capturer
      chaque paquet sur réseau de diffusion (e.g., un réseau
      Ethernet).  Ces paquets peuvent être enregistrés sur
      le disque et/ou examinés avec le programme
      &man.tcpdump.1;.</para>

    <note>
      <para>Le périphérique &man.bpf.4;
	est également utilisé par &man.dhclient.8; pour
	obtenir une adresse IP du routeur par défaut (passerelle) et
	ainsi de suite.  Si vous utilisez DHCP, conservez cette ligne
	non commentée.</para>
    </note>

    <programlisting># USB support
device          uhci          # UHCI PCI-&gt;USB interface
device          ohci          # OHCI PCI-&gt;USB interface
device          ehci          # EHCI PCI-&gt;USB interface (USB 2.0)
device          usb           # USB Bus (required)
#device         udbp          # USB Double Bulk Pipe devices
device          ugen          # Generic
device          uhid          # <quote>Human Interface Devices</quote>
device          ukbd          # Keyboard
device          ulpt          # Printer
device          umass         # Disks/Mass storage - Requires scbus and da
device          ums           # Mouse
device          ural          # Ralink Technology RT2500USB wireless NICs
device          urio          # Diamond Rio 500 MP3 player
device          uscanner      # Scanners
# USB Ethernet, requires mii
device          aue           # ADMtek USB Ethernet
device          axe           # ASIX Electronics USB Ethernet
device          cdce          # Generic USB over Ethernet
device          cue           # CATC USB Ethernet
device          kue           # Kawasaki LSI USB Ethernet
device          rue           # RealTek RTL8150 USB Ethernet</programlisting>

    <para>Support pour divers périphériques USB.</para>

    <programlisting># FireWire support
device          firewire      # FireWire bus code
device          sbp           # SCSI over FireWire (Requires scbus and da)
device          fwe           # Ethernet over FireWire (non-standard!)</programlisting>

    <para>Support pour divers périphériques
      Firewire.</para>

    <para>Pour plus d'informations et pour avoir la liste de
      périphériques supplémentaires supportés par
      FreeBSD, voyez le fichier
      <filename>/usr/src/sys/i386/conf/NOTES</filename>.</para>

    <sect2>
      <title>Configurations mémoire importantes
	(<acronym>PAE</acronym>)</title>
      <indexterm>
	<primary>Extensions d'adressage physique&mdash;&ldquo;Physical
	  Address Extensions&rdquo; (<acronym>PAE</acronym>)</primary>
	<secondary>mémoire importante</secondary>
      </indexterm>

      <para>Les machines &agrave; configuration mémoire
	importante ont besoin de pouvoir accéder &agrave; plus
	d'espace mémoire utilisateur et noyau que la limite des
	4 gigaoctets de l'espace d'adresse noyau+utilisateur
	(&ldquo;Kernel Virtual
	Address&rdquo;&mdash;<acronym>KVA</acronym>).  En raison de
	cette limite, Intel a ajouté le support d'adresses
	physiques sur 36&nbsp;bits pour l'espace d'adresses dans les
	familles de microprocesseurs &pentium; Pro et
	suivantes.</para>

      <para>L'extension de l'adressage physique&mdash;,&ldquo;Physical
	Address Extension&rdquo; (<acronym>PAE</acronym>) est une
	caractéristique des microprocesseurs &intel; &pentium;
	Pro et suivants autorisant les configurations mémoires
	jusqu'&agrave; 64 gigaoctets.  &os; fournit un support pour
	cette caratéristique via l'option de configuration du
	noyau <option>PAE</option>, disponible sous toutes les versions
	actuelles de &os;.
	En raison des limitations de l'architecture
	mémoire &intel;, aucune distinction n'est faite entre
	la mémoire au-dessus et en-dessous de 4 gigaoctets.  La
	mémoire allouée au-dessus de 4 gigaoctets est
	simplement ajoutée &agrave; l'ensemble de la
	mémoire disponible.</para>

      <para>Pour activer le support <acronym>PAE</acronym> dans le
	noyau, ajoutez simplement la ligne suivante dans votre fichier
	de configuration du noyau:</para>

      <programlisting>options		PAE</programlisting>

      <note>
	<para>Le support <acronym>PAE</acronym> sous &os; est
	  uniquement disponible pour les processeurs IA-32
	  d'&intel;.  Il doit être noté que le support
	  <acronym>PAE</acronym> sous &os; n'a pas été
	  énormément testé, et devrait être
	  considéré comme bêta comparé aux
	  autres fonctionnalités stables de &os;.</para>
      </note>

      <para>Le support <acronym>PAE</acronym> sous &os; a quelques
	limitations:</para>

      <itemizedlist>
	<listitem>
	  <para>Un processus est incapable d'accéder &agrave;
	    plus de 4 gigaoctets d'espace mémoire.</para>
	</listitem>

	<listitem>
	  <para>Les modules <acronym>KLD</acronym> ne peuvent
	    être chargés dans un noyau avec
	    <acronym>PAE</acronym> activé, en raison des
	    différences entre la structure d'un module et du
	    noyau.</para>
	</listitem>

	<listitem>
	  <para>Les pilotes de périphériques qui
	    n'utilisent pas l'interface &man.bus.dma.9;
	    seront &agrave; l'origine de corruption de données
	    avec un noyau <acronym>PAE</acronym> et ne sont pas
	    recommandés.  Pour cette raison, le fichier de
	    configuration du noyau avec support
	    <filename>PAE</filename> qui est fourni avec
	    &os; exclut tous les pilotes connus
	    pour ne pas fonctionner avec un noyau avec support
	    <acronym>PAE</acronym>.</para>
	</listitem>

	<listitem>
	  <para>Certains paramètres modifiables du
	    système déterminent l'utilisation des
	    ressources mémoire par la quantité de la
	    mémoire physique disponible.  De tels
	    paramètres peuvent être inutilement
	    sur-alloués en raison de la grande quantité de
	    mémoire d'un système <acronym>PAE</acronym>.
	    Un bon exemple est le &ldquo;sysctl&rdquo;
	    <option>kern.maxvnodes</option>, qui contrôle le
	    nombre maximal de &ldquo;vnodes&rdquo; alloués par le
	    noyau.  Il est recommandé d'ajuster ce dernier et les
	    autres paramètres du même genre &agrave; des
	    valeurs raisonnables.</para>
	</listitem>

	<listitem>
	  <para>Il pourra être nécessaire d'augmenter l'espace
	    d'adressage virtuel du noyau (&ldquo;kernel virtual
	    address&rdquo;&mdash;<acronym>KVA</acronym>) ou de
	    réduire le montant de la ressource spécifique
	    du noyau qui est fortement utilisée (voir plus haut)
	    afin d'éviter l'épuisement de l'espace
	    <acronym>KVA</acronym>.  L'option du noyau
	    <option>KVA_PAGES</option> peut être employée
	    pour augmenter l'espace <acronym>KVA</acronym>.</para>
	</listitem>
      </itemizedlist>

      <para>Pour des considérations de performance et de
	stabilité, il est recommandé de consulter la
	page de manuel &man.tuning.7;.  La page de manuel
	&man.pae.4; contient des informations &agrave; jour
	sur le support <acronym>PAE</acronym> sous &os;.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="kernelconfig-trouble">
    <title>Si quelque chose se passe mal</title>

    <para>Il y a cinq types de problèmes qui peuvent survenir lors de
      la compilation d'un noyau sur mesure.  Ce sont:</para>

    <variablelist>
      <varlistentry>
	<term>La commande <command>config</command> échoue:</term>

	<listitem>
	  <para>Si la commande &man.config.8; échoue quand
	    vous lui passez en paramètre la description de votre
	    noyau, vous avez probablement fait une simple erreur
	    quelque part.  Heureusement &man.config.8;
	    affichera le numéro de la ligne qui lui a posé
	    problème, vous pouvez donc localiser rapidement la
	    ligne contenant l'erreur.  Par exemple, si vous avez:</para>

	  <screen>config: line 17: syntax error</screen>

	  <para>Vérifiez que la ligne est
	    correctement écrite, en le comparant avec le noyau
	    <filename>GENERIC</filename> ou une autre
	    référence.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>La commande <command>make</command> échoue:</term>

	<listitem>
	  <para>Si la commande <command>make</command> échoue,
	    cela signale habituellement une erreur dans la description
	    de votre noyau, mais qui n'est pas suffisamment sérieuse pour que
	    la commande &man.config.8; la détecte.
	    A nouveau, vérifiez votre fichier de configuration, et si
	    vous n'arrivez toujours pas &agrave; résoudre le
	    problème, envoyez un courrier électronique &agrave; la
	    &a.questions; en joignant votre fichier de configuration
	    du noyau, le diagnostic devrait être rapide.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Le noyau ne démarre pas:<anchor xml:id="kernelconfig-noboot"/></term>

	<listitem>
	  <para>Si votre nouveau noyau ne démarre pas, ou ne
	    reconnaît pas vos périphériques,
	    ne paniquez pas!  Heureusement, FreeBSD dispose d'un
	    excellent mécanisme pour récupérer si le
	    noyau ne fonctionne pas.  Sélectionnez simplement le noyau,
	    &agrave; partir duquel vous désirez démarrer,
	    &agrave; l'invite du chargeur de FreeBSD.  Vous pouvez y
	    accéder quand le menu de démarrage
	    apparaît.  Sélectionner l'option 6,
	    <quote>Escape to a loader prompt</quote>.  A l'invite,
	    tapez <command>unload kernel</command> et ensuite
	    <command>boot /boot/kernel.old/kernel</command>,
	    ou le nom de fichier d'un autre noyau qui pourra démarrer
	    proprement.  Quand on reconfigure un noyau, il est
	    toujours bon de conserver &agrave; portée de la main un
	    noyau dont on sait qu'il fonctionne.</para>

	  <para>Après avoir démarré avec un
	    noyau en état de marche, vous pouvez revérifier votre
	    fichier de configuration et essayer de recompiler &agrave;
	    nouveau votre noyau.  Une ressource utile est le fichier
	    <filename>/var/log/messages</filename> qui enregistre,
	    entre autres, tous les messages du noyau &agrave; chaque
	    démarrage réussi.  En outre, la commande
	    &man.dmesg.8; affichera les messages du noyau pour le
	    dernier démarrage.</para>

	  <note>
	    <para>Si vous avez des difficultés &agrave; compiler
	      un noyau, veillez &agrave; conserver un noyau
	      <filename>GENERIC</filename>, ou un autre noyau dont
	      vous savez qu'il fonctionne, sous la main, avec un nom
	      différent de sorte qu'il ne soit pas
	      écrasé &agrave; la prochaine compilation.
	      Vous ne pouvez pas faire confiance au noyau
	      <filename>kernel.old</filename> parce qu'en installant
	      un nouveau noyau, <filename>kernel.old</filename> est
	      remplacé par le dernier noyau installé dont
	      il n'est pas certain qu'il soit opérationnel.  Aussi,
	      dès que possible, déplacez le noyau
	      opérationnel vers le
	      bon emplacement <filename>/boot/kernel</filename> où des commandes
	      comme &man.ps.1; pourront ne pas fonctionner correctement.
	      Pour cela, renommez le répertoire contenant le bon
	      noyau:</para>

	    <screen>&prompt.root; <userinput>mv /boot/kernel /boot/kernel.bad</userinput>
&prompt.root; <userinput>mv /boot/kernel.good /boot/kernel</userinput></screen>
	  </note>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Le noyau est opérationnel, mais la commande
	  <command>ps</command> ne fonctionne plus du tout:</term>

	<listitem>
	  <para>Si vous avez installé une version du noyau
	    différente de celle avec laquelle ont
	    été compilés les utilitaires système,
	    par exemple, un noyau
	    -CURRENT sur un système -RELEASE, de nombreuses commandes
	    d'affichage de l'état du système comme
	    &man.ps.1; and &man.vmstat.8; ne fonctionneront plus.
	    Vous devrez <link linkend="makeworld">recompiler et
	    installer un système</link> avec la même
	    version de l'arborescence des sources de celle
	    utilisée pour votre noyau.
	    C'est une des raisons pour lesquelles il n'est pas
	    judicieux d'utiliser des versions différentes du noyau et
	    du reste du système d'exploitation.</para>
	</listitem>
      </varlistentry>
    </variablelist>
  </sect1>
</chapter>
