<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD French Documentation Project

     $FreeBSD$
     Original revision: 1.58
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="users">
  <info><title>Gestion des comptes et des utilisateurs</title>
    <authorgroup>
      <author><personname><firstname>Neil</firstname><surname>Blakey-Milner</surname></personname><contrib>Contribution de </contrib></author>
    </authorgroup>
    
  </info>

  
  &trans.a.fonvieille;

  <sect1 xml:id="users-synopsis">
    <title>Synopsis</title>

    <para>FreeBSD permet &agrave; de nombreux utilisateurs d'utiliser
      l'ordinateur en même temps.  Evidemment, seul un de ces
      utilisateurs peut être assis devant l'écran et le clavier
      &agrave; un instant donné
      <footnote>
	<para>Bon, &agrave; moins que vous ne connectiez de multiples
	terminaux, mais nous laisserons cela pour le
	<xref linkend="serialcomms"/>.</para>
      </footnote>, mais n'importe quel nombre d'utilisateurs peut ouvrir
      une session par l'intermédiaire du réseau pour mener
      &agrave; bien son
      travail.  Pour utiliser le système chaque utilisateur doit
      posséder un compte.</para>

    <para>Après la lecture de ce chapitre, vous connaîtrez:</para>

    <itemizedlist>
      <listitem>
	<para>Les différences entre les divers comptes utilisateur sur
	  un système FreeBSD.</para>
      </listitem>

      <listitem>
	<para>Comment ajouter des comptes utilisateur.</para>
      </listitem>

      <listitem>
	<para>Comment supprimer des comptes utilisateur.</para>
      </listitem>

      <listitem>
	<para>Comment modifier les paramètres d'un compte, comme le nom
	complet de l'utilisateur, ou l'interpréteur de commandes
	préféré.</para>
      </listitem>

      <listitem>
	<para>Comment fixer des limites par compte, pour contrôler les
	  ressources comme la mémoire et le temps CPU auxquels les
	  comptes et les groupes de comptes sont autorisés &agrave;
	  accéder.</para>
      </listitem>

      <listitem>
	<para>Comment utiliser les groupes pour rendre la gestion de
	  comptes plus aisée.</para>
      </listitem>
    </itemizedlist>

    <para>Avant de lire ce chapitre, vous devrez:</para>

    <itemizedlist>
      <listitem>
	<para>Comprendre les fondements d'&unix; et de FreeBSD (<xref linkend="basics"/>).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="users-introduction">
    <title>Introduction</title>

    <para>Tout accès au système est effectué
      par l'intermédiaire de comptes, et tous les processus sont
      exécutés par des utilisateurs, la gestion des comptes et des
      utilisateurs est capitale sur les systèmes FreeBSD.</para>

    <para>Chaque compte sur un système FreeBSD est associé
      avec un certain nombre d'informations utilisé pour
      identifier le compte.</para>

    <variablelist>
      <varlistentry>
	<term>&ldquo;User name&rdquo; - nom d'utilisateur</term>

	<listitem>
	  <para>Le nom d'utilisateur comme il sera tapé &agrave;
	    l'invite <prompt>login:</prompt>.  Les noms d'utilisateur
	    doivent être uniques sur le système; vous ne pouvez
	    pas avoir deux utilisateurs avec le même nom
	    d'utilisateur.  Il y a un certain nombre de règles
	    pour la création de noms d'utilisateur valides,
	    documentées dans &man.passwd.5;; vous utiliserez
	    généralement des noms d'utilisateurs de huit lettres
	    ou moins et en minuscules.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>&ldquo;Password&rdquo; - mot de passe</term>

	<listitem>
	  <para>Chaque compte est associé &agrave; un mot de passe.
	    Le mot de passe peut être vide, dans ce cas aucun mot de
	    passe ne sera requis pour accéder au système.
	    Ceci est une très mauvaise idée; chaque compte
	    devrait avoir un mot de passe.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>&ldquo;User ID (UID)&rdquo; - identifiant utilisateur</term>

	<listitem>
	  <para>L'UID est un nombre compris entre 0 et 65535<footnote xml:id="users-largeuidgid">
	    <para>Il est possible d'utiliser pour les UID/GIDs tout
	      nombre inférieur &agrave; 4294967295, mais de
	      telles valeurs peuvent être &agrave; l'origine de
	      sérieux problèmes avec des logiciels qui
	      font des suppositions sur la valeur des
	      identifiants.</para>
	    </footnote>, utilisé
	    pour identifier de façon unique un utilisateur sur le
	    système.  Au niveau interne, FreeBSD utilise l'UID pour
	    identifier les utilisateurs&mdash;toute commande qui vous
	    permet de spécifier un utilisateur convertira le nom
	    d'utilisateur en son UID avant de le traiter.  Cela signifie
	    que vous pouvez avoir plusieurs comptes avec des noms
	    d'utilisateurs différents mais le même UID.
	    En ce qui concerne FreeBSD ces comptes ne sont qu'un seul et
	    unique utilisateur.  Il est peu probable que vous ayez
	    jamais &agrave; faire cela.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>&ldquo;Group ID (GID)&rdquo; - identifiant de groupe</term>

	<listitem>
	  <para>Le GID est un nombre compris entre 0 et 65535<footnoteref linkend="users-largeuidgid"/>, utilisé
	    pour identifier de façon unique le groupe principal auquel
	    appartient l'utilisateur.  Les groupes sont un mécanisme
	    pour contrôler l'accès aux ressources qui est
	    basé sur le GID de l'utilisateur plutôt que
	    sur son UID.  Un utilisateur peut également
	    appartenir &agrave; plus d'un groupe.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>&ldquo;Login class&rdquo; - classe de session</term>

	<listitem>
	  <para>Les classes de session sont une extension du
	    mécanisme de groupe qui apporte une flexibilité
	    supplémentaire quand on adapte le système aux
	    différents utilisateurs.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>&ldquo;Password change time&rdquo; - durée de vie d'un
	  mot de passe</term>

	<listitem>
	  <para>Par défaut FreeBSD n'oblige pas les utilisateurs
	    &agrave; changer leur mot de passe régulièrement.
	    Vous pouvez forcer cela en fonction de l'utilisateur, en
	    obligeant certains ou tous les utilisateurs &agrave; changer
	    leur mot de passe après qu'une certaine période
	    de temps se soit écoulée.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>&ldquo;Account expiry time&rdquo; - date d'expiration
	  d'un compte</term>

	<listitem>
	  <para>Par défaut FreeBSD ne désactive pas de
	    comptes après une certaine période.  Si vous
	    créez des comptes qui auront une durée de vie
	    limitée, par exemple, dans une école où
	    il existe des comptes pour les étudiants, alors vous
	    pouvez spécifier la date d'expiration des comptes.
	    Après la durée d'expiration écoulée
	    le compte ne pourra plus être utilisé
	    pour ouvrir de session sur le système, bien que les
	    répertoires et les fichiers attachés au compte
	    seront conservés.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>&ldquo;User's full name&rdquo; - nom complet d'utilisateur</term>

	<listitem>
	  <para>Le nom d'utilisateur identifie uniquement le compte sur
	    FreeBSD, mais ne reflète pas nécessairement le
	    nom réel de l'utilisateur.  Cette information peut être
	    associée avec le compte.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>&ldquo;Home directory&rdquo; - répertoire
	  utilisateur</term>

	<listitem>
	  <para>Le répertoire utilisateur est le chemin complet
	    vers un répertoire sur le système dans lequel se
	    retrouve l'utilisateur quand il ouvre une session sur le
	    système.  Une convention commune est de mettre tous les
	    répertoires d'utilisateurs sous
	    <filename>/home/username</filename>
	    ou <filename>/usr/home/username</filename>.
	    L'utilisateur pourra stocker ses fichiers personnel dans son
	    répertoire utilisateur et dans tout sous-répertoire
	    qu'il pourra y créer.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>&ldquo;User shell&rdquo; - interpréteur de commandes
	  de l'utilisateur</term>

	<listitem>
	  <para>L'interpréteur de commandes fournit aux utilisateurs
	    l'environnement par défaut pour communiquer avec le
	    système.  Il existe plusieurs différents types
	    d'interpréteurs de commandes, et les utilisateurs
	    expérimentés auront leur préférence,
	    qui peut se refléter dans le paramétrage
	    de leur compte.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Il y a trois principales sortes de comptes: le <link linkend="users-superuser">super-utilisateur</link>, les <link linkend="users-system">utilisateurs système</link>,
	et les <link linkend="users-user">comptes utilisateur</link>.
	Le compte super-utilisateur, normalement appelé
	<systemitem class="username">root</systemitem>, est utilisé pour gérer le
	système
	sans aucune limitation de privilèges.  Les utilisateurs
	système exécutent des services.  Et enfin,
	les comptes utilisateur sont utilisés par de véritables
	utilisateurs, qui ouvrent des sessions, lisent leur courrier
	électronique, et ainsi de suite.</para>
  </sect1>

  <sect1 xml:id="users-superuser">
    <title>Le compte super-utilisateur</title>

    <indexterm>
      <primary>comptes</primary>
      <secondary>super-utilisateur (root)</secondary>
    </indexterm>
    <para>Le compte super-utilisateur, habituellement appelé
      <systemitem class="username">root</systemitem>, est préconfiguré pour
      simplifier l'administration système, et ne devrait pas
      être utilisé pour des tâches quotidiennes comme
      l'envoi et la réception de courrier électronique,
      l'exploration
      du système, ou la programmation.</para>

    <para>Cela parce que le super-utilisateur, &agrave; la
      différence des comptes utilisateurs ordinaires, peut agir sans
      aucune limite, et une mauvaise utilisation du compte
      super-utilisateur peut être &agrave; l'origine de résultats
      catastrophiques.  On ne peut pas endommager par erreur le système
      avec un compte utilisateur, il est donc généralement
      préférable d'utiliser des comptes utilisateur ordinaires
      chaque fois que c'est possible, &agrave; moins d'avoir
      particulièrement besoin
      de droits supplémentaires.</para>

    <para>Vous devriez toujours vérifier et revérifier
      les commandes que vous tapez en tant que super-utilisateur, parce
      qu'un espace en trop ou un caractère manquant peuvent signifier la
      perte définitive de données.</para>

    <para>Donc, la première chose que vous devriez faire,
      après la lecture de ce chapitre, est de vous créer
      un compte utilisateur sans privilèges si vous n'en avez pas
      déj&agrave;.  Cela s'applique aussi bien &agrave; une machine
      multi-utilisateurs qu'&agrave; une machine mono-utilisateur.  Plus loin
      dans ce chapitre, nous expliquerons comment créer de nouveaux
      comptes, et comment passer d'un compte utilisateur ordinaire au
      compte du super-utilisateur.</para>
  </sect1>

  <sect1 xml:id="users-system">
    <title>Comptes système</title>

    <indexterm>
      <primary>comptes</primary>
      <secondary>système</secondary>
    </indexterm>
    <para>Les utilisateurs système sont ceux utilisés pour
      exécuter des services comme le DNS, le courrier
      électronique,
      les serveurs web, et ainsi de suite.  La raison de cela est la
      sécurité; si tous les services s'exécutaient
      avec les droits du super-utilisateur, ils pourraient agir sans
      aucune restriction.</para>

    <indexterm>
      <primary>comptes</primary>
      <secondary><systemitem class="username">daemon</systemitem></secondary>
    </indexterm>
    <indexterm>
      <primary>comptes</primary>
      <secondary><systemitem class="username">operator</systemitem></secondary>
    </indexterm>
    <para>Des exemples d'utilisateurs système sont
      <systemitem class="username">daemon</systemitem>, <systemitem class="username">operator</systemitem>,
      <systemitem class="username">bind</systemitem> (pour le serveur de noms de domaine),
      <systemitem class="username">news</systemitem>, et <systemitem class="username">www</systemitem>.</para>

    <indexterm>
      <primary>comptes</primary>
      <secondary><systemitem class="username">nobody</systemitem></secondary>
    </indexterm>
    <para><systemitem class="username">nobody</systemitem> est l'utilisateur sans
      privilèges générique du système.
      Cependant, il est important de garder &agrave; l'esprit que plus grand
      est le nombre de services utilisant <systemitem class="username">nobody</systemitem>,
      plus grand sera le nombre de fichiers et de processus associés
      &agrave; cet utilisateur, et par conséquent plus grand sera le
      nombre de privilèges de cet utilisateur.</para>
  </sect1>

  <sect1 xml:id="users-user">
    <title>Comptes utilisateur</title>

    <indexterm>
      <primary>comptes</primary>
      <secondary>utilisateur</secondary>
    </indexterm>
    <para>Les comptes utilisateur sont le principal moyen pour les
      véritables utilisateurs d'accéder au
      système, ces comptes isolent l'utilisateur du reste de
      l'environnement, empêchant les utilisateurs d'endommager
      le système et ou les comptes d'autres utilisateurs, tout en
      leur permettant de personnaliser leur environnement sans incidence
      pour les autres utilisateurs.</para>

    <para>Chaque personne accédant &agrave; votre système
      ne devrait posséder que son propre et unique compte.  Cela
      vous permet de savoir qui fait quoi, empêche un utilisateur de
      désorganiser l'environnement d'un autre ou de lire du courrier
      électronique qui ne lui est pas destiné, et ainsi de
      suite.</para>

    <para>Chaque utilisateur peut configurer son propre environnement en
      fonction de ses besoins, pour utiliser d'autres interpréteurs
      de commandes, éditeurs, raccourcis de clavier,
      et langues.</para>
  </sect1>

  <sect1 xml:id="users-modifying">
    <title>Modifier des comptes</title>

    <indexterm>
      <primary>comptes</primary>
      <secondary>modification</secondary>
    </indexterm>

    <para>Il existe une variété de différentes
      commandes disponibles dans l'environnement &unix; pour manipuler les
      comptes utilisateur.  Les commandes les plus communes sont
      récapitulées ci-dessous, suivis par des exemples
      détaillés de leur utilisation.</para>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
      <colspec colwidth="1*"/>
      <colspec colwidth="2*"/>
	<thead>
	  <row>
	    <entry>Commande</entry>
	    <entry>Résumé</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>&man.adduser.8;</entry>
	    <entry>L'application en ligne de commande recommandée
	      pour ajouter de nouveaux utilisateurs.</entry>
	  </row>
	  <row>
	    <entry>&man.rmuser.8;</entry>
	    <entry>L'application en ligne de commande recommandée
	      pour supprimer des utilisateurs.</entry>
	  </row>
	  <row>
	    <entry>&man.chpass.1;</entry>
	    <entry>Un outil flexible pour modifier les informations de
	      la base de données utilisateur.</entry>
	  </row>
	  <row>
	    <entry>&man.passwd.1;</entry>
	    <entry>L'outil simple en ligne de commande pour changer les
	      mots de passe utilisateur.</entry>
	  </row>
	  <row>
	    <entry>&man.pw.8;</entry>
	    <entry>Un puissant et flexible outil pour modifier tous les
	      aspects des comptes utilisateurs.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <sect2 xml:id="users-adduser">
      <title><command>adduser</command></title>

      <indexterm>
        <primary>compte</primary>
        <secondary>création</secondary>
      </indexterm>
      <indexterm>
        <primary><command>adduser</command></primary>
      </indexterm>
      <indexterm>
        <primary><filename>/usr/share/skel</filename></primary>
      </indexterm>
      <indexterm><primary>répertoire de squelettes</primary></indexterm>
      <para>&man.adduser.8; est un programme simple pour
	ajouter de nouveaux utilisateurs.  Il crée les entrées
	dans les fichiers système <filename>passwd</filename> et
	<filename>group</filename>.  Il crée également le
	répertoire utilisateur pour le nouvel utilisateur, y copie les
	fichiers de configuration par défaut (&ldquo;dotfiles&rdquo;)
	&agrave; partir de <filename>/usr/share/skel</filename>, et peut
	éventuellement envoyer &agrave; l'utilisateur un courrier
	électronique de bienvenue.</para>

      <example>
	<title>Ajouter un utilisateur sous &os;</title>

	<screen>&prompt.root; <userinput>adduser</userinput>
Username: <userinput>jru</userinput>
Full name: <userinput>J. Random User</userinput>
Uid (Leave empty for default):
Login group [jru]:
Login group is jru. Invite jru into other groups? []: <userinput>wheel</userinput>
Login class [default]:
Shell (sh csh tcsh zsh nologin) [sh]: <userinput>zsh</userinput>
Home directory [/home/jru]:
Use password-based authentication? [yes]:
Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]:
Enter password:
Enter password again:
Lock out the account after creation? [no]:
Username   : jru
Password   : ****
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? (yes/no): <userinput>yes</userinput>
adduser: INFO: Successfully added (jru) to the user database.
Add another user? (yes/no): <userinput>no</userinput>
Goodbye!
&prompt.root;</screen>
      </example>

      <note>
	<para>Le mot de passe que vous tapez n'apparaît pas &agrave;
	  l'écran, et il n'y a pas non plus d'astérisques
	  affichés.  Assurez-vous de ne pas vous tromper dans
	  le mot de passe.</para>
      </note>
    </sect2>

    <sect2 xml:id="users-rmuser">
      <title><command>rmuser</command></title>

      <indexterm><primary><command>rmuser</command></primary></indexterm>
      <indexterm>
        <primary>comptes</primary>
        <secondary>suppression</secondary>
      </indexterm>

      <para>Vous pouvez utiliser &man.rmuser.8; pour
	supprimer complètement un utilisateur du système.
	&man.rmuser.8; effectue les opérations
	suivantes:</para>

      <procedure>
	<step>
	  <para>Supprime les entrées appartenant &agrave; l'utilisateur
	  de la &man.crontab.1; (s'il y en a).</para>
	</step>
	<step>
	  <para>Supprime les tâches &man.at.1; appartenant &agrave;
	    l'utilisateur.</para>
	</step>
	<step>
	  <para>Tue tous les processus appartenant &agrave;
	    l'utilisateur.</para>
	</step>
	<step>
	  <para>Supprime l'utilisateur du fichier de mots de passe
	    local.</para>
	</step>
	<step>
	  <para>Supprime le répertoire l'utilisateur (s'il lui
	    appartient).</para>
	</step>
	<step>
	  <para>Supprime les courriers électroniques en attente pour
	  l'utilisateur dans <filename>/var/mail</filename>.</para>
	</step>
	<step>
	  <para>Supprime tous les fichiers temporaires appartenant &agrave;
	    l'utilisateur des zones de stockages temporaires comme
	    <filename>/tmp</filename>.</para>
	</step>
	<step>
	  <para>Et enfin, supprime l'utilisateur de tous les groupes
	    auxquels il appartient dans <filename>/etc/group</filename>.</para>

	    <note>
	      <para>Si un groupe est vide de ce fait et que le nom du
		groupe est le même que celui de l'utilisateur,
		le groupe est supprimé; c'est la réciproque de la
		création par &man.adduser.8; d'un groupe propre
		pour chaque utilisateur.</para>
	    </note>
	</step>
      </procedure>

      <para>&man.rmuser.8; ne peut pas être
	employé pour supprimer des comptes super-utilisateur,
	car cela entraînerait presque toujours des destructions
	massives.</para>

      <para>Par défaut, la commande travaille en mode interactif, pour
	garantir que vous soyez sûr de ce que vous
	faites.</para>

      <example>
	<title>Suppression interactive de compte avec <command>rmuser</command></title>

	<screen>&prompt.root; <userinput>rmuser jru</userinput>
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? <userinput>y</userinput>
Remove user's home directory (/home/jru)? <userinput>y</userinput>
Updating password file, updating databases, done.
Updating group file: trusted (removing group jru -- personal group is empty) done.
Removing user's incoming mail file /var/mail/jru: done.
Removing files belonging to jru from /tmp: done.
Removing files belonging to jru from /var/tmp: done.
Removing files belonging to jru from /var/tmp/vi.recover: done.
&prompt.root;</screen>
      </example>
    </sect2>

    <sect2 xml:id="users-chpass">
      <title><command>chpass</command></title>

      <indexterm><primary><command>chpass</command></primary></indexterm>
      <para>&man.chpass.1; modifie les informations de la
	base de données des utilisateurs comme les mots de passe,
	les interpréteurs de commandes, et les informations
	personnelles.</para>

      <para>Seuls les administrateurs système, comme le
	super-utilisateur, peuvent modifier les informations concernant
	les autres utilisateurs et les mots de passe &agrave; l'aide de
	&man.chpass.1;.</para>

      <para>Utilisé sans options, en dehors du nom facultatif de
	l'utilisateur, &man.chpass.1; ouvre un éditeur
	affichant les informations de l'utilisateur.  Quand
	l'utilisateur quitte l'éditeur, la base de données
	utilisateur est mise &agrave; jour avec les nouvelles
	informations.</para>

      <note>
	<para>On vous demandera votre mot de passe
	  en quittant l'éditeur si vous n'êtes pas le
	  super-utilisateur.</para>
      </note>

      <example>
	<title><command>chpass</command> interactif par le super-utilisateur</title>

	<screen>#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <para>Un utilisateur ordinaire ne peut modifier qu'une partie de
	ces informations, et seulement celles qui le concernent.</para>

      <example>
	<title><command>chpass</command> interactif par un utilisateur ordinaire</title>

	<screen>#Changing user database information for jru.
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <note>
	<para>&man.chfn.1; et &man.chsh.1; sont
	  juste des liens vers &man.chpass.1;, comme le sont
	  &man.ypchpass.1;, &man.ypchfn.1;, et
	  &man.ypchsh.1;.  NIS est supporté
	  automatiquement, aussi spécifier <literal>yp</literal>
	  avant la commande n'est pas nécessaire.  Si cela vous
	  semble confus, ne vous inquiétez pas, NIS sera
	  abordé dans le chapitre <xref linkend="network-servers"/>.</para>
      </note>
    </sect2>
    <sect2 xml:id="users-passwd">
      <title><command>passwd</command></title>

      <indexterm><primary><command>passwd</command></primary></indexterm>
      <indexterm>
        <primary>comptes</primary>
        <secondary>modifier le mot de passe</secondary>
      </indexterm>
      <para>&man.passwd.1; est la méthode habituelle
	pour modifier son mot de passe, ou celui d'un autre utilisateur
	si vous êtes le super-utilisateur.</para>

      <note>
	<para>Pour prévenir des modifications accidentelles ou
	  non autorisées, le mot de passe original doit
	  être entré avant de pouvoir fixer un nouveau mot
	  de passe.</para>
      </note>

      <example>
	<title>Modifier votre mot de passe</title>

	<screen>&prompt.user; <userinput>passwd</userinput>
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <example>
	<title>Modifier le mot de passe d'un autre utilisateur en tant
	  que super-utilisateur</title>

        <screen>&prompt.root; <userinput>passwd jru</userinput>
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <note>
	<para>Comme pour &man.chpass.1;,
	  &man.yppasswd.1; est juste un lien vers
	  &man.passwd.1;, donc NIS fonctionnera avec l'une
	  des deux commandes.</para>
      </note>
    </sect2>


    <sect2 xml:id="users-pw">
      <title><command>pw</command></title>
      <indexterm><primary><command>pw</command></primary></indexterm>

      <para>&man.pw.8; est un utilitaire en ligne de commande pour
	créer, supprimer, modifier, et lister utilisateurs et groupes.
	Il fonctionne comme une interface aux fichiers d'utilisateurs et
	de groupe.  &man.pw.8; possède un ensemble puissant
	d'options qui le rende adapté &agrave; une utilisation
	dans des procédures, mais les nouveaux utilisateurs
	pourront le trouver plus compliqué que les autres
	commandes présentées ici.</para>
    </sect2>


  </sect1>

  <sect1 xml:id="users-limiting">
    <title>Mettre en place des restrictions pour les utilisateurs</title>

    <indexterm><primary>restrictions pour les utilisateurs</primary></indexterm>
    <indexterm>
      <primary>comptes</primary>
      <secondary>restriction</secondary>
    </indexterm>
    <para>Si vous avez plusieurs utilisateurs sur votre système,
      la possibilité de limiter leur utilisation du système
      peut venir &agrave; l'esprit.
      FreeBSD fournit plusieurs méthodes &agrave;
      l'administrateur système pour limiter la quantité de
      ressources système qu'un utilisateur peut utiliser.
      Ces limites sont généralement divisées
      en deux parties: les quotas disque, et les autres limites de
      ressource.</para>

    <indexterm><primary>quotas</primary></indexterm>
    <indexterm>
      <primary>restrictions pour les utilisateurs</primary>
      <secondary>quotas</secondary>
    </indexterm>
    <indexterm><primary>quotas disque</primary></indexterm>
    <para>Les quotas limitent l'utilisation des disques par les
      utilisateurs, et
      ils fournissent un moyen de
      vérifier rapidement cette utilisation
      sans avoir &agrave; faire des calculs &agrave; chaque fois.
      Les quotas sont abordés dans la <xref linkend="quotas"/>.</para>

    <para>Les autres limites de ressource comprennent les moyens de
      limiter l'utilisation du CPU, de la mémoire, et les autres
      ressources qu'un utilisateur peut consommer.  Elles sont
      définies en employant des classes de session et sont
      abordées ici.</para>

    <indexterm>
      <primary><filename>/etc/login.conf</filename></primary>
    </indexterm>
    <para>Les classes de session sont définies dans
      <filename>/etc/login.conf</filename>.  La sémantique
      précise sort du cadre de cette section, mais est
      décrite en détail dans la page de manuel
      &man.login.conf.5;.  Il est suffisant de dire que chaque
      utilisateur est assigné &agrave; une classe
      (<literal>default</literal> par défaut), et que chaque classe
      dispose d'un ensemble de capacités associées.
      La forme utilisée pour ces capacités est une paire
      <literal>nom=valeur</literal>
      où <replaceable>nom</replaceable> est un identifiant connu et
      <replaceable>valeur</replaceable> est une chaîne arbitraire
      dépendante du nom.  Paramétrer des classes et des
      capacités est plutôt direct et également
      décrit dans &man.login.conf.5;.</para>

    <note>
      <para>Le système ne lit normalement pas directement le fichier
	<filename>/etc/login.conf</filename>, mais plutôt la
	base de données
	<filename>/etc/login.conf.db</filename> qui fournit plus
	rapidement les réponses au système.  Pour
	générer <filename>/etc/login.conf.db</filename>
	&agrave; partir du fichier
	<filename>/etc/login.conf</filename>, exécutez la
	commande suivante:</para>

      <screen>&prompt.root; <userinput>cap_mkdb /etc/login.conf</userinput></screen>
    </note>

    <para>Les limites de ressource sont différentes des
      capacités standards des classes en deux points.
      Premièrement, pour chaque limite, il existe une limite douce
      (actuelle) et limite dure.  Une limite douce peut être
      ajustée par l'utilisateur ou une application, mais jamais
      dépasser la limite dure.  Cette dernière peut être
      abaissée par l'utilisateur, mais jamais augmentée.
      Deuxièmement, la plupart des limites de ressource s'applique
      par processus &agrave; un utilisateur spécifique, et non pas
      &agrave; l'utilisateur dans sa totalité.  Notez, cependant, que ces
      différences sont exigées par la manipulation
      spécifique des
      limites, et non pas par l'implémentation du système des
      capacités des classes de session utilisateur (i.e., elles ne sont
      <emphasis>vraiment</emphasis> pas un cas particulier des
      capacités des classes de session).</para>

    <para>Sans plus attendre, ci-dessous sont présentées
      les limites de ressource les plus souvent utilisées
      (le reste, avec les autres capacités des classes
      de session, peut être trouvé dans
      &man.login.conf.5;).</para>

    <variablelist>
      <varlistentry>
        <term><literal>coredumpsize</literal></term>

	<listitem>
    <indexterm><primary>coredumpsize</primary></indexterm>
    <indexterm>
      <primary>restrictions pour les utilisateurs</primary>
      <secondary>coredumpsize</secondary>
    </indexterm>
	  <para>La limite sur la taille du fichier core
	    généré par un programme est, pour
	    d'évidentes raisons, subordonnée aux autres limites
	    sur l'utilisation du disque (e.g., <literal>filesize</literal>,
	    ou les quotas de disque).  Néanmoins, elle est souvent
	    employée comme méthode moins
	    sévère pour contrôler la
	    consommation d'espace disque: puisque les utilisateurs ne
	    génèrent pas de fichier core eux-mêmes,
	    et souvent ne les
	    suppriment pas, paramétrer cela peut leur éviter
	    de manquer d'espace disque si un programme important (e.g.,
	    <application>emacs</application>) plante.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>cputime</literal></term>

	<listitem>
    <indexterm><primary>cputime</primary></indexterm>
    <indexterm>
      <primary>restrictions pour les utilisateurs</primary>
      <secondary>cputime</secondary>
    </indexterm>
	  <para>C'est la quantité maximale de temps CPU qu'un
	    processus d'un utilisateur peut consommer.  Les processus
	    la dépassant seront tués par le noyau.</para>

	    <note>
	      <para>C'est une limite sur le <emphasis>temps</emphasis>
		CPU consommé, non sur le pourcentage comme
		affiché par certains champs de &man.top.1; et
		&man.ps.1;.  Une limite sur ce dernier est, au moment de
		l'écriture de ces lignes, impossible, et serait
		plutôt inutile: un compilateur&mdash;probablement
		une tâche légitime&mdash;peut
		aisément utiliser presque 100% du CPU pendant un certain
		temps.</para>
	    </note>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>filesize</literal></term>

	<listitem>
    <indexterm><primary>filesize</primary></indexterm>
    <indexterm>
      <primary>restrictions pour les utilisateurs</primary>
      <secondary>filesize</secondary>
    </indexterm>
	  <para>C'est la taille maximale du plus gros fichier qu'un utilisateur
	    peut posséder.  Contrairement aux <link linkend="quotas">quotas</link>, cette limite ne s'applique
	    qu'aux fichiers individuellement, et non pas sur l'ensemble
	    lui-même de tous les fichiers que possède
	    un utilisateur.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>maxproc</literal></term>

	<listitem>
    <indexterm><primary>maxproc</primary></indexterm>
        <indexterm>
      <primary>restrictions pour les utilisateurs</primary>
      <secondary>maxproc</secondary>
    </indexterm>
	  <para>C'est le nombre maximal de processus que peut exécuter
	    un utilisateur en même temps.  Ceci inclut
	    les processus de premier plan et de tâche de fond.
	    Pour d'évidentes raisons, il ne doit pas être plus
	    grand que les limites du système spécifiées
	    par la variable &man.sysctl.8;
	    <varname>kern.maxproc</varname>.  Notez en outre qu'une
	    valeur trop basse peut gêner la productivité
	    de l'utilisateur: il est souvent utile d'ouvrir plusieurs
	    sessions &agrave; la fois ou d'exécuter des opérations
	    sous forme de &ldquo;pipeline&rdquo;.
	    Certaines tâches, comme
	    compiler un gros programme, engendrent également
	    de multiples processus (e.g., &man.make.1;, &man.cc.1;, et
	    autres préprocesseurs).</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>memorylocked</literal></term>

	<listitem>
    <indexterm><primary>memorylocked</primary></indexterm>
    <indexterm>
      <primary>restrictions pour les utilisateurs</primary>
      <secondary>memorylocked</secondary>
    </indexterm>
	  <para>C'est la quantité maximale de mémoire
	    qu'un processus peut avoir demandé de verrouiller en
	    mémoire principale (e.g., voir &man.mlock.2;).
	    Certains programmes système critiques, comme
	    &man.amd.8;, sont verrouillés en mémoire
	    principale de sorte qu'en cas de dépassement de la
	    mémoire de pagination, ils ne contribuent pas aux ennuis
	    du système.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>memoryuse</literal></term>

	<listitem>
    <indexterm><primary>memoryuse</primary></indexterm>
    <indexterm>
      <primary>restrictions pour les utilisateurs</primary>
      <secondary>memoryuse</secondary>
    </indexterm>
	  <para>C'est la quantité maximale de mémoire
	    qu'un processus peut consommer &agrave; un instant donné.
	    Cela inclus la mémoire principale et celle de pagination.
	    Ce n'est pas le remède miracle pour restreindre la
	    consommation de mémoire, mais c'est un bon
	    début.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>openfiles</literal></term>

	<listitem>
    <indexterm><primary>openfiles</primary></indexterm>
    <indexterm>
      <primary>restrictions pour les utilisateurs</primary>
      <secondary>openfiles</secondary>
    </indexterm>
	  <para>C'est le nombre maximal de fichiers qu'un processus peut
	    avoir ouvert.  Sous FreeBSD, des fichiers sont également
	    employés pour représenter les sockets et
	    les canaux IPC, par conséquent faites attention
	    &agrave; ne fixer une valeur trop basse.  La limite
	    générale du système pour cela est
	    définie par la variable &man.sysctl.8;
	    <varname>kern.maxfiles</varname>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>sbsize</literal></term>

	<listitem>
    <indexterm><primary>sbsize</primary></indexterm>
    <indexterm>
      <primary>restrictions pour les utilisateurs</primary>
      <secondary>sbsize</secondary>
    </indexterm>
	  <para>C'est une limite sur la quantité de
	    mémoire réseau, et donc de &ldquo;mbufs&rdquo;,
	    qu'un utilisateur peut consommer.  Ceci est &agrave;
	    l'origine une réponse &agrave; une vielle attaque par
	    refus de service en créant de nombreuses sockets, mais peut
	    être généralement employée
	    pour limiter les communications réseau.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>stacksize</literal></term>

	<listitem>
    <indexterm><primary>stacksize</primary></indexterm>
    <indexterm>
      <primary>restrictions pour les utilisateurs</primary>
      <secondary>stacksize</secondary>
    </indexterm>
	  <para>C'est la taille maximale de la pile d'un processus.
	    Seule, cela n'est pas suffisant pour limiter la quantité
	    de mémoire que peut utiliser un programme, par
	    conséquent, cette limite devra être
	    utilisée en même temps que d'autres
	    limitations.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Il y a quelques éléments
      &agrave; se rappeler quand on fixe des
      limites de ressource.  Quelques astuces générales,
      suggestions, et commentaires divers:</para>

    <itemizedlist>
      <listitem>
        <para>Les processus lancés au démarrage
	  du système par <filename>/etc/rc</filename>
	  sont assignés &agrave; la classe
	  <literal>daemon</literal>.</para>
      </listitem>

      <listitem>
        <para>Bien que le fichier <filename>/etc/login.conf</filename>
	  qui est fourni avec le système est une bonne source
	  de valeurs raisonnables pour la plupart des limites, seul
	  vous, l'administrateur, peut savoir ce qui est approprié
	  &agrave; votre système.  Fixer une limite trop haute
	  peut laisser la porte ouverte aux abus, alors qu'une limite
	  trop basse peut être un frein &agrave; la
	  productivité.</para>
      </listitem>

      <listitem>
        <para>Les utilisateurs du système X Window (X11) devraient
	  se voir allouer plus de ressources que les autres
	  utilisateurs.  X11 par lui-même utilise beaucoup de
	  ressources, mais il encourage également les
	  utilisateurs &agrave; exécuter plus de
	  programmes simultanément.</para>
      </listitem>

      <listitem>
        <para>Souvenez-vous que de nombreuses limites ne s'appliquent
	  qu'aux processus individuels, et non pas &agrave; l'utilisateur
	  globalement.  Par exemple, paramétrer
	  <varname>openfiles</varname> &agrave; 50 signifie
	  que chaque processus que l'utilisateur exécute pourra ouvrir
	  jusqu'&agrave; 50 fichiers.  Ainsi, la quantité totale
	  de fichiers qu'un utilisateur peut ouvrir est la valeur
	  <literal>openfiles</literal> multipliée par la valeur
          <literal>maxproc</literal>.  Ceci s'applique également
	  &agrave; la consommation de mémoire.</para>
      </listitem>
    </itemizedlist>

    <para>Pour de plus amples informations sur les limites et les
      classes de session et les capacités en
      général, veuillez consulter les pages de manuel
      appropriées: &man.cap.mkdb.1;, &man.getrlimit.2;,
      &man.login.conf.5;.</para>
  </sect1>

  <sect1 xml:id="users-groups">
    <title>Groupes</title>

    <indexterm><primary>groupes</primary></indexterm>
    <indexterm>
      <primary><filename>/etc/groups</filename></primary>
    </indexterm>
    <indexterm>
      <primary>comptes</primary>
      <secondary>groupes</secondary>
    </indexterm>
    <para>Un groupe est simplement une liste d'utilisateurs.  Les
      groupes sont identifiés par leur nom et leur GID
      (identificateur de groupe).  Dans FreeBSD (et la plupart des
      systèmes &unix;), les deux éléments
      que le noyau utilise pour décider si un processus
      est autorisé &agrave; faire quelque chose sont son ID
      utilisateur et la liste des groupes auxquels il appartient.
      Différent d'un identificateur utilisateur, un
      processus est associé &agrave; une liste de groupes.  Vous pourrez
      entendre faire références au &ldquo;group ID&rdquo;
      d'un utilisateur ou d'un processus; la plupart du temps on veut
      parler du premier groupe dans la liste.</para>

    <para>La table d'équivalence nom de groupe et identificateur de
      groupe se trouve dans <filename>/etc/group</filename>.  C'est un
      fichier texte avec quatre champs délimités par deux points.
      Le premier champ est le nom du groupe, le second est le mot de
      passe crypté, le troisième est l'ID du groupe, et le
      quatrième est
      une liste de membres séparés par des virgules.
      Ce fichier peut sans risque être édité
      &agrave; la main (en supposant, bien sûr, que vous ne faites pas
      d'erreur de syntaxe!).  Pour une description complète de le
      syntaxe, voir la page de manuel &man.group.5;.</para>

    <para>Si vous ne voulez pas éditer
      <filename>/etc/group</filename> &agrave; la main, vous pouvez
      utiliser la commande &man.pw.8; pour ajouter et éditer
      des groupes.  Par exemple, pour ajouter un groupe appelé
      <systemitem class="groupname">teamtwo</systemitem> et ensuite vérifier qu'il existe
      bien vous pouvez utiliser:</para>

    <example>
      <title>Ajouter un groupe en utilisant &man.pw.8;</title>

      <screen>&prompt.root; <userinput>pw groupadd teamtwo</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:</screen>
    </example>

    <para>Le nombre <literal>1100</literal> ci-dessus est
      l'identificateur de groupe pour le groupe
      <systemitem class="groupname">teamtwo</systemitem>.  A cet instant
      <systemitem class="groupname">teamtwo</systemitem> n'a aucun membre, et est par
      conséquent plutôt inutile.  Changeons cela en ajoutant
      <systemitem class="username">jru</systemitem> au groupe
      <systemitem class="groupname">teamtwo</systemitem>.</para>

    <example>
      <title>Ajouter quelqu'un dans un groupe en utilisant
	&man.pw.8;</title>

      <screen>&prompt.root; <userinput>pw groupmod teamtwo -M jru</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:jru</screen>
    </example>

    <para>Le paramètre ajouté &agrave; l'option <option>-M</option>
      est une liste, délimitée par des virgules,
      d'utilisateurs qui sont membres du groupe.  Des sections
      précédentes nous savons que le fichier des mots de passe
      contient également un groupe pour chaque utilisateur.  Le dernier
      (utilisateur) est automatiquement ajouté &agrave; la
      liste des groupes par le système; l'utilisateur
      n'apparaîtra pas comme étant membre quand on utilise
      l'option <option>groupshow</option> avec &man.pw.8;, mais
      apparaîtra quand l'information est demandée
      par l'intermédiaire de &man.id.1; ou un outil similaire.
      En d'autres termes, &man.pw.8; manipule uniquement le fichier
      <filename>/etc/group</filename>, il n'essaiera jamais de lire des
      données supplémentaires &agrave; partir
      du fichier <filename>/etc/passwd</filename>.</para>

    <example>
      <title>Utilisation de &man.id.1; pour déterminer
	l'appartenance &agrave; un groupe</title>

      <screen>&prompt.user; <userinput>id jru</userinput>
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)</screen>
    </example>

    <para>Comme vous pouvez le voir, <systemitem class="username">jru</systemitem> est membre
      des groupes <systemitem class="groupname">jru</systemitem> et
      <systemitem class="groupname">teamtwo</systemitem>.</para>

    <para>Pour plus d'information sur &man.pw.8;, voir sa page de
      manuel, et pour d'information sur le format de
      <filename>/etc/group</filename>, consultez la page de manuel
      &man.group.5;.</para>
  </sect1>
</chapter>
