<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD French Documentation Project

     $FreeBSD$
     Original revision: 1.235
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="updating-upgrading">
  <info><title>Mise &agrave; jour de &os;</title>
    <authorgroup>
      <author><personname><firstname>Jim</firstname><surname>Mock</surname></personname><contrib>Restructuré, réorganisé, et en partie mis
	  &agrave; jour par </contrib></author>
      <!-- Mar 2000 -->
    </authorgroup>
    <authorgroup>
      <author><personname><firstname>Jordan</firstname><surname>Hubbard</surname></personname><contrib>Travail original de </contrib></author>
      <author><personname><firstname>Poul-Henning</firstname><surname>Kamp</surname></personname></author>
      <author><personname><firstname>John</firstname><surname>Polstra</surname></personname></author>
      <author><personname><firstname>Nik</firstname><surname>Clayton</surname></personname></author>
    </authorgroup>
    
  </info>

  
  &trans.a.fonvieille;

  <sect1 xml:id="updating-upgrading-synopsis">
    <title>Synopsis</title>

    <para>&os; est en constant développement entre deux
      versions.
      Certains utilisateurs préfèrent utiliser les
      versions publiées officiellement alors que d'autres
      voudront rester &agrave; jour avec les tous derniers
      développements.  Mêmes les versions officielles
      sont souvent mises &agrave; jour avec les correctifs de
      problèmes critiques et de sécurité.
      Indépendamment de la version utilisée, &os;
      fournit tous les outils nécessaires &agrave; la mise
      &agrave; jour de votre système, et permet
      également des mises &agrave; jour aisées entre
      versions.
      Ce chapitre vous aidera &agrave;
      décider si vous voulez suivre les développements, ou vous
      en tenir aux versions publiées.  Les outils de base pour
      le maintien &agrave; jour de votre système seront
      également présentés.</para>

    <para>Après la lecture de ce chapitre, vous
      connaîtrez:</para>

    <itemizedlist>
      <listitem>
	<para>Quels utilitaires peuvent être employés
	  pour mettre &agrave; jour le système et le catalogue
	  des logiciels portés.</para>
      </listitem>

      <listitem><para>Comment maintenir votre système &agrave;
	jour avec <application>freebsd-update</application>,
	<application>CVSup</application>,
	<application>CVS</application>, ou
	<application>CTM</application>.</para>
      </listitem>

      <listitem>
	<para>Comment comparer l'état d'un système
	  installé avec une copie de confiance.</para>
      </listitem>

      <listitem>
	<para>La différence entre les deux branches de
	  développement: &os.stable; et &os.current;.</para>
      </listitem>

      <listitem><para>Comment recompiler et réinstaller
	l'intégralité du système de base avec
	la commande <command>make buildworld</command> (etc.).</para>
      </listitem>

    </itemizedlist>

    <para>Avant de lire ce chapitre, vous devrez:</para>

    <itemizedlist>
      <listitem><para>Correctement configurer votre connexion
	réseau (<xref linkend="advanced-networking"/>).</para>
      </listitem>
      <listitem><para>Savoir comment installer des logiciels
	tiers (<xref linkend="ports"/>).</para></listitem>
    </itemizedlist>

    <note>
      <para>Tout au long de ce chapitre, la commande
	<command>cvsup</command> sera utilisée pour
	récupérer et mettre &agrave; jour les sources de
	&os;.  Pour l'utiliser, vous devrez installer un logiciel
	porté ou pré-compilé tel que <package>net/cvsup-without-gui</package>.  Si vous
	utilisez &os;&nbsp;6.2-RELEASE ou une version
	ultérieure, vous pouvez remplacer cette commande par
	&man.csup.1;, qui fait désormais partie du
	système de base.</para>
    </note>
  </sect1>

  <sect1 xml:id="updating-upgrading-freebsdupdate">
    <info><title>Mise &agrave; jour de FreeBSD</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Ecrit par </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Colin</firstname><surname>Percival</surname></personname><contrib>Basé sur des notes de </contrib></author>
      </authorgroup>
    </info>
    

    <indexterm><primary>Mise &agrave; jour</primary></indexterm>
    <indexterm>
      <primary>freebsd-update</primary>
      <see>mise &agrave; jour</see>
    </indexterm>

    <para>Appliquer des correctifs de sécurité est une
      part importante de la maintenance de logiciels informatiques
      tout particulièrement dans le cas du système
      d'exploitation.  Pendant très longtemps sous &os;, ce
      processus n'était pas aisé.  Les correctifs
      devaient être appliqués au code source, le code
      ensuite recompilé sous forme de binaires, et enfin les
      binaires devaient être ré-installés.</para>

    <para>Ce processus n'est plus de mise comme &os; dispose
      désormais d'un utilitaire appelé simplement
      <command>freebsd-update</command>.  Cet utilitaire fournit deux
      fonctions distinctes.  Tout d'abord, il permet l'application de
      mises &agrave; jour de correction et de sécurité
      sur le système de base de &os; sans nécessiter une
      compilation et une ré-installation.  En second lieu,
      l'utilitaire supporte les mises &agrave; jour mineures et
      majeures des versions publiées.</para>

    <note>
      <para>Les mise &agrave; jour binaires sont disponibles pour
	toutes les architectures actuellement supportées par
	l'équipe de sécurité.  Avant de mettre
	&agrave; jour vers une nouvelle version, les annonces
	concernant la version devront être passées en
	revue sachant qu'elles peuvent contenir des informations
	importantes au sujet de cette version.  Ces annonces peuvent
	être consultées &agrave; l'adresse suivante:
	<uri xlink:href="http://www.FreeBSD.org/releases/">http://www.FreeBSD.org/releases/</uri>.</para>
    </note>

    <para>S'il existe une table <command>crontab</command> utilisant
      <command>freebsd-update</command>, elle doit être
      désactivée avant de démarrer les
      opérations qui vont suivre.</para>

    <sect2 xml:id="freebsdupdate-config-file">
      <title>Le fichier de configuration</title>

      <para>Certains utilisateurs peuvent souhaiter adapter le fichier
	de configuration par défaut
	<filename>/etc/freebsd-update.conf</filename>, permettant un
	meilleur contrôle du processus.  Les options sont
	très bien documentées, mais les suivantes
	demandent un peu plus d'explication:</para>

      <programlisting># Composants du système de base qui doivent être maintenus &agrave; jour.
Components src world kernel</programlisting>

      <para>Ce paramètre contrôle quelles sont les
	parties de &os; qui seront mises &agrave; jour.  Par
	défaut on met &agrave; jour le code source,
	l'intégralité du système de base et le
	noyau.  Les composants sont les mêmes que ceux
	disponibles durant l'installation, par exemple, ajouter
	<literal>world/games</literal> ici permettrait d'appliquer les
	correctifs relatifs aux jeux.  Utiliser
	<literal>src/bin</literal> permettrait la mise &agrave; jour
	du code source du répertoire <filename>src/bin</filename>.</para>

      <para>La meilleure option est de laisser telle quelle la
	configuration par défaut car la modifier pour ajouter
	des éléments particuliers demandera &agrave;
	l'utilisateur de lister chaque élément qu'il
	désire mettre &agrave; jour.  Cela pourrait avoir des
	conséquences désastreuses puisque le code source
	et les binaires peuvent &agrave; terme ne plus être en
	phase.</para>

      <programlisting># Les chemins d'accès commençant par quelque chose correspondant &agrave; une
# entrée de type IgnorePaths seront ignorés.
IgnorePaths</programlisting>

      <para>Ajoute les chemins d'accès comme <filename>/bin</filename> ou <filename>/sbin</filename> pour préserver
	intacts ces répertoires durant le processus de mise
	&agrave; jour.  Cette option peut être utilisée
	pour empêcher <command>freebsd-update</command>
	d'écraser des modifications locales.</para>

      <programlisting># Les chemins d'accès qui commencent par quelque chose correspondant &agrave;
# une entrée de type UpdateIfUnmodified seront mis &agrave; jour que si le
# contenu du fichier n'a pas été modifié par l'utilisateur (&agrave; moins
# que les modifications ne soient fusionnées; voir plus bas).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</programlisting>

      <para>Met &agrave; jour les fichiers de configuration dans les
	répertoires désignés seulement s'ils
	n'ont pas été modifiés.  Tout changement
	effectué par l'utilisateur invalidera automatiquement
	la mise &agrave; jour de ces fichiers.  Il existe une autre
	option <literal>KeepModifiedMetadata</literal> qui indiquera
	&agrave; <command>freebsd-update</command> de sauvegarder les
	changements durant la fusion.</para>

      <programlisting># Quand on met &agrave; jour vers une nouvelle version de &os;, les fichiers
# correspondant &agrave; une entrée de type MergeChanges verront leurs
# différences locales fusionnées avec le fichier de la nouvelle
# version de &os;.
MergeChanges /etc/ /var/named/etc/</programlisting>

      <para>Liste des répertoires avec des fichiers de
	configuration que <command>freebsd-update</command> devrait
	tenter de fusionner.  Le processus de fusion des fichiers est
	l'application d'une série de correctifs &man.diff.1;
	similaires &agrave; ceux de &man.mergemaster.8; avec cependant
	moins d'options, les fusions sont soit acceptées,
	ouvrant un éditeur, soit abandonnées par
	<command>freebsd-update</command>.  En cas de doute,
	sauvegardez <filename>/etc</filename> et
	acceptez les fusions.  Consultez la section sur <xref linkend="mergemaster"/> pour plus d'information sur la commande
	<command>mergemaster</command>.</para>

      <programlisting># Répertoire dans lequel stocker les mise &agrave; jour téléchargées et les
# fichiers temporaires utilisés par la mise &agrave; jour de &os;.
# WorkDir /var/db/freebsd-update</programlisting>

      <para>Ce répertoire est l'endroit où tous les
	correctifs et les fichiers temporaires seront placés.
	Dans les cas où l'utilisateur effectue une mise
	&agrave; jour de version, cet emplacement doit disposer d'au
	moins un gigaoctet d'espace disponible.</para>

      <programlisting># Lors de mises &agrave; jour entre versions de &os;, doit-on lire la liste
# de composants de manière stricte (StrictComponents yes)
# ou tout simplement comme une liste de composants qui *pourraient*
# être installés et pour lesquels la mise &agrave; jour de &os; devrait
# déterminer lesquels sont effectivement installés et les mettre &agrave;
# jour (StrictComponents no)?
# StrictComponents no</programlisting>

      <para>Cette option fixée &agrave; <literal>yes</literal>,
	<command>freebsd-update</command> supposera que la liste de
	composants est complète et n'essaiera pas d'effectuer
	des modifications en dehors de cette liste.
	Concrètement, <command>freebsd-update</command> tentera
	de mettre &agrave; jour chaque fichier appartenant &agrave; la
	liste de composants.</para>
    </sect2>

    <sect2 xml:id="freebsdupdate-security-patches">
      <title>Correctifs de sécurité</title>

      <para>Les correctifs de sécurité sont
	stockés sur une machine distante et peuvent être
	téléchargés et installés en
	utilisant la commande suivante:</para>

      <screen>&prompt.root; <userinput>freebsd-update fetch</userinput>
&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Si des correctifs ont été appliqués
	au noyau le système devra être
	redémarré.  Si tout c'est bien passé le
	système est corrigé et
	<command>freebsd-update</command> pourra être
	exécuté chaque nuit via un processus
	&man.cron.8;.  Une entrée dans le fichier
	<filename>/etc/crontab</filename> devrait être
	suffisante pour accomplir cette tâche:</para>

      <programlisting>@daily                                  root    freebsd-update cron</programlisting>

      <para>Cette entrée indique qu'une fois par jour,
	l'utilitaire <command>freebsd-update</command> sera
	exécuté.  De cette manière, en employant
	l'option <option>cron</option>,
	<command>freebsd-update</command> vérifiera seulement
	l'existence de mises &agrave; jour.  Si des correctifs
	existent, il seront automatiquement
	téléchargés sur le disque local mais
	non-appliqués.  L'utilisateur <systemitem class="username">root</systemitem>
	sera contacté par courrier électronique, il
	pourra ainsi les installer manuellement.</para>

      <para>Si quelque s'est mal passé,
	<command>freebsd-update</command> a la capacité
	d'annuler le dernier ensemble de changements avec la commande
	suivante:</para>

      <screen>&prompt.root; <userinput>freebsd-update rollback</userinput></screen>

      <para>Une fois la commande achevée, le système
	devra être redémarré si le noyau ou un de
	ses modules ont été modifiés.  Cela
	permettra &agrave; &os; de charger en mémoire les
	nouveaux binaires.</para>

      <para>L'utilitaire <command>freebsd-update</command> peut mettre
	&agrave; jour uniquement et automatiquement le noyau
	<literal>GENERIC</literal>.  Si un noyau personnalisé
	est utilisé, il devra être recompilé et
	réinstallé après que la commande
	<command>freebsd-update</command> ait achevé
	l'installation du reste des mises &agrave; jour.  Cependant
	<command>freebsd-update</command> détectera et mettra
	&agrave; jour le noyau <literal>GENERIC</literal> dans
	<filename>/boot/GENERIC</filename> (s'il
	existe), et cela même si ce n'est pas le noyau actuel
	(qui tourne) du système.</para>

      <note>
	<para>C'est toujours une bonne idée de conserver une
	  copie du noyau <literal>GENERIC</literal> dans <filename>/boot/GENERIC</filename>.  Cela sera utile
	  pour diagnostiquer une variété de
	  problèmes, et lors des mises &agrave; jour utilisant
	  <command>freebsd-update</command> comme décrit dans
	  la <xref linkend="freebsdupdate-upgrade"/>.</para>
      </note>

      <para>A moins que la configuration par défaut
	présente dans
	<filename>/etc/freebsd-update.conf</filename> n'ait
	été modifiée,
	<command>freebsd-update</command> installera les sources du
	noyau mises &agrave; jour avec le reste des mises &agrave;
	jour.  La recompilation et la réinstallation d'un noyau
	personnalisé peuvent effectuées de la
	manière classique.</para>

      <note>
	<para>Les mises &agrave; jour distribuées via
	  <command>freebsd-update</command>, n'impliquent pas toujours
	  le noyau.  Il ne sera pas nécessaire de recompiler
	  votre noyau personnalisé si les sources du noyau
	  n'ont pas été modifiées par
	  l'exécution de <command>freebsd-update
	  install</command>.  Cependant
	  <command>freebsd-update</command> met toujours &agrave; jour
	  le fichier
	  <filename>/usr/src/sys/conf/newvers.sh</filename>.  Le
	  niveau ou la version de correctifs (comme indiqué par
	  le nombre <literal>-p</literal> rapporté par
	  <command>uname -r</command>) est obtenu &agrave; partir de
	  ce fichier.  Recompiler votre noyau personnalisé,
	  même si rien d'autre n'a changé, permettra
	  &agrave; la commande &man.uname.1; de rapporter
	  précisément le niveau de correctifs du
	  système.  C'est particulièrement utile quand
	  on gère de multiples systèmes, car cela permet
	  une évaluation rapide des mises &agrave; jour
	  présentes sur chacun d'eux.</para>
      </note>
    </sect2>

    <sect2 xml:id="freebsdupdate-upgrade">
      <title>Mises &agrave; jour mineures et majeures</title>

      <para>Ce processus supprimera les anciens fichiers objets et
	bibliothèques qui rendent inutilisables la plupart des
	applications tierce-partie.  Il est recommandé que tous
	les logiciels portés soient supprimés et
	réinstallés ou mis &agrave; jour
	ultérieurement en utilisant l'outil <package>ports-mgmt/portupgrade</package>.  La plupart
	des utilisateurs voudront lancer une compilation test &agrave;
	l'aide de la commande suivante:</para>

      <screen>&prompt.root; <userinput>portupgrade -af</userinput></screen>

      <para>Cela garantira que tout sera réinstallé
	correctement.  Notez que fixer la variable d'environnement
	<varname>BATCH</varname> &agrave; <literal>yes</literal>
	répondra <literal>yes</literal> &agrave; toute question
	lors de ce processus, supprimant ainsi la
	nécessité d'une intervention humaine durant le
	processus de compilation.</para>

      <para>Si un noyau personnalisé est utilisé, le
	processus de mise &agrave; jour est un peu plus complexe.  Une
	copie du noyau <literal>GENERIC</literal> est
	nécessaire et devrait être placée dans le
	répertoire <filename>/boot/GENERIC</filename>.  Si le noyau
	<literal>GENERIC</literal> n'est pas présent sur le
	système, il peut être obtenu en utilisant une des
	méthodes suivantes:</para>

      <itemizedlist>
	<listitem>
	  <para>Si un noyau personnalisé a déj&agrave;
	    été compilé, le noyau présent
	    dans <filename>/boot/kernel.old</filename> est en fait
	    le noyau <literal>GENERIC</literal>.  Renommer ce
	    répertoire en <filename>/boot/GENERIC</filename>.</para>
	</listitem>

	<listitem>
	  <para>En supposant qu'un accès physique &agrave; la
	    machine est possible, une copie du noyau
	    <literal>GENERIC</literal> peut être installé
	    &agrave; partir d'un CD-ROM.  Insérer votre disque
	    d'installation et utiliser les commandes suivantes:</para>

	  <screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>cd /cdrom/X.Y-RELEASE/kernels</userinput>
&prompt.root; <userinput>./install.sh GENERIC</userinput></screen>

	  <para>Remplacer <filename>X.Y-RELEASE</filename>
	    avec la version que vous utilisez.  Le noyau
	    <literal>GENERIC</literal> sera installé par
	    défaut dans <filename>/boot/GENERIC</filename>.</para>
	</listitem>

	<listitem>
	  <para>En dehors de ce qui précède le noyau
	    <literal>GENERIC</literal> peut être
	    recompilé et installé &agrave; partir des
	    sources:</para>

	  <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>env DESTDIR=/boot/GENERIC make kernel</userinput>
&prompt.root; <userinput>mv /boot/GENERIC/boot/kernel/* /boot/GENERIC</userinput>
&prompt.root; <userinput>rm -rf /boot/GENERIC/boot</userinput></screen>

	  <para>Pour que ce noyau soit pris en compte comme
	    <literal>GENERIC</literal> par
	    <command>freebsd-update</command>, le fichier de
	    configuration <literal>GENERIC</literal> devra ne pas
	    avoir été modifié.  Il est
	    également suggéré qu'il soit
	    compilé sans aucune option particulière (de
	    préférence avec un fichier
	    <filename>/etc/make.conf</filename> vide).</para>
	</listitem>
      </itemizedlist>

      <para>Redémarrer avec le noyau <literal>GENERIC</literal>
	n'est pas nécessaire &agrave; ce stade.</para>

      <para>Les mises &agrave; jour de versions majeures et mineures
	peuvent être effectuées en passant &agrave; la
	commande <command>freebsd-update</command> la version vers
	laquelle on désire mettre &agrave; jour, par exemple,
	la commande suivante effectuera la mise &agrave; jour vers
	&os;&nbsp;8.1:</para>

      <screen>&prompt.root; <userinput>freebsd-update -r 8.1-RELEASE upgrade</userinput></screen>

      <para>La commande <command>freebsd-update</command> analysera le
	fichier de configuration et le système afin de
	récupérer les informations nécessaires
	&agrave; la mise &agrave; jour du système.  A
	l'écran s'affichera quels sont les composants
	détectés et quels sont ceux qui n'ont pas
	été détectés.  Par exemple:</para>

      <screen>Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature for 8.0-RELEASE from update1.FreeBSD.org... done.
Fetching metadata index... done.
Inspecting system... done.

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD do not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable (y/n)? y</screen>

      <para>A ce niveau <command>freebsd-update</command> tentera de
	télécharger tous les fichiers nécessaires
	&agrave; la mise &agrave; jour.  Dans certains cas
	l'utilisateur sera interrogé sur ce qu'il faut
	installer ou sur comment procéder &agrave; certaines
	actions.</para>

      <para>Si un noyau personnalisé est utilisé,
	l'étape précédente produira un
	avertissement semblable au suivant:</para>

      <screen>WARNING: This system is running a "<replaceable>MYKERNEL</replaceable>" kernel, which is not a
kernel configuration distributed as part of FreeBSD 8.0-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running "/usr/sbin/freebsd-update install"</screen>

      <para>Cet avertissement peut sans risque être
	ignoré &agrave; ce niveau.  Le noyau
	<filename>GENERIC</filename> mis &agrave; jour sera
	utilisé comme une étape intermédiaire
	dans le processus de mise &agrave; jour.</para>

      <para>Une fois l'ensemble des correctifs
	téléchargé sur le système local,
	ils seront appliqués.  Ce processus peut prendre plus
	ou moins de temps en fonction de la vitesse et de la charge de
	la machine.  Les fichiers de configuration seront
	fusionnés&nbsp;&mdash; cette partie du processus
	demande l'intervention de l'utilisateur car un fichier peut
	être automatiquement fusionné ou en cas de besoin
	un éditeur peut apparaître sur l'écran
	pour une fusion manuelle.  Les résultats des fusions
	réussies seront affichés au fur et &agrave;
	mesure que se déroule l'opération.  Un
	échec ou une fusion ignorée provoqueront
	l'arrêt du processus.  Certains utilisateurs peuvent
	vouloir conserver une sauvegarde du répertoire
	<filename>/etc</filename> et fusionner plus
	tard &agrave; la main les fichiers importants comme
	<filename>master.passwd</filename> ou
	<filename>group</filename>.</para>

      <note>
	<para>Le système n'a pas encore été
	  réellement modifié, les fusions et
	  l'application des correctifs ont lieu dans un autre
	  répertoire.  Quand tous les correctifs ont
	  été appliqués avec succès, que
	  tous les fichiers de configuration ont été
	  fusionnés et que le processus s'est
	  déroulé sans problème, les
	  modifications devront être appliquées
	  définitivement au système par
	  l'utilisateur.</para>
      </note>

      <para>Une fois les opérations précédentes
	achevées, la mise &agrave; jour peut être
	appliquée en utilisant la commande suivante:</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Le noyau et les modules seront corrigés les
	premiers.  A ce moment la machine doit être
	obligatoirement redémarrée.  Si le
	système utilisait un noyau personnalisé,
	utiliser la commande &man.nextboot.8; pour indiquer le noyau
	<filename>/boot/GENERIC</filename> (qui a
	été mis &agrave; jour) pour le prochain
	démarrage:</para>

      <screen>&prompt.root; <userinput>nextboot -k GENERIC</userinput></screen>

      <warning>
	<para>Avant de redémarrer sur le noyau
	  <literal>GENERIC</literal>, assurez-vous qu'il contient tous
	  les pilotes nécessaires pour que votre système
	  démarre correctement (et se connecte au
	  réseau, si la mise &agrave; jour de la machine se
	  fait &agrave; distance).  En particulier, si le noyau
	  précédemment utilisé contient des
	  fonctions généralement fournies par des
	  modules, faites en sorte de charger temporairement ces
	  modules avec le noyau <filename>GENERIC</filename> &agrave;
	  l'aide de <filename>/boot/loader.conf</filename>.  Vous
	  pouvez également avoir intérêt &agrave;
	  désactiver les services non-indispensables, les
	  montages réseaux ou disques, etc.  avant que le
	  processus de mise &agrave; jour ne soit
	  achevé.</para>
      </warning>

      <para>La machine doit maintenant être
	redémarrée avec le noyau mis &agrave;
	jour:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <para>Une fois la machine de nouveau active,
	<command>freebsd-update</command> devra être
	lancée &agrave; nouveau.  L'état du processus de
	mise &agrave; jour a été sauvegardé, et
	donc <command>freebsd-update</command> ne recommencera pas au
	début, mais supprimera les anciens fichiers objet et
	bibliothèques partagées.  Afin de poursuivre les
	opérations, taper la commande suivante:</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <note>
	<para>En fonction d'un changement ou non de
	  numérotation d'une ou plusieurs bibliothèques,
	  il pourra y avoir deux phases d'installation au lieu de
	  trois.</para>
      </note>

      <para>Tous les logiciels tierce-partie doivent être
	maintenant recompilés et réinstallés.
	Cela est nécessaire comme certains logiciels peuvent
	dépendre de bibliothèques qui ont
	été supprimées lors du processus de mise
	&agrave; jour.  La commande <package>ports-mgmt/portupgrade</package> peut
	être employée pour automatiser la chose.  Les
	commandes suivantes peuvent être utilisées pour
	initier le processus:</para>

      <screen>&prompt.root; <userinput>portupgrade -f ruby</userinput>
&prompt.root; <userinput>rm /var/db/pkg/pkgdb.db</userinput>
&prompt.root; <userinput>portupgrade -f ruby18-bdb</userinput>
&prompt.root; <userinput>rm /var/db/pkg/pkgdb.db /usr/ports/INDEX-*.db</userinput>
&prompt.root; <userinput>portupgrade -af</userinput></screen>

      <para>Une fois cela effectué, terminer le processus de
	mise &agrave; jour avec un dernier appel &agrave;
	<command>freebsd-update</command>.  Taper la commande suivante
	pour régler les derniers détails:</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Si le noyau <literal>GENERIC</literal> a été
	utilisé temporairement, il est temps de compiler et
	d'installer un nouveau noyau personnalisé suivant la
	méthode habituelle.</para>

      <para>Redémarrer la machine avec la nouvelle version de
	&os;.  Le processus de mise &agrave; jour est
	terminé.</para>
    </sect2>

    <sect2 xml:id="freebsdupdate-system-comparison">
      <title>Comparaison de l'état du système</title>

      <para>L'utilitaire <command>freebsd-update</command> peut
	être utilisé pour comparer l'état du
	système &os; installé avec une copie de
	confiance.  Cette fonctionnalité inspecte la version
	actuelle des utilitaires système, des
	bibliothèques et des fichiers de configuration.  Pour
	lancer la comparaison, utiliser la commande suivante:</para>

      <screen>&prompt.root; <userinput>freebsd-update IDS &gt;&gt; outfile.ids</userinput></screen>

      <warning>
	<para>Bien que le nom de la commande soit
	  <acronym>IDS</acronym>, elle ne devrait en aucun cas
	  être considérée comme un système
	  de détection d'intrusion du type de <package>security/snort</package>.  Etant
	  donné que <command>freebsd-update</command> stocke
	  des données sur le disque, le risque de modification
	  des données est évident.  Alors que cette
	  possibilité peut être minimisée en
	  utilisant le paramétrage
	  <varname>kern.securelevel</varname> et en stockant les
	  données <command>freebsd-update</command> sur un
	  système de fichiers en lecture seule quand elles ne
	  sont pas utilisées, une bien meilleure solution
	  serait de comparer le système avec un disque
	  sécurisé comme un <acronym>DVD</acronym> ou un
	  disque <acronym>USB</acronym> conservé &agrave;
	  l'extérieur.</para>
      </warning>

      <para>Le système sera analysé, et une liste de
	fichiers ainsi que la valeur de leur empreinte
	numérique &man.sha256.1;, celle de la version d'origine
	et celle de la version actuellement installée, seront
	affichés.  C'est pour cela que cet affichage est
	copié dans le fichier <filename>outfile.ids</filename>.
	L'affichage défile trop rapidement une comparaison
	visuelle et remplira rapidement le tampon de la
	console.</para>

      <para>Ces lignes sont également très longues mais
	le format de sortie peut être facilement passé
	par une analyse syntaxique.  Par exemple, pour obtenir une
	liste des fichiers qui diffèrent avec ceux de la
	version d'origine, utiliser la commande suivante:</para>

      <screen>&prompt.root; <userinput>cat outfile.ids | awk '{ print $1 }' | more</userinput>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</screen>

      <para>La sortie de cette commande a été
	tronquée, bien plus de fichiers sont concernés.
	Certains de ces fichiers sont naturellement modifiés,
	le fichier <filename>/etc/passwd</filename> a
	été modifié en raison de l'ajout
	d'utilisateurs au système.  Dans certains cas, d'autres
	fichiers apparaîtrons, comme les modules du noyau, qui
	diffèrent puisque <command>freebsd-update</command>
	peut les avoir mis &agrave; jour.  Pour exclure des fichiers
	ou des répertoires spécifiques, ajoutez-les au
	paramètre <literal>IDSIgnorePaths</literal> dans le
	fichier <filename>/etc/freebsd-update.conf</filename>.</para>

      <para>Ce système peut prendre part &agrave; une
	méthode de mise &agrave; jour élaboré, en
	dehors de ce qui a été présenté
	précédemment.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="updating-upgrading-portsnap">
    <info><title>Portsnap: un outil de mise &agrave; jour du catalogue des
      logiciels portés</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Ecrit par </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Colin</firstname><surname>Percival</surname></personname><contrib>Basé sur les notes de </contrib></author>
      </authorgroup>
    </info>
    

    <indexterm><primary>Mise &agrave; jour</primary></indexterm>
    <indexterm>
      <primary>Portsnap</primary>
      <see>mise &agrave; jour</see>
    </indexterm>

    <para>Le système de base de &os; dispose également
      d'un utilitaire pour la mise &agrave; jour du catalogue des
      logiciels portés: &man.portsnap.8;.  Lors de son
      exécution, il se connectera sur un site distant,
      contrôlera la clé de sécurité et
      téléchargera une nouvelle copie du catalogue des
      logiciels portés.  La clé est utilisée pour
      vérifier l'intégrité de tous les fichiers
      téléchargés, s'assurant qu'ils n'ont pas
      été modifiés au vol.  Pour
      récupérer les tout derniers fichiers du catalogue
      des logiciels portés, utiliser la commande
      suivante:</para>

    <screen>&prompt.root; <userinput>portsnap fetch</userinput>
Looking up portsnap.FreeBSD.org mirrors... 3 mirrors found.
Fetching snapshot tag from portsnap1.FreeBSD.org... done.
Fetching snapshot metadata... done.
Updating from Wed Aug  6 18:00:22 EDT 2008 to Sat Aug 30 20:24:11 EDT 2008.
Fetching 3 metadata patches.. done.
Applying metadata patches... done.
Fetching 3 metadata files... done.
Fetching 90 patches.....10....20....30....40....50....60....70....80....90. done.
Applying patches... done.
Fetching 133 new ports or files... done.</screen>

    <para>Cet exemple nous montre que &man.portsnap.8; a trouvé
      et contrôlé plusieurs mises &agrave; jour pour les
      données actuelles du catalogue.  Est également
      indiqué si l'utilitaire a été
      précédemment exécuté, si cela avait
      été une première exécution, le
      catalogue aurait été tout simplement
      téléchargé.</para>

    <para>Lorsque &man.portsnap.8; termine avec succès une
      opération de récupération
      (<command>fetch</command>), le catalogue des logiciels
      portés et ses mises &agrave; jour sont présents
      sur le système.  A la première exécution de
      <command>portsnap</command> vous devez utiliser la commande
      <literal>extract</literal> pour installer les fichiers
      téléchargés:</para>

    <screen>&prompt.root; <userinput>portsnap extract</userinput>
/usr/ports/.cvsignore
/usr/ports/CHANGES
/usr/ports/COPYRIGHT
/usr/ports/GIDs
/usr/ports/KNOBS
/usr/ports/LEGAL
/usr/ports/MOVED
/usr/ports/Makefile
/usr/ports/Mk/bsd.apache.mk
/usr/ports/Mk/bsd.autotools.mk
/usr/ports/Mk/bsd.cmake.mk
<replaceable>...</replaceable></screen>

    <para>Pour mettre &agrave; jour un catalogue des logiciels
      portés déj&agrave; installé utilisez la
      commande <command>portsnap update</command>:</para>

    <screen>&prompt.root; <userinput>portsnap update</userinput></screen>

    <para>Le processus est maintenant terminé et les
      applications peuvent être installées ou mises
      &agrave; jour &agrave; l'aide du catalogue &agrave; jour.</para>

    <para>Les opérations <literal>fetch</literal> et
      <literal>extract</literal> ou <literal>update</literal> peuvent
      être exécutées &agrave; la suite comme
      montré dans l'exemple suivant:</para>

    <screen>&prompt.root; <userinput>portsnap fetch update</userinput></screen>

    <para>Cette commande téléchargera la dernière
      version du catalogue des logiciels portés et mettra
      &agrave; jour votre version locale située dans <filename>/usr/ports</filename>.</para>
  </sect1>

  <sect1 xml:id="current-stable">
    <title>Suivre une branche de développement</title>
    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>Il existe deux branches de développement de FreeBSD:
      &os.current; et &os.stable;.  Cette section détaillera
      un peu chacune d'elles et décrira comment garder &agrave;
      jour votre système avec chaque arborescence respective.
      &os.current; sera tout d'abord traité, suivit de
      &os.stable;.</para>

    <sect2 xml:id="current">
      <title>Se synchroniser avec la version -CURRENT de &os;</title>

      <para>En lisant ces lignes, gardez &agrave; l'esprit que
	&os.current; représente &ldquo;les tout derniers&rdquo;
	développement de &os;.  On attend des utilisateurs
	de &os.current; un degré élevé de
	compétences techniques, et devraient être
	capables de résoudre des problèmes système
	compliqués par eux-mêmes.  Si vous êtes
	nouveau &agrave; &os;, pensez &agrave; deux fois avant de
	l'installer.</para>

      <sect3>
	<title>Qu'est-ce que &os.current;?</title>
	<indexterm><primary>instantané</primary></indexterm>

	<para>&os.current; est la toute dernière version des sources
	  de &os; en cours de développement.  Cela inclut des
	  évolutions en cours, des modifications expérimentales,
	  et des mécanismes de transition qui feront ou ne feront pas
	  partie de la prochaine version officielle du logiciel.
	  Bien que de nombreux développeurs de &os; compilent les
	  sources de &os.current; quotidiennement, il arrive que
	  celles-ci ne soient pas compilables pendant une certaine
	  période de temps.  Ces problèmes sont résolus
	  aussi rapidement que possible, mais que &os.current; soit
	  &agrave; l'origine d'un désastre ou de l'apport d'une nouvelle
	  fonctionnalité attendue peut parfois dépendre
	  que du moment auquel vous avez chargé le code
	  source.</para>
      </sect3>

      <sect3>
	<title>Qui a besoin de &os.current;?</title>

	<para>&os.current; est mis &agrave; disposition pour 3
	  types de personnes:</para>

	<orderedlist>
	  <listitem>
	    <para>Les membres de la communauté &os; qui travaillent
	      activement sur une partie de l'arborescence des sources
	      et pour qui rester constamment &agrave; jour est une
	      nécessité absolue.</para>
	  </listitem>

	  <listitem>
	    <para>Les membres de la communauté &os; qui participent
	      activement aux tests et sont disposés &agrave; passer du
	      temps &agrave; résoudre les problèmes pour
	      garantir que &os.current; reste aussi saine que
	      possible.  Il y a également ceux qui désirent
	      faire des suggestions dans certains domaines sur les
	      modifications &agrave; faire et la direction
	      générale que prend &os;, et soumettent des
	      correctifs pour les implémenter.</para>
	  </listitem>

	  <listitem>
	    <para>Ceux qui veulent simplement garder un oeil sur les
	      évolutions, ou utiliser les dernières sources comme
	      référence (e.g. pour les <emphasis>lire</emphasis>,
	      et non pour les utiliser).  Ces personnes font parfois
	      des remarques ou contribuent au code.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Qu'est-ce que <emphasis>n'est pas</emphasis>
	  &os.current;?</title>

	<orderedlist>
	  <listitem>
	    <para>Un raccourci pour se procurer des pré-versions
	      parce que vous avez entendu dire qu'il y a de nouvelles
	      fonctionnalités géniales et que vous voulez
	      être le premier du coin &agrave; les avoir.  Etre le
	      premier &agrave; avoir la nouvelle fonctionnalité
	      signifie être le premier &agrave; avoir les nouveaux bogues
	      également.</para>
	  </listitem>

	  <listitem>
	    <para>Une moyen rapide d'avoir des corrections de bogues.
	      N'importe quelle version de &os.current; apportera
	      probablement de nouveaux bogues comme elle corrigera
	      ceux déj&agrave; présents.</para>
	  </listitem>

	  <listitem>
	    <para>Nous ne le &ldquo;supportons officiellement&rdquo;
	      en aucun cas.  Nous faisons du mieux que nous pouvons
	      pour aider les personnes qui font vraiment partie des
	      trois groupes &ldquo;légitimes&rdquo; &agrave; qui s'adresse
	      &os.current;, mais nous n'avons tout simplement
	      &ldquo;pas le temps&rdquo; de fournir un support
	      technique.  Ce n'est pas parce que nous sommes des
	      personnes détestables qui n'aiment pas aider les autres
	      (nous ne ferions pas &os; si tel était le cas), nous ne
	      pouvons simplement pas répondre &agrave; des centaines de
	      messages par jour <emphasis>et</emphasis> travailler sur
	      FreeBSD!  Entre améliorer &os; et répondre &agrave; de
	      nombreuses questions sur le code expérimental, les
	      développeurs optent pour le premier choix.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Utiliser &os.current;</title>

	<orderedlist>
	  <listitem>
	    <para>Inscrivez-vous &agrave; la &a.current.name;<indexterm><primary>-CURRENT</primary><secondary>utilisation</secondary></indexterm> et la &a.svn-src-head.name;.
	      Ce n'est pas seulement une bonne idée, c'est
	      <emphasis>indispensable</emphasis>.  Si vous n'êtes
	      pas sur la liste <emphasis>&a.current.name;</emphasis>, vous
	      ne verrez pas les commentaires qui sont faits sur l'état
	      courant du système et vous vous retrouverez probablement
	      confrontés &agrave; de nombreux problèmes que
	      d'autres ont déj&agrave; identifiés et
	      résolus.  Encore plus grave, vous manqueriez des
	      bulletins importants potentiellement critiques pour la bonne
	      santé de votre système.</para>

	    <para>La liste &a.svn-src-head.name; vous permettra de voir les courriers
	      de trace des soumissions de toutes les modifications
	      dès qu'elles sont faites et des informations
	      pertinentes sur les éventuels effets de bord.</para>

	    <para>Pour vous inscrire &agrave; ces listes, ou &agrave;
	      une autre, rendez vous &agrave; &a.mailman.lists.link;
	      et cliquez sur la liste &agrave; laquelle vous
	      désirez vous inscrire.  Des instructions sur le
	      reste de la procédure sont alors données.
	      Si vous êtes intéressé par le suivi
	      des modifications appliquées &agrave; l'ensemble
	      de l'arborescence des sources, nous vous recommandons de
	      vous inscrire &agrave; &a.svn-src-all.name;.</para>
	  </listitem>

	  <listitem>
	    <para>Récupérez les sources sur un <link linkend="mirrors">site miroir</link> &os;.  Vous pouvez le
	      faire de deux manières:</para>

	    <orderedlist>
	      <listitem>
		<para>Utilisez le programme <link linkend="cvsup">cvsup</link><indexterm><primary><command>cvsup</command></primary></indexterm>
		  avec le fichier <filename>supfile</filename>
		  nommé <filename>standard-supfile</filename>
		  disponible dans le répertoire <filename>/usr/share/examples/cvsup</filename>.
		  C'est la méthode recommandée, puisqu'elle
		  permet de récupérer la totalité
		  des sources la première fois et par la suite
		  uniquement ce qui a été modifié.
		  De nombreuses personnes exécutent
		  <command>cvsup</command> depuis
		  <command>cron</command><indexterm><primary><command>cron</command></primary></indexterm> et maintiennent ainsi
		  automatiquement &agrave; jour leurs sources.  Vous devez
		  personnaliser l'exemple de <filename>supfile</filename>
		  précédent, et configurer
		  <link linkend="cvsup">cvsup</link><indexterm><primary>-CURRENT</primary><secondary>Synchronisation avec <application>CVSup</application></secondary></indexterm> pour
		  votre environnement.</para>

		<note>
		  <para>Le fichier d'exemple
		    <filename>standard-supfile</filename> est
		    destiné au suivi d'une branche de
		    sécurité &os; spécifique et
		    non pas &agrave; celui de &os.current;.  Vous
		    devrez éditer ce fichier et remplacer la
		    ligne suivante:</para>

		  <programlisting>*default release=cvs tag=RELENG_<replaceable>X</replaceable>_<replaceable>Y</replaceable></programlisting>

		  <para>Par celle-ci:</para>

		  <programlisting>*default release=cvs tag=.</programlisting>

		  <para>Pour une explication détaillée
		    des étiquettes utilisables, veuillez vous
		    référer &agrave; la section <link linkend="cvs-tags">Etiquettes CVS</link> de ce
		    manuel.</para>
		</note>
	      </listitem>

	      <listitem>
		<para>Utilisez <application>CTM</application><indexterm><primary>-CURRENT</primary><secondary>Synchroniser avec <application>CTM</application></secondary></indexterm>.  Si vous
		  disposez d'une mauvaise connexion (connexions chères
		  ou seulement un accès au courrier électronique)
		  <application>CTM</application> est une bonne
		  solution.  Cependant, c'est une source de problèmes
		  et peut donner lieu &agrave; des fichiers endommagés.
		  C'est pourquoi cette méthode est rarement
		  utilisée, ce qui augmente les chances que cela ne
		  fonctionne pas pendant d'assez longue périodes.
		  Nous recommandons d'utiliser
		  <application>CVSup</application>
		  &agrave; tous ceux disposant d'un modem 9600&nbsp;bps ou
		  d'une connexion plus rapide.
		</para>
	      </listitem>
	    </orderedlist>
	  </listitem>

	  <listitem>
	    <para>Si vous récupérez les sources pour compiler
	      un système opérationnel, et pas simplement
	      pour les lire, alors récupérez
	      <emphasis>tout</emphasis>  &os.current;, et pas
	      uniquement certaines portions.  La raison de cela est
	      que diverses parties des sources dépendent de
	      modifications effectuées ailleurs, et si vous essayez
	      de compiler juste une partie des source, il est quasiment
	      certain que vous aurez des problèmes.</para>
	  </listitem>

	  <listitem>
	    <para>Avant de compiler &os.current;<indexterm><primary>-CURRENT</primary><secondary>compilation</secondary></indexterm>, lisez attentivement
	      le <filename>Makefile</filename> dans
	      <filename>/usr/src</filename>.  Vous devriez au moins
	      la première fois <link linkend="makeworld">installer un nouveau noyau et recompiler le système</link>, comme
	      étape nécessaire &agrave; votre processus de
	      mise &agrave; jour.  La lecture de la &a.current; et du fichier <filename>/usr/src/UPDATING</filename> vous tiendra
	      au courant des autres procédures de transition qui
	      sont parfois nécessaires lorsque nous préparons la
	      prochaine version.</para>
	  </listitem>

	  <listitem>
	    <para>Participez!  Si vous utilisez &os.current;, nous
	      aimerions savoir ce que vous en pensez, tout
	      particulièrement si vous avez des améliorations
	      &agrave; nous suggérer ou des corrections de bogues
	      &agrave; nous soumettre.  Les suggestions accompagnées
	      de code sont accueillies avec enthousiasme!</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>

    <sect2 xml:id="stable">
      <title>Se synchroniser avec la version -STABLE de &os;</title>

      <sect3>
	<title>Qu'est-ce que &os.stable;?</title>
	<indexterm><primary>-STABLE</primary></indexterm>

	<para>&os.stable; est notre branche de développement &agrave;
	  partir de laquelle sont extraites les versions majeures.
	  Les modifications sur cette branche se font &agrave; une allure
	  différente, et en supposant généralement
	  qu'elles ont été tout d'abord testées
	  sur &os.current;.  Cela reste cependant
	  <emphasis>toujours</emphasis> une branche de développement,
	  et cela signifie qu'&agrave; certains moments, les sources de
	  &os.stable; pourront être ou pas utilisables pour une
	  quelconque raison.  C'est tout simplement une autre branche
	  de mise au point, et non pas une ressource pour
	  l'utilisateur final.</para>
      </sect3>

      <sect3>
	<title>Qui a besoin de &os.stable;?</title>

	<para>Si vous désirez suivre ou contribuer au processus
	  de développement de FreeBSD, tout particulièrement si
	  cela a rapport avec la prochaine version de FreeBSD, alors
	  vous devriez penser &agrave; suivre &os.stable;.</para>

	<para>Bien qu'il soit vrai que les correctifs de sécurité
	  vont également dans la branche &os.stable;, vous
	  n'avez pas <emphasis>besoin</emphasis> de suivre
	  &os.stable; pour cela.  Chaque rapport de sécurité
	  concernant FreeBSD explique comment corriger le problème sur
	  les versions affectées
	  <footnote><para>Ceci n'est pas tout &agrave; fait vrai.  Nous
	    ne pouvons continuer &agrave; supporter les anciennes versions de
	    FreeBSD éternellement, bien que nous les supportions
	    pendant de nombreuses années.  Pour une description
	    complète de la politique de sécurité
	    actuelle pour les anciennes versions de FreeBSD, veuillez
	    consulter <link xlink:href="&url.base;/security/">http://www.FreeBSD.org/security/</link>.</para>
	  </footnote>
	  , et suivre intégralement une branche de développement
	  juste pour des raisons de sécurité apportera
	  également de nombreux changements non
	  désirés.</para>

	<para>Bien que nous tentons de nous assurer que la branche
	  &os.stable; soit compilable et constamment stable, cela
	  ne peut être garanti.  De plus, alors que le code est
	  développé sous &os.current; avant de l'inclure dans
	  &os.stable;, le nombre de personnes utilisant &os.stable;
	  est plus nombreux que celui utilisant &os.current;, aussi
	  il est inévitable que des bogues et des problèmes
	  pourront parfois apparaître sous &os.stable; alors qu'ils
	  n'existaient pas sous &os.current;.</para>

	<para>Pour ces raisons, nous ne recommandons
	  <emphasis>pas</emphasis> de suivre aveuglément
	  &os.stable;, et il est tout particulièrement important que
	  vous ne mettiez pas &agrave; jour des serveurs de production
	  sous &os.stable; sans avoir tout d'abord testé le code
	  dans votre environnement de travail.</para>

	<para>Si vous ne disposez pas des ressources pour faire
	  cela alors nous recommandons que vous utilisiez la version
	  de FreeBSD la plus récente, et que vous utilisiez le
	  mécanisme de mise &agrave; jour binaire pour passer d'une
	  version &agrave; une autre.</para>
      </sect3>

      <sect3>
	<title>Utiliser &os.stable;</title>

	<orderedlist>
	  <listitem>
	    <para>Inscrivez-vous &agrave; &agrave; la liste &a.stable.name;.
	      Vous serez tenu au courant des dépendances de
	      compilation qui peuvent apparaître dans la
	      branche &os.stable;<indexterm><primary>-STABLE</primary><secondary>utilisation</secondary></indexterm> ou de tout autre problème
	      demandant une attention particulière.  Les
	      développeurs publieront également des annonces
	      sur cette liste lorsqu'ils envisagent une correction ou
	      modification controversée, offrant la possibilité
	      aux utilisateurs de répondre s'ils ont des questions
	      &agrave; soulever en rapport avec la modification
	      proposée.</para>

	    <para>Inscrivez-vous &agrave; la liste
	      <application>SVN</application> correspondant &agrave; la
	      branche que vous suivez.  Par exemple, si vous suivez la
	      branche 7-STABLE, inscrivez-vous &agrave; la liste
	      &a.svn-src-stable-7.name;.  Cela vous permettra de lire
	      les courriers de trace des soumissions de toutes les
	      modifications dès qu'elles sont faites et des
	      informations pertinentes sur les éventuels effets
	      de bord.</para>

	    <para>Pour vous inscrire &agrave; ces listes, ou &agrave;
	      une autre, rendez vous &agrave; &a.mailman.lists.link;
	      et cliquez sur la liste &agrave; laquelle vous
	      désirez vous inscrire.  Des instructions sur le
	      reste de la procédure sont alors
	      données.  Si vous êtes
	      intéressé par le suivi des modifications
	      appliquées &agrave; l'ensemble de l'arborescence
	      des sources, nous vous recommandons de vous inscrire
	      &agrave; &a.svn-src-all.name;.</para>
	  </listitem>

	  <listitem>
	    <para>Si vous installez un nouveau système et vous
	      voulez qu'il utilise le dernier instantané
	      publié tous les mois &agrave; partir de la
	      branche &os.stable;, consultez la page sur les <link xlink:href="&url.base;/snapshots/">instantanés</link>
	      pour plus d'information.  D'autre part, vous pouvez
	      installer la version &os.stable; la plus récente
	      &agrave; partir des <link linkend="mirrors">sites
	      miroirs</link> et suivre les instructions ci-dessous
	      pour mettre &agrave; jour votre système avec les
	      sources &os;stable; les plus récentes.</para>

	    <para>Si vous faites tourner une version précédente
	      de &os; et que vous désirez mettre &agrave; jour via
	      les sources vous pouvez aisément le faire &agrave; partir
	      d'un <link linkend="mirrors">site miroir</link> &os;.  Cela
	      peut être fait de deux manières:</para>

	    <orderedlist>
	      <listitem>
		<para>Utilisez le programme <link linkend="cvsup">cvsup</link><indexterm><primary><command>cvsup</command></primary></indexterm>
		  avec le fichier <filename>supfile</filename>
		  nommé <filename>stable-supfile</filename>
		  disponible dans le répertoire <filename>/usr/share/examples/cvsup</filename>.
		  C'est la méthode recommandée, puisqu'elle
		  permet de récupérer la totalité
		  des sources la première fois et par la suite
		  uniquement ce qui a été modifié.
		  De nombreuses personnes exécutent
		  <command>cvsup</command> depuis
		  <command>cron</command><indexterm><primary><command>cron</command></primary></indexterm> et maintiennent ainsi
		  automatiquement &agrave; jour leurs sources.  Vous devez
		  personnaliser l'exemple de <filename>supfile</filename>
		  précédent, et configurer
		  <link linkend="cvsup">cvsup</link><indexterm><primary>-STABLE</primary><secondary>Synchronisation avec <application>CVSup</application></secondary></indexterm> pour
		  votre environnement.</para>
	      </listitem>


	      <listitem>
		<para>Utilisez <application>CTM</application><indexterm><primary>-STABLE</primary><secondary>Synchroniser avec <application>CTM</application></secondary></indexterm>.  Si vous
		  ne disposez pas d'une connexion Internet rapide et
		  peu coûteuse, c'est la méthode que vous
		  devriez penser &agrave; utiliser.</para>
	      </listitem>
	   </orderedlist>
	 </listitem>

	  <listitem>
	    <para>Avant tout, si vous avez besoin d'un accès rapide
	      &agrave; la demande aux sources et que la bande passante n'est
	      pas un problème, utilisez
	      <command>cvsup</command> ou <command>ftp</command>.
	      Sinon, utilisez <application>CTM</application>.</para>
	  </listitem>

	  <listitem>
	    <para>Avant de compiler &os.stable;<indexterm><primary>-STABLE</primary><secondary>compilation</secondary></indexterm>, lisez attentivement
	      le <filename>Makefile</filename> dans
	      <filename>/usr/src</filename>.  Vous devriez au moins
	      la première fois <link linkend="makeworld">installer un nouveau noyau et recompiler le système</link>, comme
	      étape nécessaire &agrave; votre processus de
	      mise &agrave; jour.  La lecture de la &a.stable; et du fichier <filename>/usr/src/UPDATING</filename> vous tiendra
	      au courant des autres procédures de transition qui
	      sont parfois nécessaires lorsque nous préparons la
	      prochaine version.</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="synching">
    <title>Synchroniser vos sources</title>

    <para>Il existe différentes façons d'utiliser une connexion
      Internet (ou le courrier électronique) pour garder &agrave; jour
      les sources de n'importe quelle partie, ou de l'ensemble,
      du projet &os;, selon ce qui vous intéresse.  Les
      principaux services que nous fournissons sont le
      <link linkend="anoncvs">CVS anonyme</link>, <link linkend="cvsup">CVSup</link>, et <link linkend="ctm">CTM</link>.</para>

    <warning>
      <para>Alors qu'il est possible de mettre &agrave; jour seulement
	certaines parties de l'arbre des sources, la seule procédure
	de mise &agrave; jour supportée est celle consistant
	&agrave; mettre &agrave; jour l'intégralité de
	l'arborescence et de recompiler les sources des applicatifs de
	base&mdash;&ldquo;userland&rdquo; (i.e., tous les programmes
	qui tournent dans l'espace utilisateur, comme ceux des
	répertoires <filename>/bin</filename> et
	<filename>/sbin</filename>) et du noyau.  Ne mettre &agrave; jour
	qu'une partie des sources, uniquement le noyau, ou seul le
	&ldquo;userland&rdquo; mènera souvent &agrave; des
	problèmes.  Ces problèmes pourront aller d'erreurs de
	compilation &agrave; des paniques du noyau ou même des
	corruptions de données.</para>
    </warning>

    <indexterm>
      <primary>CVS</primary>
      <secondary>anonyme</secondary>
    </indexterm>

    <para><application>CVS anonyme</application> et
      <application>CVSup</application> utilisent une méthode de
      mise &agrave; jour pilotée par le
      client&mdash;<emphasis>pull</emphasis>.  Dans le cas de
      <application>CVSup</application>, l'utilisateur (ou une
      procédure <command>cron</command>) appelle le programme
      <command>cvsup</command>, qui interagit avec un serveur
      <command>cvsupd</command> distant, pour mettre &agrave; jour vos
      fichiers.  Les mises &agrave; jour que vous recevez sont les plus
      récentes, et vous ne les recevez seulement lorsque vous le
      désirez.  Vous pouvez aisément restreindre vos mises
      &agrave; jour aux fichiers ou répertoires particuliers
      qui vous intéressent.  Les mises &agrave; jour sont
      générées &agrave; la volée par le serveur,
      en fonction de ce que vous avez déj&agrave; et de ce que vous
      voulez.  <application>CVS anonyme</application> est plus
      simpliste que <application>CVSup</application>, car ce n'est
      qu'une extension de <application>CVS</application> qui
      permet de récupérer des modifications directement
      d'une archive CVS distante.  Pour cela,
      <application>CVSup</application> est bien plus efficace mais
      <application>CVS anonyme</application> est plus facile &agrave;
      utiliser.</para>

    <indexterm>
      <primary><application>CTM</application></primary>
    </indexterm>
    <para><application>CTM</application>, &agrave; l'inverse, ne compare
      pas interactivement les sources dont vous disposez avec celles
      qui sont sur l'archive de référence.  Au lieu de cela,
      une procédure qui identifie les modifications intervenues
      depuis qu'elle a été exécutée pour la
      dernière fois, est lancée plusieurs fois par jour
      sur la machine CTM de référence (maître),
      les modifications détectées sont
      compressées, affectées d'un numéro de
      séquence et encodées pour pouvoir être envoyées
      par courrier électronique (en ASCII imprimable uniquement).
      Une fois reçus, ces &ldquo;deltas CTM&rdquo; peuvent
      être passés &agrave; l'utilitaire &man.ctm.rmail.1;
      qui décodera, contrôlera et appliquera automatiquement
      les modifications &agrave; l'exemplaire des sources de l'utilisateur.
      Cette méthode est beaucoup plus efficace que
      <application>CVSup</application> et consomme beaucoup moins de
      ressources sur notre serveur, parce que c'est un modèle
      piloté par le serveur&mdash;<emphasis>push</emphasis>
      plutôt que par
      l'utilisateur&mdash;<emphasis>pull</emphasis>.</para>

    <para>Il y a, bien sûr, quelques contreparties.
      Si vous effacez par inadvertance des parties de votre archive,
      <application>CVSup</application> s'en apercevra et vous
      reconstruira les parties endommagées.
      <application>CTM</application> ne le fera pas, et si vous
      effacez des parties de votre l'arborescence des sources
      (et que vous n'avez pas fait de sauvegarde) alors vous devrez
      repartir de zéro (&agrave; partir du plus récent
      &ldquo;delta de base&rdquo; CVS) et tout reconstituer avec
      <application>CTM</application> ou <application>CVS
      anonyme</application>, effacer les parties endommagées et
      resynchroniser.</para>
  </sect1>

  <sect1 xml:id="makeworld">
    <title>Recompiler le système</title>

    <indexterm>
      <primary>recompiler le système</primary>
    </indexterm>
    <para>Une fois que vous avez synchronisé votre arborescence des
      sources avec une version donnée de &os; (&os.stable;,
      &os.current;, et ainsi de suite) vous pouvez alors utiliser
      cette arborescence des sources pour recompiler le
      système.</para>

    <warning>
      <title>Faites une sauvegarde</title>

      <para>On n'insistera jamais assez sur l'importance de faire une
	sauvegarde de votre système <emphasis>avant</emphasis> tout
	autre chose.  Bien qu'il soit facile de &ldquo;refaire le
	monde&rdquo; (recompiler FreeBSD), si vous suivez ces
	instructions, vous ferez inévitablement des erreurs
	&agrave; un moment ou un autre, ou d'autres feront des erreurs
	au niveau de l'arborescence des sources qui empêcheraient
	votre système de redémarrer.</para>

      <para>Assurez-vous que vous avez bien fait une sauvegarde.  Ayez
	une disquette de maintenance, ou un CD démarrable &agrave; portée de la main.
	Vous ne l'utiliserez probablement pas, mais prudence est mère
	de sûreté!</para>
    </warning>

    <warning>
      <title>S'abonner &agrave; la bonne liste de diffusion</title>

      <indexterm><primary>liste de diffusion</primary></indexterm>
      <para>Les branches &os.stable; et &os.current; sont, par
	nature, <emphasis>en développement</emphasis>.  Les personnes
	qui participent &agrave; &os; sont des humains, et
	des erreurs se produisent occasionnellement.</para>

      <para>Ces erreurs sont parfois bénignes, provocant
	simplement l'affichage d'un nouveau message d'avertissement
	par votre système.  Elles peuvent aussi être
	catastrophiques, et empêcher votre système de
	redémarrer ou détruire vos systèmes de fichiers
	(ou pire).</para>

      <para>Quand de tels problèmes se produisent, un avertissement
	&ldquo;heads up&rdquo; est posté sur la liste de diffusion
	appropriée, décrivant la nature du problème et
	quels systèmes sont concernés.  Un message &ldquo;all
	clear&rdquo; est posté quand le problème est
	résolu.</para>

      <para>Si vous tentez de suivre &os.stable; ou &os.current; et
	que vous ne lisez pas la &a.stable; ou la &a.current;,
	vous allez au devant d'ennuis.</para>
    </warning>

    <warning>
      <title>N'utilisez pas la commande
	<command>make world</command></title>

      <para>De nombreuses anciennes documentations préconisent
	d'utiliser la commande <command>make world</command>.  Cette
	commande n'effectue pas un certain nombre d'étapes
	importantes et ne devrait être utilisée que si
	vous êtes sûr de ce que vous faites.  Dans presque
	tout les cas <command>make world</command> n'est pas une bonne
	chose &agrave; faire, et la procédure décrite
	dans la suite de ce document devrait être
	utilisée &agrave; la place.</para>
    </warning>

    <sect2>
      <title>La méthode générique de mise
	&agrave; jour du système</title>

      <para>Pour mettre &agrave; jour votre système, vous
	devriez consulter <filename>/usr/src/UPDATING</filename> pour
	toute opération préliminaire nécessaire
	en fonction de la version de vos sources et ensuite
	utiliser la procédure suivante:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput>
&prompt.root; <userinput>make installkernel</userinput>
&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <note>
	<para>Dans quelques rares cas, il est nécessaire de
	  lancer un <command>mergemaster -p</command> avant
	  l'étape <buildtarget>buildworld</buildtarget>.  Ces cas
	  sont décrits dans le fichier
	  <filename>UPDATING</filename>.  Généralement,
	  vous pouvez omettre cette opération si vous ne mettez
	  pas &agrave; jour d'une version majeure de &os; &agrave; une
	  autre.</para>
      </note>

      <para>Une fois l'opération
	<buildtarget>installkernel</buildtarget> terminée avec
	succès,
	vous devrez démarrer en mode mono-utilisateur (en
	utilisant par exemple la commande <command>boot -s</command>
	&agrave; l'invite du chargeur).  Exécutez
	ensuite:</para>

      <screen>&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>mergemaster -p</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput>
&prompt.root; <userinput>mergemaster</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <warning>
	<title>Lisez les explications supplémentaires</title>

	<para>La séquence décrite ci-dessus n'est qu'un
	  court résumé pour vous aider &agrave;
	  démarrer.  Vous devriez cependant lire les sections
	  suivantes afin de comprendre clairement chaque étape,
	  tout particulièrement si vous désirez utiliser
	  une configuration du noyau personnalisée.</para>
      </warning>
    </sect2>

    <sect2>
      <title>Lire <filename>/usr/src/UPDATING</filename></title>

      <para>Avant tout autre chose, lisez
	<filename>/usr/src/UPDATING</filename> (ou le fichier
	équivalent en fonction de l'endroit où se trouve vos
	sources).  Ce fichier devrait contenir les informations
	importantes au sujet des problèmes que vous pourriez
	rencontrer, ou indique l'ordre dans lequel vous devriez
	exécuter certaines commandes.  Si le fichier
	<filename>UPDATING</filename> contredit quelque chose d'écrit
	ici, <filename>UPDATING</filename> prime sur tout le
	reste.</para>

      <important>
	<para>La lecture du fichier <filename>UPDATING</filename>
	  n'est pas un substitut &agrave; l'abonnement &agrave; la liste
	  de diffusion correcte, comme décrit
	  précédemment.  Ces deux prérequis sont
	  complémentaires, et non pas exclusifs.</para>
      </important>
    </sect2>

    <sect2>
      <title>Contrôler <filename>/etc/make.conf</filename></title>
      <indexterm>
	<primary><filename>make.conf</filename></primary>
      </indexterm>

      <para>Contrôlez les fichiers
	<filename>/usr/share/examples/etc/make.conf</filename>
	et
	<filename>/etc/make.conf</filename>.  Le premier contient
	des paramètres par défaut &ndash; la plupart
	étant placés en commentaires.  Pour les utiliser quand
	vous recompilez votre système &agrave; partir des sources,
	rajoutés-les au fichier <filename>/etc/make.conf</filename>.
	Gardez &agrave; l'esprit que tout ce que vous ajoutez au fichier
	<filename>/etc/make.conf</filename> est utilisé chaque fois
	que vous invoquez la commande <command>make</command>, il est
	donc bon de s'assurer que les valeurs par défaut sont
	appropriées &agrave; votre système.</para>

      <para>Un utilisateur typique voudra probablement copier
	les lignes <varname>CFLAGS</varname> et
	<varname>NO_PROFILE</varname> se trouvant dans
	<filename>/usr/share/examples/etc/make.conf</filename> vers
	<filename>/etc/make.conf</filename> et les décommenter.</para>

      <para>Examinez les autres définitions
	(<varname>COPTFLAGS</varname>, <varname>NOPORTDOCS</varname>
	et ainsi de suite) et décidez si elles vous conviennent.</para>
    </sect2>

    <sect2>
      <title>Mettre &agrave; jour les fichiers dans <filename>/etc</filename></title>

      <para>Le répertoire <filename>/etc</filename> contient la
	plupart des informations de configuration de votre système,
	ainsi que les procédures de démarrage.  Certaines de ces
	procédures changent d'une version &agrave; l'autre de
	FreeBSD.</para>

      <para>Certains fichiers de configuration sont également
	utilisés en permanence par le système.  En particulier
	<filename>/etc/group</filename>.</para>

      <para>Il est arrivé que la phase d'installation <command>make
	installworld</command> ait besoin que certains utilisateurs et groupes
	existent.  Il y a de fortes chances qu'ils n'aient pas
	été définis avant la mise &agrave; jour.
	C'est une source de problèmes.  Dans certains cas
	<command>make buildworld</command> contrôlera si ces
	utilisateurs ou groupes existent.</para>

      <para>Un exemple de cela fut l'addition de l'utilisateur
	<systemitem class="username">smmsp</systemitem>.  Le processus d'installation
	échouait quand <command>mtree</command> tentait de créer
	<filename>/var/spool/clientmqueue</filename>.</para>

      <para>La solution est d'exécuter
	&man.mergemaster.8; dans le mode pré-&ldquo;buildworld&rdquo;
	en ajoutant l'option <option>-p</option>.  Cela effectuera la
	comparaison uniquement des fichiers essentiels pour le succès
	de la procédure <buildtarget>buildworld</buildtarget> ou
	<buildtarget>installworld</buildtarget>.  Si votre vieille
	version de <command>mergemaster</command> ne supporte pas
	l'option <option>-p</option>, utilisez la nouvelle version
	présente dans l'arborescence des sources quand vous
	l'exécutez pour la première fois:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/usr.sbin/mergemaster</userinput>
&prompt.root; <userinput>./mergemaster.sh -p</userinput></screen>

      <tip>
	<para>Si vous êtes particulièrement paranoïaque,
	  vous pouvez contrôler votre système afin de voir quels
	  fichiers appartiennent au groupe que vous renommez ou
	  effacez:</para>

	<screen>&prompt.root; <userinput>find / -group GID -print</userinput></screen>

	<para>affichera les fichiers appartenant au groupe
	  <replaceable>GID</replaceable> (qui peut être soit un nom de
	  groupe ou un identifiant numérique de groupe).</para>
      </tip>
    </sect2>

    <sect2 xml:id="makeworld-singleuser">
      <title>Passer en mode mono-utilisateur</title>
      <indexterm><primary>mode mono-utilisateur</primary></indexterm>

      <para>Il vaut mieux recompiler le système en mode
	mono-utilisateur.  En dehors du fait que cela sera
	légèrement plus rapide, la réinstallation
	va modifier un grand nombre de fichiers systèmes
	importants, tous les binaires de base du système, les
	bibliothèques, les fichiers d'include et ainsi de suite.
	Les modifier sur un système en fonctionnement (en
	particulier s'il y a des utilisateurs connectés &agrave;
	ce moment l&agrave;), c'est aller au devant de
	problèmes.</para>

      <indexterm><primary>mode multi-utilisateurs</primary></indexterm>
      <para>Une autre méthode consiste &agrave; compiler le
	système en mode multi-utilisateurs, et passer dans le mode
	mono-utilisateur pour l'installation.  Si vous désirez
	utiliser cette méthode, conservez les étapes suivantes
	pour le moment où la compilation sera terminée.  Vous
	pouvez reporter le passage en mode mono-utilisateur jusqu'&agrave;
	l'exécution de
	<buildtarget>installkernel</buildtarget> ou
	<buildtarget>installworld</buildtarget>.</para>

      <para>En tant que super-utilisateur, vous pouvez exécuter la
	commande:</para>

      <screen>&prompt.root; <userinput>shutdown now</userinput></screen>

      <para>sur un système en fonctionnement, pour passer en mode
	mono-utilisateur.</para>

      <para>Ou bien, redémarrer le système, et &agrave;
	l'invite de démarrage, sélectionnez l'option
	<quote>single user</quote>.  Le système démarrera alors
	en mode mono-utilisateur.  A l'invite de l'interpréteur de
	commandes, exécutez alors:</para>

      <screen>&prompt.root; <userinput>fsck -p</userinput>
&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

      <para>Cela effectue une vérification des systèmes
	de fichiers, remonte <filename>/</filename> en mode
	lecture/écriture, et monte tous les autres systèmes
	de fichiers UFS listés dans le fichier
	<filename>/etc/fstab</filename>, puis active la
	pagination.</para>

      <note>
	<para>Si votre horloge CMOS est réglée sur l'heure locale
	  et non pas sur le fuseau GMT (cela est vrai si la sortie
	  de la commande <command>date</command> ne donne pas l'heure
	  et le fuseau correct), vous aurez également peut-être
	  besoin d'exécuter la commande suivante:</para>

<screen>&prompt.root; <userinput>adjkerntz -i</userinput></screen>

	<para>Cela permettra de s'assurer que vos paramètres
	  de fuseaux horaires sont correctement configurés &mdash;
	  sans cela, vous risquez de faire face, plus tard, &agrave; des
	  problèmes.
	</para>
      </note>

    </sect2>

    <sect2>
      <title>Effacer <filename>/usr/obj</filename></title>

      <para>Au fur et &agrave; mesure que les différentes parties
	du système sont recompilées, elles sont
	placées dans des répertoires qui (par défaut) sont
	sous <filename>/usr/obj</filename>.  Les répertoires sont
	agencés comme sous <filename>/usr/src</filename>.</para>

      <para>Vous pouvez accélérer le processus <command>make
	buildworld</command>, et également vous éviter d'éventuels
	problèmes de dépendances en effaçant ce
	répertoire.</para>

      <para>Certains fichiers dans <filename>/usr/obj</filename>
	peuvent avoir l'indicateur immuable positionné (consultez la
	page de manuel &man.chflags.1; pour plus d'informations)
	qui doit être retiré en premier.</para>

      <screen>&prompt.root; <userinput>cd /usr/obj</userinput>
&prompt.root; <userinput>chflags -R noschg *</userinput>
&prompt.root; <userinput>rm -rf *</userinput></screen>
    </sect2>

    <sect2 xml:id="updating-upgrading-compilebase">
      <title>Recompiler le système de base</title>

      <sect3>
	<title>Enregistrer la sortie</title>

	<para>C'est une bonne idée d'enregistrer la sortie de
	  &man.make.1; dans un fichier.  Si quelque chose se passe
	  mal, vous aurez une trace des messages d'erreur.  Même
	  si cela ne vous aide pas &agrave; diagnostiquer ce qui n'a pas
	  fonctionné, cela peut aider les autres si vous postez
	  votre problème sur une des listes de diffusion de
	  &os;.</para>

	<para>La méthode la plus aisée pour faire cela est
	  d'utiliser la commande &man.script.1;, avec en paramètre
	  le nom du fichier où enregistrer les résultats.
	  Vous devez faire cela immédiatement juste avant de
	  recompiler le système, et taper <userinput>exit</userinput>
	  une fois que c'est terminé.</para>

	<screen>&prompt.root; <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out
&prompt.root; <userinput>make TARGET</userinput>
<emphasis>&hellip; compile, compile, compile &hellip;</emphasis>
&prompt.root; <userinput>exit</userinput>
Script done, &hellip;</screen>

	<para>Si vous le faites, <emphasis>n'enregistrez pas</emphasis>
	  le résultat dans <filename>/tmp</filename>.
	  Ce répertoire peut être vidé au prochain
	  redémarrage du système.  Un meilleur endroit de
	  sauvegarde est <filename>/var/tmp</filename> (comme dans l'exemple
	  précédent) ou dans le répertoire utilisateur
	  de <systemitem class="username">root</systemitem>.</para>
      </sect3>

      <sect3 xml:id="make-buildworld">
	<title>Compiler le nouveau système</title>

	<para>Vous devez être dans le répertoire
	  <filename>/usr/src</filename>:</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>

	<para>(&agrave; moins, bien sûr, que votre code source ne
	  soit ailleurs, auquel cas vous devrez aller dans le
	  répertoire correspondant).</para>
	<indexterm><primary><command>make</command></primary></indexterm>

	<para>Pour recompiler le système, on utilise la commande
	  &man.make.1;.  Cette commande lit ses instructions dans
	  le fichier <filename>Makefile</filename>, qui décrit comment
	  devraient être reconstruits les programmes qui constituent
	  &os;, dans quel ordre, et ainsi de suite.</para>

	<para>Le format général de la ligne de commande que
	  vous taperez sera la suivante:</para>

	<screen>&prompt.root; <userinput>make -x -DVARIABLE cible</userinput></screen>

	<para>Dans cet exemple,
	  <option>-<replaceable>x</replaceable></option> est une
	  option que vous passez &agrave; &man.make.1;.  Reportez-vous
	  &agrave; la page de manuel pour un exemple d'options que vous
	  pouvez passer.</para>

	<para><option>-D<replaceable>VARIABLE</replaceable></option>
	  transmet un variable au fichier
	  <filename>Makefile</filename>.  Le comportement du
	  <filename>Makefile</filename> est défini par ces variables.
	  Ce sont les mêmes variables que l'on trouve dans
	  <filename>/etc/make.conf</filename>, et c'est un autre moyen
	  de les positionner.</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE cible</userinput></screen>

	<para>est une autre manière de dire qu'il ne faut pas compiler
	  les bibliothèques profilées et correspond &agrave;
	  la ligne:</para>

	<programlisting>NO_PROFILE=    true	#    Avoid compiling profiled libraries</programlisting>

	<para>dans <filename>/etc/make.conf</filename>.</para>

	<para><replaceable>cible</replaceable> indique &agrave; &man.make.1;
	  ce que vous voulez faire.  Chaque
	  <filename>Makefile</filename> définit un certain nombre de
	  &ldquo;cibles&rdquo;, et votre choix de cible détermine ce
	  qui se passe.</para>

	<para>Certaines cibles listées dans le fichier
	  <filename>Makefile</filename>, ne doivent pas être
	  employées.  Ce sont des étapes intermédiaires
	  utilisées par le processus de recompilation pour
	  décomposer les étapes importantes de la recompilation
	  du système en sous-étapes.</para>

	<para>La plupart du temps, vous n'aurez pas besoin de passer
	  de paramètres &agrave; &man.make.1;, et votre commande
	  ressemblera &agrave; ceci:</para>

	<screen>&prompt.root; <userinput>make cible</userinput></screen>

	<para>Où <replaceable>cible</replaceable> sera une des
	  nombreuses options de compilation.  La première cible
	  devrait toujours être
	  <varname>buildworld</varname>.</para>

	<para>Comme leurs noms l'indiquent,
	  <buildtarget>buildworld</buildtarget> reconstruit la nouvelle
	  arborescence dans <filename>/usr/obj</filename>, et
	  <buildtarget>installworld</buildtarget>, une autre cible, l'installe sur la
	  machine.</para>

	<para>Disposer d'options séparées est très utile pour deux raisons.  Tout d'abord
	  cela vous permet de recompiler en toute sûreté en sachant
	  qu'aucun composant du système actuel ne sera affecté.
	  La compilation est &ldquo;autonome&rdquo;.  En raison de
	  cela vous pouvez exécuter
	  <buildtarget>buildworld</buildtarget> sur une machine en mode
	  multi-utilisateurs sans redouter d'effets fâcheux.  Il est
	  néanmoins recommandé de toujours exécuter
	  l'étape <buildtarget>installworld</buildtarget> en mode
	  mono-utilisateur.</para>

	<para>En second lieu, cela vous permet d'utiliser des
	  systèmes montés par NFS pour mettre &agrave;
	  jour plusieurs machines de votre réseau.  Si vous avez
	  trois machines <systemitem>A</systemitem>, <systemitem>B</systemitem> et
	  <systemitem>C</systemitem> que vous voulez mettre &agrave; jour,
	  exécutez <command>make buildworld</command> et
	  <command>make installworld</command> sur <systemitem>A</systemitem>.
	  <systemitem>B</systemitem> et <systemitem>C</systemitem> doivent
	  ensuite monter par NFS <filename>/usr/src</filename>
	  et <filename>/usr/obj</filename> depuis <systemitem>A</systemitem>,
	  et vous pouvez alors exécuter
	  <command>make installworld</command> pour installer le
	  système recompilé sur <systemitem>B</systemitem> et
	  <systemitem>C</systemitem>.</para>

	<para>Bien que la cible <buildtarget>world</buildtarget> existe
	  toujours, vous êtes fortement encouragé
	  &agrave; ne pas l'utiliser.</para>

	<para>Exécutez:</para>

	<screen>&prompt.root; <userinput>make buildworld</userinput></screen>

	<para>Il est possible de passer l'option
	  <option>-j</option> &agrave; &man.make.1; ce qui lui permettra
	  d'exécuter plusieurs processus simultanément.
	  C'est particulièrement utile sur une machine avec plusieurs
	  processeurs.  Cependant, comme la compilation est plus
	  gourmande en E/S plutôt qu'en CPU, c'est également
	  utile sur des machines mono-processeur.</para>

	<para>Typiquement sur une machine mono-processeur, vous
	  exécuteriez:</para>

	  <screen>&prompt.root; <userinput>make -j4 buildworld</userinput></screen>

	<para>&man.make.1; pourra exécuter jusqu'&agrave; 4 processus
	  simultanément.  Des constatations empiriques
	  postées sur les listes de diffusion montrent que c'est
	  en général ce qui apporte le plus de gain en
	  performances.</para>

	<para>Si vous avez une machine multi-processeurs et que vous
	  avez configuré un noyau SMP, essayez des valeurs entre 6 et
	  19 et voyez quel bénéfice vous en tirez.</para>
      </sect3>

      <sect3>
	<title>Durée</title>
	<indexterm>
	  <primary>compilation du système</primary>
	  <secondary>durée</secondary>
	</indexterm>

        <para>De nombreux facteurs influencent la durée de
	  compilation, mais les machines récentes devraient
	  mettrent seulement de une &agrave; deux heures
	  pour compiler l'arborescence &os.stable;,
	  sans modification ni raccourcis durant le processus.
	  Une arborescence &os.current; nécessitera un peu plus de
	  temps.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Compiler et installer un nouveau noyau</title>
      <indexterm>
	<primary>noyau</primary>
	<secondary>compilation</secondary>
      </indexterm>

      <para>Pour tirer pleinement parti de votre nouveau système,
	vous devrez recompiler le noyau.  C'est pratiquement
	indispensable, parce que certaines structures mémoires
	peuvent avoir changées, et des programmes comme &man.ps.1;
	et &man.top.1; ne fonctionneront pas tant que le système
	et le noyau n'utilisent pas les mêmes versions de code
	source.</para>

      <para>La manière la plus simple et la plus sûre est de
	compiler et installer un noyau basé sur le noyau
	<filename>GENERIC</filename>.  Alors que le noyau
	<filename>GENERIC</filename> peut ne pas comporter les pilotes
	de périphériques nécessaires pour votre
	système, il devrait contenir tout ce qui est
	nécessaire pour faire démarrer votre système
	en mode mono-utilisateur.  C'est une bonne façon de tester
	le fonctionnement de votre nouveau système.  Après
	avoir démarré &agrave; partir du noyau
	<filename>GENERIC</filename> et vérifié que
	votre système fonctionne vous pouvez alors compiler un nouveau
	noyau basé sur votre fichier de configuration normal du
	noyau.</para>

      <para>Sur &os;, il est important
	de <link linkend="make-buildworld">recompiler le
	système</link> avant de compiler un nouveau
	noyau.</para>

      <note>
	<para>Si vous désirez compiler un noyau personnalisé,
	  et que vous avez déj&agrave; un fichier de
	  configuration, utilisez juste
	  <buildtarget>KERNCONF=<replaceable>MONNOYAU</replaceable></buildtarget>
	  comme suit:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildkernel KERNCONF=MONNOYAU</userinput>
&prompt.root; <userinput>make installkernel KERNCONF=MONNOYAU</userinput></screen>
      </note>

      <para>Notez que si vous avez augmenté la variable
	<literal>kern.securelevel</literal> &agrave; une valeur
	supérieure &agrave; 1 <emphasis>et</emphasis> que vous
	avez positionné l'indicateur <literal>noschg</literal>
	ou similaire sur votre noyau, il sera intéressant de passer
	en mode mono-utilisateur pour utiliser
	<buildtarget>installkernel</buildtarget>.  Sinon vous devriez
	être en mesure d'exécuter ces commandes &agrave;
	partir du mode multi-utilisateur sans problèmes.  Voir
	la page de manuel de &man.init.8; pour plus de détails
	&agrave; propos de <literal>kern.securelevel</literal> et la page
	&man.chflags.1; pour des informations sur les différents
	indicateurs de fichiers.</para>
    </sect2>

    <sect2>
      <title>Redémarrer en mode mono-utilisateur</title>
      <indexterm><primary>mode mono-utilisateur</primary></indexterm>

      <para>Vous devriez redémarrer en mode mono-utilisateur pour
	tester le fonctionnement du nouveau noyau.  Pour cela suivez
	les instructions de
	<xref linkend="makeworld-singleuser"/>.</para>
    </sect2>

    <sect2 xml:id="make-installworld">
      <title>Installer les nouveaux binaires système</title>

      <para>Si vous avez compilé une version de &os; assez
	récente pour avoir utilisé
	<command>make buildworld</command> alors vous devriez
	utiliser maintenant <buildtarget>installworld</buildtarget>
	pour installer les nouveaux binaires système.</para>

      <para>Lancez:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput></screen>

      <note>
	<para>Si vous spécifiez des variables sur la
	  ligne de commande de <command>make buildworld</command>,
	  vous devez utiliser les mêmes variables avec la commande
	  <command>make installworld</command>.  Cela ne reste
	  pas forcément vrai pour d'autres options; par exemple,
	  <option>-j</option> ne doit jamais être utilisée
	  avec <buildtarget>installworld</buildtarget>.</para>

	<para>Par exemple, si vous exécutez:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE buildworld</userinput></screen>

	<para>vous devrez ensuite installer les résultats avec:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE installworld</userinput></screen>

	<para>sinon il essayera d'installer les bibliothèques
	  profilées qui n'ont pas été
	  recompilées &agrave; l'étape
	  <command>make buildworld</command>.</para>
      </note>
    </sect2>

    <sect2>
      <title>Mettre &agrave; jour les fichiers non modifiés par
	<command>make installworld</command></title>

      <para>La recompilation du système ne mettra pas &agrave;
	jour certains répertoires (en particulier,
	<filename>/etc</filename>, <filename>/var</filename> et
	<filename>/usr</filename>) avec les fichiers nouveaux
	ou modifiés.</para>

      <para>La manière la plus simple de mettre &agrave; jour
	ces fichiers est d'utiliser &man.mergemaster.8;, bien
	qu'il soit possible de le faire manuellement si vous le
	désirez.  Indépendamment de la manière
	que vous choisissez, assurez-vous de faire une sauvegarde
	du répertoire <filename>/etc</filename> au cas
	où quelque chose se passerait mal.</para>

    <sect3 xml:id="mergemaster">
      <info><title><command>mergemaster</command></title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Contribution de </contrib></author>
	</authorgroup>
      </info>
	
	<indexterm><primary><command>mergemaster</command></primary></indexterm>

      <para>L'utilitaire &man.mergemaster.8; est une procédure Bourne
	qui vous aidera &agrave; déterminer les différences entre
	vos fichiers de configuration dans le répertoire
	<filename>/etc</filename>, et les fichiers de configuration
	dans l'arborescence des sources
	<filename>/usr/src/etc</filename>.  C'est la solution
	recommandée pour maintenir &agrave; jour les fichiers de
	configuration du système avec ceux situés
	dans l'arborescence des sources.</para>

      <para>Pour commencer, tapez simplement
	<command>mergemaster</command> &agrave; l'invite, et observez-le
	travailler.  <command>mergemaster</command> commencera &agrave;
	constituer une arborescence temporaire, &agrave; partir de
	<filename>/</filename>, et la remplira avec divers fichiers
	de configuration.  Ces fichiers sont alors comparés avec
	ceux actuellement installés sur votre système.
	A ce point, les fichiers qui diffèrent seront
	affichés dans le format &man.diff.1;, avec le signe
	<option>+</option> représentant les lignes modifiées
	ou ajoutées, et le <option>-</option> représentant
	les lignes qui seront soit complètement supprimées,
	soit remplacées avec une nouvelle ligne.
	Voir la page de manuel &man.diff.1; pour plus d'informations
	au sujet de la syntaxe &man.diff.1; et comment sont affichées
	les différences.</para>

      <para>&man.mergemaster.8; vous affichera ensuite chaque fichier
	présentant des différences, et vous aurez
	&agrave; ce moment-l&agrave; le choix de soit supprimer le
	nouveau fichier (le fichier temporaire), soit d'installer
	le fichier temporaire non modifié, soit de fusionner
	le fichier temporaire et le fichier actuellement installé,
	soit enfin de revoir les résultats de l'opération
	&man.diff.1;.</para>

      <para>Choisir de supprimer le fichier temporaire indiquera &agrave;
	&man.mergemaster.8; que nous désirons conserver notre
	fichier actuel intacte, et effacera la nouvelle version.
	Cette option n'est pas recommandée, &agrave; moins
	que vous ne voyez aucune raison de modifier le fichier actuel.
	Vous pouvez obtenir de l'aide &agrave; n'importe quel moment en
	tapant <keycap>?</keycap> &agrave; l'invite de &man.mergemaster.8;.
	Si l'utilisateur choisit de passer un fichier, il sera
	présenté &agrave; nouveau une fois que tous les
	autres fichiers auront été traités.</para>

      <para>Choisir d'installer un fichier temporaire intact
	remplacera le fichier actuel avec le nouveau.  Pour la plupart
	des fichiers non modifiées, c'est la meilleure option.</para>

      <para>Choisir de fusionner le fichier, vous affichera un éditeur
	de texte, et le contenu des deux fichiers.  Vous pouvez
	maintenant les fusionner en les visionnant côte
	&agrave; côte sur l'écran, et en sélectionnant
	des parties des deux fichiers pour créer un fichier final.
	Quand les fichiers sont comparés côte &agrave;
	côte, la touche <keycap>l</keycap> sélectionnera le
	contenu de gauche et la touche <keycap>r</keycap>
	sélectionnera celui de droite.
	Le résultat final sera un fichier constitué des deux
	parties, qui peut alors être installé.
	Cette option est habituellement utilisée pour les fichiers
	où les des paramètres ont été
	modifiés par l'utilisateur.</para>

      <para>Choisir de revoir les résultats de l'opération
	&man.diff.1; vous affichera les différences entre fichiers
	tout comme la fait &man.mergemaster.8; avant de vous demander
	un choix.</para>

      <para>Après que &man.mergemaster.8; en ait terminé avec
	les fichiers système, il vous proposera de nouvelles
	opérations.  &man.mergemaster.8; vous demandera si vous
	désirez reconstruire le fichier des mots de passe
	et terminera en vous proposant
	de supprimer les fichiers temporaires
	restants.</para>
      </sect3>

      <sect3>
	<title>Mise &agrave; jour manuelle</title>

      <para>Si vous désirez faire la mise &agrave; jour manuellement,
	vous ne pouvez cependant pas vous contenter de copier
	les fichiers de <filename>/usr/src/etc</filename> dans
	<filename>/etc</filename> pour que cela fonctionne.  Certains
	de ces fichiers doivent d'abord être
	&ldquo;installés&rdquo;.
	En effet le répertoire <filename>/usr/src/etc</filename>
	&ldquo;n'est pas&rdquo; une copie de ce que devrait contenir
	votre répertoire <filename>/etc</filename>.  De plus,
	il a des fichiers qui doivent être dans
	<filename>/etc</filename> et qui ne sont pas dans
	<filename>/usr/src/etc</filename>.</para>

      <para>Si vous utilisez &man.mergemaster.8; (comme recommandé),
	vous pouvez passer cette section et aller directement &agrave;
	la <link linkend="updating-upgrading-rebooting">section
	suivante</link>.</para>

      <para>La façon la plus simple de procéder est
	d'installer les fichiers dans un nouveau répertoire, puis de
	passer en revue les différences.</para>

      <warning>
	<title>Sauvegardez votre répertoire
	  <filename>/etc</filename> actuel</title>

	<para>Bien qu'en principe rien ne sera modifié automatiquement
	  dans ce répertoire, prudence est mère de
	  sûreté.  Copiez donc votre répertoire
	  <filename>/etc</filename> dans un endroit sûr.  Quelque
	  chose du genre:</para>

	<screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

	<para>conviendra; l'option <option>-R</option> fait une copie
	  récursive, <option>-p</option> préserve la date, les
	  autorisations des fichiers et ainsi de suite.</para>
      </warning>

      <para>Vous devez créer un ensemble de répertoires
	provisoires pour y installer les fichiers du répertoire <filename>/etc</filename>
	et autres.  <filename>/var/tmp/root</filename> est un bon
	choix, il y a un certain nombre de sous-répertoires
	&agrave; créer également:</para>

      <screen>&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>

      <para>Cela va créer l'arborescence nécessaire et y
	installera les fichiers.  Un grand nombre des
	sous-répertoires créés dans
	<filename>/var/tmp/root</filename>
	sont vides et devront être supprimés.
	La façon la plus simple de le faire est:</para>

      <screen>&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d . -type d | xargs rmdir 2&gt;/dev/null</userinput></screen>

      <para>Ceci supprimera tous les répertoires vides (la sortie
	d'erreur standard est redirigée vers
	<filename>/dev/null</filename> pour empêcher les
	avertissements &agrave; propos des répertoires non
	vides).</para>

      <para><filename>/var/tmp/root</filename> contient maintenant
	tous les fichiers &agrave; installer &agrave; l'endroit requis sous
	<filename>/</filename>.  Vous devez maintenant examiner chacun
	de ces fichiers pour déterminer en quoi ils diffèrent
	de vos propres fichiers.</para>

      <para>Notez que certains des fichiers qui seront installés
	dans <filename>/var/tmp/root</filename> commencent par un
	&ldquo;.&rdquo;.  Au moment où sont écrites ces
	lignes, les seuls fichiers concernés sont les fichiers
	d'initialisation des interpréteurs de commandes dans
	<filename>/var/tmp/root/</filename> et
	<filename>/var/tmp/root/root/</filename>, mais il pourrait y
	en avoir d'autres (cela dépend de quand vous lirez ces
	lignes).  Assurez-vous d'utiliser la commande <command>ls
	-a</command> pour ne pas les oublier.</para>

      <para>La manière la plus simple de procéder est
	d'utiliser la commande &man.diff.1; pour comparer les deux
	fichiers:</para>

      <screen>&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>

      <para>Cela vous indiquera les différences entre votre fichier
	<filename>/etc/shells</filename> et le nouveau fichier
	<filename>/var/tmp/root//etc/shells</filename>.  A partir de
	l&agrave;, décidez si vous aller reporter les modifications
	que vous y avez apportée ou si vous allez simplement
	recopier le nouveau fichier.</para>

      <tip>
	<title>Donnez au nouveau répertoire racine
	  (<filename>/var/tmp/root</filename>) un nom qui inclue une
	  date, pour pouvoir facilement comparer les différentes
	  versions</title>

	<para>Si vous recompilez fréquemment votre système,
	  cela signifie que vous devez également souvent
	  mettre &agrave; jour le répertoire <filename>/etc</filename>,
	  ce qui peut rapidement devenir une corvée.</para>

	<para>Vous pouvez accélérer le processus en
	  conservant une copie du dernier ensemble de fichiers
	  modifiés que vous avez reportés dans
	  <filename>/etc</filename>.  La procédure suivante
	  présente une façon de faire.</para>

	<procedure>
	  <step>
	    <para>Recompilez le système comme &agrave;
	      l'accoutumé.  Au moment de mettre &agrave; jour
	      <filename>/etc</filename> et les autre répertoires,
	      donnez au répertoire cible un nom basé sur la
	      date du jour.  Si vous faisiez cela le 14 février
	      1998, vous pourriez procéder comme suit:</para>

	    <screen>&prompt.root; <userinput>mkdir /var/tmp/root-19980214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-19980214 \
    distrib-dirs distribution</userinput></screen>
	  </step>

	  <step>
	    <para>Reporter les modifications depuis ce répertoire
	      comme décrit plus haut.</para>

	    <para><emphasis>Ne supprimez pas</emphasis> le
	      répertoire <filename>/var/tmp/root-19980214</filename>
	      quand vous aurez terminé.</para>
	  </step>

	  <step>
	    <para>Quand vous récupérez la dernière
	      version des sources et la recompilerez, suivez l'étape
	      1.  Vous aurez alors un nouveau répertoire, qui
	      pourrait s'appeler <filename>/var/tmp/root-19980221</filename>
	      (si vous faites une mise &agrave; jour chaque semaine).</para>
	  </step>

	  <step>
	    <para>Vous pouvez maintenant voir les modifications
	      intervenues d'une semaine &agrave; l'autre en utilisant
	      &man.diff.1; pour afficher les différences entre tous
	      les fichiers deux répertoires:</para>

	    <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-19980214 root-19980221</userinput></screen>

	    <para>Généralement, il y aura beaucoup moins de
	      différences qu'entre
	      <filename>/var/tmp/root-19980221/etc</filename> et
	      <filename>/etc</filename>.  Comme il y a beaucoup
	      moins de différences, il est beaucoup plus facile
	      de les reporter dans le répertoire
	      <filename>/etc</filename>.</para>
	  </step>

	  <step>
	    <para>Vous pouvez maintenant supprimer le plus ancien
	      des deux répertoires
	      <filename>/var/tmp/root-*</filename>:</para>

	    <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-19980214</userinput></screen>
	  </step>

	  <step>
	    <para>Répétez l'opération chaque fois que vous devez
	      reporter des modifications dans
	      <filename>/etc</filename>.</para>
	  </step>
	</procedure>

	<para>Vous pouvez utiliser &man.date.1; pour automatiser la
	  génération des noms de répertoires:</para>

	<screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
      </tip>
      </sect3>
    </sect2>

    <sect2 xml:id="updating-upgrading-rebooting">
      <title>Redémarrer</title>

      <para>Vous en avez terminé.  Après avoir
	vérifié que tout semble être en place, vous
	pouvez alors redémarrez votre système.  Un simple
	&man.shutdown.8; devrait suffire:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>
    </sect2>

    <sect2>
      <title>C'est fini</title>

      <para>Vous devriez maintenant avoir mis &agrave; jour avec
	succès votre système &os;.  Félicitations.</para>

      <para>Si les choses se sont légèrement mal
	passées, il est facile de recompiler un élément
	particulier du système.  Par exemple, si vous avez
	accidentellement effacé <filename>/etc/magic</filename>
	lors de la mise &agrave; jour de <filename>/etc</filename>, la
	commande &man.file.1; ne fonctionnerait plus.  Dans ce cas,
	la solution serait d'exécuter:</para>

	<screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2>
      <title>Questions</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>Dois-je refaire le monde &agrave; chaque
	      évolution?</para>
	  </question>

	  <answer>
	    <para>Il n'y a pas de réponse toute faite &agrave;
	      cette question, tout dépend de la nature des
	      évolutions.  Par exemple, si vous venez juste
	      d'exécuter <application>CVSup</application>, et que
	      les fichiers suivants on été mis &agrave;
	      jour:</para>

	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

	    <para>cela ne vaut probablement pas la peine de recompiler
	      tout le système.  Vous pouvez tout simplement aller dans
	      les sous-répertoires appropriés,
	      exécuter <command>make all install</command>, et
	      c'est &agrave; peu près tout.  Mais s'il y a des
	      évolutions importantes, par exemple sur
	      <filename>src/lib/libc/stdlib</filename> alors vous
	      devrez soit refaire le monde, ou recompiler au moins
	      toutes les parties du système qui sont liées
	      statiquement (de même que tout ce vous pourriez
	      avoir ajouté qui y serait lié statiquement).</para>

	    <para>C'est &agrave; vous de voir.  Vous préférerez
	      peut-être recompiler votre système tous les
	      quinze jours, et laisser les modifications s'empiler
	      pendant quinze jours.  Ou bien vous préférerez
	      ne recompiler que ce qui a changé et vous faire
	      confiance pour tout ce qui en dépend.</para>

	    <para>Et, bien sûr, cela dépend de la
	      fréquence avec laquelle vous voulez faire vos mises
	      &agrave; jour, et de si vous suivez la branche &os.stable;
	      ou &os.current;.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Ma compilation échoue avec de nombreuses erreurs
	      &ldquo;signal 11&rdquo;<indexterm>
	      <primary>signal 11</primary></indexterm> (ou tout
	      autre numéro de signal).  Que s'est-il passé?</para>
	  </question>

	  <answer>
	    <para>Cela indique généralement un problème
	      matériel.  (Re)compiler le système est un bon
	      moyen de mettre votre matériel sous pression, et
	      mettra souvent en évidence des défaillances
	      de la mémoire vive.  Elles se manifestent normalement
	      d'elles-mêmes, la compilation échouant
	      lors de la réception de mystérieux signaux.</para>

	    <para>Un bon indicateur de cet état de fait, est que
	      vous pouvez relancer la compilation et qu'elle échouera
	      en un endroit différent.</para>

	    <para>Dans ce cas, vous ne pouvez guère faire autre chose
	      que d'intervertir les différents composants de votre
	      matériel pour déterminer lequel est en cause.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Puis-je effacer <filename>/usr/obj</filename> après
	      avoir fini?</para>
	  </question>

	  <answer>
	    <para>Une réponse courte est oui.</para>

	    <para><filename>/usr/obj</filename> contient tous les
	      fichiers objets générés &agrave; la
	      compilation.  Normalement, une des premières
	      étapes de <command>make buildworld</command> est de supprimer ce
	      répertoire et de repartir &agrave; zéro.
	      Dans ce cas, conserver le répertoire
	      <filename>/usr/obj</filename> après avoir terminé ne
	      sert pas &agrave; grand chose, alors que vous
	      économiseriez pas mal d'espace disque (actuellement
	      environ 340&nbsp;MO).</para>

	    <para>Cependant, si vous savez ce que vous faites, vous
	      pouvez faire en sorte que <command>make buildworld</command>
	      saute cette étape.  Cela rendra les compilations
	      ultérieures plus rapides, puisque la plupart des sources
	      n'auront pas besoin d'être recompilées.
	      Le revers de la médaille est que des problèmes
	      subtils de dépendance peuvent se manifester, provoquant
	      l'échec de votre compilation de manière
	      étrange.  Cela génère fréquemment
	      du bruit sur les listes de diffusion de &os;, quand quelqu'un se
	      plaint que sa mise &agrave; jour a échoué, sans
	      réaliser que c'est parce qu'il a tenté de
	      brûler les étapes.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Une recompilation interrompue peut-elle être
	      reprise?</para>
	  </question>

	  <answer>
	    <para>Tout dépend de jusqu'où vous êtes
	      aller avant de rencontrer un problème.</para>

	    <para><emphasis>En général</emphasis> (et ceci n'est
	      pas une règle absolue) <command>make buildworld</command>
	      crée de nouveaux exemplaires des outils indispensables
	      (comme &man.gcc.1; et &man.make.1;) et des bibliothèques
	      système.  Ces outils et bibliothèques sont
	      ensuite installés.  Puis ils sont utilisés pour
	      se reconstruire eux-mêmes, et installés de nouveau.
	      L'intégralité du système (y compris
	      maintenant les programmes utilisateurs classiques, comme
	      &man.ls.1; ou &man.grep.1;) est alors recompilé avec
	      les nouveaux fichiers système.</para>

	    <para>Si vous êtes &agrave; cette dernière
	      étape, et que vous le savez (parce que vous avez
	      consulté les résultats que vous avez
	      enregistrés) alors vous pouvez (sans trop de risque)
	      faire:</para>

	    <screen><emphasis>&hellip; fix the problem &hellip;</emphasis>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNO_CLEAN all</userinput></screen>

	    <para>Cela ne détruira pas les résultats du
	      travail qu'&agrave; déj&agrave; effectué <command>make
	      buildworld</command>.</para>

	    <para>Si vous voyez le message:</para>

	      <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

	    <para>dans les comptes-rendus de <command>make buildworld</command>
	      alors cette façon de procéder est probablement
	      bonne.</para>

	    <para>Si vous ne voyez pas ce message, ou que vous doutez
	      de vous, alors prudence est mère de sûreté,
	      et il vaut mieux tout reprendre depuis le début.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Comment puis-je accélérer la compilation
	      du système?</para>
          </question>

          <answer>
	    <itemizedlist>
	      <listitem>
		<para>Passez en mode mono-utilisateur.</para>
	      </listitem>

	      <listitem>
		<para>Mettez les répertoires
		  <filename>/usr/src</filename> et
		  <filename>/usr/obj</filename> sur des systèmes de
		  fichiers et des disques différents.  Si possible,
		  installez ces disques sur des contrôleurs
		  différents.</para>
	      </listitem>

	      <listitem>
		<para>Encore mieux, mettez ces systèmes de fichiers
		  sur plusieurs disques utilisant le système
		  &man.ccd.4; (pilote de disques
		  concaténés).</para>
	      </listitem>

	      <listitem>
		<para>Ne compilez pas les bibliothèques profilées
		  (mettez &ldquo;NO_PROFILE=true&rdquo; dans le fichier
		  <filename>/etc/make.conf</filename>).  Vous n'en
		  avez certainement pas besoin.</para>
	      </listitem>

	      <listitem>
		<para>Egalement dans <filename>/etc/make.conf</filename>,
		  positionnez <varname>CFLAGS</varname> &agrave; quelque
		  chose comme <option>-O -pipe</option>.
		  L'optimisation <option>-O2</option> est bien plus
		  lente, et la différence d'optimisation entre
		  <option>-O</option> et <option>-O2</option> est en
		  général négligeable.
		  <option>-pipe</option> demande au compilateur d'utiliser
		  des tuyaux &agrave; la place de fichiers temporaires, ce
		  qui économise des accès disque (mais
		  utilise plus de mémoire).</para>
	      </listitem>

	      <listitem>
		<para>Passez l'option
		  <option>-j<replaceable>n</replaceable></option>
		  &agrave; &man.make.1; pour permettre l'exécution de
		  plusieurs processus en parallèle.  Cela
		  améliore généralement les choses, que
		  vous ayez une machine mono- ou multi-processeurs.</para>
	      </listitem>

	      <listitem>
		<para>Le système de fichiers qui contient
		  <filename>/usr/src</filename> peut être monté
		  (ou remonté) avec l'option <option>noatime</option>.
		  Cela empêche l'enregistrement des dates d'accès
		  aux fichiers par le système de fichiers.  Vous
		  n'avez de toute façon probablement pas besoin de cette
		  information.</para>

		  <screen>&prompt.root; <userinput>mount -u -o noatime /usr/src</userinput></screen>

		  <warning>
		    <para>Cet exemple suppose que
		      <filename>/usr/src</filename> constitue &agrave; lui
		      seul un système de fichiers.  Si ce n'est pas
		      le cas (s'il fait partie de
		      <filename>/usr</filename> par exemple) vous
		      devez alors indiquer le point de montage de ce
		      système de fichiers, et non
		      <filename>/usr/src</filename>.</para>
		  </warning>
	      </listitem>

	      <listitem>
		<para>Le système de fichiers où se trouve
		  <filename>/usr/obj</filename> peut être
		  monté (ou remonté) avec l'option
		  <option>async</option>.  Les écritures sur le
		  disque se feront alors de façon asynchrone.  En
		  d'autres termes, le programme reprend immédiatement
		  la main, et l'écriture des données sur le
		  disque se fait quelques secondes plus tard.  Cela
		  permet le groupement des écritures sur le disque,
		  et le gain en performance peut être
		  spectaculaire.</para>

		<warning>
		  <para>Gardez &agrave; l'esprit que cette option rend votre
		    système de fichiers plus fragile.  Avec cette
		    option, les risques ne sont accrus qu'en cas de
		    coupure d'alimentation, le système de fichiers
		    soit irrécupérable quand la machine
		    redémarrera.</para>

		  <para>S'il n'y a que <filename>/usr/obj</filename>
		    sur ce système de fichiers, ce n'est alors pas un
		    problème.  Si vous avez d'autres données
		    importantes sur ce système de fichiers,
		    assurez-vous que vos sauvegardes soient &agrave; jour
		    avant d'activer cette option.</para>
		</warning>

		<screen>&prompt.root; <userinput>mount -u -o async /usr/obj</userinput></screen>

		<warning>
		  <para>Comme auparavant, si
		    <filename>/usr/obj</filename> ne constitue pas un
		    système de fichiers en soit, remplacez-le dans
		    l'exemple par le nom du point de montage
		    approprié.</para>
		</warning>
	      </listitem>
	    </itemizedlist>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Que faire si quelque chose se passe mal?</para>
	  </question>

	  <answer>
	    <para>Soyez absolument sûr que votre environnement
	      ne contient pas des restes de compilation
	      précédentes.  Cela est plutôt simple:</para>

	    <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root; <userinput>rm -rf /usr/obj/usr</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

	    <para>En effet, <command>make cleandir</command>
	      doit vraiment être exécutée
	      deux fois.</para>

	    <para>Ensuite relancez l'ensemble du processus,
	      en commençant avec
	      <command>make buildworld</command>.</para>

	    <para>Si vous avez toujours des problèmes,
	      envoyez l'erreur et le résultat de la commande
	      <command>uname -a</command> &agrave; la &a.questions;.
	      Tenez-vous prêt &agrave; répondre &agrave; d'autres
	      concernant votre configuration!</para>
	  </answer>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 xml:id="small-lan">
    <info><title>Suivre les mises &agrave; jour pour plusieurs machines</title>
      <authorgroup>
	<author><personname><firstname>Mike</firstname><surname>Meyer</surname></personname><contrib>Contribution de </contrib></author>
      </authorgroup>
    </info>
    
    <indexterm>
      <primary>NFS</primary>
      <secondary>installation de multiples machines</secondary>
    </indexterm>

    <para>Si vous avez plusieurs machines dont vous voulez maintenir &agrave;
      jour l'arborescence des sources, alors faire
      télécharger et recompiler &agrave; chacune d'entre elles
      les sources semble un gaspillage de ressources: espace disque, bande
      passante réseau, et cycles CPU.  C'est en effet bien le cas,
      et la solution est d'avoir une machine qui fait la majeure
      partie du travail, pendant que le reste des machines montent ce
      travail par NFS.  Cette section décrit une façon
      de le faire.</para>

    <sect2 xml:id="small-lan-preliminaries">
      <title>Préliminaires</title>

      <para>Premièrement, identifiez un ensemble de machines
	qui va utiliser le même ensemble de binaires, que nous
	appellerons un <emphasis>ensemble de compilation</emphasis>.
	Chaque machine peut avoir un noyau personnalisé, mais
	elles exécuteront les mêmes binaires utilisateur du
	système de base.  Dans cet ensemble de machine, choisissez
	une machine qui sera la <emphasis>machine de
	compilation</emphasis>.  Cela sera la machine sur laquelle
	le monde et le noyau seront compilés.  Idéalement, cela
	devrait être une machine rapide avec un CPU suffisamment
	disponible pour exécuter la commande <command>make
	buildworld</command> et <command>make buildkernel</command>.  Vous voudrez également utiliser
	une <emphasis>machine de test</emphasis>, qui testera
	les mises &agrave; jour logicielles avant d'être utilisées
	en production.  Cela <emphasis>doit</emphasis> être une
	machine que vous pouvez vous permettre d'avoir hors service
	pour une longue période.  Cela peut être la machine
	de compilation, mais cela n'est pas obligatoire.</para>

      <para>Toutes les machines de cet ensemble de compilation
	doivent monter <filename>/usr/obj</filename> et
	<filename>/usr/src</filename> &agrave; partir de la même
	machine, et du même point de montage.  Idéalement, ces
	derniers sont sur deux disques différents sur la machine de
	compilation, mais peuvent également être
	montés par NFS sur cette machine.  Si vous avez plusieurs
	ensembles de compilation, <filename>/usr/src</filename>
	devrait être sur une machine de compilation, et monté
	par NFS sur les autres.</para>

      <para>Finalement assurez-vous que
	<filename>/etc/make.conf</filename> et
	<filename>/etc/src.conf</filename> sur toutes les machines
	de l'ensemble de compilation sont en accord avec la machine de
	compilation.  Cela signifie que la machine de compilation doit
	compiler toutes les parties du système de base que toute
	machine de l'ensemble de compilation va installer.
	De plus, chaque machine de compilation devra avoir son nom de
	noyau défini avec <varname>KERNCONF</varname> dans
	<filename>/etc/make.conf</filename>, et la machine de
	compilation devrait tous les lister dans
	<varname>KERNCONF</varname>, en listant son noyau en premier.
	La machine de compilation doit avoir les fichiers de
	configuration des noyaux de chaque machine dans
	<filename>/usr/src/sys/arch/conf</filename>
	si elle va compiler leur noyau.</para>
    </sect2>

    <sect2>
      <title>Le système de base</title>

      <para>Maintenant que tout est configuré, vous êtes
	fin prêt pour tout compiler.  Compilez le noyau et le monde
	sur la machine de compilation comme décrit dans la <xref linkend="make-buildworld"/>, mais n'installez rien.  La
	compilation une fois terminée, allez sur la machine de
	test, et installez le noyau que vous venez juste de compiler.
	Si la machine monte <filename>/usr/src</filename>
	et <filename>/usr/obj</filename> via NFS, quand vous
	redémarrez en mode mono-utilisateur vous devrez activer le
	réseau et monter ces répertoires.  La méthode
	la plus simple est de démarrer en mode multi-utilisateur,
	puis exécutez <command>shutdown now</command> pour passer en
	mode mono-utilisateur.  Une fois &agrave; ce niveau, vous pouvez
	installer le nouveau noyau et monde puis exécuter
	<command>mergemaster</command> comme vous le feriez
	habituellement.  Une fois cela effectué, redémarrez
	pour retourner en mode multi-utilisateur pour cette
	machine.</para>

      <para>Après que vous soyez certain que tout fonctionne
	correctement sur la machine de test, utilisez la même
	procédure pour installer le nouvel ensemble logiciel sur
	chacune des autres machines de l'ensemble de
	compilation.</para>
    </sect2>

    <sect2>
      <title>Les logiciels portés</title>

      <para>La même idée peut être utilisée
	pour le catalogue des logiciels portés.  La
	première étape critique est de monter
	<filename>/usr/ports</filename> depuis la même machine vers
	toutes les machines de l'ensemble de compilation.  Vous
	pouvez alors configurer correctement
	<filename>/etc/make.conf</filename> pour partager les
	archives.  Vous devrez faire pointer <varname>DISTDIR</varname>
	sur un répertoire de partage commun dans lequel peut
	écrire n'importe quel utilisateur utilisé pour
	correspondance de l'utilisateur <systemitem class="username">root</systemitem> par vos
	montages NFS.  Chaque machine devrait faire pointer
	<varname>WRKDIRPREFIX</varname> sur une répertoire de
	compilation local.  Et enfin, si vous projetez de compiler et
	distribuer des logiciels précompilés, vous
	devriez fixer <varname>PACKAGES</varname> sur un répertoire
	similaire &agrave; <varname>DISTDIR</varname>.</para>
    </sect2>
  </sect1>
</chapter>
