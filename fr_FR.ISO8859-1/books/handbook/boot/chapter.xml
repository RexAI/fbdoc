<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD French Documentation Project

     $FreeBSD$
     Original revision: 1.65
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="boot">
  <title>Processus de démarrage de FreeBSD</title>
  &trans.a.fonvieille;

  <sect1 xml:id="boot-synopsis">
    <title>Synopsis</title>
    <indexterm><primary>démarrage</primary></indexterm>
    <indexterm><primary>bootstrap</primary></indexterm>

    <para>L'action de démarrer un ordinateur et de
      charger le système d'exploitation est désignée
      sous le nom de &ldquo;processus de bootstrap&rdquo;, ou simplement
      démarrage.  Le processus de démarrage de FreeBSD
      fournit une grande flexibilité en adaptant ce qui se passe
      quand vous démarrez le système, vous permettant
      de choisir parmi les différents systèmes
      d'exploitation installés sur l'ordinateur, ou même
      parmi les différentes versions du même système
      d'exploitation ou du noyau installées.</para>

    <para>Ce chapitre détaille les options de configuration que
      vous pouvez paramétrer et comment personnaliser le processus
      de démarrage de FreeBSD.  Cela inclut tout ce qui se produit
      jusqu'au démarrage du noyau FreeBSD, la détection des
      périphériques, et le démarrage d'&man.init.8;.
      Si vous n'êtes pas tout &agrave; fait sûr du moment auquel
      cela arrive, cela se produit &agrave; l'instant où la
      couleur du texte passe d'un blanc lumineux au gris.</para>

    <para>Après la lecture de ce chapitre, vous
      connaîtrez:</para>

    <itemizedlist>
      <listitem>
	<para>Quels sont les composants du système de
	  démarrage de FreeBSD, et comment ils agissent les uns
	  sur les autres.</para>
      </listitem>

      <listitem>
	<para>Les options que vous pouvez passer aux composants du
	  système de démarrage de FreeBSD pour
	  contrôler le processus.</para>
      </listitem>

      <listitem>
	<para>Les bases du système &man.device.hints.5;.</para>
      </listitem>
    </itemizedlist>

    <note>
      <title>x86 seulement</title>

      <para>Ce chapitre ne décrit que le processus de
	démarrage de FreeBSD pour les systèmes Intel x86.</para>
    </note>
  </sect1>

  <sect1 xml:id="boot-introduction">
    <title>Le problème du démarrage</title>

    <para>Allumer un ordinateur et démarrer le système
      d'exploitation pose un intéressant dilemme.  Par
      définition, l'ordinateur ne sait rien faire jusqu'&agrave;
      ce que le système d'exploitation soit lancé.
      Ceci inclut l'exécution des programmes &agrave; partir du disque.
      Donc si l'ordinateur ne peut pas exécuter de programme
      &agrave; partir du disque sans le système d'exploitation, et
      que les programmes du système d'exploitation sont sur
      le disque, comment le système d'exploitation est-il
      démarré?</para>

    <para>On peut faire le parallèle avec un
      événement du livre <citetitle>Les aventures du Baron
      Munchausen</citetitle>.  Le personnage tombe dans une bouche
      d'égout avec une partie du corps hors de la bouche, et il s'en
      sort en attrapant les fixations de ses bottes
      (&ldquo;bootstraps&rdquo;), et en se soulevant ainsi.  Dans les
      premiers jours de l'informatique le terme
      <firstterm>bootstrap</firstterm> fut appliqué au mécanisme
      utilisé pour charger le système d'exploitation, terme qui a
      été
      raccourci en &ldquo;booting&rdquo; (que l'on traduit par démarrage
      en Français).</para>

    <indexterm><primary>BIOS</primary></indexterm>

    <indexterm>
      <primary>Basic Input/Output System</primary>
      <see>BIOS</see>
    </indexterm>

    <para>Sur l'architecture x86 c'est le BIOS (&ldquo;Basic
      Input/Output System&rdquo;) qui est responsable du chargement du
      système d'exploitation.  Pour effectuer cela, le BIOS recherche
      sur le disque dur le &ldquo;Master Boot Record&rdquo; - Secteur
      Principal de Démarrage (MBR), qui doit être
      placé &agrave; un endroit bien précis sur le disque.
      Le BIOS dispose de
      suffisamment de connaissances pour charger et exécuter
      le MBR, et suppose que le MBR peut alors effectuer le reste des
      tâches impliquées dans le chargement du système
      d'exploitation, probablement avec l'aide du BIOS.</para>

    <indexterm><primary>Master Boot Record (MBR)</primary></indexterm>

    <indexterm><primary>Gestionnaire de démarrage</primary></indexterm>

    <indexterm><primary>Boot Loader</primary></indexterm>

    <para>Pour parler du code contenu dans le MBR, on fait souvent
      référence aux termes de <emphasis>gestionnaire de
      démarrage</emphasis> <emphasis>gestionnaire
      d'amorce</emphasis>, tout particulièrement quand il y a
      intéraction avec l'utilisateur.  Dans ce cas le code de
      ce gestionnaire occupe un espace plus important sur la
      première <emphasis>piste</emphasis> du disque ou du
      système de fichier du système d'exploitation (le
      gestionnaire de démarrage est parfois également
      appelé gestionnaire de chargement ou chargeur,
      <quote>boot loader</quote>, sous &os; ce terme est
      utilisé pour une étape ultérieur du
      démarrage).  Parmi les gestionnaire de démarrage
      populaire, se trouvent <application>boot0</application>
      (également connu sous le nom de <application>Boot
      Easy</application>, le gestionnaire de démarrage standard
      de &os;), <application>Grub</application>,
      <application>GAG</application>, et
      <application>LILO</application> (seul
      <application>boot0</application> peut tenir entièrement
      dans l'espace du MBR.).</para>

    <para>Si vous n'avez qu'un seul système d'exploitation
      installé sur vos disques alors le MBR PC standard sera suffisant.  Ce
      MBR recherche la première tranche (&ldquo;slice&rdquo;)
      amorçable (souvent appelée active) sur le disque, et puis exécute le code sur cette
      tranche pour charger le reste du système d'exploitation.
      Le MBR installé par &man.fdisk.8; par défaut se
      comporte de cette manière.  Il est basé sur
      <filename>/boot/mbr</filename>.</para>

    <para>Si vous avez installé plusieurs systèmes
      d'exploitation sur vos disques alors vous pouvez installer un gestionnaire d'amorce
      différent, qui permet d'afficher une liste des
      différents systèmes d'exploitation, et vous permet de
      sélectionner
      celui &agrave; partir duquel démarrer.  Ceci est
      abordé dans la sous-section suivante.</para>

    <para>Le reste du système de démarrage de FreeBSD est
      divisé en trois étapes.
      La première étape est exécutée
      par le MBR, qui en sait juste assez pour mettre l'ordinateur dans
      un état spécifique et lancer la deuxième
      étape.  La seconde étape peut en faire un peu plus, avant de
      lancer la troisième étape.  La troisième étape
      termine la tâche de chargement du système d'exploitation.
      La tâche a été séparée en trois
      étapes parce que le standard PC
      impose des limites sur la taille des programmes qui peuvent
      être exécutés aux étapes une et deux.
      L'enchaînement des tâches permet &agrave; FreeBSD de fournir
      un chargeur plus flexible.</para>

    <indexterm><primary>noyau</primary></indexterm>
    <indexterm><primary><command>init</command></primary></indexterm>

    <para>Le noyau est ensuite démarré et commence
      &agrave; sonder le système &agrave; la recherche de
      périphériques et les initialise.  Une fois le
      processus de démarrage du noyau achevé, le noyau
      passe la main au processus &man.init.8;, qui alors vérifie
      que les disques sont utilisables.
      &man.init.8; commence ensuite la configuration des ressources au
      niveau utilisateur, monte les systèmes de fichiers,
      initialise les cartes réseaux pour communiquer sur le
      réseau, et lance tous les processus qui sont habituellement
      exécutés au démarrage d'un système
      FreeBSD.</para>
  </sect1>

  <sect1 xml:id="boot-blocks">
    <title>Le gestionnaire de démarrage et les étapes de
      démarrage</title>

    <indexterm><primary>Gestionnaire de
      démarrage</primary></indexterm>

    <sect2 xml:id="boot-boot0">
      <title>Le gestionnaire de démarrage</title>
      <indexterm><primary>Master Boot Record (MBR)</primary></indexterm>

      <para>Le code contenu dans le MBR ou gestionnaire de
	démarrage ou d'amorce est parfois appelé
	<emphasis>étape zéro</emphasis> du processus de
	démarrage.  Cette section discute de deux gestionnaires
	de démarrage précédemment
	mentionnés: <application>boot0</application> et
	<application>LILO</application>.</para>

      <formalpara><title>Le gestionnaire d'amorce
	<application>boot0</application>:</title>
      <para>Le MBR installé par l'installateur &os; ou par
	&man.boot0cfg.8; est basé sur
	<filename>/boot/boot0</filename>.
	(<filename>boot0</filename> est très simple, puisque le
	programme dans le <abbrev>MBR</abbrev> ne peut pas occuper plus
	de 446 octets en raison de la
	table de partition principale et l'identifiant
	<literal>0x55AA</literal> &agrave; la fin du MBR).
	Si vous avez installé <application>boot0</application>
	et plusieurs systèmes d'exploitation sur vos disques durs alors
	vous verrez un affichage semblable &agrave; celui-ci au
	démarrage:</para></formalpara>

      <example xml:id="boot-boot0-example">
	<title>Ecran de <filename>boot0</filename></title>

	<screen>F1 DOS
F2 FreeBSD
F3 Linux
F4 ??
F5 Drive 1

Default: F2</screen>
      </example>

      <para>D'autres systèmes d'exploitation, en particulier
	&windows;, sont connus pour écraser le MBR existant avec le
	leur.  Si cela vous arrive, ou que vous désirez remplacer
	le MBR existant avec le MBR de FreeBSD alors utilisez la commande
	suivante:</para>

      <screen>&prompt.root; <userinput>fdisk -B -b /boot/boot0 device</userinput></screen>

      <para>où <replaceable>device</replaceable> est le
	périphérique &agrave; partir duquel vous
	démarrez, comme <filename>ad0</filename> pour le premier
	disque IDE, <filename>ad2</filename> pour le premier disque
	IDE sur le second contrôleur IDE, <filename>da0</filename>
	pour le premier disque SCSI, et ainsi de suite.  Ou, si vous
	voulez une configuration sur mesure du MBR, employez
	&man.boot0cfg.8;.</para>

      <formalpara><title>Le gestionnaire de démarrage LILO:</title>

	<para>Pour installer ce gestionnaire de manière &agrave; ce qu'il
	  amorce également &os;, démarrez tout d'abord Linux et
	  ajoutez ce qui suit au fichier de configuration
	  <filename>/etc/lilo.conf</filename>:</para></formalpara>

      <programlisting>other=/dev/hdXY
table=/dev/hdX
loader=/boot/chain.b
label=FreeBSD</programlisting>

      <para>Dans ce qui précède, précisez la
	partition primaire et le disque &os; en utilisant les
	paramètres propres &agrave; Linux, en remplaçant
	<replaceable>X</replaceable> avec la lettre correspondant au
	disque Linux et <replaceable>Y</replaceable> avec le
	numéro de la partition primaire Linux.  Si vous
	utilisez un disque <acronym>SCSI</acronym>, vous changerez
	<replaceable>/dev/hd</replaceable> pour quelque chose de
	semblable &agrave; <replaceable>/dev/sd</replaceable>.  La ligne
	<option>loader=/boot/chain.b</option> peut être omise si vous
	avez les deux systèmes d'exploitation sur le même disque.
	Lancez maintenant la commande <command>/sbin/lilo -v</command> pour
	entériner vos modifications; des messages de contrôle
	devraient s'afficher, vérifiant ces modifications.</para>
    </sect2>

    <sect2 xml:id="boot-boot1">
      <title>Etape une, <filename>/boot/boot1</filename>, et étape deux,
	<filename>/boot/boot2</filename></title>

      <para>Conceptuellement la première et la seconde étapes
	font partie du même programme, sur le même emplacement du
	disque.  Mais en raison de contraintes d'espace elles ont
	été divisées en deux, mais vous les installerez
	toujours de paire.  Elles sont copiées, &agrave; partir
	du fichier combiné <filename>/boot/boot</filename>, par
	l'installateur ou <application>bsdlabel</application> (voir
	plus bas).</para>

      <para>On les trouve en dehors des systèmes de fichiers,
	sur la première piste de la tranche de
	démarrage, &agrave; partir du premier secteur.  C'est
	l'endroit où <link linkend="boot-boot0">boot0</link>, ou tout autre gestionnaire
	de démarrage s'attend &agrave; trouver le code &agrave;
	exécuter pour continuer le processus de démarrage.
	Le nombre de secteurs utilisés est facilement
	déterminé &agrave; partir de la taille du
	fichier <filename>/boot/boot</filename>.</para>

      <para><filename>boot1</filename> est très simple, puisqu'il est
	limité &agrave; 512 octets, et en
	sait juste assez du
	<firstterm>bsdlabel</firstterm> de FreeBSD, qui contient
	l'information sur la tranche, pour trouver et lancer
	<filename>boot2</filename>.</para>

      <para><filename>boot2</filename> est légèrement
	plus sophistiqué, et en connaît assez sur le
	système de fichiers
	de FreeBSD pour y trouver des fichiers, et il peut également
	fournir une interface simple pour sélectionner un noyau ou un
	chargeur &agrave; exécuter.</para>

      <para>Comme le <link linkend="boot-loader">chargeur</link> est
	beaucoup plus sophistiqué, et dispose d'une interface de
	configuration du démarrage facile d'emploi,
	<filename>boot2</filename> l'exécute habituellement, bien que
	précédemment, c'est lui qui
	lançait directement le noyau.</para>

      <example xml:id="boot-boot2-example">
	<title>Ecran de <filename>boot2</filename></title>

	<screen>&gt;&gt; FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:</screen>
      </example>

      <para>Si vous avez un jour besoin de remplacer
	<filename>boot1</filename> et <filename>boot2</filename>,
	utilisez &man.bsdlabel.8;:</para>

      <screen>&prompt.root; <userinput>bsdlabel -B diskslice</userinput></screen>

      <para>où <replaceable>diskslice</replaceable> est le disque et la
	tranche &agrave; partir de laquelle vous démarrez, comme
	<filename>ad0s1</filename> pour la première tranche sur le
	premier disque IDE.</para>

      <warning>
	<title>Mode dangereusement dédié</title>

	<para>Si vous utilisez juste le nom du disque, comme
	  <filename>ad0</filename>, dans la commande &man.bsdlabel.8;
	  vous créerez un disque dangereusement dédié,
	  sans tranches.
	  Ce n'est presque certainement pas ce que vous voulez faire,
	  donc vérifiez &agrave; deux fois la commande
	  &man.bsdlabel.8; avant d'appuyer sur
	  <keycap>Entrée</keycap>.</para>
      </warning>
    </sect2>

  <sect2 xml:id="boot-loader">
    <title>Etape trois, <filename>/boot/loader</filename></title>

    <indexterm><primary>boot-loader</primary></indexterm>
    <para>Le chargeur est la dernière étape
      du processus de démarrage en trois temps, et il réside sur
      le système de fichiers, c'est habituellement le fichier
      <filename>/boot/loader</filename>.</para>

    <para>Le chargeur a pour objet de fournir une méthode de
      configuration conviviale, en utilisant un jeu de commandes faciles
      d'emploi, doublé d'un interpréteur plus puissant, avec un
      ensemble de commandes plus complexes.</para>

    <sect3 xml:id="boot-loader-flow">
      <title>Déroulement des opérations du chargeur</title>

      <para>A l'initialisation, le chargeur recherchera la console et
	les disques, et déterminera &agrave; partir de quel disque
	démarrer.  Il positionnera les variables en
	conséquence, et un interpréteur sera lancé
	pour lequel l'utilisateur pourra passer des commandes par
	l'intermédiaire d'une procédure ou de façon
	interactive.</para>
      <indexterm><primary>chargeur</primary></indexterm>
      <indexterm><primary>configuration du chargeur</primary></indexterm>

      <para>Le chargeur lira ensuite
	<filename>/boot/loader.rc</filename>, qui lui ira lire
	dans <filename>/boot/defaults/loader.conf</filename>
	les valeurs par défaut des variables &agrave; positionner et dans
	<filename>/boot/loader.conf</filename> les variantes locales de
	ces dernières.  <filename>loader.rc</filename> se sert de ces
	variables pour charger les modules et le noyau
	sélectionnés.</para>

      <para>Finalement, par défaut, le chargeur attend 10 secondes l'appui
	sur une ou plusieurs touches, et démarre le noyau s'il n'est pas
	interrompu.  S'il est interrompu, une invite est alors affichée
	&agrave; l'utilisateur, un jeu de commandes simples permet &agrave;
	l'utilisateur de modifier des variables, charger ou décharger des
	modules, et enfin démarrer ou redémarrer.</para>

    </sect3>

    <sect3 xml:id="boot-loader-commands">
      <title>Commandes intégrées au chargeur</title>

      <para>Voici les commandes du chargeur les plus utilisées.
	Pour une information complète sur toutes les commandes
	disponibles, veuillez consulter la page &man.loader.8;.</para>

      <variablelist>
	<varlistentry>
	  <term>autoboot <replaceable>secondes</replaceable></term>

	  <listitem>
	    <para>Démarre le noyau si elle n'est pas interrompue
	      dans le laps de temps donné en secondes.  Elle affiche
	      un compte &agrave; rebours, et le délai par défaut
	      est de 10 secondes.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>boot
	    <optional>-options</optional>
	    <optional>nom_du_noyau</optional></term>

	  <listitem>
	    <para>Démarre immédiatement le noyau dont le nom
	      est indiqué, avec les options données,
	      s'il y en a.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>boot-conf</term>

	  <listitem>
	    <para>Passe par la même configuration automatique
	      des modules basée sur des variables comme ce
	      qui se produit au démarrage.  Cela n'a de sens
	      que si vous utilisez <command>unload</command> en premier,
	      et modifiez certaines variables, généralement
	      <envar>kernel</envar>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>help
	    <optional>sujet</optional></term>

	  <listitem>
	    <para>Affiche les messages d'aide contenus dans
	      <filename>/boot/loader.help</filename>.  Si le sujet donné
	      est <literal>index</literal>, alors c'est la liste de tous les
	      sujets existants qui est donnée.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>include <replaceable>nom_du_fichier</replaceable>
	    &hellip;</term>

	  <listitem>
	    <para>Traite le fichier dont le nom est donné.
	      Le fichier est lu, et interprété ligne par ligne.
	      Une erreur stoppe immédiatement le traitement.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>load <optional>-t
	    type</optional>
	    <replaceable>nom_du_fichier</replaceable></term>

	  <listitem>
	    <para>Charge le noyau, le module, ou le fichier du type
	      donné, dont le nom est passé en
	      paramètre.  Les arguments qui suivent le nom du fichier
	      sont passés au fichier.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>ls <optional>-l</optional>
	    <optional>chemin_d_accès</optional></term>

	  <listitem>
	    <para>Affiche la liste des fichiers du répertoire
	      donné, ou du répertoire racine, si le chemin
	      d'accès n'est pas précisé.
	      Si l'option <option>-l</option> est utilisée, les
	      tailles des fichiers seront également
	      listées.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>lsdev <optional>-v</optional></term>

	  <listitem>
	    <para>Liste tous les périphériques depuis lesquels
	      il sera possible de charger des modules.  Si l'option
	      <option>-v</option> est utilisée, plus de détails
	      seront donnés.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>lsmod <optional>-v</optional></term>

	  <listitem>
	    <para>Affiche la liste des modules chargés.
	      Si l'option <option>-v</option> est utilisée, plus de
	      détails seront donnés.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>more <replaceable>nom_du_fichier</replaceable></term>

	  <listitem>
	    <para>Affiche les fichiers indiqués, avec une pause toutes
	      <varname>LINES</varname> lignes.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>reboot</term>

	  <listitem>
	    <para>Redémarre immédiatement le
	      système.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>set <replaceable>variable</replaceable></term>
	  <term>set
	    <replaceable>variable</replaceable>=<replaceable>value</replaceable></term>

	  <listitem>
	    <para>Positionne les variables d'environnement du
	      chargeur.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>unload</term>

	  <listitem>
	    <para>Retire de la mémoire tous les modules
	      chargés.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect3>

    <sect3 xml:id="boot-loader-examples">
      <title>Exemples d'utilisation du chargeur</title>

      <para>Voici quelques exemples pratiques d'utilisation du
	chargeur:</para>

      <itemizedlist>
	<listitem>
	  <para>Pour simplement démarrer votre noyau habituel,
	    mais en mode mono-utilisateur:<indexterm><primary>mode mono-utilisateur</primary></indexterm></para>

	  <screen><userinput>boot -s</userinput></screen>
	</listitem>

	<listitem>
	  <para>Pour décharger votre noyau et modules habituels,
	  puis charger votre ancien (ou un autre) noyau:</para>

	  <screen><userinput>unload</userinput>
<userinput>load kernel.old</userinput></screen>

	  <para>Vous pouvez utiliser <filename>kernel.GENERIC</filename>
	    pour faire référence au noyau
	    générique du disque d'installation, ou
	    <filename>kernel.old</filename><indexterm><primary><filename>kernel.old</filename></primary></indexterm> pour désigner votre noyau
	    précédent (quand vous avez mis &agrave; jour ou
	    configuré votre propre noyau, par exemple).</para>

	  <note>
	    <para>Utilisez ce qui suit pour charger vos modules
	      habituels avec un autre noyau:</para>

	    <screen><userinput>unload</userinput>
<userinput>set kernel="kernel.old"</userinput>
<userinput>boot-conf</userinput></screen></note>
	</listitem>

	<listitem>
	  <para>Pour charger une procédure de configuration
	    du noyau (une procédure qui automatise ce que vous faites
	    normalement avec l'outil de configuration du noyau au
	    démarrage):</para>

	  <screen><userinput>load -t userconfig_script /boot/kernel.conf</userinput></screen>
	</listitem>
      </itemizedlist>
  </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="boot-kernel">
    <title>Interaction avec le noyau au démarrage</title>
    <indexterm>
      <primary>noyau</primary>
      <secondary>interaction au démarrage</secondary>
    </indexterm>

    <para>Une fois que le noyau est chargé, soit par le
      <link linkend="boot-loader">chargeur</link> (habituellement) soit
      par <link linkend="boot-boot1">boot2</link> (en court-circuitant
      le chargeur), il examine les options de démarrage s'il y en a, et
      adapte son comportement en conséquence.</para>

    <sect2 xml:id="boot-kernel-bootflags">
      <title>Options de démarrage du noyau</title>

      <indexterm>
        <primary>noyau</primary>
        <secondary>options de démarrage</secondary>
      </indexterm>

      <para>Voici les options de démarrage les plus courantes:</para>

      <variablelist xml:id="boot-kernel-bootflags-list">
	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
	    <para>A l'initialisation du noyau, demande quel est le
	      périphérique où se trouve le système
	      de fichiers racine.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-C</option></term>

	  <listitem>
	    <para>Démarre depuis le CDROM.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-c</option></term>

	  <listitem>
	    <para>Exécute UserConfig, l'outil de configuration du
	      noyau au démarrage.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-s</option></term>

	  <listitem>
	    <para>Démarre en mode mono-utilisateur.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Donne plus de détails lors du lancement
	      du noyau.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <note>
	<para>Il existe d'autres options de démarrage, lisez
	  la page de manuel &man.boot.8; pour plus
	  d'informations.</para></note>
    </sect2>

<!--    <sect2 id="boot-kernel-userconfig">
      <title>UserConfig: The boot-time kernel configurator</title>

      <para> </para>
    </sect2> -->
  </sect1>

  <sect1 xml:id="device-hints">
    <info><title>&ldquo;Device Hints&rdquo;&mdash;Paramétrage des
      périphériques</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Contribution de </contrib></author>
      </authorgroup>
      
    </info>
    
    <indexterm>
      <primary>device.hints</primary>
    </indexterm>

    <note>
      <para>C'est une caractéristique de FreeBSD&nbsp;5.0 et
	des versions suivantes qui n'existe pas dans les versions
	précédentes.</para>
    </note>

    <para>Lors du démarrage du système, le chargeur
      (&man.loader.8;) lira le fichier &man.device.hints.5;.  Ce
      fichier stocke les informations de démarrage du noyau connues
      sous le nom de variables, et parfois appelées &ldquo;device
      hints&rdquo;.  Ces &ldquo;device hints&rdquo; sont utilisés
      par les pilotes de périphérique pour la configuration
      des périphériques.</para>

    <para>Les &ldquo;device hints&rdquo; peuvent être
      spécifiés &agrave; l'invite du <link linkend="boot-loader">chargeur</link>.
      Des variables peuvent être ajoutées en
      utilisant la commande <command>set</command>, retirées
      avec la commande <command>unset</command>, et affichées
      avec la commande <command>show</command>.  Les variables
      positionnées dans le fichier
      <filename>/boot/device.hints</filename> peuvent être
      écrasées &agrave; cet endroit.  Les &ldquo;device hints&rdquo;
      entrés au niveau du chargeur ne sont pas permanents et seront
      oubliés au prochain redémarrage.</para>

    <para>Une fois le système démarré, la commande
      &man.kenv.1; peut être utilisée pour afficher toutes
      les variables.</para>

    <para>La syntaxe du fichier <filename>/boot/device.hints</filename>
      est d'une variable par ligne, en utilisant le caractère
      &ldquo;#&rdquo; comme signe de mise en commentaire.  Les
      lignes sont présentées comme suit:</para>

    <screen><userinput>hint.pilote.unité.motclé="valeur"</userinput></screen>

    <para>La syntaxe &agrave; utiliser avec le chargeur est:</para>

    <screen><userinput>set hint.pilote.unité.motclé=valeur</userinput></screen>

    <para>où <literal>pilote</literal> est le pilote de périphérique,
      <literal>unité</literal> est le numéro de l'unité et
      <literal>motclé</literal> est le mot-clé correspondant &agrave; la variable.
      Le mot-clé pourra être une des options suivantes:</para>

    <itemizedlist>
      <listitem>
	<para><literal>at</literal>: spécifie le bus auquel le
	  périphérique est attaché.</para>
      </listitem>

      <listitem>
	<para><literal>port</literal>: spécifie l'adresse de départ de
	  l'<acronym>E/S</acronym> &agrave; utiliser.</para>
      </listitem>

      <listitem>
	<para><literal>irq</literal>: spécifie le numéro de la
	  requête d'interruption &agrave; utiliser.</para>
      </listitem>

      <listitem>
	<para><literal>drq</literal>: spécifie le numéro du canal DMA.</para>
      </listitem>

      <listitem>
	<para><literal>maddr</literal>: spécifie l'adresse mémoire physique
	  occupée par le périphérique.</para>
      </listitem>

      <listitem>
	<para><literal>flags</literal>: fixe les bits des indicateurs pour le
	  périphérique.</para>
      </listitem>

      <listitem>
	<para><literal>disabled</literal>: si positionnée &agrave; <literal>1</literal>
	  le périphérique est désactivé.</para>
      </listitem>
    </itemizedlist>

    <para>Les pilotes de périphérique pourront accepter (ou
      nécessiter) plus de variables non listées ici, il est
      recommandé de lire leur page de manuel.  Pour plus
      d'information, consultez les pages de manuel
      &man.device.hints.5;, &man.kenv.1;, &man.loader.conf.5;, et
      &man.loader.8;.</para>
  </sect1>

  <sect1 xml:id="boot-init">
    <title>Init: Initialisation de la gestion des processus</title>

    <indexterm>
      <primary><command>init</command></primary>
    </indexterm>

    <para>Une fois que le noyau a démarré, il passe le
      contrôle au processus utilisateur &man.init.8;,
      qui se trouve dans <filename>/sbin/init</filename>, ou au
      programme défini dans la variable d'environnement
      <envar>init_path</envar> du chargeur.</para>

    <sect2 xml:id="boot-autoreboot">
      <title>Séquence de redémarrage automatique</title>

      <para>La séquence de redémarrage automatique
	vérifie que les systèmes de fichiers
	sont cohérents.  S'ils ne le sont pas, et que
	&man.fsck.8; ne peut pas corriger les
	incohérences, &man.init.8; place le
	système dans le <link linkend="boot-singleuser">mode
	mono-utilisateur</link> pour que l'administrateur système
	règle directement le problème.</para>
    </sect2>

    <sect2 xml:id="boot-singleuser">
      <title>Mode mono-utilisateur</title>
      <indexterm><primary>mode mono-utilisateur</primary></indexterm>
      <indexterm><primary>console</primary></indexterm>

      <para>Ce mode peut être atteint depuis la <link linkend="boot-autoreboot">séquence de redémarrage
	automatique</link>, ou quand l'utilisateur démarre avec l'option
	<option>-s</option> ou en positionnant la variable
	<envar>boot_single</envar> du chargeur.</para>

      <para>On peut également y parvenir en appelant la commande
	&man.shutdown.8; sans les options de redémarrage
	(<option>-r</option>) ou d'arrêt (<option>-h</option>),
	&agrave; partir du <link linkend="boot-multiuser">mode multi-utilisateur</link>.</para>

      <para>Si la <literal>console</literal> système est
	positionnée dans le mode <literal>insecure</literal> dans le
	fichier <filename>/etc/ttys</filename>, alors le système
	demande le mot de passe de <systemitem class="username">root</systemitem> avant de
	passer en mode mono-utilisateur.</para>

      <example xml:id="boot-insecure-console">
	<title>Une console non sécurisée dans
	  <filename>/etc/ttys</filename></title>

	<programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off insecure</programlisting>
      </example>

      <note>
	<para>Une console <literal>insecure</literal> (non
	  sécurisée) signifie que vous considérez que la
	  console n'est pas sécurisée, et vous désirez que
	  seul quelqu'un connaissant
	  le mot passe de <systemitem class="username">root</systemitem> puisse utiliser le
	  mode mono-utilisateur, et cela ne signifie pas que vous utilisez une
	  console sans sécurité. Donc, si vous voulez de la
	  sécurité, choisissez <literal>insecure</literal>,
	  et non <literal>secure</literal>.</para>
      </note>
    </sect2>

    <sect2 xml:id="boot-multiuser">
      <title>Mode multi-utilisateur</title>
      <indexterm><primary>mode multi-utilisateur</primary></indexterm>

      <para>Si &man.init.8; trouve vos systèmes de fichiers
	en état de marche, ou dès que l'utilisateur quitte
	le <link linkend="boot-singleuser">mode mono-utilisateur</link>,
	le système entre dans le mode multi-utilisateur, dans lequel il
	commence la configuration de ses ressources.</para>

      <sect3 xml:id="boot-rc">
	<title>Configuration des ressources (rc)</title>

      <indexterm><primary>fichiers</primary></indexterm>

	<para>Le système de configuration des ressources lit les
	  valeurs par défaut dans
	  <filename>/etc/defaults/rc.conf</filename>, et les valeurs
	  propres &agrave; la machine dans <filename>/etc/rc.conf</filename>,
	  puis ensuite monte les systèmes de fichiers
	  mentionnés dans <filename>/etc/fstab</filename>,
	  démarre les services réseau, divers autres
	  &ldquo;démons&rdquo; système, et enfin exécute
	  les procédures de démarrage des logiciels
	  installés localement.</para>

	<para>La page de manuel &man.rc.8; est une bonne
	  référence au sujet du système de
	  configuration des ressources, de même que la lecture des
	  procédures de démarrage elles-mêmes.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="boot-shutdown">
    <title>Séquence d'arrêt du système</title>
    <indexterm>
      <primary><command>shutdown</command></primary>
    </indexterm>

    <para>Lors de l'arrêt manuel du système, via
      &man.shutdown.8;, &man.init.8; tentera
      d'exécuter la procédure
      <filename>/etc/rc.shutdown</filename>, et ensuite enverra &agrave;
      tous les processus le signal <literal>TERM</literal>, suivi
      du signal <literal>KILL</literal> &agrave; tous ceux qui ne se
      terminent pas &agrave; temps.</para>

    <para>Pour éteindre une machine FreeBSD et cela sur des
      architectures ou des systèmes supportant la gestion par
      logiciel de l'énergie, utilisez simplement la commande
      <command>shutdown -p now</command> pour arrêter et couper
      l'alimentation de la machine.  Pour juste redémarrer un
      système FreeBSD, utilisez <command>shutdown -r now</command>.
      Vous devez être super-utilisateur (<systemitem class="username">root</systemitem>)
      ou un membre du groupe <systemitem class="groupname">operator</systemitem> pour
      pouvoir exécuter &man.shutdown.8;.  Les commandes &man.halt.8;
      et &man.reboot.8; peuvent également être
      utilisées, veuillez consulter leur page de manuel ainsi
      que celle de &man.shutdown.8; pour plus d'informations.</para>

    <note>
      <para>La gestion de l'énergie nécessite d'avoir le support
	&man.acpi.4; dans son noyau ou chargé en tant que
	module.</para>
    </note>

  </sect1>
</chapter>
