<?xml version="1.0" encoding="iso-8859-1"?>
<!-- Copyright (c) 1998, 1999 Nik Clayton, All rights reserved.

     Redistribution and use in source (SGML DocBook) and 'compiled' forms
     (SGML, HTML, PDF, PostScript, RTF and so forth) with or without
     modification, are permitted provided that the following conditions
     are met:

      1. Redistributions of source code (SGML DocBook) must retain the above
         copyright notice, this list of conditions and the following
         disclaimer as the first lines of this file unmodified.

      2. Redistributions in compiled form (transformed to other DTDs,
         converted to PDF, PostScript, RTF and other formats) must reproduce
         the above copyright notice, this list of conditions and the
         following disclaimer in the documentation and/or other materials
         provided with the distribution.

     THIS DOCUMENTATION IS PROVIDED BY NIK CLAYTON "AS IS" AND ANY EXPRESS OR
     IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
     OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     DISCLAIMED. IN NO EVENT SHALL NIK CLAYTON BE LIABLE FOR ANY DIRECT,
     INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
     STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
     ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF THE
     POSSIBILITY OF SUCH DAMAGE.

     The FreeBSD Documentation Project
     The FreeBSD French Documentation Project

     $FreeBSD$
     Original revision: 1.8
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="sgml-primer">
  <title>Introduction &agrave; SGML</title>

  <para>La majorité des documentations du FDP utilisent SGML. Ce chapitre vous
    explique ce que cela signifie exactement, comment lire et comprendre le
    source de la documentation et décrit la façon d'utiliser le SGML que vous
    recontrerez dans la documentation.</para>

  <para>Des parties de cette section se sont inspirées du livre de Mark
    Galassi, <link xlink:href="http://nis-www.lanl.gov/~rosalia/mydocs/docbook-intro/docbook-intro.html">&ldquo;<foreignphrase>Get Going With DocBook</foreignphrase>&rdquo;</link>.</para>

  <sect1>
    <title>Introduction</title>

    <para>Il était autrefois facile de travailler sur des documents
      électroniques. Vous n'aviez normalement &agrave; connaître que le jeu de
      caractères utilisé (ASCII, EBCDIC, ou l'un des nombreux autres) et
      c'était &agrave; peu près tout. Le texte était du texte, et vous voyiez
      vraiment ce que vous obteniez. Pas de sophistication, pas de formatage,
      pas d'intelligence.</para>

    <para>Cela devint inévitablement insuffisant. Une fois que vous avez du
      texte qu'une machine peut lire, vous vous attendez &agrave; ce que la machine
      puisse l'utiliser et le manipuler intelligemment. Vous aimeriez pouvoir
      préciser que certaines phrases sont accentuées, y ajouter un glossaire
      ou des hyper-liens. Vous voulez que les noms de fichiers apparaissent
      en police &ldquo;machine &agrave; écrire&rdquo; &agrave; l'écran et en italique &agrave;
      l'impression, et tout un tas d'autres options de présentation
      encore.</para>

    <para>Il fut un temps où l'on pensait que l'Intelligence Artificielle (IA)
      rendrait cela facile. Votre ordinateur pourrait lire le document et
      identifier les phrases clés, les noms de fichiers, le texte que
      l'utilisateur devait taper, et d'autres encore. Malheureusement, la
      réalité est un peu différente, et il faut aider nos ordinateurs &agrave;
      manipuler intelligemment notre texte.</para>

    <para>Plus précisement, il faut les aider &agrave; indentifier ce qui est quoi.
      Vous et moi, &agrave; la vue de&nbsp;:</para>

      <blockquote>
	<para>Pour effacer <filename>/tmp/foo</filename>, utilisez
          &man.rm.1;&nbsp;:</para>

	<screen>&prompt.user; <command>rm /tmp/foo</command></screen>
      </blockquote>

      <para>distinguons facilement ce qui est nom de fichier, commande &agrave;
        taper, référence aux pages de manuel, et ainsi de suite. Mais
        l'ordinateur lui ne le peut pas. Pour cela, Nous avons besoin des
        marques.</para>

    <para>Le &ldquo;marquage&rdquo; est communément qualifié de &ldquo;valeur
      ajoutée&rdquo; ou &ldquo;coût augmenté&rdquo;. Le terme prend ces deux
      sens quand il s'applique au texte. La marquage est du texte en
      supplément dans le document, distinct par un moyen ou un autre du
      contenu du document, de façon &agrave; ce que les programmes qui traitent le
      document puisse le lire et l'utiliser pour prendre des décisions. Les
      éditeurs peuvent masquer le marquage &agrave; l'utilisateur, de façon &agrave; ce
      qu'il ne soit pas perturbé par ces marques.</para>

    <para>L'information supplémentaire donnée avec les marques
      <emphasis>ajoute de la valeur</emphasis> au document. Le marquage doit
      habituellement être manuel&nbsp;-&nbsp;après tout, si les ordinateurs
      pouvait analyser suffisamment le texte pour ajouter les marques, il n'y
      en aurait alors en fait pas besoin. Cela <emphasis>augment le
      coût</emphasis> du document.</para>

    <para>L'exemple précédent est codé comme suit dans le présent
      document&nbsp;:</para>

    <programlisting><![CDATA[
<para>Pour effacer <filename>/tmp/foo</filename>, utilisez
  &man.rm.1;.</para>

<para><command>rm /tmp/foo</command></para>]]></programlisting>

    <para>Comme vous pouvez le constater, le marquage est clairement séparé du
      contenu.</para>

    <para>Bien évidemment, si vous devez utiliser des marques, vous devrez
      définir ce que les marques veulent dire et comment elles doivent être
      traitées. Il vous faudra un language de marquage auquel vous référer
      pour marquer vos documents.</para>

    <para>Un seul language de marquage peut bien sûr ne pas suffire. Les
      besoins de marquage d'une documentation technique diffèrent énormément
      de ceux de recettes de cuisines. ces derniers seront &agrave; leur tour
      différents de ceux d'un language de marquage pour de la poésie. Vous
      avez en fait besoin d'un language qui vous permette de définir ces
      autres languages de marquage. Un <emphasis>méta-language de
      marquage</emphasis>.</para>

    <para>C'est exactement ce qu'est <foreignphrase>Standard Generalised
      Markup Language (SGML)</foreignphrase>&nbsp;-&nbsp;Language de Marquage
      Standard Généralisé. De nombreux languages de marquage sont écrits en
      SGML, dont les deux languages les plus utilisés par le FDP, HTML et
      DocBook.</para>

    <para>Chaque définition d'un language s'appelle plus exactement une
      <foreignphrase>Document Type Definition
      (DTD)</foreignphrase>&nbsp;-&nbsp;Définition de Type de Document. La DTD
      définit les noms des éléments utilisables, leur ordre d'apparition (et
      leur hiérarchie) et les informations qui s'y rapportent. Une DTD est
      parfois désignée comme une <emphasis>application</emphasis> de
      SGML.</para>

    <para xml:id="sgml-primer-validating">Une DTD est une spécification
      <emphasis>complète</emphasis> de tous les éléments autorisés, de l'ordre
      dans lequel ils doivent être utilisés, quels sont ceux qui sont
      obligatoires, quels sont ceux qui sont facultatifs, et ainsi de suite.
      Il est alors possible d'écrire un <emphasis>analyseur</emphasis> qui
      lise et la DTD et le document qui prétend s'y conformer. L'analyseur
      peut alors vérifier si tous les éléments requis sont bien présents dans
      l'ordre voulu dans le document et s'il y a des erreurs dans le marquage.
      On appelle habituellement cela <quote>valider le
      document</quote>.</para>

    <note>
      <para>Ce traitement ne valide uniquement que le choix des éléments, leur
        ordre, et ainsi de suite, se conforme &agrave; ce que définit la DTD. Il ne
        vérifie <emphasis>pas</emphasis> que vous avez utilisé les marques
        <emphasis>appropriées</emphasis> au document. Si vous marquez tous les
        noms de fichiers de votre document comme des noms de fonctions,
        l'analyseur ne le signalera pas comme une erreur (en supposant, bien
        sûr, que votre DTD définisse des éléments pour les noms de fichiers et
        de fonctions et qu'ils aient le droit d'apparaître aux mêmes
        endroits).</para>
    </note>

    <para>Il est probable que vos contributions au Projet de Documentation
      consiste en documents marqués soit en HTML soit en DocBook, plutôt qu'en
      modifications aux DTDs. Pour cette raison, cet ouvrage n'abordera pas la
      façon d'écrire une DTD.</para>
  </sect1>

  <sect1 xml:id="sgml-primer-elements">
    <title>Eléments, marques et attributs</title>

    <para>Toutes les DTDs écrites en HTML ont des caractéristiques communes.
      Ce n'est guère surprenant comme le montre inévitablement la philosophie
      qui sous-tend SGML. Une des manifestations les plus visibles de cette
      philosophie est la caractérisation en <emphasis>contenu</emphasis> et
      <emphasis>éléments</emphasis>.</para>

    <para>Votre documentation (que ce soit une seule page Web ou un ouvrage
      volumineux) est vue comme étant un contenu. Ce contenu est alors divisé
      (et ensuite subdivisé) en éléments. L'objectif de l'ajout de marques est
      de nommer et de définir le début et la fin de ces éléments pour
      traitement ultérieur.</para>

    <para>Considérez par exemple un livre type. Au plus haut niveau, ce livre
      lui-même est un élément.  Cet élément &ldquo;livre&rdquo; contient
      évidemment des chapitres, qui peuvent aussi être légitimement considérés
      comme des éléments. Chaque chapitre contiendra &agrave; son tour des éléments,
      tels que des paragraphes, des citations et de notes de bas de page.
      Chaque paragraphe peut lui-même contenir encore des éléments, pour
      identifier le texte parlé par exemple, ou les noms des personnages de
      l'histoire.</para>

    <para>Vous pouvez si vous le voulez voir cela comme un
      &ldquo;morcelement&rdquo; du contenu. A la racine, vous avez un morceau,
      le livre. Un niveau en dessous, vous avez plus de morceaux, les
      chapitres individuels. Ils sont &agrave; leur tour morcelés en pargraphes,
      notes de bas de page, noms des personnages, et ainsi de suite.</para>

    <para>Remarquez que vous pouvez différencier les éléments sans utiliser
      la terminologie SGML. C'est vraiment immédiat. Vous pouvez le faire avec
      un surligneur et un livre imprimé, en utilisant des couleurs différentes
      pour chaque type d'élément.</para>

    <para>Nous n'avons bien sûr pas de surligneur électronique, il nous faut
      donc un autre moyen d'indiquer &agrave; quel élément appartient chaque morceau
      du contenu. Dans les languages écrits avec SGML ,(HTML, DocBook, et
      al.), cela se fait avec des <emphasis>marques</emphasis>.</para>

    <para>Une marque sert &agrave; dire où commence et où finit un élément.
      <emphasis>La marque ne fait pas partie de l'élément lui-même</emphasis>.
      Comme chaque DTD est habituellement écrite pour marquer des types
      d'informations spécifiques, chacune reconnaîtra des éléments différents,
      et aura donc des noms différents pour les marques.</para>

    <para>Pour un élément appelé <replaceable>nom-de-l'élément</replaceable>,
      la marque de début sera normalement
      <literal>&lt;nom-de-l'élément&gt;</literal>.
      La marque de fin correspondante sera
      <literal>&lt;/nom-de-l'élément&gt;</literal>.</para>

    <example>
      <title>Utiliser un élément (marques de début et de fin)</title>

      <para>HTML dispose d'un élément pour indiquer que le contenu inclus est
        un paragraphe, appelé <literal>p</literal>. Cet élément a une marque
        de début et une de fin.</para>

      <programlisting>
<![CDATA[<p>C'est un paragraphe. Il commence avec la marque de début pour
  l'élément 'p', et se terminera avec la marque de fin pour
  l'élément 'p'</p>

<p>C'est un autre paragraphe. Mais il est beaucoup plus
  court.</p>]]></programlisting>
    </example>

    <para>Tous les éléments n'ont pas besoin d'une marque de fin. Certains
      n'ont pas de contenu. En HTML, par exemple, vous pouvez indiquer que
      vous voulez avoir une ligne horizontal dans votre document. Cette ligne
      n'a bien sûr aucun contenu, vous n'avez donc besoin que de la marque de
      début pour cet élément.</para>

    <example>
      <title>Utiliser un élément (marque de début uniquement)</title>

      <para>HTML dispose d'un élément pour inclure une ligne horizontale,
        appelé <literal>hr</literal>. C'est un élément sans contenu, il n'a
        donc qu'une marque de début.</para>

      <programlisting>
<![CDATA[<p>C'est un paragraphe.</p>

<hr>

<p>C'est un autre paragraphe. Une ligne horizontale le sépare
  du précédent.</p>]]></programlisting>
    </example>

    <para>Si ce n'était pas encore clair, les éléments peuvent contenir
      d'autres éléments. Dans l'exemple du livre plus haut, ce livre contenait
      tous les chapitres, qui &agrave; leur tour contenaient tous les paragraphes, et
      ainsi de suite.</para>

    <example>
      <title>Eléments dans des éléments&nbsp;; <tag>em</tag></title>

      <programlisting>
<![CDATA[<p>C'est un <em>paragraphe</em> simple où certains
  <em>mots</em> ont été <em>mis en valeur</em>.</p>]]></programlisting>
    </example>

    <para>La DTD définira les règles qui disent quels éléments peuvent être
      inclus dans quels autres éléments, et ce qu'ils peuvent précisement
      contenir.</para>

    <important>
      <para>Les gens confondent souvent marques et éléments comme si c'étaient
        des termes interchangeables. Ce n'est pas le cas.</para>

      <para>Un élément est une partie de la structure d'un document. Un
        élément a un début et une fin. Les marques définissent où commence et
        où finit le document.</para>

      <para>Quand le présent document (ou quelqu'un d'autre qui connait le
        SGML) parle de la marque &ldquo;the &lt;p&gt; tag&rdquo;, cela se
        rapporte au texte composé des trois caractères
        <literal>&lt;</literal>, <literal>p</literal>
        et <literal>&gt;</literal>. Mais la phrase &ldquo;l'élément
        &lt;p&gt;&rdquo; désigne tout l'élément.</para>

      <para>Cette distinction <emphasis>est</emphasis> très subtile. Mais
        gardez la &agrave; l'esprit.</para>
    </important>

    <para>Les éléments peuvent avoir des attributs. Un attribut a un nom et
      une valeur, et sert &agrave; donner des informations supplémentaires
      concernant l'élément. Ce peuvent être des informations qui précisent
      comment l'élément doit être formaté, ou un identifiant unique pour cette
      occurrence de l'élément, ou autre chose encore.</para>

    <para>Les attributs d'un élément sont donnés <emphasis>dans</emphasis> la
      marque de début de l'élément et ont la forme
      <literal>nom-de-l'attribut="valeur-de-l'attribut"</literal>.</para>

    <para>Dans les versions récentes d'HTML, l'élément <tag>p</tag> a
      un attribut appelé <literal>align</literal>, qui suggère un alignement
      (justification) du paragraphe au programme affichant l'HTML.</para>

    <para>L'attribut <literal>align</literal> peut prendre l'une des quatre
      valeurs prédéfinies, <literal>left</literal>, <literal>center</literal>,
      <literal>right</literal> et <literal>justify</literal>. Si l'attribut
      n'est pas précise, la valeur par défaut est
      <literal>left</literal>.</para>

    <example>
      <title>Utiliser un élément avec un attribut</title>

      <programlisting>
<![CDATA[<p align="left">L'attribut align est superflus pour ce paragraphe,
  puisque 'left' est la valeur par défaut.</p>

<p align="center">Ce paragraphe sera peut-être centré.</p>]]></programlisting>
    </example>

    <para>Certains attributs ne prennent que des valeurs prédéfinies, comme
      <literal>left</literal> ou <literal>justify</literal>. D'autres peuvent
      prendre les valeurs que vous voulez. Si vous avez besoin de quotes
      (<literal>"</literal>) dans un attribut, mettez la valeur de l'attribut
      entre simples quotes.</para>

    <example>
      <title>Simples quotes dans un attribut</title>

      <programlisting>
<![CDATA[<p align='right'>Je suis &agrave; droite&nbsp;!</p>]]></programlisting>
    </example>

    <para>Vous n'avez pas toujours besoin de mettre la valeur de l'attribut
      entre simples quotes. Les régles &agrave; ce sujet sont cependant subtiles, et
      il est beaucoup plus simple de <emphasis>toujours</emphasis> mettre
      entre simples quotes les valeurs des attributs.</para>

    <sect2>
      <title>A faire&hellip;</title>

      <para>Pour tester les exemples donnés dans ce document, vous devrez
        installer des logiciels sur votre système et vérifiez qu'une variable
        d'environnement est correctement définie.</para>

      <procedure>
	<step>
	  <para>Téléchargez et installez <filename>textproc/docproj</filename>
            du catalogue des logiciels portés de FreeBSD. C'est un
            <emphasis>méta-port</emphasis> qui doit télécharger et installer
            tous les programmes et fichiers utilisés par le Projet de
            Documentation.</para>
	</step>

        <step>
          <para>Ajoutez les lignes pour définir
            <envar>SGML_CATALOG_FILES</envar> &agrave; vos procédures
            d'initialisation de l'interpréteur de commandes.</para>

	  <example xml:id="sgml-primer-envars">
	    <title><filename>.profile</filename>, pour les utilisateurs de
              &man.sh.1; et &man.bash.1;</title>

	    <programlisting>
SGML_ROOT=/usr/local/share/xml
SGML_CATALOG_FILES=${SGML_ROOT}/jade/catalog
SGML_CATALOG_FILES=${SGML_ROOT}/iso8879/catalog:$SGML_CATALOG_FILES
SGML_CATALOG_FILES=${SGML_ROOT}/html/catalog:$SGML_CATALOG_FILES
SGML_CATALOG_FILES=${SGML_ROOT}/docbook/catalog:$SGML_CATALOG_FILES
export SGML_CATALOG_FILES</programlisting>
	  </example>

	  <example>
	    <title><filename>.login</filename>, pour les utilisateurs de
              &man.csh.1; et &man.tcsh.1;</title>

	    <programlisting>
setenv SGML_ROOT /usr/local/share/xml
setenv SGML_CATALOG_FILES ${SGML_ROOT}/jade/catalog
setenv SGML_CATALOG_FILES ${SGML_ROOT}/iso8879/catalog:$SGML_CATALOG_FILES
setenv SGML_CATALOG_FILES ${SGML_ROOT}/html/catalog:$SGML_CATALOG_FILES
setenv SGML_CATALOG_FILES ${SGML_ROOT}/docbook/catalog:$SGML_CATALOG_FILES</programlisting>
          </example>

          <para>Déconnectez-vous et reconnectez-vous ensuite, ou exécutez ces
            commandes pour définir la variable d'environnement.</para>
	</step>

	<step>
	  <para>Créez un fichier <filename>exemple.xml</filename>, où vous
            mettrez&nbsp;:</para>

	  <programlisting>
<![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0
  Transitional//EN">

<html>
  <head>
    <title>Exemple de fichier HTML</title>
  </head>

  <body>
    <p>C'est un paragraphe avec du texte.</p>

    <p>C'est encore un paragraphe avec du texte.</p>


    <p align="right">Ce paragraphe sera peut-être justifié &agrave;
      droite.</p>
  </body>
</html>]]></programlisting>
	</step>

	<step>
	  <para>Essayez de le valider avec un analyseur syntaxique
            SGML.</para>

	  <para><link linkend="sgml-primer-validating">L'analyseur
              syntaxique</link> &man.nsgmls.1; fait partie de
            <filename>textproc/docproj</filename>. &man.nsgmls.1; lit
            normalement un document marqué en utilisant une DTD SGML et génère
            l'<foreignphrase>Element Structure Information Set
            (ESIS)</foreignphrase>&nbsp;-&nbsp;Informations sur la
            Structuration  en Eléments&nbsp;-&nbsp;mais cela ne nous concerne
            pas pour le moment.</para>

	  <para>Néanmoins, avec le paramètre <option>-s</option>,
            &man.nsgmls.1; ne génère rien mais affiche simplement les messages
            d'erreurs éventuels. C'est utile pour vérifier si votre document
            est correct ou non.</para>

	  <para>Utilisez &man.nsgmls.1; pour vérifier si votre document est
	    valide&nbsp;:</para>

          <screen>&prompt.user; <userinput>nsgmls -s example.xml</userinput></screen>

	  <para>Vous constaterez que &man.nsgmls.1; n'affiche rien. Cela
            signifie qu'il a validé votre document.</para>
	</step>

	<step>
	  <para>Voyez ce qui ce passe si vous oubliez un élément requis.
	    Supprimez les marques <tag>title</tag> et
	    <tag>/title</tag> et relancer la validation.</para>

          <screen>&prompt.user; <userinput>nsgmls -s example.xml</userinput>
nsgmls:example.xml:5:4:E: character data is not allowed here
nsgmls:example.xml:6:8:E: end tag for "HEAD" which is not finished</screen>

	  <para>Les messages d'erreur de &man.nsgmls.1; sont structurés en
            colonnes séparés par des deux-points ou des
            points-virgules.</para>

	  <informaltable frame="none">
	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry>Colonne</entry>
		  <entry>Signification</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>1</entry>
		  <entry>Nom du programme qui a généré l'erreur. Ce sera
                    toujours <literal>nsgmls</literal>.</entry>
		</row>

		<row>
		  <entry>2</entry>
		  <entry>Nom du fichier où se trouve l'erreur.</entry>
		</row>

		<row>
		  <entry>3</entry>
		  <entry>Numéro de la ligne où se trouve l'erreur.</entry>
		</row>

		<row>
		  <entry>4</entry>
		  <entry>Numéro de la colonne où se trouve l'erreur.</entry>
		</row>

		<row>
		  <entry>5</entry>
		  <entry>Une lettre donnant le type de message d'erreur.
		    <literal>I</literal> pour un message d'information,
                    <literal>W</literal> pour un message d'avertissement,
		    <literal>E</literal> pour un message d'erreur et
                    <literal>X</literal> pour les références croisées. (Ce
                    n'est cependant pas toujours la cinquième colonne.
                    <command>nsgmls -sv</command> affiche
                    <literal>nsgmls:I: SP version
                    "1.3"</literal>&nbsp;-&nbsp;selon la version installée.
                    Comme vous pouvez le constater, c'est un message
                    d'information.) Vous voyez donc que nous avons dans notre
                    exemple des messages d'erreurs.</entry>
		</row>

		<row>
		  <entry>6</entry>
		  <entry>Le texte du message d'erreur.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>

          <para><link xlink:href="http://www.cs.duke.edu/~dsb/kgv-faq/errors.html">Vous
              aurez plus d'informations sur les erreurs de
              &man.nsgmls.1;</link> dans la <link xlink:href="http://www.cs.duke.edu/~dsb/kgv-faq/">Unofficial 'Kindler,
              Gentler HTML Validator' FAQ</link>.</para>

	  <para>Ne pas mettre les marques <tag>title</tag> a généré
	    2 erreurs différentes.</para>

	  <para>La première erreur indique que l'analyseur SGML a rencontré un
            contenu (ici, des caractères, au lieu d'une marque de début
            d'élément) alors qu'il attendait autre chose. Dans le cas présent,
            l'analyseur attendait une marque de début pour un élément valide
            &agrave; l'intérieur de <tag>head</tag>
            (<tag>title</tag> par exemple).</para>

	  <para>La deuxième erreur est due au fait que les éléments
            <tag>head</tag> doivent contenir un élément
	    <tag>title</tag>. &man.nsgmls.1; considère alors que
            l'élément n'est pas complet. La marque de fin indique donc que
            l'élément se termine alors qu'il n'est pas correctement
            renseigné.</para>
	</step>

	<step>
	  <para>Remettez l'élément <literal>title</literal> en place.</para>
	</step>
      </procedure>
    </sect2>
  </sect1>

  <sect1 xml:id="sgml-primer-doctype-declaration">
    <title>La déclaration DOCTYPE</title>

    <para>Au début de chaque document que vous rédigez, vous devez préciser le
      nom de la DTD &agrave; laquelle le document se conforme. Cela pour que les
      analyseurs syntaxiques SGML la connaissent et puissent valider le
      document.</para>

    <para>Cette information est habituellement donnée sur une seule ligne,
      dans la déclaration DOCTYPE.</para>

    <para>Voici une déclaration typique pour un document conforme &agrave; la version
      4.0 de la DTD HTML&nbsp;:</para>

    <programlisting>
<![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//EN">]]></programlisting>

    <para>Cette ligne a plusieurs composants distincts&nbsp;:</para>

    <variablelist>
      <varlistentry>
	<term><literal>&lt;!</literal></term>

	<listitem>
	  <para>C'est l'<emphasis>indicateur</emphasis> qui dit que c'est une
            déclaration SGML. Cette ligne définit le type de document.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>DOCTYPE</literal></term>

	<listitem>
	  <para>Précise que c'est la déclaration SGML du type de
            document.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>html</literal></term>

	<listitem>
	  <para>Définit le premier <link linkend="sgml-primer-elements">élément</link> qui apparaîtra
            dans le document.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>PUBLIC "-//W3C//DTD HTML 4.0//EN"</literal></term>

	<listitem>
	  <para>Donne le <foreignphrase>Formal Public Identifier
            (FPI)</foreignphrase>&nbsp;-&nbsp;Identifiant Public
            Officiel&nbsp;-&nbsp;de la DTD &agrave; laquelle le document se
            conforme.</para>

	  <para><literal>PUBLIC</literal> n'appartient pas au FPI, mais
            indique au processeur SGML comment trouver la DTD référencée par
            le FPI. Les autres façons de dire &agrave; l'analyseur SGML comment
            trouver la DTD sont données <link linkend="sgml-primer-fpi-alternatives">plus loin</link>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>&gt;</literal></term>

	<listitem>
	  <para>Retour au document.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <sect2>
      <title><foreignphrase>Formal Public Identifiers
        (FPIs)</foreignphrase>&nbsp;-&nbsp;Identifiants Publics
        Officiels</title>

      <note>
	<para>Vous n'avez pas besoin de connaître ce qui suit, mais ce n'est
          n'est pas inutile, et cela peut vous aider &agrave; résoudre des problèmes,
          si votre processeur SGML ne trouve pas la DTD que vous
          utilisez.</para>
      </note>

      <para>Les FPIs doivent respecter une syntaxe précise. La
        voici&nbsp;:</para>

      <programlisting>
"<replaceable>Propriétaire</replaceable>//<replaceable>Mot-Clé</replaceable> <replaceable>Description</replaceable>//<replaceable>Langue</replaceable>"</programlisting>

      <variablelist>
	<varlistentry>
	  <term><replaceable>Propriétaire</replaceable></term>

	  <listitem>
	    <para>Indique qui détient le FPI.</para>

	    <para>Si la chaîne de caractères commence par &ldquo;ISO&rdquo;,
              c'est un FPI ISO. Par exemple, le FPI <literal>"ISO
		8879:1986//ENTITIES Greek Symbols//EN"</literal> donne
	      <literal>ISO 8879:1986</literal> comme propriétaire du jeu
              d'entités pour les lettres grecques. ISO 8879:1986 est le
              numéro ISO du standard SGML.</para>

	    <para>Sinon, cette chaîne sera de la forme
	      <literal>-//Propriétaire</literal> ou
	      <literal>+//Propriétaire</literal>
              (remarquez que la seule différence est le <literal>+</literal>
	      ou <literal>-</literal> du début).</para>

	    <para>Si la chaîne commence par un <literal>-</literal>, c'est que
              le propriétaire n'est pas enregistré, il l'est si elle commence
              par un <literal>+</literal>.</para>

	    <para>L'ISO 9070:1991 définit comment sont générés les noms
              enregistrés&nbsp;; ils peuvent dériver du numéro d'une
              publication ISO, d'un code ISBN ou d'un code d'organisation
              affecté selon l'ISO 6523. De plus, il pourrait y avoir une
              autorité d'enregistrement pour l'affectation de ces noms. Le
              conseil ISO a délégué cela &agrave; l'<foreignphrase>American National
              Standards Institute (ANSI)</foreignphrase>&nbsp;-&nbsp;Institut
              National Américain des Standards.</para>

	    <para>Comme le Projet FreeBSD n'est pas enregistré, la chaîne
	      utilisée est <literal>-//FreeBSD</literal>. Comme vous pouvez
              vous en rendre compte, le W3C n'est pas non plus un propriétaire
	      enregistré.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><replaceable>Mot-Clé</replaceable></term>

	  <listitem>
	    <para>Il y a plusieurs mots-clés qui définissent le type
              d'information dans le fichier. Les mots-clés les plus courants
              sont&nbsp;: <literal>DTD</literal>, <literal>ELEMENT</literal>,
	      <literal>ENTITIES</literal> et <literal>TEXT</literal>.
	      <literal>DTD</literal> ne sert que pour les DTD,
	      <literal>ELEMENT</literal> sert habituellement pour les extraits
              de DTD qui ne contiennent que des entités ou des déclarations
              d'éléments. <literal>TEXT</literal> sert pour le contenu SGML
              (texte et marques).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><replaceable>Description</replaceable></term>

	  <listitem>
	    <para>La description que vous souhaitez donner du contenu du
              fichier. Cela peut inclure des numéros de version et n'importe
              quel texte court qui ait un sens et soit unique au système
              SGML.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><replaceable>Langue</replaceable></term>

	  <listitem>
	    <para>C'est une code ISO de deux caractères qui identifie la
              langue utilisée dans le fichier. Pour l'anglais, c'est
              <literal>EN</literal>.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <sect3>
	<title>Fichiers <filename>catalog</filename></title>

	<para>Si vous avez utilisé la syntaxe décrite plus haut et essayé
          d'utiliser un processeur SGML pour traiter votre document, il aura
          besoin de convertir le FPI en un nom de fichier sur votre ordinateur
          qui décrive la DTD.</para>

        <para>Vous pouvez pour cela vous servir d'un fichier catalogue
	  (habituellement appelé <filename>catalog</filename>). Il contient
          des lignes qui donnent les correspondances entre FPIs et noms de
          fichiers. Par exemple, s'il y a la ligne&nbsp;:</para>

	<programlisting>
PUBLIC "-//W3C//DTD HTML 4.0//EN" "4.0/strict.dtd"</programlisting>

	<para>le processeur SGML cherchera la DTD dans le fichier
	  <filename>strict.dtd</filename> du sous-répertoire
          <filename>4.0</filename> où se trouve le fichier
	  <filename>catalog</filename> qui comporte cette ligne.</para>

	<para>Jettez un oeil au fichier
	  <filename>/usr/local/share/xml/html/catalog</filename>. C'est le
          fichier catalogue pour les DTDs HTML qui ont été installées par le
	  logiciel porté <filename>textproc/docproj</filename>.</para>
      </sect3>

      <sect3>
	<title><envar>SGML_CATALOG_FILES</envar></title>

	<para>Pour trouver un fichier <filename>catalog</filename>, votre
          processeur SGML doit savoir où chercher. La plupart d'entre eux ont
          des paramètres de leur ligne de commande pour donner le chemin
          d'accès &agrave; un ou plusieurs catalogues.</para>

	<para>Vous pouvez par ailleurs définir
          <envar>SGML_CATALOG_FILES</envar> pour désigner ces fichiers. Cette
          variable d'environnement doit contenir une liste de fichiers
          catalogues (donnés par leurs chemins d'accès complets) séparés par
          des points-virgules.</para>

	<para>Habituellement, vous incluerez les fichiers
          suivants&nbsp;:</para>

	<itemizedlist>
	  <listitem>
	    <para><filename>/usr/local/share/xml/docbook/catalog</filename></para>
	  </listitem>

	  <listitem>
	    <para><filename>/usr/local/share/xml/html/catalog</filename></para>
	  </listitem>

	  <listitem>
	    <para><filename>/usr/local/share/xml/iso8879/catalog</filename></para>
	  </listitem>

	  <listitem>
	    <para><filename>/usr/local/share/xml/jade/catalog</filename></para>
	  </listitem>
	</itemizedlist>

<!--
	<para>Vous devriez <link linkend="sgml-primer-envars">déj&agrave; l'avoir
	    fait</link>.</para>
-->
      </sect3>
    </sect2>

    <sect2 xml:id="sgml-primer-fpi-alternatives">
      <title>Alternatives aux FPIs</title>

      <para>Au lieu d'utiliser un FPI pour préciser la DTD utilisée (et donc
        le fichier qui contient la DTD), il est possible de donner
        explicitement le nom du fichier.</para>

      <para>La syntaxe pour le faire est légèrement différente&nbsp;:</para>

      <programlisting>
<![CDATA[<!DOCTYPE html SYSTEM "/path/to/file.dtd">]]></programlisting>

      <para>Le mot-clé <literal>SYSTEM</literal> indique que le processeur
        SGML doit localiser le fichier d'une façon qui dépend du système. Cela
        signifie habituellement (mais pas toujours) que la DTD sera définie
        par un nom de fichier.</para>

      <para>Il est préférable d'utiliser des FPIs pour des raisons de
        portabilité. Vous ne voulez pas livrer un exemplaire de la DTD avec
        votre document, et si vous avez utilisé l'identifiant
        <literal>SYSTEM</literal>, il faudra que chacun ait ses DTDs aux mêmes
	endroits.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="sgml-primer-sgml-escape">
    <title>Revenir au SGML</title>

    <para>On a dit plus haut dans cette introduction que le SGML n'était
      utilisé que pour écrire les DTDs. Ce n'est pas tout &agrave; fait vrai. Il y a
      des éléments de la syntaxe SGML que vous voudrez pouvoir utiliser dans
      vos documents. Par exemple, vous pouvez y inclure des commentaires, qui
      seront ignorés par les analyseurs. Les commentaires sont inclus en
      utilisant une syntaxe SGML. D'autres utilisations du SGML dans les
      documents seront mentionnées plus loin.</para>

    <para>Il vous faut évidemment un moyen d'indiquer au processeur SGML que
      ce qui va suivre n'est pas constitué d'éléments du document, mais est du
      SGML que le processeur doit prendre en compte.</para>

    <para>Ces sections sont marqués avec <literal>&lt;! ...  &gt;</literal>
      dans votre document. Tout ce qui se trouve entre ces délimiteurs est du
      code SGML comme on en trouve dans les DTDs.</para>

    <para>Comme vous venez peut-être de vous en rendre compte, la <link linkend="sgml-primer-doctype-declaration">déclaration DOCTYPE</link>
      est un exemple de syntaxe SGML que vous devez inclure dans votre
      document&hellip;</para>
  </sect1>

  <sect1>
    <title>Commentaires</title>
    &sgml.todo;

    <para>Les commentaires suivent une syntaxe SGML et ne sont normalement
      autorisés que dans une DTD. Cependant comme la
      <xref linkend="sgml-primer-sgml-escape"/> le montre, il est possible
      d'inclure du SGML dans vos documents.</para>

    <para>Les délimiteurs pour les commentaires SGML sont constitués de la
      chaîne de caractères &ldquo;<literal>--</literal>&rdquo;. Une première
      occurence ouvre le commentaire, et la seconde le ferme.</para>

    <example>
      <title>Commentaire SGML générique</title>

      <programlisting>
<!-- commentaire de test --></programlisting>

      <programlisting>
&lt;!&hyphen;- C'est le texte du commentaire -&hyphen;&gt;

&lt;!&hyphen;- C'est un autre commentaire -&hyphen;&gt;

&lt;!&hyphen;- Voici une façon de mettre un commentaire
     sur plusieurs lignes -&hyphen;&gt;

&lt;!&hyphen;- Voici une autre façon -&hyphen;
  &hyphen;- de le faire -&hyphen;&gt;</programlisting>
    </example>

    <para>Si vous avez déj&agrave; utilisé HTML auparavant, on vous a peut-être
      donné des règles différentes pour les commentaires. En particulier, vous
      pensez peut-être qu'ils commencent par <literal>&lt;!--</literal> et
      ne se terminent qu'avec <literal>--&gt;</literal>.</para>

    <para>Ce n'est <emphasis>pas</emphasis> le cas. Les analyseurs syntaxiques
      de nombreux navigateurs sont défectueux et acceptent cette syntaxe. Ceux
      qu'utilisent le Projet de Documentation sont plus rigoureux et
      rejetteront les documents qui comportent cette erreur.</para>

    <example>
      <title>Commentaires SGML erronnés</title>

      <programlisting>
&gt;!&hyphen;- C'est en commentaire -&hyphen;

     CE N'EST PAS EN COMMENTAIRE!

  &hyphen;- retour au commentaire -&hyphen;&gt;</programlisting>

      <para>L'analyseur SGML traitera cela comme s'il trouvait&nbsp;:</para>

      <programlisting>
&lt;!CE N'EST PAS EN COMMENTAIRE&gt;</programlisting>

      <para>Ce qui n'est pas du SGML valide et donnera des messages d'erreur
        source de confusion.</para>

      <programlisting>&lt;!&hyphen;&hyphen;&hyphen;&hyphen;&hyphen; C'est un très mauvaise idée &hyphen;&hyphen;&hyphen;&hyphen;&hyphen;&gt;</programlisting>

      <para>Comme l'exemple le suggère, ne mettez <emphasis>pas</emphasis> de
        commentaires de ce type.</para>

      <programlisting>&lt;!&hyphen;-===================================================-&hyphen;&gt;</programlisting>

      <para>C'est une (légèrement) meilleure idée, mais c'est toute de même
        une source de confusion potentielle pour les débutants en SGML.</para>
    </example>

    <sect2>
      <title>A faire&hellip;</title>

      <procedure>
	<step>
	  <para>Ajoutez des commentaires &agrave; <filename>exemple.xml</filename>
            et validez vos modifications avec &man.nsgmls.1;</para>
	</step>

	<step>
	  <para>Ajoutez des commentaires incorrects &agrave;
	    <filename>exemple.xml</filename>, pour voir quels messages
            d'erreur produit alors &man.nsgmls.1;.</para>
	</step>
      </procedure>
    </sect2>
  </sect1>

  <sect1>
    <title>Entités</title>

    <para>Les entités fournissent un mécanisme pour désigner des parties d'un
      contenu. Lorsque l'analyseur SGML traite votre document, il remplace les
      entités qu'il rencontre par le contenu de ces entités.</para>

    <para>C'est un bon moyen pour avoir du texte réutilisable et facile &agrave;
      modifier. C'est aussi le seul moyen d'inclure, en utilisant SGML, un
      fichier marqué dans un autre.</para>

    <para>Il y a deux sortes d'entités SGML qui s'utilisent dans des
      situations différentes&nbsp;: les <emphasis>entités générales</emphasis>
      et les <emphasis>entités paramètres</emphasis>.</para>

    <sect2 xml:id="sgml-primer-general-entities">
      <title>Entités Générales</title>

      <para>Vous ne pouvez pas employer les entités générales dans un contexte
        SGML (bien que ce soit l&agrave; que vous les définissiez). Elles ne peuvent
        être utilisées que dans votre document. Comparez cela au cas des
	<link linkend="sgml-primer-parameter-entities">entités
	  paramètres</link>.</para>

      <para>Chaque entité générale a un nom. Quand vous voulez y faire
        référence (et donc inclure le texte qu'elle contient dans votre
        document), vous mettez
	<literal>&amp;nom-de-l'entité;</literal>.
        Supposons par exemple que vous ayez une entité appelée
	<literal>version.courante</literal> qui contienne le numéro de version
        courante de votre produit. Vous pourriez écrire&nbsp;:</para>

      <programlisting>
<![CDATA[<para>La version courante de notre produit est la
  &version.courante;.</para>]]></programlisting>

      <para>Quand le numéro de version change, il vous suffit de modifier la
        définition de l'entité générale et de recompiler votre
        document.</para>

      <para>Vous pouvez aussi vous servir d'entités générales pour représenter
        des caractères que vous ne pouvez pas inclure autrement dans un
        document SGML. &lt; et &amp;, par exemple, ne doivent normalement pas
        apparaître dans un document SGML. Quand l'analyseur SGML rencontre un
        symbole &lt;, il suppose qu'il précède une marque (de début ou de
        fin), et quand il rencontre un symbole &amp;, il suppose que le texte
        qui le suit est le nom d'une entité.</para>

      <para>Heureusement, il y a deux entités générales, &amp;lt; et
	&amp;amp; pour le cas où vous auriez besoin d'inclure l'un ou l'autre
        de ces symboles.</para>

      <para>Une entité générale ne peut être définie que dans un contexte
        SGML. On le fait habituellement immédiatement après la déclaration
        DOCTYPE.</para>

      <example>
	<title>Définition d'entités générales</title>

	<programlisting>
<![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//EN" [
<!ENTITY version.courante    "3.0-RELEASE">
<!ENTITY derniere.version  "2.2.7-RELEASE">
]>]]></programlisting>

	<para>Remarquez que la déclaration DOCTYPE est suivie d'un crochet
          ouvrant &agrave; la fin de la première ligne. Les deux entités sont
          définies aux deux lignes suivantes, avant le crochet fermant. La
          déclaration DOCTYPE se termine ensuite.</para>

	<para>Les crochets sont nécessaires pour dire que nous ajoutons un
          complément &agrave; la DTD mentionnée par la déclaration DOCTYPE.</para>
      </example>
    </sect2>

    <sect2 xml:id="sgml-primer-parameter-entities">
      <title>Entités paramètres</title>

      <para>Comme les <link linkend="sgml-primer-general-entities">entités
	  générales</link>, les entités paramètres servent &agrave; nommer des
        parties réutilisables du texte. Cependant, alors que les entités
        générales peuvent être utilisées dans le corps du document, les
        entités paramètres ne peuvent être employées que dans un
	<link linkend="sgml-primer-sgml-escape">contexte SGML</link>.</para>

      <para>Les entités paramètres sont définies de la même manière que les
        entités générales. Sinon qu'au lieu de vous servir de
        <literal>&amp;inomd-de-l'entité;</literal>
        pour y faire référence, vous utiliserez
	<literal>%nom-de-l'entité;</literal><footnote>
	  <para>Les entités <emphasis>P</emphasis>aramètres employent le
	    symbole <emphasis>P</emphasis>ourcent.</para>
	</footnote>. Leur définition comporte aussi un <literal>%</literal>
        entre le mot-clé <literal>ENTITY</literal> et le nom de
        l'entité.</para>

      <example>
	<title>Définition d'entités paramètres</title>

	<programlisting>
<![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//EN" [
<!ENTITY % param.du "du">
<!ENTITY % param.texte "text">
<!ENTITY % param.encore  "encore %param.du more %param.texte">
]>]]></programlisting>
      </example>

      <para>Cela ne paraît peut être pas très utile. On verra pourtant que ça
        l'est.</para>
    </sect2>

    <sect2>
      <title>A faire&hellip;</title>

      <procedure>
	<step>
	  <para>Définissez un entité générale dans
	    <filename>exemple.xml</filename>.</para>

	  <programlisting>
<![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" [
<!ENTITY version "1.1">
]>

<html>
  <head>
    <title>Exemple de fichier HTML</title>
  </head>

  <body>
    <p>C'est un paragraphe avec du texte.</p>

    <p>C'est encore un paragraphe avec du texte.</p>

    <p align="right">Ce paragraphe sera peut-être justifié &agrave;
      droite</p>

    <p>La version courante de ce document est : &version;</p>
  </body>
</html>]]></programlisting>
	</step>

	<step>
	  <para>Validez le document avec &man.nsgmls.1;</para>
	</step>

	<step>
	  <para>Chargez <filename>exemple.xml</filename> avec votre
            navigateur (vous devrez peut-être le recopier dans
	    <filename>exemple.html</filename> pour que votre navigateur le
            reconnaisse comme un document HTML).</para>

	  <para>A moins que votre navigateur ne soit très évolué, il ne
            remplacera pas la référence <literal>&amp;version;</literal>
            &agrave; l'entité par le numéro de version. Les analyseurs de la plupart
            des navigateurs sont élémentaires et ne gèrent pas correctement
	    le SGML<footnote><para>C'est tout &agrave; fait dommage. Imaginez les
            problèmes et bricolages (comme les <foreignphrase>Server Side
              Includes</foreignphrase>) que cela
            éviterait.</para></footnote>.</para>
	</step>

	<step>
	  <para>La solution est de <emphasis>normaliser</emphasis> votre
            document avec un outil de normalisation du SGML. Ce type d'outil
            lit un document SGML valide et le transforme en un autre document
            SGML tout aussi valide. En particulier, il y remplace les
            références aux entités par leur contenu.</para>

	  <para>Vous pouvez le faire avec &man.xmlnorm.1;.</para>

          <screen>&prompt.user; <userinput>sgmlnorm exemple.xml &gt; exemple.html</userinput></screen>

	  <para><filename>exemple.html</filename> doit maintenant contenir une
            version normalisée (i.e., où les références aux entités ont été
            remplacées par leur contenu) de votre document, prête &agrave; être
            affichée par votre navigateur.</para>
	</step>

	<step>
	  <para>Si vous jetez un oeil au résultat de &man.xmlnorm.1;, vous
            verrez qu'il ne comporte pas de déclaration DOCTYPE au début. Pour
            qu'elle y soit, utilisez l'option
            <option>-d</option>&nbsp;:</para>

          <screen>&prompt.user; <userinput>sgmlnorm -d exemple.xml &gt; exemple.html</userinput></screen>
	</step>
      </procedure>
    </sect2>
  </sect1>

  <sect1>
    <title>Utiliser les entités pour inclure des fichiers</title>

    <para>Les entités (<link linkend="sgml-primer-general-entities">générales</link> et <link linkend="sgml-primer-parameter-entities">paramètres</link>) sont
      particulièrement utiles pour inclure un fichier dans un autre.</para>

    <sect2 xml:id="sgml-primer-include-using-gen-entities">
      <title>Utiliser les entités générales pour inclure des fichiers</title>

      <para>Supposons que le contenu d'un livre SGML soit découpé en fichiers,
        &agrave; raison d'un fichier par chapitre, appelés
	<filename>chaptitre1.xml</filename>,
	<filename>chapitre2.xml</filename>, et ainsi de suite, et que le
        fichier <filename>livre.xml</filename> inclue ces chapitres.</para>

      <para>Pour que vos entités aient pour valeur le contenu de ces fichiers,
        vous les déclarerez avec le mot-clé <literal>SYSTEM</literal>. Cela
        indique &agrave; l'analyseur SGML qu'il doit utiliser le contenu du fichier
        mentionné comme valeur de l'entité.</para>

      <example>
        <title>Utiliser les entités générales pour inclure des
          fichiers</title>

	<programlisting>
<![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//EN" [
<!ENTITY chapitre.1 SYSTEM "chapitre1.xml">
<!ENTITY chapitre.2 SYSTEM "chapitre2.xml">
<!ENTITY chapitre.3 SYSTEM "chapitre3.xml">
]>

<html>
  &chapitre.1;
  &chapitre.2;
  &chapitre.3;
</html>]]></programlisting>
      </example>

      <warning>
	<para>Quand vous vous servez d'entités générales pour inclure d'autres
          fichiers dans un document, les fichiers inclus
	  (<filename>chapitre1.xml</filename>,
	  <filename>chapitre2.xml</filename>, et ainsi de suite)  ne doivent
          <emphasis>pas</emphasis> commencer par une déclaration DOCTYPE. Ce
          serait une erreur de syntaxe.</para>
      </warning>
    </sect2>

    <sect2>
      <title>Utiliser les entités paramètres pour inclure des fichiers</title>

      <para>Rappelez-vous que les entités paramètres ne peuvent être utilisées
        que dans un contexte SGML. Quand aurez-vous besoin d'inclure un
        fichier dans un contexte SGML&nbsp;?</para>

      <para>Vous pouvez vous en servir pour être sûr de pouvoir réutiliser vos
        entités générales.</para>

      <para>Supposons que votre document comporte de nombreux chapitres, et
        que vous réutilisiez ces chapitres dans deux livres différents, chacun
        organisant ces chapitres de façon différente.</para>

      <para>Vous pourriez donner la liste des entités en tête de chaque livre,
        mais cela pourrait rapidement devenit fastidieux &agrave; gérer.</para>

      <para>Mettez, au lieu de cela, les définitions des entités générales
        dans un fichier, et utilisez une entité paramètre pour inclure ce
        fichier dans votre document.</para>

      <example>
        <title>Utiliser les entités paramètres pour inclure des
          fichiers</title>

	<para>Mettez d'abord les définitions de vos entités dans un fichier
          séparé, appelé <filename>chapitres.ent</filename>. Voici ce qu'il
          contiendra&nbsp;:</para>

	<programlisting>
<![CDATA[<!ENTITY chapitre.1 SYSTEM "chapitre1.xml">
<!ENTITY chapitre.2 SYSTEM "chapitre2.xml">
<!ENTITY chapitre.3 SYSTEM "chapitre3.xml">]]></programlisting>

	<para>Créez maintenant une entité paramètre qui fasse référence au
          contenu de ce fichier. Utilisez ensuite cette entité pour inclure
          le fichier dans votre document, vous pourrez alors y utiliser les
          entités générales. Ce que vous faites de la même façon que
          précédemment&nbsp;:</para>

	<programlisting>
<![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//EN" [
<!ENTITY % chapitres SYSTEM "chapitres.ent">
%chapitres;
]>

<html>
  &chapitre.1;
  &chapitre.2;
  &chapitre.3;
</html>]]></programlisting>
      </example>
    </sect2>

    <sect2>
      <title>A faire&hellip;</title>

      <sect3>
	<title>Utiliser les entités générales pour inclure des fichiers</title>

	<procedure>
	  <step>
	    <para>Créez trois fichiers, <filename>para1.xml</filename>,
	      <filename>para2.xml</filename> et
	      <filename>para3.xml</filename>.</para>

	    <para>Mettez-y quelque chose qui ressemble &agrave; ceci&nbsp;:</para>

	    <programlisting>
<![CDATA[<p>C'est le premier paragraphe.</p>]]></programlisting>
	  </step>

	  <step>
	    <para>Modifiez <filename>exemple.xml</filename> de la façon
              suivante&nbsp;:</para>

	    <programlisting>
<![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//EN" [
<!ENTITY version "1.1">
<!ENTITY para1 SYSTEM "para1.xml">
<!ENTITY para2 SYSTEM "para2.xml">
<!ENTITY para3 SYSTEM "para3.xml">
]>

<html>
  <head>
    <title>Exemple de fichier HTML</title>
  </head>

  <body>
    <p>La version courante de ce document est : &version;</p>

    &para1;
    &para2;
    &para3;
  </body>
</html>]]></programlisting>
	  </step>

	  <step>
	    <para>Générez <filename>exemple.html</filename> en normalisant
	      <filename>exemple.xml</filename>.</para>

            <screen>&prompt.user; <userinput>sgmlnorm -d exemple.xml &gt; exemple.html</userinput></screen>
	  </step>

	  <step>
	    <para>Affichez <filename>exemple.html</filename> avec votre
              navigateur Web et vérifiez que les fichiers
	      <filename>paran.xml</filename> ont
	      bien été inclus dans <filename>exemple.html</filename>.</para>
	  </step>
	</procedure>
      </sect3>

      <sect3>
       <title>Utiliser les entités paramètres pour inclure des
         fichiers</title>

	<note>
	  <para>Vous devez d'abord avoir mis en pratique l'exemple
            précédent.</para>
	</note>

	<procedure>
	  <step>
            <para>Modifiez comme ceci
              <filename>exemple.xml</filename>&nbsp;:</para>

	    <programlisting>
<![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//EN" [
<!ENTITY % entites SYSTEM "entites.xml"> %entites;
]>

<html>
  <head>
    <title>Exemple de fichier HTML</title>
  </head>

  <body>
    <p>La version courant de ce document est : &version;</p>

    &para1;
    &para2;
    &para3;
  </body>
</html>]]></programlisting>
	  </step>

	  <step>
	    <para>Créez un nouveau fichier, <filename>entites.xml</filename>,
	      qui contienne&nbsp;:</para>

	    <programlisting>
<![CDATA[<!ENTITY version "1.1">
<!ENTITY para1 SYSTEM "para1.xml">
<!ENTITY para2 SYSTEM "para2.xml">
<!ENTITY para3 SYSTEM "para3.xml">]]></programlisting>
	  </step>

	  <step>
	    <para>Générez <filename>exemple.html</filename> en normalisant
	      <filename>exemple.xml</filename>.</para>

            <screen>&prompt.user; <userinput>sgmlnorm -d exemple.xml &gt; exemple.html</userinput></screen>
	  </step>

	  <step>
	    <para>Affichez <filename>exemple.html</filename> avec votre
              navigateur Web et vérifiez que les fichiers
	      <filename>paran.xml</filename> ont
	      bien été inclus dans <filename>example.html</filename>.</para>
	  </step>
	</procedure>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="sgml-primer-marked-sections">
    <title>Sections marquées</title>

    <para>SGML fournit un mécanisme pour définir quelles parties d'un document
      doivent être traitées de façon particulière. On appelle cela des
      &ldquo;sections marquées&rdquo;.</para>

    <example>
      <title>Structure d'une section marquée</title>

      <programlisting>
&lt;![ <replaceable>MOT-CLE</replaceable> [
  Contenu de la section marquée
]]&gt;</programlisting>
    </example>

    <para>Comme vous pouviez vous y attendre, une section marquée est une
      fonctionnalité SGML et commence donc par <literal>&lt;!</literal>.</para>

    <para>Le premier crochet ouvrant délimite la section marquée.</para>

    <para>Le <replaceable>MOT-CLE</replaceable> définit comment cette section
      marquée doit être traitée par l'analyseur.</para>

    <para>Le second crochet ouvrant indique que le contenu de la section
      marquée commence l&agrave;.</para>

    <para>La section marquée se termine par deux crochets fermants, puis un
      <literal>&gt;</literal> pour indiquer que l'on quitte le contexte SGML
      et que l'on revient au document.</para>

    <sect2>
      <title>Mots-clés pour les sections marquées</title>

      <sect3>
	<title><literal>CDATA</literal>, <literal>RCDATA</literal></title>

	<para>Ces deux mots-clés définissent des sections marquées comme
          <emphasis>modèle de contenu</emphasis> et vous permettent de
          modifier sa valeur par défaut.</para>

	<para>Quand un analyseur SGML traite un docuemnt, il mémorise ce que
          l'on appelle le &ldquo;modèle de contenu&rdquo;.</para>

	<para>En bref, le modèle de contenu décrit ce que l'analyseur doit
          s'attendre &agrave; trouver comme contenu, et ce qu'il doit en faire quand
          il le rencontre.</para>

	<para>Les deux modèles de contenu que vous trouverez certainement les
          plus utiles sont <literal>CDATA</literal> et
          <literal>RCDATA</literal>.</para>

	<para><literal>CDATA</literal> signifie
          &ldquo;<foreignphrase>Character
          Data</foreignphrase>&rdquo;&nbsp;-&nbsp;données caractères. Si
          l'analyseur est &agrave; l'intérieur de ce modèle de contenu, il s'attend
          &agrave; trouver des caractères, et uniquement des caractères. Les
          symboles &lt; et &amp; perdent alors leur signification particulière
          et sont traités comme de simples caractères.</para>

	<para><literal>RCDATA</literal> signifie &ldquo;Références &agrave; des
          entités et données caractères&rdquo;.  Si l'analyseur est &agrave;
          l'intérieur de ce modèle de contenu, il s'attend &agrave; trouver des
          caractères <emphasis>et</emphasis> des entités. &lt; perd sa
          signification particulière, mais &amp; est toujours compris comme le
          début d'une entité générale.</para>

	<para>C'est particulièrement utile si vous incluez du texte qui
          contient de nombreux caractères &lt; et &amp;. Vous pourriez bien
          sûr contrôler que dans votre texte tous les &lt; sont écrits
          &amp;lt; et tous les &amp; &amp;amp;, il peut être plus facile
          de marquer la section comme ne contenant que des
          &ldquo;CDATA&rdquo;. Quand SGML rencontre l'instruction
          correspondante, il ignorera les symboles &lt; et &amp; qui
          apparaîtront dans le contenu.</para>

	<!-- The nesting of CDATA within the next example is disgusting -->

	<example>
	  <title>Utiliser une section marquée CDATA</title>

	  <programlisting>
&lt;para&gt;Voici un exemple de la façon dont vous pourriez inclure
  un texte comportant de nombreux &amp;lt; et &amp;amp;. L'exemple
  lui-même est en HTML. Le texte qui l'encadre (&lt;para&gt; et
  &lt;programlisting&gt;) est du DocBook.&lt;/para&gt;

&lt;programlisting&gt;
  &lt;![CDATA[<![CDATA[
    <p>Cet exemple vous montre quelques éléments de HTML. Comme les
      caractères < et > y sont si fréquemment utilisés, il est plus
      facile de marquer tout l'exemple comme CDATA plutôt que de se
      servir des entités &agrave; la place de ces caractères dans tout le
      texte.</p>

    <ul>
      <li>C'est un élément de liste</li>
      <li>C'est un second élément de liste</li>
      <li>C'est un troisième élément de liste</li>
    </ul>

    <p>C'est la fin de l'exemple.</p>]]>
  ]]&gt;
&lt;/programlisting&gt;</programlisting>

	  <para>Si vous consultez le source de ce document, vous verrez qu'il
            utilise constamment cette technique.</para>
	</example>
      </sect3>

      <sect3>
	<title><literal>INCLUDE</literal> et <literal>IGNORE</literal></title>

	<para>Si le mot-clé est <literal>INCLUDE</literal>, alors le contenu
          de la section marquée sera pris en compte. Si le mot-clé est
	  <literal>IGNORE</literal>, alors la section marquée sera ignorée. Il
	  n'apparaîtra pas dans les sorties.</para>

	<example>
	  <title>Utiliser <literal>INCLUDE</literal> et
            <literal>IGNORE</literal> dans les sections marquées</title>

	  <programlisting>
&lt;![ INCLUDE [
  Ce texte sera traité et inclus.
]]&gt;

&lt;![ IGNORE [
  Ce texte ne sera pas traité ou inclus.
]]&gt;</programlisting>
	</example>

	<para>En soi, cela ne sert pas &agrave; grand-chose. Si vous vouliez
          supprimer du texte de votre document, vous auriez pu l'enlever ou le
          mettre en commentaires.</para>

	<para>Cela devient plus utile quand vous comprenez que vous pouvez
          vous servir des <link linkend="sgml-primer-parameter-entities">entités paramètres</link>
          pour contrôler ces sections. Rappelez-vous que les entités
          paramètres ne peuvent être utilisées que dans un contexte SGML, et
          une section marquée <emphasis>est</emphasis> un contexte SGML.</para>

	<para>Si par exemple, vous générez une version imprimée et une version
          électronique de votre document, vous pourriez vouloir inclure dans
          la version électronique un contenu supplémentaire qui ne devra pas
          apparaître dans la version imprimée.</para>

	<para>Créez une entité paramètre et donnez lui comme contenu
	  <literal>INCLUDE</literal>. Rédigez votre document en utilisant des
          sections marquées pour délimiter le contenu qui ne doit apparaître
          que dans la version électronique. Dans ces sections marquées,
          servez-vous de l'entité paramètre au lieu du mot-clé.</para>

	<para>Lorsque vous voulez générer la version électronique, changez la
          valeur de l'entité paramètre en <literal>IGNORE</literal> et
          retraitez le document.</para>

	<example>
	  <title>Utiliser une entité paramètre pour contrôler une section
	    marquée</title>

	  <programlisting>
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//EN" [
&lt;!ENTITY % version.electronique "INCLUDE"&gt;
]]&gt;

...

&lt;![ %version.electronique [
  Ce texte ne doit apparaître que dans
  la version électronique du document.
]]&gt;</programlisting>

	  <para>Pour générer la version imprimée, changez la définition de
            l'entité en&nbsp;:</para>

	  <programlisting>
&lt;!ENTiTY % version.electronique "IGNORE"&gt;</programlisting>

	  <para>A la seconde passe sur le document, les sections marquées qui
            utilisent <literal>%version.electronique</literal> comme mot-clé
            seront ignorées.</para>
	</example>
      </sect3>
    </sect2>

    <sect2>
      <title>A faire&hellip;</title>

      <procedure>
	<step>
	  <para>Créez un nouveau fichier, <filename>section.xml</filename>,
            qui contienne&nbsp;:</para>

	  <programlisting>
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//EN" [
&lt;!ENTITY % text.output "INCLUDE"&gt;
]&gt;

&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Exemple d'utilisation des sections marquées&lt;/title&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;p&gt;Ce paragraphe &lt;![CDATA[contient de nombreux
      caractères &lt; (&lt; &lt; &lt; &lt; &lt;) il est donc
      plus facile de l'inclure dans une section marquée
      CDATA ]]&gt;&lt;/p&gt;

    &lt;![IGNORE[
    &lt;p&gt;Ce paragraphe n'apparaîtra jamais dans les
      sorties.&lt;/p&gt;
    ]]&gt;

    &lt;![ <![CDATA[%sortie.texte]]> [
    &lt;p&gt;Ce paragraphe apparaîtra peut-être dans les
      sorties.&lt;/p&gt;

    &lt;p&gt;Cela dépend de l'entité paramètre
      <![CDATA[%sortie.texte]]>.&lt;/p&gt;
    ]]&gt;
  &lt;/body&gt;
&lt;/html&gt;</programlisting>
	</step>

	<step>
	  <para>Normalisez le fichier avec &man.xmlnorm.1; et examinez le
            résultat. Notez quels paragraphes ont été conservés et quels
            paragraphes ont été supprimés, et ce qu'est devenu le contenu des
            sections marquées CDATA.</para>
	</step>

	<step>
	  <para>Modifiez la définition de l'entité
            <literal>sortie.texte</literal> de <literal>INCLUDE</literal> en
	    <literal>IGNORE</literal>. Normalisez de nouveau le fichier et
            regardez ce qui a changé dans le résultat.</para>
	</step>
      </procedure>
    </sect2>
  </sect1>

  <sect1>
    <title>Conclusion</title>

    <para>Ici se termine cette introduction &agrave; SGML. Pour des raisons de place
      et de complexité, de nombreux points ont été survolés (voire omis).
      Les sections qui précédent décrivent néanmoins suffisamment d'éléments
      du SGML pour vous permettre de comprendre comment est organisée la
      documentation du FDP.</para>
  </sect1>
</chapter>
