<?xml version="1.0" encoding="koi8-r"?>
<!DOCTYPE book PUBLIC "-//FreeBSD//DTD DocBook XML V5.0-Based Extension//EN"
	"http://www.FreeBSD.org/XML/share/xml/freebsd50.dtd" [
<!ENTITY values.uses SYSTEM "uses.xml">
<!ENTITY values.versions SYSTEM "versions.xml">
]>
<!--
     The FreeBSD Russian Documentation Project

     $FreeBSD$
     $FreeBSDru: frdp/doc/ru_RU.KOI8-R/books/porters-handbook/book.xml,v 1.136 2006/10/20 09:25:00 marck Exp $

     Original revision: r42833
-->
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="ru">
  <info><title>Руководство FreeBSD по созданию портов</title>
    

    <authorgroup>
      <author><orgname>The FreeBSD Documentation Project</orgname></author>
    </authorgroup>

    <pubdate>$FreeBSD$</pubdate>

    <copyright>
      <year>2000</year>
      <year>2001</year>
      <year>2002</year>
      <year>2003</year>
      <year>2004</year>
      <year>2005</year>
      <year>2006</year>
      <year>2007</year>
      <year>2008</year>
      <year>2009</year>
      <year>2010</year>
      <year>2011</year>
      <year>2012</year>
      <year>2013</year>
      <holder role="mailto:doc@FreeBSD.org">
        The FreeBSD Documentation Project</holder>
    </copyright>

    &trademarks;

    &legalnotice;

    <releaseinfo>$FreeBSD$</releaseinfo>
  </info>

  <chapter xml:id="why-port">
    <title>Введение</title>

    <para>Коллекция портов FreeBSD является способом, используемым
      практически каждым для установки приложений ("портов") на FreeBSD.
      Как и почти всё остальное во FreeBSD, эта система в основном является
      добровольно поддерживаемым начинанием.  Важно иметь это в виду при
      чтении данного документа.</para>

    <para>Во FreeBSD любой может прислать новый порт либо изъявить желание
      поддерживать существующий порт, если его никто ещё никто не
      поддерживает&mdash;вам не нужно иметь никаких особых привилегий на
      внесение изменений, чтобы это делать.</para>
  </chapter>

  <chapter xml:id="own-port">
    <title>Как самому сделать новый порт</title>

    <para>Итак, вы интересуетесь, как создать собственный порт или
      обновить существующий?  Великолепно!</para>

    <para>Ниже находятся некоторые указания по созданию нового порта для
      FreeBSD.	Если вы хотите обновить существующий порт, вы должны
      прочесть их, а затем <xref linkend="port-upgrading"/>.</para>

    <para>Если этот документ недостаточно подробен, вы должны обратиться к
      файлу <filename>/usr/ports/Mk/bsd.port.mk</filename>, который
      включается в make-файл каждого порта.  Он хорошо прокомментирован, и
      даже если вы не занимаетесь хакингом make-файлов каждодневно,  из него
      вы сможете узнать много нового.  Кроме того, конкретные вопросы можно
      задать, послав письмо на адрес &a.ports;.</para>

    <note>
      <para>Только часть переменных
        (<varname><replaceable>VAR</replaceable></varname>), которые могут быть
        переопределены, описаны в этом документе.  Большинство (если не все)
        описаны в начале файла <filename>/usr/ports/Mk/bsd.port.mk</filename>;
        остальные, скорее всего, тоже там описаны.  Заметьте, что
        в этом файле используется нестандартная настройка шага табуляции:
        <application>Emacs</application> и <application>Vim</application>
        должны распознать это при загрузке файла.  Как &man.vi.1;,
        так и &man.ex.1; могут быть настроены на использование
        правильного значения выдачей команды <command>:set tabstop=4</command>
        после загрузки файла.</para>
    </note>

    <para>
      Ищете, с чего бы начать попроще? Посмотрите на <link xlink:href="http://wiki.freebsd.org/WantedPorts">перечень запрошенных
	портов</link>, есть ли там такие, над которыми вы можете работать.
    </para>
  </chapter>

  <chapter xml:id="quick-porting">
    <title>Быстрое портирование</title>

    <para>В этом разделе описано, как создать новый порт на скорую руку.
      Во многих случаях этого бывает не достаточно, так что вам нужно будет
      прочитать документ дальше.</para>

    <para>Во-первых, скачайте оригинальный tar-файл и поместите его в каталог
      <varname>DISTDIR</varname>, который по умолчанию есть не что иное, как
      <filename>/usr/ports/distfiles</filename>.</para>

    <note>
      <para>Здесь предполагается, что программное обеспечение компилируется
        без проблем как есть, то есть для работы приложения на вашей системе
        FreeBSD не потребовалось абсолютно никаких изменений.  Если
        требовалось что-то изменить, то вам придется обратиться также и к
        следующему разделу.</para>
    </note>

    <sect1 xml:id="porting-makefile">
      <title>Создание файла <filename>Makefile</filename></title>

      <para>Минимальный <filename>Makefile</filename> будет выглядеть
        примерно так:</para>

      <programlisting># &dollar;FreeBSD&dollar;

PORTNAME=      oneko
PORTVERSION=   1.1b
CATEGORIES=    games
MASTER_SITES=  ftp://ftp.cs.columbia.edu/archives/X11R5/contrib/

MAINTAINER=    asami@FreeBSD.org
COMMENT=       Cat chasing a mouse all over the screen

MAN1=	       oneko.1
MANCOMPRESSED= yes

.include &lt;bsd.port.mk&gt;</programlisting>

      <note>
	<para>В некоторых случаях в заголовке <filename>Makefile</filename>
	  существующего порта могут содержаться дополнительные строки,
	  такие как название порта и дата его создания.
	  Эта дополнительная информация была объявлена устаревшей
	  и находится в процессе удаления.</para>
      </note>

      <para>Посмотрим, сможете ли вы его понять.  Не обращайте внимание на
        содержимое строчки <literal>&dollar;FreeBSD&dollar;</literal>, она
        будет заполнена автоматически системой SVN, когда порт будет
        импортирован в наше дерево портов.  Вы можете найти более подробный
        пример в разделе <link linkend="porting-samplem">пример
        Makefile</link>.</para>
    </sect1>

    <sect1 xml:id="porting-desc">
      <title>Создание информационных файлов</title>

      <para>Имеется два информационных файла, которые требуются для любого
        порта, вне зависимости от того, является ли он пакетом или нет.  Это
        <filename>pkg-descr</filename> и <filename>pkg-plist</filename>.
        Префикс <filename>pkg-</filename> отличает их от других файлов.</para>

      <sect2>
        <title><filename>pkg-descr</filename></title>

        <para>Это более подробное краткое описание порта.  От одного до
          нескольких абзацев, кратко описывающих, что представляет собой
          порт, будет достаточно.</para>

        <note>
          <para>Это <emphasis>не</emphasis> руководство и не подробнейшее
            описание того, как использовать или компилировать порт!
            <emphasis>Пожалуйста, будьте внимательны при копировании текста
            из <filename>README</filename> или страниц
            справочника</emphasis>; слишком часто они не являются кратким
            описанием порта или имеют неудобный формат (например, страницы
	    справочника выровнены пробелами, поскольку это выглядит в
	    особенности плохо с моноширинными шрифтами).</para>
	</note>

	<para>Хорошо составленный <filename>pkg-descr</filename>
	  описывает порт достаточно полно, чтобы пользователю не
	  приходилось сверяться с документацией или посещать вебсайт
	  для понимания того, что делает данное программное обеспечение,
	  чем оно может быть полезно или какие хорошие функции у него
	  имеются.  Упоминание про определённые требования, такие как
	  используемый графический инструментарий, тяжёлые зависимости,
	  окружение для запуска или используемый язык программирования
	  помогут пользователям определиться, будет ли этот порт для
	  них работать.</para>

	<para>Включите сюда URL официальной домашней страницы Интернет.
	  Перед <emphasis>одним</emphasis> из сайтов (выберите основной)
	  добавьте <literal>WWW:</literal> (с последующим единичным
	  пробелом) для того, чтобы вспомогательные утилиты работали
	  правильно.  Если URI является корнем сайта или каталогом,
	  то значение должно быть дополнено косой чертой.</para>

	<note>
	  <para>Если указанная для порта веб-страница не доступна,
	    попытайтесь сперва поискать, был ли официальный сайт
	    перемещён, переименован или размещён в другом месте.</para>
	</note>

        <para>Следующий пример показывает, как должен выглядеть ваш
	  <filename>pkg-descr</filename>:</para>

        <programlisting>This is a port of oneko, in which a cat chases a poor mouse all over
the screen.
 :
(etc.)

WWW: http://www.oneko.org/</programlisting>
      </sect2>

      <sect2>
        <title><filename>pkg-plist</filename></title>

        <para>Здесь перечисляются все файлы, устанавливаемые портом.  Его
          также называют <quote>списком для упаковки</quote>, потому что
          пакет генерируется упаковкой файлов, которые здесь указаны.
          Имена путей указываются относительно установочного префикса
          (обычно <filename>/usr/local</filename>).
	  Если вы используете переменные
          <varname>MAN<replaceable>n</replaceable></varname> (а вы должны
          это делать), то указывать страницы справочника здесь не
          нужно.  Если порт во время установки создает каталоги,  убедитесь,
	  что добавили строку <literal>@dirrm</literal> для удаления
	  каталогов при удалении пакета.</para>

        <para>Вот маленький пример:</para>

        <programlisting>bin/oneko
lib/X11/app-defaults/Oneko
lib/X11/oneko/cat1.xpm
lib/X11/oneko/cat2.xpm
lib/X11/oneko/mouse.xpm
@dirrm lib/X11/oneko</programlisting>

        <para>Обратитесь к странице справочной системы по команде
          &man.pkg.create.1; с подробным описанием формата списка
          упаковки.</para>

        <note>
          <para>Рекомендуется, чтобы имена файлов в этом списке были
	    отсортированы в алфавитном порядке.  Это позволит значительно
	    облегчить сверку изменений при обновлении порта.</para>
	</note>

	<note>
	  <para>Создание списка упаковки вручную может оказаться весьма
	    трудоёмкой задачей.  Если порт устанавливает большое количество
	    файлов, раздел об <link linkend="plist-autoplist">автоматическом построении списка
	    упаковки</link> может помочь сэкономить время.</para>
        </note>

        <para>Существует только одно исключение, когда у порта может
          отсутствовать <filename>pkg-plist</filename>.  Если порт
          устанавливает лишь несколько файлов, а возможно, и каталогов, то
          они могут быть перечислены в переменных
          <varname>PLIST_FILES</varname> и <varname>PLIST_DIRS</varname>,
          соответственно, внутри файла <filename>Makefile</filename> порта.
          К примеру, мы можем обойтись без файла
          <filename>pkg-plist</filename> у приведённого выше порта
          <filename>oneko</filename>, добавив следующие строки в
          <filename>Makefile</filename>:</para>

        <programlisting>PLIST_FILES=    bin/oneko \
                lib/X11/app-defaults/Oneko \
                lib/X11/oneko/cat1.xpm \
                lib/X11/oneko/cat2.xpm \
                lib/X11/oneko/mouse.xpm
PLIST_DIRS=     lib/X11/oneko</programlisting>

        <para>Конечно, переменная <varname>PLIST_DIRS</varname> не должна
          задаваться, если порт не устанавливает никаких каталогов.</para>

	<note>
	  <para>Несколько портов могут совместно использовать общий
	    каталог.  В этом случае <varname>PLIST_DIRS</varname>
	    следует заменить на <varname>PLIST_DIRSTRY</varname>, так
	    чтобы каталог удалялся только если он пуст, а иначе
	    игнорировался.  Использование <varname>PLIST_DIRS</varname>
	    и <varname>PLIST_DIRSTRY</varname> аналогично
	    <literal>@dirrm</literal> и <literal>@dirrmtry</literal>
	    в <filename>pkg-plist</filename>, описание которых
	    входит в <xref linkend="plist-dir-cleaning"/>.</para>
	</note>

        <para>Обратной стороной такого способа перечисления файлов и
          каталогов порта является невозможность использования
          последовательностей команд, описанных в &man.pkg.create.1;.
          Поэтому он подходит для простых портов, что делает их ещё более
          простыми.  Одновременно с этим положительным моментом является
          уменьшение количества файлов в коллекции портов.  Пожалуйста,
          подумайте над использованием этой техники, прежде чем создавать
          <filename>pkg-plist</filename>.</para>

        <para>Далее мы увидим, как можно использовать файлы
          <filename>pkg-plist</filename> и <varname>PLIST_FILES</varname>
          выполнения <link linkend="plist">более сложных
          задач</link>.</para>
      </sect2>
    </sect1>

    <sect1 xml:id="porting-checksum">
      <title>Создание файла с контрольной суммой</title>

      <para>Просто введите команду <command>make makesum</command>.
        Правила утилиты make автоматически сгенерируют файл
        <filename>distinfo</filename>.</para>

      <para>Если у извлекаемого файла регулярно меняется контрольная
	сумма и вы не сомневаетесь в надежности источника (т.е. он получен
	из CD производителя, либо ежедневно обновляется документация), то вы
	должны указать эти файлы в переменной <varname>IGNOREFILES</varname>.
	Тогда контрольная сумма при выполнении <command>make makesum</command>
	для этого файла создаваться не будет, а вместо этого для него будет
	установлено значение <literal>IGNORE</literal>.</para>
    </sect1>

    <sect1 xml:id="porting-testing">
      <title>Тестирование порта</title>

      <para>Вы должны удостовериться, что правила построения порта выполняют
	именно то, что вы хотите, включая создание пакета для порта.  Вот
	те важные вещи, которые вы должны проверить.</para>

      <itemizedlist>
	<listitem>
	  <para><filename>pkg-plist</filename> не содержит ничего сверх того,
	    что устанавливается вашим портом</para>
	</listitem>

	<listitem>
	  <para><filename>pkg-plist</filename> содержит абсолютно все, что
	    устанавливается вашим портом</para>
	</listitem>

	<listitem>
	    <para>Ваш порт может быть переустановлен множество раз с помощью
	      указания цели <buildtarget>reinstall</buildtarget></para>
	</listitem>

	<listitem>
	  <para>Ваш порт <link linkend="plist-cleaning">подчищает</link>
	    за собой после своего удаления</para>
	</listitem>
      </itemizedlist>

      <procedure>
	<title>Рекомендуемый порядок проверки</title>

	<step>
	  <para><command>make install</command></para>
	</step>

	<step>
	  <para><command>make package</command></para>
	</step>

	<step>
	  <para><command>make deinstall</command></para>
	</step>

	<step>
	  <para><command>pkg_add package-name
	    </command></para>
	</step>

	<step>
	  <para><command>make deinstall</command></para>
	</step>

	<step>
	  <para><command>make reinstall</command></para>
	</step>

	<step>
	  <para><command>make package</command></para>
	</step>

	<step>
	  <para><command>make readme</command></para>
	</step>
      </procedure>

      <para>Проверьте, что ни на шаге <buildtarget>package</buildtarget>, ни на
	шаге <buildtarget>deinstall</buildtarget> не выдается никаких
	предупреждений.  После выполнения шага 3 проверьте, что все новые
	каталоги были успешно удалены.	Также попробуйте запустить
	программное обеспечение после выполнения шага 4, чтобы убедиться, что
	оно работает правильно при установке из пакета.</para>

      <para>Наиболее основательным способом автоматизации этих шагов является
	установка <application>ports tinderbox</application>.  Это
 	обеспечивает <literal>jails</literal>, в которых вы можете проверять
	все вышеуказанные шаги без изменения состояния в вашей основной
	системе.  Для получения дополнительной информации смотрите
	<filename>ports/ports-mgmt/tinderbox</filename>.</para>
    </sect1>

    <sect1 xml:id="porting-portlint">
      <title>Проверка вашего порта утилитой
	<command>portlint</command></title>

      <para>Будьте добры, пользуйтесь утилитой <command>portlint</command>
	для проверки того, что ваш порт соответствует нашим рекомендациям.
	Программа <package>ports-mgmt/portlint</package>
	является частью Коллекции
	Портов.  В частности, вы можете захотеть проверить, правильно ли
	сформирован файл <link linkend="porting-samplem">Makefile</link> и
	соответствующим ли образом именован <link linkend="porting-pkgname">пакет</link>.</para>
    </sect1>

    <sect1 xml:id="porting-submitting">
      <title>Посылка нового порта</title>

      <para>Перед посылкой нового порта удостоверьтесь, что вы прочитали
	раздел о том, что <link linkend="porting-dads">можно и нельзя</link> делать.</para>

      <para>Теперь, когда вы счастливы от своего первого порта, единственное,
	что осталось сделать, это включить его в основное дерево портов
	&os; и осчастливить этим всех остальных.  Нам не нужен ни ваш
	каталог <filename>work</filename>, ни пакет
	<filename>pkgname.tgz</filename>, так что удалите их прямо сейчас.
	Затем (предположим, что ваш порт зовут oneko) перейдите в каталог
	выше, там, где находится каталог <literal>oneko</literal>, и наберите
	следующее: <command>shar `find oneko` &gt; oneko.shar</command></para>

      <para>Включите ваш файл <literal>oneko.shar</literal>
	в сообщение об ошибке и пошлите
        его с помощью программы &man.send-pr.1; (обратитесь к разделу <link xlink:href="&url.articles.contributing;/contrib-how.html#CONTRIB-GENERAL">
        Сообщения об ошибках и общие замечания</link> для получения подробной
        информации о программе &man.send-pr.1;).  Не забудьте
	указать в сообщении категорию <literal>ports</literal> и класс
	<literal>change-request</literal> (Не указывайте, что сообщение
	имеет статус <literal>confidential</literal>!).  Добавьте также
        краткое описание программы, порт которой вы создали, в раздел
        <quote>Description</quote> отправляемого PR (например, содержимое
	<varname>COMMENT</varname> в сокращенном виде) и сам файл в виде архива
        shar, поместив его в раздел <quote>Fix</quote>.</para>

      <note>
        <para>Вы можете значительно облегчить нашу работу, если в тему
          сообщения о проблеме поместите хорошее описание.  Мы рекомендуем
          нечто вроде <quote>New port: &lt;категория&gt;/&lt;название
          порта&gt; &lt;краткое описание порта&gt;</quote> для новых портов.
	  Если вы следуете этой схеме, то шансы на то, что на ваше PR вскоре
          кто-то взглянет, гораздо выше.</para>
      </note>

      <para>Повторим ещё раз, что <emphasis>не нужно включать ни оригинальный
	файл с дистрибутивом, ни каталог <filename>work</filename>,
	ни пакет, построенный вами командой
	<command>make package</command></emphasis>; для новых портов
	используйте &man.shar.1;, но не &man.diff.1;.</para>

      <para>После того как вы послали порт, пожалуйста, потерпите.
        Иногда включение нового порта во &os; может занять до нескольких
	месяцев, а иногда всего несколько дней. <link xlink:href="http://www.FreeBSD.org/cgi/query-pr-summary.cgi?category=ports">
        Здесь</link> вы можете найти список PR для портов ожидающих своей
	очереди для включения во &os;.</para>

      <para>Мы рассмотрим ваш порт, при необходимости вернём его обратно, а
        затем включим порт в наше дерево.  Ваше имя также будет добавлено
	в список <link xlink:href="&url.articles.contributors;/contrib-additional.html">
	  Дополнительных контрибуторов проекта FreeBSD</link> и другие
	файлы.</para>
    </sect1>
  </chapter>

  <chapter xml:id="slow">
    <title>Медленное портирование</title>

    <para>Итак, все оказалось не так уж и просто, и порт потребовал
      некоторых модификаций для того, чтобы заставить его работать.  В этом
      разделе мы расскажем, шаг за шагом, как его модифицировать, чтобы он
      работал с нашей системой портов.</para>

    <sect1 xml:id="slow-work">
      <title>Как всё это работает</title>

      <para>Во-первых, когда пользователь дает в своем каталоге с портом
	команду <command>make</command>, происходит целая череда событий.
	Во время чтения этого текста может оказаться полезным иметь файл
	<filename>bsd.port.mk</filename> открытым в другом окне, что сильно
	поможет в их понимании.</para>

      <para>Но не волнуйтесь сильно, если вы не до конца понимаете, что
	делается в <filename>bsd.port.mk</filename>, не так уж много людей
	его понимает... <!-- smiley --><emphasis>:-&gt;</emphasis></para>

      <procedure>
	<step>
	  <para>Запускается цель <buildtarget>fetch</buildtarget>.  Цель
	    <buildtarget>fetch</buildtarget> отвечает за то, что архив исходных
	    текстов имеется в наличии локально в каталоге
	    <varname>DISTDIR</varname>.  Если цель
	    <buildtarget>fetch</buildtarget> не может найти требуемые файлы в
	    каталоге <varname>DISTDIR</varname>, то он будет искаться по
	    указателю URL <varname>MASTER_SITES</varname>, который
	    устанавливается в Makefile, а также на нашем основном FTP-сервере
	    по адресу <uri xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/">ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/</uri>,
            куда мы по возможности помещаем дистрибутивные файлы для архива.
	    Затем она попытается сгрузить указанный файл с помощью
	    <varname>FETCH</varname>, полагая, что запрашивающая машина имеет
	    прямое подключение к Интернет.  Если файл скачается удачно, то
	    он будет помещен в каталог <varname>DISTDIR</varname> для
	    последующего использования и обработки.</para>
	</step>

	<step>
	  <para>Выполняется цель <buildtarget>extract</buildtarget>.  Она ищет
	    дистрибутивный файл порта (как правило, tar-архив
	    <command>gzip</command>) в
	    каталоге <varname>DISTDIR</varname> и распаковывает его во
	    временный каталог, задаваемый переменной
	    <varname>WRKDIR</varname> (по умолчанию
	    <filename>work</filename>).</para>
	</step>

	<step>
	  <para>Выполняется цель <buildtarget>patch</buildtarget>.  Во-первых,
	    применяются все патчи, заданные переменной
	    <varname>PATCHFILES</varname>.  Во-вторых, если какие-либо файлы с
            патчами, носящие имена
            <filename>patch-*</filename>, имеются в
	    подкаталоге <varname>PATCHDIR</varname> (по умолчанию это каталог
            <filename>files</filename>), то они применяются в этот момент в
            алфавитном порядке.</para>
	</step>

	<step>
	  <para>Запускается цель <buildtarget>configure</buildtarget>.  Здесь
	    может выполняться любая из многих различных вещей.</para>

	  <orderedlist>
	    <listitem>
	      <para>Если существует скрипт
		<filename>scripts/configure</filename>, то он запускается.
	      </para>
	    </listitem>

	    <listitem>
	      <para>Если задана переменная <varname>HAS_CONFIGURE</varname>
		или <varname>GNU_CONFIGURE</varname>, то запускается скрипт
		<filename>WRKSRC/configure</filename>.
	      </para>
	    </listitem>
	  </orderedlist>
	</step>

	<step>
	  <para>Выполняется цель <buildtarget>build</buildtarget>.  Она
	    отвечает за переход в собственный рабочий каталог порта
	    (<varname>WRKSRC</varname>) и его построение.  Если задана
	    переменная <varname>USES= gmake</varname>, будет использоваться
	    GNU-версия утилиты <command>make</command>, в противном случае
	    будет использована системная утилита
	    <command>make</command>.</para>
	</step>
      </procedure>

      <para>Выше перечислены стандартные действия.  Кроме того, вы сами
	можете определить цели
	<buildtarget>pre-<replaceable>что-то</replaceable></buildtarget> или
	<buildtarget>post-<replaceable>что-то</replaceable></buildtarget>,
	или создать скрипты с такими именами в подкаталоге
	<filename>scripts</filename>, и они будут запущены до или после
	выполнения действий по умолчанию.</para>

      <para>Например, если у вас есть цель
	<buildtarget>post-extract</buildtarget>, определённая в вашем файле
	<filename>Makefile</filename> и файл <filename>pre-build</filename> в
        подкаталоге
	<filename>scripts</filename>, то после выполнения обычных действий по
	распаковке, будет вызвана цель <buildtarget>post-extract</buildtarget>
	а скрипт <filename>pre-build</filename> будет выполнен перед
	запуском стандартных правил построения.  Рекомендуется использовать
	цели из <filename>Makefile</filename>, если действия достаточно
	просты, потому что в дальнейшем будет проще определить, какие
	нестандартные действия требует порт.</para>

      <para>Действия по умолчанию выполняются целями
	<buildtarget>do-<replaceable>что-то</replaceable></buildtarget> из
	<filename>bsd.port.mk</filename>.  Например, команды для
	распаковки порта находятся в цели
	<buildtarget>do-extract</buildtarget>.  Если вам не хватает цели по
	умолчанию, вы можете ее исправить, переопределив цель
	<buildtarget>do-<replaceable>something</replaceable></buildtarget>
	в вашем файле <filename>Makefile</filename>.</para>

      <note>
	<para><quote>Основные</quote> цели (к примеру,
	  <buildtarget>extract</buildtarget>, <buildtarget>configure</buildtarget>
          и так далее) не делают ничего больше,
	  чем проверяют успешность завершения всех предыдущих шагов и
	  вызывают настоящие цели или скрипты, и их не нужно менять.  Если
	  вам нужно изменить распаковку, исправляйте
	  <buildtarget>do-extract</buildtarget>, но никогда не меняйте способ
          работы <buildtarget>extract</buildtarget>!  Кроме того, цель
	  <buildtarget>post-deinstall</buildtarget> является недействительной
	  и не выполняется инфраструктурой портов.</para>
      </note>

      <para>Теперь вы представляете, что происходит, когда пользователь
	набирает команду <command>make</command>, теперь давайте пройдемся
	через шаги, рекомендуемые для создания настоящего порта.</para>
    </sect1>

    <sect1 xml:id="slow-sources">
      <title>Получение исходного кода</title>

      <para>Получите оригинальные исходные тексты (обычно) в виде
	упакованного tar-архива
	(<filename>foo.tar.gz</filename> или
	<filename>foo.tar.bz2</filename>)
	и скопируйте его в каталог <varname>DISTDIR</varname>.	Всегда
	используйте исходные тексты <emphasis>основной ветки
	разработки</emphasis> везде, где это возможно.</para>

      <para>Вам потребуется задать значение переменной
        <varname>MASTER_SITES</varname> так, чтобы оно указывало на
        местоположение оригинального tar-архива.  В файле
        <filename>bsd.sites.mk</filename> вы найдёте краткие обозначения
        для большинства популярных сайтов.  Пожалуйста, используйте эти
        сайты&mdash;и соответствующие определения&mdash;везде, где это
        возможно, чтобы избежать проблем повторения одной и той же информации
        в базе источников.  Так как эти сайты со временем меняются, для
        всех причастных поддержка становится настоящим кошмаром.</para>

      <para>Если вы не можете найти FTP/HTTP сайт с хорошим подключением к
	сети, или находите только сайты, которые имеют раздражающе
	нестандартные форматы, то можете захотеть поместить копию на надежный
	сервер FTP или HTTP, который вам доступен (например, ваша домашняя
	страница).</para>

      <para>Если вы не можете найти доступного и надёжного места для
	помещения дистрибутивного файла, то мы сами сможем разместить его на
        сервере <systemitem>ftp.FreeBSD.org</systemitem>; однако это наименее
        рекомендуемое решение.  Дистрибутивный файл должен
        быть помещён в каталог <filename>~/public_distfiles/</filename>
        одного из пользователей машины <systemitem>freefall</systemitem>.  Попросите
        того, кто коммиттил ваш порт, сделать это.  Этот человек также задаст
        переменной <varname>MASTER_SITES</varname> значение
        <varname>MASTER_SITE_LOCAL</varname>, а в переменной
        <varname>MASTER_SITE_SUBDIR</varname> укажет своё имя пользователя
        с машины <systemitem>freefall</systemitem>.</para>

      <para>Если дистрибутивные файлы вашего порта постоянно меняются по
	неизвестным причинам без изменения версий со стороны автора, остаётся
        только поместить дистрибутив на вашу домашнюю Web-страницу и указать
        её первой в списке <varname>MASTER_SITES</varname>.  Если можете,
        попытайтесь договориться с автором порта об этом; это действительно
        помогает в достижении некоторого управления исходным кодом.
        Размещение собственной версии поможет избежать появления ошибок у
        пользователей типа <errorname>checksum mismatch</errorname>, а
	также уменьшит нагрузку на людей, сопровождающих наш FTP-сервер.
	Также, если у порта имеется только один основной сервер, то
	рекомендуется поместить архивную копию на свой сайт и указать его в
	списке <varname>MASTER_SITES</varname> вторым.</para>

      <para>Если вашему порту требуются дополнительные `патчи', доступные
	в Интернет, скачайте также и их, поместив в каталог
	<varname>DISTDIR</varname>.  Не волнуйтесь, если они находятся не
	на том же сайте, откуда взят дистрибутивный архив, мы умеем
	обрабатывать такие ситуации (смотрите описание <link linkend="porting-patchfiles">PATCHFILES</link> ниже).</para>
    </sect1>

    <sect1 xml:id="slow-modifying">
      <title>Модификация порта</title>

      <para>Распакуйте копию дистрибутивного файла в отдельный каталог и
	внесите изменения, которые необходимы для того, чтобы порт
	компилировался нормально в текущей версии &os;.
	<emphasis>Тщательно отслеживайте</emphasis> все, что вы делаете,
	этот процесс вам предстоит автоматизировать.  Все, включая удаление,
	добавление или модификацию в файлах должны будут выполняться
	автоматически с помощью скриптов или файлов патчей, когда вы
	завершите работу над портом.</para>

      <para>Если вашему порту во время компиляции, установки и настройки
	требуется довольно много взаимодействовать с пользователем, то
	посмотрите на один из классических скриптов
	<application>Configure</application> Лэрри Уолла (Larry Wall) и
	сделайте сами что-либо подобное.  Предназначение новой коллекции
	портов - это сделать каждое приложение в стиле
	<quote>plug-and-play</quote> настолько, насколько это вообще возможно
	для конечного пользователя при минимальном использовании дискового
	пространства.</para>

      <note>
	<para>Если явно не указано обратное, то патчи, скрипты и другие
	  файлы, которые вы создали и предоставили для Коллекции Портов
	  &os;, неявно подпадают под стандартные условия лицензии
	  BSD.</para>
      </note>
    </sect1>

    <sect1 xml:id="slow-patch">
      <title>Создание патчей</title>

      <para>Файлы, которые добавлялись или изменялись в процессе создания
	порта, могут быть выявлены вызовом программы &man.diff.1;,
        а результат работы этой программы может быть в дальнейшем передан
	программе &man.patch.1;.  Каждый патч, который вы собираетесь
	применить, должен быть сохранен в файл с именем
	<filename>patch-*</filename>, где
	<replaceable>*</replaceable> обозначает путь к файлу, к которому
	применяется патч, такой как
        <filename>patch-Imakefile</filename> или
        <filename>patch-src-config.h</filename>.  Эти файлы должны находиться в
        каталоге <varname>PATCHDIR</varname>
	(как правило, это <filename>files/</filename>),
	откуда они будут взяты автоматически.  Все патчи обязаны быть сделаны
	относительно каталога <varname>WRKSRC</varname> (как правило,
	это каталог, в который распаковывается исходный архив и где будет
	выполняться построение).  Для упрощения внесения изменений и
	обновлений вы должны избегать наличия более чем одного патча для
	одного и того же файла (например, патчей
	<filename>patch-file</filename> и <filename>patch-file2</filename>,
	оба меняющих файл <filename>WRKSRC/foobar.c</filename>).
	Обратите внимание, что если путь к изменяемому файлу содержит символ
	подчеркивания (<literal>_</literal>), то патч должен содержать в своем
	имени два подчеркивания вместо одного.  Например, для применения патча
	на файл с именем <filename>src/freeglut_joystick.c</filename>
	соответствующий патч следует назвать
	<filename>patch-src-freeglut__joystick.c</filename>.</para>

      <para>Пожалуйста, используйте для именования ваших патчей только символы
	<literal>[-+._a-zA-Z0-9]</literal>.  Не используйте любые другие
	символы, кроме этих.  Не называйте ваши патчи как
	<filename>patch-aa</filename> или <filename>patch-ab</filename> и
	так далее, всегда ссылайтесь на путь и название файла в названиях
	патчей.</para>

      <para>Не помещайте строки RCS в патчи.  SVN будет изменять их при
	помещении файлов в дерево портов, и когда мы будем их оттуда
	извлекать, они будут уже другие, поэтому применение патчей
	окончится неудачей.  Строчки RCS предваряются знаком доллара
	(<literal>&dollar;</literal>), и обычно начинаются с
	<literal>&dollar;Id</literal> или
	<literal>&dollar;RCS</literal>.</para>

      <para>Использование параметра рекурсии (<option>-r</option>) с командой
	&man.diff.1; для генерации патчей - это хорошо, но всё же,
	пожалуйста, смотрите на получающиеся патчи, чтобы убедиться в
	отсутствии ненужного мусора.  В частности, diff-разниц между двумя
	резервными копиями файлов, файлы <filename>Makefile</filename>, когда
	как порт использует <command>Imake</command> или
	GNU-версию программы <command>configure</command>, и так далее,
	не нужны, и должны быть удалены.  Если вы отредактировали файл
	<filename>configure.in</filename> и запустили
	<command>autoconf</command> для перегенерации
	<command>configure</command>, не нужно включать файлы diff для
	<command>configure</command> (они частенько вырастают до нескольких
	тысяч строк!); задайте <literal>USE_AUTOTOOLS=autoconf:261</literal> и
	включите diff-файл для <filename>configure.in</filename>.</para>

      <para>Также постарайтесь минимизировать в ваших патчах объем
	нефункциональных изменений с пустыми символами.  В мире Открытого
	Исходного Кода является распространенным совместное использование
	проектами больших объемов кодовой базы, но с различными стилями
	и правилами отступов.  Если вы берете работающую функциональную
	часть из одного проекта для исправления похожей области в другом,
	то будьте аккуратны, пожалуйста: получаемый однострочный патч
	может быть полон нефункциональных изменений.  Это не только
	увеличивает размер репозитория SVN, но также усложняет поиск того,
	что конкретно вызвало проблему и что вы вообще изменили.</para>

      <para>Если вам нужно удалить файл, то вы можете сделать это при
	выполнении цели <buildtarget>post-extract</buildtarget> вместо того,
	чтобы оформлять это как часть патча.</para>

      <para>Простые перемещения могут быть выполнены непосредственно из
	<filename>Makefile</filename> порта с использованием &man.sed.1; в
	режиме in-place.  Это очень удобно, когда вам нужно применить патч
	на значение переменной.  Пример:</para>

      <programlisting>post-patch:
	@${REINPLACE_CMD} -e 's|for Linux|for FreeBSD|g' ${WRKSRC}/README</programlisting>

      <para>Довольно часто бывают ситуации, когда портируемое программное
	обеспечение, особенно если основной платформой разработки является
	&windows;, использует конвенцию CR/LF для большинства своих исходных
	файлов.  Это может быть причиной проблем с дальнейшей упаковкой,
	предупреждениями компилятора, выполнением скриптов
	(<command>/bin/sh^M</command> not found) и так далее.  Для быстрой
	преобразования всех файлов из CR/LF просто в LF добавьте
	<literal>USE_DOS2UNIX=yes</literal> в <filename>Makefile</filename>
	порта.  Может быть указан перечень преобразуемых файлов:</para>

      <programlisting>USE_DOS2UNIX=    util.c util.h</programlisting>

      <para>Если вы хотите преобразовать группу файлов в разных подкаталогах,
	то для этого можно использовать <varname>DOS2UNIX_REGEX</varname>.
	Его параметром является регулярное выражение, совместимое с
	<command>find</command>.  Подробнее о формате в &man.re.format.7;.
	Эта опция используется для преобразования всех файлов заданного
	расширения, к примеру всех исходных файлов, не затрагивая двоичные
	файлы:</para>

      <programlisting>USE_DOS2UNIX=    yes
DOS2UNIX_REGEX=  .*\.(c|cpp|h)</programlisting>

      <para>Если вы хотите создать патч на основе существующего файла, то вы
	можете его скопировать с расширением <filename>.orig</filename>, а
	затем изменить исходный.  Цель<buildtarget>makepatch</buildtarget>
	запишет соответствующий файл с патчем в каталог
	<filename>files</filename> данного порта.</para>
    </sect1>

    <sect1 xml:id="slow-configure">
      <title>Конфигурирование</title>

      <para>Поместите все дополнительные команды, требуемые для настройки,
	в ваш скрипт <filename>configure</filename> и сохраните его в
	подкаталоге <filename>scripts</filename>. Как отмечено выше, вы
	можете сделать это целями в файле <filename>Makefile</filename>
	и/или скриптами с именами <filename>pre-configure</filename> или
	<filename>post-configure</filename>.</para>
    </sect1>

    <sect1 xml:id="slow-user-input">
      <title>Обработка пользовательского ввода</title>

      <para>Если для построения, конфигурации или установки вашего порта
	требуется некоторый ввод со стороны пользователя, то вы должны задать
	переменную <varname>IS_INTERACTIVE</varname> в вашем файле
        <filename>Makefile</filename>.  В случае <quote>ночного
        построения</quote> это позволит пропустить
	ваш порт, если пользователь в своем окружении задал переменную
	<envar>BATCH</envar> (и если пользователь установил переменную
	<envar>INTERACTIVE</envar>, то будут строиться
	<emphasis>только</emphasis> порты, которые требуют взаимодействия
	с пользователем.  Это сэкономит значительное количество времени на
        части машин, которые постоянно строят порты (смотрите ниже).</para>

      <para>При наличии разумных ответов на задаваемые вопросы, подходящих по
	умолчанию, также рекомендуется проверять переменную
	<varname>PACKAGE_BUILDING</varname> и выключать интерактивный скрипт,
	если он есть.  Это позволит нам строить пакеты для помещения на
	компакт-диски и FTP-серверы.</para>
    </sect1>
  </chapter>

  <chapter xml:id="makefile">
    <title>Настройка файла Makefile</title>

    <para>Настройка файла <filename>Makefile</filename> достаточно проста, и
      мы снова предполагаем, что перед тем, как начать, вы посмотрите на
      существующие примеры.  К тому же в этом руководстве имеется <link linkend="porting-samplem">примерный Makefile</link>, так что взгляните
      на него и, пожалуйста, следуйте порядку переменных и разделов в этом
      образце, чтобы облегчить чтение вашего порта другими людьми.</para>

    <para>Итак, расположим решаемые задачи в порядке их возникновения при
      создании вашего нового файла <filename>Makefile</filename>:</para>

    <sect1 xml:id="makefile-source">
      <title>Оригинальные исходный код</title>

      <para>Находится ли он в каталоге <varname>DISTDIR</varname> в виде
	стандартного упакованного архиватором <command>gzip</command>
	tar-архива с именем типа
        <filename>foozolix-1.2.tar.gz</filename>?  Если это так,
	можно перейти к следующему шагу.  Если нет, то вы должны попытаться
	переопределить некоторые из переменных
	<varname>DISTVERSION</varname>, <varname>DISTNAME</varname>,
	<varname>EXTRACT_CMD</varname>,
	<varname>EXTRACT_BEFORE_ARGS</varname>,
	<varname>EXTRACT_AFTER_ARGS</varname>,
	<varname>EXTRACT_SUFX</varname> или <varname>DISTFILES</varname> в
	зависимости от того, насколько необычен формат дистрибутивного
	файла.</para>

      <para>В худшем случае вы можете просто определить свою собственную цель
	<buildtarget>do-extract</buildtarget> для переопределения действий по
	умолчанию, хотя к этому нужно будет прибегать в очень редких случаях,
	если вообще придётся.</para>
    </sect1>

    <sect1 xml:id="makefile-naming">
      <title>Именование</title>

      <para>В первой части <filename>Makefile</filename> порта ему даётся
        название, указывается его номер версии и принадлежность к правильной
        категории.</para>

      <sect2>
        <title><varname>PORTNAME</varname> и
          <varname>PORTVERSION</varname></title>

        <para>В переменной <varname>PORTNAME</varname> вы должны указать
	  основную часть имени вашего порта, а в переменной
          <varname>PORTVERSION</varname> - номер версии.</para>
      </sect2>

      <sect2 xml:id="makefile-naming-revepoch">
        <title><varname>PORTREVISION</varname> и
          <varname>PORTEPOCH</varname></title>

        <sect3>
          <title><varname>PORTREVISION</varname></title>

          <para>Переменная <varname>PORTREVISION</varname> представляет собой
            монотонно увеличивающееся число, которое обнуляется при каждом
            увеличении значения переменной <varname>PORTVERSION</varname> (то
            есть каждый раз, когда создателями выпускается новый официальный
            релиз), и добавляется к имени пакета, если оно не равно нулю.
            Изменения в <varname>PORTREVISION</varname> используются
            автоматизированными инструментами (например, &man.pkg.version.1;)
            для определения факта появления нового пакета.</para>

          <para>Значение <varname>PORTREVISION</varname> должно увеличиваться
            каждый раз, когда в порте FreeBSD делаются изменения, которые
            достаточно сильно затрагивают содержимое или структуру
            соответствующего пакета.</para>

          <para>Примеры случаев, когда значение <varname>PORTREVISION</varname>
            должно быть увеличено:</para>

          <itemizedlist>
            <listitem>
	      <para>Добавление патчей для исправления уязвимостей,
	        ошибок, или добавления новой функциональности в порт.</para>
            </listitem>

            <listitem>
	      <para>Изменения в файле <filename>Makefile</filename> порта для
                включения и выключения параметров, определяемых при компиляции
                пакета.</para>
            </listitem>

            <listitem>
	      <para>Изменения в списке упаковки или в поведении пакета во
                время его установки (например, изменение скрипта, генерирующего
	        начальные данные для пакета, такие, как ssh-ключи для
	        хоста).</para>
            </listitem>

            <listitem>
	      <para>Увеличение версии динамической библиотеки, от которой
                зависит порт (в этом случае тот, кто попытается установить
                старый пакет после установки более новой версии библиотеки,
                не сможет этого сделать, потому что при этом будет делаться
                поиск старой библиотеки libfoo.x, а не libfoo.(x+1)).</para>
            </listitem>

            <listitem>
	      <para>Большие функциональные изменения в дистрибутивном файле
                порта, происходящие без объявлений, и приводящие к большим
                изменениям, то есть изменения в дистрибутиве требуют
                корректировки файла <filename>distinfo</filename> без
                соответствующего изменения <varname>PORTVERSION</varname>,
                когда как команда <command>diff -ru</command> между новой
                и старой версиями показывает нетривиальные изменения в
                коде.</para>
            </listitem>
          </itemizedlist>

          <para>Примеры изменений, которые не требуют увеличения переменной
            <varname>PORTREVISION</varname>:</para>

          <itemizedlist>
            <listitem>
	      <para>Изменения стиля в скелете порта без функциональных изменений
	        в пакете.</para>
            </listitem>

            <listitem>
	      <para>Изменения в переменной <varname>MASTER_SITES</varname> или
	        другие функциональные изменения порта, которые не затрагивают
	        получающегося пакета.</para>
            </listitem>

            <listitem>
	      <para>Тривиальные патчи к дистрибутивному файлу, такие, как
	        исправления опечаток, которые не так уж важны, что пользователи
	        пакета должны озаботиться обновлением.</para>
            </listitem>

            <listitem>
	      <para>Исправления, касающиеся этапа построения, которые делают
	        возможным построение пакета, если ранее это было невозможно
	        сделать (пока изменения не приводят к изменению работы на любых
	        других платформах, на которых порт ранее строился).  Так как
	        <varname>PORTREVISION</varname> отражает содержимое пакета,
                то, если ранее пакет не строился, то нет нужды увеличивать
	        <varname>PORTREVISION</varname> для отметки изменения.</para>
            </listitem>
          </itemizedlist>

          <para>Правило, которому нужно приблизительно следовать, заключается в
            том, что нужно спрашивать себя, является ли вносимое в порт
            изменение таким, что от него выиграют все (в виде
            усовершенствования, исправления или благодаря тому, что новый
            пакет будет вообще работоспособным), и примите во внимание тот
            факт, что при этом все, кто регулярно обновляют своё дерево портов,
            будут обязаны это сделать.  Если это так, то переменная
            <varname>PORTREVISION</varname> должна быть увеличена.</para>
        </sect3>

        <sect3>
          <title><varname>PORTEPOCH</varname></title>

          <para>Время от времени разработчик программного обеспечения или
            создатель порта FreeBSD делают что-то не так и выпускают версию
            программы, номер которой меньше предыдущей версии.  Примером этого
            является порт, название которого меняется с foo-20000801 на foo-1.0
            (изначально это не считалось бы более новой версией, так как
            20000801 численно больше, чем 1).</para>

	  <tip>
	    <para>Результат сравнения номера версии не всегда очевиден.
	      Для выполнения сравнения двух строк с номером версии можно
	      использовать &man.pkg.version.1;.  Эквивалентом в
	      <application>pkgng</application> является
	      <command>pkg version -t</command>.  Например:</para>

	    <screen>&prompt.user; <userinput>pkg_version -t 0.031 0.29</userinput>
&gt;</screen>

	    <para>Для пользователей <application>pkgng</application>:</para>

	    <screen>&prompt.user; <userinput>pkg version -t 0.031 0.29</userinput>
&gt;</screen>

	    <para>Строка <literal>&gt;</literal> в выводе команды означает,
	      что версия 0.031 считается выше, чем версия 0.29, что может
	      быть не очевидно для того, кто выполняет портирование.</para>
	</tip>

          <para>В ситуациях, подобных этой, должно быть увеличено значение
            <varname>PORTEPOCH</varname>.  Если значение
            <varname>PORTEPOCH</varname> не равно нулю, то оно добавляется к
            имени пакета, как описано в разделе выше.  Значение
            <varname>PORTEPOCH</varname> никогда не должно уменьшаться или
            сбрасываться в ноль, потому что это приведёт к ошибке сравнения с
            пакетом с меньшим номером эпохи (то есть то, что пакет устарел,
            обнаружено не будет): номер новой версии (например,
            <literal>1.0,1</literal> в примере выше) останется меньше, чем
            номер предыдущей версии (20000801), однако суффикс
            <literal>,1</literal> интерпретируется различными
            автоматизированными утилитами особым образом, и окажется больше,
            чем предполагаемый суффикс <literal>,0</literal> более раннего
            пакета).</para>

          <para>Некорректное уменьшение или сброс <varname>PORTEPOCH</varname>
            приводит к печальным последствиям; если вы не поняли, о чём шла
            речь ранее, пожалуйста, всё же разберитесь с этим, либо спросите
            в списках рассылки.</para>

          <para>Предполагается, что в большинстве портов переменная
            <varname>PORTEPOCH</varname> использоваться не будет, но при
            корректном использовании <varname>PORTVERSION</varname> может
            появиться необходимость её иметь, если в будущих релизах
            программное обеспечение должно изменить структуру номера версии.
            Однако создателям портов нужно быть внимательными, когда
            разработчик выпускает релиз без официального номера версии &mdash;
            эдакие <quote>промежуточные</quote> релизы.  Имеется соблазн
            пометить релиз датой его выхода, что может вызвать проблемы, как и
            в примере выше, когда будет выпущен новый
            <quote>официальный</quote> релиз.</para>

          <para>Например, если промежуточный релиз помечен датой 20000917, а
            предыдущая версия программного обеспечения имела номер 1.2, то
            промежуточному релизу должно быть поставлено в соответствие
            значение <varname>PORTVERSION</varname>, равное 1.2.20000917 или
            что-то похожее, но не 20000917, так как последующий релиз, скажем,
            1.3, должен иметь численно большее значение.</para>
        </sect3>

        <sect3>
          <title>Пример использования переменных
            <varname>PORTREVISION</varname> и
            <varname>PORTEPOCH</varname></title>

          <para>Выполнен коммит порта <literal>gtkmumble</literal>, версии
            <literal>0.10</literal>, в коллекцию портов.</para>

          <programlisting>PORTNAME=       gtkmumble
PORTVERSION=    0.10</programlisting>

          <para>Значение <varname>PKGNAME</varname> станет равным
            <literal>gtkmumble-0.10</literal>.</para>

          <para>Обнаружена брешь в безопасности, исправление которой
	    потребовало создания
            локального патча для FreeBSD.  Соответственно было увеличено
            значение переменной <varname>PORTREVISION</varname>.</para>

          <programlisting>PORTNAME=       gtkmumble
PORTVERSION=    0.10
PORTREVISION=   1</programlisting>

          <para><varname>PKGNAME</varname> принимает значение
            <literal>gtkmumble-0.10_1</literal></para>

          <para>Разработчиком выпущена новая версия с номером
            <literal>0.2</literal> (оказалось, что под номером
            <literal>0.10</literal> автор имел в виду
            <literal>0.1.0</literal>, а не <quote>то, что будет выпущено после
            версии 0.9</quote> - извините, теперь уже поздно).  Так как новый
            младший номер версии <literal>2</literal> по значению меньше, чем
            номер предыдущей версии <literal>10</literal>, то должно быть
            увеличено значение <varname>PORTEPOCH</varname> для того, чтобы
            заставить распознавать вновь создаваемый пакет как <quote>более
            новый</quote>.  Так как это новый релиз программы, то
            <varname>PORTREVISION</varname> обнуляется (или удаляется из
            файла <filename>Makefile</filename>).</para>

          <programlisting>PORTNAME=       gtkmumble
PORTVERSION=    0.2
PORTEPOCH=      1</programlisting>

          <para><varname>PKGNAME</varname> принимает значение
            <literal>gtkmumble-0.2,1</literal></para>

          <para>Следующий релиз имеет номер версии 0.3.  Так как значение
            переменной <varname>PORTEPOCH</varname> никогда не уменьшается, что
            переменные, определяющие версии, теперь выглядят так:</para>

          <programlisting>PORTNAME=       gtkmumble
PORTVERSION=    0.3
PORTEPOCH=      1</programlisting>

          <para><varname>PKGNAME</varname> принимает значение
            <literal>gtkmumble-0.3,1</literal></para>

          <note>
            <para>Если значение <varname>PORTEPOCH</varname> этим обновлением
              было бы сброшено в <literal>0</literal>, то кто-нибудь, имеющий
              установленный пакет <literal>gtkmumble-0.10_1</literal>, не
              смог бы опознать пакет <literal>gtkmumble-0.3</literal> как
              более новый, так как <literal>3</literal> было бы меньше, чем
              <literal>10</literal>.  Помните, что в первую очередь это
              касается <varname>PORTEPOCH</varname>.</para>
          </note>
        </sect3>
      </sect2>

      <sect2>
        <title>Переменные <varname>PKGNAMEPREFIX</varname>
          и <varname>PKGNAMESUFFIX</varname></title>

        <para>Две необязательные переменные, <varname>PKGNAMEPREFIX</varname> и
          <varname>PKGNAMESUFFIX</varname>, объединяются со значениями
          <varname>PORTNAME</varname> и
          <varname>PORTVERSION</varname> для формирования
          <varname>PKGNAME</varname> в форме
          <literal>${PKGNAMEPREFIX}${PORTNAME}${PKGNAMESUFFIX}-${PORTVERSION}</literal>.
          Добейтесь того, чтобы это соответствовало нашим <link linkend="porting-pkgname">рекомендациям по правильному выбору
          названий для пакетов</link>.  В частности, в переменной
          <varname>PORTVERSION</varname> <emphasis>не разрешается</emphasis>
          использование дефиса (<literal>-</literal>).  Кроме того, если в
          имени пакета присутствует часть <replaceable>language-</replaceable>
          или <replaceable>-compiled.specifics</replaceable> (смотрите ниже),
          то используйте переменные <varname>PKGNAMEPREFIX</varname> и
          <varname>PKGNAMESUFFIX</varname>, соответственно.  Не делайте их
          частью значения переменной <varname>PORTNAME</varname>.</para>
      </sect2>

      <sect2>
	<title><varname>LATEST_LINK</varname></title>

	<para><varname>LATEST_LINK</varname> задает в процессе построения
	  пакета короткое имя ссылки, которые могут использоваться при
	  выполнении команды <command>pkg_add -r</command>.  Это позволяет,
	  к примеру, установить последнюю версию perl, используя
	  <command>pkg_add -r perl</command>, без знания точного номера
	  версии.  Такое имя должно быть уникальным и очевидным для
	  пользователей.</para>

	<para>В некоторых случаях в коллекции портов может присутствовать
	  несколько версий программы одновременно.  Обе системы, построения
	  индексов и построения пакетов, нуждаются в способности их видеть
	  как разные, независимые порты, хотя все они могут иметь схожее
	  значение для <varname>PORTNAME</varname>,
	  <varname>PKGNAMEPREFIX</varname> и даже
	  <varname>PKGNAMESUFFIX</varname>.  В этих случаях для всех портов
	  кроме <quote>главного</quote> следует присвоить различные значения для
	  необязательной переменной <varname>LATEST_LINK</varname> &mdash;
	  чтобы получить пример ее использования, смотрите порты
	  <filename>lang/gcc46</filename> и <filename>lang/gcc</filename>,
	  а также семейство <filename>www/apache*</filename>.  При установке
	  <varname>NO_LATEST_LINK</varname> ссылки не создаются; эта
	  необязательная переменная может быть указана во всех версиях,
	  кроме <quote>главной</quote>.  Обратите
	  внимание, как выбирать <quote>главную</quote> версию &mdash;
	  <quote>самую популярную</quote>, <quote>самую поддерживаемую</quote>,
	  <quote>с наименьшими изменениями</quote> и так далее &mdash; это
	  выходит за рамки рекомендаций этого руководства; мы всего лишь
	  сообщаем вам, как указывать версии других портов после того, как
	  вы выбрали <quote>главный</quote>.</para>
      </sect2>

      <sect2 xml:id="porting-pkgname">
        <title>Соглашения по именованию пакетов</title>

        <para>Далее описаны некоторые соглашения, которым вы должны следовать
          в именовании ваших пакетов.  Они были разработаны для облегчения
          просмотра каталога, так как имеется уже тысячи пакетов, а
          пользователи отвернутся от нас, если список не понравится их
          взору!</para>

        <para>Имя пакета должно иметь вид
          <filename>language_region-name-compiled.specifics-version.numbers</filename>.</para>

        <para>Имя пакета определяется как
          <literal>${PKGNAMEPREFIX}${PORTNAME}${PKGNAMESUFFIX}-${PORTVERSION}</literal>.
          Вы должны задавать значения переменных в соответствии с этим
          форматом.</para>

        <orderedlist>
          <listitem>
	    <para>FreeBSD пытается поддерживать языки, на которых разговаривают
	      её пользователи.  Часть <replaceable>language-</replaceable>
	      должна быть двухсимвольным сокращением от названия языка по
	      стандарту ISO-639, если порт специфичен для конкретного языка.
	      Примерами являются <literal>ja</literal> для японского,
	      <literal>ru</literal> для русского, <literal>vi</literal> для
	      вьетнамского, <literal>zh</literal> для китайского,
	      <literal>ko</literal> для корейского и <literal>de</literal> для
	      немецкого языков.</para>

	    <para>Если ваш порт специфичен для конкретного региона внутри
              области использования языка, добавьте также двухсимвольный код
              страны.  Примерами являются <literal>en_US</literal> для US
              English и <literal>fr_CH</literal> для Swiss French.</para>

            <para>Часть <replaceable>language-</replaceable> должна задаваться
              в переменной <varname>PKGNAMEPREFIX</varname>.</para>
          </listitem>

          <listitem>
	    <para>Первая буква части <filename>name</filename> должна быть в
              нижнем регистре.  (Оставшаяся часть названия может содержать
              буквы в верхнем регистре, так что принимайте решение сами, когда
              преобразуете имя программного пакета, содержащего в имени
              некоторое количество заглавных букв.)  Существует традиция
              именовать модули для <literal>Perl 5</literal>, добавляя впереди
              <literal>p5-</literal> и преобразуя пару двоеточий в
              дефис; например, модуль <literal>Data::Dumper</literal> будет
              именоваться <literal>p5-Data-Dumper</literal>.</para>
	  </listitem>

	  <listitem>
	    <para>Убедитесь, что имя порта и версия четко отделены и
	      размещаются в переменных <varname>PORTNAME</varname> и
	      <varname>PORTVERSION</varname>.  Единственная причина, по
	      которой <varname>PORTNAME</varname> содержит версионную часть,
	      это если полученный дистрибутив сам назван таким образом, как
	      это сделано для портов <filename>textproc/libxml2</filename>
	      или <filename>japanese/kinput2-freewnn</filename>.  В противном
	      случае <varname>PORTNAME</varname> не должен содержать никакой
	      информации, указывающей на версию.  То, что некоторые порты
	      имеют одинаковый <varname>PORTNAME</varname>, является вполне
	      нормальным, как для портов <filename>www/apache*</filename>;
	      в этом случае различные версии (и различные записи в индексе)
	      отличаются по значениям <varname>PKGNAMEPREFIX</varname>,
	      <varname>PKGNAMESUFFIX</varname> и
	      <varname>LATEST_LINK</varname>.</para>
          </listitem>

          <listitem>
	    <para>Если порт может быть построен с различными <link linkend="makefile-masterdir">статически заданными значениями по
	      умолчанию</link> (обычно это часть имени каталога в семействе
	      портов), то часть <replaceable>-compiled.specifics</replaceable>
	      должна определять вкомпилированные значения по умолчанию (дефис
	      не обязателен).  Примерами являются размеры бумаги и
	      шрифтов.</para>

            <para>Часть <replaceable>-compiled.specifics</replaceable> должна
              задаваться в переменной <varname>PKGNAMESUFFIX</varname>.</para>
          </listitem>

          <listitem>
	    <para>Строка с номером версии должна следовать за дефисом
	      (<literal>-</literal>) и являться списком разделенных двоеточием
	      чисел и букв в нижнем регистре.  В частности, не разрешается
              иметь еще один дефис внутри строки с обозначением номера версии.
	      Единственным исключением является строчка <literal>pl</literal>
	      (означающая <quote>patchlevel</quote>), которая может
              использоваться <emphasis>только</emphasis> тогда, когда у
              программного обеспечения нет старшего и младшего номера версии.
              Если в номер версии программного обеспечения включена строчка
              типа <quote>alpha</quote>, <quote>beta</quote>,
              <quote>rc</quote> или <quote>pre</quote>, возьмите из неё первую
              букву и поставьте её непосредственно после точки.  Если после
              таких строк номер версии ещё продолжается, то после буквы должно
              следовать число без дополнительной разделяющей точки.</para>

            <para>Смысл такого формата заключается в удобстве сортировки портов
              по номеру версии.  В частности, следите за тем, чтобы компоненты
              номера версии разделялись точкой, и если там присутствует дата,
              то используйте формат
              <literal>0.0.yyyy.mm.dd</literal>, но не
              <literal>dd.mm.yyyy</literal>
              или не совместимый с проблемой Y2K
              <literal>yy.mm.dd</literal>.
	      Добавление к версии префикса <literal>0.0.</literal> является
	      важным, в случае если выпущен релиз с присвоением настоящей
	      версии, которая в числовом представлении, конечно же, будет
	      ниже, чем
	      <literal>yyyy</literal>.</para>
          </listitem>
        </orderedlist>

        <para>Вот несколько (реальных) примеров того, как преобразовать имя из
          оригинального, придуманного авторами, к подходящему для имени
          пакета:</para>

        <informaltable frame="none" pgwide="1">
          <tgroup cols="6">
            <thead>
              <row>
	        <entry>Имя дистрибутива</entry>

                <entry><varname>PKGNAMEPREFIX</varname></entry>

                <entry><varname>PORTNAME</varname></entry>

                <entry><varname>PKGNAMESUFFIX</varname></entry>

                <entry><varname>PORTVERSION</varname></entry>

	        <entry>Обоснование</entry>
              </row>
            </thead>

            <tbody>
              <row>
	        <entry>mule-2.2.2</entry>
                <entry>(пусто)</entry>
                <entry>mule</entry>
                <entry>(пусто)</entry>
                <entry>2.2.2</entry>
	        <entry>Изменений не потребовалось</entry>
              </row>

	      <row>
		<entry>EmiClock-1.0.2</entry>
		<entry>(пусто)</entry>
		<entry>emiclock</entry>
		<entry>(пусто)</entry>
		<entry>1.0.2</entry>
		<entry>Для отдельных программ имена с заглавными буквами
		  запрещены</entry>
	      </row>

	      <row>
		<entry>rdist-1.3alpha</entry>
		<entry>(пусто)</entry>
		<entry>rdist</entry>
		<entry>(пусто)</entry>
		<entry>1.3.a</entry>
		<entry>Строчки типа <literal>alpha</literal> запрещены</entry>
	      </row>

	      <row>
		<entry>es-0.9-beta1</entry>
		<entry>(пусто)</entry>
		<entry>es</entry>
		<entry>(пусто)</entry>
		<entry>0.9.b1</entry>
		<entry>Строчки типа <literal>beta</literal> запрещены</entry>
	      </row>

	      <row>
		<entry>mailman-2.0rc3</entry>
		<entry>(пусто)</entry>
		<entry>mailman</entry>
		<entry>(пусто)</entry>
		<entry>2.0.r3</entry>
		<entry>Строчки типа <literal>rc</literal> запрещены</entry>
	      </row>

	      <row>
		<entry>v3.3beta021.src</entry>
		<entry>(пусто)</entry>
		<entry>tiff</entry>
		<entry>(пусто)</entry>
		<entry>3.3</entry>
		<entry>Что это такое было вообще?</entry>
	      </row>

	      <row>
		<entry>tvtwm</entry>
		<entry>(пусто)</entry>
		<entry>tvtwm</entry>
		<entry>(пусто)</entry>
		<entry>pl11</entry>
		<entry>Всегда требуется указание номера версии</entry>
	      </row>

	      <row>
		<entry>piewm</entry>
		<entry>(пусто)</entry>
		<entry>piewm</entry>
		<entry>(пусто)</entry>
		<entry>1.0</entry>
		<entry>Всегда требуется указание номера версии</entry>
	      </row>

	      <row>
		<entry>xvgr-2.10pl1</entry>
		<entry>(пусто)</entry>
		<entry>xvgr</entry>
		<entry>(пусто)</entry>
		<entry>2.10.1</entry>
		<entry><literal>pl</literal> разрешено только при отсутствии
		  старшего/младшего номера версии</entry>
	      </row>

	      <row>
		<entry>gawk-2.15.6</entry>
		<entry>ja-</entry>
		<entry>gawk</entry>
		<entry>(пусто)</entry>
		<entry>2.15.6</entry>
		<entry>Версия на японском языке</entry>
	      </row>

	      <row>
		<entry>psutils-1.13</entry>
		<entry>(пусто)</entry>
		<entry>psutils</entry>
		<entry>-letter</entry>
		<entry>1.13</entry>
		<entry>Размер бумаги задается статически во время построения
		  пакета</entry>
	      </row>

	      <row>
		<entry>pkfonts</entry>
		<entry>(пусто)</entry>
		<entry>pkfonts</entry>
		<entry>300</entry>
		<entry>1.0</entry>
		<entry>пакет для шрифтов 300dpi</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

        <para>Если в исходном коде абсолютно нет информации о номере версии и
          не похоже, что автор собирается выпускать другую версию, то в
          качестве номера версии задайте просто <literal>1.0</literal> (как в
          примере с <literal>piewm</literal> выше).  В противном случае
          спросите автора программы или используйте дату
          (<literal>0.0.yyyy.mm.dd</literal>)
          в качестве номера версии.</para>
      </sect2>
    </sect1>

    <sect1 xml:id="makefile-categories">
      <title>Разделение по категориям</title>

      <sect2>
        <title><varname>CATEGORIES</varname></title>

        <para>В процессе создания пакета он помещается в каталог
	  <filename>/usr/ports/packages/All</filename>, а в одном или более
	  подкаталогов из <filename>/usr/ports/packages</filename>
	  создаются на него ссылки.  Имена этих подкаталогов определяются
	  переменной <varname>CATEGORIES</varname>.  Такая схема нужна для
	  облегчения жизни пользователя, когда он сталкивается с массой
	  пакетов на FTP-сервере или компакт-диске.  Пожалуйста, посмотрите на
	  <link linkend="porting-categories">текущий список категорий</link>
	  и выберите те из них,
	  которые более всего подходят к вашему порту.</para>

        <para>Этот список также определяет, куда в дереве портов будет помещен
	  порт.  Если вы укажете здесь более одной категории, то
	  предполагается, что файлы порта будут помещены в подкаталог с именем
	  первой категории.  Посмотрите <link linkend="choosing-categories">ниже</link> для получения
	  подробной информации о том, как правильно выбрать категории.</para>
      </sect2>

      <sect2 xml:id="porting-categories">
        <title>Текущий список категорий</title>

        <para>Вот текущий список категорий.  Те, которые отмечены
	  звёздочкой (<literal>*</literal>), являются
	  <emphasis>виртуальными</emphasis> категориями&mdash;они не имеют
	  собственного подкаталога в дереве портов.  Они используются только в
          качестве вторичных категорий, и только для поиска.</para>

        <note>
	  <para>Для невиртуальных категорий имеется однострочное описание
	    в <varname>COMMENT</varname> в <filename>Makefile</filename>
	    соответствующего подкаталога.</para>
        </note>

        <informaltable frame="none" pgwide="1">
          <tgroup cols="3">
            <thead>
	      <row>
	        <entry>Категория</entry>

	        <entry>Описание</entry>

                <entry>Примечания</entry>
	      </row>
            </thead>

            <tbody>
	      <row>
                <entry><filename>accessibility</filename></entry>
                <entry>Порты для помощи пользователям с ограниченными
                  возможностями.</entry>
                <entry/>
              </row>

	      <row>
	        <entry><filename>afterstep*</filename></entry>
	        <entry>Порты, поддерживающие менеджер окон <link xlink:href="http://www.afterstep.org">AfterStep</link>.</entry>
                <entry/>
	      </row>

	      <row>
                <entry><filename>arabic</filename></entry>
                <entry>Поддержка арабского языка.</entry>
                <entry/>
              </row>

              <row>
	        <entry><filename>archivers</filename></entry>
	        <entry>Инструменты для работы с архивами.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>astro</filename></entry>
	        <entry>Приложения, связанные с астрономией.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>audio</filename></entry>
	        <entry>Поддержка работы со звуком.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>benchmarks</filename></entry>
	        <entry>Утилиты для измерения производительности системы.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>biology</filename></entry>
	        <entry>Программное обеспечение, связанное с биологией.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>cad</filename></entry>
	        <entry>Инструменты Систем Автоматизированного
	          Проектирования.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>chinese</filename></entry>
	        <entry>Поддержка китайского языка.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>comms</filename></entry>
	        <entry>Коммуникационное программное обеспечение.</entry>
                <entry>В основном программы для работы с последовательным
                  портом.</entry>
	      </row>

	      <row>
	        <entry><filename>converters</filename></entry>
	        <entry>Утилиты для преобразования символьных форматов.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>databases</filename></entry>
	        <entry>Базы данных.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>deskutils</filename></entry>
	        <entry>То, что было на столе до изобретения компьютеров.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>devel</filename></entry>
	        <entry>Утилиты для разработки программного обеспечения.</entry>
                <entry>Не помещайте сюда библиотеки просто потому что это
	          библиотеки&mdash;если они подпадают под какую-то другую
	          категорию, то их быть здесь не должно.</entry>
	      </row>

              <row>
                <entry><filename>dns</filename></entry>
                <entry>Программное обеспечение для работы с DNS.</entry>
                <entry/>
              </row>

              <row>
                <entry><filename>docs*</filename></entry>
                <entry>Мета-порты для документации FreeBSD.</entry>
                <entry/>
              </row>

	      <row>
	        <entry><filename>editors</filename></entry>
	        <entry>Редакторы общего назначения.</entry>
                <entry>Специализированные редакторы относят к разделу для
                  соответствующих инструментов (например, редактор
                  математических формул попадает в
                  категорию <filename>math</filename>).</entry>
	      </row>

	      <row>
	        <entry><filename>elisp*</filename></entry>
	        <entry>Порты для Emacs lisp.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>emulators</filename></entry>
	        <entry>Эмуляторы других операционных систем.</entry>
                <entry>Эмуляторы терминалов сюда <emphasis>не</emphasis>
                  относятся&mdash;те, которые разработаны для X, должны быть в
                  категории <filename>x11</filename>, а текстовые в
	          <filename>comms</filename> или <filename>misc</filename>, в
	          зависимости от конкретного их предназначения.</entry>
	      </row>

	      <row>
                <entry><filename>finance</filename></entry>
                <entry>Приложения для работы с деньгами, финансами и всем, что
                  с этим связано.</entry>
                <entry/>
              </row>

              <row>
                <entry><filename>french</filename></entry>
                <entry>Поддержка французского языка.</entry>
                <entry/>
              </row>

              <row>
	        <entry><filename>ftp</filename></entry>
	        <entry>Клиенты и серверы FTP.</entry>
                <entry>Если ваш порт понимает как FTP,
	          так и HTTP, поместите его в категорию
                  <filename>ftp</filename> и укажите вторичную категорию
                  <filename>www</filename>.</entry>
	      </row>

	      <row>
	        <entry><filename>games</filename></entry>
	        <entry>Игры.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>geography*</filename></entry>
	        <entry>Программное обеспечение, связанное с географией.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>german</filename></entry>
	        <entry>Поддержка немецкого языка.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>gnome*</filename></entry>
	        <entry>Порты Проекта <link xlink:href="http://www.gnome.org">GNOME</link>.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>gnustep*</filename></entry>
	        <entry>Программное обеспечение для окружения рабочего
		  стола GNUstep.</entry>
                <entry/>
              </row>

	      <row>
	        <entry><filename>graphics</filename></entry>
	        <entry>Графические утилиты.</entry>
                <entry/>
              </row>

	      <row>
	        <entry><filename>hamradio*</filename></entry>
	        <entry>Программное обеспечение для любительского радио</entry>
                <entry/>
              </row>

              <row>
                <entry><filename>haskell*</filename></entry>
                <entry>Программное обеспечение, связанное с языком
                  Haskell.</entry>
                <entry/>
              </row>

              <row>
                <entry><filename>hebrew</filename></entry>
                <entry>Поддержка иврита.</entry>
                <entry/>
	      </row>

	      <row>
                <entry><filename>hungarian</filename></entry>
                <entry>Поддержка венгерского языка.</entry>
                <entry/>
              </row>

              <row>
	        <entry><filename>ipv6*</filename></entry>
	        <entry>Программное обеспечение, связанное с IPv6.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>irc</filename></entry>
	        <entry>Утилиты для работы с Internet Relay Chat.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>japanese</filename></entry>
	        <entry>Поддержка японского языка.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>java</filename></entry>
	        <entry>Программное обеспечение, связанное с языком
                  Java&trade;.</entry>
                <entry>Категория <filename>java</filename> ни в коем случае
		  не должна быть единственной для порта.  Оставьте для портов,
		  непосредственно имеющих отношение к языку Java, портерам
		  также рекомендуется не использовать
		  <filename>java</filename> как основную категорию
		  порта.</entry>
	      </row>

	      <row>
	        <entry><filename>kde*</filename></entry>
		<entry>Порты проекта
		  <link xlink:href="http://www.kde.org">KDE</link>.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>kld*</filename></entry>
	        <entry>Загружаемые модули ядра.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>korean</filename></entry>
	        <entry>Поддержка корейского языка.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>lang</filename></entry>
	        <entry>Языки программирования.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>linux*</filename></entry>
	        <entry>Linux приложения и утилиты.</entry>
                <entry/>
	      </row>

	      <row>
                <entry><filename>lisp*</filename></entry>
                <entry>Программное обеспечение, связанное с языком
                  Lisp.</entry>
                <entry/>
              </row>

              <row>
	        <entry><filename>mail</filename></entry>
	        <entry>Программы для работы с электронной почтой.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>math</filename></entry>
	        <entry>Программное обеспечение для численных вычислений и
                  другие утилиты, связанные с математикой.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>mbone*</filename></entry>
	        <entry>Приложения для MBone.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>misc</filename></entry>
	        <entry>Различные утилиты</entry>
                <entry>В основном то, что не попадает в
	          другие категории.  Если это возможно, попробуйте найти
                  более подходящую, чем <literal>misc</literal>, категорию для
                  вашего порта, так как здесь порты теряются.</entry>
	      </row>

	      <row>
                <entry><filename>multimedia</filename></entry>
                <entry>Программное обеспечение для работы с
                  мультимедиа.</entry>
                <entry/>
              </row>

              <row>
	        <entry><filename>net</filename></entry>
	        <entry>Различное сетевое программное обеспечение.</entry>
                <entry/>
	      </row>

              <row>
	        <entry><filename>net-im</filename></entry>
	        <entry>Программы мгновенного обмена сообщениями.</entry>
                <entry/>
	      </row>

	      <row>
                <entry><filename>net-mgmt</filename></entry>
                <entry>Программное обеспечение для сетевого управления.</entry>
                <entry/>
              </row>

	      <row>
                <entry><filename>net-p2p</filename></entry>
                <entry>Приложения для пиринговых сетей.</entry>
                <entry/>
              </row>

              <row>
	        <entry><filename>news</filename></entry>
	        <entry>Программное обеспечение для работы с конференциями
	          USENET.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>palm</filename></entry>
	        <entry>Программная поддержка <link xlink:href="http://www.palm.com/">Palm&trade;</link>.</entry>
                <entry/>
	      </row>

              <row>
                <entry><filename>parallel*</filename></entry>
                <entry>Приложения, связанные с параллельными
                  вычислениями.</entry>
                <entry/>
              </row>

              <row>
                <entry><filename>pear*</filename></entry>
                <entry>Порты, относящиеся к технологии Pear PHP.</entry>
                <entry/>
              </row>

              <row>
	        <entry><filename>perl5*</filename></entry>
	        <entry>Порты, которым для работы требуется
                  <application>Perl</application> версии 5.</entry>
                <entry/>
              </row>

	      <row>
	        <entry><filename>plan9*</filename></entry>
	        <entry>Различные программы из <link xlink:href="http://www.cs.bell-labs.com/plan9dist/">
                  Plan9</link>.</entry>
                <entry/>
	      </row>

              <row>
                <entry><filename>polish</filename></entry>
                <entry>Поддержка польского языка.</entry>
                <entry/>
              </row>

              <row>
                <entry><filename>ports-mgmt</filename></entry>
                <entry>Порты для управления, установки и разработки
		  портов и пакетов FreeBSD.</entry>
                <entry/>
              </row>

	      <row>
                <entry><filename>portuguese</filename></entry>
                <entry>Поддержка португальского языка.</entry>
                <entry/>
              </row>

              <row>
	        <entry><filename>print</filename></entry>
	        <entry>Программное обеспечение для печати.</entry>
                <entry>Инструменты для вёрстки (просмотрщики и тому подобное)
                  тоже относятся сюда.</entry>
	      </row>

	      <row>
	        <entry><filename>python*</filename></entry>
	        <entry>Программное обеспечение, связанное с языком <link xlink:href="http://www.python.org/">Python</link>.</entry>
                <entry/>
              </row>

              <row>
                <entry><filename>ruby*</filename></entry>
	        <entry>Программное обеспечение, связанное с языком <link xlink:href="http://www.ruby-lang.org/">Ruby</link>.</entry>
                <entry/>
	      </row>

              <row>
                <entry><filename>rubygems*</filename></entry>
	        <entry>Порты для пакетов <link xlink:href="http://www.rubygems.org/">RubyGems</link>.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>russian</filename></entry>
	        <entry>Поддержка русского языка.</entry>
                <entry/>
	      </row>

              <row>
                <entry><filename>scheme*</filename></entry>
                <entry>Программное обеспечение, связанное с языком
		  Scheme.</entry>
                <entry/>
              </row>

              <row>
                <entry><filename>science</filename></entry>
                <entry>Научные программы, которые не подпадают под другие
                  категории, скажем, <filename>astro</filename>,
                  <filename>biology</filename> или
                  <filename>math</filename>.</entry>
                <entry/>
              </row>

	      <row>
	        <entry><filename>security</filename></entry>
	        <entry>Программы, обеспечивающие безопасность системы.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>shells</filename></entry>
	        <entry>Различные командные процессоры.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>sysutils</filename></entry>
	        <entry>Системные утилиты.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>spanish*</filename></entry>
	        <entry>Поддержка испанского языка.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>tcl*</filename></entry>
	        <entry>Порты, для работы которых нужен Tcl.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>textproc</filename></entry>
	        <entry>Утилиты для обработки текстов.</entry>
                <entry>Инструменты для вёрстки помещаются в категорию
                  <filename>print</filename>, а не сюда.</entry>
	      </row>

	      <row>
	        <entry><filename>tk*</filename></entry>
	        <entry>Порты, для работы которых нужен Tk.</entry>
                <entry/>
	      </row>

              <row>
                <entry><filename>ukrainian</filename></entry>
                <entry>Поддержка украинского языка.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>vietnamese</filename></entry>
	        <entry>Поддержка вьетнамского языка.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>windowmaker*</filename></entry>
	        <entry>Порты, поддерживающие менеджер окон WindowMaker.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>www</filename></entry>
	        <entry>Программное обеспечение, связанное с World Wide
                  Web.</entry>
	        <entry>Поддержка языка HTML относится сюда же.</entry>
	      </row>

	      <row>
	        <entry><filename>x11</filename></entry>
	        <entry>X Window System и иже с ними.</entry>
                <entry>Эта категория
                  предназначена только для программного обеспечения, которое
                  поддерживает саму оконную систему.  Не помещайте сюда
                  обычные приложения для X: большинство из них должны быть
                  перенесены в другие категории <filename>x11-*</filename>
		  (смотрите ниже).</entry>
	      </row>

	      <row>
	        <entry><filename>x11-clocks</filename></entry>
	        <entry>Часы для X11.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>x11-drivers</filename></entry>
	        <entry>Драйверы X11.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>x11-fm</filename></entry>
	        <entry>Менеджеры файлов для X11.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>x11-fonts</filename></entry>
	        <entry>Шрифты для X11 и утилиты для работы с ними.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>x11-servers</filename></entry>
	        <entry>Серверы для X11.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>x11-themes</filename></entry>
	        <entry>Темы для X11.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>x11-toolkits</filename></entry>
	        <entry>Пакеты разработчика для X11.</entry>
                <entry/>
	      </row>

	      <row>
	        <entry><filename>x11-wm</filename></entry>
	        <entry>Оконные менеджеры для X11.</entry>
                <entry/>
              </row>

              <row>
                <entry><filename>xfce*</filename></entry>
                <entry>Порты, связанные с окружением рабочего стола
		  <link xlink:href="http://www.xfce.org/">Xfce</link>.</entry>
                <entry/>
	      </row>

              <row>
                <entry><filename>zope*</filename></entry>
                <entry>Поддержка <link xlink:href="http://www.zope.org/">Zope</link>.</entry>
                <entry/>
	      </row>
            </tbody>
          </tgroup>
        </informaltable>
      </sect2>

      <sect2 xml:id="choosing-categories">
        <title>Выбор правильной категории</title>

        <para>Так как многие категории перекрываются, вам часто необходимо
	  будет выбирать, какая их них должна быть основной для вашего порта.
	  Есть несколько правил, по которым можно решить этот вопрос. Вот
	  список приоритетов, в уменьшающейся степени предпочтения:</para>

        <itemizedlist>
	  <listitem>
	    <para>Первая категория должна быть физической категорий (смотрите
	      <link linkend="porting-categories">выше</link>). Это
	      необходимо для создания пакетов.  После этого виртуальные
	      и физические категории могут смешиваться.</para>
	  </listitem>

	  <listitem>
	    <para>Сначала всегда идут категории, специфичные для языков.
	      Например, если ваш порт устанавливает японские шрифты для X11,
	      то строчка <varname>CATEGORIES</varname> должна иметь вид
	      <filename>japanese x11-fonts</filename>.</para>
	  </listitem>

	  <listitem>
	    <para>Более конкретные категории идут первыми перед более
              общими.  В частности, редактор HTML должен быть описан как
	      <filename>www editors</filename>, а не наоборот.  Кроме того, вы
              не должны указывать категорию <filename>net</filename>, если порт
	      относится к одной из категорий <filename>irc</filename>,
	      <filename>mail</filename>,
	      <filename>news</filename>, <filename>security</filename> или
	      <filename>www</filename>, так как <filename>net</filename>
              включается автоматически.</para>
	  </listitem>

	  <listitem>
	    <para><filename>x11</filename> используется как вторичная категория
	      только в случае, если в качестве основной категории указан
	      естественный язык.  В частности, вам не нужно указывать
	      <filename>x11</filename> в качестве категории для
	      приложений X.</para>
	  </listitem>

	  <listitem>
	    <para>Режимы для редактора <application>Emacs</application> должны
	      помещаться в ту же категорию, что и приложение, которое
	      поддерживается этим режимом, а не в <filename>editors</filename>.
	      Например, режим <application>Emacs</application> для
	      редактирования исходного кода некоторого языка программирования
	      должен быть помещен в категорию <filename>lang</filename>.</para>
	  </listitem>

	  <listitem>
	    <para>Порты, устанавливающие загружаемые модули ядра, должны
	      содержать виртуальную категорию <filename>kld</filename> в
	      строке <varname>CATEGORIES</varname>.
	    </para>
	  </listitem>

	  <listitem>
	    <para><filename>misc</filename>
		  не должна указываться вместе с любой другой невиртуальной
		  категорией.  Если вы указываете <literal>misc</literal>
		  вместе с чем-то ещё в строке <varname>CATEGORIES</varname>,
                  это значит, что вы можете спокойно удалить
		  <literal>misc</literal> и просто поместить порт в этот
		  другой подкаталог!</para>
	  </listitem>

	  <listitem>
	    <para>Если ваш порт решительным образом не подпадает ни под какую
              категорию, поместите его в <filename>misc</filename>.</para>
          </listitem>
        </itemizedlist>

        <para>Если вы не уверены в правильности выбора категории, пожалуйста,
	  отметьте это в вашем сообщении через &man.send-pr.1;, чтобы мы
	  могли обсудить это до того, как включить порт в Коллекцию.  Если вы
	  являетесь коммиттером, пошлите замечание на адрес &a.ports;, чтобы мы
	  могли обсудить это.  Зачастую новые порты помещаются не в ту
          категорию только для того, чтобы их оттуда сразу же удалили.
          Это приводит к излишнему и ненужному росту основного хранилища
          исходных текстов.</para>
      </sect2>

      <sect2 xml:id="proposing-categories">
	<title>Предложение новой категории</title>

	<para>Поскольку со временем Коллекция Портов увеличилась, то в связи
	  с этим были добавлены различные новые категории.  Новые категории
	  могут быть или <emphasis>виртуальными</emphasis> категориями&mdash;
	  которые не имеют соответствующего подкаталога в дереве портов&mdash;
	  или <emphasis>физическими</emphasis> категориями&mdash;у которых
	  он есть.  Следующий текст содержит обсуждение вопросов, возникающих
	  при создании новой физической категории, чтобы вы могли понимать
	  их, когда предложите новую категорию.</para>

	<para>В соответствие с существующей практикой мы избегаем создания
	  новой физической категории, пока достаточно большое число портов
	  логически ей не принадлежит или же порты, которые могли бы ей
	  принадлежать, не являются логически обособленной группой,
	  представляющей для всех ограниченный интерес (в частности,
	  категории, относящиеся к естественным языкам); предпочтительно
	  выполнение обоих условий.</para>

	<para>Основной причиной для этого является то, что такое изменение
	  создает <link xlink:href="&url.articles.committers-guide;/#ports">изрядное
	  количество работы</link> и для коммиттеров, и для всех тех
	  пользователей, которые отслеживают изменения в Коллекции Портов.
	  В дополнение, предложенная категория создает естественное
	  разногласие.  (Пожалуй, потому что не существует четкого соглашения,
	  является ли категория <quote>слишком большой</quote>, или должны
	  ли категории предоставлять себя для просмотра (и, таким образом,
	  какое количество категорий было бы идеальным значением), и так
	  далее.)</para>

	<para>Процедура:</para>

	<procedure>
	  <step>
	    <para>Предложите новую категорию на &a.ports;. Вам следует
	      включить для новой категории детальное обоснование, в том числе
	      почему вы считаете, что существующие категории не являются
	      достаточными, и список существующих портов, предложенных для
	      перемещения.  (Если есть новые порты, ожидающие в
	      <application>GNATS</application> и попадающие в эту категорию,
	      то укажите их тоже.)  Если вы являетесь сопровождающим и/или
	      отправителем, то укажите это соответственно, так как это может
	      помочь вам в вашем деле.</para>
	  </step>

	  <step>
	    <para>Принимайте участие в обсуждении.</para>
	  </step>

	  <step>
	    <para>Если кажется, что для вашей идеи появилась поддержка,
	      отправьте PR, который будет включать обоснование и список
	      существующих портов, которые надо переместить.  В идеале
	      этот PR должен также включать патчи для следующего:</para>

	    <itemizedlist>
	      <listitem>
		<para><filename>Makefile</filename>'ы для новых портов в
		  результате репозиторного копирования</para>
	      </listitem>

	      <listitem>
		<para><filename>Makefile</filename> для категорий старых
		  портов</para>
	      </listitem>

	      <listitem>
		<para><filename>Makefile</filename>'ы для портов, зависящих
		  от старых портов</para>
	      </listitem>

	      <listitem>
		<para>(в дополнение, вы можете включить другие файлы,
		  требующие изменений, согласно процедуре из Руководства
		  Коммиттера.)</para>
	      </listitem>
	    </itemizedlist>
	  </step>

	  <step>
	    <para>Поскольку это затрагивает инфраструктуру портов и
	      охватывает не только выполнение репозиторного копирования, но
	      также, возможно, и выполнение регрессивных тестов на кластере
	      построения, то PR должна назначать себе &a.portmgr;.</para>
	  </step>

	  <step>
	    <para>Если этот PR одобрен, то коммиттеру нужно продолжить
	      остальную часть процедуры, которая <link xlink:href="&url.articles.committers-guide;/article.html#PORTS">
	      изложена в Руководстве Коммиттера</link>.</para>
	  </step>
	</procedure>

	<para>Предложение новой виртуальной категории должно быть схожим
	  с вышеизложенным, но при этом затрагивать намного меньше,
	  поскольку ни один из портов не будет перемещен в действительности.
	  В этом случае единственными патчами, включенными в PR, будут
	  те, что добавляют новую категорию в <varname>CATEGORIES</varname>
	  каждого из затрагиваемых портов.</para>
      </sect2>

      <sect2 xml:id="proposing-reorg">
	<title>Предложение реорганизации всех категорий</title>

	<para>Время от времени кто-нибудь предлагает произвести реорганизацию
	  категорий либо до двухуровневой, либо другого типа на основе
	  ключевых слов.  На данный момент из этих предложений ничего не
	  получилось, потому что, хотя они просты в реализации, но
	  предполагаемая переделка всей коллекции портов по меньшей мере
	  приводит в уныние.  Пожалуйста, прочтите историю этих предложений
	  в архивах рассылок перед тем, как присылать свои соображения;
	  более того, вы должны быть готовы представить работающий
	  прототип.</para>
      </sect2>
    </sect1>

    <sect1 xml:id="makefile-distfiles">
      <title>Дистрибутивные файлы</title>

      <para>Во второй части <filename>Makefile</filename> задаётся, какие
        файлы и откуда должны быть сгружены для того, чтобы построить
        порт.</para>

      <sect2>
        <title><varname>DISTVERSION/DISTNAME</varname></title>

        <para>В переменной <varname>DISTNAME</varname> указывается имя порта
          так, как назвали его создатели программного обеспечения.  Значение
          <varname>DISTNAME</varname> по умолчанию совпадает с
          <literal>${PORTNAME}-${PORTVERSION}</literal>, так что
          переопределяете её значение только в случае необходимости.
          <varname>DISTNAME</varname> используется только в двух местах.
          Во-первых, список дистрибутивных файлов
          (<varname>DISTFILES</varname>) по умолчанию состоит из
          <varname>${DISTNAME}</varname><varname>${EXTRACT_SUFX}</varname>.  И
          во-вторых, предполагается, что дистрибутивный файл будет распакован в
          подкаталог с именем <varname>WRKSRC</varname>, значение которого по
          умолчанию есть не что иное, как
          <filename>work/${DISTNAME}</filename>.</para>

	<para>Названия некоторых дистрибутивов, которые не укладываются в
	  <literal>${PORTNAME}-${PORTVERSION}</literal>-схему, могут быть
	  автоматически обработаны посредством установки переменной
	  <varname>DISTVERSION</varname>.  <varname>PORTVERSION</varname> и
	  <varname>DISTNAME</varname> будут унаследованы автоматически, но
	  конечно же могут быть переопределены.  Следующая таблица
	  демонстрирует некоторые примеры:</para>

	<informaltable frame="none" pgwide="0">
	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry><varname>DISTVERSION</varname></entry>
		<entry><varname>PORTVERSION</varname></entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry>0.7.1d</entry>
		<entry>0.7.1.d</entry>
	      </row>

	      <row>
		<entry>10Alpha3</entry>
		<entry>10.a3</entry>
	      </row>

	      <row>
		<entry>3Beta7-pre2</entry>
		<entry>3.b7.p2</entry>
	      </row>

	      <row>
		<entry>8:f_17</entry>
		<entry>8f.17</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

        <note>
          <para>Значения переменных <varname>PKGNAMEPREFIX</varname>
            и <varname>PKGNAMESUFFIX</varname> не влияют на значение
            <varname>DISTNAME</varname>.  Заметьте также, что если значение
            <varname>WRKSRC</varname> равно
            <filename>work/${PORTNAME}-${PORTVERSION}</filename>,
            и в случае, когда оригинальный архив называется по имени, отличном
            от <varname>${PORTNAME}-${PORTVERSION}${EXTRACT_SUFX}</varname>,
            скорее всего, вы должны оставить <varname>DISTNAME</varname>
            как есть&mdash; лучше переопределить <varname>DISTFILES</varname>,
            чем задавать значения как
            <varname>DISTNAME</varname>, так и <varname>WRKSRC</varname>
            (и, возможно, ещё и <varname>EXTRACT_SUFX</varname>).</para>
        </note>
      </sect2>

      <sect2>
        <title><varname>MASTER_SITES</varname></title>

        <para>Содержит часть с каталогом FTP/HTTP-URL, которая указывает на
	  оригинальный архив на сервере <varname>MASTER_SITES</varname>.  Не
	  забудьте лидирующий слэш (<filename>/</filename>)!</para>

        <para>Макрос команды <command>make</command> будет пытаться
	  воспользоваться этой переменной для получения дистрибутивного файла
	  с помощью программы <varname>FETCH</varname>, если он не будет найден
	  в системе.</para>

        <para>Рекомендуется помещать в список много сайтов, предпочтительно с
	  разных континентов.  Это поможет при наличии проблем с мировой сетью.
	  Мы даже планируем добавить поддержку автоматического определения
	  ближайшего сайта и сгрузки файлов оттуда; наличие нескольких сайтов
          будет способствовать этому начинанию.</para>

        <para>Если оригинальный архив находится на одном из таких популярных
          серверов, как SourceForge, GNU или Perl CPAN, то указывайте эти
	  сайты в простой форме при помощи
          <varname>MASTER_SITE_<replaceable>*</replaceable></varname>
          (к примеру, <varname>MASTER_SITE_SOURCEFORGE</varname>,
	  <varname>MASTER_SITE_GNU</varname> или
	  <varname>MASTER_SITE_PERL_CPAN</varname>.  Просто укажите в переменной
          <varname>MASTER_SITES</varname> одно из этих значений, а в
	  переменной <varname>MASTER_SITE_SUBDIR</varname> задайте путь к
          архиву.  Вот пример:</para>

        <programlisting>MASTER_SITES=         ${MASTER_SITE_GNU}
MASTER_SITE_SUBDIR=   make</programlisting>

	<para>Или можно использовать сокращенный формат:</para>

	<programlisting>MASTER_SITES=	GNU/make</programlisting>

        <para>Эти переменные определены в файле
          <filename>/usr/ports/Mk/bsd.sites.mk</filename>.  Всё время
          добавляются новые записи, так что обращайтесь к последней версии
          этого файла перед тем, как послать нам свой порт.</para>

        <para>Для популярных сайтов существует несколько
	  <emphasis>магических</emphasis> макросов с заранее известной
	  структурой каталогов.  Используйте для них сокращения, и система
	  попытается угадать для вас правильный подкаталог.</para>

	<programlisting>MASTER_SITES=   SF</programlisting>

	<para>Если попытка угадать не удалась, то это может быть переписано
	  следующим образом.</para>

	<programlisting>MASTER_SITES=   SF/stardict/WyabdcRealPeopleTTS/${PORTVERSION}</programlisting>

	<para>Что также можно записать в таком виде:</para>

	<programlisting>MASTER_SITES=	SF
MASTER_SITE_SUBDIR=	stardict/WyabdcRealPeopleTTS/${PORTVERSION}</programlisting>

	<table frame="none">
	  <title>Популярные магические макросы для
	    <varname>MASTER_SITES</varname></title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Macro</entry>

		<entry>Assumed subdirectory</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><varname>BERLIOS</varname></entry>

		<entry><varname>/${PORTNAME:L}</varname></entry>
	      </row>

	      <row>
		<entry><varname>CHEESESHOP</varname></entry>

		<entry><varname>/packages/source/source/${DISTNAME:C/(.).*/\1/}/${DISTNAME:C/(.*)-[0-9].*/\1/}</varname></entry>
	      </row>

	      <row>
		<entry><varname>DEBIAN</varname></entry>

		<entry><varname>/debian/pool/main/${PORTNAME:C/^((lib)?.).*$/\1/}/${PORTNAME}</varname></entry>
	      </row>

	      <row>
		<entry><varname>GCC</varname></entry>

		<entry><varname>/pub/gcc/releases/${DISTNAME}</varname></entry>
	      </row>

	      <row>
		<entry><varname>GNOME</varname></entry>

		<entry><varname>/pub/GNOME/sources/${PORTNAME}/${PORTVERSION:C/^([0-9]+\.[0-9]+).*/\1/}</varname></entry>
	      </row>

	      <row>
		<entry><varname>GNU</varname></entry>

		<entry><varname>/gnu/${PORTNAME}</varname></entry>
	      </row>

	      <row>
		<entry><varname>MOZDEV</varname></entry>

		<entry><varname>/pub/mozdev/${PORTNAME:L}</varname></entry>
	      </row>

	      <row>
		<entry><varname>PERL_CPAN</varname></entry>

		<entry><varname>/pub/CPAN/modules/by-module/${PORTNAME:C/-.*//}</varname></entry>
	      </row>

	      <row>
		<entry><varname>PYTHON</varname></entry>

		<entry><varname>/ftp/python/${PYTHON_PORTVERSION:C/rc[0-9]//}</varname></entry>
	      </row>

	      <row>
		<entry><varname>RUBYFORGE</varname></entry>

		<entry><varname>/${PORTNAME:L}</varname></entry>
	      </row>

	      <row>
		<entry><varname>SAVANNAH</varname></entry>

		<entry><varname>/${PORTNAME:L}</varname></entry>
	      </row>

	      <row>
		<entry><varname>SF</varname></entry>

		<entry><varname>/project/${PORTNAME:L}/${PORTNAME:L}/${PORTVERSION}</varname></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </sect2>

      <sect2>
        <title><varname>EXTRACT_SUFX</varname></title>

        <para>Если у вас имеется один дистрибутивный файл, и в его имени
          используется странное окончание для указания типа сжатия, задайте
          переменную <varname>EXTRACT_SUFX</varname>.</para>

        <para>К примеру, если дистрибутивный файл носит имя
          <filename>foo.tgz</filename>, а не более привычное
          <filename>foo.tar.gz</filename>, вы должны написать:</para>

        <programlisting>DISTNAME=      foo
EXTRACT_SUFX=  .tgz</programlisting>

        <para>Переменные <varname>USE_BZIP2</varname>,
	  <varname>USE_XZ</varname> и
          <varname>USE_ZIP</varname> при необходимости автоматически
	  устанавливают значение <varname>EXTRACT_SUFX</varname> в
	  <literal>.tar.bz2</literal>, <literal>.tar.xz</literal> или
	  <literal>.zip</literal>.  Если ни одна из этих
          переменных не задана, то значение <varname>EXTRACT_SUFX</varname>
          по умолчанию устанавливается в <literal>.tar.gz</literal>.</para>

        <note>
          <para>Вам не нужно задавать значения <varname>EXTRACT_SUFX</varname>
            и <varname>DISTFILES</varname> одновременно.</para>
        </note>
      </sect2>

      <sect2>
        <title><varname>DISTFILES</varname></title>

        <para>Иногда имена сгружаемых файлов не соответствуют имени порта.  К
          примеру, файл может называться <filename>source.tar.gz</filename> или
          подобным образом.  В других случаях исходный код приложения может
          располагаться в нескольких отличающихся архивах, и все они должны
          быть сгружены.</para>

        <para>Если это ваш случай, то задайте в переменной
          <varname>DISTFILES</varname> список разделённых пробелами имён
          файлов, которые нужно сгрузить.</para>

        <programlisting>DISTFILES=     source1.tar.gz source2.tar.gz</programlisting>

        <para>Если переменная <varname>DISTFILES</varname> не задана явно, то
          её значением по умолчанию будет
          <literal>${DISTNAME}${EXTRACT_SUFX}</literal>.</para>
      </sect2>

      <sect2>
        <title><varname>EXTRACT_ONLY</varname></title>

        <para>Если только некоторые из <varname>DISTFILES</varname> должны быть
          распакованы&mdash;к примеру, часть из них является исходным кодом, а
          другие представляют собой неупакованную
          документацию&mdash;перечислите имена файлов, которые должны быть
          распакованы, в <varname>EXTRACT_ONLY</varname>.</para>

        <programlisting>DISTFILES=     source.tar.gz manual.html
EXTRACT_ONLY=  source.tar.gz</programlisting>

        <para>Если <emphasis>ни один</emphasis> из <varname>DISTFILES</varname>
          не должен распаковываться, то установите пустое значение
          переменной <varname>EXTRACT_ONLY</varname>.</para>

        <programlisting>EXTRACT_ONLY=</programlisting>
      </sect2>

      <sect2 xml:id="porting-patchfiles">
        <title><varname>PATCHFILES</varname></title>

        <para>Если вашему порту требуются некоторых дополнительные патчи,
	  которые доступны по FTP или HTTP, задайте имена этих файлов в
	  переменной <varname>PATCHFILES</varname>, а в переменной
	  <varname>PATCH_SITES</varname> укажите URL того каталога, в котором
	  они содержатся (формат такой же, как
	  для <varname>MASTER_SITES</varname>).</para>

        <para>Если патч не относится к самому верху дерева исходных текстов
	  (то есть <varname>WRKSRC</varname>), потому что он содержит некоторые
	  дополнительные пути, установите соответственно значение переменной
	  <varname>PATCH_DIST_STRIP</varname>.  В частности, если все имена
	  путей в патче имеют дополнительный путь
	  <literal>foozolix-1.0/</literal> перед именем файла, то задайте
	  <literal>PATCH_DIST_STRIP=-p1</literal>.</para>

        <para>Не волнуйтесь, если патчи упакованы; они будут распакованы
	  автоматически, если имена файлов оканчиваются на
	  <filename>.gz</filename> или <filename>.Z</filename>.</para>

        <para>Если патч распространяется вместе с какими-то другими файлами,
	  такими, как документация, в виде tar-архива <command>gzip</command>,
	  вы не можете просто
	  использовать <varname>PATCHFILES</varname>.  Если это ваш случай,
	  добавьте имя и местоположение архива с патчем к
	  <varname>DISTFILES</varname> и <varname>MASTER_SITES</varname>.
          Затем воспользуйтесь переменной <varname>EXTRA_PATCHES</varname> для
          указания этих файлов, и <filename>bsd.port.mk</filename> автоматически
          применит эти патчи.  В частности, <emphasis>не копируйте</emphasis>
          файлы с патчами в каталог <varname>PATCHDIR</varname>&mdash;этот
          каталог может быть недоступным для записи.</para>

        <note>
	  <para>Архив будет распакован вне исходного кода, как
	    обычно, и к тому же его не нужно явно распаковывать, если
	    это обычный архив <command>gzip</command> или
	    <command>compress</command>.  Если вы сделаете последнее,
	    приложите дополнительные усилия для того, чтобы не перезаписать
	    что-либо, уже существующее в этом каталоге.  Также не забудьте
	    добавить команду для удаления скопированного патча в цели
	    <buildtarget>pre-clean</buildtarget>.</para>
        </note>
      </sect2>

      <sect2 xml:id="porting-master-sites-n">
        <title>Несколько дистрибутивных файлов или патчей с различных серверов
          и подкаталогов (<literal>MASTER_SITES:n</literal>)</title>

        <para>(Этот раздел можно считать немного <quote>повышенной
          трудности</quote>; те, кто впервые знакомятся с этим текстом, могут
          пропустить этот раздел).</para>

        <para>В этом разделе находится информация о механизме сгрузки,
          известном как <literal>MASTER_SITES:n</literal> и
	  <literal>MASTER_SITES_NN</literal>.  Далее мы будем называть этот
          механизм <literal>MASTER_SITES:n</literal>.</para>

	<para>Сначала немного общей информации.  В OpenBSD имеется полезная
          возможность, используемая в переменных <varname>DISTFILES</varname> и
	  <varname>PATCHFILES</varname>, которая позволяет закреплять после
	  имен файлов и патчей идентификаторы типа <literal>:n</literal>. Здесь
          <literal>n</literal> может быть из диапазона <literal>[0-9]</literal>
          и обозначать закреплённую группу.  К примеру:</para>

	<programlisting>DISTFILES=      alpha:0 beta:1</programlisting>

	<para>В OpenBSD дистрибутивный файл <filename>alpha</filename> будет
          связан с переменной <varname>MASTER_SITES0</varname>, но не с нашей
          общей переменной <varname>MASTER_SITES</varname>, а файл
   	  <filename>beta</filename> с переменной
          <varname>MASTER_SITES1</varname>.</para>

	<para>Этот очень интересная возможность, которая может уменьшить этот
          бесконечный поиск работающего сайта для сгрузки.</para>

	<para>Просто представьте себе 2 файла в <varname>DISTFILES</varname> и
          20 сайтов в <varname>MASTER_SITES</varname>; сайты очень медленные,
          причём <filename>beta</filename> находится на всех сайтах из
          <varname>MASTER_SITES</varname>, а <filename>alpha</filename>
          может быть найден только на 20-м сайте.  Будет неправильно проверять
          их все, если создатель знает об этом, не правда ли?  Неподходящее
          начало для таких прекрасных выходных!</para>

	<para>Теперь, когда вы получили общее представление, просто представьте
          ещё большее количество <varname>DISTFILES</varname> и
          <varname>MASTER_SITES</varname>.  Конечно, наш <quote>магистр
          доступности дистрибутивов</quote> представляет масштабы нагрузки
          на сеть, которую это даёт.</para>

	<para>В последующих разделах информация будет даваться вместе с
           реализацией этой идеи во FreeBSD.  Мы несколько улучшили концепцию
           OpenBSD.</para>

	<sect3>
	  <title>Упрощённая информация</title>

	  <para>В этом разделе рассказывается, как быстро подготовить точную
            сгрузку нескольких дистрибутивных файлов и патчей с разных сайтов
            и каталогов.  Мы описываем здесь случай упрощённого использования
	    <literal>MASTER_SITES:n</literal>.  Для большинства сценариев этого
            будет достаточно.  Однако, если вам нужна дополнительная
            информация, обратитесь к следующему разделу.</para>

	  <para>Некоторые приложения состоят из многих дистрибутивных
            файлов, которые должны быть сгружены с нескольких различных сайтов.
            К примеру, <application>Ghostscript</application> состоит из
            основной программы и большого числа файлов драйверов, которые
            используются в зависимости от принтера пользователя.  Некоторые из
            этих файлов драйверов поставляются с основной программой, но при
            этом многие другие должны быть сгружены с множества различных
            сайтов.</para>

	  <para>Чтобы это поддерживать, за каждой записью в
            <varname>DISTFILES</varname> может следовать символ двоеточия и
            <quote>имя метки</quote>.  За каждым сайтом, перечисленным в
	    <varname>MASTER_SITES</varname>, тоже следует двоеточие и метка,
            которая указывает, какие файлы дистрибутива должны быть сгружены
            с этого сайта.</para>

	  <para>Например, рассмотрим приложение, исходный код которого разделён
            на две части, <filename>source1.tar.gz</filename> и
	    <filename>source2.tar.gz</filename>, которые должны быть сгружены с
            двух различных источников.  Файл <filename>Makefile</filename>
            порта будет содержать строчки типа <xref linkend="ports-master-sites-n-example-simple-use-one-file-per-site"/>.</para>

	  <example xml:id="ports-master-sites-n-example-simple-use-one-file-per-site">

	    <title>Упрощённое использование <literal>MASTER_SITES:n</literal>
	      с 1 файлом на каждом сайте</title>

	    <programlisting>MASTER_SITES=   ftp://ftp.example1.com/:source1 \
                ftp://ftp.example2.com/:source2
DISTFILES=      source1.tar.gz:source1 \
                source2.tar.gz:source2</programlisting>
	  </example>

	  <para>Несколько дистрибутивных файлов могут иметь одну и ту же метку.
            Продолжая предыдущий пример, положим, что имеется и третий
            дистрибутивный файл, <filename>source3.tar.gz</filename>, который
            должен быть сгружен с <systemitem>ftp.example2.com</systemitem>.  Тогда
            файл <filename>Makefile</filename> будет написан как <xref linkend="ports-master-sites-n-example-simple-use-more-than-one-file-per-site"/>.</para>

	  <example xml:id="ports-master-sites-n-example-simple-use-more-than-one-file-per-site">
	    <title>Упрощённое использование <literal>MASTER_SITES:n</literal> с
	      более чем 1 файлом на каждом сервере</title>

	    <programlisting>MASTER_SITES=   ftp://ftp.example1.com/:source1 \
                ftp://ftp.example2.com/:source2
DISTFILES=      source1.tar.gz:source1 \
                source2.tar.gz:source2 \
                source3.tar.gz:source2</programlisting>
	  </example>
	</sect3>

	<sect3>
	  <title>Подробная информация</title>

	  <para>Прекрасно, но пример из предыдущего раздела не показал вам всё,
            что вам нужно?  В этом разделе мы подробно опишем, как работает
            механизм <literal>MASTER_SITES:n</literal> точной сгрузки и как
            вы можете изменить ваши порты, чтобы это использовать.</para>

	  <orderedlist>
	    <listitem>
	      <para>За элементами могут следовать символы
                <literal>:n</literal>, где
		<replaceable>n</replaceable> это <literal>[^:,]+</literal>, то
                есть <replaceable>n</replaceable> может теоретически быть
                любой алфавитно-цифровой строкой, но пока мы будем ограничивать
                их <literal>[a-zA-Z_][0-9a-zA-Z_]+</literal>.</para>

	      <para>Более того, совпадение строк чувствительно к регистру;
                другими словами, <literal>n</literal> отличается от
		<literal>N</literal>.</para>

	      <para>Однако следующие слова не могут использоваться для этих
                нужд, так как они имеют особое значение:
		<literal>default</literal>, <literal>all</literal> и
		<literal>ALL</literal> (они используются для своих нужд в <xref linkend="porting-master-sites-n-what-changes-in-port-targets"/>).
		Кроме того, <literal>DEFAULT</literal> является специальным
                ключевым словом (посмотрите <xref linkend="porting-master-sites-n-DEFAULT-group"/>).</para>
	    </listitem>

	    <listitem>
	      <para>Элементы, за которыми следуют <literal>:n</literal>,
                принадлежат группе <literal>n</literal>,
		<literal>:m</literal> относится к группе <literal>m</literal> и
                так далее.</para>
	    </listitem>

	    <listitem xml:id="porting-master-sites-n-DEFAULT-group">
	      <para>Элементы без таких суффиксов не относятся ни к какой
                группе, то есть они принадлежат к особой группе
		<literal>DEFAULT</literal>.  Если вы укажете суффиксом любого
                элемента <literal>DEFAULT</literal>, вы просто выполните
                излишнюю работу, если только вы не хотите отнесения элемента
                как к группе <literal>DEFAULT</literal>, так и какой-то другой
                в одно и то же время (посмотрите на пункт <xref linkend="porting-master-sites-n-comma-operator"/>).</para>

	      <para>Следующие примеры равнозначны, но первый более
                предпочтителен:</para>

	      <programlisting>MASTER_SITES=   alpha</programlisting>

	      <programlisting>MASTER_SITES=   alpha:DEFAULT</programlisting>
	    </listitem>

	    <listitem>
	      <para>Группы не являются эксклюзивными, элемент может
                принадлежать к нескольким отличающимся группам одновременно, а
                группа может либо иметь несколько различных элементов, либо не
                иметь их вовсе.  Повторяющиеся элементы в одной и той же группе
                будут являться просто повторяющимися элементами.</para>
	    </listitem>

	    <listitem xml:id="porting-master-sites-n-comma-operator">
	      <para>Если в хотите, чтобы элемент принадлежал к нескольким
                группам одновременно, вы можете использовать
                запятую (<literal>,</literal>).</para>

	      <para>Вместо того, чтобы повторять их несколько раз, каждый раз с
                разным постфиксом, мы можем перечислить несколько групп за раз
                в одном постфиксе.  Например, <literal>:m,n,o</literal>
                определяет элемент, принадлежащий группам <literal>m</literal>,
		<literal>n</literal> и <literal>o</literal>.</para>

	      <para>Все следующие примеры имеют один смысл, но последний
                является предпочтительным:</para>

	      <programlisting>MASTER_SITES=   alpha alpha:SOME_SITE</programlisting>

	      <programlisting>MASTER_SITES=   alpha:DEFAULT alpha:SOME_SITE</programlisting>

	      <programlisting>MASTER_SITES=   alpha:SOME_SITE,DEFAULT</programlisting>

	      <programlisting>MASTER_SITES=   alpha:DEFAULT,SOME_SITE</programlisting>
	    </listitem>

	    <listitem>
	      <para>Все серверы внутри определённой группы сортируются в
                соответствии с <varname>MASTER_SORT_AWK</varname>.  Все группы
		в <varname>MASTER_SITES</varname> и
                <varname>PATCH_SITES</varname> тоже сортируются.</para>
	    </listitem>

	    <listitem xml:id="porting-master-sites-n-group-semantics">
	      <para>Семантика групп может использоваться в любой из следующих
                переменных <varname>MASTER_SITES</varname>,
                <varname>PATCH_SITES</varname>,
          	<varname>MASTER_SITE_SUBDIR</varname>,
		<varname>PATCH_SITE_SUBDIR</varname>,
		<varname>DISTFILES</varname> и
		<varname>PATCHFILES</varname> в соответствии со следующим
                синтаксисом:</para>

	      <orderedlist>
		<listitem>
		  <para>Все элементы <varname>MASTER_SITES</varname>,
		    <varname>PATCH_SITES</varname>,
		    <varname>MASTER_SITE_SUBDIR</varname> и
		    <varname>PATCH_SITE_SUBDIR</varname> должны заканчиваться
                    символом прямого слэша <literal>/</literal>.  Если какие-то
                    элементы принадлежат каким-то группам, постфикс группы
		    <literal>:n</literal> должен
		    следовать сразу после завершающего символа
		    <literal>/</literal>.  Механизм
                    <literal>MASTER_SITES:n</literal> опирается на наличие
                    завершающего символа <literal>/</literal> во избежание
                    совпадающих элементов, где <literal>:n</literal> является
                    корректной частью элемента с вхождениями, где
                    <literal>:n</literal> обозначает группу
                    <literal>n</literal>.  Для целей совместимости, так как
		    завершающий символ <literal>/</literal> ранее не
                    требовался в элементах
                    <varname>MASTER_SITE_SUBDIR</varname> и
		    <varname>PATCH_SITE_SUBDIR</varname>, если символ, сразу
                    предшествующий постфиксу, не является символом
		    <literal>/</literal>, то <literal>:n</literal> будет
                    считаться корректной частью элемента, а не постфиксом
                    группы, даже если за элементом следует
                    <literal>:n</literal>.  Посмотрите <xref linkend="ports-master-sites-n-example-detailed-use-master-site-subdir"/>
		    и <xref linkend="ports-master-sites-n-example-detailed-use-complete-example-master-sites"/>.</para>

		  <example xml:id="ports-master-sites-n-example-detailed-use-master-site-subdir">
		    <title>Подробное использование
		      <literal>MASTER_SITES:n</literal> в
		      <varname>MASTER_SITE_SUBDIR</varname></title>

		    <programlisting>MASTER_SITE_SUBDIR=     old:n new/:NEW</programlisting>

		    <itemizedlist>
		      <listitem>
			<para>Каталоги внутри группы
			  <literal>DEFAULT</literal> -&gt; old:n</para>
		      </listitem>

		      <listitem>
			<para>Каталоги внутри группы
			  <literal>NEW</literal> -&gt; new</para>
		      </listitem>
		    </itemizedlist>
		  </example>

		  <example xml:id="ports-master-sites-n-example-detailed-use-complete-example-master-sites">
	            <title>Подробное использование
		      <literal>MASTER_SITES:n</literal> с запятыми,
                      несколькими файлами, несколькими серверами и
                      несколькими подкаталогами</title>

		    <programlisting>MASTER_SITES=   http://site1/%SUBDIR%/ http://site2/:DEFAULT \
                http://site3/:group3 http://site4/:group4 \
                http://site5/:group5 http://site6/:group6 \
                http://site7/:DEFAULT,group6 \
                http://site8/%SUBDIR%/:group6,group7 \
                http://site9/:group8
DISTFILES=      file1 file2:DEFAULT file3:group3 \
                file4:group4,group5,group6 file5:grouping \
                file6:group7
MASTER_SITE_SUBDIR=     directory-trial:1 directory-n/:groupn \
                        directory-one/:group6,DEFAULT \
                        directory</programlisting>

		    <para>Предыдущий пример приводит к следующей точной
                      сгрузке.  Серверы перечислены в точном порядке их
                      использования.</para>

		    <itemizedlist>
		      <listitem>
			<para><filename>file1</filename> будет сгружаться
                          с</para>

			<itemizedlist>
			  <listitem>
			    <para><varname>MASTER_SITE_OVERRIDE</varname></para>
			  </listitem>

			  <listitem>
			    <para>http://site1/directory-trial:1/</para>
			  </listitem>

			  <listitem>
			    <para>http://site1/directory-one/</para>
			  </listitem>

			  <listitem>
			    <para>http://site1/directory/</para>
			  </listitem>

			  <listitem>
			    <para>http://site2/</para>
			  </listitem>

			  <listitem>
			    <para>http://site7/</para>
			  </listitem>

			  <listitem>
			    <para><varname>MASTER_SITE_BACKUP</varname></para>
			  </listitem>
			</itemizedlist>
		      </listitem>

		      <listitem>
			<para><filename>file2</filename> будет сгружаться точно
                          также, как <filename>file1</filename>, так как они
                          оба относятся к одной и той же группе</para>

			<itemizedlist>
			  <listitem>
			    <para><varname>MASTER_SITE_OVERRIDE</varname></para>
			  </listitem>

			  <listitem>
			    <para>http://site1/directory-trial:1/</para>
			  </listitem>

			  <listitem>
			    <para>http://site1/directory-one/</para>
			  </listitem>

			  <listitem>
			    <para>http://site1/directory/</para>
			  </listitem>

			  <listitem>
			    <para>http://site2/</para>
			  </listitem>

			  <listitem>
			    <para>http://site7/</para>
			  </listitem>

			  <listitem>
			    <para><varname>MASTER_SITE_BACKUP</varname></para>
			  </listitem>
			</itemizedlist>
		      </listitem>

		      <listitem>
			<para><filename>file3</filename> будет сгружен с</para>

			<itemizedlist>
			  <listitem>
			    <para><varname>MASTER_SITE_OVERRIDE</varname></para>
			  </listitem>

			  <listitem>
			    <para>http://site3/</para>
			  </listitem>

			  <listitem>
			    <para><varname>MASTER_SITE_BACKUP</varname></para>
			  </listitem>
			</itemizedlist>
		      </listitem>

		      <listitem>
			<para><filename>file4</filename> будет сгружаться
                          с</para>

			<itemizedlist>
			  <listitem>
			    <para><varname>MASTER_SITE_OVERRIDE</varname></para>
			  </listitem>

			  <listitem>
			    <para>http://site4/</para>
			  </listitem>

			  <listitem>
			    <para>http://site5/</para>
			  </listitem>

			  <listitem>
			    <para>http://site6/</para>
			  </listitem>

			  <listitem>
			    <para>http://site7/</para>
			  </listitem>

			  <listitem>
			    <para>http://site8/directory-one/</para>
			  </listitem>

			  <listitem>
			    <para><varname>MASTER_SITE_BACKUP</varname></para>
			  </listitem>
			</itemizedlist>
		      </listitem>

		      <listitem>
			<para><filename>file5</filename> будет сгружен с</para>

			<itemizedlist>
			  <listitem>
			    <para><varname>MASTER_SITE_OVERRIDE</varname></para>
			  </listitem>

			  <listitem>
			    <para><varname>MASTER_SITE_BACKUP</varname></para>
			  </listitem>
			</itemizedlist>
		      </listitem>

		      <listitem>
			<para><filename>file6</filename> будет сгружаться
                          с</para>

			<itemizedlist>
			  <listitem>
			    <para><varname>MASTER_SITE_OVERRIDE</varname></para>
			  </listitem>

			  <listitem>
			    <para>http://site8/</para>
			  </listitem>

			  <listitem>
			    <para><varname>MASTER_SITE_BACKUP</varname></para>
			  </listitem>
			</itemizedlist>
		      </listitem>
		    </itemizedlist>
		  </example>
		</listitem>
	      </orderedlist>
	    </listitem>

	    <listitem>
	      <para>Как мне сгруппировать одну из специальных переменных из
		<filename>bsd.sites.mk</filename>, например,
		<varname>MASTER_SITE_SOURCEFORGE</varname>?</para>

	      <para>Посмотрите <xref linkend="ports-master-sites-n-example-detailed-use-master-site-sourceforge"/>.</para>

	      <example xml:id="ports-master-sites-n-example-detailed-use-master-site-sourceforge">
		<title>Подробное использование
		  <literal>MASTER_SITES:n</literal> с
		  <varname>MASTER_SITE_SOURCEFORGE</varname></title>

		<programlisting>MASTER_SITES=   http://site1/ ${MASTER_SITE_SOURCEFORGE:S/$/:sourceforge,TEST/}
DISTFILES=      something.tar.gz:sourceforge</programlisting>
	      </example>

	      <para><filename>something.tar.gz</filename> будет сгружаться со
                всех сайтов из
                <varname>MASTER_SITE_SOURCEFORGE</varname>.</para>
	    </listitem>

	    <listitem>
	      <para>Как мне использовать это с переменными
                <varname>PATCH*</varname>?</para>

	      <para>Все примеры выполнялись с переменными
		<varname>MASTER*</varname>, и они работают точно также и для
                <varname>PATCH*</varname>, как это можно видеть в <xref linkend="ports-master-sites-n-example-detailed-use-patch-sites"/>.</para>

	      <example xml:id="ports-master-sites-n-example-detailed-use-patch-sites">
		<title>Упрощённое использование
		  <literal>MASTER_SITES:n</literal> с
		  <varname>PATCH_SITES</varname>.</title>

		<programlisting>PATCH_SITES=    http://site1/ http://site2/:test
PATCHFILES=     patch1:test</programlisting>
	      </example>
	    </listitem>
	  </orderedlist>
	</sect3>

	<sect3>
	  <title>Что изменится для портов?  А что не изменится?</title>

	  <orderedlist numeration="lowerroman">
	    <listitem>
	      <para>Все имеющиеся порты остаются без изменений.  Код для
		механизма <literal>MASTER_SITES:n</literal> активируется, если
                только есть элементы, которые заканчиваются на
		<literal>:n</literal>, как и
                элементы в соответствии с вышеописанным синтаксисом, особенно
                как это показано в пункте <xref linkend="porting-master-sites-n-group-semantics"/>.</para>
	    </listitem>

	    <listitem xml:id="porting-master-sites-n-what-changes-in-port-targets">
	      <para>Цели порт остаются теми же самыми:
		<buildtarget>checksum</buildtarget>,
		<buildtarget>makesum</buildtarget>,
		<buildtarget>patch</buildtarget>,
		<buildtarget>configure</buildtarget>,
		<buildtarget>build</buildtarget> и так далее.  С обычными
                исключениями для <buildtarget>do-fetch</buildtarget>,
		<buildtarget>fetch-list</buildtarget>,
		<buildtarget>master-sites</buildtarget> и
		<buildtarget>patch-sites</buildtarget>.</para>

	      <itemizedlist>
		<listitem>
		  <para><buildtarget>do-fetch</buildtarget>: использует новую
                    группировку с постфиксами в <varname>DISTFILES</varname> и
		    <varname>PATCHFILES</varname> с соответствующими элементами
                    групп в <varname>MASTER_SITES</varname> и
		    <varname>PATCH_SITES</varname>, которые используют группы
                    из <varname>MASTER_SITE_SUBDIR</varname> и
		    <varname>PATCH_SITE_SUBDIR</varname>.  Посмотрите <xref linkend="ports-master-sites-n-example-detailed-use-complete-example-master-sites"/>.</para>
		</listitem>

		<listitem>
		  <para><buildtarget>fetch-list</buildtarget>: работает также,
                    как старая цель <buildtarget>fetch-list</buildtarget> с тем
                    исключением, что она группирует, как и
		    <buildtarget>do-fetch</buildtarget>.</para>
		</listitem>

		<listitem>
		  <para><buildtarget>master-sites</buildtarget> и
		    <buildtarget>patch-sites</buildtarget>:
		    (несовместимы со старыми версиями) только возвращают
                    элементы группы <literal>DEFAULT</literal>; на самом деле
                    они выполняют цели
		    <buildtarget>master-sites-default</buildtarget> и
		    <buildtarget>patch-sites-default</buildtarget>
		    соответственно.</para>

		  <para>Более того, использование целей
	            <buildtarget>master-sites-all</buildtarget> или
		    <buildtarget>patch-sites-all</buildtarget> предпочтительно
                    для непосредственной проверки
                    <buildtarget>MASTER_SITES</buildtarget> или
		    <buildtarget>PATCH_SITES</buildtarget>.  Также работа прямой
                    проверки в последующих версиях не гарантируется.
                    Посмотрите <xref linkend="porting-master-sites-n-new-port-targets-master-sites-all"/>
		    для получения более дополнительной информации об этих новых
		    целях.</para>
		</listitem>
	      </itemizedlist>
	    </listitem>

	    <listitem>
	      <para>Новые цели построения портов</para>

	      <orderedlist>
		<listitem>
		  <para>Имеются цели
		    <buildtarget>master-sites-<replaceable>n</replaceable></buildtarget>
		    и
		    <buildtarget>patch-sites-<replaceable>n</replaceable></buildtarget>,
		    которые будут перечислять элементы соответствующей группы
		    <replaceable>n</replaceable> из
                    <varname>MASTER_SITES</varname> и
		    <varname>PATCH_SITES</varname> соответственно.  К примеру,
		    <buildtarget>master-sites-DEFAULT</buildtarget> и
		    <buildtarget>patch-sites-DEFAULT</buildtarget> обе будут
		    возвращать элементы группы <literal>DEFAULT</literal>,
		    <buildtarget>master-sites-test</buildtarget> и
		    <buildtarget>patch-sites-test</buildtarget> группы
		    <literal>test</literal> и так далее.</para>
		</listitem>

		<listitem xml:id="porting-master-sites-n-new-port-targets-master-sites-all">
		  <para>Имеются новые цели
		    <buildtarget>master-sites-all</buildtarget> и
		    <buildtarget>patch-sites-all</buildtarget>, которые выполняют
		    работу старых <buildtarget>master-sites</buildtarget> и
		    <buildtarget>patch-sites</buildtarget>.  Они возвращают
		    элементы всех групп, как если бы они все принадлежали одной
		    и той же группе с тем, что она перечисляет ровно столько
		    <varname>MASTER_SITE_BACKUP</varname> и
		    <varname>MASTER_SITE_OVERRIDE</varname>, как и группы,
		    определённые в <varname>DISTFILES</varname> или
		    <varname>PATCHFILES</varname>; соответственно для
		    <buildtarget>master-sites-all</buildtarget> и
		    <buildtarget>patch-sites-all</buildtarget>.</para>
		</listitem>
	      </orderedlist>
	    </listitem>
	  </orderedlist>
	</sect3>
      </sect2>

      <sect2>
        <title><varname>DIST_SUBDIR</varname></title>

        <para>Не позволяйте вашему порту засорять
	  <filename>/usr/ports/distfiles</filename>.  Если вашему порту
	  требуется сгрузить много файлов, или он содержит имя файла,
	  могущее вызвать конфликты с другими портами (например,
	  <filename>Makefile</filename>), то укажите в переменной
	  <varname>DIST_SUBDIR</varname> имя порта (должны подойти
          <literal>${PORTNAME}</literal> или
          <literal>${PKGNAMEPREFIX}${PORTNAME}</literal>).  Это изменит
          значение переменной <varname>DISTDIR</varname> со значения по
          умолчанию <filename>/usr/ports/distfiles</filename> к значению
	  <filename>/usr/ports/distfiles/DIST_SUBDIR</filename>,
	  и в результате всё, что требуется для порта, будет помещено в этот
	  подкаталог.</para>

        <para>Он заглянет также в подкаталог с тем же именем на
	  основном резервном сервере <filename>ftp.FreeBSD.org</filename>.
	  (Явное задание переменной <varname>DISTDIR</varname> в вашем файле
	  <varname>Makefile</varname> этого не сделает, так что, пожалуйста,
	  воспользуйтесь <varname>DIST_SUBDIR</varname>.)</para>

        <note>
	  <para>Это не коснётся тех сайтов <varname>MASTER_SITES</varname>,
	    которые вы указали в вашем файле
            <filename>Makefile</filename>.</para>
        </note>
      </sect2>

      <sect2>
	<title><varname>ALWAYS_KEEP_DISTFILES</varname></title>

	<para>Если ваш порт использует двоичные дистрибутивные файлы и
	  обладает лицензией, требующей, чтобы исходный код предоставлялся
	  вместе с пакетами, распространяемыми в двоичной форме, например
	  GPL, то <varname>ALWAYS_KEEP_DISTFILES</varname> даст кластеру
	  построения &os; указание сохранять копию файлов, указанных в
	  <varname>DISTFILES</varname>.  Пользователям таких портов эти
	  файлы в основном не нужны, поэтому хорошей идеей является
	  добавление в <varname>DISTFILES</varname> исходных
	  дистрибутивных файлов, только когда определена переменная
	  <varname>PACKAGE_BUILDING</varname>.</para>

	<example xml:id="ports-master-sites-n-example-always-keep-distfiles">
	  <title>Использование <varname>ALWAYS_KEEP_DISTFILES</varname>.</title>
	    <programlisting>.if defined(PACKAGE_BUILDING)
DISTFILES+=             <replaceable>foo.tar.gz</replaceable>
ALWAYS_KEEP_DISTFILES=  yes
.endif</programlisting>
	</example>

	<para>При добавлении дополнительных файлов в <varname>DISTFILES</varname>
	  убедитесь, что вы их также добавляете в <filename>distinfo</filename>.
	  Кроме того, дополнительные файлы обычно распаковываются также в
	  <varname>WRKDIR</varname>, что для некоторых портов может вызывать
	  нежелательные подобные эффекты и требовать особую обработку.</para>
      </sect2>
    </sect1>

    <sect1 xml:id="makefile-maintainer">
      <title><varname>MAINTAINER</varname></title>

      <para>Укажите здесь ваш адрес электронной почты.	Пожалуйста.
	<!-- smiley --><emphasis>:-)</emphasis></para>

      <para>Заметьте, что в качестве значения для
        <varname>MAINTAINER</varname> допустимо использование только одного
        адреса без поля комментария.  Должен использоваться формат
        <literal>user@hostname.domain</literal>.  Пожалуйста, не включайте
        никакого описательного текста, например, вашего настоящего имени в
        эту строку&mdash;это несколько сбивает с толку
        <filename>bsd.port.mk</filename>.</para>

      <para>Сопровождающий ответственен за поддержание порта в актуальном
	состоянии и обеспечение правильной работы порта.  За подробным
	описанием обязанностей сопровождающего порт обращайтесь к главе
	<link xlink:href="&url.articles.contributing-ports.en;/maintain-port.html">The
	challenge for port maintainers</link>.</para>

      <para>Перед фиксацией в репозитории изменения в порте будут отправлены
	сопровождающему для просмотра и одобрения.
	Если сопровождающий порта не ответил на запрос пользователя об
        обновлении в течение двух недель (исключая большие праздники),
        то это можно считать тайм-аутом сопровождающего, и обновление может
        быть выполнено без явного подтверждения от сопровождающего.  Если
        сопровождающий не отвечает в течение трёх месяцев, то считается, что
        он отсутствует, и как сопровождающий порта, о котором идёт речь, может
        быть заменён.  Исключениями из этого правила является всё, что
        сопровождает &a.portmgr; или &a.security-officer;.  Запрещено делать
        любые несанкционированные изменения в портах, которые ведут эти
        группы.</para>

      <para>Мы оставляем за собой право изменять сообщение сопровождающего
	для лучшего соответствия существующим политикам и стилю Коллекции
	Портов без явного одобрения со стороны отправителя.  Также,
	крупные изменения в инфраструктуре могут повлечь изменения в порте
	без согласия сопровождающего.  Такой вид изменений никогда не будет
	затрагивать функциональность порта.</para>

      <para>За &a.portmgr; оставляется право снять или назначить кого-либо
        сопровождающим по любой причине, а за the &a.security-officer;
        оставляется право лишать или назначать права на сопровождение порта
        по соображениям информационной безопасности.</para>
    </sect1>

    <sect1 xml:id="makefile-comment">
      <title><varname>COMMENT</varname></title>

      <para>Содержит однострочное описание порта.  Пожалуйста, соблюдайте
	следующие правила:</para>

      <orderedlist>
	<listitem>
	  <para>Старайтесь делать строку COMMENT длиной не больше, чем 70
	    символов, так как эта строка будет использована программой
	    &man.pkg.info.1; для отображения однострочного описания
	    порта;</para>
	</listitem>

	<listitem>
	  <para><emphasis>Не</emphasis> включайте сюда название пакета
	    (или номер версии программного обеспечения);</para>
	</listitem>

	<listitem>
	  <para>Комментарий должен начинаться с заглавной буквы и не
	    заканчиваться точкой;</para>
	</listitem>

	<listitem>
	  <para>Не начинайте комментарий с неопределённого артикля (A
	    или An);</para>
	</listitem>

	<listitem>
	  <para>Имена пишутся с заглавной буквы (например, Apache,
	    JavaScript. Perl);</para>
	</listitem>

	<listitem>
	  <para>Для перечислений используйте английскую Оксфордскую
	    запятую (англ. Oxford comma) (например, green,
	    red<emphasis>,</emphasis> and blue);</para>
	</listitem>

	<listitem>
	  <para>Используйте программу проверки орфографии.</para>
	</listitem>
      </orderedlist>

      <para>Вот пример:</para>

      <programlisting>Cat chasing a mouse all over the screen</programlisting>

      <para>В файле <filename>Makefile</filename> переменная COMMENT должна
        следовать сразу за переменной MAINTAINER.</para>
    </sect1>

    <sect1 xml:id="makefile-portscout">
      <title><varname>PORTSCOUT</varname></title>

      <para><application>Portscout</application> являет собой
	автоматизированное средство проверки доступности дистрибутивных
	файлов для Коллекции Портов &os;, подробное описание которого
	предоставляет <xref linkend="distfile-survey"/>.</para>

      <para>Переменная <varname>PORTSCOUT</varname> задаёт специальные
	условия, ограничивающие работу <application>Portscout</application>
	-  сканера дистрибутивных файлов.</para>

      <para>Ситуации, при которых следует указывать переменную
	<varname>PORTSCOUT</varname>:</para>

      <itemizedlist>
	<listitem>
	  <para>Когда должны игнорироваться дистрибутивные файлы для
	    конкретных версий или младших ревизий.  Например, чтобы
	    исключить из проверок новых версий дистрибутивных файлов
	    версию <replaceable>8.2</replaceable> по причине того, что
	    она является поломанной, добавьте следующее:</para>

	  <programlisting>PORTSCOUT=	ignore:8.2</programlisting>

	</listitem>
	<listitem>
	  <para>Когда должны проверяться конкретные версии или старшие
	    и младшие ревизии дистрибутивных файлов.  Например, если
	    следует ограничиться проверкой версии
	    <replaceable>0.6.4</replaceable>, потому что более новые
	    версии имеют проблемы совместимости с &os;, добавьте:</para>

	  <programlisting>PORTSCOUT=	limit:^0\.6\.4</programlisting>

	</listitem>
	<listitem>
	  <para>Когда URL, в которых указаны доступные версии, отличаются
	    от URL их загрузки.  Например, чтобы привязать проверку новых
	    версий дистрибутивных файлов к странице загрузки для порта
	    <package>databases/pgtune</package>,
	    добавьте:</para>

	  <programlisting>PORTSCOUT=	site:http://pgfoundry.org/frs/?group_id=1000416</programlisting>
	</listitem>
      </itemizedlist>
    </sect1>

    <sect1 xml:id="makefile-depend">
      <title>Зависимости</title>

      <para>Многие порты зависят от других портов.  Это очень удобная
	замечательная особенность большинства Unix-подобных операционных
	систем, включая &os;.  Множество портов могут использовать общую
	зависимость совместно, а не включать её в состав каждого порта или
	пакета, который в ней нуждается.  Имеется семь переменных,
	которые вы можете использовать для обеспечения того, что всё
	требуемое находится на машине пользователя.  Имеется также несколько
	предопределённых переменных, отражающих зависимости для общих
	случаев, плюс ещё несколько для управления поведением
	зависимостей.</para>

      <sect2>
	<title><varname>LIB_DEPENDS</varname></title>

	<para>Эта переменная указывает, от каких совместно используемых
	  библиотек зависит порт.  Это список пар
	  <replaceable>lib</replaceable>:<replaceable>dir</replaceable>
	  где <replaceable>lib</replaceable> - это имя библиотеки,
	  <replaceable>dir</replaceable> - это каталог, в котором можно ее
	  найти в случае, если ее нет на машине.  Например,</para>

	<programlisting>LIB_DEPENDS=   libjpeg.so:${PORTSDIR}/graphics/jpeg</programlisting>

	<para>проверит наличие библиотеки jpeg с любым номером версии и
	  перейдет в подкаталог <filename>graphics/jpeg</filename> вашего
	  дерева портов для ее построения и установки, если библиотека
	  отсутствует.</para>

	<para>Зависимость проверяется дважды, один раз внутри цели
	  <buildtarget>extract</buildtarget>, а затем из цели
	  <buildtarget>install</buildtarget>.  Кроме того, имя зависимости
	  помещается в пакет, так что &man.pkg.add.1; будет
	  автоматически её устанавливать, если её нет на пользовательской
	  системе.</para>
      </sect2>

      <sect2>
	<title><varname>RUN_DEPENDS</varname></title>

	<para>В этой переменной перечисляются выполнимые файлы или файлы, от
	  которых зависит работа порта.  Это список пар вида
	  <replaceable>path</replaceable>:<replaceable>dir</replaceable><optional>:target</optional>
	  где <replaceable>path</replaceable> - это имя программы или файла,
	  а <replaceable>dir</replaceable> - каталог, в котором можно найти
	  порт в случае, если его нет в системе, и
	  <replaceable>target</replaceable> - это цель, которую нужно вызвать
	  в этом каталоге.  Если <replaceable>path</replaceable> начинается
	  со слэша (<literal>/</literal>), он воспринимается как файл и его
	  существование проверяется командой <command>test -e</command>; в
	  противном случае предполагается, что это выполнимый файл, и
	  для определения того, имеется ли программа в пути поиска,
	  используется команда <command>which -s</command>.</para>

	<para>Например,</para>

	<programlisting>RUN_DEPENDS=   ${LOCALBASE}/news/bin/innd:${PORTSDIR}/news/inn \
	       xmlcatmgr:${PORTSDIR}/textproc/xmlcatmgr</programlisting>

	<para>проверит существование файла или каталога
	  <filename>/usr/local/news/bin/innd</filename>, и если ничего
	  не будет найдено, то построит и установит порт из подкаталога
	  <filename>news/inn</filename> дерева портов.  Также будет
	  выполнена проверка, присутствует ли в пути поиска исполняемый
	  файл с именем <command>xmlcatmgr</command>, и перейдет в
	  подкаталог <filename>textproc/xmlcatmgr</filename> вашего дерева
	  портов для его построения и установки, если он не будет
	  найден.</para>

	<note>
	  <para>В приведенном примере <command>innd</command> является
	    выполнимым файлом; если выполнимый файл находится в месте,
	    которое отсутствует в списке путей файлов, то вы должны указать
	    полный путь к файлу.</para>
	</note>

	<note>
	  <para>Официальным значением переменной поиска <envar>PATH</envar>,
	    используемым в кластере построения портов является</para>

	  <programlisting>/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin</programlisting>
	</note>

	<para>Зависимость проверяется внутри цели
	  <buildtarget>install</buildtarget>. Кроме того, имя зависимости
	  помещается в пакет, так что программа &man.pkg.add.1;
	  будет автоматически его устанавливать, если он не будет найден
	  в пользовательской системе.  Часть
	  <replaceable>target</replaceable> может быть опущена, если она
	  совпадает с <varname>DEPENDS_TARGET</varname>.</para>

	<para>Довольно распространенной является ситуация, когда
	  <varname>RUN_DEPENDS</varname> буквально такая же как
	  <varname>BUILD_DEPENDS</varname>, особенно если переносимое
	  программное обеспечение написано на языке сценариев, или если
	  оно требует такое же окружение для исполнения, как и используемое
	  во время построения.  В этом случае, очень заманчивым или довольно
	  естественным является присвоение одного другому:</para>

	<programlisting>RUN_DEPENDS= ${BUILD_DEPENDS}</programlisting>

	<para>Тем не менее, подобные присвоения могут загрязнять зависимости
	  времени исполнения содержимым, не заданным в
	  <varname>BUILD_DEPENDS</varname> исходного порта.
	  Такое случается из-за ленивого вычисления в &man.make.1;
	  присваиваемых переменных.  Представьте <filename>Makefile</filename>
	  с переменными <varname>USE_<replaceable>*</replaceable></varname>,
	  которые обрабатываются в <filename>ports/Mk/bsd.*.mk</filename>
	  для пополнения первоначальных зависимостей построения.  Например,
	  <literal>USES= gmake</literal> добавляет
	  <package>devel/gmake</package> в
	  <varname>BUILD_DEPENDS</varname>.  Для предотвращения загрязнения
	  <varname>RUN_DEPENDS</varname> подобными дополнительными
	  зависимостями проявляйте осторожность с присвоением с раскрытием,
	  т.е. с раскрытием значения перед его присвоением переменной:</para>

	<programlisting>RUN_DEPENDS:=  ${BUILD_DEPENDS}</programlisting>
      </sect2>

      <sect2>
	<title><varname>BUILD_DEPENDS</varname></title>

	<para>В этой переменной перечисляются выполнимые или обычные файлы,
	  которые требуются порту для его построения.  Как и
	  <varname>RUN_DEPENDS</varname>, это список пар
	  <replaceable>path</replaceable>:<replaceable>dir</replaceable><optional>:target</optional>
	  Например,</para>

	<programlisting>BUILD_DEPENDS=  unzip:${PORTSDIR}/archivers/unzip</programlisting>

	<para>будет проверять
	  наличие выполнимого фала с именем <command>unzip</command> и
	  перейдет в подкаталог <filename>archivers/unzip</filename> вашего
	  дерева портов для его построения и установки, если последний не
	  будет найден.</para>

	<note>
	  <para>Под <quote>построением</quote> здесь понимается всё, от
	    распаковки до компиляции.  Зависимость проверяется из цели
	    <buildtarget>extract</buildtarget>.  Часть
	    <replaceable>target</replaceable> может быть опущена, если она
	    совпадает с <varname>DEPENDS_TARGET</varname>.</para>
	</note>
      </sect2>

      <sect2>
	<title><varname>FETCH_DEPENDS</varname></title>

	<para>В этой переменной перечисляются выполняемые файлы или просто
	  файлы, которые требуются порту для сгрузки.  Как и предыдущие две
	  переменные, это список пар
	  <replaceable>path</replaceable>:<replaceable>dir</replaceable><optional>:target</optional>
	  Например,</para>

	<programlisting>FETCH_DEPENDS=  ncftp2:${PORTSDIR}/net/ncftp2</programlisting>

	<para>будет проверять
	  наличие выполняемого файла с именем <command>ncftp2</command> и
	  перейдет в каталог <filename>net/ncftp2</filename> вашего дерева
	  портов для его построения и установки, если тот не будет
	  найден.</para>

	<para>Зависимость проверяется при выполнении цели
	  <buildtarget>fetch</buildtarget>.  Часть
	  <replaceable>target</replaceable> может быть опущена, если она
	  совпадает с <varname>DEPENDS_TARGET</varname>.</para>
      </sect2>

      <sect2>
        <title><varname>EXTRACT_DEPENDS</varname></title>

        <para>В этой переменной указываются программы или файлы, которые
          требуются для распаковки порта.  Как и в предыдущих случаях, это
          список пар вида
          <replaceable>path</replaceable>:<replaceable>dir</replaceable><optional>:target</optional>.
          Например,</para>

	<programlisting>EXTRACT_DEPENDS=        unzip:${PORTSDIR}/archivers/unzip</programlisting>

	<para>будет проверять
          наличие программы с именем <command>unzip</command>, и перейдёт в
          подкаталог <filename>archivers/unzip</filename> вашего дерева
          портов для её построения и установки, если такой программы не будет
          найдено.</para>

        <para>Зависимость проверяется внутри цели
          <buildtarget>extract</buildtarget>.  Часть
          <replaceable>target</replaceable> может быть опущена, если она
          совпадает с <varname>DEPENDS_TARGET</varname>.</para>

        <note>
          <para>Используйте эту переменную, только если распаковка не
            работает (по умолчанию предполагается использование
            <command>gzip</command>) и это не исправляется при помощи
            <varname>USE_ZIP</varname> или <varname>USE_BZIP2</varname>,
            которые описаны в <xref linkend="use-vars"/>.</para>
        </note>
      </sect2>

      <sect2>
        <title><varname>PATCH_DEPENDS</varname></title>

        <para>Эта переменная указывает на программы или файлы, которые нужны
          порту для применения патчей.  Как и в предыдущих случаях, это
          список пар вида
          <replaceable>path</replaceable>:<replaceable>dir</replaceable><optional>:target</optional>.
          Например,</para>

	<programlisting>PATCH_DEPENDS=  ${NONEXISTENT}:${PORTSDIR}/java/jfc:extract</programlisting>

	<para>будет
          переходить в подкаталог <filename>java/jfc</filename> вашего дерева
          портов для распаковки.</para>

        <para>Зависимость проверяется внутри цели
          <buildtarget>patch</buildtarget>.  Часть
          <replaceable>target</replaceable> может быть опущена, если она
          совпадает с <varname>DEPENDS_TARGET</varname>.</para>
      </sect2>

      <sect2 xml:id="uses">
	<title><varname>USES</varname></title>

	<para>Существует несколько параметров для определения различных
	  видов характерных особенностей и зависимостей, которыми
	  обладает рассматриваемый порт.  Они могут быть указаны путём
	  добавления следующей строки в <filename>Makefile</filename>
	  порта:</para>

	<programlisting>USES= feature[:arguments]</programlisting>

	<para>Для получения полного списка значений смотрите <xref linkend="uses-values"/>.</para>

	<warning>
	  <para>Значение <varname>USES</varname> нельзя присваивать
	    после подключения <filename>bsd.port.pre.mk</filename>.</para>
	</warning>
      </sect2>

      <sect2 xml:id="use-vars">
	<title><varname>USE_<replaceable>*</replaceable></varname></title>

	<para>Для определения общих зависимостей, совместно используемых
	  многими портами, предназначено несколько переменных.  Их
	  использование является необязательным, но помогает упростить
	  избыточность файлов <filename>Makefile</filename> порта.
	  Каждый из них оформляется как
	  <varname>USE_<replaceable>*</replaceable></varname>.  Эти
	  переменные можно использовать только в <filename>Makefile</filename>
	  порта и <filename>ports/Mk/bsd.*.mk</filename>.  Они не
	  предназначены для установки пользователями параметров &mdash;
	  используйте для этих целей <varname>PORT_OPTIONS</varname>.</para>

	<note>
	  <para>Установка любых <varname>USE_<replaceable>*</replaceable></varname>
	  в <filename>/etc/make.conf</filename> <emphasis>всегда</emphasis>
	  является ошибочным действием.  В частности, установка</para>

	  <programlisting>USE_GCC=X.Y</programlisting>

	  <para>(где X.Y соответствует версии) добавит зависимость
	    от gccXY к каждому порту, включая и сам
	    <literal>lang/gccXY</literal>!</para>
	</note>

	<table frame="none">
	  <title>Переменные
            <varname>USE_<replaceable>*</replaceable></varname></title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Переменная</entry>

		<entry>Значение</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><varname>USE_BZIP2</varname></entry>

		<entry>tar-архивы порта упакованы при помощи
		  <command>bzip2</command>.</entry>
	      </row>

	      <row>
		<entry><varname>USE_ZIP</varname></entry>

		<entry>tar-архивы порта упакованы при помощи
		  <command>zip</command>.</entry>
	      </row>

	      <row>
		<entry><varname>USE_GCC</varname></entry>

		<entry>Для сборки порта требуется GCC
		  (<command>gcc</command> или <command>g++</command>).
		  Некоторым портам подходит любая версия, для других
		  требуются последние современные версии.  Обычно
		  используется со значением <literal>any</literal> (в
		  этом случае используется встроенный GCC в тех
		  версиях &os;, в состав которых он всё ещё входит,
		  или устанавливается порт
		  <literal>lang/gcc</literal>, когда Clang является
		  компилятором C/C++ по умолчанию) или
		  <literal>yes</literal> (всегда используется
		  стабильная современная версия GCC из порта
		  <literal>lang/gcc</literal>).  Также в значении
		  переменной можно указать точную версию, например
		  <literal>4.7</literal>.  Минимально допустимую
		  версию можно указать как <literal>4.6+</literal>.
		  GCC из основной системы используется в случае, если
		  его версия удовлетворяет запрошенной, иначе
		  собирается подходящая версии компилятора из порта с
		  соответствующей коррекцией переменных
		  <varname>CC</varname> и <varname>CXX</varname>.
		</entry>
	      </row>

	    </tbody>
	  </tgroup>
	</table>

	<para>Переменные, относящиеся к <application>gmake</application>
	  и сценарию <filename>configure</filename>, описаны в
	  <xref linkend="building"/>, а <application>autoconf</application>,
	  <application>automake</application> и
	  <application>libtool</application> описаны в
	  <xref linkend="using-autotools"/>.  Переменные, связанные с
	  <application>Perl</application>, описаны в <xref linkend="using-perl"/>.  Переменные X11 перечислены в <xref linkend="using-x11"/>.  <xref linkend="using-gnome"/>
	  работает с переменными GNOME и <xref linkend="using-kde"/> с KDE.
	  <xref linkend="using-java"/> описывает переменные Java, а <xref linkend="using-php"/> содержит информацию об
	  <application>Apache</application>, <application>PHP</application>
	  и модулях PEAR.  <application>Python</application> обсуждается в
	  <xref linkend="using-python"/>, а <application>Ruby</application>
	  в <xref linkend="using-ruby"/>.  <xref linkend="using-sdl"/>
	  предоставляет переменные, используемые для приложений
	  <application>SDL</application>, и, наконец,
	  <xref linkend="using-xfce"/> содержит информацию о приложении
	  <application>Xfce</application>.</para>
      </sect2>

      <sect2>
	<title>Минимальная версия зависимости</title>

	<para>Минимальная версия зависимости может быть указана в любой
	  переменной <varname>*_DEPENDS</varname>, за исключением
	  <varname>LIB_DEPENDS</varname>, с использованием следующего
	  синтаксиса:</para>

	<programlisting>p5-Spiffy&gt;=0.26:${PORTSDIR}/devel/p5-Spiffy</programlisting>

	<para>Первое поле содержит название зависимого пакета, которое
	  обязано совпадать с записью в базе данные пакетов, знак сравнения
	  и версию версию пакета.  Зависимость удовлетворяется если на машине
	  установлен p5-Spiffy-0.26 или новее.</para>
      </sect2>

      <sect2>
	<title>Замечания касательно зависимостей</title>

	<para>Как уже отмечено выше, целью, которая вызывается по умолчанию
	  в случае, когда это требует зависимость, является
	  <buildtarget>DEPENDS_TARGET</buildtarget>.  Она по умолчанию есть
	  <literal>install</literal>.  Это пользовательская переменная; она
	  нигде не определена в файле <filename>Makefile</filename> порта.
	  Если вашему порту требуется особый метод обработки зависимости,
	  воспользуйтесь частью <literal>:target</literal> переменной
	  <varname>*_DEPENDS</varname> вместо того, чтобы переопределять
	  <varname>DEPENDS_TARGET</varname>.</para>

	<para>Когда вы набираете команду <command>make clean</command>,
	  эта операция также выполняется и над зависимостями этого порта.
	  Если вы не хотите, чтобы это случилось, определите переменную
	  <varname>NOCLEANDEPENDS</varname> в вашем окружении.
          Это может быть особенно нужным, если порт имеет нечто, что занимает
          много времени на построение, в своём списке зависимостей, например,
          KDE, GNOME или Mozilla.</para>

	<para>Чтобы безусловно зависеть от другого порта, укажите переменную
          <varname>${NONEXISTENT}</varname> в качестве первого поля
	  переменной <varname>BUILD_DEPENDS</varname> или
	  <varname>RUN_DEPENDS</varname>.  Пользуйтесь этим, только когда вам
	  нужно иметь исходный код другого порта.  Вы можете сэкономить время
	  на компиляции, указав также и цель.  Например,</para>

	<programlisting>BUILD_DEPENDS=   ${NONEXISTENT}:${PORTSDIR}/graphics/jpeg:extract</programlisting>

	<para>всегда будет переходить в каталог с портом
	  <literal>jpeg</literal> и распаковывать его.</para>
      </sect2>

      <sect2>
        <title>Зацикленные зависимости фатальны</title>

        <important>
          <para>Не помещайте зацикливающиеся зависимости в дерево
            портов!</para>
        </important>

        <para>Технология построения портов не защищена от зацикленных
          зависимостей.  Если вы создадите такую, то у кого-нибудь и
          где-нибудь установка FreeBSD будет немедленно сломана, а у остальных
          сломается несколько позже.  Это на самом деле очень трудно
          распознать; если вы сомневаетесь, то перед внесением изменений
          проверьте, что выполнили следующее: <command>cd /usr/ports; make
          index</command>.  Этот процесс может быть достаточно медленным на
          старых машинах, хотя мы сможете спасти большое количество
          людей&mdash;включая себя&mdash;от грядущих бед.</para>
      </sect2>

      <sect2>
	<title>Автоматические зависимости и проблемы, которые они
	  вызывают</title>

	<para>Зависимости должны быть указаны либо явно, либо с
	  использованием <link linkend="makefile-options">фреймворка
	  OPTIONS</link>.  Использование прочих методов, таких как
	  автоматическое обнаружение зависимостей, усложняет индексирование,
	  что вызывает проблемы в управлении портами и пакетами.</para>

	<example>
	  <title>Некорректное объявление необязательной зависимости</title>

	  <programlisting>.include &lt;bsd.port.pre.mk&gt;

.if exists(${LOCALBASE}/bin/foo)
LIB_DEPENDS=	bar:${PORTSDIR}/foo/bar
.endif</programlisting>
	</example>

	<para>Проблема автоматического добавления зависимостей
	  заключается в том, что файлы и настройки за пределами порта
	  могут произвольно меняться.  Пример: после построения
	  индекса устанавливается набор портов.  При этом один из
	  них устанавливает проверяемый файл.  На этом этапе индекс
	  будет неправильным, потому что установленный порт неожиданно
	  получит новую зависимость.  Индекс может быть по прежнему
	  неправильным даже после его перестроения, в случае если
	  другие порты также определят дополнительные зависимости,
	  основываясь на существовании других файлов.</para>

	<example>
	  <title>Корректное объявление необязательной зависимости</title>

	  <programlisting>OPTIONS_DEFINE=	BAR
BAR_DESC=	Bar support

.include &lt;bsd.port.options.mk&gt;

.if ${PORT_OPTIONS:MBAR}
LIB_DEPENDS=	bar:${PORTSDIR}/foo/bar
.endif</programlisting>
	</example>

	<para>Правильным способом является проверка переменных параметров.
	  Этот способ не приводит к несоответствиям в индексе набора
	  портов, поскольку параметры определены до построения индекса.
	  При этом можно использовать простые скрипты для автоматизации
	  построения, установки и обновления этих портов и соответствующих
	  им пакетов.</para>
      </sect2>

      <sect2 xml:id="use-want">
	<title><varname>USE_</varname> и
	  <varname>WANT_</varname></title>

	<para>Переменные <varname>USE_</varname> задаются мейнтейнером
	  порта для определения программного обеспечения, от которого
	  этот порт зависит.  Порт, для которого нужен Firefox,
	  укажет</para>

	<programlisting>USE_FIREFOX=	yes</programlisting>

	<para>Некоторые переменные <varname>USE_</varname> могут
	  принимать номера версий или другие параметры.  Например,
	  порт, который требует Apache 2.2, укажет</para>

	<programlisting>USE_APACHE=	22</programlisting>

	<para>В некоторых случаях для большего контроля над
	  зависимостями используются переменные <varname>WANT_</varname>,
	  которые позволяют указывать требования в более точной форме.
	  Например, взгляните на порт <package>mail/squirrelmail</package>.  Этому порту
	  нужны несколько модулей PHP, которые перечислены в переменной
	  <varname>USE_PHP</varname>:</para>

	<programlisting>USE_PHP=	session mhash gettext mbstring pcre openssl xml</programlisting>

	<para>Эти модули доступны в версиях CLI и web, поэтому версия
	  web выбрана с переменной <varname>WANT_</varname>:</para>

	<programlisting>WANT_PHP_WEB=	yes</programlisting>

	<para>Имеющиеся переменные <varname>USE_</varname> и
	  <varname>WANT_</varname> определены в файлах
	  <filename>/usr/ports/Mk</filename>.</para>
      </sect2>
    </sect1>

  <sect1 xml:id="makefile-masterdir">
    <title><varname>MASTERDIR</varname></title>

    <para>Если вашему порту требуется построение довольно различающихся
      версий пакетов через переменную (задающую, например, разрешение,
      или размер бумаги), которая принимает различные значения, создайте для
      каждого пакета отдельный подкаталог, чтобы пользователям было легче
      определить, каким пакетом воспользоваться, но попробуйте использовать
      совместно между портами как можно больше файлов.	В типичном случае вам
      потребуются только очень короткие файлы <filename>Makefile</filename>
      во всех каталогах, кроме одного, если вы будете использовать переменные
      с умом.  В отдельных файлах <filename>Makefile</filename> вы можете
      использовать переменную <varname>MASTERDIR</varname> для указания
      каталога, в котором находятся все остальные файлы.  Также используйте
      переменную как часть <link linkend="porting-pkgname"><varname>PKGNAMESUFFIX</varname></link>, чтобы
      пакеты имели разные имена.</para>

    <para>Продемонстрируем это на примере.  Вот часть файла
      <filename>japanese/xdvi300/Makefile</filename>:</para>

    <programlisting>
PORTNAME=       xdvi
PORTVERSION=    17
PKGNAMEPREFIX=  ja-
PKGNAMESUFFIX=  ${RESOLUTION}
 :
# default
RESOLUTION?=   300
.if ${RESOLUTION} != 118 &amp;&amp; ${RESOLUTION} != 240 &amp;&amp; \
       ${RESOLUTION} != 300 &amp;&amp; ${RESOLUTION} != 400
       @${ECHO_MSG} "Error: invalid value for RESOLUTION: \"${RESOLUTION}\""
       @${ECHO_MSG} "Possible values are: 118, 240, 300 (default) and 400."
       @${FALSE}
.endif
    </programlisting>

    <para>Порт <package>japanese/xdvi300</package> содержит
      также все обычные патчи, файлы для пакета и так далее.  Если вы введете
      здесь команду <command>make</command>, она возьмет в качестве разрешения
      значение по умолчанию (300) и построит порт обычным образом.</para>

    <para>Для другого разрешения приведем <emphasis>полный</emphasis>
      <filename>xdvi118/Makefile</filename>:</para>

    <programlisting>RESOLUTION=	118
MASTERDIR=	${.CURDIR}/../xdvi300

.include "${MASTERDIR}/Makefile"</programlisting>

    <para>(<filename>xdvi240/Makefile</filename> и
      <filename>xdvi400/Makefile</filename> похожи).  Задание
      <varname>MASTERDIR</varname> говорит <filename>bsd.port.mk</filename>,
      что обычный набор подкаталогов типа <varname>FILESDIR</varname> и
      <varname>SCRIPTDIR</varname> находится в каталоге
      <filename>xdvi300</filename>.  Строчка
      <literal>RESOLUTION=118</literal> переопределят строку
      <literal>RESOLUTION=300</literal> в файле
      <filename>xdvi300/Makefile</filename> и порт будет построен с
      разрешением 118.</para>
  </sect1>

  <sect1 xml:id="makefile-manpages">
    <title>Страницы Справочника</title>

    <para>Переменные <varname>MAN[1-9LN]</varname> автоматически добавят любые
      страницы Справочника к файлу <filename>pkg-plist</filename> (это
      означает, что вам <emphasis>не нужно</emphasis> указывать страницы
      Справочника в файле <filename>pkg-plist</filename>&mdash;обратитесь к
      главе о <link linkend="plist-sub">генерации файла PLIST</link> для
      получения более подробной информации).  Это также позволяет на этапе
      установки автоматически упаковывать и распаковывать страницы
      Справочника в зависимости от значения переменной
      <varname>NO_MANCOMPRESS</varname> в файле
      <filename>/etc/make.conf</filename>.</para>

    <para>Если ваш порт пытается задать несколько имен для страниц
      Справочника при помощи символических или жестких ссылок, то вы должны
      использовать переменную <varname>MLINKS</varname>, чтобы указать на
      это.  Ссылка, установленная вашим портом, будет уничтожена и создана
      заново сценарием <filename>bsd.port.mk</filename> для проверки того,
      что она указывает на правильный файл.  Любые страницы Справочника,
      перечисленные в переменной MLINKS, не должны фигурировать в файле
      <filename>pkg-plist</filename>.</para>

    <para>Для указания того, что страницы Справочника нужно сжимать во
      время установки, используйте переменную
      <varname>MANCOMPRESSED</varname>.  Эта переменная может принимать три
      значения - <literal>yes</literal>, <literal>no</literal> и
      <literal>maybe</literal>.  <literal>yes</literal> означает, что
      страницы Справочника устанавливаются уже сжатыми, <literal>no</literal>
      означает, что они не сжимаются и <literal>maybe</literal> означает, что
      программное обеспечение принимает во внимание значение переменной
      <varname>NO_MANCOMPRESS</varname>, так что сценарию
      <filename>bsd.port.mk</filename> ничего дополнительно делать не
      нужно.</para>

    <para>Если ваш порт определяет корнем для файлов Справочника каталог,
      отличный от <varname>PREFIX</varname>, вы можете использовать
      переменную <varname>MANPREFIX</varname>, чтобы задать его явно.  Кроме
      того, если страницы только некоторых разделов помещаются в
      нестандартное место, например, в случае портов модулей языка
      <literal>perl</literal> Perl, вы можете установить маршруты к справочным
      страницам индивидуально, при помощи
      <varname>MAN<replaceable>sect</replaceable>PREFIX</varname> (где
      <replaceable>sect</replaceable> принимает значения
      <literal>1-9</literal>, <literal>L</literal> или
      <literal>N</literal>).</para>

    <para>Если страницы Справочника помещаются в подкаталоги, соответствующие
      некоторому языку, то задайте название языка языка в переменной
      <varname>MANLANG</varname>.  Значение этой переменной по умолчанию
      равно <literal>""</literal> (то есть только английский язык).</para>

    <para>Вот пример, в котором приводятся все случаи.</para>

    <programlisting>
MAN1=	       foo.1
MAN3=	       bar.3
MAN4=	       baz.4
MLINKS=        foo.1 alt-name.8
MANLANG=       "" ja
MAN3PREFIX=    ${PREFIX}/share/foobar
MANCOMPRESSED= yes
    </programlisting>

    <para>Здесь указано, что этот порт устанавливает 6 файлов:</para>

      <programlisting>${MANPREFIX}/man/man1/foo.1.gz
${MANPREFIX}/man/ja/man1/foo.1.gz
${PREFIX}/share/foobar/man/man3/bar.3.gz
${PREFIX}/share/foobar/man/ja/man3/bar.3.gz
${MANPREFIX}/man/man4/baz.4.gz
${MANPREFIX}/man/ja/man4/baz.4.gz</programlisting>

    <para>Кроме того, файл
      <filename>${MANPREFIX}/man/man8/alt-name.8.gz</filename> может быть, а
      может и не быть установлен вашим портом.	В любом случае будет создана
      символическая ссылка для объединения страниц Справочника foo(1) и
      alt-name(8).</para>

    <para>Если переведена только часть страниц справочника, вы можете
      использовать некоторые переменные, созданные динамически из
      содержимого <varname>MANLANG</varname>:</para>

    <programlisting>MANLANG=       "" de ja
MAN1=          foo.1
MAN1_EN=       bar.1
MAN3_DE=       baz.3</programlisting>

    <para>Что переводится в такой список файлов:</para>

    <programlisting>${MANPREFIX}/man/man1/foo.1.gz
${MANPREFIX}/man/de/man1/foo.1.gz
${MANPREFIX}/man/ja/man1/foo.1.gz
${MANPREFIX}/man/man1/bar.1.gz
${MANPREFIX}/man/de/man3/baz.3.gz</programlisting>
  </sect1>

  <sect1 xml:id="makefile-info">
    <title>Файлы в формате info</title>

    <para>Если в вашем пакете нужна установка файлов GNU info, они должны
      быть перечислены в переменной <varname>INFO</varname> (без окончания
      <literal>.info</literal>), по записи на документ.  Предполагается,
      что эти файлы устанавливаются в
      <filename>PREFIX/INFO_PATH</filename>.
      Вы можете изменить <varname>INFO_PATH</varname>, если ваш пакет
      использует другое место для размещения.  Однако, это не рекомендуется
      делать.  Эти записи всего лишь содержат путь относительно
      <filename>PREFIX/INFO_PATH</filename>.
      Например, <package>lang/gcc34</package> устанавливает
      файлы info в
      <filename>PREFIX/INFO_PATH/gcc34</filename>,
      и в <varname>INFO</varname> будет что-то вроде этого:</para>

      <programlisting>INFO= gcc34/cpp gcc34/cppinternals gcc34/g77 ...</programlisting>

      <para>Перед регистрацией пакета соответствующий код установки/удаления будет
      автоматически добавлен во временный <filename>pkg-plist</filename>.</para>
  </sect1>

      <sect1 xml:id="makefile-options">
      <title>Опции для Makefile</title>

      <para>Многие приложения могут быть построены в различных
	конфигурациях и с дополнительной функциональностью.  Например,
	выбор естественного (человеческого) языка, GUI против командной
	строки или типа используемой базы данных.  Пользователи могут
	нуждаться в различных конфигурациях, отличных от используемой по
	умолчанию, поэтому в системе портов предусмотрен механизм,
	позволяющий автору порта управлять сборкой того или иного
	варианта конфигурации.
	Правильная поддержка этих необязательных параметров облегчает
	пользователям жизнь и даёт два или более порта по цене одного.</para>

      <sect2>
	<title>Knobs</title>

	<sect3>
	  <title><varname>WITH_<replaceable>*</replaceable></varname>
	    и
	    <varname>WITHOUT_<replaceable>*</replaceable></varname></title>

	  <para>Эти переменные предназначены для установки системным
	    администратором.  Многие из них стандартизованы в файле
	    <link xlink:href="http://svnweb.FreeBSD.org/ports/head/KNOBS?view=markup"><filename>ports/KNOBS</filename></link>.</para>

	  <para>При создании порта не давайте имя для knob, специфичное
	    для данного приложения.  На примере порта Avahi, используйте
	    <varname>WITHOUT_MDNS</varname> вместо
	    <varname>WITHOUT_AVAHI_MDNS</varname>.</para>

	  <note>
	    <para>Не стоит рассчитывать, что
	      <varname>WITH_<replaceable>*</replaceable></varname>
	      обязательно имеет соответствующую переменную
	      <varname>WITHOUT_<replaceable>*</replaceable></varname>,
	      и наоборот.  В общем случае, предполагается значение по
	      умолчанию.</para>
	  </note>

	  <note>
	    <para>Если обратное не указано, то проверяется только факт
	      установки самих переменных, но не их конкретное значение типа
	      <literal>YES</literal> или <literal>NO</literal>.</para>
	  </note>

	  <table frame="none">
	    <title>Основные переменные
	      <varname>WITH_<replaceable>*</replaceable></varname>
	      и <varname>WITHOUT_<replaceable>*</replaceable></varname></title>

	    <tgroup cols="2">
	      <thead>
	        <row>
		  <entry>Переменная</entry>

		  <entry>Значение</entry>
	        </row>
	      </thead>

	      <tbody>
	        <row>
		  <entry><varname>WITH_OPENSSL_BASE</varname></entry>

		  <entry>Использовать версию OpenSSL из базовой системы.</entry>
	        </row>

	        <row>
		  <entry><varname>WITH_OPENSSL_PORT</varname></entry>

		  <entry>Устанавливает версию OpenSSL из
		    <package>security/openssl</package>,
		    даже если в базовой системе последняя версия.</entry>
	        </row>
	      </tbody>
	    </tgroup>
	  </table>

	</sect3>

	<sect3>
	  <title>Наименование KNOBS</title>
	    <para>Портеры должны использовать так называемые
	      knobs для помощи конечным пользователям и для поддержания
	      количества наименований knobs в небольшом количестве.
	      Список популярных названий knobs можно найти в файле <link xlink:href="http://svnweb.FreeBSD.org/ports/head/KNOBS?view=markup"><filename>KNOBS</filename></link>
	    </para>

	    <para>Названия knobs должны отражать, что это такое и что
	      выполняет.  Если у порта имеется библиотечный префикс в
	      <varname>PORTNAME</varname>, то он должен присутствовать в
	      названии knobs.</para>
	</sect3>
      </sect2>

      <sect2>
	<title><varname>OPTIONS</varname></title>

	<sect3>
	  <title>Описание</title>
	    <para>При установке порта переменные <varname>OPTIONS_*</varname>
	      предоставляют пользователю окно диалога с отображением
	      доступных параметров, с записью выбранных параметров в файл
	      <filename>/var/db/ports/${UNIQUENAME}/options</filename>.
	      Эти опции повторно используются при следующем построении
	      порта.</para>

	    <para>Когда пользователь запускает <command>make config</command>
	      (или запускает впервые <command>make build</command>),
	      инфраструктура выполняет проверку существования файла
	      <filename>/var/db/ports/${UNIQUENAME}/options</filename>.
	      Если этот файл не существует, то используются значения
	      <varname>OPTIONS_*</varname> и отображается диалоговое окно,
	      в котором эти параметры можно включить или выключить.
	      Затем сохраняется файл опций <filename>options</filename>,
	      и выбранные переменные используются при построении порта.</para>

	    <para>Если новая версия порта добавляет новые значения
	      <varname>OPTIONS</varname>, то пользователю будет представлено
	      окно диалога с сохраненными заполненными значениями старых
	      <varname>OPTIONS.</varname></para>

	    <para><command>make showconfig</command> отображает
	      сохраненную конфигурацию.  Для удаления
	      сохраненной конфигурации используйте
	      <command>make rmconfig</command>.</para>
	</sect3>

	<sect3>
	  <title>Синтаксис</title>

	    <para><varname>OPTIONS_DEFINE</varname> содержит список
	      используемых <varname>OPTIONS</varname>.  Они независимы
	      друг от друга и не сгруппированы:</para>

	    <programlisting>OPTIONS_DEFINE=	OPT1 OPT2</programlisting>

	    <para>Далее после определения следует описание
	      <varname>OPTIONS</varname> (не является обязательным,
	      но настоятельно рекомендуется):</para>

	    <programlisting>OPT1_DESC=	Describe OPT1
OPT2_DESC=	Describe OPT2
OPT3_DESC=	Describe OPT3
OPT4_DESC=	Describe OPT4
OPT5_DESC=	Describe OPT5
OPT6_DESC=	Describe OPT6</programlisting>

	    <tip>
	      <para><filename>ports/Mk/bsd.options.desc.mk</filename>
		содержит описание множества наиболее используемых
		<varname>OPTIONS</varname>; переопределять их, как
		правило, не нужно.</para>
	    </tip>

	    <tip>
	      <para>При описании параметров старайтесь представить себя
		на месте пользователя: <quote>Что это делает?</quote>
		и <quote>Для чего бы я захотел включить это?</quote>
		Не делайте простое повторение названия.  Например,
		описание параметра <literal>NLS</literal> как
		<quote>include NLS support</quote> (<quote>включить
		поддержку NLS</quote>) не поможет пользователю, который
		уже видит название параметра, но может не знать, что
		это означает.  Описав его как <quote>Native Language
		Support via gettext utilities</quote> (<quote>Поддержка
		национального языка через утилиты gettext</quote>),
		вы поможете пользователю гораздо больше.</para>
	    </tip>

	    <para><varname>OPTIONS</varname> можно группировать в виде
	      переключателей, для которых разрешен выбор единственного
	      варианта в каждой группе:</para>

	    <programlisting>OPTIONS_SINGLE=		SG1
OPTIONS_SINGLE_SG1=	OPT3 OPT4</programlisting>

	    <para><varname>OPTIONS</varname> можно группировать в виде
	      переключателей, для которых разрешен выбор единственного
	      варианта (или ни одного) в каждой группе:</para>

	    <programlisting>OPTIONS_RADIO=		RG1
OPTIONS_RADIO_RG1=	OPT7 OPT8</programlisting>

	    <para><varname>OPTIONS</varname> также можно группировать
	      в виде списков со множественным выбором, для которых
	      обязан быть включен <emphasis>по крайней мере
	      один</emphasis> из параметров:</para>

	    <programlisting>OPTIONS_MULTI=		MG1
OPTIONS_MULTI_MG1=	OPT5 OPT6</programlisting>

	    <para><varname>OPTIONS</varname> также можно группировать
	      в виде списков со множественным выбором, для которых
	      могут быть включены любые параметры, включая отсутствие
	      выбора:</para>

	    <programlisting>OPTIONS_GROUP=		GG1
OPTIONS_GROUP_GG1=	OPT9 OPT10</programlisting>

	    <para>По умолчанию <varname>OPTIONS</varname> находится в
	      выключенном положении, если при этом оно также отсутствует
	      в списке <varname>OPTIONS_DEFAULT</varname>:</para>

	    <programlisting>OPTIONS_DEFAULT=	OPT1 OPT3 OPT6</programlisting>

	    <para>Определения <varname>OPTIONS</varname> обязаны появиться
	      до подключения <filename>bsd.port.options.mk</filename>.
	      Переменные <varname>PORT_OPTIONS</varname>
	      могут быть проверены только после
	      подключения <filename>bsd.port.options.mk</filename>.
	      Вместо этого также можно использовать подключение
	      <filename>bsd.port.pre.mk</filename>, что все еще широко
	      используется в портах, написанных до появления
	      <filename>bsd.port.options.mk</filename>.  Но имейте в виду,
	      что некоторые переменные, обычно, это некоторые флаги
	      <varname>USE_*</varname>,
	      после подключения <filename>bsd.port.pre.mk</filename> будут
	      работать не так, как этого от них ожидают.</para>

	  <example xml:id="ports-options-simple-use">
	    <title>Простое использование <varname>OPTIONS</varname></title>

	    <programlisting>OPTIONS_DEFINE=	FOO BAR
FOO_DESC=	Enable option foo
BAR_DESC=	Support feature bar

.include &lt;bsd.port.options.mk&gt;

.if ${PORT_OPTIONS:MFOO}
CONFIGURE_ARGS+=--with-foo
.else
CONFIGURE_ARGS+=--without-foo
.endif

.if ${PORT_OPTIONS:MBAR}
RUN_DEPENDS+=	bar:${PORTSDIR}/bar/bar
.endif

.include &lt;bsd.port.mk&gt;</programlisting>
	  </example>

	  <example xml:id="ports-options-check-unset">
	    <title>Проверка незаданных значений
	      <varname>OPTIONS</varname></title>

	    <programlisting>.if ! ${PORT_OPTIONS:MEXAMPLES}
CONFIGURE_ARGS+=--without-examples
.endif</programlisting>
	  </example>

	  <example xml:id="ports-options-practical-use">
	    <title>Пример реального использования
	      <varname>OPTIONS</varname></title>

	    <programlisting>OPTIONS_DEFINE=		EXAMPLES

OPTIONS_SINGLE=		BACKEND
OPTIONS_SINGLE_BACKEND=	MYSQL PGSQL BDB

OPTIONS_MULTI=		AUTH
OPTIONS_MULTI_AUTH=	LDAP PAM SSL

EXAMPLES_DESC=		Install extra examples
MYSQL_DESC=		Use MySQL as backend
PGSQL_DESC=		Use PostgreSQL as backend
BDB_DESC=		Use Berkeley DB as backend
LDAP_DESC=		Build with LDAP authentication support
PAM_DESC=		Build with PAM support
SSL_DESC=		Build with OpenSSL support

OPTIONS_DEFAULT=	PGSQL LDAP SSL

.include &lt;bsd.port.options.mk&gt;

.if ${PORT_OPTIONS:MPGSQL}
USE_PGSQL=		yes
CONFIGURE_ARGS+=	--with-postgres
.else
CONFIGURE_ARGS+=	--without-postgres
.endif

.if ${PORT_OPTIONS:MICU}
LIB_DEPENDS+=	icuuc:${PORTSDIR}/devel/icu
.endif

.if ! ${PORT_OPTIONS:MEXAMPLES}
CONFIGURE_ARGS+=	--without-examples
.endif

# Проверка других параметров OPTIONS

.include &lt;bsd.port.mk&gt;</programlisting>
	  </example>
	</sect3>

	<sect3>
	  <title>Параметры по умолчанию</title>
  	  <para>Следующие параметры по умолчанию всегда включены.</para>
          <itemizedlist>
	    <listitem>
	      <para><literal>DOCS</literal> &mdash; построение и установка
		документации.</para>
	    </listitem>
	    <listitem>
	      <para><literal>NLS</literal> &mdash; интернационализация.</para>
            </listitem>
	    <listitem>
	      <para><literal>EXAMPLES</literal> &mdash; построение и
		установка примеров использования.</para>
	    </listitem>
	    <listitem>
	      <para><literal>IPV6</literal> &mdash; поддержка протокола
		IPv6.</para>
	    </listitem>
	  </itemizedlist>
	  <note>
	    <para>Нет необходимости добавлять эти параметры в
	      <varname>OPTIONS_DEFAULT</varname>.  Тем не менее, чтобы
	      отобразить их в окне диалога выбора параметров, они должны
	      быть добавлены в <varname>OPTIONS_DEFINE</varname>.</para>
          </note>
	</sect3>
      </sect2>

      <sect2>
	<title>Функция автоматической активации</title>

	<para>При использовании сценария GNU configure, следите за тем,
	  какие необязательные функции задействуются посредством
	  автоматической активации.  Отключайте явным образом те
	  необязательные функции, которые вы не хотели бы использовать,
	  через передачу соответствующих <literal>--without-xxx</literal>
	  или <literal>--disable-xxx</literal> в переменной
	  <varname>CONFIGURE_ARGS</varname>.</para>

	<example>
	  <title>Неправильное управление опцией</title>

	  <programlisting>.if ${PORT_OPTIONS:MFOO}
LIB_DEPENDS+=		libfoo.so:${PORTSDIR}/devel/foo
CONFIGURE_ARGS+=	--enable-foo
.endif</programlisting>
	</example>

	<para>В приведенном выше примере представьте себе библиотеку libfoo,
	  установленную в системе.  Пользователь не желает, чтобы приложение
	  использовало libfoo, и поэтому он выключает соответствующую опцию
	  в диалоге <literal>make config</literal>.  Но сценарий configure
	  приложения определяет наличие библиотеки в системе и включает ее
	  поддержку в итоговый исполняемый файл.  Теперь, когда пользователь
	  решит удалить libfoo из системы, система портов позволит это
	  сделать (т.к. зависимость от libfoo не была записана), но
	  приложение перестанет работать.</para>

	<example>
	  <title>Правильное управление опцией</title>

	  <programlisting>.if ${PORT_OPTIONS:MFOO}
LIB_DEPENDS+=		libfoo.so:${PORTSDIR}/devel/foo
CONFIGURE_ARGS+=	--enable-foo
.else
CONFIGURE_ARGS+=	--disable-foo
.endif</programlisting>
	</example>

	<para>Во втором примере библиотека libfoo отключена явным образом.
	  Сценарий configure не включает соответствующие функции в приложении,
	  несмотря на присутствие библиотеки в системе.</para>

	<note>
	  <para>При определенных условиях сокращенный синтаксис записи
	    условий может вызывать проблемы со сложными конструкциями.
	    Если вы получаете ошибки, такие как <literal>Malformed
	      conditional</literal>, то может быть использован
	    альтернативный синтаксис.</para>

	  <programlisting>.if !empty(VARIABLE:MVALUE)
# as an alternative to
.if ${VARIABLE:MVALUE}</programlisting>
	</note>
      </sect2>

      <sect2>
	<title>Вспомогательные макросы</title>

	<para>Существует несколько макросов, упрощающих запись условных
	  значений, которые отличаются в зависимости от набора
	  параметров.</para>

	<para>Если переменная <varname>OPTIONS_SUB</varname> имеет
	  значение <literal>yes</literal>, то каждый из указанных в
	  <varname>OPTIONS_DEFINE</varname> параметров будет добавлен
	  в <varname>PLIST_SUB</varname>.  Следующая запись:</para>

	<programlisting>OPTIONS_DEFINE=	OPT1
OPTIONS_SUB=	yes</programlisting>

	<para>соответствует:</para>

	<programlisting>OPTIONS_DEFINE=	OPT1

.include &lt;bsd.port.options.mk&gt;

.if ${PORT_OPTIONS:MOPT1}
PLIST_SUB+=	OPT1=""
.else
PLIST_SUB+=	OPT1="@comment "
.endif</programlisting>

	<para><varname>X_CONFIGURE_ENABLE</varname> дописывает в
	  <varname>CONFIGURE_ARGS</varname> строку
	  <literal>--enable-${X_CONFIGURE_ENABLE}</literal> или
	  <literal>--disable-${X_CONFIGURE_ENABLE}</literal> в
	  соответствии с состоянием <varname>X</varname>.  Следующая
	  запись:</para>

	<programlisting>OPTIONS_DEFINE=	OPT1
OPT1_CONFIGURE_ENABLE=	test</programlisting>

	<para>соответствует:</para>

	<programlisting>OPTIONS_DEFINE=	OPT1

.include &lt;bsd.port.options.mk&gt;

.if ${PORT_OPTIONS:MOPT1}
CONFIGURE_ARGS+=	--enable-test
.else
CONFIGURE_ARGS+=	--disable-test
.endif</programlisting>

	<para><varname>X_CONFIGURE_WITH</varname> дописывает в
	  <varname>CONFIGURE_ARGS</varname> строку
	  <literal>--with-${X_CONFIGURE_WITH}</literal> или
	  <literal>--without-${X_CONFIGURE_WITH}</literal> в
	  соответствии с состоянием <varname>X</varname>.  Следующая
	  запись:</para>

	<programlisting>OPTIONS_DEFINE=	OPT1
OPT1_CONFIGURE_WITH=	test</programlisting>

	<para>соответствует:</para>

	<programlisting>OPTIONS_DEFINE=	OPT1

.include &lt;bsd.port.options.mk&gt;

.if ${PORT_OPTIONS:MOPT1}
CONFIGURE_ARGS+=	--with-test
.else
CONFIGURE_ARGS+=	--without-test
.endif</programlisting>

	<para>Значение переменной <varname>X_CONFIGURE_ON</varname>
	  будет дописано в <varname>CONFIGURE_ARGS</varname> в
	  соответствии с состоянием <varname>X</varname>.  Следующая
	  запись:</para>

	<programlisting>OPTIONS_DEFINE=	OPT1
OPT1_CONFIGURE_ON=	--add-test</programlisting>

	<para>соответствует:</para>

	<programlisting>OPTIONS_DEFINE=	OPT1

.include &lt;bsd.port.options.mk&gt;

.if ${PORT_OPTIONS:MOPT1}
CONFIGURE_ARGS+=	--add-test
.endif</programlisting>

	<para>Значение переменной <varname>X_CONFIGURE_OFF</varname>
	  будет дописано в <varname>CONFIGURE_ARGS</varname> в
	  соответствии с состоянием <varname>X</varname>.  Следующая
	  запись:</para>

	<programlisting>OPTIONS_DEFINE=	OPT1
OPT1_CONFIGURE_OFF=	--no-test</programlisting>

	<para>соответствует:</para>

	<programlisting>OPTIONS_DEFINE=	OPT1
.include &lt;bsd.port.options.mk&gt;
.if ! ${PORT_OPTIONS:MOPT1}
CONFIGURE_ARGS+=	--no-test
.endif</programlisting>

	<para>Значение переменной <varname>X_CMAKE_ON</varname> будет
	  дописано в <varname>CMAKE_ARGS</varname> в соответствии с
	  состоянием <varname>X</varname>.  Следующая запись:</para>

	<programlisting>OPTIONS_DEFINE=	OPT1
OPT1_CMAKE_ON=	-DTEST:BOOL=true</programlisting>

	<para>соответствует:</para>

	<programlisting>OPTIONS_DEFINE=	OPT1

.include &lt;bsd.port.options.mk&gt;

.if ${PORT_OPTIONS:MOPT1}
CMAKE_ARGS+=	-DTEST:BOOL=true
.endif</programlisting>

	<para>Значение переменной <varname>X_CMAKE_OFF</varname> будет
	  дописано в <varname>CMAKE_ARGS</varname> в соответствии с
	  состоянием <varname>X</varname>.  Следующая запись:</para>

	<programlisting>OPTIONS_DEFINE=	OPT1
OPT1_CMAKE_OFF=	-DTEST:BOOL=false</programlisting>

	<para>соответствует:</para>

	<programlisting>OPTIONS_DEFINE=	OPT1

.include &lt;bsd.port.options.mk&gt;

.if ! ${PORT_OPTIONS:MOPT1}
CMAKE_ARGS+=	-DTEST:BOOL=false
.endif</programlisting>

	<para>Для любой из следующих переменных:</para>

	<itemizedlist>
	  <listitem>
	    <para><varname>ALL_TARGET</varname></para>
	  </listitem>

	  <listitem>
	    <para><varname>CATEGORIES</varname></para>
	  </listitem>

	  <listitem>
	    <para><varname>CFLAGS</varname></para>
	  </listitem>

	  <listitem>
	    <para><varname>CPPFLAGS</varname></para>
	  </listitem>

	  <listitem>
	    <para><varname>CXXFLAGS</varname></para>
	  </listitem>

	  <listitem>
	    <para><varname>CONFIGURE_ENV</varname></para>
	  </listitem>

	  <listitem>
	    <para><varname>DISTFILES</varname></para>
	  </listitem>

	  <listitem>
	    <para><varname>EXTRA_PATCHES</varname></para>
	  </listitem>

	  <listitem>
	    <para><varname>INSTALL_TARGET</varname></para>
	  </listitem>

	  <listitem>
	    <para><varname>LDFLAGS</varname></para>
	  </listitem>

	  <listitem>
	    <para><varname>MAKE_ARGS</varname></para>
	  </listitem>

	  <listitem>
	    <para><varname>MAKE_ENV</varname></para>
	  </listitem>

	  <listitem>
	    <para><varname>PATCH_SITES</varname></para>
	  </listitem>

	  <listitem>
	    <para><varname>PATCHFILES</varname></para>
	  </listitem>

	  <listitem>
	    <para><varname>PLIST_FILES</varname></para>
	  </listitem>

	  <listitem>
	    <para><varname>PLIST_DIRS</varname></para>
	  </listitem>

	  <listitem>
	    <para><varname>PLIST_DIRSTRY</varname></para>
	  </listitem>

	  <listitem>
	    <para><varname>USES</varname></para>
	  </listitem>
	</itemizedlist>

	<para>Значение переменной <varname>X_ABOVEVARIABLE</varname>
	  будет дописано в <varname>ABOVEVARIABLE</varname> в
	  соответствии с состоянием <varname>X</varname>.  Следующая
	  запись:</para>

	<programlisting>OPTIONS_DEFINE=	OPT1
OPT1_USES=	gmake
OPT1_CFLAGS=	-DTEST</programlisting>

	<para>соответствует:</para>

	<programlisting>OPTIONS_DEFINE=	OPT1

.include &lt;bsd.port.options.mk&gt;

.if ${PORT_OPTIONS:MOPT1}
USES+=		gmake
CFLAGS+=	-DTEST
.endif</programlisting>

	<para>Для любого из следующих типов зависимости:</para>

	<itemizedlist>
	    <listitem>
	      <para><varname>PKG_DEPENDS</varname></para>
	    </listitem>

	    <listitem>
	      <para><varname>EXTRACT_DEPENDS</varname></para>
	    </listitem>

	    <listitem>
	      <para><varname>PATCH_DEPENDS</varname></para>
	    </listitem>

	    <listitem>
	      <para><varname>FETCH_DEPENDS</varname></para>
	    </listitem>

	    <listitem>
	      <para><varname>BUILD_DEPENDS</varname></para>
	    </listitem>

	    <listitem>
	      <para><varname>LIB_DEPENDS</varname></para>
	    </listitem>

	    <listitem>
	      <para><varname>RUN_DEPENDS</varname></para>
	    </listitem>
	</itemizedlist>

	<para>Значение переменной <varname>X_ABOVEVARIABLE</varname>
	  будет дописано в <varname>ABOVEVARIABLE</varname> в
	  соответствии с состоянием <varname>X</varname>.  Следующая
	  запись:</para>

	<programlisting>OPTIONS_DEFINE=	OPT1
OPT1_LIB_DEPENDS=	liba.so:${PORTSDIR}/devel/a</programlisting>

	<para>соответствует:</para>

	<programlisting>OPTIONS_DEFINE=	OPT1

.include &lt;bsd.port.options.mk&gt;

.if ${PORT_OPTIONS:MOPT1}
LIB_DEPENDS+=	liba.so:${PORTSDIR}/devel/a
.endif</programlisting>
      </sect2>
    </sect1>

    <sect1 xml:id="makefile-wrkdir">
      <title>Задание рабочего каталога</title>

      <para>Каждый порт распаковывается в рабочий каталог, который должен быть
        доступным для записи.  В системе портов по умолчанию
        <varname>DISTFILES</varname> распаковываются в каталог с именем
        <literal>${DISTNAME}</literal>.  Другими словами, если вы
        задали:</para>

      <programlisting>PORTNAME=      foo
PORTVERSION=   1.0</programlisting>

      <para>то дистрибутивные файлы порта содержат каталог верхнего уровня,
        <filename>foo-1.0</filename>, и все файлы расположены в этом
        каталоге.</para>

      <para>Если это не ваш случай, то имеется несколько переменных, которые
        вы можете переопределить.</para>

      <sect2>
        <title><varname>WRKSRC</varname></title>

        <para>Эта переменная задаёт имя каталога, который создаётся при
          распаковке исходных файлов приложения.  В нашем предыдущем
          примере если бы распаковка происходила в каталог с именем
          <filename>foo</filename> (а не
          <filename>foo-1.0</filename>), то вы должны написать:</para>

        <programlisting>WRKSRC=      ${WRKDIR}/foo</programlisting>

        <para>или, как вариант</para>

        <programlisting>WRKSRC=      ${WRKDIR}/${PORTNAME}</programlisting>
      </sect2>

      <sect2>
        <title><varname>NO_WRKSUBDIR</varname></title>

        <para>Если порт вообще не распаковывается ни в какой каталог, то вы
          должны задать переменную <varname>NO_WRKSUBDIR</varname> для указания
          на этот факт.</para>

        <programlisting>NO_WRKSUBDIR= yes</programlisting>
      </sect2>
    </sect1>

    <sect1 xml:id="conflicts">
      <title>Разрешение конфликтов</title>

      <para>Для регистрации конфликта между пакетами и портами используются
	три различные переменные: <varname>CONFLICTS</varname>,
	<varname>CONFLICTS_INSTALL</varname> и
	<varname>CONFLICTS_BUILD</varname>.</para>

      <note>
	<para>Переменные регистрации конфликта автоматически определяют
	  переменную <varname>IGNORE</varname>, которая более подробно
	  описана в <xref linkend="dads-noinstall"/>.</para>
      </note>

      <para>При удалении одного из конфликтующих портов целесообразно
	сохранить записи <varname>CONFLICTS</varname> в тех других портах
	в течении нескольких месяцев, чтобы позаботиться о тех пользователей,
	которые обновляются от случая к случаю.</para>

      <sect2>
	<title><varname>CONFLICTS_INSTALL</varname></title>

	<para>Если ваш пакет не может существовать вместе с другими
	  (из-за конфликта файлов, несовместимости времени выполнения и так
	  далее), перечислите имена остальных пакетов в переменной
	  <varname>CONFLICTS_INSTALL</varname>.  Здесь вы можете использовать
	  шаблоны командного интерпретатора, такие как <literal>*</literal>
	  и <literal>?</literal>.  Имена пакетов должны выглядеть так же,
	  как в <filename>/var/db/pkg</filename>.  Пожалуйста, убедитесь,
	  что <varname>CONFLICTS_INSTALL</varname> не содержит пакет самого
	  этого порта.  В противном случае не будет работать установка с
	  использованием переменной <varname>FORCE_PKG_REGISTER</varname>.
	  Проверка CONFLICTS_INSTALL выполняется после процесса сборки и
	  до процесса установки.</para>
      </sect2>

      <sect2>
	<title><varname>CONFLICTS_BUILD</varname></title>

	<para>Если ваш порт не может быть собран, когда уже установлен
	  другой, перечислите имена остальных портов в переменной
	  <varname>CONFLICTS_BUILD</varname>.  Здесь вы можете использовать
	  шаблоны командного интерпретатора, такие как <literal>*</literal>
	  и <literal>?</literal>.  Имена пакетов должны выглядеть так же,
	  как в <filename>/var/db/pkg</filename>.  Проверка CONFLICTS_BUILD
	  выполняется до процесса сборки.  Конфликты сборки в получаемом
	  пакете не записываются.</para>
      </sect2>

      <sect2>
	<title><varname>CONFLICTS</varname></title>

	<para>Если ваш порт не может быть собран, когда уже установлен
	  другой, а получаемый пакет не может существовать вместе с другими,
	  перечислите имена остальных пакетов в переменной
	  <varname>CONFLICTS</varname>.  Здесь вы можете использовать шаблоны
	  командного интерпретатора, такие как <literal>*</literal> и
	  <literal>?</literal>.  Имена пакетов должны выглядеть так же, как
	  в <filename>/var/db/pkg</filename>.  Пожалуйста, убедитесь, что
	  <varname>CONFLICTS</varname> не содержит пакет самого этого порта.
	  В противном случае не будет работать установка с использованием
	  переменной <varname>FORCE_PKG_REGISTER</varname>.  Проверка
	  CONFLICTS выполняется до процессов сборки и установки.</para>
      </sect2>
    </sect1>

    <sect1 xml:id="install">
      <title>Установка файлов</title>

      <sect2 xml:id="install-macros">
	<title>Макросы INSTALL_*</title>

	<para>Используйте макросы, которые есть в файле
	  <filename>bsd.port.mk</filename> для обеспечения правильных прав
	  доступа и владения файлов в своих целях
	  <buildtarget>*-install</buildtarget>.</para>

	<itemizedlist>
	  <listitem>
	    <para><varname>INSTALL_PROGRAM</varname> - это команда для
	      установки бинарных выполнимых файлов.</para>
	  </listitem>

	  <listitem>
	    <para><varname>INSTALL_SCRIPT</varname> - это команда для установки
	      выполнимых скриптов.</para>
	  </listitem>

	  <listitem>
	    <para><varname>INSTALL_LIB</varname> - это команда для установки
	      динамических библиотек.</para>
	  </listitem>

	  <listitem>
	    <para><varname>INSTALL_KLD</varname> - это команда для установки
	      загружаемых модулей ядра.  Некоторые архитектуры предпочитают,
	      чтобы для модулей сохранялись отладочные сведения, по этой
	      причине используйте эту команду вместо
	      <varname>INSTALL_PROGRAM</varname>.</para>
	  </listitem>

	  <listitem>
	    <para><varname>INSTALL_DATA</varname> - это команда для установки
	      совместно используемых файлов данных.</para>
	  </listitem>

	  <listitem>
	    <para><varname>INSTALL_MAN</varname> - это команда для установки
	      страниц Справочника и другой документации (никаких файлов она не
	      сжимает).</para>
	  </listitem>
	</itemizedlist>

	<para>В основе работы этих макросов лежит команда
	  <command>install</command> со всеми соответствующими флагами.
	  Смотрите пример их использования ниже.</para>
      </sect2>

      <sect2 xml:id="install-strip">
	<title>Удаление отладочной информации в бинарных файлах и
	  динамических библиотеках</title>

	<para>Не удаляйте отладочную информацию из бинарных файлов вручную,
	  если вы это делали.  Во всех двоичных файлах отладочная информация
	  должна быть удалена, и макрос <varname>INSTALL_PROGRAM</varname>
	  выполнит установку и удаление отладочной информации одновременно
	  (обратитесь к следующему разделу).  Макрос
	  <varname>INSTALL_LIB</varname> делает то же самое для
	  динамических библиотек.</para>

	<para>Если вам нужно удалить отладочную информацию из файла без
	  использования макросов <varname>INSTALL_PROGRAM</varname> и
	  <varname>INSTALL_LIB</varname>, то это можно сделать при помощи
	  <varname>${STRIP_CMD}</varname>.  Обычно это делается внутри цели
	  <literal>post-install</literal>.  К примеру:</para>

	<programlisting>post-install:
	${STRIP_CMD} ${PREFIX}/bin/xdl</programlisting>

	<para>Для проверки того, удалена ли отладочная информация из
	  установленного выполнимого файла, выполните команду &man.file.1;.
	  Если утилита не выдаст строку <literal>not stripped</literal>, то
	  файл уже обработан.  Кроме того, &man.strip.1; не будет обрабатывать
	  программу, отладочная информация из которой уже удалена; вместо этого
	  утилита просто завершит свою работу.</para>
      </sect2>

      <sect2 xml:id="install-copytree">
	<title>Установка целого дерева файлов</title>

	<para>Иногда существует необходимость в установке большого количества
	  файлов с сохранением их иерархической организации, т.е. в копировании
	  дерева каталогов целиком из <varname>WRKSRC</varname> в целевой
	  каталог внутри <varname>PREFIX</varname>.</para>

	<para>Для этой ситуации существует два макроса.  Преимущество от
	  использования этих макросов вместо команды <command>cp</command>
	  в том, что они гарантируют установку правильного владельца и прав
	  на конечные файлы.  Первый макрос, <varname>COPYTREE_BIN</varname>,
	  делает все устанавливаемые файлы исполняемыми, что подходит для
	  установки в <filename>PREFIX/bin</filename>.
	  Второй макрос, <varname>COPYTREE_SHARE</varname>, не устанавливает
	  на файлы права исполнения, и, таким образом, подходит для установки
	  файлов внутри каталога
	  <filename>PREFIX/share</filename>.</para>

	<programlisting>post-install:
	${MKDIR} ${EXAMPLESDIR}
	(cd ${WRKSRC}/examples &amp;&amp; ${COPYTREE_SHARE} . ${EXAMPLESDIR})</programlisting>

	<para>В этом примере устанавливается содержимое каталога
	  <filename>examples</filename> из установочных файлов производителя
	  в надлежащее место для примеров вашего порта.</para>

	<programlisting>post-install:
	${MKDIR} ${DATADIR}/summer
	(cd ${WRKSRC}/temperatures &amp;&amp; ${COPYTREE_SHARE} "June July August" ${DATADIR}/summer)</programlisting>

	<para>А в этом примере будут установлены данные летних месяцев в
	  подкаталог <filename>summer</filename> каталога
	  <filename>DATADIR</filename>.</para>

	<para>В качестве третьего параметра в макросе
	  <varname>COPYTREE_*</varname> можно передать дополнительные
	  параметры <command>find</command>.  Например, чтобы в первом
	  примере установить все файлы кроме файлов Makefile, можно
	  использовать следующую команду.</para>

	<programlisting>post-install:
	${MKDIR} ${EXAMPLESDIR}
	(cd ${WRKSRC}/examples &amp;&amp; \
		${COPYTREE_SHARE} . ${EXAMPLESDIR} "! -name Makefile")</programlisting>

	<para>Обратите внимание, что эти макросы не производят добавление
	  устанавливаемых файлов в <filename>pkg-plist</filename>.  Вам все
	  еще нужно их перечислить.</para>

      </sect2>

      <sect2 xml:id="install-documentation">
	<title>Установка дополнительной документации</title>

	<para>Если с вашим программным обеспечением поставляется некоторая
	  документация, отличающаяся от стандартных страниц Справочника и
	  файлов info, которая, как вы думаете, будет полезна пользователям,
	  установите ее в каталог
	  <filename>PREFIX/share/doc</filename>.  Это может
	  быть сделано, как и в предыдущем разделе, в цели
	  <buildtarget>post-install</buildtarget>.</para>

	<para>Создайте для вашего порта новый каталог.  Имя каталога должно
	  соответствовать тому, что представляет из себя порт.  Обычно это
	  означает <varname>PORTNAME</varname>.  Однако, если
	  вы думаете, что пользователь захочет иметь разные версии порта,
	  установленные одновременно, то вы можете использовать полное имя
	  <varname>PKGNAME</varname>.</para>

	<para>Сделайте установку документации зависящей от параметра
	  <literal>DOCS</literal> для того, чтобы пользователи могли
	  выключить это в файле <filename>/etc/make.conf</filename>, как
	  здесь:</para>

	<programlisting>post-install:
.if ${PORT_OPTIONS:MDOCS}
	${MKDIR} ${DOCSDIR}
	${INSTALL_MAN} ${WRKSRC}/docs/xvdocs.ps ${DOCSDIR}
 .endif</programlisting>

	<para>Вот несколько полезных переменных и то, как они преобразуются по
	  умолчанию при использовании в <filename>Makefile</filename>:</para>

	<itemizedlist>
	  <listitem>
	    <para><varname>DATADIR</varname> преобразуется в
	      <filename>PREFIX/share/PORTNAME</filename>.</para>
	  </listitem>

	  <listitem>
	    <para><varname>DATADIR_REL</varname> преобразуется в
	      <filename>share/PORTNAME</filename>.</para>
	  </listitem>

	  <listitem>
	    <para><varname>DOCSDIR</varname> преобразуется в
	      <filename>PREFIX/share/doc/PORTNAME</filename>.</para>
	  </listitem>

	  <listitem>
	    <para><varname>DOCSDIR_REL</varname> преобразуется в
	      <filename>share/doc/PORTNAME</filename>.</para>
	  </listitem>

	  <listitem>
	    <para><varname>EXAMPLESDIR</varname> преобразуется в
	      <filename>PREFIX/share/examples/PORTNAME</filename>.</para>
	  </listitem>

	  <listitem>
	    <para><varname>EXAMPLESDIR_REL</varname> преобразуется в
	      <filename>share/examples/PORTNAME</filename>.</para>
	  </listitem>
	</itemizedlist>

	<note>
	  <para>Параметр <literal>DOCS</literal> управляет установкой
	    дополнительной документации в <varname>DOCSDIR</varname>.  Это
	    не относится к стандартным страницам справочника и страницам info.
	    Все, что устанавливается в <varname>DATADIR</varname> и
	    <varname>EXAMPLESDIR</varname>, соответственно управляется
	    через параметры <literal>DATA</literal> и
	    <literal>EXAMPLES</literal>.</para>
	</note>

	<para>Эти переменные экспортируются в <varname>PLIST_SUB</varname>.
	  Их значения появятся там в виде имён путей относительно
	  <filename>PREFIX</filename>, если это возможно.
	  То есть <filename>share/doc/PORTNAME</filename>
	  в списке сборки по умолчанию будет заменен на
	  <literal>%%DOCSDIR%%</literal>, и так далее.  (Дополнительную
	  информацию о подстановке в <filename>pkg-plist</filename> можно
	  найти <link linkend="plist-sub">здесь</link>.)</para>

	<para>Все условно устанавливаемые файлы и каталоги с документацией
	  должны быть перечислены в файле <filename>pkg-plist</filename> с
	  префиксом <literal>%%PORTDOCS%%</literal>, например:</para>

	<programlisting>%%PORTDOCS%%%%DOCSDIR%%/AUTHORS
%%PORTDOCS%%%%DOCSDIR%%/CONTACT
%%PORTDOCS%%@dirrm %%DOCSDIR%%</programlisting>

	<para>В качестве альтернативы перечислению файлов документации в файле
	  <filename>pkg-plist</filename>, порт может указать в переменной
	  <varname>PORTDOCS</varname> список имён файлов и глобальных шаблонов
	  командного процессора для добавления в окончательный список сборки.
	  Имена будут задаваться относительно <varname>DOCSDIR</varname>.
	  Таким образом, порт, использующий <varname>PORTDOCS</varname> и
	  нестандартное местоположение документации, должен задавать
	  соответствующим образом и <varname>DOCSDIR</varname>.  Если каталог
	  указан в <varname>PORTDOCS</varname> или соответствует шаблону для
	  этой переменной, то полное поддерево с входящими в него файлами и
	  каталогами будет регистрироваться в окончательном списке сборки.
	  Если параметр <literal>DOCS</literal> не задан, то файлы и каталоги,
	  перечисленные в <varname>PORTDOCS</varname>, не будут установлены и
	  добавлены в список сборки порта. Установка документации в
	  <varname>PORTDOCS</varname>, как это показано выше, остаётся за
	  самим портом.  Типичный пример использования
	  <varname>PORTDOCS</varname> выглядит следующим образом:</para>

	<programlisting>PORTDOCS=       README.* ChangeLog docs/*</programlisting>

	<note>
	  <para>Эквивалентами <varname>PORTDOCS</varname> для файлов,
	    устанавливаемых в <varname>DATADIR</varname> и
	    <varname>EXAMPLESDIR</varname> являются <varname>PORTDATA</varname>
	    и <varname>PORTEXAMPLES</varname> соответственно.</para>

	  <para>Кроме того, вы можете использовать файл
	    <filename>pkg-message</filename> для вывода сообщений во
	    время установки.  За подробной информацией обратитесь к <link linkend="porting-message">разделу об использовании
	    <filename>pkg-message</filename></link>.
	    Файл <filename>pkg-message</filename> не нужно добавлять в
	    <filename>pkg-plist</filename>.</para>
	</note>
      </sect2>

      <sect2 xml:id="install-subdirs">
	<title>Подкаталоги внутри PREFIX</title>

	<para>Попробуйте поместить все файлы порта в правильных подкаталогах
	  каталога <varname>PREFIX</varname>.  Некоторые порты игнорируют все
	  установки и помещают все в подкаталог с именем порта, что
	  неправильно.  Также многие порты помещают все, кроме бинарных файлов,
	  файлов заголовков и страниц Справочника, в подкаталог каталога
	  <filename>lib</filename>, что не очень хорошо работает с подходом
	  BSD.  Многие файлы должны быть перемещены в одно из следующих
	  местоположений: <filename>etc</filename>
	  (настроечные/конфигурационные файлы), <filename>libexec</filename>
	  (выполнимые файлы, запускаемые из других программ),
	  <filename>sbin</filename> (исполнимые файлы для
	  администраторов/менеджеров системы), <filename>info</filename>
	  (документация в формате info для просмотрщика info) или
	  <filename>share</filename> (независимые от архитектуры файлы).
	  Обратитесь к &man.hier.7; для прояснения деталей; правила,
	  покрывающие <filename>/usr</filename>, достаточно хорошо подходят
	  также и к <filename>/usr/local</filename>.  Исключением являются
	  порты, имеющие дело с <quote>новостями</quote> USENET.  Они могут
	  использовать каталог
	  <filename>PREFIX/news</filename> для установки
	  своих файлов.</para>
      </sect2>

    </sect1>

  </chapter>

  <chapter xml:id="special">
    <title>Особые соглашения</title>

    <para>Имеется ещё несколько вещей, которые вы должны иметь в виду при
      создании порта.  Этот раздел описывает наиболее часто встречающиеся из
      них.</para>

    <sect1 xml:id="porting-shlibs">
      <title>Динамические библиотеки</title>

      <para>Если ваш порт устанавливает одну или несколько динамических
        библиотек, определите переменную <varname>USE_LDCONFIG</varname>,
        которая приведёт к запуску из <filename>bsd.port.mk</filename> команды
        <literal>&dollar;{LDCONFIG} -m</literal> относительно каталога, в
        который устанавливается новая библиотека (как правило, это
        <filename>PREFIX/lib</filename>), во время
        выполнения цели <buildtarget>post-install</buildtarget> для её
        регистрации в кэше динамических библиотек.  Эта переменная, если она
        определена, также приведёт к добавлению соответствующей пары команд
        <literal>@exec /sbin/ldconfig -m</literal> и
        <literal>@unexec /sbin/ldconfig -R</literal> в ваш файл
        <filename>pkg-plist</filename>, так что пользователь, устанавливающий
        пакет, сможет сразу же использовать динамическую библиотеку, а
        удаление пакета не приведёт к тому, что система будет предполагать,
        что библиотека всё ещё имеется в наличии.</para>

      <programlisting>USE_LDCONFIG= yes</programlisting>

      <para>Если нужно, вы можете переопределить каталог по умолчанию,
        задав значение
        <varname>USE_LDCONFIG</varname>, в котором должны быть перечислены
        каталоги, в которые устанавливаются динамические библиотеки.  Например,
        если ваш порт устанавливает динамические библиотеки в каталоги
        <filename>PREFIX/lib/foo</filename> и
        <filename>PREFIX/lib/bar</filename>, то вы можете в
        файле <filename>Makefile</filename> указать следующее:</para>

      <programlisting>USE_LDCONFIG= ${PREFIX}/lib/foo ${PREFIX}/lib/bar</programlisting>

      <para>Будьте
	добры перепроверить, т.к. часто это вовсе не является необходимым
	и может быть решено иначе с помощью <literal>-rpath</literal>
	или установки <envar>LD_RUN_PATH</envar> во время компоновки (для
	примера смотрите <package>lang/moscow_ml</package>),
	или с помощью сценария-обёртки, который выставляет
	<varname>LD_LIBRARY_PATH</varname> перед запуском исполняемого файла
	как это делает <package>www/seamonkey</package>.</para>

      <para>При установке 32-разрядных библиотек на 64-разрядной системе
	используйте вместо этого <varname>USE_LDCONFIG32</varname>.</para>

      <para>Постарайтесь сохранять номера версий динамических библиотек
	в формате <filename>libfoo.so.0</filename>.  Наш компоновщик
	позаботится только о старшем (первом) номере.</para>

      <para>Если при обновлении порта увеличивается старший номер версии
	библиотеки, то для всех портов, компонуемых с затронутой библиотекой,
	следует увеличить значение <varname>PORTREVISION</varname> для
	форсирования перекомпиляции с новой версией библиотеки.</para>

    </sect1>

    <sect1 xml:id="porting-restrictions">
      <title>Порты с ограничениями на распространение</title>

      <para>Лицензии бывают разных видов, и некоторые накладывают ограничение
        на то, как приложение может быть оформлено в виде пакета, может ли
        оно продаваться для извлечения коммерческой выгоды, и так далее.</para>

      <important>
        <para>На вас, как на человека, портирующего приложение, ложится
	  обязанность прочесть лицензионные соглашения на программное
	  обеспечение и удостовериться, что проект FreeBSD не будет являться
	  их нарушителем, если будет заниматься распространением исходного
	  кода или в бинарном виде по FTP/HTTP или на CD-ROM.  Если
	  у вас возникли сомнения, то, пожалуйста, обратитесь в
          &a.ports;.</para>
      </important>

      <para>В подобных ситуациях можно использовать переменные, описываемые в
        последующих разделах.</para>

      <sect2>
        <title><varname>NO_PACKAGE</varname></title>

        <para>Эта переменная указывает, что мы не можем создавать для
          приложения двоичный пакет.  К примеру, лицензия не позволяет
	  бинарное распространение или она может запрещать распространение
	  пакетов, созданных из изменённых исходников.</para>

	  <para>Однако файлы <varname>DISTFILES</varname> могут свободно
	  зеркалироваться по FTP/HTTP.  Они также могут распространяться,
	  используя CD-ROM (или на похожих носителях), если не установлена
	  переменная <varname>NO_CDROM</varname>.</para>

        <para><varname>NO_PACKAGE</varname> должна также использоваться, если
          двоичный пакет, как правило, бесполезен, а приложение должно всегда
          компилироваться из исходного кода.  К примеру, если в приложение
          во время компиляции жёстко включается конфигурационная информация,
          привязанная к конкретной системе, то задайте переменную
          <varname>NO_PACKAGE</varname>.</para>

        <para>Значением переменной <varname>NO_PACKAGE</varname> должна быть
          строка, описывающая причину, по которой пакет не должен
          создаваться.</para>
      </sect2>

      <sect2>
        <title><varname>NO_CDROM</varname></title>

        <para>Эта переменная указывает на то, что, хотя мы имеем право
          создавать бинарные пакеты, мы не можем помещать эти пакеты или
          файлы <varname>DISTFILES</varname> порта на CD-ROM (или на похожие носители) для
          перепродажи.  Однако бинарные пакеты и файлы
          <varname>DISTFILES</varname> порта будут оставаться
          доступными посредством FTP/HTTP.</para>

	<para>Если эта переменная устанавливается вместе с
	  <varname>NO_PACKAGE</varname>, то только файлы порта
	  <varname>DISTFILES</varname> будут доступны, и только посредством
	  FTP/HTTP.</para>

        <para>В качестве значения <varname>NO_CDROM</varname> должна
          указываться строка, описывающая причины, по которым порт не может
          распространяться на CD-ROM.  К примеру, это применяется, если
          лицензионное соглашение приложения предполагает только его
          <quote>некоммерческое</quote> использование.</para>
      </sect2>

      <sect2>
	<title><varname>NOFETCHFILES</varname></title>

	<para>Файлы, определенные в переменной <varname>NOFETCHFILES</varname>,
	  не будут извлекаться ни из одного из <varname>MASTER_SITES</varname>.
	  Примером такого файла является файл, поставляемый на CD-ROM.</para>

	<para>Инструменты, проверяющие доступность этих файлов на
	  <varname>MASTER_SITES</varname>, должны игнорировать эти файлы и
	  не сообщать о них.</para>
      </sect2>

      <sect2>
        <title><varname>RESTRICTED</varname></title>

        <para>Задайте эту переменную, если лицензия на приложение не позволяет
          ни зеркалировать файлы <varname>DISTFILES</varname>, ни распространять
          бинарный пакет через FTP/HTTP или на CD-ROM.</para>

	<para>Ни <varname>NO_CDROM</varname>, ни <varname>NO_PACKAGE</varname>
	  не стоит устанавливать вместе с <varname>RESTRICTED</varname>, так
	  как последняя переменная подразумевает первые две.</para>

        <para>В качестве значения <varname>RESTRICTED</varname> должна
          указываться строка, описывающая причины, по которым порт нельзя
          распространять.  Обычно это означает, что порт использует закрытое
          программное обеспечение, а пользователь должен вручную сгрузить файлы
          <varname>DISTFILES</varname>, возможно, после заполнения
          регистрационной формы или подтверждения соглашения с условиями
          <acronym>EULA</acronym>.</para>
      </sect2>

      <sect2>
        <title><varname>RESTRICTED_FILES</varname></title>

        <para>Если заданы <varname>RESTRICTED</varname> или
          <varname>NO_CDROM</varname>, то значение этой переменной по умолчанию
          соответствует <literal>${DISTFILES} ${PATCHFILES}</literal>, в
          противном случае она пуста.  Если ограничены в распространении лишь
          некоторые из дистрибутивных файлов, то в этой переменной задаётся их
          список.</para>

        <para>Обратите внимание, что при включении порта в дерево исходных
          текстов системы коммиттер должен добавить запись в файл
          <filename>/usr/ports/LEGAL</filename> для каждого из перечисленных
          файлов, в точности описав, что подразумевают ограничения.</para>
      </sect2>

      <sect2>
	<title>Примеры использования</title>

	<para>Предпочтительным способом реализации утверждения "архивы
	  исходных текстов для этого порта должны загружаться самостоятельно"
	  является следующее:</para>

	<programlisting>.if !exists(${DISTDIR}/${DISTNAME}${EXTRACT_SUFX})
IGNORE=         may not be redistributed because of licensing reasons. Please visit <replaceable>some-website</replaceable> to accept their license and download ${DISTFILES} into ${DISTDIR}
.endif</programlisting>

	<para>Это одновременно и информирует пользователя, и устанавливает
	  нужные метаданные на пользовательской машине для использования
	  автоматическими программами.</para>

	<para>Обратите внимание, что данная кляуза должна предшествовать
	  подключению файла <filename>bsd.port.pre.mk</filename>.</para>
      </sect2>
    </sect1>

    <sect1 xml:id="building">
      <title>Механизмы построения</title>

      <sect2 xml:id="parallel-builds">
	<title>Параллельное построение портов</title>

	<para>Инфраструктура портов &os; поддерживает параллельное
	  построение с использованием множественных подпроцессов
	  <command>make</command>, что позволяет системам
	  <acronym>SMP</acronym> задействовать всю доступную мощность
	  <acronym>CPU</acronym>, тем самым делая построение портов более
	  быстрым и эффективным.</para>

	<para>Это достигается путем передачи флага <varname>-jX</varname>
	  команде &man.make.1;.  К сожалению, не все порты поддерживают
	  параллельную сборку достаточно хорошо.  Поэтому требуется включать
	  этот механизм явным образом путем добавления строки
	  <literal>MAKE_JOBS_SAFE=yes</literal> в <filename>Makefile</filename>
	  где-нибудь после раздела с объявлениями зависимостей.</para>

	<para>Другой опцией управления этим механизмом с точки зрения
	  сопровождающего является <varname>MAKE_JOBS_UNSAFE=yes</varname>.
	  Эта переменная используется в случае, когда известно, что порт
	  ломается с <varname>-jX</varname>, и пользователь форсирует
	  использование многопроцессорной компиляции для всех портов с
	  переменной <literal>FORCE_MAKE_JOBS=yes</literal> в
	  <filename>/etc/make.conf</filename>.</para>
      </sect2>

      <sect2 xml:id="using-make">
	<title><command>make</command>, <command>gmake</command> и
	  <command>imake</command></title>

	<para>Если ваш порт использует <application>GNU make</application>,
	  то установите <literal>USES= gmake</literal>.</para>

	  <table frame="none">
	    <title>Переменные для портов, использующих
	      <application>gmake</application></title>

	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry>Переменная</entry>

		  <entry>Значение</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry><varname>USES= gmake</varname></entry>

		  <entry>Для сборки порта требуется
		    <command>gmake</command>.</entry>
		</row>

		<row>
		  <entry><varname>GMAKE</varname></entry>

		  <entry>Полный путь к команде <command>gmake</command>, если
		    отсутствует в <envar>PATH</envar>.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>

	  <para>Если ваш порт является приложением X, которое создает файлы
	    <filename>Makefile</filename> из <filename>Imakefile</filename>,
	    используя <application>imake</application>, то установите
	    <literal>USES= imake</literal>.  Это заставит стадию
	    конфигурирования автоматически выполнить <command>xmkmf -a</command>.
	    Если флаг <option>-a</option> представляет для вашего порта
	    проблему, то установите <literal>XMKMF=xmkmf</literal>.  Если
	    порт использует <application>imake</application>, но не понимает
	    цель <buildtarget>install.man</buildtarget>, то следует установить
	    <literal>NO_INSTALL_MANPAGES=yes</literal>.</para>

	  <para>Если исходный <filename>Makefile</filename> вашего порта
	    имеет что-нибудь помимо <buildtarget>all</buildtarget> в качестве
	    основной цели построения, то задайте соответствующее значение
	    <varname>ALL_TARGET</varname>.  То же касается
	    <buildtarget>install</buildtarget> и
	    <varname>INSTALL_TARGET</varname>.</para>

	</sect2>

	<sect2 xml:id="using-configure">
	  <title>Сценарий <command>configure</command></title>

	<para>Если ваш порт использует сценарий <command>configure</command>
	  для получения файлов <filename>Makefile</filename> из файлов
	  <filename>Makefile.in</filename>, то установите
	  <literal>GNU_CONFIGURE=yes</literal>.  Если вы хотите дать
	  дополнительные параметры сценарию <command>configure</command>
	  (аргументом по умолчанию является <literal>--prefix=&dollar;{PREFIX}
	  --infodir=&dollar;{PREFIX}/&dollar;{INFO_PATH}
	  --mandir=&dollar;{MANPREFIX}/man
	  --build=&dollar;{CONFIGURE_TARGET}</literal>), установите эти параметры
	  в <varname>CONFIGURE_ARGS</varname>.  Дополнительные переменные
	  окружения можно передать, используя переменную
	  <varname>CONFIGURE_ENV</varname>.</para>

	<table frame="none">
	  <title>Переменные для портов, использующих
	    <command>configure</command></title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Переменная</entry>

		<entry>Значение</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><varname>GNU_CONFIGURE</varname></entry>

		<entry>Порт использует сценарий <command>configure</command>
		  для подготовки построения.</entry>
	      </row>

	      <row>
		<entry><varname>HAS_CONFIGURE</varname></entry>

		<entry>То же, что и <varname>GNU_CONFIGURE</varname>, кроме
		  того, что цель configure по умолчанию не добавляется в
		  <varname>CONFIGURE_ARGS</varname>.</entry>
	      </row>

	      <row>
		<entry><varname>CONFIGURE_ARGS</varname></entry>

		<entry>Дополнительные параметры, передаваемые сценарию
		  <command>configure</command>.</entry>
	      </row>

	      <row>
		<entry><varname>CONFIGURE_ENV</varname></entry>

		<entry>Дополнительные переменные окружения, задаваемые для
		  запуска сценария <command>configure</command>.</entry>
	      </row>

	      <row>
		<entry><varname>CONFIGURE_TARGET</varname></entry>

		<entry>Переопределить цель configure по умолчанию.  Значением
		  по умолчанию является
		  <literal>&dollar;{MACHINE_ARCH}-portbld-freebsd&dollar;{OSREL}</literal>.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </sect2>

      <sect2 xml:id="using-cmake">
	<title>Использование <command>cmake</command></title>

	<para>Если ваш порт использует <application>CMake</application>,
	  определите <literal>USES= cmake</literal> или
	  <literal>USES= cmake:outsource</literal> для построения
	  во внешнем каталоге (см. ниже).</para>

	<table frame="none">
	  <title>Переменные для портов, использующих
	    <command>cmake</command></title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Переменная</entry>
		<entry>Значение</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><varname>CMAKE_ARGS</varname></entry>
		<entry>Специфичные для порта флаги
		  <application>CMake</application>, передаваемые
		  <command>cmake</command>.</entry>
	      </row>

	      <row>
		<entry><varname>CMAKE_BUILD_TYPE</varname></entry>
		<entry>Тип построения (предопределённые профили
		  построения <application>CMake</application>).  По
		  умолчанию <literal>Release</literal>,
		  <literal>Debug</literal> при использовании
		  <varname>WITH_DEBUG</varname>.</entry>
	      </row>

	      <row>
		<entry><varname>CMAKE_ENV</varname></entry>
		<entry>Переменные окружения для передачи
		  <command>cmake</command>.  По умолчанию
		  <literal>&dollar;{CONFIGURE_ENV}</literal>.</entry>
	      </row>

	      <row>
		<entry><varname>CMAKE_SOURCE_PATH</varname></entry>
		<entry>Путь к каталогу с исходным кодом.  По умолчанию
		  <literal>&dollar;{WRKSRC}</literal>.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para><application>CMake</application> поддерживает следующие
	  профили построения: <literal>Debug</literal>,
	  <literal>Release</literal>,
	  <literal>RelWithDebInfo</literal> и
	  <literal>MinSizeRel</literal>.  Профили
	  <literal>Debug</literal> и <literal>Release</literal>
	  учитывают системные флаги <literal>*FLAGS</literal>;
	  <literal>RelWithDebInfo</literal> и
	  <literal>MinSizeRel</literal> соответственно определяют
	  <varname>CFLAGS</varname> со значением
	  <literal>-O2 -g</literal> и <literal>-Os -DNDEBUG</literal>.
	  Значение <varname>CMAKE_BUILD_TYPE</varname> экспортируется
	  в нижнем регистре в <varname>PLIST_SUB</varname> и должно
	  использоваться, если порт устанавливает файлы
	  <literal>*.cmake</literal> в зависимости от типа построения
	  (для примера посмотрите на <package>deskutils/strigi</package>).  Следует
	  учитывать, что некоторые проекты могут определять собственные
	  профили построения и/или форсировать конкретный тип построения
	  через установку <literal>CMAKE_BUILD_TYPE</literal> в файлах
	  <filename>CMakeLists.txt </filename> .  Для того чтобы порт
	  для такого проекта учитывал <varname>CFLAGS</varname> и
	  <varname>WITH_DEBUG</varname>, из этих файлов должны быть
	  удалены значения <literal>CMAKE_BUILD_TYPE</literal>.</para>

	<para>Большинство проектов, основанных на
	  <application>CMake</application>, поддерживают метод внешнего
	  (out-of-source) построения.  Для порта внешнее построение
	  можно запросить с использованием суффикса
	  <literal>:outsource</literal>.  В этом случае
	  <varname>CONFIGURE_WRKSRC</varname>,
	  <varname>BUILD_WRKSRC</varname> и
	  <varname>INSTALL_WRKSRC</varname> будут иметь значение
	  <literal>&dollar;{WRKDIR}/.build</literal> для каталога,
	  содержащего файлы, получаемые на этапах конфигурации и
	  построения; при этом каталог с исходным кодом будет
	  оставаться без изменений.</para>

	<example xml:id="using-cmake-example">
	  <title>Пример использования
	    <literal>USES= cmake</literal></title>

	  <para>Следующий отрывок демонстрирует использование
	    <application>CMake</application> для порта.
	    <varname>CMAKE_SOURCE_PATH</varname> обычно не требуется,
	    но может быть установлен, когда исходный код не находится
	    в верхнем каталоге или если порт используется для
	    построения части проекта.</para>

	  <programlisting>USES=			cmake:outsource
CMAKE_SOURCE_PATH=	&dollar;{WRKSRC}/subproject</programlisting>
	</example>
      </sect2>

      <sect2 xml:id="using-scons">
	<title>Использование <command>scons</command></title>

	<para>Если ваш порт использует <application>SCons</application>,
	  определите <literal>USE_SCONS=yes</literal>.</para>

	<table frame="none">
	  <title>Переменные для портов, использующих
	    <command>scons</command></title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Переменная</entry>

		<entry>Значение</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><varname>SCONS_ARGS</varname></entry>

		<entry>Специфичные для порта флаги SCons, передаваемые
		  окружению SCons.</entry>
	      </row>

	      <row>
		<entry><varname>SCONS_BUILDENV</varname></entry>

		<entry>Переменные для установки в системном окружении.</entry>
	      </row>

	      <row>
		<entry><varname>SCONS_ENV</varname></entry>

		<entry>Переменные для установки в окружении SCons.</entry>
	      </row>

	      <row>
		<entry><varname>SCONS_TARGET</varname></entry>

		<entry>Последний параметр для передачи SCons, похожий на
		  <varname>MAKE_TARGET</varname>.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>Для того, чтобы сторонний <filename>SConstruct</filename>
	  соответствовал всему, что передается SCons в переменной
	  <varname>SCONS_ENV</varname> (самое главное, это
	  <varname>CC/CXX/CFLAGS/CXXFLAGS</varname>), примените патч к
	  <filename>SConstruct</filename>, так чтобы переменная построения
	  <literal>Environment</literal> выглядела следующим образом:</para>

	<programlisting>env = Environment(**ARGUMENTS)</programlisting>

	<para>В дальнейшем ее можно изменить при помощи
	  <literal>env.Append</literal> и <literal>env.Replace</literal>.</para>
      </sect2>
    </sect1>

    <sect1 xml:id="using-autotools">
      <title>Использование GNU autotools</title>

	<sect2 xml:id="using-autotools-introduction">
	  <title>Введение</title>

	  <para>Различные инструменты GNU autotools предоставляют механизм
	    абстракции для построения частей программного обеспечения на
	    широком наборе операционных систем и аппаратных архитектур.
	    Внутри Коллекции Портов отдельный порт может использовать
	    эти инструменты при помощи простых конструкций:</para>

	  <programlisting>USE_AUTOTOOLS= <replaceable>tool</replaceable>:<replaceable>version</replaceable>[:<replaceable>operation</replaceable>] ...</programlisting>

	  <para>К моменту написания <replaceable>tool</replaceable>
	    может быть одним из <literal>libtool</literal>,
	    <literal>libltdl</literal>, <literal>autoconf</literal>,
	    <literal>autoheader</literal>, <literal>automake</literal> или
	    <literal>aclocal</literal>.</para>

	  <para><replaceable>version</replaceable> указывает конкретную
	    версию используемого инструмента (действующие версии смотрите в
	    <literal>devel/{automake,autoconf,libtool}[0-9]+</literal>).</para>

	  <para><replaceable>operation</replaceable> является необязательным
	    расширением и указывает на способ использования
	    инструмента.</para>

	  <para>Одновременно может быть указано несколько инструментов,
	    добавляя их все на одной строке или используя конструкцию
	    Makefile <literal>+=</literal>.</para>

	  <para>В заключение, существует специальный инструмент по называнию
	    <literal>autotools</literal>, который является удобной функцией
	    при установке всех доступных версий autotools для возможности
	    проведения кросс-разработки.  Это также может быть достигнуто
	    путем установки порта <literal>devel/autotools</literal>.</para>

	</sect2>

	<sect2 xml:id="using-libtool">
	  <title><command>libtool</command></title>

	  <para>Динамические библиотеки, использующие инфраструктуру
	    построения GNU, обычно используют <application>libtool</application>
	    для настройки компиляции и установки динамических библиотек в
	    соответствии с особенностями данной операционной системы.
	    В типичной практике используется копирование встроенного в
	    приложение <command>libtool</command>.  Если вам нужно
	    использовать внешнюю команду <command>libtool</command>, то вы
	    можете использовать версию, поставляемую Коллекцией Портов:</para>

	  <programlisting>USE_AUTOTOOLS= libtool:<replaceable>version</replaceable>[:env]</programlisting>

	  <para>При отсутствии дополнительных операций,
	    <literal>libtool:version</literal>
	    сообщает инфраструктуре построения о применении патча к сценарию
	    configure с установленной в системе копией
	    <command>libtool</command>.  Подразумевается использование
	    The <varname>GNU_CONFIGURE</varname>
	    Более того, некоторые переменные make и оболочки shell
	    будут назначены для дальнейшего использования этим портом.
	    Подробности смотрите в <filename>bsd.autotools.mk</filename>.</para>

	  <para>При использовании операции <literal>:env</literal> будет
	    настроено только окружение.</para>

	  <para>Наконец, <varname>LIBTOOLFLAGS</varname> и
	    <varname>LIBTOOLFILES</varname> можно установить по желанию,
	    чтобы переопределить наиболее вероятные аргументы для
	    <command>libtool</command> и файлы, предназначенные для
	    изменения.  Большинству портов это скорее всего не понадобится.
	    Для дальнейших подробностей смотрите
	    <filename>bsd.autotools.mk</filename>.</para>
	</sect2>

	<sect2 xml:id="using-libltdl">
	  <title><command>libltdl</command></title>

	  <para>Некоторые порты задействуют пакет с библиотекой
	    <command>libltdl</command>, которая является частью комплекта
	    <command>libtool</command>.  Использование этой библиотеки
	    не вызывает автоматическое использование самой
	    <command>libtool</command>, и, таким образом, обеспечивается
	    отдельная конструкция.</para>

	  <programlisting>USE_AUTOTOOLS= libltdl:<replaceable>version</replaceable></programlisting>

	  <para>Всё, что в настоящее время она делает, это добавление
	    <varname>LIB_DEPENDS</varname> для подходящего порта
	    <command>libltdl</command>, потому она предоставляется как
	    удобная функция для помощи в устранении всяких зависимостей от
	    портов autotools вне инфраструктуры <varname>USE_AUTOTOOLS</varname>.
	    Для этого инструмента не существует необязательных операций.</para>

	</sect2>

	<sect2 xml:id="using-autoconf">
	  <title><command>autoconf</command> и
	    <command>autoheader</command></title>

	  <para>Некоторые порты не содержат сценарий configure, но содержат
	    шаблон autoconf в файле <filename>configure.ac</filename>.
	    Вы можете использовать следующие присвоения, чтобы позволить
	    <command>autoconf</command> создать сценарий configure, а
	    <command>autoheader</command> создать заголовки шаблона для
	    использования в сценарии configure.</para>

	  <programlisting>USE_AUTOTOOLS=	autoconf:<replaceable>version</replaceable>[:env]</programlisting>

	  <para>и</para>

	  <programlisting>USE_AUTOTOOLS=	autoheader:<replaceable>version</replaceable></programlisting>

	  <para>которые также подразумевают использование
	    <literal>autoconf:version</literal>.</para>

	  <para>Аналогично команде <command>libtool</command>, подключение
	    необязательной операции <literal>:env</literal> всего лишь
	    настраивает окружение для дальнейшего использования.  Без этого
	    выполняется наложение патчей и переконфигурирование порта.</para>

	  <para>Дополнительные необязательные переменные
	    <varname>AUTOCONF_ARGS</varname> и <varname>AUTOHEADER_ARGS</varname>
	    можно переопределить в <filename>Makefile</filename> порта,
	    если указано явным образом.  Как и с эквивалентами
	    <command>libtool</command>, большинству портов это вряд ли
	    понадобится.</para>
	</sect2>

	<sect2 xml:id="using-automake">
	  <title><command>automake</command> и
	    <command>aclocal</command></title>

	  <para>Некоторые пакеты содержат только файлы
	    <filename>Makefile.am</filename>.  Они должны быть преобразованы
	    в файлы <filename>Makefile.in</filename> с использованием
	    <application>automake</application> и дальнейшей обработкой
	    <command>configure</command> для получения настоящего
	    <filename>Makefile</filename>.</para>

	  <para>Аналогично, иногда пакеты не поставляются с вложенными
	    файлами <filename>aclocal.m4</filename>, снова требуемых для
	    построения программного обеспечения.  Этого можно достичь
	    с <command>aclocal</command>, которая просматривает
	    <filename>configure.ac</filename> или
	    <filename>configure.in</filename>.</para>

	  <para><command>aclocal</command> имеет похожую связь с
	    <command>automake</command>, как у <command>autoheader</command>
	    с <command>autoconf</command>, что описано в предыдущей главе.
	    <command>aclocal</command> подразумевает использование
	    <command>automake</command>, таким образом, мы имеем:</para>

	  <programlisting>USE_AUTOTOOLS=	automake:<replaceable>version</replaceable>[:<replaceable>env</replaceable>]</programlisting>

	  <para>и</para>

	  <programlisting>USE_AUTOTOOLS=	aclocal:<replaceable>version</replaceable></programlisting>

	  <para>которые также подразумевают использование
	    <literal>automake:version</literal>.</para>

	  <para>Также как и для <command>libtool</command> и
	    <command>autoconf</command>, подключение необязательной
	    операции <literal>:env</literal> всего лишь устанавливает
	    окружение для дальнейшего пользования.  Без этого выполняется
	    реконфигурирование этого порта.</para>

	  <para>Как и в случае с
	    <command>autoconf</command> и <command>autoheader</command>, обе
	    <command>automake</command> и <command>aclocal</command> имеют
	    необязательные переменные <varname>AUTOMAKE_ARGS</varname> и
	    <varname>ACLOCAL_ARGS</varname>, соответственно, которые при
	    необходимости можно переопределить в <filename>Makefile</filename>
	    порта.</para>

	</sect2>
      </sect1>

    <sect1 xml:id="using-gettext">
      <title>Использование GNU <literal>gettext</literal></title>

      <sect2>
	<title>Простой вариант использования</title>

	<para>Если для вашего порта требуется <literal>gettext</literal>,
	  добавьте <literal>USES= gettext</literal>, и ваш порт
	  унаследует зависимость от <package>devel/gettext</package>.
	  <xref linkend="uses-values"/> содержит перечень других
	  значений для использования <literal>gettext</literal>.</para>

	<para>Довольно распространенным случаем является использование в
	  порте <literal>gettext</literal> и <command>configure</command>.
	  Как правило, GNU <command>configure</command> способен находить
	  <literal>gettext</literal> автоматически.  Если он все же не
	  сможет это сделать, то подсказки для размещения
	  <literal>gettext</literal> можно передать через переменные окружения
	  <envar>CPPFLAGS</envar> и <envar>LDFLAGS</envar>:</para>

	<programlisting>USES=	gettext
CPPFLAGS+=      -I${LOCALBASE}/include
LDFLAGS+=       -L${LOCALBASE}/lib

GNU_CONFIGURE=  yes</programlisting>

	<para>Конечно же, этот код можно записать в более компактном
	  виде, если передавать флаги в
	  <command>configure</command> не требуется:</para>

	<programlisting>USES=	gettext
GNU_CONFIGURE=  yes</programlisting>
      </sect2>

      <sect2>
	<title>Оптимальное использование</title>

	<para>Некоторые программные продукты позволяют отключать NLS,
	  к примеру через передачу параметра <option>--disable-nls</option>
	  сценарию <command>configure</command>.  В этом случае ваш порт
	  должен использовать <literal>gettext</literal>, в зависимости
	  от значения <varname>NLS</varname>.
	  Для портов небольшой или средней сложности вы можете полагаться
	  на следующую идиому:</para>

	<programlisting>GNU_CONFIGURE=          yes

.include &lt;bsd.port.options.mk&gt;

.if ${PORT_OPTIONS:MNLS}
USES+=			gettext
PLIST_SUB+=             NLS=""
.else
CONFIGURE_ARGS+=        --disable-nls
PLIST_SUB+=             NLS="@comment "
.endif

.include &lt;bsd.port.mk&gt;</programlisting>

	<para>Следующий пункт в вашем списке дел разобраться, чтобы файлы
	  каталога сообщения включались в список упаковки по условию.  Часть,
	  входящая в <filename>Makefile</filename>, уже обеспечена этой
	  идиомой.  Остальное объясняется в главе <link linkend="plist-sub">
	  продвинутые практики <filename>pkg-plist</filename></link>.  Вкратце,
          каждое вхождение <literal>%%NLS%%</literal> в
	  <filename>pkg-plist</filename> будет заменено на
	  <quote><literal>@comment&nbsp;</literal></quote>, если NLS выключен,
	  или пустой строкой, если включен.  В результате строки,
	  предваряемые <literal>%%NLS%%</literal>, станут комментариями
	  в итоговом листе упаковки, если NLS выключен; иначе, префикс будет
	  просто удален.  Всё, что вам нужно, это вставить
	  <literal>%%NLS%%</literal> перед каждым путем к файлу каталога
	  сообщений в <filename>pkg-plist</filename>.  Например:</para>

	<programlisting>%%NLS%%share/locale/fr/LC_MESSAGES/foobar.mo
%%NLS%%share/locale/no/LC_MESSAGES/foobar.mo</programlisting>

	<para>В особо сложных случаях вам понадобиться использовать более
	  продвинутые техники, чем данный рецепт, такие как <link linkend="plist-dynamic">динамические списки упаковки</link>.</para>
      </sect2>

      <sect2>
	<title>Управление каталогами сообщений</title>

	<para>Существует момент, который следует учитывать при установке
	  файлов каталогов сообщений.  Целевые каталоги для размещения,
	  расположенные под
	  <filename>LOCALBASE/share/locale</filename>,
	  редко когда должны создаваться и удаляться портом.  Для
	  наиболее популярных языков имеются собственные каталоги,
	  перечисленные в
	  <filename>PORTSDIR/Templates/BSD.local.dist</filename>.
	  Каталоги для
	  множества других языков управляются с помощью порта <package>devel/gettext</package>.  Обратите внимание
	  на его <filename>pkg-plist</filename> и посмотрите, куда данный
	  порт собирается установить файлы каталогов сообщений для
	  единственного в своем роде языка.</para>
      </sect2>
    </sect1>

    <sect1 xml:id="using-perl">
      <title>Использование <application>Perl</application></title>

      <para>Если <varname>MASTER_SITES</varname> установлена в значение
	<varname>MASTER_SITE_PERL_CPAN</varname>, то предпочтительным
	значением <varname>MASTER_SITE_SUBDIR</varname> является имя
	иерархии верхнего уровня.  Например, рекомендуемым значением для
	<literal>p5-Module-Name</literal> является <literal>Module</literal>.
	Иерархию верхнего уровня можно посмотреть на сайте <link xlink:href="http://cpan.org/modules/by-module/">cpan.org</link>.  Это
	поддерживает порт в рабочем состоянии при изменении модуля
	автором.</para>

      <para>Исключением этого правила является отсутствие соответствующего
	каталога или файла с дистрибутивом в этом каталоге.  В этом случае
	в качестве <varname>MASTER_SITE_SUBDIR</varname> разрешается
	использовать id автора.</para>

      <para>Все из настраиваемых knobs ниже принимают либо <literal>YES</literal>,
	либо строку с версией вида <literal>5.8.0+</literal>.
	<literal>YES</literal> означает, что данный порт можно использовать
	с любой из поддерживаемых версий Perl.
	Если порт работает только с некоторыми версиями
	Perl, то это можно обозначить при помощи
	строки с версией, указывающей на минимальную версию (пример:
	<literal>5.7.3+</literal>), максимальную версию (пример:
	<literal>5.8.0-</literal>) или точную версию (пример:
	<literal>5.8.3</literal>).</para>

      <table frame="none">
	<title>Переменные для портов, использующих
	  <application>Perl</application></title>

	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Переменная</entry>

	      <entry>Значение</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><varname>USE_PERL5</varname></entry>

	      <entry>Perl 5 используется для построения и работы.</entry>
	    </row>

	    <row>
              <entry><varname>USE_PERL5_BUILD</varname></entry>

	      <entry>Perl 5 используется для построения.</entry>
            </row>

            <row>
              <entry><varname>USE_PERL5_RUN</varname></entry>

	      <entry>Perl 5 используется во время работы.</entry>
            </row>

            <row>
              <entry><varname>PERL</varname></entry>

	      <entry>Полный путь к интерпретатору Perl 5, либо в
                системе, либо установленному из портов, но без номера версии.
                Используйте это, если вам нужно заменить строки
                <quote><literal>#!</literal></quote> в скриптах.</entry>
            </row>

            <row>
              <entry><varname>PERL_CONFIGURE</varname></entry>

              <entry>Конфигурация при помощи MakeMaker языка Perl.  Влечёт
                <varname>USE_PERL5</varname>.</entry>
	    </row>

            <row>
              <entry><varname>PERL_MODBUILD</varname></entry>

              <entry>Конфигурация, построение и установка с использованием
		Module::Build.  Влечёт <varname>PERL_CONFIGURE</varname>.
	      </entry>
	    </row>
	  </tbody>
	</tgroup>

	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Переменные только для чтения</entry>

	      <entry>Значение</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><varname>PERL_VERSION</varname></entry>

	      <entry>Полная версия установленного Perl
                (например, <literal>5.8.9</literal>).</entry>
	    </row>

            <row>
              <entry><varname>PERL_LEVEL</varname></entry>

	      <entry>Установленная версия Perl в форме
                целого числа вида <literal>MNNNPP</literal> (например,
                <literal>500809</literal>).</entry>
	    </row>

	    <row>
	      <entry><varname>PERL_ARCH</varname></entry>

	      <entry>Место, в котором Perl хранит
                архитектурно-зависимые библиотеки.  По умолчанию
                это <literal>${ARCH}-freebsd</literal>.</entry>
            </row>

            <row>
              <entry><varname>PERL_PORT</varname></entry>

	      <entry>Название установленного порта Perl,
                (к примеру, <literal>perl5</literal>).</entry>
            </row>

            <row>
              <entry><varname>SITE_PERL</varname></entry>

              <entry>Имя каталога, куда помещаются специфичные для сайта
                пакеты Perl.  Это значение добавляется к
                <varname>PLIST_SUB</varname>.</entry>
            </row>
	  </tbody>
	</tgroup>
      </table>

      <note>
	<para>Порты для модулей Perl, которые не имеют официального вебсайта,
	  должны указывать <systemitem>cpan.org</systemitem> в строке WWW в файле
	  <filename>pkg-descr</filename>.  Предпочтительная форма URL
	  <literal>http://search.cpan.org/dist/Module-Name/</literal>
	  (включая завершающий слэш).</para>
      </note>

      <note>
	<para>Не используйте <literal>${SITE_PERL}</literal> в объявлении
	  зависимостей.  Использование этой конструкции подразумевает
	  наличие подключенного <filename>bsd.perl.mk</filename>, что
	  не всегда так.  Порты, зависимые от этого порта, получат
	  неправильные зависимости, если файлы этого порта будут
	  перемещены при последующем обновлении.  Правильный способ
	  объявления зависимостей для модулей Perl показан в примере
	  ниже.</para>
      </note>

      <example xml:id="use-perl-dependency-example">
	<title>Пример зависимости Perl</title>

	<programlisting>p5-IO-Tee&gt;=0.64:${PORTSDIR}/devel/p5-IO-Tee</programlisting>
      </example>
    </sect1>

    <sect1 xml:id="using-x11">
      <title>Использование X11</title>

      <sect2 xml:id="x11-variables">
	<title>Компоненты X.Org</title>

	<para>X.Org является реализацией X11, доступной в Коллекции Портов.
	  Если ваше приложение зависит от компонентов X, установите в
	  переменную <varname>USE_XORG</varname> в перечень требуемых
	  компонентов.  К настоящему времени доступными компонентами
	  являются:</para>

	<para><literal>bigreqsproto compositeproto damageproto dmx
	    dmxproto dri2proto evieproto fixesproto fontcacheproto
	    fontenc fontsproto fontutil glproto ice inputproto kbproto
	    libfs oldx pciaccess pixman printproto randrproto
	    recordproto renderproto resourceproto scrnsaverproto sm
	    trapproto videoproto x11 xau xaw xaw6 xaw7 xbitmaps
	    xcmiscproto xcomposite xcursor xdamage xdmcp xevie xext
	    xextproto xf86bigfontproto xf86dgaproto xf86driproto
	    xf86miscproto xf86rushproto xf86vidmodeproto xfixes xfont
	    xfontcache xft xi xinerama xineramaproto xkbfile xkbui
	    xmu xmuu xorg-server xp xpm xprintapputil xprintutil
	    xproto xproxymngproto xrandr xrender xres xscrnsaver xt
	    xtrans xtrap xtst xv xvmc xxf86dga xxf86misc xxf86vm</literal>.</para>

	<para>Всегда актуальный перечень можно найти в
	  <filename>/usr/ports/Mk/bsd.xorg.mk</filename>.</para>

	<para>Проект Mesa является попыткой обеспечить свободную реализацию
	  OpenGL.  Вы можете указать зависимость от различных компонентов
	  этого проекта при помощи переменной <varname>USE_GL</varname>.
	  Действительные опции: <literal>glut, glu, glw, glew, gl</literal> и
	  <literal>linux</literal>.  Для обратной совместимости значение
	  <literal>yes</literal> соответствует <literal>glu</literal>.</para>

	<example xml:id="use-xorg-example">
	  <title>Пример для USE_XORG</title>
	  <programlisting>USE_XORG=   xrender xft xkbfile xt xaw
USE_GL=     glu</programlisting>
	</example>

      <table frame="none">
	<title>Переменные для портов, использующих X</title>

	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry><varname>USES= imake</varname></entry>

	      <entry>Порт использует <command>imake</command>.</entry>
	    </row>

	    <row>
	      <entry><varname>XMKMF</varname></entry>

	      <entry>Задаётся маршрут до <command>xmkmf</command>, если он
                отсутствует в переменной окружения <envar>PATH</envar>.  По
                умолчанию это <literal>xmkmf -a</literal>.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <example xml:id="using-x11-vars">
	<title>Использование переменных X11 в порте</title>

	<programlisting># Использовать некоторые библиотеки X11
USE_XORG=      x11 xpm</programlisting>
      </example>
      </sect2>

      <sect2 xml:id="porting-motif">
	<title>Порты, которым требуется Motif</title>

	<para>Если вашему порту требуется Motif, задайте переменную
	  <varname>USES= motif</varname> в файле <filename>Makefile</filename>.
	  Реализация Motif, используемая по умолчанию, находится в
	  <package>x11-toolkits/open-motif</package>.
	  Пользователи вместо этого могут выбрать
	  <package>x11-toolkits/lesstif</package> через
	  установку переменной <varname>WANT_LESSTIF</varname>.</para>

	<para>Переменная <varname>MOTIFLIB</varname> будет установлена в
	  <filename>bsd.port.mk</filename>, чтобы ссылаться на
	  соответствующую библиотеку Motif.  Пожалуйста, измените исходные
	  тексты вашего порта на использование
	  <literal>&dollar;{MOTIFLIB}</literal> везде, где упоминается
	  библиотека Motif, в первоначальном <filename>Makefile</filename>
	  или <filename>Imakefile</filename>.</para>

	<para>Существует два общих случая:</para>

	<itemizedlist>
	  <listitem>
	    <para>Если порт обращается к библиотеке Motif как
	      <literal>-lXm</literal> в своих файлах
	      <filename>Makefile</filename> или <filename>Imakefile</filename>,
	      просто подставьте вместо этих обращений
	      <literal>&dollar;{MOTIFLIB}</literal>.</para>
	  </listitem>

	  <listitem>
	    <para>Если порт использует <literal>XmClientLibs</literal> в своем
	      файле <filename>Imakefile</filename>, измените это обращение на
	      <literal>&dollar;{MOTIFLIB} &dollar;{XTOOLLIB}
	      &dollar;{XLIB}</literal>.</para>
	  </listitem>
	</itemizedlist>

	<para>Заметьте, что переменная <varname>MOTIFLIB</varname> (как
	  правило) раскрывается в <literal>-L/usr/local/lib -lXm</literal> или
	  <literal>/usr/local/lib/libXm.a</literal>, так что нет нужды впереди
	  добавлять <literal>-L</literal> или <literal>-l</literal>.</para>

      </sect2>

      <sect2>
	<title>Шрифты для X11</title>

	<para>Если ваш порт устанавливает шрифты для X Window System,
	  поместите их в каталог
	  <filename>LOCALBASE/lib/X11/fonts/local</filename>.
	</para>

      </sect2>

      <sect2>
	<title>Получение поддельного <envar>DISPLAY</envar>, используя
	  Xvfb</title>

	<para>Некоторые приложения для успешной компиляции требуют
	  наличие работающего дисплея X11.  Это создает проблему для машин,
	  которые работают в режиме headless.  При использовании следующего
	  канонического хака инфраструктура построения
	  запустит сервер X в виртуальном фреймбуфере.  Затем переменная
	  работающего <envar>DISPLAY</envar> передается при построении.</para>

	<programlisting>USES=	display</programlisting>
      </sect2>

      <sect2 xml:id="desktop-entries">
	<title>Элементы рабочего стола</title>

	<para>Элементы рабочего стола (<link xlink:href="http://standards.freedesktop.org/desktop-entry-spec/latest/">стандарта
	  Freedesktop</link>) предоставляют способ автоматической настройки
	  функций рабочего стола при установке новой программы, не требуя
	  вмешательства пользователя.  Например, новые программы автоматически
	  отображаются в меню приложений совместимых окружений рабочего стола.
	  Элементы рабочего стола изначально появились в окружении рабочего
	  стола <application>GNOME</application>, но в настоящее время являются
	  стандартом и также работают с <application>KDE</application> и
	  <application>Xfce</application>.  Такая небольшая автоматизация
	  предоставляет реальное удобство для пользователя, и посему элементы
	  рабочего стола приветствуются в приложениях, которые можно
	  использовать в окружении рабочего стола.</para>

	<sect3>
	  <title>Использование предопределенных файлов
	    <filename>.desktop</filename></title>

	  <para>Порты, включающие предопределенные файлы
	    <filename>*.desktop</filename>, должны включать эти файлы в
	    <filename>pkg-plist</filename> и устанавливать их в каталог
	    <filename>&dollar;LOCALBASE/share/applications</filename>.
	    Для установки этих файлов используется <link linkend="install-macros">макрос <varname>INSTALL_DATA</varname></link>.</para>
	</sect3>

	<sect3 xml:id="updating-desktop-database">
	  <title>Обновление базы данных рабочего стола</title>

	  <para>Если в файле порта
	    <filename>portname.desktop</filename>
	    имеется запись MimeType, то база данных рабочего стола
	    должна быть обновлена после установки и удаления.  Для
	    этого укажите
	    <varname>USES</varname>= desktop-file-utils.</para>
	</sect3>

	<sect3 xml:id="desktop-entries-macro">
	  <title>Создание элементов рабочего стола с использованием
	    <varname>DESKTOP_ENTRIES</varname></title>

	  <para>Элементы рабочего стола можно легко создавать для приложений,
	    используя переменную <varname>DESKTOP_ENTRIES</varname>.
	    Будет автоматически создан, установлен и добавлен в
	    <filename>pkg-plist</filename> файл с названием
	    <filename>name.desktop</filename>.
	    Синтаксис:</para>

	  <programlisting>DESKTOP_ENTRIES=  "NAME" "COMMENT" "ICON" "COMMAND" "CATEGORY" StartupNotify</programlisting>

	  <para>Перечень возможных категорий доступен на <link xlink:href="http://standards.freedesktop.org/menu-spec/latest/apa.html">
	    вебсайте Freedesktop</link>.  <varname>StartupNotify</varname>
	    отобразит, поддерживает ли приложение <emphasis>уведомления о
	    запуске</emphasis>.  Как правило, это графический индикатор часы
	    вместо указателя мыши, меню или панель, которые уведомляют
	    пользователя о загрузке программы.  Программа, поддерживающая
	    уведомления о запуске, очистит этот индикатор после запуска.
	    Программы, несовместимые с уведомлениями о запуске, не будут
	    очищать индикатор (возможно, вызывая путаницу и приводя
	    пользователей в бешенство), и поэтому должны иметь
	    <varname>StartupNotify</varname> в выключенном состоянии
	    <literal>false</literal>; тогда индикатор не будет отображаться
	    совсем.</para>

	  <para>Пример:</para>

	  <programlisting>DESKTOP_ENTRIES=  "ToME" "Roguelike game based on JRR Tolkien's work" \
                  "${DATADIR}/xtra/graf/tome-128.png" \
                  "tome -v -g" "Application;Game;RolePlaying;" \
                  false</programlisting>
	</sect3>
      </sect2>
    </sect1>

    <sect1 xml:id="using-gnome">
      <title>Использование GNOME</title>

      <para>Для задания того, какие компоненты GNOME использует конкретный
        порт, проект FreeBSD/GNOME использует собственный набор переменных.
        На странице проекта FreeBSD/GNOME
        размещён <link xlink:href="http://www.FreeBSD.org/gnome/docs/porting.html">
        исчерпывающий список этих переменных</link>.</para>

    </sect1>

    <sect1 xml:id="using-qt">
      <title>Использование Qt</title>

      <sect2 xml:id="qt-common">
	<title>Порты, для которых требуется Qt</title>

	<table frame="none">
	  <title>Переменные для портов, использующих Qt</title>

	  <tgroup cols="2">
	    <tbody>
	      <row>
		<entry><varname>USE_QT_VER</varname></entry>

		<entry>Порт использует инструментальный пакет Qt.
		  Единственным возможным значением является
		  <literal>3</literal>.  Соответствующие
		  параметры передаются в сценарий <command>configure</command>
		  и <command>make</command>.</entry>
	      </row>

	      <row>
		<entry><varname>USE_QT4</varname></entry>

		<entry>Указывает инструменты и библиотеки в качестве
		  зависимостей для портов, которые используют Qt 4.
		  Для получения подробностей смотрите <link linkend="qt4-components">выбор компонентов Qt
		    4</link>.</entry>
	      </row>

	      <row>
		<entry><varname>QT_PREFIX</varname></entry>

		<entry>Устанавливается в значение, содержащее путь к
		  установленному Qt (переменная только для чтения).</entry>
	      </row>

	      <row>
		<entry><varname>MOC</varname></entry>

		<entry>Устанавливается в значение, содержащее путь к
		  <command>moc</command> (переменная только для чтения).
		  По умолчанию устанавливается в соответствии со значением
		  <varname>USE_QT_VER</varname>.</entry>
	      </row>

	      <row>
		<entry><varname>QTCPPFLAGS</varname></entry>

		<entry>Дополнительные флаги компилятора для инструментального
		  пакета Qt, передаваемые через переменную
		  <varname>CONFIGURE_ENV</varname>.  По умолчанию
		  устанавливается в соответствии со значением
		  <varname>USE_QT_VER</varname>.</entry>
	      </row>

	      <row>
		<entry><varname>QTCFGLIBS</varname></entry>

		<entry>Дополнительные флаги компоновки для инструментального
		  пакета Qt, передаваемые через переменную
		  <varname>CONFIGURE_ENV</varname>.  По умолчанию
		  устанавливается в соответствии со значением
		  <varname>USE_QT_VER</varname>.</entry>
	      </row>

	      <row>
		<entry><varname>QTNONSTANDARD</varname></entry>

		<entry>Подавляет изменение <varname>CONFIGURE_ENV</varname>,
		  <varname>CONFIGURE_ARGS</varname>,
		  <varname>CPPFLAGS</varname> и
		  <varname>MAKE_ENV</varname>.</entry>
	      </row>

	    </tbody>
	  </tgroup>
	</table>

	<table frame="none">
	  <title>Дополнительные переменные для портов,
	    использующих Qt 4.x</title>

	  <tgroup cols="2">
	    <tbody>
	      <row>
		<entry><varname>UIC</varname></entry>

		<entry>Устанавливает путь к <command>uic</command>
		  (переменная только для чтения).</entry>
	      </row>

	      <row>
		<entry><varname>QMAKE</varname></entry>

		<entry>Устанавливает путь к <command>qmake</command>
		  (переменная только для чтения).</entry>
	      </row>

	      <row>
		<entry><varname>QMAKESPEC</varname></entry>

		<entry>Устанавливает путь к конфигурационному файлу для
		  <command>qmake</command> (переменная только для чтения).</entry>
	      </row>

	      <row>
		<entry><varname>QMAKEFLAGS</varname></entry>

		<entry>Дополнительные флаги для
		  <command>qmake</command>.</entry>
	      </row>

	      <row>
		<entry><varname>QT_INCDIR</varname></entry>

		<entry>Устанавливает каталоги для заголовков Qt 4
		  (переменная только для чтения).</entry>
	      </row>

	      <row>
		<entry><varname>QT_LIBDIR</varname></entry>

		<entry>Устанавливает путь к библиотекам Qt 4
		  (переменная только для чтения).</entry>
	      </row>

	      <row>
		<entry><varname>QT_PLUGINDIRC</varname></entry>

		<entry>Устанавливает путь к плагинам Qt 4
		  (переменная только для чтения).</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>Когда переменная <varname>USE_QT_VER</varname> определена
	  со значением <literal>3</literal>,
	  сценарию <command>configure</command> можно передавать некоторые
	  полезные настройки:</para>

	<programlisting>CONFIGURE_ARGS+= --with-qt-includes=${QT_PREFIX}/include \
                 --with-qt-libraries=${QT_PREFIX}/lib \
                 --with-extra-libs=${LOCALBASE}/lib \
                 --with-extra-includes=${LOCALBASE}/include
CONFIGURE_ENV+=  MOC="${MOC}" LIBS="${QTCFGLIBS}" \
                 QTDIR="${QT_PREFIX}" KDEDIR="${KDE_PREFIX}"
CPPFLAGS+=       ${QTCPPFLAGS}</programlisting>

	<para>При заданной переменной <varname>USE_QT4</varname>
	  применяются следующие настройки:</para>

	<programlisting>CONFIGURE_ARGS+=	--with-qt-includes=${QT_INCDIR} \
			--with-qt-libraries=${QT_LIBDIR} \
			--with-extra-libs=${LOCALBASE}/lib \
			--with-extra-includes=${LOCALBASE}/include
CONFIGURE_ENV+=	MOC="${MOC}" UIC="${UIC}" LIBS="${QTCFGLIBS}" \
		QMAKE="${QMAKE}" QMAKESPEC="${QMAKESPEC}" QTDIR="${QT_PREFIX}"
MAKE_ENV+=	QMAKESPEC="${QMAKESPEC}"

PLIST_SUB+=	QT_INCDIR_REL=${QT_INCDIR_REL} \
		QT_LIBDIR_REL=${QT_LIBDIR_REL} \
		QT_PLUGINDIR_REL=${QT_PLUGINDIR_REL}</programlisting>
      </sect2>

      <sect2 xml:id="qt4-components">
	<title>Выбор компонентов (только для Qt 4.x)</title>

	<para>В переменной <varname>USE_QT4</varname> должны указываться
	  зависимости от отдельных инструментов и библиотек Qt 4.  К каждому
	  компоненту можно добавить суффикс, <literal>_build</literal>
	  или <literal>_run</literal>, отражающий, когда должна быть применена
	  зависимость, во время сборки или выполнения, соответственно.  Если
	  суффикс отсутствует, зависимость от компонента будет и для времени
	  сборки, и для времени выполнения.  Обычно, компоненты библиотек
	  должны указываться без суффиксов, компоненты инструментов - с
	  суффиксом <literal>_build</literal>, а компоненты плагинов - с
	  суффиксом <literal>_run</literal>.  Наиболее общие используемые
	  компоненты перечислены ниже (все доступные компоненты перечислены
	  в <varname>_USE_QT4_ALL</varname> в файле
	  <filename>/usr/ports/Mk/bsd.qt.mk</filename>):</para>

	<table frame="none">
	  <title>Доступные библиотечные компоненты Qt 4</title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Название</entry>
		<entry>Описание</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><literal>corelib</literal></entry>
		<entry>основная библиотека (можно опустить, если порт не
		  использует ничего, кроме <literal>corelib</literal>)</entry>
	      </row>

	      <row>
		<entry><literal>gui</literal></entry>
		<entry>библиотека графического пользовательского
		  интерфейса</entry>
	      </row>

	      <row>
		<entry><literal>network</literal></entry>
		<entry>сетевая библиотека</entry>
	      </row>

	      <row>
		<entry><literal>opengl</literal></entry>
		<entry>библиотека OpenGL</entry>
	      </row>

	      <row>
		<entry><literal>qt3support</literal></entry>
		<entry>библиотека совместимости с Qt 3</entry>
	      </row>

	      <row>
		<entry><literal>qtestlib</literal></entry>
		<entry>библиотека модульного тестирования</entry>
	      </row>

	      <row>
		<entry><literal>script</literal></entry>
		<entry>библиотека сценариев</entry>
	      </row>

	      <row>
		<entry><literal>sql</literal></entry>
		<entry>библиотека SQL</entry>
	      </row>

	      <row>
		<entry><literal>xml</literal></entry>
		<entry>библиотека XML</entry>
	      </row>

	    </tbody>
	  </tgroup>
	</table>

	<para>Вы можете определить, от каких библиотек зависит приложение,
	  запустив <command>ldd</command> на основной исполняемый файл
	  после успешной компиляции.</para>

	<table frame="none">
	  <title>Доступные компоненты инструментов Qt 4</title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Название</entry>
		<entry>Описание</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><literal>moc</literal></entry>
		<entry>мета-объектный компилятор (нужен при построении
		  почти для каждого приложения Qt)</entry>
	      </row>

	      <row>
		<entry><literal>qmake</literal></entry>
		<entry>генератор Makefile / утилита построения</entry>
	      </row>

	      <row>
		<entry><literal>rcc</literal></entry>
		<entry>компилятор ресурсов (нужен, если приложение
		  идет вместе с файлами <filename>*.rc</filename> или
		  <filename>*.qrc</filename>)</entry>
	      </row>

	      <row>
		<entry><literal>uic</literal></entry>
		<entry>компилятор пользовательского интерфейса (нужен, если
		  приложение идет вместе с файлами <filename>*.ui</filename>,
		  созданными при помощи Qt Designer, - на практике каждое
		  приложение Qt с GUI)</entry>
	      </row>

	    </tbody>
	  </tgroup>
	</table>

	<table frame="none">
	  <title>Доступные компоненты плагинов Qt 4</title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Название</entry>
		<entry>Описание</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><literal>iconengines</literal></entry>
		<entry>плагин для движка иконок SVG (если приложение
		  поставляется с иконками SVG)</entry>
	      </row>

	      <row>
		<entry><literal>imageformats</literal></entry>
		<entry>плагины для графических форматов GIF, JPEG, MNG и SVG
		  (если приложение поставляется с графическими файлами)</entry>
	      </row>

	    </tbody>
	  </tgroup>
	</table>

	<example xml:id="qt4-components-example">
	  <title>Выбор компонентов Qt 4</title>

	  <para>В этом примере портированное приложение использует библиотеку
	    графического пользовательского интерфейса Qt 4, основную библиотеку
	    Qt 4, все инструменты генерации кода Qt 4 и генератор Makefile Qt 4.
	    Поскольку библиотека <literal>gui</literal> подразумевает
	    зависимость от основной библиотеки, указывать
	    <literal>corelib</literal> нет необходимости.  Инструменты
	    генерации кода Qt 4 <literal>moc</literal>, <literal>uic</literal>
	    и <literal>rcc</literal>, а также генератор Makefile
	    <literal>qmake</literal> нужны только для времени построения,
	    поэтому они указаны с суффиксом <literal>_build</literal>:</para>

	  <programlisting>USE_QT4=	gui moc_build qmake_build rcc_build uic_build</programlisting>
	</example>
      </sect2>

      <sect2 xml:id="qt-additional">
	<title>Прочие соображения</title>

	<para>Если вместе с приложением вместо <filename>configure</filename>
	  поставляется файл <filename>.pro</filename>, вы можете использовать
	  следующее:</para>

	<programlisting>HAS_CONFIGURE=	yes

do-configure:
        @cd ${WRKSRC} &amp;&amp; ${SETENV} ${CONFIGURE_ENV} \
                ${QMAKE} ${QMAKEFLAGS} PREFIX=${PREFIX} texmaker.pro</programlisting>

	<para>Обратите внимание на сходство со строкой <command>qmake</command>
	  из прилагаемого сценария <filename>BUILD.sh</filename>.  Передача
	  <varname>CONFIGURE_ENV</varname> обеспечивает видимость переменной
	  <varname>QMAKESPEC</varname> для <command>qmake</command>, без
	  которой команда не может работать. <command>qmake</command>
	  порождает стандартные Makefile, и, таким образом, отпадает
	  необходимость в написании своих собственных целей
	  <buildtarget>build</buildtarget>.</para>

	<para>Приложения Qt часто пишутся в кроссплатформенной манере, и
	  X11/Unix часто не является для них платформой разработки, что в
	  свою очередь часто приводит к соответствующим упущенным
	  моментам:</para>

	<itemizedlist>
	  <listitem>
	    <para><emphasis>Отсутствующие дополнительные пути для
	      заголовочных файлов.</emphasis>  Многие приложения идут с
	      поддержкой иконки в системном трее, но пренебрегают смотреть
	      на наличие заголовочных файлов и/или библиотеками в каталогах
	      X11.  Вы можете сообщить <command>qmake</command>, чтобы она
	      добавила каталоги в пути поиска заголовочных файлов и библиотек
	      через командную строку.  К примеру:</para>

	    <programlisting>${QMAKE} ${QMAKEFLAGS} PREFIX=${PREFIX} INCLUDEPATH+=${LOCALBASE}/include \
	LIBS+=-L${LOCALBASE}/lib sillyapp.pro</programlisting>
	  </listitem>

	  <listitem>
	    <para><emphasis>Фиктивные пути установки.</emphasis>
	      Иногда данные, такие как иконки и файлы .desktop,
	      устанавливаются по умолчанию в каталоги, которые не
	      просматриваются XDG-совместимыми приложениями.  Примером
	      является <package>editors/texmaker</package> -
	      взгляните на <filename>patch-texmaker.pro</filename> из каталога
	      <filename>files</filename> этого порта, который можно взять
	      в качестве шаблона исправления этого непосредственно в файле
	      проекта <command>qmake</command>.</para>
	  </listitem>
	</itemizedlist>

      </sect2>

    </sect1>

    <sect1 xml:id="using-kde">
      <title>Использование KDE</title>

      <sect2 xml:id="kde4-variables">
	<title>Задание переменных KDE 4</title>

	<para>Если ваше приложение зависит от KDE 4.x, присвойте
	  <varname>USE_KDE4</varname> список требуемых компонентов.
	  Для переопределения типа зависимости компонента могут быть
	  использованы суффиксы <literal>_build</literal> и
	  <literal>_run</literal> (например, <literal>baseapps_run</literal>).
	  Если суффикс не задан, будет использован тип зависимости по
	  умолчанию.  Если вы хотите использовать оба типа, добавьте
	  компонент дважды с обоими суффиксами (например,
	  <literal>automoc4_build automoc4_run</literal>).  Основные
	  наиболее используемые компоненты перечислены ниже (актуальные
	  компоненты задокументированы в начале файла
	  <filename>/usr/ports/Mk/bsd.kde4.mk</filename>):</para>

	<table frame="none">
	  <title>Доступные компоненты KDE 4</title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Название</entry>
		<entry>Описание</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><literal>kdehier</literal></entry>
		<entry>Иерархия основных каталогов KDE</entry>
	      </row>

	      <row>
		<entry><literal>kdelibs</literal></entry>
		<entry>KDE Developer Platform</entry>
	      </row>

	      <row>
		<entry><literal>kdeprefix</literal></entry>
		<entry>Если установлено, то порт будет установлен в
		  <literal>&dollar;{KDE4_PREFIX}</literal> вместо
		  <literal>&dollar;{LOCALBASE}</literal></entry>
	      </row>

	      <row>
		<entry><literal>sharedmime</literal></entry>
		<entry>База данных MIME типов для портов KDE</entry>
	      </row>

	      <row>
		<entry><literal>automoc4</literal></entry>
		<entry>automoc для пакетов Qt 4</entry>
	      </row>

	      <row>
		<entry><literal>akonadi</literal></entry>
		<entry>Сервер хранения KDE-Pim</entry>
	      </row>

	      <row>
		<entry><literal>soprano</literal></entry>
		<entry>Фреймворк Qt 4 RDF</entry>
	      </row>

	      <row>
		<entry><literal>strigi</literal></entry>
		<entry>Поисковые даемон рабочего стола</entry>
	      </row>

	      <row>
		<entry><literal>libkcddb</literal></entry>
		<entry>Библиотека KDE CDDB</entry>
	      </row>

	      <row>
		<entry><literal>libkcompactdisc</literal></entry>
		<entry>Библиотека KDE для взаимодействия с аудио-CD</entry>
	      </row>

	      <row>
		<entry><literal>libkdeedu</literal></entry>
		<entry>Библиотеки, используемые для образовательных
		  приложений</entry>
	      </row>

	      <row>
		<entry><literal>libkdcraw</literal></entry>
		<entry>Библиотека KDE LibRaw</entry>
	      </row>

	      <row>
		<entry><literal>libkexiv2</literal></entry>
		<entry>Библиотека KDE Exiv2</entry>
	      </row>

	      <row>
		<entry><literal>libkipi</literal></entry>
		<entry> KDE Image Plugin Interface</entry>
	      </row>

	      <row>
		<entry><literal>libkonq</literal></entry>
		<entry>Основная библиотека Konqueror</entry>
	      </row>

	      <row>
		<entry><literal>libksane</literal></entry>
		<entry>Библиотека KDE SANE ("Scanner Access Now
		  Easy")</entry>
	      </row>

	      <row>
		<entry><literal>pimlibs</literal></entry>
		<entry>Библиотеки KDE-Pim</entry>
	      </row>

	      <row>
		<entry><literal>kate</literal></entry>
		<entry>Тектовый редактор</entry>
	      </row>

	      <row>
		<entry><literal>marble</literal></entry>
		<entry>Виртуальный глобус</entry>
	      </row>

	      <row>
		<entry><literal>okular</literal></entry>
		<entry>Универсальный просмотрщик документов</entry>
	      </row>

	      <row>
		<entry><literal>korundum</literal></entry>
		<entry>Привязка Ruby к KDE</entry>
	      </row>

	      <row>
		<entry><literal>perlkde</literal></entry>
		<entry>Привязка Perl к KDE</entry>
	      </row>

	      <row>
		<entry><literal>pykde4</literal></entry>
		<entry>Привязка Python к KDE</entry>
	      </row>

	      <row>
		<entry><literal>pykdeuic4</literal></entry>
		<entry>Компилятор пользовательского интерфейса PyKDE</entry>
	      </row>

	      <row>
		<entry>smokekde<literal/></entry>
		<entry>Библиотеки KDE SMOKE</entry>
	      </row>

	    </tbody>
	  </tgroup>
	</table>

	<para>Порты KDE 4.x
	  устанавливаются в <varname>KDE4_PREFIX</varname>, что в
	  настоящее время соответствует <filename>/usr/local/kde4</filename>.
	  Это достигается путем указания компонента <literal>kdeprefix</literal>,
	  который определяет значение по умолчанию для <varname>PREFIX</varname>.
	  Тем не менее, порты учитывают любые <varname>PREFIX</varname>,
	  установленные через переменную окружения <envar>MAKEFLAGS</envar>
	  и/или параметры <command>make</command>.</para>

	<example xml:id="kde4-components-example">
	  <title>Пример <varname>USE_KDE4</varname></title>

	  <para>Это простой пример для порта KDE 4.
	    <literal>USES= cmake:outsource</literal> указывает порту
	    использовать <application>CMake</application>, конфигурационный
	    инструмент, широко применяемый в проектах KDE 4 (подробное
	    описание даёт <xref linkend="using-cmake"/>).
	    <varname>USE_KDE4</varname> добавляет зависимость от библиотек KDE
	    и заставляет порты использовать <command>automoc4</command>
	    во время сборки.  Требуемые компоненты KDE и другие зависимости
	    можно определить в журнале configure.  <varname>USE_KDE4</varname>
	    не подразумевает <varname>USE_QT4</varname>.  Если порт требует
	    какой-либо из компонентов Qt 4, их следует указать в
	    <varname>USE_QT4</varname>.</para>

	  <programlisting>USES=		cmake:outsource
USE_KDE4=	kdelibs kdeprefix automoc4
USE_QT4=	moc_build qmake_build rcc_build uic_build</programlisting>
	</example>
      </sect2>

    </sect1>

    <sect1 xml:id="using-java">
      <title>Использование Java</title>

      <sect2 xml:id="java-variables">
        <title>Задание переменных</title>

        <para>Если вашему порту необходимо наличие Java&trade; Development Kit
          (JDK&trade;) для построения, работы или даже распаковки
	  дистрибутивного файла, то в нём должна быть задана переменная
          <varname>USE_JAVA</varname>.</para>

        <para>В Коллекции Портов присутствуют несколько JDK различных
          разработчиков и разных версий.  Если ваш порт должен использовать
          одну из этих версий, то вы должны указать, какую именно.  Самой
          последней версией и версией по умолчанию является <package>java/openjdk6</package>.</para>

        <table frame="none">
	  <title>Переменные, которые которые могут задаваться портами,
            использующими Java</title>

	  <tgroup cols="2">
	    <thead>
	      <row>
	        <entry>Переменная</entry>

	        <entry>Значение</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
	        <entry><varname>USE_JAVA</varname></entry>

	        <entry>Должна быть определена для того, что последующие
                  переменные вступили в действие.</entry>
	      </row>

	      <row>
	        <entry><varname>JAVA_VERSION</varname></entry>
	        <entry>Список версий Java, перечисленных через пробел,
                  подходящих для порта.  Опциональный знак
                  <literal>"+"</literal> позволяет вам указать диапазон
                  версий (возможные значения:
		  <literal>1.5[+] 1.6[+] 1.7[+]
		  </literal>).</entry>
	      </row>

	      <row>
	        <entry><varname>JAVA_OS</varname></entry>
	        <entry>Список операционных систем, перечисленных через пробел,
                  порты JDK для которых подходят для порта (возможные значения:
                  <literal>native	linux</literal>).</entry>
	      </row>

	      <row>
	        <entry><varname>JAVA_VENDOR</varname></entry>
	        <entry>Список разработчиков портов JDK, перечисленных через
                  пробел, которые подходят для порта (возможные значения:
                  <literal>freebsd bsdjava sun
		  openjdk</literal>).</entry>
	      </row>

	      <row>
	        <entry><varname>JAVA_BUILD</varname></entry>
	        <entry>Если задана, то означает, что выбранный порт JDK должен
                  быть добавлен к зависимостям порта для его
                  построения.</entry>
	      </row>

	      <row>
	        <entry><varname>JAVA_RUN</varname></entry>
	        <entry>Если задана, то означает, что выбранный порт JDK должен
                  быть добавлен в зависимостям порта для его работы.</entry>
	      </row>

	      <row>
	        <entry><varname>JAVA_EXTRACT</varname></entry>
	        <entry>Если задана, то означает, что выбранный порт JDK должен
                  быть добавлен в зависимостям порта для распаковки его
                  дистрибутивных файлов.</entry>
	      </row>
	    </tbody>
	  </tgroup>
        </table>

        <para>Ниже перечисляются все значения, которые принимают переменные
          после задания переменной <varname>USE_JAVA</varname>:</para>

        <table frame="none">
	  <title>Переменные, доступные в портах, использующих Java</title>

	  <tgroup cols="2">
	    <thead>
	      <row>
	        <entry>Переменная</entry>

	        <entry>Значение</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
	        <entry><varname>JAVA_PORT</varname></entry>
	        <entry>Название порта JDK (к примеру,
		  <literal>'java/openjdk6'</literal>).</entry>
	      </row>

	      <row>
	        <entry><varname>JAVA_PORT_VERSION</varname></entry>
	        <entry>Полное наименовании версии порта JDK (к примеру,
		  <literal>'1.6.0'</literal>).  Если вам нужны только первые
                  две цифры номера версии, используйте конструкцию
		  <varname>${JAVA_PORT_VERSION:C/^([0-9])\.([0-9])(.*)$/\1.\2/}</varname>.</entry>
	      </row>

	      <row>
	        <entry><varname>JAVA_PORT_OS</varname></entry>
	        <entry>Операционная система, используемая портом JDK (к примеру,
		  <literal>'native'</literal>).</entry>
	      </row>

	      <row>
	        <entry><varname>JAVA_PORT_VENDOR</varname></entry>
	        <entry>Разработчик порта JDK (к примеру,
		  <literal>'openjdk'</literal>).</entry>
	      </row>

	      <row>
	        <entry><varname>JAVA_PORT_OS_DESCRIPTION</varname></entry>
	        <entry>Описание операционной системы, используемой портом JDK
                  (к примеру, <literal>'Native'</literal>).</entry>
	      </row>

	      <row>
	        <entry><varname>JAVA_PORT_VENDOR_DESCRIPTION</varname></entry>
	        <entry>Описание разработчика порта JDK (к примеру,
		  <literal>'OpenJDK BSD Porting Team'</literal>).</entry>
	      </row>

	      <row>
	        <entry><varname>JAVA_HOME</varname></entry>
	        <entry>Маршрут к установочному каталогу JDK (к примеру,
		  <filename>'/usr/local/openjdk6'</filename>).</entry>
	      </row>

	      <row>
	        <entry><varname>JAVAC</varname></entry>
	        <entry>Маршрут к используемому компилятору Java (к примеру,
		  <filename>'/usr/local/openjdk6/bin/javac'</filename>.
		  </entry>
	      </row>

	      <row>
	        <entry><varname>JAR</varname></entry>
	        <entry>Маршрут к используемой утилите <command>jar</command> (к
		  примеру, <filename>'/usr/local/openjdk6/bin/jar'</filename>
                  или <filename>'/usr/local/bin/fastjar'</filename>).</entry>
	      </row>

	      <row>
	        <entry><varname>APPLETVIEWER</varname></entry>
	        <entry>Маршрут к утилите <command>appletviewer</command> (к
                  примеру,
		  <filename>'/usr/local/openjdk6/bin/appletviewer'</filename>).
                </entry>
	      </row>

	      <row>
	        <entry><varname>JAVA</varname></entry>
	        <entry>Маршрут к выполняемому файлу <command>java</command>.
                  Используйте его для запуска Java-программ (к примеру,
		  <filename>'/usr/local/openjdk6/bin/java'</filename>).</entry>
	      </row>

	      <row>
	        <entry><varname>JAVADOC</varname></entry>
	        <entry>Маршрут к вспомогательной программе
                  <command>javadoc</command>.</entry>
	      </row>

	      <row>
	        <entry><varname>JAVAH</varname></entry>
	        <entry>Маршрут к программе <command>javah</command>.</entry>
	      </row>

	      <row>
	        <entry><varname>JAVAP</varname></entry>
	        <entry>Маршрут к программе <command>javap</command>.</entry>
	      </row>

	      <row>
	        <entry><varname>JAVA_KEYTOOL</varname></entry>
	        <entry>Маршрут к вспомогательной программе
                  <command>keytool</command>.</entry>
	      </row>

	      <row>
	        <entry><varname>JAVA_N2A</varname></entry>
	        <entry>Маршрут к утилите
                  <command>native2ascii</command>.</entry>
	      </row>

	      <row>
	        <entry><varname>JAVA_POLICYTOOL</varname></entry>
	        <entry>Маршрут к программе <command>policytool</command>.</entry>
	      </row>

	      <row>
	        <entry><varname>JAVA_SERIALVER</varname></entry>
	        <entry>Маршрут к вспомогательной программе
                  <command>serialver</command>.</entry>
	      </row>

	      <row>
	        <entry><varname>RMIC</varname></entry>
	        <entry>Маршрут к генератору каркаса программ RMI, утилите
		  <command>rmic</command>.</entry>
	      </row>

	      <row>
	        <entry><varname>RMIREGISTRY</varname></entry>
	        <entry>Маршрут к программе регистрации RMI,
		  <command>rmiregistry</command>.</entry>
	      </row>

	      <row>
	        <entry><varname>RMID</varname></entry>
	        <entry>Маршрут к программе-даемону RMI
		  <command>rmid</command>.</entry>
	      </row>

	      <row>
	        <entry><varname>JAVA_CLASSES</varname></entry>
	        <entry>Маршрут к архиву, который содержит файлы классов JDK,
		  <filename>${JAVA_HOME}/jre/lib/rt.jar</filename>.</entry>
	      </row>
	    </tbody>
	  </tgroup>
        </table>

        <para>Вы можете воспользоваться make-целью
          <literal>java-debug</literal> для получения информации, необходимой
          для отладки вашего порта.  При её выполнении будут выданы значения
          многих упомянутых выше переменных.</para>

        <para>Кроме того, для единообразия установки всех портов Java
          определены следующие константы:</para>

        <table frame="none">
          <title>Константы, определённые для портов, использующих Java</title>

          <tgroup cols="2">
            <thead>
              <row>
                <entry>Константа</entry>

                <entry>Значение</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><varname>JAVASHAREDIR</varname></entry>
                <entry>Корневой каталог для всего, что связано с Java.
                  По умолчанию: <filename>${PREFIX}/share/java</filename>.
                </entry>
              </row>

              <row>
                <entry><varname>JAVAJARDIR</varname></entry>
                <entry>Каталог, в который должны устанавливаться JAR-файлы.  По
                  умолчанию:
                  <filename>${JAVASHAREDIR}/classes</filename>.</entry>
              </row>

	      <row>
		<entry><varname>JAVALIBDIR</varname></entry>
		<entry>Каталог, в который устанавливаются JAR-файлы из
		  других портов. По умолчанию:
		  <filename>${LOCALBASE}/share/java/classes</filename>.</entry>
	      </row>
            </tbody>
          </tgroup>
        </table>

      <para>Соответствующие записи определяются в обоих переменных
	<varname>PLIST_SUB</varname> (описана в <xref linkend="plist-sub"/>) и <varname>SUB_LIST</varname>.</para>

      </sect2>

      <sect2 xml:id="java-building-with-ant">
	<title>Построение с Ant</title>

	<para>Если построение порта производится с использованием Apache Ant,
	  то необходимо определить <varname>USE_ANT</varname>.  Таким образом
	  Ant становится подкомандой make.  Если в порте не определена цель
	  <literal>do-build</literal>, то будет установлена цель по умолчанию,
	  которая просто запускает Ant в соответствии со значением
	  <varname>MAKE_ENV</varname>, <varname>MAKE_ARGS</varname> и
	  <varname>ALL_TARGET</varname>.  Это похоже на механизм
	  <varname>USES= gmake</varname>, который описан в
	  <xref linkend="building"/>.</para>

      </sect2>

      <sect2 xml:id="java-best-practices">
        <title>Практические рекомендации</title>

        <para>При портировании Java-библиотеки ваш порт должен
          устанавливать JAR-файл(ы) в каталог
          <filename>${JAVAJARDIR}</filename>, а все остальные данные в каталог
          <filename>${JAVASHAREDIR}/${PORTNAME}</filename> (за исключением
          документации, о которой пойдёт речь ниже).  Для уменьшения размера
          упакованного файла вы можете сослаться на JAR-файл(ы) непосредственно
          в файле <filename>Makefile</filename>.  Просто воспользуйтесь
          следующей директивой (в которой <filename>myport.jar</filename>
          является именем JAR-файла, устанавливаемого как часть порта):</para>

	<programlisting>PLIST_FILES+= %%JAVAJARDIR%%/myport.jar</programlisting>

        <para>При портировании Java-приложения порт обычно устанавливает всё
          в один каталог (в том числе все свои JAR-зависимости).  В этом
          отношении настоятельно рекомендуется использование
          <filename>${JAVASHAREDIR}/${PORTNAME}</filename>.  На усмотрение
          создателя порта остаётся решение вопроса о том, устанавливать ли
          дополнительные JAR-зависимости в этот каталог или напрямую
          использовать уже установленные (из каталога
          <filename>${JAVAJARDIR}</filename>).</para>

        <para>Вне зависимости от типа вашего порта (библиотека это или
          приложение), дополнительная документация должна быть устанавливаться
          <link linkend="install-documentation">в тоже самое место</link>, что
	  и для других портов.  Известно, что в зависимости от используемой
          версии JDK утилита JavaDoc генерирует различные наборы файлов.  Для
          портов, которые не привязаны к использованию определённой версии
          JDK, таким образом становится проблематичным определить список файлов
          для упаковки (<filename>pkg-plist</filename>).  Это одна из причин,
          по которой создателям портов настоятельно рекомендуется использовать
          макрос <varname>PORTDOCS</varname>.  Более того, даже если вы сможете
          угадать набор файлов, который будет сгенерирован утилитой
          <command>javadoc</command>, размер получающегося файла
          <filename>pkg-plist</filename> голосует за использование
          <varname>PORTDOCS</varname>.</para>

        <para>Значением по умолчанию для переменной <varname>DATADIR</varname>
          является <filename>${PREFIX}/share/${PORTNAME}</filename>.  Хорошей
          идеей является переопределение для Java-портов значения
          <varname>DATADIR</varname> как
          <filename>${JAVASHAREDIR}/${PORTNAME}</filename>.  На самом деле
          <varname>DATADIR</varname> автоматически добавляется к
          <varname>PLIST_SUB</varname> (это описано в <xref linkend="plist-sub"/>), так что вы сможете
          использовать <literal>%%DATADIR%%</literal> непосредственно в
          <filename>pkg-plist</filename>.</para>

        <para>Что касается выбора между построением портов Java из исходных
          текстов или их прямой установкой из бинарных дистрибутивов, то на
          момент создания этого текста определённой политики на этот счёт не
          существует.  Однако участники <link xlink:href="http://www.freebsd.org/java/">Проекта &os; Java</link>
          рекомендуют создателям портов строить их из исходных текстов, если
          эта задача является несложной.</para>

        <para>Все возможности, которые были описаны в этом разделе, реализованы
          в файле <filename>bsd.java.mk</filename>.  Если вы предположите, что
          вашему порту требуется менее тривиальная поддержка Java, пожалуйста,
          взгляните сначала на <link xlink:href="http://svnweb.FreeBSD.org/ports/head/Mk/bsd.java.mk?view=markup">журнал
	  изменений bsd.java.mk в SVN</link>, так как для
          документирования последних изменений требуется какое-то время.
          Затем, если вы думаете, что не хватающая вам поддержка окажется
          полезной для многих других портов Java, обсудите ваш вопрос в
          &a.java;.</para>

        <para>Хотя в базе сообщений об ошибках для соответствующих PR имеется
          категория <literal>java</literal>, она относится к работе над
          портированием JDK, которые проводит Проект &os; Java.  Таким образом,
          вы должны относить свой Java-порт, как и любой другой, к категории
          <literal>ports</literal>, если решаемый вами вопрос не относится ни
          к реализации JDK, ни к <filename>bsd.java.mk</filename>.</para>

	<para>Похожим образом определена политика по отношению к
	  <varname>CATEGORIES</varname> порта Java, которая подробно описана
	  в <xref linkend="makefile-categories"/>.</para>

      </sect2>
    </sect1>

    <sect1 xml:id="using-php">
      <title>Веб-приложения, Apache и PHP</title>

      <sect2 xml:id="using-apache">
	<title>Apache</title>

	<table frame="none">
	  <title>Переменные для портов, использующих Apache</title>

	  <tgroup cols="2">
	    <tbody>

	      <row>
		<entry><varname>USE_APACHE</varname></entry>

		<entry>Порт требует Apache.  Возможные значения:
		  <literal>yes</literal> (берёт любую версию),
		  <literal>22</literal>, <literal>24</literal>,
		  <literal>22-24</literal>, <literal>22+</literal>
		  и так далее.  Версия по умолчанию
		  <literal>22</literal>.  Более подробная информация
		  содержится в файле
		  <filename>ports/Mk/bsd.apache.mk</filename> и на
		  странице <link xlink:href="http://wiki.freebsd.org/Apache/">
		  wiki.freebsd.org/Apache/</link>.</entry>
	      </row>

	      <row>
		<entry><varname>APXS</varname></entry>

		<entry>Полный путь к исполняемому файлу <command>apxs</command>.
		  Может быть переопределен в вашем порту.</entry>
	      </row>

	      <row>
		<entry><varname>HTTPD</varname></entry>

		<entry>Полный путь к исполняемому файлу <command>httpd</command>.
		  Может быть переопределен в вашем порту.</entry>
	      </row>

	      <row>
		<entry><varname>APACHE_VERSION</varname></entry>

		<entry>Версия установленного Apache (переменная только для
		  чтения).  Эта переменная доступна только после подключения
		  <filename>bsd.port.pre.mk</filename>.  Возможные значения:
		  <literal>22</literal>, <literal>24</literal>.</entry>
	      </row>

	      <row>
		<entry><varname>APACHEMODDIR</varname></entry>

		<entry>Каталог для модулей Apache.  Значение переменной
		  автоматически подставляется в <filename>pkg-plist</filename>.</entry>
	      </row>

	      <row>
		<entry><varname>APACHEINCLUDEDIR</varname></entry>

		<entry>Каталог для заголовков Apache.  Значение переменной
		  автоматически подставляется в <filename>pkg-plist</filename>.</entry>
	      </row>

	      <row>
		<entry><varname>APACHEETCDIR</varname></entry>

		<entry>Каталог для конфигурационных файлов Apache.  Значение
		  переменной автоматически подставляется в
		  <filename>pkg-plist</filename>.</entry>
	      </row>

	    </tbody>
	  </tgroup>
	</table>

	<table frame="none">
	  <title>Используемые переменные при портировании модулей
	    Apache</title>

	  <tgroup cols="2">
	    <tbody>

	      <row>
		<entry><varname>MODULENAME</varname></entry>

		<entry>Название модуля.  Значением по умолчанию является
		  <varname>PORTNAME</varname>.  Пример:
		  <literal>mod_hello</literal></entry>
	      </row>

	      <row>
		<entry><varname>SHORTMODNAME</varname></entry>

		<entry>Краткое название модуля.  Наследуется автоматически
		  от <varname>MODULENAME</varname>, но может быть
		  переопределено.  Пример: <literal>hello</literal></entry>
	      </row>

	      <row>
		<entry><varname>AP_FAST_BUILD</varname></entry>

		<entry>Использовать <command>apxs</command> для компиляции
		  и установки модуля.</entry>
	      </row>

	      <row>
		<entry><varname>AP_GENPLIST</varname></entry>

		<entry>Также автоматически создает
		  <filename>pkg-plist</filename>.</entry>
	      </row>

	      <row>
		<entry><varname>AP_INC</varname></entry>

		<entry>Добавляет каталог к пути поиска заголовков
		  во время компиляции.</entry>
	      </row>

	      <row>
		<entry><varname>AP_LIB</varname></entry>

		<entry>Добавляет каталог к пути поиска библиотек
		  во время компиляции.</entry>
	      </row>

	      <row>
		<entry><varname>AP_EXTRAS</varname></entry>

		<entry>Дополнительные флаги, передаваемые
		  <command>apxs</command>.</entry>
	      </row>

	    </tbody>
	  </tgroup>
	</table>
      </sect2>

      <sect2 xml:id="web-apps">
	<title>Веб-приложения</title>

	<para>Веб-приложения следует устанавливать в
	  <filename>PREFIX/www/appname</filename>.
	  Для вашего удобства этот путь одинаково доступен в
	  <filename>Makefile</filename> и <filename>pkg-plist</filename>
	  как переменная <varname>WWWDIR</varname>, а путь относительно
	  <varname>PREFIX</varname> доступен в <filename>Makefile</filename>
	  как <varname>WWWDIR_REL</varname>.</para>

	<para>Пользователь и группа процесса веб-сервера доступны как
	  <varname>WWWOWN</varname> и <varname>WWWGRP</varname>, в случае
	  если вам нужно изменить владельца для некоторых файлов.  Значением
	  по умолчанию и для владельца, и для группы является
	  <literal>www</literal>.  Если вы хотите использовать в вашем
	  порте другие значения, воспользуйтесь для этого нотацией
	  <literal>WWWOWN?= myuser</literal>, чтобы позволить
	  пользователю легко переопределить их.</para>

	<para>Не добавляйте зависимость от Apache, если веб-приложение
	  явным образом не нуждается в Apache.  Учитывайте, что пользователи
	  могут пожелать запустить ваше веб-приложение на другом веб-сервере
	  помимо Apache.</para>

      </sect2>

      <sect2 xml:id="php-variables">
	<title>PHP</title>

	<table frame="none">
	  <title>Переменные для портов, использующих PHP</title>

	  <tgroup cols="2">
	    <tbody>
	      <row>
		<entry><varname>USE_PHP</varname></entry>

		<entry>Порт требует PHP.  Значение <literal>yes</literal>
		  добавляет зависимость от PHP.  Вместо этого может быть
		  указан перечень требуемых расширений PHP.  Пример:
		  <literal>pcre xml gettext</literal></entry>
	      </row>

	      <row>
		<entry><varname>DEFAULT_PHP_VER</varname></entry>

		<entry>Выбирает старший номер версии, с которым будет
		  установлен PHP как зависимость в случае, когда PHP еще
		  не установлен.  По умолчанию <literal>5</literal>.
		  Возможные значения: <literal>4</literal>,
		  <literal>5</literal></entry>
	      </row>

	      <row>
		<entry><varname>IGNORE_WITH_PHP</varname></entry>

		<entry>Порт не работает с PHP данной версии.  Возможные
		  значения: <literal>4</literal>, <literal>5</literal></entry>
	      </row>

	      <row>
		<entry><varname>USE_PHPIZE</varname></entry>

		<entry>Порт будет построен как расширение PHP.</entry>
	      </row>

	      <row>
		<entry><varname>USE_PHPEXT</varname></entry>

		<entry>Порт будет считаться расширением PHP, включая установку
		  и регистрацию в реестре расширений.</entry>
	      </row>

	      <row>
		<entry><varname>USE_PHP_BUILD</varname></entry>

		<entry>Установить PHP как зависимость времени построения.</entry>
	      </row>

	      <row>
		<entry><varname>WANT_PHP_CLI</varname></entry>

		<entry>Хочет CLI (командная строка) версию PHP.</entry>
	      </row>

	      <row>
		<entry><varname>WANT_PHP_CGI</varname></entry>

		<entry>Хочет CGI версию PHP.</entry>
	      </row>

	      <row>
		<entry><varname>WANT_PHP_MOD</varname></entry>

		<entry>Хочет PHP как модуль Apache.</entry>
	      </row>

	      <row>
		<entry><varname>WANT_PHP_SCR</varname></entry>

		<entry>Хочет CLI или CGI версию PHP.</entry>
	      </row>

	      <row>
		<entry><varname>WANT_PHP_WEB</varname></entry>

		<entry>Хочет модуль Apache или CGI версию PHP.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

      </sect2>

      <sect2>
	<title>Модули PEAR</title>

	<para>Портирование модулей PEAR является очень простым
	  процессом.</para>

	<para>Используйте переменные <varname>FILES</varname>,
	  <varname>TESTS</varname>, <varname>DATA</varname>,
	  <varname>SQLS</varname>, <varname>SCRIPTFILES</varname>,
	  <varname>DOCS</varname> and <varname>EXAMPLES</varname> для
	  перечисления файлов, которые вы хотите установить.  Все
	  перечисленные файлы будут автоматически установлены в подходящие
	  места и добавлены в <filename>pkg-plist</filename>.</para>

	<para>Подключите
	  <filename>&dollar;{PORTSDIR}/devel/pear/bsd.pear.mk</filename>
	  на последней строке <filename>Makefile</filename>.</para>

	<example xml:id="pear-makefile">
	  <title>Пример Makefile для классов PEAR</title>
	  <programlisting>PORTNAME=       Date
PORTVERSION=    1.4.3
CATEGORIES=     devel www pear

MAINTAINER=     example@domain.com
COMMENT=        PEAR Date and Time Zone Classes

BUILD_DEPENDS=  ${PEARDIR}/PEAR.php:${PORTSDIR}/devel/pear-PEAR
RUN_DEPENDS:=   ${BUILD_DEPENDS}

FILES=          Date.php Date/Calc.php Date/Human.php Date/Span.php     \
                Date/TimeZone.php
TESTS=          test_calc.php test_date_methods_span.php testunit.php   \
                testunit_date.php testunit_date_span.php wknotest.txt   \
                bug674.php bug727_1.php bug727_2.php bug727_3.php       \
                bug727_4.php bug967.php weeksinmonth_4_monday.txt       \
                weeksinmonth_4_sunday.txt weeksinmonth_rdm_monday.txt   \
                weeksinmonth_rdm_sunday.txt
DOCS=           TODO
_DOCSDIR=       .

.include &lt;bsd.port.pre.mk&gt;
.include "&dollar;{PORTSDIR}/devel/pear/bsd.pear.mk"
.include &lt;bsd.port.post.mk&gt;</programlisting>

	</example>

      </sect2>

    </sect1>

    <sect1 xml:id="using-python">
      <title>Использование Python</title>

      <para>Коллекция Портов поддерживает параллельную установку множества
	версий Python.  Следует убедиться, что в портах используется
	правильный интерпретатор <command>python</command> в соответствии
	с переменной <varname>PYTHON_VERSION</varname>, установленной
	пользователем.  По большей части это означает замену пути к
	исполняемому файлу <command>python</command> в сценариях на
	значение переменной <varname>PYTHON_CMD</varname>.</para>

      <para>Порты, устанавливающие файлы под каталог
	<varname>PYTHON_SITELIBDIR</varname>, должны использовать префикс
	вида <literal>pyXY-</literal>, таким образом названия пакетов будут
	включать в себя версию Python, с которой они установлены.</para>

      <programlisting>PKGNAMEPREFIX= ${PYTHON_PKGNAMEPREFIX}</programlisting>

      <table frame="none">
	<title>Переменные для портов, которые используют Python</title>

	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry><varname>USE_PYTHON</varname></entry>

	      <entry>Для этого порта нужен Python.  Минимальная требуемая
		версия может быть указана с таким значением как
		<literal>2.6+</literal>.  Также можно указан диапазон
		версий с разделением двух версий через &dash;, например:
		<literal>2.6-2.7</literal></entry>
	    </row>

	    <row>
	      <entry><varname>USE_PYDISTUTILS</varname></entry>

	      <entry>Использовать дистрибутивные утилиты (distutils) Python
		для конфигурации, компиляции и установки.  Необходимо, если
		порт использует <filename>setup.py</filename>.
		Переопределяет цели <buildtarget>do-build</buildtarget> и
		<buildtarget>do-install</buildtarget> и также может
		переопределять <buildtarget>do-configure</buildtarget>, если
		не определена <varname>GNU_CONFIGURE</varname>.</entry>
	    </row>

	    <row>
	      <entry><varname>PYTHON_PKGNAMEPREFIX</varname></entry>

	      <entry>Используется как <varname>PKGNAMEPREFIX</varname> для
		отличия пакетов, использующих разные версии Python.  Пример:
		<literal>py24-</literal></entry>
	    </row>

	    <row>
	      <entry><varname>PYTHON_SITELIBDIR</varname></entry>

	      <entry>Местонахождение дерева site-packages, которое содержит
		путь установки Python (обычно, <varname>LOCALBASE</varname>).
		Переменная <varname>PYTHON_SITELIBDIR</varname> может быть
		очень полезной при установке модулей Python.</entry>
	    </row>

	    <row>
	      <entry><varname>PYTHONPREFIX_SITELIBDIR</varname></entry>

	      <entry>Вариант PYTHON_SITELIBDIR без PREFIX.
		По возможности всегда используйте
		<literal>%%PYTHON_SITELIBDIR%%</literal> в
		<filename>pkg-plist</filename>.  Значением по умолчанию для
		<literal>%%PYTHON_SITELIBDIR%%</literal> является
		<literal>lib/python%%PYTHON_VERSION%%/site-packages</literal>
	      </entry>
	    </row>

	    <row>
	      <entry><varname>PYTHON_CMD</varname></entry>

	      <entry>Командная строка интерпретатора Python, включая номер
		версии.</entry>
	    </row>

	    <row>
	      <entry><varname>PYNUMERIC</varname></entry>

	      <entry>Строка зависимости для расширения numeric.</entry>
	    </row>

	    <row>
	      <entry><varname>PYNUMPY</varname></entry>
	      <entry>Строка зависимости для нового расширения numeric,
		numpy (PYNUMERIC объявлен устаревшим вышестоящим
		производителем).</entry>
	    </row>

	    <row>
	      <entry><varname>PYXML</varname></entry>

	      <entry>Строка зависимости для расширения XML (не нужно для
		Python 2.0 и выше, т.к. включено в основной дистрибутив).
	      </entry>
	    </row>

	    <row>
	      <entry><varname>USE_TWISTED</varname></entry>

	      <entry>Добавить зависимость от twistedCore.  Перечень требуемых
		компонентов может быть указан как значение этой переменной.
		Пример: <literal>web lore pair flow</literal></entry>
	    </row>

	    <row>
	      <entry><varname>USE_ZOPE</varname></entry>

	      <entry>Добавить зависимость от Zope, платформы веб приложений.
		Изменяет зависимость от Python на Python 2.7.  Переменная
		<varname>ZOPEBASEDIR</varname> содержит директорию с
		установленным Zope.</entry>
	    </row>

	  </tbody>
	</tgroup>
      </table>

      <para>Полный перечень доступных переменных можно найти в
	<filename>/usr/ports/Mk/bsd.python.mk</filename>.</para>

    </sect1>

    <sect1 xml:id="using-tcl">
      <title>Использование <application>Tcl/Tk</application></title>

      <para>В Коллекции Портов поддерживается одновременная установка
	множественных версий <application>Tcl/Tk</application>.  Порты
	должны пытаться поддерживать по крайней мере версию
	<application>Tcl/Tk</application>, используемую по умолчанию, и
	выше с помощью переменных <varname>USE_TCL</varname> и
	<varname>USE_TK</varname>.  Желаемую версию <command>tcl</command>
	можно указать в переменной <varname>WITH_TCL_VER</varname>.</para>

      <table frame="none">
	<title>Наиболее востребованные переменные для портов, которые
	  используют <application>Tcl/Tk</application></title>

	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry><varname>USE_TCL</varname></entry>

	      <entry>Порт зависит от библиотеки
		<application>Tcl</application> (не оболочки).
		Минимальную требуемую версию можно указать с использованием
		таких значений, как 84+.  Отдельные неподдерживаемые версии
		указываются в переменной
		<varname>INVALID_TCL_VER</varname>.</entry>
	    </row>

	    <row>
	      <entry><varname>USE_TCL_BUILD</varname></entry>

	      <entry><application>Tcl</application> нужен для порта только
		на время сборки.</entry>
	    </row>

	    <row>
	      <entry><varname>USE_TCL_WRAPPER</varname></entry>

	      <entry>Эту новую переменную следует использовать для портов,
		для которых требуется оболочка <application>Tcl</application>
		и не требуется конкретная версия <literal>tclsh</literal>.
		Обертка <literal>tclsh</literal> устанавливается в систему.
		Пользователь может указать желаемую оболочку
		<command>tcl</command> для использования.</entry>
	    </row>

	    <row>
	      <entry><varname>WITH_TCL_VER</varname></entry>

	      <entry>Определяемые пользователем переменные, которые
		устанавливают желаемую версию
		<application>Tcl</application>.</entry>
	    </row>

	    <row>
	      <entry><varname><replaceable>UNIQUENAME</replaceable>_WITH_TCL_VER</varname></entry>

	      <entry>Подобно <varname>WITH_TCL_VER</varname>, но для
		каждого порта.</entry>
	    </row>

	    <row>
	      <entry><varname>USE_TCL_THREADS</varname></entry>

	      <entry>Требует многопоточную сборку
		<application>Tcl/Tk</application>.</entry>
	    </row>

	    <row>
	      <entry><varname>USE_TK</varname></entry>

	      <entry>Порт зависит от библиотеки <application>Tk</application>
		(не от предпочитаемой оболочки).  Подразумевает
		<varname>USE_TCL</varname> с тем же значением.  Для
		большей информации смотрите описание переменной
		<varname>USE_TCL</varname>.</entry>
	    </row>

	    <row>
	      <entry><varname>USE_TK_BUILD</varname></entry>

	      <entry>Аналогично <varname>USE_TCL_BUILD</varname>.</entry>
	    </row>

	    <row>
	      <entry><varname>USE_TK_WRAPPER</varname></entry>

	      <entry>Аналогично <varname>USE_TCL_WRAPPER</varname>.</entry>
	    </row>

	    <row>
	      <entry><varname>WITH_TK_VER</varname></entry>

	      <entry>Аналогично <varname>WITH_TCL_VER</varname>,
		подразумевает <varname>WITH_TCL_VER</varname> той же
		версии.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>Полный перечень доступных переменных находится в
	<filename>/usr/ports/Mk/bsd.tcl.mk</filename>.</para>
    </sect1>

    <sect1 xml:id="using-emacs">
      <title>Использование Emacs</title>

      <para>Этот раздел ещё предстоит написать.</para>
    </sect1>

    <sect1 xml:id="using-ruby">
      <title>Использование Ruby</title>

      <table frame="none">
	<title>Полезные переменные для портов, использующих Ruby</title>

	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Переменная</entry>
	      <entry>Описание</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><varname>USE_RUBY</varname></entry>

	      <entry>Порт требует Ruby.</entry>
	    </row>

	    <row>
	      <entry><varname>USE_RUBY_EXTCONF</varname></entry>

	      <entry>Порт использует для конфигурации
		<filename>extconf.rb</filename>.</entry>
	    </row>

	    <row>
	      <entry><varname>USE_RUBY_SETUP</varname></entry>

	      <entry>Порт использует для конфигурации
		<filename>setup.rb</filename>.</entry>
	    </row>

	    <row>
	      <entry><varname>RUBY_SETUP</varname></entry>

	      <entry>Устанавливает альтернативное имя для
		<filename>setup.rb</filename>.  Распространенным значением
		является <filename>install.rb</filename>.</entry>
	    </row>

	  </tbody>
	</tgroup>
      </table>

      <para>Следующая таблица отражает некоторые переменные, доступные
	авторам портов через инфраструктуру портов.  Эти переменные должны
	использоваться для установки файлов в правильное месторасположение.
	Используйте их в <filename>pkg-plist</filename> как можно больше.
	Эти переменные не должны переопределяться в самом порте.</para>

      <table frame="none">
	<title>Отобранные переменные только для чтения для портов,
	  использующих Ruby</title>

	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Переменная</entry>
	      <entry>Описание</entry>
	      <entry>Примерное значение</entry>
	    </row>
	  </thead>
	  <tbody>

	    <row>
	      <entry><varname>RUBY_PKGNAMEPREFIX</varname></entry>

	      <entry>Используется как <varname>PKGNAMEPREFIX</varname>
		для различия пакетов от разных версий Ruby.</entry>

	      <entry><literal>ruby18-</literal></entry>
	    </row>

	    <row>
	      <entry><varname>RUBY_VERSION</varname></entry>

	      <entry>Полная версия Ruby в форме <literal>x.y.z</literal>.</entry>

	      <entry><literal>1.8.2</literal></entry>
	    </row>

	    <row>
	      <entry><varname>RUBY_SITELIBDIR</varname></entry>

	      <entry>Путь для установки архитектуронезависимых библиотек.</entry>

	      <entry><literal>/usr/local/lib/ruby/site_ruby/1.8</literal></entry>
	    </row>

	    <row>
	      <entry><varname>RUBY_SITEARCHLIBDIR</varname></entry>

	      <entry>Путь для установки архитектурозависимых библиотек.</entry>

	      <entry><literal>/usr/local/lib/ruby/site_ruby/1.8/amd64-freebsd6</literal></entry>
	    </row>

	    <row>
	      <entry><varname>RUBY_MODDOCDIR</varname></entry>

	      <entry>Путь для установки документации модуля.</entry>

	      <entry><literal>/usr/local/share/doc/ruby18/patsy</literal></entry>
	    </row>

	    <row>
	      <entry><varname>RUBY_MODEXAMPLESDIR</varname></entry>

	      <entry>Путь для установки примеров модуля.</entry>

	      <entry><literal>/usr/local/share/examples/ruby18/patsy</literal></entry>
	    </row>

	  </tbody>
	</tgroup>
      </table>

      <para>Полный перечень доступных переменных находится в
	<filename>/usr/ports/Mk/bsd.ruby.mk</filename>.</para>

    </sect1>

    <sect1 xml:id="using-sdl">
      <title>Использование SDL</title>

      <para>Переменная <varname>USE_SDL</varname> используется для
        автоматической настройки зависимостей для портов, использующих
        библиотеки на основе SDL, такие как
        <package>devel/sdl12</package> или
        <package>x11-toolkits/sdl_gui</package>.</para>

      <para>На данный момент распознаются следующие SDL-библиотеки:</para>

      <itemizedlist>
        <listitem>
          <para>sdl: <package>devel/sdl12</package></para>
        </listitem>

        <listitem>
          <para>gfx: <package>graphics/sdl_gfx</package></para>
        </listitem>

        <listitem>
          <para>gui: <package>x11-toolkits/sdl_gui</package></para>
        </listitem>

        <listitem>
          <para>image: <package>graphics/sdl_image</package></para>
        </listitem>

        <listitem>
          <para>ldbad: <package>devel/sdl_ldbad</package></para>
        </listitem>

        <listitem>
          <para>mixer: <package>audio/sdl_mixer</package></para>
        </listitem>

        <listitem>
          <para>mm: <package>devel/sdlmm</package></para>
        </listitem>

        <listitem>
          <para>net: <package>net/sdl_net</package></para>
        </listitem>

        <listitem>
          <para>sound: <package>audio/sdl_sound</package></para>
        </listitem>

        <listitem>
          <para>ttf: <package>graphics/sdl_ttf</package></para>
        </listitem>
      </itemizedlist>

      <para>Таким образом, если порт имеет зависимость от
        <package>net/sdl_net</package> и
        <package>audio/sdl_mixer</package>, то строка будет
        следующей:</para>

      <programlisting>USE_SDL=        net mixer</programlisting>

      <para>Зависимость от порта <package>devel/sdl12</package>, который требуется для <package>net/sdl_net</package> и <package>audio/sdl_mixer</package> будет также автоматически
        добавлен.</para>

      <para>Если вы используете <varname>USE_SDL</varname>, то
        он автоматически:</para>

      <itemizedlist>
        <listitem>
          <para>Добавляет зависимость от
            <application>sdl12-config</application>
            к <varname>BUILD_DEPENDS</varname></para>
        </listitem>

        <listitem>
          <para>Добавляет переменную <varname>SDL_CONFIG</varname> к
            <varname>CONFIGURE_ENV</varname></para>
        </listitem>

        <listitem>
          <para>Добавляет зависимости от указанных библиотек к
            <varname>LIB_DEPENDS</varname></para>
        </listitem>
      </itemizedlist>

      <para>Для проверки наличия библиотеки SDL вы можете делать это при
        помощи переменной <varname>WANT_SDL</varname>:</para>

      <programlisting>WANT_SDL=yes

.include &lt;bsd.port.pre.mk&gt;

.if ${HAVE_SDL:Mmixer}!=""
USE_SDL+=   mixer
.endif

.include &lt;bsd.port.post.mk&gt;</programlisting>
    </sect1>

    <sect1 xml:id="using-wx">
      <title>Использование <application>wxWidgets</application></title>

      <para>Эта глава описывает статус библиотек
	<application>wxWidgets</application> в дереве портов и их интеграцию
	с системой портов.</para>

      <sect2 xml:id="wx-introduction">
	<title>Введение</title>

	<para>Существует множество версий библиотек
	  <application>wxWidgets</application>, конфликтующих между собой
	  (устанавливают файлы под тем же именем).  В дереве портов эта
	  проблема решена путем установки каждой версии под собственным
	  названием с использованием номера версии в качестве
	  суффикса.</para>

	<para>Очевидным недостатком этого является необходимость изменения
	  каждого приложения для нахождения искомой версии.  К счастью,
	  большинство приложений для определения нужного компилятора и флагов
	  компоновки вызывают сценарий <command>wx-config</command>.  Для
	  каждой доступной версии этот сценарий имеет своё имя.  Большинство
	  приложений учитывают переменную окружения или принимают
	  аргумент configure для указания, какой сценарий
	  <command>wx-config</command> следует вызывать.  На все остальные
	  приходится накладывать патч.</para>
      </sect2>

      <sect2 xml:id="wx-version">
	<title>Выбор версии</title>

	<para>Для того, чтобы заставить ваш порт использовать конкретную
	  версию <application>wxWidgets</application>, существует две
	  доступные для определения переменные (если определена только одна,
	  то вторая примет значение по умолчанию):</para>

	<table xml:id="wx-ver-sel-table" frame="none">
	  <title>Переменные для выбора версии
	    <application>wxWidgets</application></title>

	  <tgroup cols="3">
	    <thead>
	      <row>
		<entry>Переменная</entry>

		<entry>Описание</entry>

		<entry>Значение по умолчанию</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><varname>USE_WX</varname></entry>

		<entry>Перечень версий, которые порт может использовать</entry>

		<entry>Все доступные версии</entry>
	      </row>

	      <row>
		<entry><varname>USE_WX_NOT</varname></entry>

		<entry>Перечень версий, которые порт не может использовать</entry>

		<entry>Нет</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>Перечень доступных версий <application>wxWidgets</application>
	  и соответствующих им портов в дереве:</para>

	<table frame="none">
	  <title>Доступные версии <application>wxWidgets</application></title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Версия</entry>

		<entry>Порт</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><literal>2.4</literal></entry>

		<entry><package>x11-toolkits/wxgtk24</package></entry>
	      </row>

	      <row>
		<entry><literal>2.6</literal></entry>

		<entry><package>x11-toolkits/wxgtk26</package></entry>
	      </row>

	      <row>
		<entry><literal>2.8</literal></entry>

		<entry><package>x11-toolkits/wxgtk28</package></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<note>
	  <para>Версии начиная с <literal>2.5</literal> также поставляются
	    с Unicode и устанавливается подчиненным портом с названием как
	    как у обычного, но с суффиксом <literal>-unicode</literal>, но
	    этим можно управлять при помощи переменных (смотрите <xref linkend="wx-unicode"/>).</para>
	</note>

	<para>Переменные в <xref linkend="wx-ver-sel-table"/> можно установить
	  в одну или более следующих комбинаций, разделенных пробелами:</para>

	<table frame="none">
	  <title>Определение версии для
	    <application>wxWidgets</application></title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Описание</entry>

		<entry>Пример</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry>Единичная версия</entry>

		<entry><literal>2.4</literal></entry>
	      </row>

	      <row>
		<entry>Восходящий диапазон</entry>

		<entry><literal>2.4+</literal></entry>
	      </row>

	      <row>
		<entry>Нисходящий диапазон</entry>

		<entry><literal>2.6-</literal></entry>
	      </row>

	      <row>
		<entry>Полный диапазон (обязан быть восходящим)</entry>

		<entry><literal>2.4-2.6</literal></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>Кроме того, существует несколько переменных для выбора
	  предпочитаемых версий из перечня доступных.  Они могут быть
	  установлены в несколько версий, первая из которых будет иметь
	  наибольший приоритет.</para>

	<table frame="none">
	  <title>Переменные для выбора предпочитаемых версий
	    <application>wxWidgets</application></title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Название</entry>

		<entry>Предназначение</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><varname>WANT_WX_VER</varname></entry>

		<entry>порт</entry>
	      </row>

	      <row>
		<entry><varname>WITH_WX_VER</varname></entry>

		<entry>пользователь</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </sect2>

      <sect2 xml:id="wx-components">
	<title>Выбор компонентов</title>

	<para>Существуют другие приложения, которые, хотя и не являются
	  библиотеками <application>wxWidgets</application>, но в тоже время
	  относятся к ним. Эти приложения можно указать в переменной
	  <varname>WX_COMPS</varname>.  Доступны следующие компоненты:</para>

	<table frame="none">
	  <title>Доступные компоненты <application>wxWidgets</application></title>

	  <tgroup cols="3">
	    <thead>
	      <row>
		<entry>Название</entry>

		<entry>Описание</entry>


		<entry>Ограничение версии</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><literal>wx</literal></entry>

		<entry>основная библиотека</entry>

		<entry>нет</entry>
	      </row>

	      <row>
		<entry><literal>contrib</literal></entry>

		<entry>сторонние библиотеки</entry>

		<entry><literal>нет</literal></entry>
	      </row>

	      <row>
		<entry><literal>python</literal></entry>

		<entry><application>wxPython</application>
		  (привязки к <application>Python</application>)</entry>

		<entry><literal>2.4-2.6</literal></entry>
	      </row>

	      <row>
		<entry><literal>mozilla</literal></entry>

		<entry><application>wxMozilla</application></entry>

		<entry><literal>2.4</literal></entry>
	      </row>
	      <row>
		<entry><literal>svg</literal></entry>

		<entry><application>wxSVG</application></entry>

		<entry><literal>2.6</literal></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>Тип добавляемой зависимости при выборе каждого компонента
	  может быть указан вручную путем добавления суффикса, отделенного
	  точкой с запятой.  Если таковой отсутствует, но будет использовано
	  значение по умолчанию (смотрите <xref linkend="wx-def-dep-types"/>).
	  Доступные типы зависимости:</para>

	<table frame="none">
	  <title>Доступные типы зависимости
	    <application>wxWidgets</application></title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Название</entry>

		<entry>Описание</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><literal>build</literal></entry>

		<entry>Компонент требуется для построения, эквивалентен
		  <varname>BUILD_DEPENDS</varname></entry>
	      </row>

	      <row>
		<entry><literal>run</literal></entry>

		<entry>Компонент требуется для запуска, эквивалентен
		  <varname>RUN_DEPENDS</varname></entry>
	      </row>

	      <row>
		<entry><literal>lib</literal></entry>

		<entry>Компонент требуется для построения и запуска,
		  эквивалентен <varname>LIB_DEPENDS</varname></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>Значения по умолчанию для компонентов подробно рассматриваются
	  в следующей таблице:</para>

	<table xml:id="wx-def-dep-types" frame="none">
	  <title>Типы зависимости <application>wxWidgets</application>,
	    используемые по умолчанию</title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Компонент</entry>

		<entry>Тип зависимости</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><literal>wx</literal></entry>

		<entry><literal>lib</literal></entry>
	      </row>

	      <row>
		<entry><literal>contrib</literal></entry>

		<entry><literal>lib</literal></entry>
	      </row>

	      <row>
		<entry><literal>python</literal></entry>

		<entry><literal>run</literal></entry>
	      </row>

	      <row>
		<entry><literal>mozilla</literal></entry>

		<entry><literal>lib</literal></entry>
	      </row>

	      <row>
		<entry><literal>svg</literal></entry>

		<entry><literal>lib</literal></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<example xml:id="wx-components-example">
	  <title>Выбор компонентов
	    <application>wxWidgets</application></title>

	  <para>Следующий фрагмент относится к порту, в котором используется
	    <application>wxWidgets</application> версии 2.4 с его сторонними
	    библиотеками.</para>

	  <programlisting>USE_WX=       2.4
WX_COMPS=     wx contrib</programlisting>
	</example>
      </sect2>
      <sect2 xml:id="wx-unicode">
	<title>Unicode</title>

	<para>Библиотека <application>wxWidgets</application> поддерживает
	  Unicode начиная с версии <literal>2.5</literal>.  В дереве портов
	  доступны обе версии и могут быть выбраны с использованием
	  следующих переменных:</para>

	<table xml:id="wx-unicode-var-table" frame="none">
	  <title>Переменные для выбора версии
	    <application>wxWidgets</application> с Unicode</title>

	  <tgroup cols="3">
	    <thead>
	      <row>
		<entry>Переменная</entry>

		<entry>Описание</entry>

		<entry>Предназначение</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><varname>WX_UNICODE</varname></entry>

		<entry>Порт работает <emphasis>только</emphasis> с версией
		  Unicode</entry>

		<entry>порт</entry>
	      </row>

	      <row>
		<entry><varname>WANT_UNICODE</varname></entry>

		<entry>Порт работает с обеими версиями, но предпочитает
		  версию с Unicode</entry>

		<entry>порт</entry>
	      </row>
	      <row>
		<entry><varname>WITH_UNICODE</varname></entry>

		<entry>Порт будет использовать версию Unicode</entry>

		<entry>пользователь</entry>
	      </row>
	      <row>
		<entry><varname>WITHOUT_UNICODE</varname></entry>

		<entry>Порт будет использовать обычную версию, если это
		  поддерживается (когда <varname>WX_UNICODE</varname>
		  не определена)</entry>

		<entry>пользователь</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<warning>
	  <para>Не используйте <varname>WX_UNICODE</varname> для портов,
	    которые могут использовать обе версии.  Если вы хотите, чтобы
	    порт по умолчанию использовал Unicode, определите вместо этого
	    <varname>WANT_UNICODE</varname>.</para>
	</warning>
      </sect2>

      <sect2 xml:id="wx-version-detection">
	<title>Обнаружение установленных версий</title>

	<para>Для обнаружения установленной версии вам необходимо задать
	  переменную <varname>WANT_WX</varname>.  Если вы не присвоите ей
	  определенную версию, то компоненты получат суффикс версии.
	  Переменная <varname>HAVE_WX</varname> будет заполнена после
	  обнаружения.</para>

	<example xml:id="wx-ver-det-example">
	  <title>Обнаружение установленных версий и компонентов
	    <application>wxWidgets</application></title>

	  <para>Следующий фрагмент может быть использован в порту, который
	    использует <application>wxWidgets</application>, в случае если
	    он установлен или выбран соответствующий параметр.</para>

	  <programlisting>WANT_WX=        yes

.include &lt;bsd.port.pre.mk&gt;

.if defined(WITH_WX) || !empty(PORT_OPTIONS:MWX) || !empty(HAVE_WX:Mwx-2.4)
USE_WX=         2.4
CONFIGURE_ARGS+=--enable-wx
.endif</programlisting>

	  <para>Следующий фрагмент может быть использован в порту, который
	    задействует поддержку <application>wxPython</application>,
	    в случае если он установлен или выбран соответствующий параметр,
	    в дополнение к <application>wxWidgets</application>, обе версии
	    <literal>2.6</literal>.</para>

	  <programlisting>USE_WX=         2.6
WX_COMPS=       wx
WANT_WX=        2.6

.include &lt;bsd.port.pre.mk&gt;

.if defined(WITH_WXPYTHON) || !empty(PORT_OPTIONS:MWXPYTHON) || !empty(HAVE_WX:Mpython)
WX_COMPS+=      python
CONFIGURE_ARGS+=--enable-wxpython
.endif</programlisting>
	</example>
      </sect2>

      <sect2 xml:id="wx-defined-variables">
	<title>Переменные для определения</title>

	<para>Следующие переменные доступны в порту (после определения одной
	  из переменных из <xref linkend="wx-ver-sel-table"/>).</para>

	<table frame="none">
	  <title>Переменные, определенные для портов, использующих
	    <application>wxWidgets</application></title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Название</entry>

		<entry>Описание</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><varname>WX_CONFIG</varname></entry>

		<entry>Путь к сценарию <application>wxWidgets</application>
		  <command>wx-config</command> (с другим именем)</entry>
	      </row>

	      <row>
		<entry><varname>WXRC_CMD</varname></entry>

		<entry>Путь к программе <application>wxWidgets</application>
		  <command>wxrc</command> (с другим именем)</entry>
	      </row>

	      <row>
		<entry><varname>WX_VERSION</varname></entry>

		<entry>Версия <application>wxWidgets</application>, которая
		  будет использоваться (например,
		  <literal>2.6</literal>)</entry>
	      </row>

	      <row>
		<entry><varname>WX_UNICODE</varname></entry>

		<entry>Если не определена, но Unicode будет использоваться,
		  то она будет определена</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </sect2>

      <sect2 xml:id="wx-premk">
	<title>Обработка в <filename>bsd.port.pre.mk</filename></title>

	<para>Если вам нужно использовать переменные для запуска команд
	  сразу после подключения <filename>bsd.port.pre.mk</filename>, то
	  вам нужно определить <varname>WX_PREMK</varname>.</para>

	<important>
	  <para>Если вы определите <varname>WX_PREMK</varname>, то версия,
	  зависимости, компоненты и заданные переменные не изменяться, в
	  случае вы изменили переменные порта
	  <application>wxWidgets</application> <emphasis>после</emphasis>
	  подключения <filename>bsd.port.pre.mk</filename>.</para>
	</important>

	<example xml:id="wx-premk-example">
	  <title>Использование переменных <application>wxWidgets</application>
	    в командах</title>

	  <para>Следующий фрагмент иллюстрирует использование переменной
	    <varname>WX_PREMK</varname> посредством запуска сценария
	    <command>wx-config</command> для получения строки с полной версией
	    с присвоением ее переменной и передачей в программу.</para>

	  <programlisting>USE_WX=         2.4
WX_PREMK=       yes

.include &lt;bsd.port.pre.mk&gt;

.if exists(${WX_CONFIG})
VER_STR!=       ${WX_CONFIG} --release

PLIST_SUB+=     VERSION="${VER_STR}"
.endif</programlisting>
	</example>

	<note>
	  <para>Переменные <application>wxWidgets</application> можно
	    безопасно использовать в командах внутри целей без необходимости
	    в использовании <varname>WX_PREMK</varname>.</para>
	</note>
      </sect2>

      <sect2 xml:id="wx-additional-config-args">
	<title>Дополнительные параметры <command>configure</command></title>

	<para>Некоторые сценарии GNU <command>configure</command> не могут
	  найти <application>wxWidgets</application> только с установленной
	  переменной окружения <literal>WX_CONFIG</literal>, требуя
	  дополнительные параметры.  Для их передачи можно использовать
	  переменную <varname>WX_CONF_ARGS</varname>.</para>

	<table frame="none">
	  <title>Допустимые значения <varname>WX_CONF_ARGS</varname></title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Возможное значение</entry>

		<entry>Получаемый параметр</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><literal>absolute</literal></entry>

		<entry><literal>--with-wx-config=${WX_CONFIG}</literal></entry>
	      </row>

	      <row>
		<entry><literal>relative</literal></entry>

		<entry><literal>--with-wx=${LOCALBASE}
		  --with-wx-config=${WX_CONFIG:T}</literal></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </sect2>
    </sect1>

    <sect1 xml:id="using-lua">
      <title>Использование <application>Lua</application></title>

      <para>Эта глава описывает статус библиотек <application>Lua</application>
	в дереве портов и их интеграцию в систему портов.</para>

      <sect2 xml:id="lua-introduction">
	<title>Введение</title>

	<para>Существует множество версий библиотек
	  <application>Lua</application> и соответствующих интерпретаторов,
	  конфликтующих между собой (устанавливают файлы под тем же именем).
	  В дереве портов эта проблема решена путем установки каждой версии
	  в собственное место с использованием номера версии в качестве
	  суффикса.</para>

	<para>Очевидным недостатком этого является необходимость изменения
	  каждого приложения для нахождения искомой версии.  Но это решается
	  добавлением некоторых дополнительных флагов для компилятора и
	  компоновщика.</para>
      </sect2>

      <sect2 xml:id="lua-version">
	<title>Выбор версии</title>

	<para>Для того, чтобы заставить ваш порт использовать конкретную
	  версию <application>Lua</application>, существует две доступные
	  для определения переменные (если определена только одна, то
	  вторая примет значение по умолчанию):</para>

	<table xml:id="lua-ver-sel-table" frame="none">
	  <title>Переменные для выбора версии
	    <application>Lua</application></title>

	  <tgroup cols="3">
	    <thead>
	      <row>
		<entry>Переменная</entry>

		<entry>Описание</entry>

		<entry>Значение по умолчанию</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><varname>USE_LUA</varname></entry>

		<entry>Перечень версий, которые порт может использовать</entry>

		<entry>Все доступные версии</entry>
	      </row>

	      <row>
		<entry><varname>USE_LUA_NOT</varname></entry>

		<entry>Перечень версий, которые порт не может
		  использовать</entry>

		<entry>Пусто</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>Перечень доступных версий <application>Lua</application> и
	  соответствующих портов в дереве:</para>

	<table frame="none">
	  <title>Доступные версии <application>Lua</application></title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Версия</entry>

		<entry>Порт</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><literal>4.0</literal></entry>

		<entry><package>lang/lua4</package></entry>
	      </row>

	      <row>
		<entry><literal>5.0</literal></entry>

		<entry><package>lang/lua50</package></entry>
	      </row>

	      <row>
		<entry><literal>5.1</literal></entry>

		<entry><package>lang/lua</package></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>Переменные из <xref linkend="lua-ver-sel-table"/> могут иметь
	  комбинации из одного или нескольких значений, разделенных
	  пробелом:</para>

	<table frame="none">
	  <title>Определение версии <application>Lua</application></title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Описание</entry>

		<entry>Пример</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry>Единичная версия</entry>

		<entry><literal>4.0</literal></entry>
	      </row>

	      <row>
		<entry>Восходящий диапазон</entry>

		<entry><literal>5.0+</literal></entry>
	      </row>


	      <row>
		<entry>Нисходящий диапазон</entry>

		<entry><literal>5.0-</literal></entry>
	      </row>

	      <row>
		<entry>Полный диапазон (обязан быть восходящим)</entry>

		<entry><literal>5.0-5.1</literal></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>Кроме того, существует несколько переменных для выбора
	  предпочитаемых версий из перечня доступных.  Они могут быть
	  установлены в несколько версий, первая из которых будет иметь
	  наибольший приоритет.</para>

	<table frame="none">
	  <title>Переменные для выбора предпочитаемых версий
	    <application>Lua</application></title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Название</entry>

		<entry>Предназначение</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><varname>WANT_LUA_VER</varname></entry>

		<entry>порт</entry>
	      </row>

	      <row>
		<entry><varname>WITH_LUA_VER</varname></entry>

		<entry>пользователь</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<example xml:id="lua-version-example">
	  <title>Выбор версии <application>Lua</application></title>

	  <para>Следующий фрагмент взят из порта, который использует
	    <application>Lua</application> версий <literal>5.0</literal>
	    или <literal>5.1</literal>, по умолчанию <literal>5.0</literal>.
	    Значение может быть переопределено пользователем с использованием
	    переменной <varname>WITH_LUA_VER</varname>.</para>

	  <programlisting>USE_LUA=      5.0-5.1
WANT_LUA_VER= 5.0</programlisting>
	</example>
      </sect2>

      <sect2 xml:id="lua-components">
	<title>Выбор компонентов</title>

	<para>Существуют другие приложения, которые хотя и не являются
	  библиотеками <application>Lua</application>, но относятся к ним.
	  Эти приложения можно указать в переменной
	  <varname>LUA_COMPS</varname>.  Доступны следующие компоненты:</para>

	<table frame="none">
	  <title>Доступные компоненты <application>Lua</application></title>

	  <tgroup cols="3">
	    <thead>
	      <row>
		<entry>Название</entry>

		<entry>Описание</entry>


		<entry>Ограничение версии</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><literal>lua</literal></entry>

		<entry>Основная библиотека</entry>

		<entry>нет</entry>
	      </row>

	      <row>
		<entry><literal>tolua</literal></entry>

		<entry>Библиотека доступа к коду C/C++</entry>

		<entry>4.0-5.0</entry>
	      </row>

	      <row>
		<entry><literal>ruby</literal></entry>

		<entry>Привязка к Ruby</entry>

		<entry>4.0-5.0</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<note>
	  <para>Есть и другие компоненты, но они относятся к модулям для
	    интерпретатора и не используются приложениями (только другими
	    модулями).</para>
	</note>

	<para>Тип зависимости можно выбрать для каждого компонента через
	  добавление суффикса, отделенного точкой с запятой.  В случае
	  отсутствия будет использован тип по умолчанию (смотрите
	  <xref linkend="lua-def-dep-types"/>).  Доступные следующие
	  типы:</para>

	<table frame="none">
	  <title>Доступные типы зависимости
	    <application>Lua</application></title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Название</entry>

		<entry>Описание</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><literal>build</literal></entry>

		<entry>Компонент требуется для построения, эквивалентен
		  <varname>BUILD_DEPENDS</varname></entry>
	      </row>

	      <row>
		<entry><literal>run</literal></entry>

		<entry>Компонент требуется для запуска, эквивалентен
		  <varname>RUN_DEPENDS</varname></entry>
	      </row>

	      <row>
		<entry><literal>lib</literal></entry>

		<entry>Компонент требуется для построения и запуска,
		  эквивалентен <varname>LIB_DEPENDS</varname></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>Значения по умолчанию для компонентов подробно рассматриваются
	  в следующей таблице:</para>

	<table xml:id="lua-def-dep-types" frame="none">
	  <title>Типы зависимости <application>Lua</application>,
	    используемые по умолчанию</title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Компонент</entry>

		<entry>Тип зависимости</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><literal>lua</literal></entry>

		<entry><literal>lib</literal> для <literal>4.0-5.0</literal>
		  (динамическая) и <literal>build</literal> для
		  <literal>5.1</literal> (статическая)</entry>
	      </row>

	      <row>
		<entry><literal>tolua</literal></entry>

		<entry><literal>build</literal> (статическая)</entry>
	      </row>

	      <row>
		<entry><literal>ruby</literal></entry>

		<entry><literal>lib</literal> (динамическая)</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<example xml:id="lua-components-example">
	  <title>Выбор компонентов <application>Lua</application></title>

	  <para>Следующий фрагмент соответствует порту, использующему
	    <application>Lua</application> версии <literal>4.0</literal>
	    и привязку к <application>Ruby</application>.</para>

	  <programlisting>USE_LUA=      4.0
LUA_COMPS=    lua ruby</programlisting>
	</example>
      </sect2>

      <sect2 xml:id="lua-version-detection">
	<title>Обнаружение установленных версий</title>

	<para>Для обнаружения установленной версии вам необходимо задать
	  переменную <varname>WANT_LUA</varname>.  Если вы не присвоите ей
	  определенную версию, то компоненты получат суффикс версии.
	  Переменная <varname>HAVE_LUA</varname> будет заполнена после
	  обнаружения.</para>

	<example xml:id="lua-ver-det-example">
	  <title>Обнаружение установленных версий и компонентов
	    <application>Lua</application></title>

	  <para>Следующий фрагмент можно использовать для порта, использующего
	    <application>Lua</application>, если она установлена, или был
	    выбран соответствующий параметр.</para>

	  <programlisting>WANT_LUA=       yes

.include &lt;bsd.port.pre.mk&gt;

.if defined(WITH_LUA5) || !empty(PORT_OPTIONS:MLUA5) || !empty(HAVE_LUA:Mlua-5.[01])
USE_LUA=        5.0-5.1
CONFIGURE_ARGS+=--enable-lua5
.endif</programlisting>

	  <para>Следующий фрагмент можно использовать для порта, который
	    включает поддержку <application>tolua</application>, если
	    такой компонент установлен, или был выбран соответствующий
	    параметр в дополнение к <application>Lua</application>, оба
	    имеют версию <literal>4.0</literal>.</para>

	  <programlisting>USE_LUA=        4.0
LUA_COMPS=      lua
WANT_LUA=       4.0

.include &lt;bsd.port.pre.mk&gt;

.if defined(WITH_TOLUA) || !empty(PORT_OPTIONS:MTOLUA) || !empty(HAVE_LUA:Mtolua)
LUA_COMPS+=     tolua
CONFIGURE_ARGS+=--enable-tolua
.endif</programlisting>
	</example>
      </sect2>

      <sect2 xml:id="lua-defined-variables">
	<title>Переменные для определения</title>

	<para>Следующие переменные доступны в порту (после определения одной
	  из переменных из <xref linkend="lua-ver-sel-table"/>).</para>

	<table frame="none">
	  <title>Переменные, определенные для портов, использующих
	    <application>Lua</application></title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Название</entry>

		<entry>Описание</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><varname>LUA_VER</varname></entry>

		<entry>Версия <application>Lua</application>, которая будет
		  использоваться (например, <literal>5.1</literal>)</entry>
	      </row>

	      <row>
		<entry><varname>LUA_VER_SH</varname></entry>

		<entry>Старший номер версии динамической библиотеки
		  <application>Lua</application> (например,
		  <literal>1</literal>)</entry>
	      </row>

	      <row>
		<entry><varname>LUA_VER_STR</varname></entry>

		<entry>Версия <application>Lua</application> без точки
		  (например, <literal>51</literal>)</entry>
	      </row>

	      <row>
		<entry><varname>LUA_PREFIX</varname></entry>

		<entry>Префикс, в который установлена
		  <application>Lua</application> (и компоненты)</entry>
	      </row>

	      <row>
		<entry><varname>LUA_SUBDIR</varname></entry>

		<entry>Каталог под <filename>${PREFIX}/bin</filename>,
		  <filename>${PREFIX}/share</filename> и
		  <filename>${PREFIX}/lib</filename>, в который установлена
		  <application>Lua</application></entry>
	      </row>

	      <row>
		<entry><varname>LUA_INCDIR</varname></entry>

		<entry>Каталог, в который установлены заголовочные файлы
		  <application>Lua</application> и
		  <application>tolua</application></entry>
	      </row>

	      <row>
		<entry><varname>LUA_LIBDIR</varname></entry>

		<entry>Каталог, в который установлены библиотеки
		  <application>Lua</application> и
		  <application>tolua</application></entry>
	      </row>

	      <row>
		<entry><varname>LUA_MODLIBDIR</varname></entry>

		<entry>Каталог, в который установлены модули библиотеки
		  <application>Lua</application>
		  (<filename>.so</filename>)</entry>
	      </row>

	      <row>
		<entry><varname>LUA_MODSHAREDIR</varname></entry>

		<entry>Каталог, в который установлены модули
		  <application>Lua</application>
		  (<filename>.lua</filename>)</entry>
	      </row>

	      <row>
		<entry><varname>LUA_PKGNAMEPREFIX</varname></entry>

		<entry>Префикс с именем пакета, используемый модулями
		  <application>Lua</application></entry>
	      </row>

	      <row>
		<entry><varname>LUA_CMD</varname></entry>

		<entry>Путь к интерпретатору
		  <application>Lua</application></entry>
	      </row>

	      <row>
		<entry><varname>LUAC_CMD</varname></entry>

		<entry>Путь к компилятору
		  <application>Lua</application></entry>
	      </row>

	      <row>
		<entry><varname>TOLUA_CMD</varname></entry>

		<entry>Путь к программе
		  <application>tolua</application></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<example xml:id="lua-variables-example">
	  <title>Указание для порта, где искать
	    <application>Lua</application></title>

	  <para>Следующий фрагмент показывает, как сообщить порту, который
	    использует сценарий configure, где расположены заголовочные
	    файлы и библиотеки <application>Lua</application>.</para>

	  <programlisting>
USE_LUA=        4.0
GNU_CONFIGURE=  yes
CONFIGURE_ENV=  CPPFLAGS="-I${LUA_INCDIR}" LDFLAGS="-L${LUA_LIBDIR}"</programlisting>
	</example>
      </sect2>

      <sect2 xml:id="lua-premk">
	<title>Обработка в <filename>bsd.port.pre.mk</filename></title>

	<para>Если вам нужно использовать переменные для запуска команд сразу
	  после подключения <filename>bsd.port.pre.mk</filename>, для этого
	  вам нужно определить переменную <varname>LUA_PREMK</varname>.</para>

	<important>
	  <para>Если вы задаете <varname>LUA_PREMK</varname>, то версия,
	  зависимости, компоненты и уже заданные переменные не будут
	  изменены, в случае если вы изменили переменные порта
	  <application>Lua</application> <emphasis>после</emphasis>
	  подключения <filename>bsd.port.pre.mk</filename>.</para>
	</important>

	<example xml:id="lua-premk-example">
	  <title>Использование переменных <application>Lua</application>
	    в командах</title>

	  <para>Следующий фрагмент иллюстрирует использование
	    <varname>LUA_PREMK</varname> посредством запуска
	    интерпретатора <application>Lua</application> для того, чтобы
	    получить строку с полной версией, сохранить ее в переменную
	    и передать программе.</para>

	  <programlisting>USE_LUA=        5.0
LUA_PREMK=      yes

.include &lt;bsd.port.pre.mk&gt;

.if exists(${LUA_CMD})
VER_STR!=       ${LUA_CMD} -v

CFLAGS+=        -DLUA_VERSION_STRING="${VER_STR}"
.endif</programlisting>
	</example>

	<note>
	  <para>Переменные <application>Lua</application> можно безопасно
	    использовать в командах внутри целей без необходимости в
	    использовании <varname>LUA_PREMK</varname>.</para>
	</note>
      </sect2>
    </sect1>

    <sect1 xml:id="using-xfce">
      <title>Использование Xfce</title>

      <para>Переменная <varname>USE_XFCE</varname> используется для
	автоматической конфигурации зависимостей для портов, использующих
	библиотеки или приложения на основе Xfce, такие как
	<package>x11-toolkits/libxfce4gui</package> и
	<package>x11-wm/xfce4-panel</package>.</para>

      <para>В настоящее время распознаются следующие библиотеки и приложения
	Xfce:</para>

      <itemizedlist>
	<listitem>
	  <para>libexo: <package>x11/libexo</package></para>
	</listitem>

	<listitem>
	  <para>libgui: <package>x11-toolkits/libxfce4gui</package></para>
	</listitem>

	<listitem>
	  <para>libutil: <package>x11/libxfce4util</package></para>
	</listitem>

	<listitem>
	  <para>libmcs: <package>x11/libxfce4mcs</package></para>
	</listitem>

	<listitem>
	  <para>mcsmanager: <package>sysutils/xfce4-mcs-manager</package></para>
	</listitem>

	<listitem>
	  <para>panel: <package>x11-wm/xfce4-panel</package></para>
	</listitem>

	<listitem>
	  <para>thunar: <package>x11-fm/thunar</package></para>
	</listitem>

	<listitem>
	  <para>wm: <package>x11-wm/xfce4-wm</package></para>
	</listitem>

	<listitem>
	  <para>xfdev: <package>dev/xfce4-dev-tools</package></para>
	</listitem>

      </itemizedlist>

      <para>Распознаются следующие дополнительные параметры:</para>

      <itemizedlist>
	<listitem>
	  <para>configenv: Используйте, если ваш порт требует специально
	    измененного значения <varname>CONFIGURE_ENV</varname> для поиска
	    требуемых для порта библиотек.</para>

	  <programlisting>-I&dollar;{LOCALBASE}/include -L&dollar;{LOCALBASE}/lib</programlisting>

	  <para>добавляется в CPPFLAGS к <varname>CONFIGURE_ENV</varname>.</para>
	</listitem>
      </itemizedlist>

      <para>Следовательно, если у порта имеется зависимость от
	<package>sysutils/xfce4-mcs-manager</package>, и
	порт требует специальных CPPFLAGS в своем окружении configure,
	то синтаксис будет следующим:</para>

      <programlisting>USE_XFCE=        mcsmanager configenv</programlisting>
    </sect1>

    <sect1 xml:id="using-mozilla">
      <title>Использование Mozilla</title>

	<table frame="none">
	  <title>Переменные для портов, использующих Mozilla</title>

	  <tgroup cols="2">
	    <tbody>

	      <row>
		<entry><varname>USE_GECKO</varname></entry>

		<entry>Один из бэкэндов Gecko, с которым может работать
		  порт.  Возможные значения:
		  <literal>libxul</literal> (<filename>libxul.so</filename>),
		  <literal>seamonkey</literal> (<filename>libgtkembedmoz.so</filename>,
		  устаревший, больше не должен использоваться).</entry>
	      </row>
	      <row>
		<entry><varname>USE_FIREFOX</varname></entry>

		<entry>Для запуска порта требуется Firefox.
		  Возможные значения:
		  <literal>yes</literal> (берется версия по умолчанию),
		  <literal>40</literal>, <literal>36</literal>,
		  <literal>35</literal>.
		  По умолчанию устанавливает зависимость от версии
		  <literal>40</literal>.</entry>
	      </row>
	      <row>
		<entry><varname>USE_FIREFOX_BUILD</varname></entry>

		<entry>Для построения порта требуется Firefox.
		  Возможные значения: смотрите USE_FIREFOX.
		  Автоматически устанавливает USE_FIREFOX с присвоением
		  того же значения.</entry>
	      </row>
	      <row>
		<entry><varname>USE_SEAMONKEY</varname></entry>

		<entry>Для запуска порта требуется SeaMonkey.
		  Возможные значения:
		  <literal>yes</literal> (берется версия по умолчанию),
		  <literal>20</literal>, <literal>11</literal>
		  (устарело, больше не должно использоваться).
		  По умолчанию устанавливает зависимость от версии
		  <literal>20</literal>.</entry>
	      </row>
	      <row>
		<entry><varname>USE_SEAMONKEY_BUILD</varname></entry>

		<entry>Для построения порта требуется SeaMonkey.
		  Возможные значения: смотрите USE_SEAMONKEY.
		  Автоматически устанавливает USE_SEAMONKEY с присвоением
		  того же значения.</entry>
	      </row>
	      <row>
		<entry><varname>USE_THUNDERBIRD</varname></entry>

		<entry>Для запуска порта требуется Thunderbird.
		  Возможные значения:
		  <literal>yes</literal> (берется версия по умолчанию),
		  <literal>31</literal>, <literal>30</literal>
		  (устарело, больше не должно использоваться).
		  По умолчанию устанавливает зависимость от версии
		  <literal>31</literal>.</entry>
	      </row>
	      <row>
		<entry><varname>USE_THUNDERBIRD_BUILD</varname></entry>

		<entry>Для построения порта требуется Thunderbird.
		  Возможные значения: смотрите USE_THUNDERBIRD.
		  Автоматически устанавливает USE_THUNDERBIRD с присвоением
		  того же значения.</entry>
	      </row>

	    </tbody>
	  </tgroup>
	</table>
      <para>Полный перечень доступных переменных можно получить в файле
	<filename>/usr/ports/Mk/bsd.gecko.mk</filename>.</para>
    </sect1>

    <sect1 xml:id="using-databases">
      <title>Использование баз данных</title>

	<table frame="none">
	  <title>Переменные для портов, использующих базы данных</title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Переменная</entry>

		<entry>Значение</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><varname>USE_BDB</varname></entry>

		<entry>Если переменная установлена в <literal>yes</literal>,
		  добавляет зависимость от порта
		  <package>databases/db41</package>.
		  Также переменной можно присвоить значения: 2, 3, 40, 41,
		  42, 43, 44, 46, 47, 48 или 51.  Вы можете объявить диапазон
		  принимаемых значений, <varname>USE_BDB</varname>=42+
		  будет искать установленную версию с наибольшим номером,
		  и, если ничего не установлено, вернется к 42.</entry>
	      </row>

	      <row>
		<entry><varname>USE_MYSQL</varname></entry>

		<entry>Если переменная установлена в <literal>yes</literal>,
		  добавляет зависимость от порта
		  <package>databases/mysql55-client</package>.
		  Как связанная переменная,
		  <varname>WANT_MYSQL_VER</varname> может быть установлена
		  в значение 323, 40, 41, 50, 51, 52, 55 или 60.</entry>
	      </row>

	      <row>
		<entry><varname>USE_PGSQL</varname></entry>

		<entry>Если установлена в <literal>yes</literal>, добавляет
		  зависимость от порта <package>databases/postgresql90-client</package>.
		  Как связанная переменная,
		  <varname>WANT_PGSQL_VER</varname> может быть установлена
		  в значение 83, 84, 90, 91 или 92.  Вы можете указать
		  максимальное и минимальное значения;
		  <varname>WANT_PGSQL_VER</varname>=
		  <literal> 90+</literal> сделает порт зависимым от
		  минимальной версии 9.0.</entry>
	      </row>

	      <row>
		<entry><varname>USE_SQLITE</varname></entry>

		<entry>Если переменная имеет значение <literal>yes</literal>,
		  добавляет зависимость от порта <package>databases/sqlite3</package>.
		  Переменная может принимать значения: 3, 2.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>Подробнее смотрите в <link xlink:href="http://svnweb.FreeBSD.org/ports/head/Mk/bsd.database.mk?view=markup">bsd.database.mk</link>.</para>
    </sect1>

    <sect1 xml:id="rc-scripts">
      <title>Запуск и остановка служб (сценарии <literal>rc</literal>)</title>

      <para>Сценарии <filename>rc.d</filename> используются для запуска служб
	при запуске системы и дают администратору стандартный способ
	остановки, запуска и перезапуска службы.  Порты интегрируются в
	системную инфраструктуру <filename>rc.d</filename>.  Подробности
	по её использованию можно найти в <link xlink:href="&url.books.handbook;/configtuning-rcd.html">главе rc.d
	Руководства</link>.  Подробное объяснение доступных команд
	находится в &man.rc.8; и &man.rc.subr.8;.  Наконец, есть <link xlink:href="&url.articles.rc-scripting;">статья</link>о практических
	аспектах написания сценариев <filename>rc.d</filename>.</para>

      <para>Установить можно один или более сценариев
	<filename>rc.d</filename>:</para>

      <programlisting>USE_RC_SUBR=	doormand</programlisting>

      <para>Сценарии обязаны размещаться в подкаталоге
	<filename>files</filename> с обязательным добавлением суффикса
	<literal>.in</literal> к имени файла.  Для этого файла будут
	использоваться стандартные расширения <varname>SUB_LIST</varname>.
	Также особенно приветствуется использование расширений
	<literal>%%PREFIX%%</literal> и <literal>%%LOCALBASE%%</literal>.
	Подробнее о <varname>SUB_LIST</varname> в <link linkend="using-sub-files">соответствующей главе</link>.</para>

      <para>До &os;&nbsp;6.1-RELEASE интеграция с &man.rcorder.8; доступна
	через использование <varname>USE_RCORDER</varname> вместо
	<varname>USE_RC_SUBR</varname>.  Однако, использовать этот метод
	не нужно, если ваш порт не включает опцию по своей установке в
	основную систему или службе не нужно запускаться до выполнения
	сценария <filename>FILESYSTEMS</filename> из <filename>rc.d</filename>
	основной системы.</para>

      <para>Начиная с &os;&nbsp;6.1-RELEASE локальные сценарии
	<filename>rc.d</filename> (включая установленные из портов) включены
	в общий &man.rcorder.8; основной системы.</para>

      <para>Пример простого сценария <filename>rc.d</filename>:</para>

      <programlisting>#!/bin/sh

# &dollar;FreeBSD&dollar;
#
# PROVIDE: doormand
# REQUIRE: LOGIN
# KEYWORD: shutdown
#
#
# Add the following lines to /etc/rc.conf.local or /etc/rc.conf to enable doorman:
# doorman_enable (bool):      Set to "NO" by default.
#                             Set it to "YES" to enable doorman
# doorman_config (path):      Set to "%%PREFIX%%/etc/doormand/doormand.cf" by default.
# Add the following lines to /etc/rc.conf.local or /etc/rc.conf
# to enable this service:
#
# doormand_enable (bool):	Set to NO by default.
#				Set it to YES to enable doormand.
# doormand_config (path):	Set to %%PREFIX%%/etc/doormand/doormand.cf
#				by default.
#

. /etc/rc.subr

name=doormand
rcvar=doormand_enable

load_rc_config $name

: ${doormand_enable:="NO"}
: ${doormand_config="%%PREFIX%%/etc/doormand/doormand.cf"}

command=%%PREFIX%%/sbin/${name}
pidfile=/var/run/${name}.pid

command_args="-p $pidfile -f $doormand_config"

run_rc_command "$1"</programlisting>

      <para>Если нет стоящей причины запускать службы раньше всех портов,
	сценарии должны использовать</para>

      <programlisting>REQUIRE: LOGIN</programlisting>

      <para>Если служба
	работает под определенным пользователем (отличным от root), то
	это делается принудительно.  В сценарий выше включена конструкция</para>

      <programlisting>KEYWORD: shutdown</programlisting>

      <para>потому что
	вымышленный порт, который мы используем в качестве примера, запускает
	службу, и она должна корректно завершиться при выключении системы.
	Если сценарий не запускает постоянную службу, то это не является
	необходимым.</para>

      <para>Для необязательных элементов конфигурации
	присвоение переменной по умолчанию в стиле &quot;=&quot;
	является более предпочтительным по сравнению со стилем &quot;:=&quot;,
	используемым здесь, поскольку первый устанавливает значение по
	умолчанию только если переменная не установлена, а последний
	устанавливает её, если переменная не установлена
	<emphasis>или</emphasis> обнулена.  Пользователь вполне может
	написать в своем файле <filename>rc.conf.local</filename>
	что-нибудь типа</para>

      <programlisting>doormand_flags=""</programlisting>

      <para>и тогда произойдет
	неуместная подстановка переменной с использованием &quot;:=&quot;,
	что переопределит намерения пользователя.  Переменная
	<literal>_enable</literal> является обязательной; значением
	по умолчанию должно быть &quot;:&quot;.</para>

      <note>
	<para>Новые сценарии следует добавлять без окончания
	  <filename>.sh</filename>.</para>
      </note>

      <sect2>
	<title>Контрольный список перед внесением изменений</title>

	<para>Перед тем, как отсылать порт со сценарием
	  <filename>rc.d</filename>, и тем более перед его коммитом,
	  сверьтесь со следующим контрольным списком, чтобы убедиться,
	  что порт для этого готов.</para>

	<procedure>
	  <step>
	    <para>Если это новый файл, заканчивается ли он на
	      <filename>.sh</filename>?  Если это так, то имя файла должно
	      быть изменено на <filename>file.in</filename>, поскольку
	      новые файлы <filename>rc.d</filename> не могут оканчиваться
	      на такое расширение.</para>
	  </step>

	  <step>
	    <para>Присутствует ли в файле тег
	      <literal>&dollar;FreeBSD&dollar;</literal>?</para>
	  </step>

	  <step>
	    <para>Соответствуют ли друг другу имя файла
	      (без <filename>.in</filename>), строка <literal>PROVIDE</literal>
	      и <literal>&dollar;</literal><replaceable>name</replaceable>?
	      Имя файла, совпадающее с <literal>PROVIDE</literal>, упрощает
	      отладку, особенно для проблем, связанных с &man.rcorder.8;.
	      Соответствие имени файла и
	      <literal>&dollar;</literal><replaceable>name</replaceable>
	      также упрощает понимание, какие переменные имеют отношение к
	      сценарию в <filename>rc.conf[.local]</filename>.  Последнее
	      также является тем, что вы могли бы назвать &quot;политикой&quot;
	      для всех новых сценариев, включая те, что входят в базовую
	      систему.</para>
	  </step>

	  <step>
	    <para>Содержит ли строка <literal>REQUIRE</literal> значение
	      LOGIN?  Это условие обязательно для сценариев, работающих не
	      из под суперпользователя.  Если сценарий запускается из-под
	      суперпользователя, то стоит ли его запускать до
	      <literal>LOGIN</literal>?  Если нет, то его следует запускать
	      после, так чтобы мы могли свободно сгруппировать локальные
	      сценарии в той точке &man.rcorder.8;, когда почти все сценарии
	      в базовой системе уже стартовали.</para>
	  </step>

	  <step>
	    <para>Запускает ли сценарий постоянную службу?  Если да, то он
	    должен иметь <literal>KEYWORD: shutdown</literal>.</para>
	  </step>

	  <step>
	    <para>Убедитесь в том, что в сценарии отсутствует
	      <literal>KEYWORD: FreeBSD</literal>.  Это перестало быть
	      нужным и нежелательно уже много лет.  Это также служит
	      индикатором того, что новый сценарий был скопирован со
	      старого, поэтому особое внимание должно быть уделено при
	      проверке.</para>
	  </step>

	  <step>
	    <para>Если сценарий использует интерпретируемый язык, такой
	      как <command>perl</command>, <command>python</command> или
	      <command>ruby</command>, то убедитесь, что значение
	      <varname>command_interpreter</varname> установлено
	      должным образом.  В противном случае</para>

	    <screen>&prompt.root; <userinput>service name stop</userinput></screen>

	    <para>возможно будет работать неправильно.  Смотрите &man.service.8;
	      для получения дополнительной информации.</para>
	  </step>

	  <step>
	    <para>Все ли вхождения <filename>/usr/local</filename> были
	      заменены на <literal>%%PREFIX%%</literal>?</para>
	  </step>

	  <step>
	    <para>Идет ли присвоение переменным значений по умолчанию
	      после <function>load_rc_config</function>?</para>
	  </step>

	  <step>
	    <para>Используются ли пустые строки при присвоении значений
	      по умолчанию?  Такие присвоения должны быть удалены, но
	      перепроверьте, что эти параметры задокументированы в
	      комментариях в начале файла.</para>
	  </step>

	  <step>
	    <para>Действительно ли в сценариях используются значения,
	      присвоенные переменным?</para>
	  </step>

	  <step>
	    <para>Являются ли параметры по умолчанию, перечисленные в
	      <replaceable>name</replaceable><varname>_flags</varname>,
	      обязательными?  Если это так, то их следует поместить
	      в <varname>command_args</varname>.  Параметр <option>-d</option>
	      здесь - это как красный флаг (прошу прощения за каламбур),
	      поскольку обычно он применяется для &ldquo;демонизации&ldquo;
	      процесса и поэтому на самом деле обязательный.</para>
	  </step>

	  <step>
	    <para>Никогда не включайте переменную
	      <replaceable>name</replaceable><varname>_flags</varname> в
	      <varname>command_args</varname> (и наоборот; в прочем, такая
	      ошибка встречается реже).</para>
	  </step>

	  <step>
	    <para>Запускает ли сценарий какой-либо код безусловно?  Это
	      нехорошо.  Обычно такие вещи могут/должны помещаться в
	      <function>start_precmd</function>.</para>
	  </step>

	  <step>
	    <para>Все логические условия должны использовать функцию
	      <function>checkyesno</function>.  Не пишите самописных
	      проверок для <literal>[Yy][Ee][Ss]</literal>, и так далее.</para>
	  </step>

	  <step>
	    <para>Если в сценарии выполняется цикл (например, ожидание
	      чего-либо перед стартом), используется ли счетчик для
	      завершения цикла?  Мы не хотим бесконечного ожидания загрузки
	      в случае возникновения ошибки.</para>
	  </step>

	  <step>
	    <para>Создает ли сценарий файлы или каталоги, которым нужны
	      особые права доступа?  Например, файл <filename>pid</filename>,
	      который должен принадлежать пользователю, из-под которого
	      запускается процесс.  Вместо традиционных команд
	      &man.touch.1;/&man.chown.8;/&man.chmod.1; подумайте об
	      использовании &man.install.1; с подходящими аргументами
	      командной строки, для того чтобы выполнить всю процедуру за
	      один шаг.</para>
	  </step>
	</procedure>
      </sect2>
    </sect1>

    <sect1 xml:id="users-and-groups">
      <title>Добавление пользователей и групп</title>

      <para>Некоторые порты требуют в установленной системе наличие
	определенного пользователя. Выберите свободный UID в диапазоне от 50
	до 999 и зарегистрируйте его в <filename>ports/UIDs</filename>
	(для пользователей) и/или в <filename>ports/GIDs</filename> (для
	групп).  Удостоверьтесь, что не используете UID, уже используемый
        системой или другими портами.</para>

      <para>Пожалуйста, включите в патч изменение для этих двух файлов,
	если вам требуется создать нового пользователя или группу для
	вашего порта.</para>

      <para>Затем вы сможете использовать в вашем <filename>Makefile</filename>
	переменные <varname>USERS</varname> и <varname>GROUPS</varname>,
	и пользователь автоматические создастся при установке порта.</para>

      <para>Текущий перечень зарезервированных UID и GID находится в
	<filename>ports/UIDs</filename> и <filename>ports/GIDs</filename>.
      </para>

    </sect1>

    <sect1 xml:id="requiring-kernel-sources">
      <title>Порты, требующие наличия исходных текстов ядра</title>

      <para>Некоторым портам (таким как загружаемые модули ядра) для
	компиляции нужны файлы с исходными текстами ядра.  Ниже указан
	корректный способ определения, установлены ли они пользователем:</para>

      <programlisting>.if !exists(${SRC_BASE}/sys/Makefile)
IGNORE=         requires kernel sources to be installed
.endif</programlisting>
    </sect1>

  </chapter>

  <chapter xml:id="plist">
    <title>Продвинутые практики <filename>pkg-plist</filename></title>
    <sect1 xml:id="plist-sub">
      <title>Изменение содержимого <filename>pkg-plist</filename> в зависимости
	от make-переменных</title>

      <para>Некоторые порты, в частности, порты <literal>p5-</literal>, должны
        менять содержимое своих файлов <filename>pkg-plist</filename> в
        зависимости от того, с какими параметрами они были отконфигурированы
        (или в зависимости от версии языка <literal>perl</literal> в случае
        портов <literal>p5-</literal>).  Чтобы облегчить этот
	процесс, любые вхождения ключевых слов <literal>%%OSREL%%</literal>,
	<literal>%%PERL_VER%%</literal> и <literal>%%PERL_VERSION%%</literal>
	в файле <filename>pkg-plist</filename> будут заменяться соответствующими
	значениями.  Значением <literal>%%OSREL%%</literal> является номер
	версии операционной системы (например, <literal>4.9</literal>).
	<literal>%%PERL_VERSION%%</literal> и <literal>%%PERL_VER%%</literal>
	обозначают полный номер версии <command>perl</command> (например,
	<literal>5.8.9</literal>).  Некоторые
	другие <literal>%%VARS%%</literal>, имеющие
	отношение к файлам документации порта, описаны в <link linkend="install-documentation">соответствующем разделе</link>.</para>

      <para>Если вам нужно сделать другие подстановки, вы можете указать в
	переменной <varname>PLIST_SUB</varname> список пар
	<literal>VAR=VALUE</literal>,
	и все вхождения <literal>%%VAR%%</literal>
	в файле <filename>pkg-plist</filename> будут заменяться на значение
	<replaceable>VALUE</replaceable>.</para>

      <para>Например, если у вас имеется порт, который устанавливает много
	файлов в каталог, зависящий от версии, вы можете задать нечто
	типа</para>

      <programlisting>OCTAVE_VERSION= 2.0.13
PLIST_SUB=	OCTAVE_VERSION=${OCTAVE_VERSION}</programlisting>

      <para>в файле <filename>Makefile</filename> и использовать
	<literal>%%OCTAVE_VERSION%%</literal> везде, где нужно указать
	номер версии в файле <filename>pkg-plist</filename>.  Таким образом,
	при обновлении порта вам не нужно будет менять десятки (а в некоторых
	случаях и сотни) строк в файле <filename>pkg-plist</filename>.</para>

      <para>Если ваш порт устанавливает файлы в соответствии с установленными
	в порту опциями, то обычным способом управления является добавление
	префиксов <literal>%%TAG%%</literal> для строк
	<filename>pkg-plist</filename> с добавлением этого
	<literal>TAG</literal> в переменную <varname>PLIST_SUB</varname>
	внутри <filename>Makefile</filename> со специальным значением
	<literal>@comment</literal>, которое указывает пакетным инструментам
	игнорировать эти строки:</para>

      <programlisting>.if defined(WITH_X11)
PLIST_SUB+=	X11=""
.else
PLIST_SUB+=	X11="@comment "
.endif</programlisting>

      <para>и в самом <filename>pkg-plist</filename>:</para>

      <programlisting>%%X11%%bin/foo-gui</programlisting>

      <para>Эта подстановка (также, как и добавление любых <link linkend="makefile-manpages">справочных страниц</link>) будет сделана
	между выполнением целей <buildtarget>pre-install</buildtarget> и
	<buildtarget>do-install</buildtarget>, посредством чтения файла
	<filename>PLIST</filename> и записью в файл
	<filename>TMPPLIST</filename>
	(по умолчанию это файл
	<filename>WRKDIR/.PLIST.mktmp</filename>).  Так
	что если ваш порт строит <filename>PLIST</filename> на лету, делайте
	это во время или до выполнения цели
	<buildtarget>pre-install</buildtarget>.  Кроме того, если вашему порту
	требуется отредактировать получающийся файл, делайте это в цели
	<buildtarget>post-install</buildtarget> изменением файла
	<filename>TMPPLIST</filename>.</para>

      <para>Другой способ изменения списка сборки порта основан на
	определении значений переменных <varname>PLIST_FILES</varname>,
	<varname>PLIST_DIRS</varname> и <varname>PLIST_DIRSTRY</varname>.
	Каждое из них рассматривается как перечень путей для записи в
        <filename>TMPPLIST</filename> содержимого
        <filename>PLIST</filename>.  Имена, перечисленные
	в <varname>PLIST_FILES</varname>, <varname>PLIST_DIRS</varname>
	и <varname>PLIST_DIRSTRY</varname> подвергаются подстановке
	<literal>%%VAR%%</literal>, как описано
        выше.  За исключением этого, имена из <varname>PLIST_FILES</varname>
        будут появляться в окончательном варианте перечня сборки без
	изменений, тогда как <literal>@dirrm</literal> и
	<literal>@dirrmtry</literal> будут соответственно предшествовать
	именам из <varname>PLIST_DIRS</varname> и
	<varname>PLIST_DIRSTRY</varname>.  Для того чтобы изменения
	вступили в силу, <varname>PLIST_FILES</varname>,
	<varname>PLIST_DIRS</varname> и <varname>PLIST_DIRSTRY</varname>
	должны задаваться до того, как будет
        записываться <filename>TMPPLIST</filename>, то
        есть в цели <buildtarget>pre-install</buildtarget> или ещё
        раньше.</para>
    </sect1>

    <sect1 xml:id="plist-cleaning">
      <title>Пустые каталоги</title>

      <sect2 xml:id="plist-dir-cleaning">
	<title>Очистка пустых каталогов</title>

      <para>Заставьте ваш порты удалять пустые каталоги при удалении.  Обычно это
	достигается добавлением строк <literal>@dirrm</literal> для всех
	каталогов, которые создаются этим портом.  Вам нужно удалить
	подкаталоги до того, как вы сможете удалить родительские
	каталоги.</para>

      <programlisting>
 :
lib/X11/oneko/pixmaps/cat.xpm
lib/X11/oneko/sounds/cat.au
 :
@dirrm lib/X11/oneko/pixmaps
@dirrm lib/X11/oneko/sounds
@dirrm lib/X11/oneko
      </programlisting>

      <para>Однако, иногда <literal>@dirrm</literal> будет выдавать ошибки,
	потому что другие порты используют тот же самый подкаталог.  Вы
	можете использовать <literal>@dirrmtry</literal> для удаления
	только пустых каталогов без выдачи предупреждений.</para>

      <programlisting>@dirrmtry share/doc/gimp</programlisting>

      <para>Эта команда не выведет никаких сообщений об ошибках и не вызовет
	аварийного завершения работы &man.pkg.delete.1;, даже если
	каталог <filename>${PREFIX}/share/doc/gimp</filename>
	не пуст из-за того, что другие порты установили сюда какие-то
	файлы.</para>
      </sect2>

      <sect2 xml:id="plist-dir-empty">
	<title>Создание пустых каталогов</title>

	<para>Пустым каталогам, создаваемым во время установки порта, нужно
	  особое внимание.  Они не будут созданы при установке пакета, потому
	  что пакеты содержат только файлы, а &man.pkg.add.1; создает для них
	  каталоги по мере надобности.  Чтобы убедиться, что пустой каталог
	  создается при установке пакета, добавьте эту строку в
	  <filename>pkg-plist</filename> перед соответствующей строкой
	  <literal>@dirrm</literal>:</para>

	<programlisting>@exec mkdir -p %D/share/foo/templates</programlisting>
      </sect2>

    </sect1>

    <sect1 xml:id="plist-config">
      <title>Конфигурационные файлы</title>

      <para>Если ваш порт устанавливает конфигурационные файлы в каталог
	<filename>PREFIX/etc</filename> (или куда-то еще),
	<emphasis>не</emphasis> делайте их простого перечисления в файле
	<filename>pkg-plist</filename>.  Это приведёт к тому, что по команде
	&man.pkg.delete.1; или при новой установке файлы,
	тщательно отредактированные и настроенные пользователем, будут
	уничтожены.</para>

      <para>Вместо этого установите файл(ы) с примерами с расширением
	<filename>filename.sample</filename>.
	Затем скопируйте файл с примером на место настоящего файла
	конфигурации, если таковой ещё не существует.  При деинсталляции
	удаляйте файл конфигурации только в том случае, если он идентичен
	файлу с расширением <filename>.sample</filename>.  Вам
	нужно управлять этим в <filename>Makefile</filename> и в
	<filename>pkg-plist</filename> (для установки из пакета).</para>

      <para>Пример части <filename>Makefile</filename>:</para>

      <programlisting>post-install:
	@if [ ! -f ${PREFIX}/etc/orbit.conf ]; then \
		${CP} -p ${PREFIX}/etc/orbit.conf.sample ${PREFIX}/etc/orbit.conf ; \
	fi</programlisting>

      <para>Добавьте по три строки в <filename>pkg-plist</filename> для
	каждого конфигурационного файла, как показано ниже:</para>

      <programlisting>@unexec if cmp -s %D/etc/orbit.conf.sample %D/etc/orbit.conf; then rm -f %D/etc/orbit.conf; fi
etc/orbit.conf.sample
@exec if [ ! -f %D/etc/orbit.conf ] ; then cp -p %D/%F %B/orbit.conf; fi</programlisting>

      <para>Данные строки являются упорядоченными.  На этапе удаления
	файл с примером сравнивается с рабочим конфигурационным файлом.
	Полное совпадение означает отсутствие каких-либо изменений в
	рабочем файле со стороны пользователя, и следовательно этот файл
	может быть безопасно удалён.  Так как файл с примером всё ещё
	должен существовать для сравнения, строка <literal>@unexec</literal>
	следует перед именем файла с примером конфигурации.  На этапе
	установки, если рабочий файл конфигурации отсутствует, он
	копируется из файла с примером.  Файл с примером обязательно
	должен быть установлен до операции копирования, поэтому строка
	<literal>@exec</literal> следует после имени файла с примером
	конфигурации.</para>

      <para>Для получения дополнительного отладочного вывода на экран
	можно временно удалить параметр <literal>-s</literal> из команды
	&man.cmp.1;.</para>

      <para>Для получения дополнительной инфорации по использованию
	<literal>%D</literal> и прочих маркеров подстановки обратитесь
	к странице Справочника &man.pkg.create.1;.</para>

      <para>Если существует действительно стоящая причина не устанавливать
	рабочий файл конфигурации по умолчанию, уберите строку
	<literal>@exec</literal> из <filename>pkg-plist</filename> и
	добавьте <link linkend="porting-message">сообщение</link>,
	указывающее на то, что пользователь обязан скопировать и
	отредактировать этот файл перед тем, как программное обеспечение
	начнёт работать.</para>
    </sect1>

      <sect1 xml:id="plist-dynamic">
	<title>Динамический или статический список упаковки</title>

	<para><emphasis>Статический список упаковки</emphasis> &mdash; это список
	  упаковки, который доступен в Коллекции Портов или как файл
	  <filename>pkg-plist</filename> (с подстановкой переменных или без
	  неё), или как встроенный в <filename>Makefile</filename> посредством
	  <varname>PLIST_FILES</varname>, <varname>PLIST_DIRS</varname>
	  и <varname>PLIST_DIRSTRY</varname>.
	  Даже если содержимое является автоматически порождаемым при помощи
	  инструмента или в результате выполнения цели в Makefile
	  <emphasis>до</emphasis> включения в Коллекцию Портов коммиттером,
	  то список всё ещё будет считаться статическим, поскольку его
	  можно узнать без необходимости скачивания или компиляции
	  дистрибутива.</para>

	<para><emphasis>Динамический список упаковки</emphasis> это список
	  упаковки, который получается во время компиляции порта и строится
	  на основе устанавливаемых файлов и каталогов.  Узнать такой список
	  невозможно до того, как исходный код портируемого приложения
	  будет скачен и скомпилирован, или после запуска
	  <literal>make clean</literal>.</para>

	<para>Хотя использование динамических список упаковки не запрещено,
	  сопровождающие должны использовать статические списки упаковки
	  везде, где это возможно, поскольку это позволяет пользователям
	  выполнять &man.grep.1; по доступным портам для обнаружения, например,
	  который порт устанавливает определенный файл.  Динамические списки
	  должны быть использованы в основном для сложных портов, для которых
	  изменения в списке упаковки кардинальным образом основаны на
	  необязательных возможностях порта (и, таким образом, делая
	  сопровождение статических списков упаковки невозможным), или портов,
	  которые изменяют список упаковки на основе версии используемого
	  им программного обеспечения (например, порты, которые порождают
	  документы при помощи <application>Javadoc</application>).</para>

	<para>Сопровождающим, которые предпочитают динамические списки
	  упаковки, рекомендуется добавлять в свои порты новую цель,
	  которая производит файл <filename>pkg-plist</filename>, чтобы
	  пользователи могли изучать содержимое.</para>

      </sect1>

  <sect1 xml:id="plist-autoplist">
    <title>Автоматическое создание списка упаковки</title>

    <para>Первым делом убедитесь, что ваш порт практически полностью
      завершён и осталось создать только <filename>pkg-plist</filename>.</para>

    <para>Далее создайте временное дерево каталогов, куда может быть
      установлен ваш порт, и установите все зависимости.</para>

    <screen>&prompt.root; <userinput>mkdir /var/tmp/`make -V PORTNAME`</userinput>
&prompt.root; <userinput>mtree -U -f `make -V MTREE_FILE` -d -e -p /var/tmp/`make -V PORTNAME`</userinput>
&prompt.root; <userinput>make depends PREFIX=/var/tmp/`make -V PORTNAME`</userinput></screen>

    <para>Сохраните структуру каталогов в новом файле.</para>

    <screen>&prompt.root; <userinput>(cd /var/tmp/`make -V PORTNAME` &amp;&amp; find -d * -type d) | sort &gt; OLD-DIRS</userinput></screen>

    <para>Создайте пустой файл <filename>pkg-plist</filename>:</para>

    <screen>&prompt.root; <userinput>:&gt;pkg-plist</userinput></screen>

    <para>Если ваш порт принимает во внимание <varname>PREFIX</varname> (а он
      должен это делать), то тогда вы можете установить порт и создать список
      упаковки.</para>

    <screen>&prompt.root; <userinput>make install PREFIX=/var/tmp/`make -V PORTNAME`</userinput>
&prompt.root; <userinput>(cd /var/tmp/`make -V PORTNAME` &amp;&amp; find -d * \! -type d) | sort &gt; pkg-plist</userinput></screen>

    <para>Кроме того, в список упаковки вы должны добавить все вновь
      созданные каталоги.</para>

    <screen>&prompt.root; <userinput>(cd /var/tmp/`make -V PORTNAME` &amp;&amp; find -d * -type d) | sort | comm -13 OLD-DIRS - | sort -r | sed -e 's#^#@dirrm #' &gt;&gt; pkg-plist</userinput></screen>

    <para>И наконец, вам нужно вручную отшлифовать список упаковки; его
      создание автоматизировано <emphasis>не полностью</emphasis>.  Страницы
      справочной системы должны быть перечислены в файле
      <filename>Makefile</filename> порта в переменных
      <varname>MAN<replaceable>n</replaceable></varname>, а не в списке
      упаковки.  Пользовательские конфигурационные файлы должны быть удалены
      или быть установлены как
      <filename>filename.sample</filename>.
      Файл <filename>info/dir</filename> включать в список не нужно, но
      должны быть добавлены соответствующие строчки
      <filename>install-info</filename>, так, как это описано в разделе о <link linkend="makefile-info">файлах в формате info</link>.  Все
      библиотеки, устанавливаемые портом, должны быть перечислены так, как
      это описано в разделе о <link linkend="porting-shlibs">динамических библиотеках</link>.</para>

    <para>Как альтернативу, можно использовать скрипт <command>plist</command>
      из <filename>/usr/ports/Tools/scripts/</filename> для автоматического
      построения списка упаковки.  Скрипт <filename>plist</filename> - это
      сценарий на <application>Ruby</application>, который автоматизирует
      большинство ручных операций, изложенных в предыдущем параграфе.</para>

      <para>Первый шаг такой же как выше: взять
      первые три строки,
      <command>mkdir</command>, <command>mtree</command> и
      <command>make depends</command>.  Затем собрать и установить
      порт:</para>

    <screen>&prompt.root; <userinput>make install PREFIX=/var/tmp/`make -V PORTNAME`</userinput></screen>

    <para>И позволить <command>plist</command> создать файл
      <filename>pkg-plist</filename>:</para>

    <screen>&prompt.root; <userinput>/usr/ports/Tools/scripts/plist -Md -m `make -V MTREE_FILE` /var/tmp/`make -V PORTNAME` &gt; pkg-plist</userinput></screen>

    <para>Список упаковки всё ещё должен быть подчищен вручную как описано
      выше.</para>

    <para>Для первоначального создания <filename>pkg-plist</filename> можно
      использовать другой инструмент <package>ports-mgmt/genplist</package>.  Как и с прочими
      автоматизированными инструментами, получаемый <filename>pkg-plist</filename>
      следует проверить и при необходимости отредактировать вручную.</para>
  </sect1>

  </chapter>

  <chapter xml:id="pkg-files">
    <title>Файлы <filename>pkg-*</filename></title>

  <para>Есть несколько приёмов работы с файлами
    <filename>pkg-*</filename>, которые мы ещё не
    описали, но они иногда могут быть очень кстати.</para>

    <sect1 xml:id="porting-message">
      <title><filename>pkg-message</filename></title>

      <para>Если вам нужно вывести сообщение для человека, устанавливающего
	приложение, то вы можете поместить сообщение в файл
	<filename>pkg-message</filename>.  Эта возможность часто оказывается
	полезной для вывода дополнительных шагов установки, которые нужно
	предпринять после выполнения команды &man.pkg.add.1;, или
	для вывода информации о лицензировании.</para>

      <para>Если должны выводиться некоторые строки о knobs времени построения
	или предупреждения, используйте <varname>ECHO_MSG</varname>.  Файл
	<filename>pkg-message</filename> только для послеустановочных шагов.
	Также следует иметь в виду различие между <varname>ECHO_MSG</varname>
	и <varname>ECHO_CMD</varname>.  Первое предназначено для вывода на
	экран информационного текста, а второе для конвейера команд:</para>

      <programlisting>update-etc-shells:
	@${ECHO_MSG} "updating /etc/shells"
	@${CP} /etc/shells /etc/shells.bak
	@( ${GREP} -v ${PREFIX}/bin/bash /etc/shells.bak; \
		${ECHO_CMD} ${PREFIX}/bin/bash) &gt;/etc/shells
	@${RM} /etc/shells.bak</programlisting>

      <note>
	<para>Файл <filename>pkg-message</filename> не нужно добавлять в
	  <filename>pkg-plist</filename>.  И он не будет автоматически
	  выводиться, если пользователь использует порт, а не пакет, так что
	  вы должны будете сами выводить его при выполнении цели
	  <buildtarget>post-install</buildtarget>.</para>
      </note>
    </sect1>

    <sect1 xml:id="pkg-install">
      <title><filename>pkg-install</filename></title>

      <para>Если при установке бинарного пакета по команде
	&man.pkg.add.1; вашему порту нужно выполнить какие-то
	дополнительные действия или команды, то вы можете сделать это с
	помощью скрипта <filename>pkg-install</filename>.  Этот скрипт будет
	автоматически добавлен к пакету, и будет дважды запускаться по
	команде &man.pkg.add.1;: первый раз в виде
	<literal>&dollar;{SH} pkg-install &dollar;{PKGNAME}
        PRE-INSTALL</literal>, а второй раз как <literal>&dollar;{SH} {PKGNAME}
        POST-INSTALL</literal>.
	Для распознавания того, в каком режиме запущен скрипт, можно
	использовать параметр <literal>&dollar;2</literal>.  Переменная
	окружения <envar>PKG_PREFIX</envar> будет принимать значение,
	соответствующее каталогу, в который устанавливается пакет.
	Дополнительная информация находится на странице Справочника о
	команде &man.pkg.add.1;.</para>

      <note>
	<para>Этот скрипт не запускается автоматически, если вы
	  устанавливаете порт командой <command>make install</command>.
	  Если же вам действительно необходимо его запустить, то запустите
	  его явно из файла <filename>Makefile</filename> порта строкой
	  вида <literal>PKG_PREFIX=&dollar;{PREFIX} &dollar;{SH} &dollar;
	  {PKGINSTALL}&dollar;{PKGNAME} PRE-INSTALL</literal>.</para>
      </note>
    </sect1>

    <sect1 xml:id="pkg-deinstall">
      <title><filename>pkg-deinstall</filename></title>

      <para>Этот скрипт вызывается при удалении пакета.</para>

      <para>Этот скрипт утилитой &man.pkg.delete.1; будет запускаться
        дважды.  Первый раз как <literal>&dollar;{SH} pkg-deinstall
        &dollar;{PKGNAME} DEINSTALL</literal>, а второй раз как
        <literal>&dollar;{SH} pkg-deinstall &dollar;{PKGNAME}
        POST-DEINSTALL</literal>.</para>
    </sect1>

    <sect1 xml:id="pkg-req">
      <title><filename>pkg-req</filename></title>

      <para>Если вашему порту нужно определять, должен ли он устанавливаться
	или нет, то вы можете создать скрипт <quote>необходимости</quote>
	<filename>pkg-req</filename>.  Он будет вызван автоматически
	в момент установки/удаления для определения того, должны ли они
	реально выполняться.</para>

      <para>Скрипт будет запущен в процессе установки командой
        &man.pkg.add.1;, как <literal>pkg-req
	&dollar;{PKGNAME} INSTALL</literal>.  В процессе удаления он
	будет запущен командой &man.pkg.delete.1; как
	<literal>pkg-req &dollar;{PKGNAME} DEINSTALL</literal>.</para>
    </sect1>


    <sect1 xml:id="pkg-names">
      <title xml:id="porting-pkgfiles">Изменение имён файлов
        <filename>pkg-*</filename></title>

      <para>Все имена файлов
        <filename>pkg-*</filename>
	определяются с помощью переменных, так что вы можете изменить их,
	если это нужно, в вашем файле <filename>Makefile</filename>.  Это
	особенно полезно, если вы используете одни и те же файлы
        <filename>pkg-*</filename>
	совместно между несколькими портами или
	пишете в один из вышеперечисленных файлов (в главе о <link linkend="porting-wrkdir">записи в каталоги, отличные от
	<varname>WRKDIR</varname></link> объяснено, почему не рекомендуется
	осуществлять запись непосредственно в файлы
        <filename>pkg-*</filename>.</para>

      <para>Вот список имён переменных и их значений по умолчанию.  (Значение
        <varname>PKGDIR</varname> по умолчанию равно
        <varname>${MASTERDIR}</varname>.)</para>

      <informaltable frame="none" pgwide="0">
        <tgroup cols="2">
          <thead>
	    <row>
	      <entry>Переменная</entry>

	      <entry>Значение по умолчанию</entry>
	    </row>
          </thead>

          <tbody>
	    <row>
	      <entry><varname>DESCR</varname></entry>
	      <entry><literal>${PKGDIR}/pkg-descr</literal></entry>
	    </row>

	    <row>
	      <entry><varname>PLIST</varname></entry>
	      <entry><literal>${PKGDIR}/pkg-plist</literal></entry>
	    </row>

	    <row>
	      <entry><varname>PKGINSTALL</varname></entry>
	      <entry><literal>${PKGDIR}/pkg-install</literal></entry>
	    </row>

	    <row>
	      <entry><varname>PKGREQ</varname></entry>
	      <entry><literal>${PKGDIR}/pkg-req</literal></entry>
	    </row>

	    <row>
	      <entry><varname>PKGMESSAGE</varname></entry>
	      <entry><literal>${PKGDIR}/pkg-message</literal></entry>
	    </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Пожалуйста, изменяйте значения этих переменных, а не
	переопределяйте <varname>PKG_ARGS</varname>.  Если вы измените
	значение переменных <varname>PKG_ARGS</varname>, то эти файлы при
	установке из порта будут установлены в каталог
	<filename>/var/db/pkg</filename> некорректно.</para>
    </sect1>

    <sect1 xml:id="using-sub-files">
      <title>Использование <varname>SUB_FILES</varname> и
	<varname>SUB_LIST</varname></title>

      <para>Переменные <varname>SUB_FILES</varname> и
	<varname>SUB_LIST</varname> подходят для задания в файлах порта
	динамических значений, таких как <varname>PREFIX</varname> установки
	в <filename>pkg-message</filename>.</para>

      <para>В переменной <varname>SUB_FILES</varname> указывается перечень
	файлов для автоматического изменения.  Каждый
	<replaceable>file</replaceable> из перечня <varname>SUB_FILES</varname>
	обязан иметь соответствующий
	<filename>file.in</filename>,
	присутствующий в <varname>FILESDIR</varname>.  Измененная версия
	будет создана в <varname>WRKDIR</varname>.  Файлы, определенные в
	качестве значения <varname>USE_RC_SUBR</varname> (или устаревшего
	<varname>USE_RCORDER</varname>), автоматически добавляются в
	<varname>SUB_FILES</varname>.  Для файлов
	<filename>pkg-message</filename>, <filename>pkg-install</filename>,
	<filename>pkg-deinstall</filename> и <filename>pkg-req</filename>
	устанавливается соответствующая переменная Makefile, указывающая на
	обработанную версию.</para>

      <para>Переменная <varname>SUB_LIST</varname> содержит перечень пар
	<literal>VAR=VALUE</literal>.  В каждом файле из
	<varname>SUB_FILES</varname> для каждой пары будет произведена
	замена <literal>%%VAR%%</literal> на <literal>VALUE</literal>.
	Некоторые общие пары определяются автоматически:
	<varname>PREFIX</varname>, <varname>LOCALBASE</varname>,
	<varname>DATADIR</varname>,
	<varname>DOCSDIR</varname>, <varname>EXAMPLESDIR</varname>,
	<varname>WWWDIR</varname> и <varname>ETCDIR</varname>.
	Любая строка, начинающаяся с <literal>@comment</literal>, будет
	удалена из конечного файла после подстановки переменной.</para>

      <para>В следующем примере в <filename>pkg-message</filename>
	будет сделана замена <literal>%%ARCH%%</literal> на системную
	архитектуру:</para>

      <programlisting>SUB_FILES=     pkg-message
SUB_LIST=      ARCH=${ARCH}</programlisting>

      <para>Обратите внимание, что в этом примере в <varname>FILESDIR</varname>
	обязательно существование файла <filename>pkg-message.in</filename>.
      </para>

      <para>Пример хорошего <filename>pkg-message.in</filename>:</para>

      <programlisting>Now it's time to configure this package.
Copy %%PREFIX%%/share/examples/putsy/%%ARCH%%.conf into your home directory
as .putsy.conf and edit it.</programlisting>

    </sect1>
  </chapter>

  <chapter xml:id="testing">
    <title>Тестирование вашего порта</title>

    <sect1 xml:id="make-describe">
      <title>Запуск <command>make describe</command></title>

      <para>Некоторые утилиты &os; для сопровождения портов, например,
        &man.portupgrade.1;, опираются на базу данных с именем
        <filename>/usr/ports/INDEX</filename>, в которой отслеживаются такие
        характеристики портов, как их зависимости.  Файл
        <filename>INDEX</filename> создаётся при помощи
        <filename>ports/Makefile</filename> верхнего уровня по команде
        <command>make index</command>, спускающейся в подкаталог каждого
        порта и выполняющей в нём <command>make describe</command>.  Таким
        образом, если выполнение <command>make describe</command> с
        каким-либо портом завершится неудачно, то никому не удастся создать
        <filename>INDEX</filename>, при этом много людей вскоре станут
        несчастны.</para>

      <note>
        <para>Возможность генерировать этот файл очень важна вне зависимости
          от того, какие параметры присутствуют в
          <filename>make.conf</filename>, поэтому, пожалуйста, избегайте,
          таких вещей, как использование декларации
          <literal>.error</literal>, когда (к примеру) требования к
          зависимости не было удовлетворено.  (Смотрите
	  <xref linkend="dads-dot-error"/>.)</para>
      </note>

      <para>Если команда <command>make describe</command> выдаёт строчку, а
        не ошибку, то для вас это пройдёт безболезненно.  Обратитесь к файлу
        <filename>bsd.port.mk</filename>, чтобы выяснить значение выдаваемых
        строк.</para>

      <para>Заметьте также, что запуск последней версии
        <command>portlint</command> (как указано в следующем разделе)
        приведёт к автоматическому запуску команды
        <command>make describe</command>.</para>
    </sect1>

    <sect1 xml:id="testing-portlint">
      <title>Portlint</title>

      <para>Проверьте свою работу командой <link linkend="porting-portlint"><command>portlint</command></link>
        перед тем, как её отослать или перенести в дерево портов.
        <command>portlint</command> предупреждает вас о многих
        распространённых ошибках, как функциональных, так и стилистических.
        Для нового (или скопированного внутри хранилища) порта самым
        подходящим является запуск <command>portlint -A</command>; для
        уже существующего порта достаточно будет запустить
        <command>portlint -C</command>.</para>

      <para>Так как для обнаружения ошибок <command>portlint</command>
        использует эвристические методы, то им могут выдаваться и ошибочные
        предупреждения.  Кроме того, время от времени нечто, отмечаемое как
        некорректность, из-за ограничений механизма создания портов не может
        быть сделано никак иначе.  Если вы сомневаетесь, то лучше всего
        спросить в &a.ports;.</para>
    </sect1>

    <sect1 xml:id="testing-porttools">
      <title>Port Tools</title>

      <para>Программа <package>ports-mgmt/porttools</package>
	входит в состав Коллекции Портов.</para>

      <para><command>port</command> является сценарием переднего плана,
	который может упростить вам задачу тестирования.  Если вы хотите
	проверить новый порт или обновить существующий, то вы можете
	использовать <command>port test</command> для проверки вашего порта,
	включая проверку <link linkend="testing-portlint"><command>portlint</command></link>.  Эта
	команда также находит и отображает любые файлы, которые невключенные
	в <filename>pkg-plist</filename>.  Смотрите следующий пример:</para>

      <screen>&prompt.root; <userinput>port test /usr/ports/net/csup</userinput></screen>
    </sect1>

    <sect1 xml:id="porting-prefix">
      <title><varname>PREFIX</varname> и <varname>DESTDIR</varname></title>

      <para>Переменная <varname>PREFIX</varname> определяет, куда будет
	установлен порт.  По умолчанию это <filename>/usr/local</filename>,
	но может меняться пользователем на собственный путь, такой как
	<filename>/opt</filename>.  В вашем порту значение этой переменной
	должно учитываться.</para>

      <para>Если пользователь установил переменную <varname>DESTDIR</varname>,
	то она определяет полное альтернативное окружение, обычно, это jail
	или установленная система, смонтированная в месте, отличном от
	<filename>/</filename>.  На самом деле порт устанавливается в
	<filename>DESTDIR/PREFIX</filename>
	и регистрируется в базе данных пакетов в
	<filename>DESTDIR/var/db/pkg</filename>.
	Поскольку управление <varname>DESTDIR</varname> производится
	автоматически инфраструктурой портов с помощью &man.chroot.8;, вам
	не нужны никакие изменения или проявление особой осторожности
	при написании <varname>DESTDIR</varname>-совместимых портов.</para>

      <para>Значение переменной <varname>PREFIX</varname> будет установлено
	в <varname>LOCALBASE</varname> (по умолчанию
	<filename>/usr/local</filename>).  Если
	задана переменная <varname>USE_LINUX_PREFIX</varname>, то
	<varname>PREFIX</varname> примет значение <varname>LINUXBASE</varname>
	(по умолчанию <filename>/compat/linux</filename>).</para>

      <para>Избегание явно прописываемых путей <filename>/usr/local</filename>
	в исходном коде сделает порт гораздо более гибким и способным
	удовлетворить потребности других серверов.  Часто этого можно
	добиться простой заменой строк <filename>/usr/local</filename>
	в различных файлах <filename>Makefile</filename> внутри порта на
        <literal>&dollar;{PREFIX}</literal>.  Эта переменная
        автоматически передаётся далее на каждом этапе построения и
        установки.</para>

      <para>Проверьте, что ваше приложение не устанавливает чего-либо в
        каталог <filename>/usr/local</filename> вместо
        <varname>PREFIX</varname>.  Наличие явно указанных путей можно быстро
	проверить следующим образом:</para>

      <screen>&prompt.root; <userinput>make clean; make package PREFIX=/var/tmp/`make -V PORTNAME`</userinput></screen>

      <para>Если что-то было установлено за пределами
        <varname>PREFIX</varname>, то процесс создания пакета сообщит об
        отсутствии файлов.</para>

      <para>Этот тест не найдет явно указанных путей внутри файлов порта
	и не проверит корректность использования <varname>LOCALBASE</varname>
	в качестве ссылки на файлы из других портов.  Порт, временно
	установленный в <filename>/var/tmp/`make -V PORTNAME`</filename>,
	следует проверять на работоспособность, чтобы убедиться в отсутствии
	проблем с путями.</para>

      <para>Переменная <varname>PREFIX</varname> не должна задаваться явно в
	файле <filename>Makefile</filename> порта.  Пользователи при установке
	порта могут задать в <varname>PREFIX</varname> свое собственное
	место, и порт должен учитывать это значение.</para>

      <para>Обратитесь к программам/файлам из других портов с
	переменными, перечисленными выше, без указания явных маршрутов.
	Например, если ваш порт требует, чтобы макрос <literal>PAGER</literal>
	являлся полным путем утилиты <command>less</command>, не используйте
	строковый путь <filename>/usr/local/bin/less</filename>.  Вместо
	этого используйте <literal>&dollar;{LOCALBASE}</literal>:</para>

      <programlisting>-DPAGER=\"&dollar;{LOCALBASE}/bin/less\"</programlisting>

      <para>Путь с использованием <varname>LOCALBASE</varname> имеет больше
	шансов оставаться работоспособным, если системный администратор
	переместил всё дерево <filename>/usr/local</filename> куда-то в другое
        место.</para>
    </sect1>

    <sect1 xml:id="testing-tinderbox">
      <title>Tinderbox</title>

      <para>Если вы алчный контрибутор портов, то вы можете захотеть
	взглянуть на <application>Tinderbox</application>.  Это мощная
	система построения и тестирования портов, основанная на сценариях,
	используемых в <link linkend="build-cluster">Pointyhat</link>.
	<application>Tinderbox</application> можно установить, используя
	порт <package>ports-mgmt/tinderbox</package>.
	Обязательно прочитайте поставляемую документацию, поскольку
	конфигурация не является тривиальной.</para>

      <para>Для получения подробностей посетите <link xlink:href="http://tinderbox.marcuscom.com/">вебсайт Tinderbox</link>.</para>

    </sect1>
  </chapter>

  <chapter xml:id="port-upgrading">
    <title>Обновление отдельного порта</title>

    <para>Если вы заметите, что ваш порт устарел по сравнению с последней
      авторской версией, первым делом вы должны получить самую
      последнюю версия порта.  Вы можете найти их в каталоге
      <filename>ports/ports-current</filename> на зеркальных FTP-серверах &os;.
      Однако если вы работаете с достаточно большим количеством портов,
      наверное, будет проще использовать
      <application>Subversion</application> или &man.portsnap.8; для
      поддержания всей коллекции портов в актуальном состоянии, как это
      описано в <link xlink:href="&url.books.handbook;/ports-using.html">
      Руководстве</link>.  К тому же это даст возможность отслеживать все
      зависимости портов.</para>

    <para>На следующем шаге необходимо выяснить, нет ожидает ли уже это
      обновление своей очереди.  Для этого у вас есть две возможности.
      Существует интерфейс к <link xlink:href="http://www.FreeBSD.org/cgi/query-pr-summary.cgi?query">базе
      данных сообщений о проблемах FreeBSD (PR)</link> (известной также как
      <literal>GNATS</literal>) с поисковыми возможностями.  Выберите из
      выпадающего списка <literal>ports</literal> и введите название
      порта.</para>

    <para>Однако иногда люди забывают поместить название порта в поле
      Synopsis в точном виде.  В таком случае вы можете воспользоваться
      <link linkend="portsmon">Системой мониторинга портов
      FreeBSD</link> (которая известна также как
      <literal>portsmon</literal>).  В рамках этой системы делается попытка
      классифицировать PR, касающиеся портов, по имени порта.  Для поиска
      PR, относящихся к определённому порту, используйте механизм <link xlink:href="http://portsmon.FreeBSD.org/portoverview.py">Просмотра
      по одному порту</link>.</para>

    <para>Если таких отложенных PR не существует, то на следующем этапе
      следует послать сообщение электронной почты человеку, поддерживающему
      порт, который выдаётся по команде <command>make maintainer</command>.
      Этот человек может уже работать над обновлением, или иметь
      причину не обновлять порт прямо сейчас (например, из-за проблем со
      стабильностью функционирования новой версии);
      вам нет нужды дублировать их работу.  Заметьте, что неподдерживаемые
      порты перечисляются с адресом сопровождающего
      <literal>ports@FreeBSD.org</literal>, который является всего лишь
      адресом общего списка рассылки, так что отправка туда сообщений,
      скорее всего, в данном случае не поможет.</para>

    <para>Если сопровождающий просит вас выполнить обновление, либо
      сопровождающий отсутствует, то у вас появляется шанс помочь &os;,
      приготовив обновление самим!  Пожалуйста, делайте это с использованием
      команды &man.diff.1; в основной системе.</para>

    <para>Чтобы создать подходящий <command>diff</command> для одного патча,
      скопируйте файл, который нужно пропатчить, в
      <replaceable>something.orig</replaceable>, сохраните ваши изменения в
      <replaceable>something</replaceable>, а затем создайте ваше патч:</para>

    <informalexample>
      <screen>&prompt.user; <userinput>diff -u something.orig something &gt; something.diff</userinput></screen>
    </informalexample>

    <para>В противном случае, вам следует воспользоваться методом
      <command>svn diff</command> (<xref linkend="svn-diff"/>), либо
      скопировать содержимое порта в
      отдельный каталог и применить результат рекурсивной команды &man.diff.1;
      между новым и старым каталогами порта (например, если каталог с
      модифицированным портом называется <filename>superedit</filename>,
      а оригинальный, совпадающий с находящимся в нашем дереве портов,
      <filename>superedit.bak</filename>, то сохраните результат выполнения
      команды <command>diff -ruN superedit.bak superedit</command>).
      Подойдёт как унифицированный, так и контекстный дифф, однако коммиттеры
      портов обычно предпочитают унифицированный формат.  Отметьте
      использование опции <literal>-N</literal>&mdash;это одобряемый способ
      заставить diff корректно работать в случае добавления новых файлов или
      удаления старых.  Перед тем, как посылать нам diff-файл, пожалуйста,
      проверьте его, чтобы убедиться в значимости всех внесённых
      изменений.  (В частности, убедитесь, что вы очистили рабочие каталоги
      командой <command>make clean</command>).</para>

    <para>Для упрощения повторяющихся операций с файлами заплаток
      вы можете воспользоваться скриптом
      <filename>/usr/ports/Tools/scripts/patchtool.py</filename>.  Перед тем,
      как его запускать, пожалуйста, прочтите
      <filename>/usr/ports/Tools/scripts/README.patchtool</filename>.</para>

    <para>Если порт никем не поддерживается, а вы активно его используете,
      пожалуйста, подумайте над тем, чтобы добровольно стать его
      сопровождающим.  Во &os; имеется более 4000 портов без поддержки, и это
      как раз та область, где всегда нужны добровольцы.  (Детальное описание
      обязанностей сопровождающего можно найти в разделе в <link xlink:href="&url.books.developers-handbook;/policies.html#POLICIES-MAINTAINER">
      Руководстве Разработчика</link>.)</para>

    <para>Лучше всего послать нам diff-файл, включив его в посылку по команде
      &man.send-pr.1; (категория <literal>ports</literal>).  Если вы
      сопровождаете порт,
      обязательно поместите текст <literal>[maintainer update]</literal> в
      начале строки описания и задайте в поле <quote>Class</quote>
      вашего PR строчку <literal>maintainer-update</literal>.
      В противном случае в поле <quote>Class</quote> вашего PR должно быть
      указано <literal>change-request</literal>.  Будьте добры, в сообщении
      отметьте все добавленные или удалённые файлы, так как они будут
      непосредственно указаны &man.svn.1; при выполнении операции коммита.
      Если diff-файл имеет размер, превышающий 20КБ, сожмите его и обработайте
      утилитой uuencode; в противном случае просто включите его как есть
      в PR.</para>

    <para>Прежде чем пользоваться &man.send-pr.1; вы должны просмотреть раздел
      о <link xlink:href="&url.articles.problem-reports;/pr-writing.html">Написании
      сообщений о проблемах</link> в статье о Сообщениях об ошибках; он
      содержит гораздо больше информации о том, как писать полезные сообщения
      о проблемах.</para>

    <important>
      <para>Если ваше обновление вызвано соображениями информационной
        безопасности или наличием серьёзных ошибок в имеющемся порте,
        пожалуйста, оповестите &a.portmgr; о необходимости немедленного
        перепостроения и повторного распространения пакета вашего порта.
        В противном случае ничего не подозревающие пользователи &man.pkg.add.1;
        будут продолжать устанавливать старую версию по команде
        <command>pkg_add -r</command> в течение ещё нескольких недель.</para>
    </important>

    <note>
      <para>Повторяем еще раз - для посылки обновлений существующих портов
	используйте утилиту &man.diff.1;, а не &man.shar.1;!  Это поможет
	понять коммиттерам портов, что именно было изменено.</para>
    </note>

    <para>Теперь, когда вы проделали всё это, вам может понадобиться
      прочесть о том, как поддерживать актуальное состояние, в <xref linkend="keeping-up"/>.</para>

    <sect1 xml:id="svn-diff">
      <title>Использование <literal>SVN</literal> для создания патчей</title>

      <para>По возможности присылайте исправления в формате &man.svn.1; diff;
	&mdash; в таком виде их проще использовать по сравнению с разницей между
	<quote>старым и новым</quote> каталогами. К тому же, вам проще
	увидеть ваши изменения и обновить их в случае, если что-нибудь
	изменилось в Коллекции Портов с тех пор, как вы начали работу, пока вы
	не отправите ваши изменения, либо если коммиттер попросит вас
	исправить что-то еще.</para>

      <screen>&prompt.user; <userinput>cd ~/my_wrkdir</userinput> <co xml:id="my-wrkdir"/>
&prompt.user; <userinput>svn co https://svn0.us-west.FreeBSD.org/ports/head/dns/pdnsd</userinput> <co xml:id="svn-FreeBSD-org"/>
&prompt.user; <userinput>cd ~/my_wrkdir/pdnsd</userinput></screen>

      <calloutlist>
	<callout arearefs="my-wrkdir">
	  <para>Это может быть где угодно; место, в котором производится
	    построение портов, не привязано к
	    <filename>/usr/ports/</filename>.</para>
	</callout>

	<callout arearefs="svn-FreeBSD-org">
	  <para><link xlink:href="https://svn0.us-west.FreeBSD.org/">svn0.us-west.FreeBSD.org</link>
	    &mdash; это общедоступный <literal>SVN</literal> сервер.
	    Выберите ближайшее зеркало и проверьте сертификат
	    зеркалирующего сервера на наличие в перечне <link xlink:href="&url.books.handbook;/svn-mirrors.html">зеркалирующих
	    сайтов Subversion</link>.</para>
	</callout>
      </calloutlist>

      <para>Находясь в рабочем каталоге, вносите любые изменения, которые
	обычно делают для порта.  При добавлении или удалении файла
	используйте <command>svn</command> для отслеживания этих
	изменений:</para>

      <screen>&prompt.user; <userinput>svn add new_file</userinput>
&prompt.user; <userinput>svn remove deleted_file</userinput></screen>

      <para>Убедитесь, что вы проверяете порт в соответствии с рекомендуемым
	порядком проверки, описанным в <xref linkend="porting-testing"/> и
	<xref linkend="porting-portlint"/>.</para>

      <screen>&prompt.user; <userinput>svn status</userinput>
&prompt.user; <userinput>svn update</userinput> <co xml:id="svn-update"/></screen>

      <calloutlist>
	<callout arearefs="svn-update">
	  <para>Эта команда попытается выполнить слияние различий между
	    вашим патчем и текущим содержимым в SVN; внимательно проверьте
	    полученный вывод.  Буква перед названием каждого файла означает
	    тип изменения, сделанного с этим файлом.  Для получения полного
	    списка смотрите <xref linkend="table-svn-up"/>.</para>
	</callout>
      </calloutlist>

      <table pgwide="1" frame="none" xml:id="table-svn-up">
	<title>Префиксы файлов для <literal>SVN</literal> update</title>

	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry>U</entry>

	      <entry>Файл обновлен без проблем.</entry>
	    </row>

	    <row>
	      <entry>G</entry>

	      <entry>Файл обновлен без проблем (вы увидите это только
		при работе с удаленным репозиторием).</entry>
	    </row>

	    <row>
	      <entry>M</entry>

	      <entry>Файл с локальными изменениями, слияние выполнено
		без конфликтов.</entry>
	    </row>

	    <row>
	      <entry>C</entry>

	      <entry>Файл с локальными изменениями, слияние выполнено
		с конфликтами.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>Если в результате выполнения <literal>svn update</literal>
	вы получили <literal>C</literal>, то это означает, что что-то
	изменилось в репозитории SVN и &man.svn.1; не смогла выполнить
	слияние ваших локальных изменений с полученными из репозитория.
	В любом случае никогда не помешает просмотреть изменения,
	поскольку &man.svn.1; ничего не знает о том, каким должен быть
	порт, поэтому эта команда может (и, вероятно, будет) делать
	слияние тех изменений, которые не имеют смысла.</para>

      <para>Последним шагом является создание унифицированного &man.diff.1;
	для файлов относительно SVN:</para>

      <screen>&prompt.user; <userinput>svn diff &gt; ../`basename ${PWD}`.diff</userinput></screen>

      <note>
	<para>Информация о любых удаляемых файлов должна быть явным
	  образом указана в PR, поскольку необходимость в удалении
	  файла для коммиттера может быть неочевидна.</para>
      </note>

      <para>Присылайте свои патчи в соответствии с руководством, описанном в
	<xref linkend="port-upgrading"/>.</para>
    </sect1>

    <sect1 xml:id="moved-and-updating-files">
      <title>Файлы <filename>UPDATING</filename> и
	<filename>MOVED</filename></title>

      <para>Если при обновлении порта требуются специальные шаги, такие как
	изменение файлов конфигурации или запуск специальной программы,
	то вам следует это задокументировать в файле
	<filename>/usr/ports/UPDATING</filename>.  Формат записи в этом
	файле приводится ниже:</para>

      <programlisting>YYYYMMDD:
  AFFECTS: users of portcategory/portname
  AUTHOR: Your name &lt;Your email address&gt;

  Special instructions</programlisting>

      <para>Если вы включаете точные инструкции portmaster или portupgrading,
	пожалуйста, убедитесь в правильном экранировании символов внутри
	командной оболочки.</para>

      <para>Файл <filename>/usr/ports/MOVED</filename> содержит записи
	об удалённых или перемещённых портах.  Каждая строка в этом
	файле состоит из полей: название порта, место, куда он был
	перемещён, дата и причина перемещения.  Если порт был удалён,
	то поле, указывающее новое место, может оставаться незаполненным.
	Поля должны разделяться символом <literal>|</literal> (pipe),
	как это показано ниже:</para>

      <programlisting>old name|new name (blank for deleted)|date of move|reason</programlisting>

      <para>Дату следует вводить в формате <literal>YYYY-MM-DD</literal>.
	Новые записи следует добавлять в конец файла в хронологическом
	порядке.</para>

      <para>Если порт был перемещён, но в дальнейшем восстановлен на
	прежнем месте, удалите в этом файле строку, содержащую
	информацию о перемещении.</para>

      <para>Полученные изменения можно проверить командой
	<command>Tools/scripts/MOVEDlint.awk</command>.</para>
    </sect1>
  </chapter>

  <chapter xml:id="security">
    <title>Безопасность портов</title>

    <sect1 xml:id="security-intro">
      <title>Почему безопасность так важна</title>

      <para>Ошибки в программном обеспечении появляются случайно.  Возможно,
	самые опасные из них те, что создают уязвимости безопасности.  С
	технической точки зрения подобные уязвимости должны быть закрыты
	путем исправления вызывающих их ошибок.  Тем не менее, политики
	обработки несущественных ошибок и уязвимостей очень различаются.
      </para>

      <para>Обычная небольшая ошибка затрагивает только тех пользователей,
	которые задействуют некоторые комбинации настроек, активирующие эту
	ошибку.  Разработчик в конечном счете выпустит патч, а зачтем новую
	версию программного обеспечения, свободного от ошибки, но большинство
	пользователей не посчитают нужным сразу же произвести обновление,
	поскольку эта ошибка никогда у них не проявлялась.  Критическая
	ошибка, которая может приводить к потере данных, представляет
	серьезную проблему.  Тем не менее, предусмотрительные пользователи
	знают, что большинство возможных происшествий, и среди них программные
	ошибки, скорее всего приводят к потере данных, поэтому они выполняют
	резервное копирование важных данных; дополнительно, критическая
	ошибка будет обнаружена очень скоро.</para>

      <para>С уязвимостью безопасности всё иначе.  Во-первых, она может
	сохраняться необнаруженной целые годы, потому что чаще всего не
	вызывает ошибок в работе.  Во-вторых, компания злоумышленников
	может использовать ее для получения неавторизованного доступа к
	уязвимой системе, уничтожить или подменить важные данные; в худшем
	случае пользователь даже не заметит нанесенный урон.  В-третьих,
	взлом уязвимой системы часто упрощает задачу проникновения атакующих
	в другие системы, которые не могут быть скомпрометированы иначе.
	Таким образом, устранение уязвимости как таковой недостаточно:
	следует разослать всем заинтересованным уведомления в наиболее
	понятной и исчерпывающей форме, что позволит оценить риск и
	предпринять подходящие меры.</para>
    </sect1>

    <sect1 xml:id="security-fix">
      <title>Исправление уязвимостей безопасности</title>

      <para>Что касается портов и пакетов, уязвимость безопасности
	изначально может появиться в исходном дистрибутиве или файлах
	порта.  В первом случае, разработчик исходного программного
	обеспечения скорее всего сразу же выпустит патч или новую версию,
	и вам лишь понадобится сразу обновить порт в соответствии с
	исправлением автора.  Если исправление по какой-то причине
	задерживается, вам следует либо <link linkend="dads-noinstall">пометить
	порт как <varname>FORBIDDEN</varname></link>, либо добавить в порт
	ваш собственный патч.  В случае уязвимости порта просто исправьте
	этот порт как можно скорее.  В любом случае нужно следовать
	<link linkend="port-upgrading">стандартной процедуре отправки вашего
	изменения</link>, если вы не обладаете правами на коммит изменения
	непосредственно в дерево портов.</para>

      <important>
	<para>Быть коммиттером портов недостаточно для коммита произвольного
	  порта.  Помните, что обычно у портов есть сопровождающие, мнение
	  которых вы должны учитывать.</para>
      </important>

      <para>Пожалуйста, убедитесь, что ревизия порта после закрытия
	уязвимости увеличена.  Вот как пользователи, обновляющие
	установленные пакеты на постоянной основе, увидят, что им нужно
	запустить обновление.  Кроме того, новый пакет будет собран и
	распространен через FTP и WWW зеркала, замещая уязвимый.
	Если в процессе исправления уязвимости не было изменено значение
	<varname>PORTVERSION</varname>, то должно быть увеличено значение
	<varname>PORTREVISION</varname>.  Вам следует увеличить значение
	<varname>PORTREVISION</varname> после добавления в порт файла с
	патчем, но не когда вы обновили порт до последней версии
	программного обеспечения, попутно затронув при этом
	<varname>PORTVERSION</varname>.  За дальнейшей информацией
	обращайтесь к
	<link linkend="makefile-naming-revepoch">соответствующему
	разделу</link>.</para>
    </sect1>

    <sect1 xml:id="security-notify">
      <title>Обеспечение сообщества информацией</title>

      <sect2 xml:id="security-notify-vuxml-db">
	<title>База данных VuXML</title>

	<para>Очень важным и первостепенным шагом при действии как можно
	  раньше после раскрытия уязвимости является уведомление сообщества
	  пользователей порта об опасности.  Такие уведомления служат двум
	  целям.  Во-первых, в случае действительно серьезной угрозы, будет
	  посоветовано применить мгновенное воздействие.  Например, остановить
	  затрагиваемый сетевой сервис или даже удалить порт целиком,
	  пока уязвимость не будет устранена.  Во-вторых, масса
	  пользователей имеет тенденцию обновлять установленные пакеты только от
	  случая к случаю.  Из уведомления они узнают, что
	  <emphasis>должны</emphasis> обновить пакет без промедления сразу
	  же после появления исправленной версии.</para>

        <para>Учитывая огромное число портов в дереве, невозможно по
	  каждому случаю выпускать бюллетень безопасности без создания
	  флуда и потери внимания сообщества к моменту появления
	  действительно серьезных причин.  Поэтому уязвимости безопасности,
	  обнаруженные в портах, записываются в <link xlink:href="http://vuxml.freebsd.org/">базу данных FreeBSD VuXML</link>.
	  Члены Команды Офицеров Безопасности также отслеживают её на
	  предмет появления вопросов, требующих их вмешательства.</para>

	<para>Если вы обладаете правами коммиттера, вы можете сам обновить
	  базу данных VuXML.  Так вы поможете Команде Офицеров Безопасности
	  и своевременно пошлете ценную информацию сообществу.  Тем не
	  менее, если вы не являетесь коммиттером или верите, что нашли
	  исключительно серьезную уязвимость, то не
	  задумываясь свяжитесь с Командой Офицеров Безопасности напрямую
	  как это описано на странице <link xlink:href="http://www.freebsd.org/security/#how">информационной
	  безопасности FreeBSD</link>.</para>

	<para>База данных VuXML является
	  документом XML.  Его исходный файл <filename>vuln.xml</filename>
	  содержится прямо внутри порта <package>security/vuxml</package>.  Поэтому полное имя
	  пути к файлу будет
	  <filename>PORTSDIR/security/vuxml/vuln.xml</filename>.
	  Каждый раз, при обнаружении вами в порте уязвимости безопасности
	  добавьте об этом запись в этот файл.  Пока вы не знакомы с VuXML,
	  лучшее, что вы можете сделать, это найти существующую запись,
	  подпадающую под ваш случай, затем скопировать ее и использовать
	  в качестве шаблона.</para>
      </sect2>

      <sect2 xml:id="security-notify-vuxml-intro">
	<title>Короткое вступление в VuXML</title>

	<para>В совокупности XML является очень сложным форматом, и его
	  описание выходит далеко за рамки
	  этой книги.  Тем не менее, для достижения основного понимания
	  структуры записи VuXML вам понадобится всего лишь понять теги.
	  Имена тегов XML обрамляются в угловые скобки.  Каждый открывающий
	  &lt;tag&gt; должен иметь совпадающий закрывающий &lt;/tag&gt;.
	  Теги могут быть вложенными.  При вложенности внутренние теги
	  должны быть закрыты до закрытия внешних.  Существует иерархия
	  тегов, т.е. более сложные правила вкладывания тегов.  Это
	  похоже на HTML.  Основное отличие в расширяемости XML,
	  т.е. в определении собственных тегов.  Из-за своей характерной
	  структуры XML придает форму разрозненным данным.  В частности,
	  XML подходит для разметки описаний уязвимостей безопасности.</para>

	<para>Теперь рассмотрим настоящую запись VuXML:</para>

	<programlisting>&lt;vuln vid="f4bc80f4-da62-11d8-90ea-0004ac98a7b9"&gt; <co xml:id="co-vx-vid"/>
  &lt;topic&gt;Several vulnerabilities found in Foo&lt;/topic&gt; <co xml:id="co-vx-top"/>
  &lt;affects&gt;
    &lt;package&gt;
      &lt;name&gt;foo&lt;/name&gt; <co xml:id="co-vx-nam"/>
      &lt;name&gt;foo-devel&lt;/name&gt;
      &lt;name&gt;ja-foo&lt;/name&gt;
      &lt;range&gt;&lt;ge&gt;1.6&lt;/ge&gt;&lt;lt&gt;1.9&lt;/lt&gt;&lt;/range&gt; <co xml:id="co-vx-rng"/>
      &lt;range&gt;&lt;ge&gt;2.*&lt;/ge&gt;&lt;lt&gt;2.4_1&lt;/lt&gt;&lt;/range&gt;
      &lt;range&gt;&lt;eq&gt;3.0b1&lt;/eq&gt;&lt;/range&gt;
    &lt;/package&gt;
    &lt;package&gt;
      &lt;name&gt;openfoo&lt;/name&gt; <co xml:id="co-vx-nm2"/>
      &lt;range&gt;&lt;lt&gt;1.10_7&lt;/lt&gt;&lt;/range&gt; <co xml:id="co-vx-epo"/>
      &lt;range&gt;&lt;ge&gt;1.2,1&lt;/ge&gt;&lt;lt&gt;1.3_1,1&lt;/lt&gt;&lt;/range&gt;
    &lt;/package&gt;
  &lt;/affects&gt;
  &lt;description&gt;
    &lt;body xmlns="http://www.w3.org/1999/xhtml"&gt;
      &lt;p&gt;J. Random Hacker reports:&lt;/p&gt; <co xml:id="co-vx-bdy"/>
      &lt;blockquote
        cite="http://j.r.hacker.com/advisories/1"&gt;
        &lt;p&gt;Several issues in the Foo software may be exploited
          via carefully crafted QUUX requests.  These requests will
          permit the injection of Bar code, mumble theft, and the
          readability of the Foo administrator account.&lt;/p&gt;
      &lt;/blockquote&gt;
    &lt;/body&gt;
  &lt;/description&gt;
  &lt;references&gt; <co xml:id="co-vx-ref"/>
    &lt;freebsdsa&gt;SA-10:75.foo&lt;/freebsdsa&gt; <co xml:id="co-vx-fsa"/>
    &lt;freebsdpr&gt;ports/987654&lt;/freebsdpr&gt; <co xml:id="co-vx-fpr"/>
    &lt;cvename&gt;CAN-2010-0201&lt;/cvename&gt; <co xml:id="co-vx-cve"/>
    &lt;cvename&gt;CAN-2010-0466&lt;/cvename&gt;
    &lt;bid&gt;96298&lt;/bid&gt; <co xml:id="co-vx-bid"/>
    &lt;certsa&gt;CA-2010-99&lt;/certsa&gt; <co xml:id="co-vx-cts"/>
    &lt;certvu&gt;740169&lt;/certvu&gt; <co xml:id="co-vx-ctv"/>
    &lt;uscertsa&gt;SA10-99A&lt;/uscertsa&gt; <co xml:id="co-vx-ucs"/>
    &lt;uscertta&gt;SA10-99A&lt;/uscertta&gt; <co xml:id="co-vx-uct"/>
    &lt;mlist msgid="201075606@hacker.com"&gt;http://marc.theaimsgroup.com/?l=bugtraq&amp;amp;m=203886607825605&lt;/mlist&gt; <co xml:id="co-vx-mls"/>
    &lt;url&gt;http://j.r.hacker.com/advisories/1&lt;/url&gt; <co xml:id="co-vx-url"/>
  &lt;/references&gt;
  &lt;dates&gt;
    &lt;discovery&gt;2010-05-25&lt;/discovery&gt; <co xml:id="co-vx-dsc"/>
    &lt;entry&gt;2010-07-13&lt;/entry&gt; <co xml:id="co-vx-ent"/>
    &lt;modified&gt;2010-09-17&lt;/modified&gt; <co xml:id="co-vx-mod"/>
  &lt;/dates&gt;
&lt;/vuln&gt;</programlisting>

	<para>Имена тегов должны быть самодокументируемыми, чтобы мы
	  сфокусировались только на полях, нужных нам для заполнения:</para>

	<calloutlist>
	  <callout arearefs="co-vx-vid">
	    <para>Это тег верхнего уровня записи VuXML.  У него есть
	      обязательный атрибут <literal>vid</literal>, указывающий на
	      универсальный уникальный идентификатор (UUID) для этой записи
	      (в кавычках).  Вы должны формировать UUID для каждой новой
	      записи VuXML (и не забудьте заменить ее для шаблона UUID,
	      если вы не пишете запись с нуля).  Для получения VuXML UUID
	      вы можете использовать &man.uuidgen.1;.</para>
	  </callout>

	  <callout arearefs="co-vx-top">
	    <para>Однострочное описание найденной проблемы.</para>
	  </callout>

	  <callout arearefs="co-vx-nam">
	    <para>Здесь перечислены имена затронутых пакетов.
	      Может быть дано несколько имен, поскольку некоторые пакеты
	      могут быть основаны на одном главном порте или программном
	      продукте.  Сюда можно включить стабильную ветвь и ветвь
	      разработки, локализованные версии и подчиненные порты,
	      зависящие от различного выбора важных вариантов конфигурации,
	      указанных на этапе построения.</para>

	    <important>
	      <para>Поиск всех подобных пакетов при написании записи VuXML
		входит в зону вашей ответственности.  Имейте в виду, что
		<literal>make search name=foo</literal> это ваш друг.
		Первичные точки для поиска следующие:</para>

	      <itemizedlist>
		<listitem>
		  <para>вариант <filename>foo-devel</filename> для порта
		    <filename>foo</filename>;</para>
		</listitem>

		<listitem>
		  <para>другие варианты с суффиксами вида
		    <literal>-a4</literal> (для пакетов, связанных с печатью),
		    <literal>-without-gui</literal> (для пакетов с
		    отключенной поддержкой X), или подобных;</para>
		</listitem>

		<listitem>
		  <para><literal>jp-</literal>, <literal>ru-</literal>,
		    <literal>zh-</literal> и другие возможные локализованные
		    варианты в соответствующих национальных категориях
		    коллекции портов.</para>
		</listitem>
	      </itemizedlist>
	    </important>
	  </callout>

	  <callout arearefs="co-vx-rng">
	    <para>Здесь указаны затронутые версии пакета(-ов) как один или
	      более диапазонов с использованием комбинации элементов
	      <literal>&lt;lt&gt;</literal>, <literal>&lt;le&gt;</literal>,
	      <literal>&lt;eq&gt;</literal>, <literal>&lt;ge&gt;</literal>,
	      и <literal>&lt;gt&gt;</literal>.  Диапазоны внесённых версий
	      не должны пересекаться.</para>

	    <para>В спецификации диапазонов <literal>*</literal> (звёздочка)
	      означает наименьший номер версии.  В частности,
	      <literal>2.*</literal> меньше, чем <literal>2.a</literal>.
	      Поэтому звездочка может быть использована в диапазоне для
	      совпадения со всеми возможными <literal>alpha</literal>,
	      <literal>beta</literal> и <literal>RC</literal> версиями.
	      Как вариант,
	      <literal>&lt;ge&gt;2.*&lt;/ge&gt;&lt;lt&gt;3.*&lt;/lt&gt;</literal>
	      выборочно совпадет с версией <literal>2.x</literal>, а
	      <literal>&lt;ge&gt;2.0&lt;/ge&gt;&lt;lt&gt;3.0&lt;/lt&gt;</literal>
	      - нет, поскольку последнее не включает
	      <literal>2.r3</literal> и совпадает с <literal>3.b</literal>.
	    </para>

	    <para>Пример выше указывает, что к затронутым относятся версии с
	      <literal>1.6</literal> до <literal>1.9</literal> включительно,
	      версии <literal>2.x</literal> до <literal>2.4_1</literal> и
	      версия <literal>3.0b1</literal>.</para>
	  </callout>

	  <callout arearefs="co-vx-nm2">
	    <para>Некоторые связанные группы пакетов (в конечном счете, порты)
	      могут быть указаны в разделе <literal>&lt;affected&gt;</literal>.
	      Это можно использовать, если некоторые программные продукты
	      (скажем, FooBar, FreeBar and OpenBar) являются производными
	      от общей кодовой базы и всё еще совместно используют её ошибки
	      и уязвимости.  Имейте в виду отличие от перечисления
	      множественных имён в одном разделе &lt;package&gt;.</para>
	  </callout>

	  <callout arearefs="co-vx-epo">
	    <para>Диапазоны версий должны учитывать
	      <varname>PORTEPOCH</varname> и <varname>PORTREVISION</varname>,
	      если это применимо.  Пожалуйста, помните, что в соответствии
	      с правилами сравнения строк версия с ненулевым значением
	      <varname>PORTEPOCH</varname> выше, чем любая версия без
	      <varname>PORTEPOCH</varname>, например, <literal>3.0,1</literal>
	      выше, чем <literal>3.1</literal> или даже <literal>8.9</literal>.
	    </para>
	  </callout>

	  <callout arearefs="co-vx-bdy">
	    <para>Сводная информация о проблеме.  В этом поле
	      используется XHTML.  По крайней мере, должны быть обрамляющие
	      <literal>&lt;p&gt;</literal> и <literal>&lt;/p&gt;</literal>.
	      Может быть использована более сложная разметка, но только в
	      целях аккуратности и ясности:  без эстетства, пожалуйста.
	    </para>
	  </callout>

	  <callout arearefs="co-vx-ref">
	    <para>Этот раздел содержит ссылки на имеющие отношение документы.
	      Приветствуется как можно большее количество ссылок.</para>
	  </callout>

	  <callout arearefs="co-vx-fsa">
	    <para>Это
	      <link xlink:href="http://www.freebsd.org/security/#adv">бюллетень
	      безопасности FreeBSD</link>.</para>
	  </callout>

	  <callout arearefs="co-vx-fpr">
	    <para>Это
	      <link xlink:href="http://www.freebsd.org/support.html#gnats">сообщение
	      об ошибке FreeBSD</link>.</para>
	  </callout>

	  <callout arearefs="co-vx-cve">
	    <para>Идентификатор
	      <link xlink:href="http://www.cve.mitre.org/">MITRE
	      CVE</link>.</para>
	  </callout>

	  <callout arearefs="co-vx-bid">
	    <para>Это
	      <link xlink:href="http://www.securityfocus.com/bid">SecurityFocus
	      Bug ID</link>.</para>
	  </callout>

	  <callout arearefs="co-vx-cts">
	    <para>Бюллетень безопасности
	      <link xlink:href="http://www.cert.org/">US-CERT</link>.</para>
	  </callout>

	  <callout arearefs="co-vx-ctv">
	    <para>Примечание к уязвимости
	      <link xlink:href="http://www.cert.org/">US-CERT</link>.</para>
	  </callout>

	  <callout arearefs="co-vx-ucs">
	    <para>Уведомление системы Cyber Security Alert
	      <link xlink:href="http://www.cert.org/">US-CERT</link>.</para>
	  </callout>

	  <callout arearefs="co-vx-uct">
	    <para>Уведомление системы Technical Cyber Security Alert
	      <link xlink:href="http://www.cert.org/">US-CERT</link>.</para>
	  </callout>

	  <callout arearefs="co-vx-mls">
	    <para>URL к архивному сообщению в списке рассылки.
	      Атрибут <literal>msgid</literal> является необязательным
	      и может указывать на message ID сообщения.</para>
	  </callout>

	  <callout arearefs="co-vx-url">
	    <para>Основной URL.  Должен быть использован в случае, если
	      не подходит ни одна из категорий источника.</para>
	  </callout>

	  <callout arearefs="co-vx-dsc">
	    <para>Дата последнего изменения любой информации данной записи
	      (<replaceable>YYYY-MM-DD</replaceable>).  Новые записи не
	      должны включать это поле.  Поле должно быть добавлено после
	      редактирования существующей записи.</para>
	  </callout>
	</calloutlist>
      </sect2>

      <sect2 xml:id="security-notify-vuxml-testing">
	<title>Тестирование ваших изменений в базе данных VuXML</title>

	<para>Предположим, что вы только что написали или заполнили запись
	  об уязвимости в пакете <literal>clamav</literal>, которая была
	  исправлена в версии <literal>0.65_7</literal>.</para>

	<para>Прежде всего, вам нужно <emphasis>установить</emphasis>
	  последние версии портов
	  <package>ports-mgmt/portaudit</package>,
	  <package>ports-mgmt/portaudit-db</package> и
	  <package>security/vuxml</package>.</para>

	<note>
	  <para>Для запуска <command>packaudit</command> вы должны обладать
	    правами на запись в
	    <filename>DATABASEDIR</filename>; как правило,
	    это <filename>/var/db/portaudit</filename>.</para>

	  <para>Для использования другого каталога присвойте переменной
	    окружения <filename>DATABASEDIR</filename>
	    другой путь.</para>

	  <para>Если вы работаете в каталоге, отличном от
	    <filename>${PORTSDIR}/security/vuxml</filename>, присвойте
	    переменной окружения
	    <filename>VUXMLDIR</filename> путь к каталогу,
	    в котором находится <filename>vuln.xml</filename>.</para>
	</note>

	<para>Во-первых, проверьте, нет ли уже записи об этой уязвимости.
	  Если такая запись есть, она совпадёт с предыдущей версией
	  пакета <literal>0.65_6</literal>:</para>

	<screen>&prompt.user; <userinput>packaudit</userinput>
&prompt.user; <userinput>portaudit clamav-0.65_6</userinput></screen>

	<para>Если ничего не найдено, значит вы получили зеленый свет для
	  добавления новой записи для этой уязвимости.</para>

	<screen>&prompt.user; <userinput>cd ${PORTSDIR}/security/vuxml</userinput>
&prompt.user; <userinput>make newentry</userinput></screen>

	<para>Когда вы закончите, проверьте синтаксис и форматирование.</para>

	<screen>&prompt.user; <userinput>make validate</userinput></screen>

	<note>
	  <para>Вам понадобится установить по крайней мере один из следующих
	    пакетов: <package>textproc/libxml2</package>,
	    <package>textproc/jade</package>.</para>
	</note>

	<para>Теперь выполните перепостроение базы данных
	  <command>portaudit</command> из файла VuXML:</para>

	<screen>&prompt.user; <userinput>packaudit</userinput></screen>

	<para>Чтобы убедиться, что раздел <literal>&lt;affected&gt;</literal>
	  в вашей записи совпадает с правильными пакетами, выполните
	  следующую команду:</para>

	<screen>&prompt.user; <userinput>portaudit -f /usr/ports/INDEX -r uuid</userinput></screen>

	<note>
	  <para>Для лучшего понимания синтаксиса этой команды обращайтесь
	    к &man.portaudit.1;.</para>
	</note>

	<para>Убедитесь, что ваша запись не производит ложных совпадений
	  в выводе.</para>

	<para>Теперь проверьте, совпадает ли ваша запись с нужными версиями
	  пакета:</para>

	<screen>&prompt.user; <userinput>portaudit clamav-0.65_6 clamav-0.65_7</userinput>
Affected package: clamav-0.65_6 (matched by clamav&lt;0.65_7)
Type of problem: clamav remote denial-of-service.
Reference: &lt;http://www.freebsd.org/ports/portaudit/74a9541d-5d6c-11d8-80e3-0020ed76ef5a.html&gt;

1 problem(s) found.</screen>

	<para>Первая версия должна совпасть, а последняя
	  нет.</para>

	<para>В заключение проверьте, что веб-страница, сформированная из
	  базы данных VuXML, выглядит как положено:</para>

	<screen>&prompt.user; <userinput>mkdir -p ~/public_html/portaudit</userinput>
&prompt.user; <userinput>packaudit</userinput>
&prompt.user; <userinput>lynx ~/public_html/portaudit/74a9541d-5d6c-11d8-80e3-0020ed76ef5a.html</userinput></screen>
      </sect2>
    </sect1>
  </chapter>

  <chapter xml:id="porting-dads">
    <title>Что делать нужно, и что делать нельзя</title>

    <sect1 xml:id="dads-intro">
      <title>Введение</title>

      <para>Вот список часто встречающихся действий, которые нужно и которые
        нельзя делать во время процесса портирования.  Вы должны проверять ваш
        порт по этому списку, и вы также можете проверять порты в <link xlink:href="http://www.FreeBSD.org/cgi/query-pr-summary.cgi?query">базе
        сообщений PR</link>, которые присланы другими людьми.  Присылайте
        любые комментарии о портах, которые вы проверили, так, как это описано
        в статье о <link xlink:href="&url.articles.contributing;/contrib-how.html#CONTRIB-GENERAL">
        Сообщениях об ошибках и общих замечаниях</link>.  Проверка портов в
        базе сообщений PR позволит нам быстрее коммиттить их и удостовериться,
        что вы знаете, что делаете.</para>
    </sect1>

    <sect1 xml:id="porting-wrkdir">
      <title><varname>WRKDIR</varname></title>

      <para>Не пишите ничего в файлы вне каталога <varname>WRKDIR</varname>.
	Каталог <varname>WRKDIR</varname> является единственным местом,
	которое гарантированно будет доступно для записи во время построения
	порта (обратитесь к главе о <link xlink:href="&url.books.handbook;/ports-using.html#PORTS-CD">установке портов с
        CDROM</link> за
	примером построения портов из дерева, доступного только для чтения).
	Если вам нужно изменить какой-либо из файлов
        <filename>pkg-*</filename>, сделайте это,
        <link linkend="porting-pkgfiles">переопределив переменную</link>, но не
	перезаписывая их.</para>
    </sect1>

    <sect1 xml:id="porting-wrkdirprefix">
      <title><varname>WRKDIRPREFIX</varname></title>

      <para>Добейтесь того, чтобы ваш порт принимал во внимание значение
	переменной <varname>WRKDIRPREFIX</varname>.  Большинство портов об
	этом не заботятся.  В частности, если вы обращаетесь к каталогу
	<varname>WRKDIR</varname> другого порта, заметьте, что его правильным
	местоположением является
	<filename>WRKDIRPREFIXPORTSDIR/subdir/name/work</filename> not <filename>PORTSDIR/subdir/work</filename>
	или <filename>.CURDIR/../../subdir/name/work</filename>
	или что-то подобное.</para>

      <para>Кроме того, если вы сами задаете <varname>WRKDIR</varname>, то
	должны поставить перед ним знак
	<literal>&dollar;{WRKDIRPREFIX}&dollar;{.CURDIR}</literal>.</para>
    </sect1>

    <sect1 xml:id="porting-versions">
      <title>Различение операционных систем и версий ОС</title>

      <para>Вы можете встретиться с кодом, который требует модификаций
	или условной компиляции в зависимости от того, с какой версией &os;
	Unix он работает.  Предпочтительным способом отделения кода для
	версий &os; является использование макросов
	<literal>__FreeBSD_version</literal> и
	<literal>__FreeBSD__</literal>, определённых в файле <link xlink:href="http://svnweb.freebsd.org/base/head/sys/sys/param.h?view=markup">sys/param.h</link>.
	Если этот файл не подключен, добавьте код</para>

      <programlisting>#include &lt;sys/param.h&gt;</programlisting>

      <para>в соответствующем месте файла <filename>.c</filename>.
	<literal>__FreeBSD__</literal> определён во всех версиях &os;
	в качестве старшего номера версии системы.  Например, в &os;
	9.x <literal>__FreeBSD__</literal> определён со значением
	<literal>9</literal>.</para>

      <para>
	<programlisting>#if __FreeBSD__ &gt;= 9
#  if __FreeBSD_version &gt;= 901000
	 /* здесь особый код для версий 9.1+ */
#  endif
#endif</programlisting>
      </para>
    </sect1>

    <sect1 xml:id="dads-after-port-mk">
      <title>Написание чего-либо после
	<filename>bsd.port.mk</filename></title>

      <para>Не пишите ничего после строки
	<literal>.include &lt;bsd.port.mk&gt;</literal>.  Этой строки можно
	избежать, включив в где-то в середину вашего файла
	<filename>Makefile</filename> файл
	<filename>bsd.port.pre.mk</filename>, и
	файл <filename>bsd.port.post.mk</filename> в конец.</para>

      <note>
	<para>Вам нужно включить либо пару файлов
          <filename>bsd.port.pre.mk</filename>/<filename>bsd.port.post.mk</filename>,
          либо только <filename>bsd.port.mk</filename>; не используйте оба этих
          метода одновременно.</para>
      </note>

      <para>В файле <filename>bsd.port.pre.mk</filename> определяются лишь
	несколько переменных, которые могут быть использованы в тестах из
	файла <filename>Makefile</filename>, в файле
	<filename>bsd.port.post.mk</filename> заданы остальные.</para>

      <para>Вот некоторые важные переменные, определенные в файле
	<filename>bsd.port.pre.mk</filename> (это не полный список, для
	выяснения полного списка прочтите, пожалуйста, сам файл
	<filename>bsd.port.mk</filename>).</para>

      <informaltable frame="none" pgwide="0">
      <tgroup cols="2">
      <thead>
	<row>
	  <entry>Переменная</entry>
	  <entry>Описание</entry>
	</row>
      </thead>

      <tbody>
	<row>
	  <entry><varname>ARCH</varname></entry>
	  <entry>Архитектура машины в виде, получаемом по команде
	    <command>uname -m</command> (например,
	    <literal>i386</literal>)</entry>
	</row>

	<row>
	  <entry><varname>OPSYS</varname></entry>
	  <entry>Тип операционной системы, получаемый по команде
	    <command>uname -s</command> (например,
	    <literal>FreeBSD</literal>)</entry>
	</row>

	<row>
	  <entry><varname>OSREL</varname></entry>
	  <entry>Версия релиза операционной системы (например,
	    <literal>2.1.5</literal> или <literal>2.2.7</literal>)</entry>
	</row>

	<row>
	  <entry><varname>OSVERSION</varname></entry>

	  <entry>Версия операционной системы в виде числа, та же, что и <link linkend="freebsd-versions">
	    <literal>__FreeBSD_version</literal></link>.</entry>
	</row>

	<row>
	  <entry><varname>LOCALBASE</varname></entry>
	  <entry>Корень дерева <quote>local</quote> (например,
	    <literal>/usr/local</literal>)</entry>
	</row>

	<row>
	  <entry><varname>PREFIX</varname></entry>
	  <entry>Куда, собственно, устанавливается порт (обратитесь к <link linkend="porting-prefix">
	    подробной информации о <varname>PREFIX</varname></link>).</entry>
	</row>
      </tbody>
      </tgroup>
      </informaltable>

      <note>
	<para>Если вы задаете переменную
	  <varname>MASTERDIR</varname>, делайте это до
	  подключения <filename>bsd.port.pre.mk</filename>.</para>
      </note>

      <para>Вот несколько примеров того, что вы можете написать после
	<filename>bsd.port.pre.mk</filename>:</para>

      <programlisting># no need to compile lang/perl5 if perl5 is already in system
.if ${OSVERSION} &gt; 300003
BROKEN= perl is in system
.endif</programlisting>

      <para>Вы не забываете об использовании табуляции вместо пробелов
	после <literal>BROKEN=</literal>,
	не так ли? <!-- улыбка -->:-).</para>
    </sect1>

    <sect1 xml:id="dads-sh-exec">
      <title>Использование выражения <function>exec</function>
	в сценариях обёртках</title>

      <para>Если порт устанавливает сценарий на языке shell, который служит
	для запуска другой программы, и если запуск этой программы является
	последним действием сценария, убедитесь, что запуск программы
	производится с использованием выражения <function>exec</function>,
	например:</para>

      <programlisting>#!/bin/sh
exec %%LOCALBASE%%/bin/java -jar %%DATADIR%%/foo.jar "$@"</programlisting>

      <para>Выражение <function>exec</function> заменяет процесс сценария
	на указанную программу.  Если <function>exec</function> опущен,
	то процесс сценария во время работы программы остается в памяти,
	без бесполезно потребляя системные ресурсы.</para>

    </sect1>

    <sect1 xml:id="dads-rational">
      <title>Поступайте разумно</title>

      <para>Файл <filename>Makefile</filename> должен выполнять действия
	просто и небеспричинно.  Если вы можете сделать что-то на несколько
	строк короче или более читабельно, сделайте это.  В качестве примеров
	можно привести использование конструкций <literal>.if</literal>
	утилиты make вместо соответствующей конструкции <literal>if</literal>
	командного процессора, ненужность переопределения цели
	<buildtarget>do-extract</buildtarget> при возможности переопределения
	<varname>EXTRACT*</varname> и использование
	<varname>GNU_CONFIGURE</varname> вместо
	<literal>CONFIGURE_ARGS+= --prefix=&dollar;{PREFIX}</literal>.</para>

      <para>Если вы обнаружите, что для выполнения чего-то приходится писать
        много нового кода, то, пожалуйста, просмотрите файл
        <filename>bsd.port.mk</filename> на предмет того, не содержит ли он
        реализацию именно вашей проблемы.  Хотя его трудно читать, имеется
        много проблем, выглядящих сложными, для которых файл
        <filename>bsd.port.mk</filename> уже содержит быстрое решение.</para>
    </sect1>

    <sect1 xml:id="dads-cc">
      <title>Работа как с <varname>CC</varname>, так и
        <varname>CXX</varname></title>

      <para>Порт должен принимать во внимание как переменную
        <varname>CC</varname>, так и <varname>CXX</varname>.
        Под этим мы подразумеваем, что порт ни в коем случае не должен
        устанавливать значения этих переменных, переопределяя имеющиеся
        значения; вместо этого можно добавлять нужные значения к уже
	имеющимся.  Это связано с тем, что параметры построения,
        относящиеся ко всем портам, могут быть заданы глобально.</para>

      <para>Если порты не учитывают значения этих переменных, добавьте
	строку <literal>NO_PACKAGE=ignores either cc or cxx</literal>
	в файл <filename>Makefile</filename>.</para>

      <para>Далее следует пример файла <filename>Makefile</filename>,
        использующего как переменную <varname>CC</varname>, так и
        <varname>CXX</varname>.  Обратите внимание на использование символов
        <varname>?=</varname>:</para>

      <programlisting>CC?= gcc</programlisting>

      <programlisting>CXX?= g++</programlisting>

      <para>Вот пример, в котором не принимаются во внимание ни переменная
        <varname>CC</varname>, ни <varname>CXX</varname>:</para>

      <programlisting>CC= gcc</programlisting>

      <programlisting>CXX= g++</programlisting>

      <para>Обе переменные <varname>CC</varname> и <varname>CXX</varname>
        могут быть определены в системах FreeBSD в файле
        <filename>/etc/make.conf</filename>.  В первом примере задаётся
        значение, если оно ранее не было определено в
        <filename>/etc/make.conf</filename>, что сохраняет любые определения,
        данные на уровне системы в целом.  Второй пример переопределяет всё,
        что было задано ранее.</para>
    </sect1>

    <sect1 xml:id="dads-cflags">
      <title>Использование <varname>CFLAGS</varname></title>

      <para>Порт должен принимать во внимание переменную
	<varname>CFLAGS</varname>.
        Под этим мы подразумеваем, что порт ни в коем случае не должен
        устанавливать значения этих переменных, переопределяя имеющиеся
        значения; вместо этого можно добавлять нужные значения к уже
        имеющимся.  Это связано с тем, что параметры построения,
        относящиеся ко всем портам, могут быть заданы глобально.</para>

      <para>Если порты не учитывают значения этой переменной, добавьте
	строку <literal>NO_PACKAGE=ignores cflags</literal> в файл
	<filename>Makefile</filename>.</para>

      <para>Далее следует пример файла <filename>Makefile</filename>,
	использующего переменную <varname>CFLAGS</varname>.  Обратите
	внимание на использование символов <varname>+=</varname>:</para>

      <programlisting>
CFLAGS+= -Wall -Werror
      </programlisting>

      <para>А вот пример, в котором не учитывается значение переменной
        <varname>CFLAGS</varname>:</para>

      <programlisting>
CFLAGS= -Wall -Werror
      </programlisting>

      <para>В системе FreeBSD переменная <varname>CFLAGS</varname> определена
        в файле <filename>/etc/make.conf</filename>.  В первом примере к
        переменной <varname>CFLAGS</varname> добавляются дополнительные флаги,
        при этом сохраняются все определения, данные ранее на уровне системы.
        Во втором примере всё, что было задано ранее, игнорируется.</para>

      <para>Из сторонних файлов <filename>Makefile</filename> следует удалить
	флаги оптимизации.  Общесистемные флаги оптимизации находятся в
	системной переменной <varname>CFLAGS</varname>.  Пример из
	немодифицированного <filename>Makefile</filename>:</para>

      <programlisting>CFLAGS= -O3 -funroll-loops -DHAVE_SOUND</programlisting>

      <para>При использовании системных флагов оптимизации
	<filename>Makefile</filename> станет похожим на следующий пример:</para>

      <programlisting>CFLAGS+= -DHAVE_SOUND</programlisting>

    </sect1>

      <sect1 xml:id="dads-pthread">
	<title>Библиотеки потоков</title>

	<para>Во &os; библиотека потоков обязана быть скомпонована с
	  исполняемыми файлами с использованием специального флага
	  <literal>-pthread</literal>.  Если порт настаивает
	  на прямой компоновке с <literal>-lpthread</literal>,
	  создайте патч для использования <literal>-pthread</literal>
	</para>

	<note>
	  <para>Если построение порта заканчивается ошибкой
	    <literal>unrecognized option '-pthread'</literal>,
	    то может быть желательно использование <command>cc</command>
	    в качестве компоновщика через установку
	    <varname>CONFIGURE_ENV</varname> в <literal>LD=${CC}</literal>.
	    Параметр <literal>-pthread</literal> напрямую командой
	    <command>ld</command> не поддерживается.</para>
	</note>

      </sect1>

    <sect1 xml:id="dads-freedback">
      <title>Пожелания</title>

      <para>Посылайте подходящие изменения/патчи авторам/сопровождающему
	для включения в следующий релиз.  Это только сделает вашу работу
	гораздо легче при выходе следующего релиза.</para>
    </sect1>

    <sect1 xml:id="dads-readme">
      <title><filename>README.html</filename></title>

      <para>Не включайте сюда файл <filename>README.html</filename>.  Этот файл
	не является частью дерева SVN, и он генерируется при помощи команды
        <command>make readme</command>.</para>

      <note>
	<para>Если не удается выполнить <command>make readme</command>,
	  убедитесь, что значение по умолчанию <varname>ECHO_MSG</varname>
	  не было изменено внутри порта.</para>
      </note>
    </sect1>

    <sect1 xml:id="dads-noinstall">
      <title>Пометка неустанавливаемого порта как <varname>BROKEN</varname>,
        <varname>FORBIDDEN</varname> или <varname>IGNORE</varname></title>

      <para>В некоторых случаях пользователи не должны допускаться к
	установке порта.  Для того, чтобы сообщить пользователю, что порт
	не следует устанавливать, имеется несколько
        <command>make</command>-переменных, которые могут быть использованы
        в файле <filename>Makefile</filename> порта.  Значения следующих
        <command>make</command>-переменных будут причиной, возвращаемой
	пользователям, по которой порт отказывает в установке.
        Пожалуйста, используйте корректные <command>make</command>-переменные,
        так как каждая переменная make передает абсолютно различный смысл
        как для пользователей, так и для автоматизированных систем, которые
        полагаются на файлы <filename>Makefile</filename>, таких как
	<link linkend="build-cluster">кластер построения портов</link>,
	<link linkend="freshports">FreshPorts</link> и
	<link linkend="portsmon">portsmon</link>.</para>

      <sect2 xml:id="dads-noinstall-variables">
	<title>Переменные</title>

      <itemizedlist>
	<listitem>
	  <para><varname>BROKEN</varname> предназначена для портов, которые
	    в настоящее время не компилируются, не устанавливаются или не
	    удаляются правильно.  Следует использовать для портов,
	    когда проблема считается временной.</para>

	  <para>В особых случаях кластер
	    построения будет продолжать попытки собрать их, чтобы показать,
	    решена ли основная проблема.  (Однако, как правило, кластер
	    запускается без этой возможности.)</para>

	  <para>В частности, используйте
	    <varname>BROKEN</varname>, когда порт:</para>

	  <itemizedlist>
	    <listitem>
	      <para>не компилируется</para>
	    </listitem>

	    <listitem>
	      <para>не выполняет процесс своей конфигурации или
		установки</para>
	    </listitem>

	    <listitem>
	      <para>устанавливает файлы вовне
		<filename>${LOCALBASE}</filename></para>
	    </listitem>

	    <listitem>
	      <para>не удаляет полностью все свои файлы при деинсталляции
		(тем не менее, это может быть допустимо, и подходит
		для портов, оставляющих после себя файлы, измененные
		пользователем)</para>
	    </listitem>
	  </itemizedlist>

	</listitem>

        <listitem>
	  <para><varname>FORBIDDEN</varname> используется для портов, которые
            содержат уязвимости в информационной безопасности или
            являются потенциально вредными в плане обеспечения информационной
            безопасности системы FreeBSD при установке данного порта
            (например: заведомо небезопасная программа или программа, которая
            предоставляет легко взламываемые сервисы).  Порты должны
            помечаться как <varname>FORBIDDEN</varname>, как только в
            конкретном программном обеспечении обнаружилась уязвимость, но
            обновление выпущено не было.  В идеальном случае порты должны
            обновляться максимально быстро после обнаружения уязвимости,
            чтобы уменьшить число уязвимых хостов FreeBSD (нам нравится иметь
            репутацию безопасной системы), однако иногда случается
            значительный временной разрыв между обнаружением уязвимости и
            выходом обновлённого релиза уязвимого программного обеспечения.
            Не помечайте порт как <varname>FORBIDDEN</varname>, если причина
            не вызвана соображениями информационной безопасности.</para>
	</listitem>

	<listitem>
	  <para><varname>IGNORE</varname> предназначена для портов, которые
            не должны строиться по какой-либо другой причине.  Следует
	    использовать для портов, в случае когда проблема считает
	    конструктивной.  Кластер построения
            ни при каких условиях не будет строить порты, помеченные как
	    <varname>IGNORE</varname>.  В частности, используйте
	    <varname>IGNORE</varname>, когда порт:</para>

	  <itemizedlist>
	    <listitem>
	      <para>компилируется, но работает неправильно</para>
	    </listitem>

	    <listitem>
	      <para>не работает на установленной версии &os;</para>
	    </listitem>

	    <listitem>
	      <para>требует для построения исходные тексты ядра &os;, но
		у пользователя в установленном виде они отсутствуют</para>
	    </listitem>

	    <listitem>
	      <para>имеет distfile, который не может быть автоматически
		извлечен из-за лицензионных ограничений</para>
	    </listitem>

	    <listitem>
	      <para>не работает с каким-либо другим портом, установленным
		в настоящее время (например, порт зависит от <package>www/apache20</package>, но установлен
		<package>www/apache22</package>)
	      </para>
	    </listitem>
	  </itemizedlist>

	  <note>
	    <para>Если порт будет конфликтовать с уже установленным портом,
	      (например, если они устанавливают файл в то же место, но
	      с иным функциональным назначением), то
	      <link linkend="conflicts">используйте
	      вместо этого <varname>CONFLICTS</varname></link>.
	      <varname>CONFLICTS</varname> сам установит значение
	      <varname>IGNORE</varname>.</para>
	  </note>
	</listitem>

	<listitem>
	  <para>Если порт нужно пометить как <varname>IGNORE</varname>
	    только на некоторых архитектурах, для этого есть две другие
	    удобные переменные, которые автоматически установят для вас
	    значения: <varname>ONLY_FOR_ARCHS</varname> и
	    <varname>NOT_FOR_ARCHS</varname>.  Примеры:</para>

	  <programlisting>ONLY_FOR_ARCHS= i386 amd64</programlisting>

	  <programlisting>NOT_FOR_ARCHS= ia64 sparc64</programlisting>

	  <para>Собственное сообщение <varname>IGNORE</varname> можно задать
	    с использованием <varname>ONLY_FOR_ARCHS_REASON</varname> и
	    <varname>NOT_FOR_ARCHS_REASON</varname>.  Отдельно для каждой
	    архитектуры это возможно с использованием
	    <varname>ONLY_FOR_ARCHS_REASON_<replaceable>ARCH</replaceable></varname>
	    и
	    <varname>NOT_FOR_ARCHS_REASON_<replaceable>ARCH</replaceable></varname>.</para>
	</listitem>

	<listitem>
	  <para>Если порт загружает и устанавливает исполняемые файлы i386,
	    то следует установить <varname>IA32_BINARY_PORT</varname>.
	    Если эта переменная установлена, будет выполнена проверка
	    доступности каталога <filename>/usr/lib32</filename> для
	    библиотек версии IA32 и поддержки IA32 в ядре.  При невыполнении
	    любого из этих условий будет автоматически установлена
	    переменная <varname>IGNORE</varname>.</para>
	</listitem>

      </itemizedlist>

      </sect2>
      <sect2 xml:id="dads-noinstall-notes">
	<title>Замечания по реализации</title>

	<para>Строки не следует брать в кавычки.
	  Также построение строки должно несколько различаться из-за
	  способа отображения информации пользователю.  Примеры:</para>

	<programlisting>BROKEN= this port is unsupported on FreeBSD 5.x</programlisting>

	<programlisting>IGNORE= is unsupported on FreeBSD 5.x</programlisting>

	<para>получаемые в результате следующего вывода
	  <command>make describe</command>:</para>

	<programlisting>===&gt;  foobar-0.1 is marked as broken: this port is unsupported on FreeBSD 5.x.</programlisting>

	<programlisting>===&gt;  foobar-0.1 is unsupported on FreeBSD 5.x.</programlisting>
      </sect2>
    </sect1>

    <sect1 xml:id="dads-deprecated">
      <title>Пометка порта на удаление с <varname>DEPRECATED</varname>
	или <varname>EXPIRATION_DATE</varname></title>

      <para>Помните, что <varname>BROKEN</varname> и
	<varname>FORBIDDEN</varname> будут использованы как временное
        средство, если порт не является работающим.  Постоянно
        неработоспособные порты должны полностью удаляться из дерева.</para>

      <para>В подходящих ситуациях пользователи могут быть оповещены о
	предстоящем удалении через переменные <varname>DEPRECATED</varname>
	и <varname>EXPIRATION_DATE</varname>.  Первое - это просто строка,
	сообщающая причину запланированного удаления порта; вторая является
	строкой в формате ISO 8601 (YYYY-MM-DD).  Обе будут показаны
	пользователю.</para>

      <para>Переменную <varname>DEPRECATED</varname> можно установить без
	использования <varname>EXPIRATION_DATE</varname> (в частности, при
	рекомендации новой версии порта), но обратный порядок не имеет
	никакого смысла.</para>

      <para>Не существует устоявшейся политики, как долго следует продолжать
	уведомления. Текущая практика дает около месяца для решения проблем
	безопасности и два месяца для проблем построения.  Это также дает
	немного времени на исправление проблем любым заинтересованным
	коммиттерам.</para>
    </sect1>

    <sect1 xml:id="dads-dot-error">
      <title>Избегайте использования конструкции
	<literal>.error</literal></title>

      <para>Правильным способом подать сигнал для <filename>Makefile</filename>
	о том, что порт не может быть установлен из-за какого-то внешнего
	фактора (например, пользователь указал недопустимую комбинацию
	опций построения), является установка непустого значения для
	<varname>IGNORE</varname>.  Это значение будет сформатировано и
	показано пользователю во время <command>make install</command>.</para>

      <para>Использование для этих целей <literal>.error</literal> является
	распространенной ошибкой.  Проблема в том, что в этой ситуации
	будут повреждены многие инструменты автоматизации, работающие с
	деревом портов.  Наибольшим образом это распространено при попытке
	построить <filename>/usr/ports/INDEX</filename> (смотрите <xref linkend="make-describe"/>).  Тем не менее, даже более простые команды,
	такие как <command>make maintainer</command>, в этом случае также
	вернут ошибку.  Это не является приемлемым.</para>

      <example xml:id="dot-error-breaks-index">
	<title>Как избегать использование <literal>.error</literal></title>
	<para>Предположим, что кто-то поместил строку</para>

	<programlisting>USE_POINTYHAT=yes</programlisting>

	<para>в <filename>make.conf</filename>.  Первый из последующих двух
	  вариантов строк файла <filename>Makefile</filename> приведёт к
	  неудачному завершению работы <command>make index</command>, а
	  второй - нет:</para>
	  <programlisting>.if USE_POINTYHAT
.error "POINTYHAT is not supported"
.endif</programlisting>

	  <programlisting>.if USE_POINTYHAT
IGNORE=POINTYHAT is not supported
.endif</programlisting>
      </example>

    </sect1>

    <sect1 xml:id="dads-sysctl">
      <title>Использование <filename>sysctl</filename></title>

      <para>Использование <filename>sysctl</filename> не рекомендуется,
	кроме как при выполнении целей. Это вызвано тем, что вычисление
	любых <literal>makevar</literal>, таких как во время команды
	<command>make index</command>, с необходимостью запуска этой
	команды, еще больше замедляет весь процесс.</para>

      <para>&man.sysctl.8; следует всегда использовать через переменную
	<varname>SYSCTL</varname>, поскольку она содержит полностью заданный
	путь, и при необходимости может быть переопределена.</para>
    </sect1>

    <sect1 xml:id="dads-rerolling-distfiles">
      <title>Меняющиеся дистрибутивные файлы</title>

      <para>Иногда авторы программного обеспечения меняют содержимое
	выпущенных дистрибутивных файлов без смены названия.  Вы должны
	проверять, что изменения являются официальными и произведены
	автором.  В прошлом бывало, что дистрибутивный файл молча изменялся
	на сайтах загрузки с намерением нанести вред или скомпрометировать
	безопасность конечного пользователя.</para>

      <para>Отложите старый файл с дистрибутивом в сторону, загрузите новый,
	распакуйте его и сравните содержимое при помощи &man.diff.1;.
	Если вы не видите ничего подозрительного, то можете обновить файл
	<filename>distinfo</filename>.  Убедитесь, что вы подытожили различия
	в вашем PR или описании коммита, чтобы другие люди были в курсе, что
	вы позаботились о том, что ничего плохого не случилось.</para>

      <para>Возможно вы также захотите связаться с автором этого программного
	обеспечения для подтверждения изменений.</para>
    </sect1>

    <sect1 xml:id="dads-avoiding-linuxisms">
      <title>Избегание линуксизмов</title>

      <para>Не используйте <filename>/proc</filename>, если доступны
	любые другие источники получения информации, например,
	<function>setprogname(argv[0])</function> в
	<function>main()</function> и &man.getprogname.3;, в случае
	если вы хотите <quote>знать своё имя</quote>.</para>

      <para>Не полагайтесь на поведение, не регламентированное
	<acronym>POSIX</acronym>.</para>

      <para>Не выполняйте запись временных меток в критических путях
	выполнения приложения, если можно обойтись без этого.  Получение
	временных меток может быть медленным, в зависимости от степени
	точности используемых часов в операционной системе.  Если
	временные метки действительно нужны, определите степень
	требуемой точности и используйте тот <acronym>API</acronym>,
	в котором документируется получение достаточной точности.</para>

      <para>Ряд простых системных вызовов (например, &man.gettimeofday.2;,
	&man.getpid.2;) работают намного быстрее в &linux; по сравнению
	с любой другой операционной системой из-за кеширования и
	используемой оптимизации vsyscall.  Не полагайтесь на их
	дешевизну в критичных к производительности приложениях.  В
	целом, старайтесь избегать системных вызовов там, где это
	возможно.</para>

      <para>Не полагайтесь на специфичное для &linux; поведение сокета.
	В частности, отличаются размеры буфера сокета по умолчанию
	(выполните вызов &man.setsockopt.2; с <literal>SO_SNDBUF</literal>
	и <literal>SO_RCVBUF</literal>, и в то время как в &linux;
	при заполнении буфера сокета &man.send.2; блокируется, &os;
	возвращает ошибку и устанавливает <literal>ENOBUFS</literal>
	в качестве значения errno.</para>

      <para>Если требуется рассчитывать на нестандартное поведение,
	инкапсулируйте это должным образом в общий для всех
	<acronym>API</acronym> с проверкой поведения на этапе
	конфигурации, и если требуемое поведение не найдено,
	прекращайте выполнение.</para>

      <para>Используйте <link xlink:href="http://www.freebsd.org/cgi/man.cgi">страницы
	справочника</link> для проверки, относится ли функция к
	интерфейсу <acronym>POSIX</acronym> (ищите раздел
	<quote>STANDARDS</quote> на странице справочника).</para>

      <para>Не рассчитывайте на то, что в качестве
	<filename>/bin/sh</filename> используется
	<application>bash</application>.  Убедитесь, что командная
	строка, переданная в &man.system.3;, будет работать в
	<acronym>POSIX</acronym>-совместимой оболочке.</para>

      <para>Список основных <application>bash</application>-измов
	расположен <link xlink:href="https://wiki.ubuntu.com/DashAsBinSh">здесь</link>.</para>

      <para>Не используйте <literal>#include
	  &lt;stdint.h&gt;</literal>, если
	достаточно подключить <filename>inttypes.h</filename>.  Это
	позволит убедиться, что программное обеспечение собирается на
	более старых версиях &os;.</para>

      <para>Проверьте, что используемые заголовочные файлы включены в
	<acronym>POSIX</acronym> или список, рекомендуемый страницей
	справочника, т.к. например, забыть подключить
	<filename>sys/types.h</filename> &mdash; не такая уж проблема
	в &linux;, однако это не так во &os;.</para>

      <para>Компилируйте многопоточные приложения с ключом
	<quote>-pthread</quote>, а не <quote>-lpthread</quote> или
	как-либо ещё.</para>
    </sect1>

    <sect1 xml:id="dads-misc">
      <title>Разное</title>

      <para>Файлы <filename>pkg-descr</filename> и
        <filename>pkg-plist</filename> должны проверяться дважды.  Если вы
        пересматриваете порт и думаете, что его можно описать иначе,
        сделайте это.</para>

      <para>Пожалуйста, не создавайте дополнительных копий лицензии GNU
	General Public License в нашей системе.</para>

      <para>Будьте внимательны с юридическими вопросами!  Не делайте из нас
	нелегальных распространителей ПО!</para>
    </sect1>

  </chapter>

  <chapter xml:id="porting-samplem">
    <title>Примерный <filename>Makefile</filename></title>

    <para>Вот примерный <filename>Makefile</filename>, который можно
      использовать при создании нового порта.  Обязательно удалите все
      дополнительные комментарии (те, которые в скобках)!</para>

    <para>Вам рекомендуется следовать этому формату (соблюдая порядок
      следования переменных, пустые строки между разделами, и так далее).
      Этот формат разработан для того, чтобы важная информация была легко
      найдена.	Мы рекомендуем вам воспользоваться утилитой <link linkend="porting-portlint">portlint</link> для проверки файла
      <filename>Makefile</filename>.</para>

    <programlisting>[заголовок...просто чтобы нам было легче идентифицировать порт.]
# Created by: Satoshi Asami &lt;asami@FreeBSD.org&gt;
[Необязательная строка <emphasis>Created by:</emphasis> содержит имя
человека, создавшего первоначальную версию порта.  Следует отметить,
что за <quote>:</quote> следует пробел, но не символ табуляции.  Если
эта строка присутствует, будущие сопровождающие не должны её менять
или удалять, кроме как по запросу первоначального автора.]

# &dollar;FreeBSD&dollar;
[ ^^^^^^^^^ Эта строка будет автоматически заменена на строчку RCS ID
системой SVN при выполнении операции коммита в наше хранилище.  При
обновлении порта не приводите эту строку обратно к виду
"&dollar;FreeBSD&dollar;".  SVN сделает это автоматически.]

[секция описания собственно порта и основного сервера - сначала всегда
 PORTNAME и PORTVERSION, за ним следует CATEGORIES, а затем
 MASTER_SITES, за которым может идти MASTER_SITE_SUBDIR.
 PKGNAMEPREFIX и PKGNAMESUFFIX, если они нужны, следуют за ними.
 Затем следует DISTNAME, EXTRACT_SUFX и/или DISTFILES, а потом, если это нужно,
 EXTRACT_ONLY.]
PORTNAME=      xdvi
PORTVERSION=   18.2
CATEGORIES=    print
[не забывайте про завершающую косую черту ("/")!
 если вы не используете макросы MASTER_SITE_*]
MASTER_SITES=  ${MASTER_SITE_XCONTRIB}
MASTER_SITE_SUBDIR= applications
PKGNAMEPREFIX= ja-
DISTNAME=      xdvi-pl18
[задайте это, если исходный код поставляется не в виде
 стандартного файла ".tar.gz"]
EXTRACT_SUFX=  .tar.Z

[секция патчей -- может быть пустой]
PATCH_SITES=   ftp://ftp.sra.co.jp/pub/X11/japanese/
PATCHFILES=    xdvi-18.patch1.gz xdvi-18.patch2.gz

[сопровождающий; *обязательное поле*!  Это человек, который добровольно
 занимается обновлениями порта и неисправностями при построении, и которому
 пользователь может направлять вопросы и сообщения об ошибках.  Для
 сохранения как можно более высокого качества Коллекции Портов мы больше
 не принимаем новые порты, назначенные на "ports@FreeBSD.org".]
MAINTAINER=    asami@FreeBSD.org
COMMENT=       A DVI Previewer for the X Window System

[зависимости -- могут быть пустыми]
RUN_DEPENDS=   gs:${PORTSDIR}/print/ghostscript

[этот раздел для остальных стандартных переменных из bsd.port.mk, кроме
 тех, что перечислены выше]
[Если порт задает вопросы во время этапов настройки, построения,
 установки...]
IS_INTERACTIVE=        yes
[Если распаковка происходит в каталог, отличных от ${DISTNAME}...]
WRKSRC= 	       ${WRKDIR}/xdvi-new
[Если патчи делались не относительно ${WRKSRC}, вам, может быть, не
 придется изменять эту переменную]
PATCH_DIST_STRIP=      -p1
[Если порт требует скрипта "configure", генерируемого GNU-версией программы
 autoconf]
GNU_CONFIGURE= yes
[Если для построения порту требуется GNU-версия утилиты make, а не
 /usr/bin/make...]
USES=          gmake
[Если это приложение X и требует запуска "xmkmf -a"...]
USES=          imake
[и так далее]

[В правилах ниже используются нестандартные переменные]
MY_FAVORITE_RESPONSE=  "yeah, right"

[теперь специальные правила, в порядке их вызова]
pre-fetch:
	я что-то выкачиваю, точно

post-patch:
	мне кое-что сделать после применения патча, великолепно

pre-install:
	и потом еще кое-что перед установкой, ого

[и, наконец, эпилог]
.include &lt;bsd.port.mk&gt;
    </programlisting>
  </chapter>


  <chapter xml:id="keeping-up">
    <title>Актуализация</title>

    <para>Коллекция Портов &os; постоянно изменяется.  Здесь находится
      некоторая информация о том, как поддерживать её в актуальном
      состоянии.</para>

    <sect1 xml:id="freshports">
      <title>FreshPorts</title>

      <para>Самым простым способом отслеживать уже произошедшие обновления
        является подписка на <link xlink:href="http://www.FreshPorts.org/">
        FreshPorts</link>.  Для мониторинга вы можете выбрать несколько
        портов.  Мейнтейнерам настоятельно рекомендуется подписаться здесь,
        потому что они будут получать уведомления не только о собственных
        изменениях, но и об изменениях, сделанных любым другим коммиттером
        &os;.  (Это часто необходимо для синхронизации с изменениями на более
        низком технологическом уровне&mdash;хотя более корректным было бы
        получение предупреждений от тех, кто вносит подобные изменения,
        иногда этот этап пропускается или он просто непрактичен.  Кроме того,
        в некоторых случаях изменения по своей природе весьма незначительны.
        Мы полагаем, что любой разработчик в таких ситуациях будет
        руководствоваться здравым смыслом).</para>

      <para>Если вы хотите использовать FreshPorts, то вам нужна только
        учётная запись.  Если регистрационный адрес вашей электронной почты
        будет иметь вид <literal>@FreeBSD.org</literal>, то справа на
        Web-страницах вы увидите дополнительную ссылку.  Для тех из вас, кто
        уже получил учётную запись FreshPorts, но не использовал собственный
        адрес электронной почты <literal>@FreeBSD.org</literal>, достаточно
        сменить адрес на <literal>@FreeBSD.org</literal>, подписаться, а
        затем сменить его обратно.</para>

      <para>Во FreshPorts имеется также функция проверки правильности,
        которая автоматически проверяет каждое изменение, внесённое в дерево
        портов FreeBSD.  Если вы подпишетесь на эту услугу, то будете
        оповещаться обо всех ошибках, обнаруженных FreshPorts при проверке
        внесённых вами изменений.</para>
    </sect1>

    <sect1 xml:id="svnweb">
      <title>Web-интерфейс к хранилищу исходных текстов</title>

      <para>Файлы в хранилище исходных текстов можно просматривать при помощи
        Web-интерфейса.  Изменения, которые касаются в целом всей системы
	портов, теперь документируются в файле <link xlink:href="http://svnweb.FreeBSD.org/ports/head/CHANGES">CHANGES</link>.
	Изменения, касающиеся отдельных портов, отражаются теперь в
	файле <link xlink:href="http://svnweb.FreeBSD.org/ports/head/UPDATING">UPDATING</link>.
	Однако однозначный ответ на любой вопрос можно найти, только
	прочитав исходных код <link xlink:href="http://svnweb.FreeBSD.org/ports/head/Mk/bsd.port.mk">bsd.port.mk</link>
	и связанных с ним файлов.</para>
    </sect1>

    <sect1 xml:id="ports-mailling-list">
      <title>Список рассылки &os;, посвящённый портам</title>

      <para>Если вы поддерживаете порты, то должны следить за &a.ports;.
        О важных изменениях, отражающихся на работе портов, будет сообщаться
        здесь, а затем они переносятся в <filename>CHANGES</filename>.</para>

      <para>Если данный список рассылки слишком загружен сообщениями,
	вы можете отслеживать &a.ports-announce.name;, который модерируется
	и не является местом для дискуссий.</para>
    </sect1>

    <sect1 xml:id="build-cluster">
      <title>Кластер построения портов &os; на
	<systemitem class="fqdomainname">pointyhat.FreeBSD.org</systemitem></title>

      <para>Одной из наименее известных сильных сторон &os; является тот
        факт, что для непрерывного построения Коллекции Портов для каждого
        из основных релизов ОС для каждой архитектуры уровня поддержки
        Tier-1 выделен целый кластер машин.  Вы можете увидеть результаты
        этих построений в <link xlink:href="http://pointyhat.FreeBSD.org/">протоколах
        построения пакетов и обнаруженных ошибок</link>.</para>

      <para>Отдельные порты собираются, если они специально не помечены как
	<varname>IGNORE</varname>.  Для портов, помеченных как
	<varname>BROKEN</varname>, попытки будут продолжены для того,
	чтобы увидеть, если основная проблема была решена.  (Это сделано
	через использование переменной <varname>TRYBROKEN</varname> для
	<filename>Makefile</filename> порта.)</para>

    </sect1>

    <sect1 xml:id="distfile-survey">
      <title>Portscout: сканер дистрибутивных файлов портов &os;</title>

      <para>Кластер построения выделен для выполнения самого последнего
        релиза каждого из портов, дистрибутивные файлы которых уже были
        сгружены.  Однако из-за постоянных изменений в Internet
        дистрибутивные файлы могут быстро исчезать.  <link xlink:href="http://portscout.FreeBSD.org">Portscout</link>, средство
	сканирования дистрибутивных файлов &os; пытается опросить
	каждый из сайтов, доступных для сгрузки каждого из портов,
        для определения того, доступны ли ещё дистрибутивные файлы.
	<application>Portscout</application> может готовить отчёты
	в <acronym>HTML</acronym> и рассылать электронные письма об
	имеющихся обновлениях для портов тем, кто это запрашивает.
	Мейнтейнеры периодически запрашивают наличие изменений, либо
	вручную, либо используя ленту <acronym>RSS</acronym>.</para>

      <para>Главная страница <application>Portscout</application>
	отображает email мейнтейнера порта, количество портов, за
	которые ответственен мейнтейнер, количество портов с новыми
	дистрибутивными файлами и процент устаревших портов.  Функция
	поиска выполняет поиск мейнтейнера по адресу электронной почты
	и позволяет выбирать между всеми портами или только
	устаревшими.</para>

      <para>При щелчке по адресу электронной почты мейнтейнера
	отображается список всех его портов, разделённых по категориям,
	вместе с текущим номером версии, информацией о наличии новой
	версии, временем последнего обновления порта и временем его
	последней проверки.  Функция поиска на этой странице позволяет
	пользователю выполнять поиск конкретного порта.</para>

      <para>По щелчку на название порта в списке отображается информация
	о порте <link xlink:href="http://freshports.org">FreshPorts</link>.</para>
    </sect1>

    <sect1 xml:id="portsmon">
      <title>Система мониторинга портов &os;</title>

      <para>Другим полезным ресурсом является <link xlink:href="http://portsmon.FreeBSD.org">Система мониторинга портов
        FreeBSD</link> (известная также как <literal>portsmon</literal>).
        Система представляет собой базу данных, обрабатывающую информацию из
        нескольких источников и позволяющую просматривать их при помощи
        Web-интерфейса.  На данный момент задействованы база сообщений об
        ошибках (PR), протоколы ошибок кластера построения и отдельные файлы
        из коллекции портов.  В будущем в этот список будет добавлена система
        проверки дистрибутивных файлов и другие ресурсы.</para>

      <para>Для начала вы можете просмотреть всю информацию о некотором порте
        при помощи средства <link xlink:href="http://portsmon.FreeBSD.org/portoverview.py">Обзор
        отдельного порта</link>.</para>

      <para>На момент написания это единственный доступный ресурс, который
	для имени порта ставит в соответствие записи PR GNATS.
	(Отправители PR не всегда добавляют в название имя порта, хотя
	мы предпочитаем, чтобы они это делали.)  Таким образом,
	<literal>portsmon</literal> это хорошее место для начала, если вы
	хотите найти присланные PR и/или ошибки построения для существующего
	порта; либо поискать, был ли уже прислан новый порт, который вы
	подумывали создать сами.</para>
    </sect1>
  </chapter>

  <chapter xml:id="appendices">
    <title>Приложения</title>

    <sect1 xml:id="uses-values">
      <title>Значения <varname>USES</varname></title>

      <table frame="none">
	<title>Значения <varname>USES</varname></title>

	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Наименование</entry>
	      <entry>Аргументы</entry>
	      <entry>Описание</entry>
	    </row>
	  </thead>
	  <tbody>
	    &values.uses;
	  </tbody>
	</tgroup>
      </table>
    </sect1>

    <sect1 xml:id="freebsd-versions">
      <title>Значения <literal>__FreeBSD_version</literal></title>

      <para>Ниже для справки приводится перечень значений
        <literal>__FreeBSD_version</literal> в виде, который определён в
	<link xlink:href="http://svnweb.FreeBSD.org/base/head/sys/sys/param.h?view=markup">sys/param.h</link>:</para>

      <table frame="none">
        <title>Значения <literal>__FreeBSD_version</literal></title>

        <tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Значение</entry>
	      <entry>Дата</entry>
	      <entry>Релиз</entry>
	    </row>
	  </thead>

	  <tbody>
	    &values.versions;
	  </tbody>
	</tgroup>
      </table>

      <note>
	<para>Заметьте, что 2.2-STABLE иногда идентифицирует себя как
	  <quote>2.2.5-STABLE</quote> после 2.2.5-RELEASE.  Такой принцип
	  использовался год и месяц, но мы решили изменить его на более
	  однозначную систему нумерации старший/младший, начиная с версии
	  2.2.	Это объясняется тем, что параллельная разработка в нескольких
	  ветках делает непрактичным идентификацию релизов просто по их
	  реальным датам выпуска.  Если вы сейчас делаете порт, вам не стоит
	  заботиться о старых версиях -CURRENT; они перечислены здесь просто
	  в информационных целях.</para>
      </note>
    </sect1>
  </chapter>
</book>
