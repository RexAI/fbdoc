<?xml version="1.0" encoding="koi8-r"?>
<!--
     The FreeBSD Russian Documentation Project

     $FreeBSD$
     $FreeBSDru: frdp/doc/ru_RU.KOI8-R/books/handbook/cutting-edge/chapter.xml,v 1.52 2006/06/20 18:02:32 marck Exp $

     Original revision: r33528
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="updating-upgrading">
  <info><title>Обновление системы и смена версии</title>
    <authorgroup>
      <author><personname><firstname>Jim</firstname><surname>Mock</surname></personname><contrib>Реструктурирование, реорганизацию и частичное обновление
	  выполнил </contrib></author>
      <!-- Март 2000 -->
    </authorgroup>

    <authorgroup>
      <author><personname><firstname>Jordan</firstname><surname>Hubbard</surname></personname><contrib>Оригинальный текст написали </contrib></author>

      <author><personname><firstname>Poul-Henning</firstname><surname>Kamp</surname></personname></author>

      <author><personname><firstname>John</firstname><surname>Polstra</surname></personname></author>

      <author><personname><firstname>Nik</firstname><surname>Clayton</surname></personname></author>
    </authorgroup>
    
    <authorgroup>
      <author><personname><firstname>Андрей</firstname><surname>Захватов</surname></personname><contrib>Перевод на русский язык: </contrib></author>
    </authorgroup>
  </info>

  

  <sect1 xml:id="updating-upgrading-synopsis">
    <title>Краткий обзор</title>

    <para>Между релизами над &os; ведется постоянная работа.  Некоторые
      отдают предпочтение официально выпущенным версиям, в то время как
      остальные предпочитают использовать последние разработки.  Тем не
      менее, даже для официальных версий часто выходят обновления,
      связанные с безопасностью и другими критическими исправлениями.
      Независимо от используемой версии &os; предоставляет все необходимые
      инструменты для поддержания системы в актуальном состоянии, а также
      позволяет легко перейти на другую версию.  Эта глава поможет
      вам решить, хотите ли вы отслеживать систему в процессе работы над ней
      или останетесь верным одному из выпущенных релизов.  Также имеются
      простейшие инструменты для поддержания вашей системы в актуальном
      состоянии.</para>

    <para>После чтения этой главы вы будете знать:</para>

    <itemizedlist>
      <listitem>
	<para>Какие программы можно использовать для обновления системы и
	Коллекции Портов.</para>
      </listitem>

      <listitem>
	<para>Как поддерживать вашу систему в актуальном состоянии при
	  помощи <application>freebsd-update</application>,
	  <application>CVSup</application>, <application>CVS</application>
	  или <application>CTM</application>.</para>
      </listitem>

      <listitem>
	<para>Как узнать состояние установленной системы по отношению к
	  известной нетронутой копии.</para>
      </listitem>

      <listitem>
	<para>Разницу между двумя ветвями разработки: &os.stable; и
	  &os.current;.</para>
      </listitem>

      <listitem>
	<para>Как перестраивать и переустанавливать базовую систему полностью
	  при помощи <command>make buildworld</command> (и других).</para>
      </listitem>
    </itemizedlist>

    <para>Перед чтением этой главы вы должны:</para>

    <itemizedlist>
      <listitem>
	<para>Полностью настроить своё подключение к сети (<xref linkend="advanced-networking"/>).</para>
      </listitem>

      <listitem>
	<para>Знать, как устанавливать дополнительное программное обеспечение
	  других разработчиков (<xref linkend="ports"/>).</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>В этой главе для получения и обновления исходных текстов &os;
	используется команда <command>cvsup</command>.  Для этого вам
	нужно установить порт или пакет <package>net/cvsup-without-gui</package>.  Начиная с версии
	&os;&nbsp;6.2-RELEASE для этих целей можно воспользоваться командой
	&man.csup.1;, которая входит в состав системы.</para>
    </note>
  </sect1>
  
  <sect1 xml:id="updating-upgrading-freebsdupdate">
    <info><title>Обновление FreeBSD</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Оригинальный текст написал </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Colin</firstname><surname>Percival</surname></personname><contrib>На основе заметок, которые предоставил  </contrib></author>
      </authorgroup>
    </info>
    

    <indexterm><primary>обновление и смена версии</primary></indexterm>
    <indexterm>
      <primary>freebsd-update</primary>
      <see>обновление и смена версии</see>
    </indexterm>

    <para>Применение обновлений безопасности &mdash; важный момент в
      сопровождении программного обеспечения, особенно такого как
      операционная система.  Для &os; этот процесс не был простым в
      течение долгого времени.  На исходный код нужно было накладывать
      патчи, перестраивать код в двоичные файлы, а затем эти двоичные файлы
      требовалось переустановить. </para>

    <para>Теперь это давно не так, и &os; включает программу с простым
      названием <command>freebsd-update</command>.  Эта программа
      предоставляет две различные функции.  Во-первых, она позволяет
      применить к базовой системе &os; обновления безопасности и критические
      исправления в двоичном виде, без необходимости сборки и установки.
      Во-вторых, программа поддерживает обновление системы со сменой
      старшего или младшего номера версии.</para>

    <note>
      <para>Двоичные обновления доступны для всех архитектур и версий,
	поддерживаемых группой безопасности; тем не менее, для работы
	некоторых из возможностей, таких как смена версии операционной
	системы &os;, требуется последняя версия &man.freebsd-update.8;
	и по крайней мере &os; 6.3.  Перед обновлением до новой версии
	следует ознакомиться с объявлением о выпуске текущей версии, так
	как там может содержаться важная информация, применимая к версии,
	на которую намечен переход.  С соответствующими объявлениями можно
	ознакомиться, перейдя по следующей ссылке: <uri xlink:href="http://www.FreeBSD.org/releases/">http://www.FreeBSD.org/releases/</uri>.</para>
    </note>

    <para>Если имеется задание <command>crontab</command>, запускающее
      <command>freebsd-update</command>, то перед началом выполнения
      следующих действий его обязательно нужно выключить.</para>

    <sect2>
      <title>Конфигурационный файл</title>

      <para>Некоторые пользователи могут пожелать изменить
	конфигурационный файл для лучшего контроля над процессом
	обновления.  Все параметры подробно задокументированы, но
	для некоторых из них может понадобиться дополнительное
	разъяснение:</para>

      <programlisting># Components of the base system which should be kept updated.
Components src world kernel</programlisting>

      <para>Данный параметр определяет, какие части &os; будут обновлены.
	По умолчанию обновляется исходный код (src), вся базовая система
	(world) и ядро (kernel).  Компоненты те же самые, что и во время
	установки; в частности, добавление "world/games" позволяет
	обновить игры.  Использование "src/bin" позволяет обновить
	исходный код в <filename>src/bin</filename>.</para>

      <para>Лучшим вариантом будет оставить всё как есть, поскольку
	изменение этого перечня с целью добавления особых пунктов
	потребует от пользователя указания подряд всех пунктов, которые
	пользователь захочет обновить.  Это может привести к негативным
	последствиям из-за возможной рассинхронизации между исходными
	текстами и двоичными файлами.</para>

      <programlisting># Paths which start with anything matching an entry in an IgnorePaths
# statement will be ignored.
IgnorePaths</programlisting>

      <para>Добавьте сюда пути к каталогам (например, <filename>/bin</filename> или <filename>/sbin</filename>), которые вы хотели бы
	оставить нетронутыми в процессе обновления.  Этот параметр можно
	использовать для предотвращения перезаписывания локальных
	изменений программой <command>freebsd-update</command>.</para>

      <programlisting># Paths which start with anything matching an entry in an UpdateIfUnmodified
# statement will only be updated if the contents of the file have not been
# modified by the user (unless changes are merged; see below).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</programlisting>

      <para>Обновлять конфигурационные файлы в указанных каталогах, только
	если они не содержат изменений.  При наличии каких-либо изменений
	со стороны пользователя автоматическое обновление таких файлов
	отменяется.  Есть другой параметр
	<literal>KeepModifiedMetadata</literal>, который предписывает
	команде <command>freebsd-update</command> сохранять изменения во
	время процесса слияния.</para>

      <programlisting># When upgrading to a new &os; release, files which match MergeChanges
# will have any local changes merged into the version from the new release.
MergeChanges /etc/ /var/named/etc/</programlisting>

      <para>Список каталогов с конфигурационными файлами, для которых
	<command>freebsd-update</command> попытается выполнить слияние.
	Процесс слияния файла представляет собой набор изменений
	в формате &man.diff.1;, похож на &man.mergemaster.8;, но с
	меньшим количеством параметров: результат слияния принимается,
	открывается редактор или <command>freebsd-update</command>
	прекращает свою работу.  В случае сомнений сделайте резервную
	копию <filename>/etc</filename> и просто
	согласитесь со всеми изменениями.  Для получения подробной
	информации по команде <command>mergemaster</command> смотрите
	<xref linkend="mergemaster"/>.</para>

      <programlisting># Directory in which to store downloaded updates and temporary
# files used by &os; Update.
# WorkDir /var/db/freebsd-update</programlisting>

      <para>Этот каталог предназначен для размещения патчей и временных
	файлов.  В случае, когда пользователь выполняет обновление со сменой
	версии, в этом месте должен иметь по крайней мере гигабайт дискового
	пространства.</para>

      <programlisting># When upgrading between releases, should the list of Components be
# read strictly (StrictComponents yes) or merely as a list of components
# which *might* be installed of which &os; Update should figure out
# which actually are installed and upgrade those (StrictComponents no)?
# StrictComponents no</programlisting>

      <para>Если выставлено значение <literal>yes</literal>, то
	<command>freebsd-update</command> будет исходить из того, что
	список <literal>Components</literal> является полным, и не будет
	пытаться выполнить изменения за пределами этого списка. 
	В действительности <command>freebsd-update</command> попытается
	обновить все файлы, которые принадлежат списку
	<literal>Components</literal>.</para>
    </sect2>

    <sect2>
      <title>Обновления безопасности</title>

      <para>Обновления безопасности хранятся на удалённой машине и могут
	быть загружены и установлены с использованием следующей
	команды:</para>

      <screen>&prompt.root; <userinput>freebsd-update fetch</userinput>
&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Если были установлены обновления ядра, то после этого
	нужно перезагрузить систему.  Если все пошло хорошо, система
	должна быть с установленными исправлениями, и
	<command>freebsd-update</command> можно запускать в качестве ночного
	задания &man.cron.8;.  Для этого достаточно добавить следующую
	запись в <filename>/etc/crontab</filename>:</para>

      <programlisting>@daily                                  root    freebsd-update cron</programlisting>

      <para>Эта запись означает, что <command>freebsd-update</command> будет
	запускаться ежедневно.  В данном случае, в соответствии с аргументом
	<option>cron</option> <command>freebsd-update</command> ограничится
	проверкой доступных обновлений.  В случае наличия обновлений они
	будут автоматически загружены и сохранены на локальном диске. 
	Пользователю <systemitem class="username">root</systemitem> будет отправлено
	соответствующее письмо, так что эти обновления можно будет
	установить самостоятельно.</para>

      <para>На случай, если что-то пошло не так, в
	<command>freebsd-update</command> предусмотрен механизм возврата
	последнего набора изменений с использованием следующей команды:</para>

      <screen>&prompt.root; <userinput>freebsd-update rollback</userinput></screen>

      <para>Если после завершения всех действий было изменено ядро или
	какой-либо из его модулей, система должна быть перезагружена. 
	Это позволит &os; загрузить новые двоичные файлы в память.</para>

      <note>
	<para>Команда <command>freebsd-update</command> работает только
	  с ядром <filename>GENERIC</filename>.  Если в
	  <filename>GENERIC</filename> присутствуют изменения или
	  используется собственная конфигурация ядра,
	  <command>freebsd-update</command> завершится неудачно.</para>
      </note>
    </sect2>

    <sect2>
      <title>Обновления со сменой старшей и младшей версий</title>

      <para>Этот процесс удаляет старые объектные файлы и библиотеки, что
	может нарушить работу большинства сторонних приложений.  Все
	установленные порты рекомендуется либо удалить и переустановить
	заново, либо обновить с использованием программы <package>ports-mgmt/portupgrade</package>.  Большинство
	пользователей предпочтут выполнить тестовое построение, запустив для
	этого следующую команду:</para>

      <screen>&prompt.root; <userinput>portupgrade -af</userinput></screen>

      <para>Это позволит убедиться в том, что всё будет переустановлено
	правильно.  Обратите внимание, что если переменной окружения
	<varname>BATCH</varname> присвоить значение <literal>yes</literal>,
	то на все вопросы в течение этого процесса будет возвращаться
	ответ <literal>yes</literal>, что позволит исключить необходимость
	ручного вмешательства в процесс построения.</para>

      <para>Обновления со сменой старшей и младшей версий можно выполнить,
	указав значение версии, на которую будет произведен переход, в
	качестве аргумента команды <command>freebsd-update</command>.
	Так, например, можно выполнить обновление до версии
	&os;&nbsp;6.3:</para>

      <screen>&prompt.root; <userinput>freebsd-update -r 6.3-RELEASE upgrade</userinput></screen>

      <para>После своего запуска <command>freebsd-update</command>
	анализирует содержимое конфигурационного файла и собирает
	необходимую для проведения обновления информацию о текущей
	установленной системе.  На экран будет выдан перечень компонентов,
	которые удалось и не удалось обнаружить установленными. 
	Например:</para>

      <screen>Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature for 6.3-BETA1 from update1.FreeBSD.org... done.
Fetching metadata index... done.
Inspecting system... done.

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD do not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable (y/n)? y</screen>

      <para>Следующим шагом <command>freebsd-update</command> попытается
	загрузить по сети файлы, необходимые для выполнения обновления.
	В некоторых случаях может потребоваться ответить на вопросы
	относительно того, что и как устанавливать.</para>

      <para>После того, как все изменения были загружены, они будут
	применены.  Этот процесс может занять определённое время, в
	зависимости от производительности и текущей загруженности
	компьютера.  Затем будет выполнено слияние конфигурационных файлов
	&mdash; эта часть процесса требует от пользователя определённого
	вмешательства, так как для файла можно выполнить слияние
	автоматически, а можно открыть текстовый редактор для слияния
	вручную.  Результат успешного слияния будет показан на экране.
	Неудачное или пропущенное слияние вызовет преждевременное завершение
	программы.  Можно подготовить резервную копию каталога <filename>/etc</filename> для таких важных файлов как
	<filename>master.passwd</filename> и <filename>group</filename> и 
	выполнить их слияние вручную позднее.</para>

      <note>
	<para>На данном этапе система еще не модифицирована, и все изменения
	  и слияния происходят в отдельном каталоге.  Теперь, когда все
	  изменения успешно применены, все конфигурационные файлы слиты и
	  кажется, что процесс должен пройти плавно, пользователь должен
	  установить изменения.</para>
      </note>

      <para>После завершения этого процесса, изменения могут быть
	установлены на диск с помощью следующей команды.</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>В первую очередь изменения будут применены к ядру и его модулям. 
	После этого компьютер должен быть перезагружен.  Следующая команда
	выполнит перезагрузку компьютера, после чего будет загружено новое
	ядро:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <para>После перезагрузки нужно повторно запустить команду
	<command>freebsd-update</command>.  Команда прочитает, на каком
	этапе она находится, и перейдёт к удалению старых объектных файлов
	и совместно используемых библиотек.  Чтобы перейти к этому этапу,
	выполните следующую команду:</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <note>
	<para>Количество этапов установки обновлений может быть два вместо
	  трёх и зависит от того, были ли изменены номера версий каких-либо
	  совместно используемых библиотек.</para>
      </note>

      <para>Теперь понадобится пересобрать и переустановить всё стороннее
	программное обеспечение.  Это необходимая операция, так как
	установленное программное обеспечение может зависеть от библиотек,
	которые были удалены в процессе смены версии операционной системы.
	Для автоматизации этого процесса можно воспользоваться командой
	<package>ports-mgmt/portupgrade</package>.
	Начать можно со следующих команд:</para>

      <screen>&prompt.root; <userinput>portupgrade -f ruby</userinput>
&prompt.root; <userinput>rm /var/db/pkg/pkgdb.db</userinput>
&prompt.root; <userinput>portupgrade -f ruby18-bdb</userinput>
&prompt.root; <userinput>rm /var/db/pkg/pkgdb.db /usr/ports/INDEX-*.db</userinput>
&prompt.root; <userinput>portupgrade -af</userinput></screen>

      <para>После этого завершите процесс обновления последним запуском
	<command>freebsd-update</command>.  Выполните следующую команду,
	чтобы убедиться, что ничего не забыто в процессе обновления:</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Перезагрузите компьютер с новой версией &os;.  На этом процесс
	завершён.</para>
    </sect2>

    <sect2>
      <title>Сравнение состояния системы</title>

      <para>Утилита <command>freebsd-update</command> может быть
	использована для проверки состояния установленной версии &os;
	относительно известной хорошей копии.  Оценивается текущая версия
	системных утилит, библиотек и конфигурационных файлов.  Для того,
	чтобы начать сравнение, выполните следующую команду:</para>

      <screen>&prompt.root; <userinput>freebsd-update IDS &gt;&gt; outfile.ids</userinput></screen>

      <warning>
	<para>Не смотря на то, что команда называется
	  <acronym>IDS</acronym>, это ни в коей мере не должно являться
	  заменой системе обнаружения вторжений, такой как <package>security/snort</package>.  Поскольку
	  <command>freebsd-update</command> сохраняет свои данные на
	  диске, возможность подмены становится очевидной.  И хотя эта
	  возможность может быть уменьшена при использовании настройки
	  <varname>kern.securelevel</varname>, а также используя для
	  записи данных <command>freebsd-update</command> файловую
	  систему, которая в остальное время смонтирована только на
	  чтение, лучшим решением будет сравнить систему относительно
	  эталона на физически защищенном носителе, таком как
	  <acronym>DVD</acronym> или внешний <acronym>USB</acronym> диск
	  с включённой защитой от записи.</para>
      </warning>

      <para>Теперь запустится проверка системы, в результате которой будет
	выведен список файлов с их контрольными суммами в &man.sha256.1; с
	известным значением для файла из релиза и значением для текущего
	в системе.  Результат выводится слишком быстро для наглядного
	сравнения и вскоре заполняет консольный буфер.  По этой причине в
	данном примере вывод перенаправлен в файл
	<filename>outfile.ids</filename>.</para>

      <para>Эти строки также очень длинные, но зато такой формат вывода
	удобен для разбора.  Так, для получения списка всех отличающихся
	от релиза файлов достаточно выполнить такую команду:</para>

      <screen>&prompt.root; <userinput>cat outfile.ids | awk '{ print $1 }' | more</userinput>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</screen>

      <para>Вывод специально обрезан, на самом деле файлов намного больше.
	Некоторые из них изменены в ходе нормальной работы: так, файл
	<filename>/etc/passwd</filename> был изменён после заведения
	пользователей в системе.  В некоторых случаях могут быть и другие
	файлы, такие как модули ядра, которые могли измениться вследствие
	обновления через <command>freebsd-update</command>.  Для
	исключения из проверки конкретных файлов и каталогов укажите их
	в качестве значения параметра <literal>IDSIgnorePaths</literal>
	в <filename>/etc/freebsd-update.conf</filename>.</para>

      <para>Эта система может использоваться как часть более сложной
	процедуры обновления, в отличие от описанного выше способа.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="updating-upgrading-portsnap">
    <info><title>Portsnap: средство обновления Коллекции Портов</title>
      <authorgroup>
        <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Предоставил </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Colin</firstname><surname>Percival</surname></personname><contrib>На основе заметок, которые предоставил </contrib></author>
      </authorgroup>
    </info>
    

    <indexterm><primary>обновление и смена версии</primary></indexterm>
    <indexterm>
      <primary>Portsnap</primary>
      <see>обновление и смена версии</see>
    </indexterm>

    <para>Для обновления Коллекции Портов в базовую поставку &os;
      включена утилита &man.portsnap.8;.  Во время её выполнения
      устанавливается соединение с удалённым сервером, проверяется
      правильность ключа и загружается новая копия Коллекции Портов.
      Ключ используется для проверки целостности загруженных файлов
      для исключения возможности подмены на этапе передачи файлов.
      Для получения последней версии файлов Коллекции Портов выполните
      следующую команду:</para>

    <screen>&prompt.root; <userinput>portsnap fetch</userinput>
Looking up portsnap.FreeBSD.org mirrors... 3 mirrors found.
Fetching snapshot tag from portsnap1.FreeBSD.org... done.
Fetching snapshot metadata... done.
Updating from Wed Aug  6 18:00:22 EDT 2008 to Sat Aug 30 20:24:11 EDT 2008.
Fetching 3 metadata patches.. done.
Applying metadata patches... done.
Fetching 3 metadata files... done.
Fetching 90 patches.....10....20....30....40....50....60....70....80....90. done.
Applying patches... done.
Fetching 133 new ports or files... done.</screen>

    <para>В данном примере показано, что &man.portsnap.8; обнаружила
      и верифицировала несколько патчей относительно текущего содержимого
      портов.  Здесь также видно, что утилита уже запускалась ранее,
      иначе при первом запуске была бы загружена вся коллекция.</para>

    <para>После того как &man.portsnap.8; успешно завершила операцию
      <command>fetch</command>, Коллекция Портов и сопутствующие патчи
      находятся на локальной системе и прошли проверку целостности.
      Обновлённые файлы можно установить командой:</para>

    <screen>&prompt.root; <userinput>portsnap extract</userinput>
/usr/ports/.cvsignore
/usr/ports/CHANGES
/usr/ports/COPYRIGHT
/usr/ports/GIDs
/usr/ports/KNOBS
/usr/ports/LEGAL
/usr/ports/MOVED
/usr/ports/Makefile
/usr/ports/Mk/bsd.apache.mk
/usr/ports/Mk/bsd.autotools.mk
/usr/ports/Mk/bsd.cmake.mk
<replaceable>...</replaceable></screen>

    <para>На этом процесс завершён, и теперь приложения можно
      установить или обновить с использованием Коллекции Портов.</para>

    <para>Для последовательного запуска обоих процессов выполните
      следующую команду:</para>

    <screen>&prompt.root; <userinput>portsnap fetch update</userinput></screen>
  </sect1>    

  <sect1 xml:id="current-stable">
    <title>Использование ветви разработки</title>
    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>Во FreeBSD имеется две ветки разработки: &os.current; и &os.stable;.
      Этот раздел описывает каждую из них и объясняет, как синхронизировать
      вашу систему с любой из веток.  Сначала будет обсуждаться ветка
      &os.current;, затем &os.stable;.</para>

    <sect2 xml:id="current">
      <title>Как следовать текущим разработкам во &os;</title>

      <para>Пока вы читаете этот текст, помните, что &os.current; является
	<quote>передовым краем</quote> работ над &os;.  Предполагается, что
	пользователи &os.current; технически более грамотны и могут решать
	проблемы с системой самостоятельно.  Если вы являетесь во &os;
	новичком, вам лучше сначала дважды подумать, прежде чем
	её устанавливать.</para>

      <sect3>
	<title>Что такое &os.current;?</title>
	<indexterm><primary>snapshot</primary></indexterm>

	<para>&os.current; является последними рабочими версиями исходных
	  текстов &os;.  Сюда включаются неоконченные работы, экспериментальные
	  изменения и промежуточные механизмы, которые могут присутствовать, а
	  могут и отсутствовать в следующем официальном релизе программного
	  обеспечения.  Хотя многие из разработчиков &os; выполняют компиляцию
	  из исходных текстов &os.current; ежедневно, случаются периоды, когда
	  исходные тексты заведомо не могут быть откомпилированы.  Такие
	  проблемы обычно решаются так быстро, как это возможно, но всё-таки
	  момент, когда вы загрузили исходные тексты &os.current;, может
	  повлиять на то, содержат они мину замедленного действия или очень
	  нужную функциональность!</para>
      </sect3>

      <sect3>
	<title>Кому нужна &os.current;?</title>

	<para>&os.current; предназначается трём основным заинтересованным
	  группам:</para>

	<orderedlist>
	  <listitem>
	    <para>Участники проекта &os;, активно работающие над
	      некоторой частью дерева исходных текстов и для кого работа в
	      <quote>current</quote> является абсолютной
	      необходимостью.</para>
	  </listitem>

	  <listitem>
	    <para>Участники проект &os;, которые являются
	      активными тестерами.  Они тратят свое время на
	      исправление проблем для того, чтобы &os.current; оставалась,
	      насколько это возможно, нормально работающей системой.  Есть
	      также люди, которые вносят важные предложения по изменениям и
	      общему направлению развития &os; и присылают свои патчи,
	      реализующие эти изменения.</para>
	  </listitem>

	  <listitem>
	    <para>Те, кто просто хотят быть в курсе всех изменений или
	      используют текущие исходные тексты для ознакомительных целей (к
	      примеру, для <emphasis>чтения</emphasis>, но не для
	      использования).  Такие люди также иногда высказывают замечания
	      или предоставляют код.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Чем &os.current; <emphasis>не</emphasis> является?</title>

	<orderedlist>
	  <listitem>
	    <para>Быстрым способом получить предварительную версию, в
	      случае, если вы услышали, что здесь появилась некая крутая
	      возможность, и вы хотите быть первым в вашем микрорайоне, у
	      кого она есть.  Здесь быть первым из тех, кто имеет это
	      программное обеспечение означает также быть первым из тех, кто
	      столкнулся с ошибками в нём.</para>
	  </listitem>

	  <listitem>
	    <para>Быстрым способом получения исправлений.  Любая версия
	      &os.current; является в равной мере как источником исправлений
	      существующих ошибок, так и источником появления новых.</para>
	  </listitem>

	  <listitem>
	    <para><quote>Официально поддерживаемой</quote> каким бы то ни было
	      способом.  Мы прилагаем все усилия, чтобы помочь тем, кто
	      изначально принадлежит одной из трех <quote>признанных</quote>
	      групп пользователей &os.current;, но у нас просто <emphasis>нет
	      времени</emphasis> на техническую поддержку.  Это не потому, что
	      мы гадкие и злые люди, которые ни за что не будут помогать другим
	      (если бы это было так, мы бы не создали &os;).  Мы просто не в
	      силах отвечать на сотни сообщений в день <emphasis>и</emphasis>
	      работать над FreeBSD!  Если бы стоял выбор между тем, отвечать ли
	      на множество вопросов об экспериментально коде или продолжать
	      работу над совершенствованием &os;, большинство разработчиков
	      проголосовало бы за последнее.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Использование &os.current;</title>

	<orderedlist>
	  <listitem>
	    <para>Подпишитесь на списки рассылки &a.current.name;<indexterm><primary>-CURRENT</primary><secondary>использование</secondary></indexterm> и
	      &a.svn-src-head.name;.  Это не просто хорошая идея, это
	      <emphasis>необходимость</emphasis>.  Если вы не являетесь
	      участником списка рассылки <emphasis>&a.current.name;</emphasis>,
	      то вы не увидите замечаний,
	      высказываемых о текущем состоянии системы и в итоге можете
	      столкнуться со множеством проблем, которые уже были найдены и
	      решены другими.  Ещё хуже, если вы пропустите важные сообщения,
	      касающиеся жизнеспособности вашей системы.</para>

	    <para>Список рассылки &a.svn-src-head.name; позволит вам для каждого
	      изменения увидеть соответствующую запись в журнале коммитов,
	      а они порой содержат относящуюся к делу
	      информацию о возможных побочных эффектах.</para>

	    <para>Чтобы подписаться на эти и другие доступные списки
	      рассылки, перейдите по ссылке &a.mailman.lists.link; и щёлкните
	      на списке, к которому вы хотите подключиться.  Инструкции по
	      дальнейшим действиям размещены там же.  Если вы заинтересованы
	      в отслеживании изменений всего дерева исходных текстов, то мы
	      рекомендуем вам подписаться на &a.svn-src-all.name;.</para>
	  </listitem>

	  <listitem>
	    <para>Загрузите исходные тексты с <link linkend="mirrors">зеркального сайта</link> &os;.  Вы можете
	      сделать это одним из следующих двух способов:</para>

	    <orderedlist>
	      <listitem>
		<para>При помощи программы <link linkend="cvsup">cvsup</link><indexterm><primary><command>cvsup</command></primary></indexterm>
		  с <filename>sup</filename>-файлом
		  <filename>standard-supfile</filename>, который можно найти в
		  каталоге <filename>/usr/share/examples/cvsup</filename>.  Это
		  наиболее
		  рекомендуемый метод, так как он позволяет вам загрузить набор
		  исходных текстов один раз полностью, а затем загружать только
		  произошедшие изменения.  Многие запускают
		  <command>cvsup</command> при помощи программы
		  <command>cron</command><indexterm><primary><command>cron</command></primary></indexterm> и получают самые свежие исходные
		  тексты автоматически.  Измените примерный файл
		  <filename>supfile</filename> выше и отконфигурируйте <link linkend="cvsup">cvsup</link><indexterm><primary>-CURRENT</primary><secondary>Синхронизация при помощи <application>CVSup</application></secondary></indexterm> для вашего окружения.</para>
		<note>
		  <para>Примерный файл <filename>standard-supfile</filename>
		    предназначен для отслеживания специальной ветки
		    безопасности &os;, а не &os.current;.  Вам нужно
		    открыть этот файл на редактирование и заменить в нём
		    строку:</para>

		  <programlisting>*default release=cvs tag=RELENG_<replaceable>X</replaceable>_<replaceable>Y</replaceable></programlisting>

		  <para>на следующую:</para>

		  <programlisting>*default release=cvs tag=.</programlisting>

		  <para>Для получения подробной информации по использованию
		  тегов обратитесь к разделу Руководства <link linkend="cvs-tags">Теги CVS</link>.</para>
		</note>
	      </listitem>

	      <listitem>
		<indexterm>
		  <primary>-CURRENT</primary>
		  <secondary>Синхронизация при помощи CTM</secondary>
		</indexterm>

		<para>При помощи <application>CTM</application>.  Если у вас очень
		  плохое подключение (дорогое или предоставляющее доступ только
		  к электронной почте), то <application>CTM</application>
		  можно рассматривать как вариант.  Однако в нем много
		  &quot;подводных камней&quot;, и его использование может
		  привести к появлению неправильных файлов.  Это привело к
		  тому, что этот способ используется редко, что, в свою
		  очередь, увеличивает шанс появления периодов его
		  неработы.  Мы рекомендуем использовать <application>CVSup</application> всем, чья скорость
		  подключения равна 9600&nbsp;bps и выше.</para>
	      </listitem>
	    </orderedlist>
	  </listitem>

	  <listitem>
	    <para>Если вам нужны исходные тексты для компиляции и запуска, а
	      не просто для ознакомления, то загружайте исходные тексты
	      ветки &os.current; <emphasis>полностью</emphasis>, а не отдельные
	      ее части.  Причиной является то, что многие части исходных
	      текстов зависят от других обновлений где-то еще, и попытка
	      компиляции лишь некоторой части программ в этом случае
	      гарантированно вызовет проблемы.</para>

	    <para>Перед тем, как компилировать &os.current;<indexterm><primary>-CURRENT</primary><secondary>компиляция</secondary></indexterm>, внимательно
	      прочтите файл <filename>Makefile</filename> в каталоге
	      <filename>/usr/src</filename>.  В процессе обновления вы
	      по крайней мере раз должны пройти через <link linkend="makeworld">установку нового ядра и перестроение всех
	      компонентов системы</link>.  Чтение списка рассылки &a.current.name; и
	      <filename>/usr/src/UPDATING</filename> позволит вам быть в курсе
	      всех процедур, которые иногда бывают необходимы в процессе
	      работы над следующим релизом.</para>
	  </listitem>

	  <listitem>
	    <para>Будьте активным подписчиком!  Если вы работаете с
	      &os.current;, мы хотим знать, что вы думаете о ней, особенно
	      если у вас есть соображения по ее улучшению или исправлению
	      ошибок.  Пожелания, к которым прилагается код, всегда
	      принимаются с большим энтузиазмом!</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>

    <sect2 xml:id="stable">
      <title>Работа с веткой stable во &os;</title>

      <sect3>
	<title>Что такое &os.stable;?</title>
	<indexterm><primary>-STABLE</primary></indexterm>

	<para>&os.stable; является нашей веткой разработки, из которой делаются
	  основные релизы.  Изменения в этой ветке происходят с разной
	  скоростью, и при этом предполагается, что сначала они были выполнены
	  для &os.current; в целях тестирования.  Однако эта ветка
	  <emphasis>остаётся</emphasis> веткой для разработки, а это значит,
	  что в любой момент времени исходные тексты &os.stable; могут
	  оказаться неприменимы для некоторой задачи.  Это просто ещё одна
	  ветка при разработке, а не ресурс для конечных пользователей.</para>
      </sect3>

      <sect3>
	<title>Кому нужна &os.stable;?</title>

	<para>Если вы заинтересованы в отслеживании процесса разработки FreeBSD
	  или хотите принять в нём участие, особенно в той мере, насколько это
	  касается выпуска следующего релиза FreeBSD с <quote>точкой</quote>, то
	  вам необходимо отслеживать &os.stable;.</para>

	<para>Хотя правда то, что исправления, касающиеся безопасности, также
	  делаются и в ветке &os.stable;, вам <emphasis>не нужно</emphasis>
	  для этого отслеживать &os.stable;.  Каждый бюллетень по безопасности
	  FreeBSD описывает, как решить проблему для тех релизов, которых он
	  касается
	  <footnote>
	    <para>Это не совсем так.  Мы не можем поддерживать старые релизы
	      FreeBSD бесконечно долго, хотя мы поддерживаем их многие годы.
	      Полное описание текущей политики безопасности относительно
	      старых релизов FreeBSD можно найти по адресу <link xlink:href="&url.base;/ru/security/">
	      http://www.FreeBSD.org/ru/security/</link>.</para>
	  </footnote>
	  , а отслеживание ветки разработки в полном объёме только ради
	  исправлений пробелов в безопасности приводит к появлению большого
	  количества дополнительных ненужных изменений.</para>

	<para>Хотя мы прилагаем все усилия, чтобы ветка &os.stable; всегда
	  компилировалась и работала, этого нельзя гарантировать.  Кроме того,
	  несмотря на то, что перед включением в &os.stable;, код
	  разрабатывается в &os.current;, гораздо большее количество людей
	  работают с &os.stable;, чем с &os.current;.  Поэтому неудивительно,
	  что в &os.stable; иногда
	  обнаруживаются ошибки и всплывают непредвиденные ситуации, которые не
	  проявляли себя в &os.current;.</para>

	<para>По этим причинам мы <emphasis>не</emphasis> рекомендуем слепо
	  отслеживать &os.stable;, и, что особенно важно, вы не должны
	  обновлять какие-либо сервера, находящиеся в активной эксплуатации, до
	  &os.stable; без предварительного тщательного тестирования кода в
	  вашей среде разработки.</para>

	<para>Если у вас нет возможности сделать это, то мы рекомендуем
	  работать с самой последним релизом &os; и использовать механизм
	  обновления бинарных файлов для перехода от релиза к релизу.</para>
      </sect3>

      <sect3>
	<title>Использование &os.stable;</title>

	<orderedlist>
	  <listitem>
	    <para>Подпишитесь на список рассылки &a.stable.name;<indexterm><primary>-STABLE</primary><secondary>использование</secondary></indexterm>.  Это позволит
	      вам узнавать о зависимостях процесса компиляции,
	      которые могут появиться в ветке &os.stable; или
	      любых других проблемах, требующих особого внимания.  В этом
	      списке рассылки разработчики также делают объявления о
	      спорных исправлениях или добавлениях,
	      давая пользователям возможность высказать свое мнение о
	      возможных тонких моментах.</para>

	    <para>Присоединяйтесь к соответствующему списку рассылки
	      <application>SVN</application> для той ветви, которую вы
	      используете.  Например, если вы используете ветвь 7-STABLE, то
	      присоединяйтесь к списку &a.svn-src-stable-7.name;.  Это
	      позволит вам просматривать записи в журнале коммитов для
	      каждого изменения, а они порой содержат относящуюся к делу
	      информацию о возможных побочных эффектах.</para>

	    <para>Чтобы подключиться к этим и другим доступным спискам
	      рассылки, перейдите по ссылке &a.mailman.lists.link; и щёлкните
	      на списке, к которому вы хотите подключиться.  Инструкции по
	      дальнейшим действиям размещены там же.  Если вы заинтересованы
	      в отслеживании изменений всего дерева исходных текстов, то мы
	      рекомендуем вам подписаться на &a.svn-src-all.name;.</para>
	  </listitem>

	  <listitem>
	    <para>Если вы собираетесь установить новую систему, и хотите,
	      чтобы она соответствовала ежемесячным стандартным сборкам
	      ветви &os.stable;, обратитесь к
	      <link xlink:href="&url.base;/snapshots/">странице снэпшотов
	      </link>.  Либо вы
	      можете установить самый последний релиз &os.stable;, загрузив его
	      с <link linkend="mirrors">зеркалирующих сайтов</link>, а затем
	      следовать инструкциям ниже по обновлению исходных текстов вашей
	      системы до самой последней версии &os.stable;.</para>

	    <para>Если вы уже работаете с предыдущим релизом &os; и хотите
	      обновить его из исходных текстов, то вы можете легко это
	      сделать с <link linkend="mirrors">зеркального сайта</link> &os;.
	      Это можно сделать одним из двух способов:</para>

	    <orderedlist>
	      <listitem>
		<para>При помощи программы <link linkend="cvsup">cvsup</link><indexterm><primary><command>cvsup</command></primary></indexterm>
		  с <filename>sup</filename>-файлом
		  <filename>stable-supfile</filename> из каталога
		  <filename>/usr/share/examples/cvsup</filename>.
		  Это наиболее рекомендуемый
		  метод, так как он позволяет вам загрузить набор исходных
		  текстов один раз полностью, а затем загружать только
		  произошедшие изменения.  Многие запускают
		  <command>cvsup</command> при помощи программы
		  <command>cron</command><indexterm><primary><command>cron</command></primary></indexterm> и получают самые свежие исходные
		  тексты автоматически.  Измените примерный файл
		  <filename>supfile</filename> выше и отконфигурируйте <link linkend="cvsup">cvsup</link><indexterm><primary>-STABLE</primary><secondary>Синхронизация при помощи <application>CVSup</application></secondary></indexterm> для вашего окружения.</para>
	      </listitem>

	      <listitem>
		<para>При помощи <application>CTM</application><indexterm><primary>-STABLE</primary><secondary>синхронизация при помощи CTM</secondary></indexterm>.  Если у вас нет
		  быстрого и недорогого подключения к Интернет, то это как раз
		  тот метод, которым вы должны воспользоваться.</para>
	      </listitem>
	    </orderedlist>
	  </listitem>

	  <listitem>
	    <para>Итак, если вам нужен быстрый доступ к
	      исходным текстам и нагрузка на каналы связи для вас не
	      проблема, то используйте <command>cvsup</command>
	      или <command>ftp</command>.  В противном случае воспользуйтесь
	      <application>CTM</application>.</para>
	  </listitem>

	  <listitem>
	    <para>Перед тем, как компилировать &os.stable;<indexterm><primary>-STABLE</primary><secondary>компиляция</secondary></indexterm>, внимательно
	      прочтите файл <filename>Makefile</filename> в каталоге
	      <filename>/usr/src</filename>.  В процессе обновления вы
	      по крайней мере раз должны пройти через <link linkend="makeworld">установку нового ядра и перестроение всех
	      компонентов системы</link>.  Чтение списка рассылки &a.stable.name; и
	      <filename>/usr/src/UPDATING</filename>
	      позволит вам быть в курсе всех процедур,
	      которые иногда бывают необходимы при переходе к следующему
	      релизу.</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="synching">
    <title>Синхронизация ваших исходных текстов</title>

    <para>Имеются различные способы использования Интернет (или почтового)
      подключения для того, чтобы иметь самые последние версии исходных
      текстов любого проекта &os;, в зависимости от
      того, чем вы интересуетесь.  Основной сервис, который мы предлагаем,
      это <link linkend="anoncvs">Анонимный CVS</link>, <link linkend="cvsup">CVSup</link> и <link linkend="ctm">CTM</link>.</para>

    <warning>
      <para>Хотя имеется возможностью обновлять только часть дерева исходных
	текстов, процедурой, которую мы настоятельно советуем, является обновление всего
	дерева и перекомпиляция пользовательских программ (то есть тех,
	которые работают в пространстве имен пользователя, например те, что
	находятся в каталогах <filename>/bin</filename> и
	<filename>/sbin</filename>) и ядра.  Обновление только части дерева
	исходных текстов, только текстов ядра или только текстов
	пользовательских программ часто приводит к возникновению проблем.  Эти
	проблемы могут варьироваться от ошибок компиляции до аварийных
	остановов системы или порчи данных.</para>
    </warning>

    <indexterm>
      <primary>CVS</primary>

      <secondary>анонимный</secondary>
    </indexterm>

    <para><application>Анонимный CVS</application> и
      <application>CVSup</application> используют модель
      <emphasis>pull</emphasis> обновления исходных текстов.  В случае
      <application>CVSup</application> пользователь (или скрипт программы
      <application>cron</application>) вызывают <command>cvsup</command>, а она
      работает с каким-либо сервером <application>cvsupd</application>, чтобы
      выполнить обновление ваших
      файлов.  Обновления, которые вы получаете, актуальны с точностью до
      минуты, и вы получаете их тогда и только тогда, когда сами захотите.
      Вы можете с легкостью ограничить обновления конкретными файлами
      или каталогами, которые представляют для вас интерес.  Обновления
      создаются на лету сервером согласно тому, что у вас есть и что вы
      хотите иметь.  <application>Анонимный CVS</application> гораздо проще,
      чем <application>CVSup</application> в том смысле, что он представляет
      собой всего лишь расширение
      <application>CVS</application>, позволяющее загрузить изменения
      непосредственно с удаленного хранилища CVS.
      <application>CVSup</application> может делать это гораздо более
      эффективно, однако <application>анонимным CVS</application> легче
      пользоваться.</para>

    <indexterm>
      <primary><application>CTM</application></primary>
    </indexterm>
    <para><application>CTM</application>, с другой стороны, не сравнивает
      последовательно исходные тексты, имеющиеся у вас, с теми, что
      находятся в главном архиве и вообще ни коим образом не касается наших
      серверов.  Вместо этого несколько раз в день на главной машине CTM
      запускается скрипт, находящий изменения в файлах с момента
      своего предыдущего запуска; все замеченные изменения сжимаются,
      помечаются последовательным номером и кодируются для передачи по
      электронной почте (в форме печатаемых символов ASCII).
      После получения эти <quote>дельта-файлы CTM</quote> могут быть
      переданы утилите &man.ctm.rmail.1;, которая осуществит автоматическое
      декодирование, проверку и применение изменений к пользовательской
      копии исходных текстов.  Этот процесс гораздо более эффективен, чем
      <application>CVSup</application>, и требует меньше ресурсов нашего
      сервера, так как он сделан по модели <emphasis>push</emphasis>, а не
      <emphasis>pull</emphasis>.</para>

    <para>Несомненно, есть и минусы.  Если вы случайно уничтожили
      часть вашего архива, то <application>CVSup</application> обнаружит
      и загрузит поврежденную часть.  <application>CTM</application> этого
      делать не будет, и если вы уничтожили какую-то часть вашего дерева
      исходных текстов (и у вас нет архивной копии), то вам нужно будет
      начать с самого начала (с последнего <quote>базового
      дельта-файла</quote>), перестроив всё с помощью
      <application>CTM</application>, или, используя <application>анонимный
      CVS</application>, просто удалить повреждённую часть и
      пересинхронизироваться.</para>
  </sect1>

  <sect1 xml:id="makeworld">
    <title>Пересборка <quote>world</quote></title>

    <indexterm>
      <primary>Пересборка <quote>world</quote></primary>
    </indexterm>
    <para>После того, как вы синхронизировали ваше локальное дерево
      исходных текстов с некоторой версией &os;
      (&os.stable;, &os.current; и так далее),
      то можете использовать эти исходные тексты для перестроения
      системы.</para>

    <warning>
      <title>Создайте резервную копию</title>

      <para>Невозможно переоценить важность создания резервной
	копии вашей системы <emphasis>до того</emphasis>, как вы будете
	это делать.  Хотя перестроение системы (пока вы следуете этим
	инструкциям) является простой задачей, вы всегда можете допустить
	ошибку, или ошибка может оказаться в исходных текстах, что может
	привести к тому, что система перестанет загружаться.</para>

      <para>Обязательно сделайте резервную копию.  И держите под рукой
	аварийную (fixit) дискету или загрузочный компакт диск.  Может быть,
	вам никогда не приходилось ими
	пользоваться, но, постучав по дереву, всегда лучше подготовиться, чем
	потом сожалеть.</para>
    </warning>

    <warning>
      <title>Подпишитесь на соответствующий список рассылки</title>

      <indexterm><primary>список рассылки</primary></indexterm>
      <para>Ветки &os.stable; и &os.current; кода по природе своей являются
	<emphasis>изменяющимися</emphasis>.  В разработке &os; участвуют
	люди, и время от времени случаются ошибки.</para>

      <para>Иногда эти ошибки достаточно безобидны и приводят к выводу
	нового диагностического сообщения.  Бывает, что изменение оказывается
	катастрофическим, и система не может загрузиться или разрушаются
	файловые системы (или что-нибудь ещё хуже).</para>

      <para>Если возникают подобные проблемы, в соответствующем списке
	рассылки публикуется сообщение <quote>heads up</quote>, в котором
	описывается природа проблемы и затрагиваемые системы.  Когда проблема
	решается, публикуется сообщение <quote>all clear</quote>.</para>

      <para>Если вы пытаетесь отслеживать &os.stable; или &os.current; и не
	читаете &a.stable; или &a.current; соответственно, то
	вы напрашиваетесь на неприятности.</para>
    </warning>

    <warning>
      <title>Не используйте <command>make world</command></title>

      <para>Множество старой документации рекомендует использование
	<command>make world</command>.  При этом пропускаются многие
	важные шаги, и использование этой команды возможно лишь в том
	случае, если вы точно знаете, что делаете.  Почти во всех
	обстоятельствах	<command>make world</command> это неправильный
	способ, вместо него необходимо использовать описанную здесь
	процедуру.</para>
    </warning>

    <sect2>
      <title>Канонический способ обновления вашей системы</title>

      <para>Для обновления вашей системы вы должны прочесть
	<filename>/usr/src/UPDATING</filename> для выяснения шагов, которые
	нужно предпринять перед построением системы из вашей версии исходных
	текстов, а затем выполнить следующую последовательность
	действий:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput>
&prompt.root; <userinput>make installkernel</userinput>
&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <note>
	<para>Есть несколько редких случаев, когда перед выполнением
	  <buildtarget>buildworld</buildtarget> необходимо дополнительно
	  запустить <command>mergemaster -p</command>.  Они описаны в файле
	  <filename>UPDATING</filename>.  В общем случае вы можете без ущерба
	  пропустить этот шаг, если не выполняете обновление с одной большой
	  версии &os; на другую.</para>
      </note>

      <para>После успешного выполнения <buildtarget>installkernel</buildtarget>
	вам необходимо загрузить систему в однопользовательском режиме (то
	есть посредством команды <command>boot -s</command>, заданной в
	приглашении загрузчика).  После этого выполните:</para>

      <screen>&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>mergemaster -p</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput>
&prompt.root; <userinput>mergemaster</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <warning>
	<title>Прочтите более полное описание</title>

	<para>Описанная выше последовательность является только краткой
	  выжимкой для того, чтобы помочь вам начать.  Вы должны всё же
	  прочесть последующие разделы для полного понимания каждого шага,
	  особенно если собираетесь использовать собственную конфигурацию
	  ядра.</para>
      </warning>
    </sect2>

    <sect2>
      <title>Прочтите <filename>/usr/src/UPDATING</filename></title>

      <para>Перед тем, как делать что-либо, прочтите
	<filename>/usr/src/UPDATING</filename> (или соответствующий файл
	в вашей копии исходных текстов).  В этом файле
	содержится важная информация о проблемах, с которыми вы можете
	столкнуться, или указан порядок, в котором вы должны запускать
	определенные команды.  Если в файле <filename>UPDATING</filename>
	написано нечто, противоречащее тому, что вы здесь читаете, то
	нужно следовать указаниям в <filename>UPDATING</filename>.</para>

      <important>
	<para>Чтение <filename>UPDATING</filename> не заменит подписки на
	  соответствующий список рассылки, как это и описано выше.  Эти два
	  условия являются дополняющими, а не взаимоисключающими друг
	  друга.</para>
      </important>
    </sect2>

    <sect2>
      <title>Проверьте содержимое <filename>/etc/make.conf</filename></title>
      <indexterm>
	<primary><filename>make.conf</filename></primary>
      </indexterm>

      <para>Просмотрите файлы <filename>/usr/share/examples/etc/make.conf</filename>
	и <filename>/etc/make.conf</filename>.  Первый содержит некоторые
	предопределенные по умолчанию значения &ndash; большинство из них
	закомментировано.  Чтобы воспользоваться ими при перестроении системы
	из исходных текстов, добавьте их в файл
	<filename>/etc/make.conf</filename>.  Имейте в виду, что все,
	добавляемое вами в <filename>/etc/make.conf</filename>, используется
	также каждый раз при запуске команды <command>make</command>, так что
	полезно задать здесь значения, подходящие вашей системе.</para>

      <para>Вероятно стоит скопировать строки
	<varname>CFLAGS</varname> и <varname>NO_PROFILE</varname>,
	расположенные в
	<filename>/usr/share/examples/etc/make.conf</filename>, в файл
	<filename>/etc/make.conf</filename> и раскомментировать их.</para>

      <para>Посмотрите на другие определения (<varname>COPTFLAGS</varname>,
	<varname>NOPORTDOCS</varname> и так далее) и решите, нужны ли они
	вам.</para>
    </sect2>

    <sect2>
      <title>Обновите файлы в каталоге <filename>/etc</filename></title>

      <para>Каталог <filename>/etc</filename> содержит значительную часть
	информации о конфигурации вашей системы, а также скрипты, работающие
	в начале работы системы.  Некоторые из этих скриптов меняются от
	версии к версии &os;.</para>

      <para>Некоторые конфигурационные файлы также используются в ежедневной
	работе системы.  В частности, файл
	<filename>/etc/group</filename>.</para>

      <para>Случалось, что установочная часть <command>make installworld</command>
	ожидала существования определённых имен пользователей или групп.  При
	обновлении существует вероятность, что эти пользователи или группы не
	существуют.  Это вызывает проблемы при обновлении.  В некоторых
	случаях <command>make buildworld</command> проверяет наличие этих
	пользователей или групп.</para>

      <para>Примером этого является добавление пользователя
	<systemitem class="username">smmsp</systemitem>.  Пользователи столкнулись с прерыванием
	процесса установки, когда &man.mtree.8; пыталась
	создать <filename>/var/spool/clientmqueue</filename>.</para>

      <para>Выходом является запуск утилиты &man.mergemaster.8; в
	режиме, предваряющем построение системы, задаваемым опцией
	<option>-p</option>.  Она будет сравнивать только те файлы, которые
	необходимы для успешного выполнения целей
	<buildtarget>buildworld</buildtarget> или
	<buildtarget>installworld</buildtarget>.  Если ваша старая версия
	утилиты <command>mergemaster</command> не поддерживает опцию
	<option>-p</option>, воспользуйтесь новой версией из дерева исходных
	текстов при первом запуске:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/usr.sbin/mergemaster</userinput>
&prompt.root; <userinput>./mergemaster.sh -p</userinput></screen>

      <tip>
	<para>Если вы параноик, можете поискать файлы, владельцем которых
	  является та группа, которую вы переименовываете или удаляете:</para>

	<screen>&prompt.root; <userinput>find / -group GID -print</userinput></screen>

	<para>выдаст список всех файлов, владельцем которых является группа
	  <replaceable>GID</replaceable> (задаваемая именем или
	  численным значением ID).</para>
      </tip>
    </sect2>

    <sect2 xml:id="makeworld-singleuser">
      <title>Перейдите в однопользовательский режим</title>
      <indexterm><primary>однопользовательский режим</primary></indexterm>

      <para>Вам может понадобиться откомпилировать систему в
	однопользовательском режиме.  Кроме обычного выигрыша в
	скорости процесса, переустановка системы затрагивает много важных
	системных файлов, все стандартные выполнимые файлы системы,
	библиотеки, include-файлы и так далее.  Изменение их на работающей
	системе (в частности, в которой активно работают пользователи) может
	привести к неприятностям.</para>

      <indexterm><primary>многопользовательский режим</primary></indexterm>
      <para>Другим способом является компиляция системы в многопользовательском
	режиме с последующим переходом в однопользовательский режим для
	выполнения установки.  Если вы хотите поступить именно так, просто
	следуйте инструкциям до момента окончания построения.  Вы можете
	отложить переход в однопользовательский режим до завершения целей
	<buildtarget>installkernel</buildtarget> или
	<buildtarget>installworld</buildtarget>.</para>

      <para>Как администратор, вы можете выполнить:</para>

      <screen>&prompt.root; <userinput>shutdown now</userinput></screen>

      <para>на работающей системе, что переведет ее в однопользовательский
	режим.</para>

      <para>Либо вы можете выполнить перезагрузку и в приглашении загрузчика
	выбрать пункт <quote>single user</quote>.  После этого система загрузится в
	однопользовательском режиме.  В приглашении командного процессора вы
	должны запустить:</para>

      <screen>&prompt.root; <userinput>fsck -p</userinput>
&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

      <para>Эти команды выполняют проверку файловых систем, повторно монтируют
	<filename>/</filename> в режиме чтения/записи, монтируют все
	остальные файловые системы UFS, перечисленные в файле
	<filename>/etc/fstab</filename> и включат подкачку.</para>

      <note>
	<para>Если часы в вашей CMOS настроены на местное время, а не на GMT
	  (это имеет место, если команда &man.date.1; выдаёт
	  неправильные время и зону), то вам может понадобиться запустить
	  следующую команду:</para>

	<screen>&prompt.root; <userinput>adjkerntz -i</userinput></screen>

	<para>Это обеспечит корректную настройку местного часового пояса
	  &mdash; без этого впоследствии вы можете столкнуться с некоторыми
	  проблемами.</para>
      </note>
    </sect2>

    <sect2>
      <title>Удалите <filename>/usr/obj</filename></title>

      <para>При перестроении частей системы они помещаются в каталоги,
	которые (по умолчанию) находятся в <filename>/usr/obj</filename>.
	Структура повторяет структуру <filename>/usr/src</filename>.</para>

      <para>Вы можете ускорить выполнение процесса <command>make buildworld</command>
	и, возможно, избавить себя от некоторой головной боли, связанной с
	зависимостями, удалив этот каталог.</para>

      <para>На некоторых файлах из <filename>/usr/obj</filename> могут быть
	установлены специальные флаги (обратитесь к &man.chflags.1; за
	дополнительной информацией), которые сначала должны быть
	сняты.</para>

      <screen>
&prompt.root; <userinput>cd /usr/obj</userinput>
&prompt.root; <userinput>chflags -R noschg *</userinput>
&prompt.root; <userinput>rm -rf *</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="updating-upgrading-compilebase">
      <title>Перекомпилируйте исходные тексты базовой системы</title>

      <sect3>
	<title>Сохраните вывод</title>

	<para>Неплохо сохранить вывод, получаемый при работе программы
	  &man.make.1;, в файл.  Если что-то вдруг пойдет не так, вы будете
	  иметь копию сообщения об ошибке и полную картину того, где она
	  произошла.  Хотя это может и не помочь в определении причин
	  происходящего, это может помочь другим, если вы опишите вашу
	  проблему в одном из списков рассылки &os;.</para>

	<para>Проще всего это сделать при помощи команды &man.script.1; с
	  параметром, в котором указано имя файла, в который нужно сохранить
	  вывод.  Вы должны сделать это непосредственно перед тем, как
	  перестроить систему, а по окончании процесса набрать
	  <userinput>exit</userinput>.</para>

	<screen>
&prompt.root; <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out
&prompt.root; <userinput>make world</userinput>
<emphasis>&hellip; compile, compile, compile &hellip;</emphasis>
&prompt.root; <userinput>exit</userinput>
Script done, &hellip;
	</screen>

	<para>Если вы делаете это, <emphasis>не</emphasis> сохраняйте
	  вывод в <filename>/tmp</filename>.  Этот каталог может быть
	  очищен при следующей перезагрузке.  Лучше сохранить его в
	  <filename>/var/tmp</filename> (как в предыдущем примере) или в
	  домашнем каталоге пользователя <systemitem class="username">root</systemitem>.</para>
      </sect3>

      <sect3 xml:id="make-buildworld">
	<title>Компиляция базовых компонентов системы</title>

	<para>Вы должны находиться в каталоге
	  <filename>/usr/src</filename>:</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>

	<para>(если, конечно, ваш исходный код не находится в другом месте, в
	  случае чего вам нужно перейти в соответствующий каталог).</para>

	<indexterm><primary><command>make</command></primary></indexterm>

	<para>Для полного перестроения системы используется
	  команда &man.make.1;.  Эта команда читает инструкции из файла
	  <filename>Makefile</filename>, описывающего, как должны быть
	  перестроены программы, которые составляют систему &os;, в каком
	  порядке они должны быть построены и так далее.</para>

	<para>Общий формат командной строки, которую вы будет набирать,
	  таков:</para>

	<screen>&prompt.root; <userinput>make -x -DVARIABLE target</userinput></screen>

	<para>В этом примере <option>-<replaceable>x</replaceable></option>
	  является параметром, который вы передаете в &man.make.1;.
	  Обратитесь к справочной странице программы &man.make.1;, которая
	  содержит список возможных параметров.</para>

	<para><option>-D<replaceable>VARIABLE</replaceable></option>
	  передает переменную в <filename>Makefile</filename>.  Поведение
	  <filename>Makefile</filename> определяется этими переменными.  Это
	  те же самые переменные, которые задаются в
	  <filename>/etc/make.conf</filename>, и это &mdash; еще один способ
	  их задания.</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE=true target</userinput></screen>

	<para>является другим способом указания того, что библиотеки для
	  профилирования строить не нужно, и соответствует строке</para>

	<programlisting>NO_PROFILE=    true	# Обход построения библиотек для профилирования</programlisting>

	<para>в файле <filename>/etc/make.conf</filename>.</para>

	<para><replaceable>target</replaceable> указывает программе
	  &man.make.1; на то, что вы хотите сделать.  Каждый файл
	  <filename>Makefile</filename> определяет некоторое количество
	  различных <quote>целей</quote>, и ваш выбор цели определяет то, что
	  будет делаться.</para>

	<para>Некоторые цели, перечисленные в файле
	  <filename>Makefile</filename>, не предназначены для вызова.  Просто
	  они используются в процессе построения для разбиения его на этапы.</para>

	<para>В большинстве случаев вам не нужно передавать никаких
	  параметров в &man.make.1;, так что ваша команда будет выглядеть
	  примерно так:</para>

	<screen>
&prompt.root; <userinput>make target</userinput>
	</screen>

	<para>Замените <replaceable>target</replaceable> на одну или более из
	  опций сборки.  Первой из них всегда должна быть опция
	  <varname>buildworld</varname>.</para>

	<para>Как указывают на это названия,
	  <buildtarget>buildworld</buildtarget> строит полностью новое дерево
	  в каталоге <filename>/usr/obj</filename>, а
	  <buildtarget>installworld</buildtarget> устанавливает это дерево на
	  используемой машине.</para>

	<para>Разделение этих опций весьма полезно по двум причинам.  Во-первых, это позволяет
	  вам безопасно строить систему, зная, что компоненты вашей рабочей
	  системы затронуты не будут.  Построение
	  <quote>самодостаточно</quote>.  По этой причине вы можете спокойно
	  запустить <buildtarget>buildworld</buildtarget> на машине, работающей в
	  многопользовательском режиме без опаски получить какие-либо проблемы.
	  Но всё же рекомендуется запускать цель
	  <buildtarget>installworld</buildtarget> в однопользовательском
	  режиме.</para>

	<para>Во-вторых, это позволяет вам использовать монтирование по NFS для
	  обновления многих машин в сети.  Если у вас есть три машины,
	  <systemitem>A</systemitem>, <systemitem>B</systemitem> и <systemitem>C</systemitem>, которые
	  вы хотите обновить, запустите <command>make buildworld</command> и
	  <command>make installworld</command> на машине <systemitem>A</systemitem>.
	  Хосты <systemitem>B</systemitem> и <systemitem>C</systemitem> должны будут
	  затем смонтировать по NFS каталоги <filename>/usr/src</filename>
	  и <filename>/usr/obj</filename> с машины <systemitem>A</systemitem>, и вы
	  сможете запустить <command>make installworld</command> для установки
	  результатов построения на машинах <systemitem>B</systemitem> и
	  <systemitem>C</systemitem>.</para>

	<para>Хотя цель <buildtarget>world</buildtarget> всё ещё имеется в
	  наличии, вам настоятельно рекомендуется не пользоваться ею.</para>

	<para>Выполните</para>

	<screen>&prompt.root; <userinput>make buildworld</userinput></screen>

	<para>Имеется возможность задавать команде
	  <command>make</command> параметр <option>-j</option>, который
	  приводит к запуску нескольких одновременно работающих процессов.
	  Наиболее полезно использовать это на многопроцессорных машинах.
	  Однако, так как процесс компиляции больше всего требователен к
	  подсистеме ввода/вывода, а не к производительности процессора, это
	  можно использовать и на машинах с одним процессором.</para>

	<para>На типичной машине с одним CPU вы должны запускать:</para>

	<screen>
&prompt.root; <userinput>make -j4 buildworld</userinput>
	</screen>

	<para>&man.make.1; будет иметь до 4 одновременно работающих
	  процессов.  Эмпирические замеры, опубликованные как-то в списке рассылки,
	  показывают, что в среднем это дает наибольшее увеличение
	  производительности.</para>

	<para>Если у вас многопроцессорная машина и вы используете ядро с
	  настройками для SMP, попробуйте использовать значения между 6 и
	  10 и посмотрите, как это отразится на скорости работы.</para>
      </sect3>

      <sect3>
	<title>Время на построение</title>

	<indexterm>
	  <primary>перестроение <quote>world</quote></primary>

	  <secondary>затраченное время</secondary>
	</indexterm>

	<para>На время компиляции влияет множество факторов, но на данный
	  момент современные машины
	  справляются с построением дерева &os.stable; примерно за 1-2&nbsp;часа
	  без дополнительных хитростей и убыстряющих процесс уловок.  Дерево
	  &os.current; строится несколько дольше.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Откомпилируйте и установите новое ядро</title>
      <indexterm>
	<primary>ядро</primary>
	<secondary>компиляция</secondary>
      </indexterm>

      <para>Чтобы получить полную отдачу от вашей новой системы, вы должны
	перекомпилировать ядро.  Это практически необходимость, так как
	отдельные структуры в памяти могут меняться, и программы типа
	&man.ps.1; и &man.top.1; не будут работать, пока версии ядра и
	исходных текстов системы не будут совпадать.</para>

      <para>Самым простым и надежным способом сделать это является компиляция и
	установка ядра на основе <filename>GENERIC</filename>.  Хотя в
	<filename>GENERIC</filename> могут оказаться не все необходимые для
	работы вашей системы устройства, в нем имеется все необходимое
	для перезагрузки вашей системы обратно в однопользовательский режим.
	Это является хорошей проверкой на правильность работы новой системы.
	После загрузки с ядром <filename>GENERIC</filename> и проверки
	работоспособности системы вы можете построить новое ядро на основе
	вашего обычного конфигурационного файла ядра.</para>

      <para>В &os; важно выполнить <link linkend="make-buildworld">buildworld</link> перед сборкой
	нового ядра.</para>

      <note>
	<para>Если вы хотите построить собственное ядро и уже подготовили файл
	  конфигурации, просто используйте
	  <literal>KERNCONF=MYKERNEL</literal>
	  следующим образом:</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildkernel KERNCONF=MYKERNEL</userinput>
&prompt.root; <userinput>make installkernel KERNCONF=MYKERNEL</userinput></screen>
      </note>

      <para>Заметьте, что, если вы установили
	<literal>kern.securelevel</literal> в значение, превышающее 1,
	<emphasis>и</emphasis> установили флаг <literal>noschg</literal> или
	подобный на бинарный файл ядра, то вы будете вынуждены перейти в
	однопользовательский режим для того, чтобы воспользоваться
	<buildtarget>installkernel</buildtarget>.  В противном случае вы
	должны выполнять эти команды без проблем.  Обратитесь к справочным
	страницам об &man.init.8; для получения подробной информации о
	<literal>kern.securelevel</literal> и &man.chflags.1; для получения
	информации о различных флагах файлов.</para>
    </sect2>

    <sect2>
      <title>Перезагрузитесь в однопользовательский режим</title>
      <indexterm><primary>однопользовательский режим</primary></indexterm>

      <para>Для проверки работоспособности ядра вы должны перезагрузить систему
	и перейти в однопользовательский режим.  Сделайте это, следуя указаниям
	в <xref linkend="makeworld-singleuser"/>.</para>
    </sect2>

    <sect2 xml:id="make-installworld">
      <title>Установите новые версии системных программ</title>

      <para>Если вы компилировали достаточно свежую версию &os;, в которой
	имеется команда <command>make buildworld</command>, то для установки
	новых версий программ вы должны теперь выполнить команду
	<buildtarget>installworld</buildtarget>.</para>

      <para>Запустите</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput></screen>

      <note>
	<para>Если при выполнении команды <command>make buildworld</command> вы
	  задавали значения каких-либо переменных, то при выполнении
	  <command>make installworld</command> вы должны задать те же самые
	  переменные.  Это не всегда так для остальных параметров; например,
	  при выполнении <buildtarget>installworld</buildtarget> никогда не
	  должен использоваться параметр <option>-j</option>.</para>

	<para>Например, если вы выполняли команду:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE buildworld</userinput></screen>

	<para>то результат её выполнения должен устанавливаться командой</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE installworld</userinput></screen>

	<para>В противном случае будет делаться попытка установить библиотеки
	  для профилирования, которые не компилировались на этапе выполнения
	  команды <command>make buildworld</command>.</para>
      </note>
    </sect2>

    <sect2>
      <title>Обновите файлы, не обновленные по команде
	<command>make installworld</command></title>

      <para>При перестроении системы не будут обновляться некоторые каталоги
	(в частности, <filename>/etc</filename>, <filename>/var</filename> и
	<filename>/usr</filename>) с конфигурационными
	файлами.</para>

      <para>Самым простым способом обновить такие файлы является запуск
	утилиты &man.mergemaster.8;, хотя можно сделать это и вручную, если вам
	так больше нравится.  Вне зависимости от выбранного вами способа
	обязательно сделайте резервную копию каталога <filename>/etc</filename>
	на случай, если произойдёт что-то непредвиденное.</para>

      <sect3 xml:id="mergemaster">
	<info><title><command>mergemaster</command></title>
	  <authorgroup>
	    <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Текст предоставил </contrib></author>
	  </authorgroup>
	</info>

	

	<indexterm>
	  <primary><command>mergemaster</command></primary>
	</indexterm>

	<para>Утилита &man.mergemaster.8; является скриптом для оболочки Боурна,
	  которая поможет вам в определении разницы между вашими
	  конфигурационными файлами в каталоге <filename>/etc</filename> и
	  конфигурационными файлами из дерева исходных текстов
	  <filename>/usr/src/etc</filename>.  Это является рекомендуемым
	  способом синхронизации системных конфигурационных файлов с теми, что
	  размещены в дереве исходных текстов.</para>

	<para>Для начала просто наберите <command>mergemaster</command> в
	  приглашении командной строки и посмотрите, что происходит.
	  <command>mergemaster</command> построит временное окружение для
	  пользователя root, начиная от <filename>/</filename>, а затем
	  заполнит его различными системными конфигурационными файлами.  Эти
	  файлы затем будут сравниваться с теми, что установлены в вашей
	  системе.  В этот момент файлы, которые имеют отличия, будут выданы в
	  формате &man.diff.1;, где знак <option>+</option> будет означать
	  добавленные или изменённые строки, а знак <option>-</option> будет
	  означать строки, которые были либо полностью удалены, либо заменены
	  на новые.  Обратитесь к страницам справочной системы по команде
	  &man.diff.1; для получения более полной информации о синтаксисе
	  команды &man.diff.1; и формате выдачи отличий в файлах.</para>

	<para>Затем &man.mergemaster.8; выдаст вам каждый файл, в котором есть
	  изменения, и в этот момент у вас есть возможность либо удалить новый
	  файл (который будем считать временным), установить временный файл в
	  его неизменённом виде, объединить временный файл с установленным на
	  данный момент, либо просмотреть выдачу &man.diff.1; ещё раз.</para>

	<para>Выбор удаления временного файла укажет &man.mergemaster.8; на то,
	  что мы хотим оставить наш текущий файл без изменений и удалить его
	  новую версию.  Делать это не рекомендуется, если только
	  у вас нет причин вносить изменения в текущий файл.  Вы можете
	  получить помощь в любое время, набрав <keycap>?</keycap> в
	  приглашении &man.mergemaster.8;.  Если пользователь выбирает пропуск
	  файла, запрос появится снова после того, как будут обработаны все
	  остальные файлы.</para>

	<para>Выбор установки немодифицированного временного файла приведёт к
	  замене текущего файла новым.  Для большинства немодифицированных
	  файлов это является подходящим вариантом.</para>

	<para>Выбор варианта с объединением файла приведёт к вызову текстового
	  редактора, содержащего текст обоих файлов.  Теперь вы можете
	  объединить их, просматривая оба файла на экране, и выбирая те части
	  из обоих, что подходят для окончательного варианта.  Когда файлы
	  сравниваются на экране, то нажатие <keycap>l</keycap> выбирает
	  содержимое слева, а нажатие <keycap>r</keycap> выбирает содержимое
	  справа.  В окончательном варианте будет файл, состоящий из обеих
	  частей, который и будет установлен.  Этот вариант используется для
	  файлов, настройки в которых изменялись пользователем.</para>

	<para>Выбор повторного просмотра &man.diff.1;-разниц выдаст вам разницы
	  между файлами, как это делала утилита &man.mergemaster.8; до того,
	  как запросила вас о выборе.</para>

	<para>После того, как утилита &man.mergemaster.8; закончит работу с
	  системными файлами, она выдаст запрос относительно других параметров.
	  &man.mergemaster.8; может запросить вас относительно перестроения
	  файла паролей и завершит запросом на удаление оставшихся
	  временных файлов.</para>
      </sect3>

      <sect3>
	<title>Обновление в ручном режиме</title>

	<para>Однако если вы хотите произвести обновление вручную, то вы не
	  можете просто скопировать файлы из <filename>/usr/src/etc</filename> в
	  <filename>/etc</filename> и получить работающую систему.  Некоторые
	  из этих файлов сначала нужно <quote>установить</quote>.  Это нужно
	  потому, что каталог <filename>/usr/src/etc</filename>
	  <emphasis>не</emphasis> является копией того, что должен содержать
	  ваш каталог <filename>/etc</filename>.  Кроме того, есть файлы,
	  которые должны присутствовать в <filename>/etc</filename>, но которых
	  нет в <filename>/usr/src/etc</filename>.</para>

	<para>Если вы используете &man.mergemaster.8; (как это рекомендуется),
	  то вы можете перейти сразу к <link linkend="updating-upgrading-rebooting">следующему
	  разделу</link>.</para>

      <para>Вручную проще всего сделать это, установив файлы в новый каталог,
	а затем пройтись по ним, отмечая разницу.</para>

      <warning>
	<title>Сделайте резервную копию вашего каталога
	  <filename>/etc</filename></title>

	<para>Хотя, в теории, никаких автоматических действий с этим
	  каталогом не производится,
	  всегда лучше чувствовать себя уверенным.  Так что скопируйте
	  имеющийся каталог <filename>/etc</filename> в какое-нибудь
	  безопасное место.  Запустите что-то вроде:</para>

	<screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

	<para><option>-R</option> задает выполнение рекурсивного копирования,
	  а <option>-p</option> сохраняет даты, владельца файлов и тому
	  подобное.</para>
      </warning>

      <para>Вам нужно создать шаблонную структуру каталогов для установки
	нового содержимого <filename>/etc</filename> и других файлов.
	Подходящим местом является <filename>/var/tmp/root</filename>, и в нём
	потребуется разместить некоторое количество подкаталогов.</para>

      <screen>&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>

      <para>Эти команды приведут к созданию нужной структуры каталогов и
	установке файлов.  Множество каталогов, созданных в
	<filename>/var/tmp/root</filename>, будут пустыми и должны быть удалены.
	Проще всего сделать это так:</para>

      <screen>&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d . -type d | xargs rmdir 2&gt;/dev/null</userinput></screen>

      <para>Эти команды удалят все пустые каталоги.  (Стандартный поток
	диагностических сообщений перенаправляется в
	<filename>/dev/null</filename> для исключения предупреждений о
	непустых каталогах.)</para>

      <para>Теперь <filename>/var/tmp/root</filename> содержит все файлы,
	которые должны быть помещены в соответствующие места в
	<filename>/</filename>.  Теперь пройдитесь по каждому их этих файлов
	и определите, чем они отличаются от имеющихся у вас файлов.</para>

      <para>Заметьте, что некоторые из файлов, которые были установлены в
	каталог <filename>/var/tmp/root</filename>, имеют первым символом
	<quote>.</quote>.  На момент написания единственными такими файлами
	являлись файлы начальных скриптов командных процессоров в
	<filename>/var/tmp/root/</filename> и
	<filename>/var/tmp/root/root/</filename>, хотя могут быть и другие
	(зависит от того, когда вы это читаете).  Обязательно пользуйтесь
	командой <command>ls -a</command>, чтобы выявить их.</para>

      <para>Проще всего сделать это путём сравнения двух файлов при помощи
	команды &man.diff.1;:</para>

      <screen>&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>

      <para>Эта команда покажет разницу между вашим файлом
	<filename>/etc/shells</filename> и новым файлом
	<filename>/var/tmp/root/etc/shells</filename>.  Используйте это для
	определения того, переносить ли сделанные вами изменения или
	скопировать поверх вашего старого файла.</para>

      <tip>
	<title>Называйте новый корневой каталог
	  (<filename>/var/tmp/root</filename>) по дате, чтобы вы смогли легко
	  выявить разницу между версиями</title>

	<para>Частое перестроение системы означает также и частое обновление
	  <filename>/etc</filename>, которое может быть несколько
	  обременительным.</para>

	<para>Вы можете ускорить этот процесс, сохраняя копию последнего
	  набора измененных файлов, которые вы перенесли в
	  <filename>/etc</filename>.  Следующая процедура подаст вам одну
	  идею о том, как это сделать.</para>

	<procedure>
	  <step>
	    <para>Выполните перестроение системы обычным образом.  Когда вы
	      вам потребуется обновить <filename>/etc</filename> и другие
	      каталоги, дайте целевому каталогу имя на основе текущей даты.
	      Если вы делаете это 14 февраля 1998 года, то вы можете сделать
	      следующее:</para>

	    <screen>&prompt.root; <userinput>mkdir /var/tmp/root-19980214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-19980214 \
    distrib-dirs distribution</userinput></screen>
	  </step>

	  <step>
	    <para>Перенесите изменение из этого каталога, как это описано
	      выше.</para>

	    <para><emphasis>Не</emphasis> удаляйте каталог
	      <filename>/var/tmp/root-19980214</filename> после окончания
	      этого процесса.</para>
	  </step>

	  <step>
	    <para>Когда вы загрузите самую последнюю версию исходного кода и
	      перестроите систему, выполните шаг 1.  Это даст вам новый
	      каталог, который может называться
	      <filename>/var/tmp/root-19980221</filename> (если вы ждете
	      неделю между обновлениями).</para>
	  </step>

	  <step>
	    <para>Теперь вы можете видеть изменения, которые были сделаны
	      за прошедшую неделю, выполнив при помощи команды &man.diff.1;
	      рекурсивное сравнение двух каталогов:</para>

	    <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-19980214 root-19980221</userinput></screen>

	    <para>Как правило, здесь содержится гораздо меньше отличий, чем
	      между каталогами
	      <filename>/var/tmp/root-19980221/etc</filename> и
	      <filename>/etc</filename>.  Так как отличий меньше, то и легче
	      перенести эти изменения в ваш каталог
	      <filename>/etc</filename>.</para>
	  </step>

	  <step>
	    <para>Теперь вы можете удалить более старый из двух каталогов
	      <filename>/var/tmp/root-*</filename>:</para>

	    <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-19980214</userinput></screen>
	  </step>

	  <step>
	    <para>Повторяйте этот процесс всякий раз, когда вам нужно
	      перенести изменения в каталог <filename>/etc</filename>.</para>
	  </step>
	</procedure>

	<para>Для автоматической генерации имён каталогов можно
	  использовать команду &man.date.1;:</para>

	  <screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
	</tip>
      </sect3>
    </sect2>

    <sect2 xml:id="updating-upgrading-rebooting">
      <title>Перезагрузка</title>

      <para>Теперь вы сделали всё.  После того, как вы проверили, что всё
	на месте, можете перегрузить систему.  Простая команда
	&man.shutdown.8; должна это сделать:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>
    </sect2>

    <sect2>
      <title>Завершение</title>

      <para>Теперь у вас имеется успешно обновлённая система &os;.
	Поздравляем!</para>

      <para>Если что-то работает неправильно, можно с лёгкостью перестроить
	конкретную часть системы.  Например, если вы случайно удалили файл
	<filename>/etc/magic</filename> в процессе обновления или переноса
	<filename>/etc</filename>, то команда &man.file.1; перестанет работать.
	В таком случае это можно исправить вот так:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2>
      <title>Вопросы?</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>Нужно ли полностью перестраивать систему при каждом
	      изменении?</para>
	  </question>

	  <answer>
	    <para>Простого ответа на этот вопрос нет, так как это зависит от
	      характера изменения.  Например, если вы только что выполнили
	      <application>CVSup</application>, и оказалось, что с момента
	      последнего его запуска были изменены следующие файлы:</para>

	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

	    <para>то перестраивать всю систему незачем.  Вы можете просто
	      перейти в соответствующий подкаталог и выдать команду
	      <command>make all install</command>, этого будет достаточно.
	      Однако, если меняется что-то важное, например,
	      <filename>src/lib/libc/stdlib</filename>, то вы должны
	      перестроить всю систему или по крайней мере те ее части, которые
	      скомпонованы статически.</para>

	    <para>В конце концов, выбор за вами.  Может быть вам нравится
	      перестраивать систему, скажем, каждый вечер, а изменения
	      скачивать ночью.  Или вы можете захотеть перестраивать только
	      те вещи, которые менялись, но быть уверенным, что отслежены все
	      изменения.</para>

	    <para>И, конечно же, всё это зависит от того, как часто вы хотите
	      делать обновление, и отслеживаете ли вы &os.stable; или
	      &os.current;.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Компиляция прерывается с большим количеством ошибок по
	      сигналу 11<indexterm><primary>сигнал 11</primary></indexterm>
	      (или с другим номером сигнала).  Что
	      случилось?</para>
	  </question>

	  <answer>
	    <para>Как правило, это говорит о проблемах с оборудованием.
	      (Пере)построение системы является эффективным стресс-тестом для
	      вашего оборудования и частенько выявляет проблемы с памятью.
	      Обычно это проявляется в виде неожиданных сбоев компилятора
	      или получения странных программных сигналов.</para>

	    <para>Явным указателем на это является то, что при перезапуске
	      процедуры построения она прекращается в различные моменты
	      времени.</para>

	    <para>В этом случае вы мало что можете сделать, разве что
	      попробовать заменить комплектующие вашей машины для определения
	      сбоящей компоненты.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Могу ли я удалить каталог <filename>/usr/obj</filename>
	      после окончания?</para>
	  </question>

	  <answer>
	    <para>Если отвечать коротко, то да.</para>

	    <para>Каталог <filename>/usr/obj</filename> содержит все
	      объектные файлы, которые создаются во время фазы компиляции.
	      Обычно одним из первых шагов в процессе <command>make buildworld</command>
	      является удаление этого каталога.  В этом случае сохранение
	      <filename>/usr/obj</filename> после окончания имеет мало смысла;
	      вдобавок, он будет занимать большой объём дискового
	      пространства (на данный момент около 340&nbsp;МБ).</para>

	    <para>Однако если вы точно знаете, что делаете, то можете заставить
	      процедуру <command>make buildworld</command> пропустить этот шаг.  Это
	      позволит последующие построения выполняться гораздо быстрее, так
	      как большинство исходных текстов не нужно будет
	      перекомпилировать.  Оборотной стороной медали этого подхода
	      является вероятность появления некоторых проблем с зависимостями,
	      что может привести к прерыванию построения по странным причинам.
	      Это частенько вызывает шум в списках рассылки &os;, когда
	      кто-либо жалуется на прерывание процесса построения, не обращая
	      внимания на то, что он пытается срезать углы на
	      повороте.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Могут ли быть продолжены прерванные процессы
	      построения?</para>
	  </question>

	  <answer>
	    <para>Это зависит от того, насколько далеко зашел процесс
	      построения перед тем, как вы обнаружили проблему.</para>

	    <para><emphasis>В общем случае</emphasis> (и это несложное и
	      быстрое правило) процесс <command>make buildworld</command> строит
	      новые копии необходимых инструментальных средств (таких, как
	      &man.gcc.1; и &man.make.1;) и системные библиотеки.  Затем эти
	      средства и библиотеки устанавливаются.  Новые инструментальные
	      средства и библиотеки затем используются для перестроения
	      самих себя, и повторно устанавливаются.  Система в целом
	      (теперь включая обычные пользовательские программы, такие,
	      как &man.ls.1; или &man.grep.1;) теперь перестраивается с
	      новыми системными файлами.</para>

	    <para>Если вы на последнем шаге, и вы знаете это (потому что
	      просматривали вывод, который сохраняете), то вы можете
	      (достаточно безболезненно) выполнить команду:</para>

	    <screen><emphasis>&hellip; исправление проблемы &hellip;</emphasis>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNO_CLEAN all</userinput></screen>

	    <para>При этом результат предыдущего запуска
	      <command>make buildworld</command> откатываться не будет.</para>

	    <para>Если вы видите сообщение:</para>

	    <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

	    <para>в выводе команды <command>make buildworld</command>, то делать так
	      достаточно безопасно.</para>

	    <para>Если этого сообщения не было, или вы в этом не уверены, то
	      всегда лучше обезопасить себя, и начать построение с самого
	      начала.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Как ускорить процесс построения системы?</para>
	  </question>

	  <answer>
	    <itemizedlist>
	      <listitem>
		<para>Работайте в однопользовательском режиме.</para>
	      </listitem>

	      <listitem>
		<para>Разместите каталоги <filename>/usr/src</filename> и
		  <filename>/usr/obj</filename> в отдельных файловых
		  системах, располагающихся на разных дисках.  Если это
		  возможно, то разместите эти диски на разных дисковых
		  контроллерах.</para>
	      </listitem>

	      <listitem>
		<para>Ещё лучше разместить эти файловые системы на нескольких
		  дисках при помощи устройства &man.ccd.4; (драйвер
		  объединённых дисков).</para>
	      </listitem>

	      <listitem>
		<para>Выключите генерацию профилирующего кода (установив
		  <quote>NO_PROFILE=true</quote> в файле
		  <filename>/etc/make.conf</filename>).  Вам это скорее
		  всего никогда не понадобится.</para>
	      </listitem>

	      <listitem>
		<para>Также в <filename>/etc/make.conf</filename> установите
		  значение <varname>CFLAGS</varname> во что-то типа <option>-O
		  -pipe</option>.  Оптимизация <option>-O2</option> выполняется
		  гораздо медленнее, а разница между <option>-O</option> и
		  <option>-O2</option> обычно несущественна.
		  <option>-pipe</option> позволяет компилятору использовать для
		  связи вместо временных файлов программные каналы, что
		  уменьшает обращение к диску (за счет оперативной
		  памяти).</para>
	      </listitem>

	      <listitem>
		<para>Передайте утилите &man.make.1; параметр
		  <option>-j<replaceable>n</replaceable></option> для запуска
		  параллельно нескольких процессов.  Обычно это помогает вне
		  зависимости от того, сколько процессоров установлено в вашей
		  машине.</para>
	      </listitem>

	      <listitem>
		<para>Файловая система, на которой располагается каталог
		  <filename>/usr/src</filename>, может быть смонтирована (или
		  перемонтирована) с опцией <option>noatime</option>.  При этом
		  запись на диск информации о времени последнего доступа к
		  файлам будет отключена.  Скорее всего, вам эта информация и
		  не нужна.</para>

		<screen>&prompt.root; <userinput>mount -u -o noatime /usr/src</userinput></screen>

		<warning>
		  <para>В примере предполагается, что
		    <filename>/usr/src</filename> располагается на
		    собственной файловой системе.  Если это не так (то
		    есть он является частью, скажем,
		    <filename>/usr</filename>), то вам нужно использовать
		    точку монтирования той файловой системы, а не
		    <filename>/usr/src</filename>.</para>
		</warning>
	      </listitem>

	      <listitem>
		<para>Файловая система, на которой располагается
		  <filename>/usr/obj</filename>, может быть смонтирована (или
		  перемонтирована) с параметром <option>async</option>.  Это
		  приведёт к тому, что операции записи на диск будут
		  выполняться асинхронно.  Другими словами, запись будет
		  завершаться немедленно, но данные записываться на диск
		  несколькими секундами позже.  Это позволит объединять
		  операции записи и приведёт к значительному приросту
		  производительности.</para>

		<warning>
		  <para>Имейте в виду, что эта опция делает вашу файловую
		    систему менее устойчивой.  С этой опцией имеется больше
		    шансов, что при перезагрузке машины после неожиданного
		    сбоя при пропадании напряжения файловая система окажется
		    в невосстановимом состоянии.</para>

		  <para>Если каталог <filename>/usr/obj</filename> &mdash; это все,
		    что есть в этой файловой системе, то это не проблема.
		    Если на той же самой файловой системе имеются какие-то
		    важные данные, то проверьте давность ваших резервных
		    копий перед включением этой опции.</para>
		</warning>

		<screen>&prompt.root; <userinput>mount -u -o async /usr/obj</userinput></screen>

		<warning>
		  <para>Как и раньше, если каталог
		    <filename>/usr/obj</filename> располагается не на
		    собственной файловой системе, то в примере замените его
		    на имя соответствующей точки монтирования.</para>
		</warning>
	      </listitem>
	    </itemizedlist>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Что мне делать, если что-то пошло не так?</para>
	  </question>

	  <answer>
	    <para>Скрупулезно проверьте, чтобы в вашем окружении не было
	      мешающих остатков от предыдущих построений.  Это достаточно
	      просто.</para>

	    <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root; <userinput>rm -rf /usr/obj/usr</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

	    <para>Да, команду <command>make cleandir</command> действительно
	      нужно выполнять дважды.</para>

	    <para>После этого повторите весь процесс снова, начиная с
	      <command>make buildworld</command>.</para>

	    <para>Если у вас все еще есть проблемы, пришлите текст ошибки и
	      выдачу команды <command>uname -a</command> на адрес списка рассылки
	      &a.questions.name;.  Будьте готовы ответить на другие вопросы о
	      конфигурации вашей системы!</para>
	  </answer>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 xml:id="small-lan">
    <info><title>Отслеживание исходных текстов для нескольких машин</title>
      <authorgroup>
	<author><personname><firstname>Mike</firstname><surname>Meyer</surname></personname><contrib>Текст предоставил </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>NFS</primary>
      <secondary>installing multiple machines</secondary>
    </indexterm>

    <para>Если у вас множество машин, для которых вы хотите отслеживать одно
      и то же дерево исходных текстов, то загрузка кода и перестроение системы
      полностью выглядит как ненужная трата ресурсов: дискового пространства,
      пропускной способности сети и процессорного времени.  Так оно и есть, и
      решением является выделение одной машины, которая выполняет основной
      объём работы, в то время как остальные используют результаты работы
      посредством NFS.  В этом разделе описывается именно этот метод.</para>

    <sect2 xml:id="small-lan-preliminaries">
      <title>Подготовка</title>

      <para>Первым делом определите набор машин, на которых выполняется один
	и тот же набор бинарных программ, и мы будем называть его
	<emphasis>набором для построения</emphasis>.  Каждая машина может иметь
	собственное уникальное ядро, но они будут работать с одними и теми же
	программами пользователя.  Из этого набора выберите машину, которая
	будет являться <emphasis>машиной для построения</emphasis>.  Она станет
	машиной, на которой будут строиться ядро и всё окружение.  В идеальном
	случае с достаточно незагруженным CPU для выполнения команд
	<command>make buildworld</command> и <command>make
	buildkernel</command>.  Вам также потребуется выбрать машину,
	которая будет <emphasis>тестовой</emphasis> для проверки обновлений
	программного обеспечения прежде, чем оно будет запущено в промышленную
	эксплуатацию.  Это <emphasis>должна</emphasis> быть машина, которая
	может быть в нерабочем состоянии достаточно долго.  Это может быть
	машина для построения, но не обязательно.</para>

      <para>Все машины в этом наборе для построения должны монтировать каталоги
	<filename>/usr/obj</filename> и
	<filename>/usr/src</filename> с одной и той же машины и в одну и ту же
	точку монтирования.  В идеальном случае они располагаются на разных
	дисках машины построения, но они могут также монтироваться по NFS на
	этой машине.  Если у вас имеется несколько наборов для построения, то
	каталог <filename>/usr/src</filename> должен быть на машине построения,
	а по NFS он должен быть смонтирован на остальных.</para>

      <para>Наконец, удостоверьтесь в том, что файлы
	<filename>/etc/make.conf</filename> и
	<filename>/etc/src.conf</filename> на всех машинах набора для
	построения соответствуют машине построения.  Это означает, что машина
	построения должна строить все части основного системного набора,
	которые будут устанавливаться на каждой машине из набора для
	построения.  Кроме того, у каждой машины построения должно быть задано
	имя ядра посредством переменной <varname>KERNCONF</varname> в файле
	<filename>/etc/make.conf</filename>, а машина построения должна
	перечислить их все в переменной <varname>KERNCONF</varname>, причём
	первым должно быть имя её собственного ядра.  Машина построения должна
	хранить конфигурационные файлы ядра каждой машины в каталоге
	<filename>/usr/src/sys/arch/conf</filename>,
	если на ней будут строиться соответствующие ядра..</para>
    </sect2>

    <sect2>
      <title>Основные системные компоненты</title>

      <para>Теперь, когда всё это сделано, вы готовы к построению.  Постройте
	ядро и всё окружение так, как это описано в <xref linkend="make-buildworld"/> на машине построения, но ничего не
	устанавливайте.  После того, как процесс построения завершится,
	перейдите к тестовой машине и установите только что построенное ядро.
	Если эта машина монтирует каталоги <filename>/usr/src</filename> и
	<filename>/usr/obj</filename> посредством NFS, то при перезагрузке в
	однопользовательский режим вам потребуется задействовать сеть и
	смонтировать их.  Самым простым способом сделать это является переход
	во многопользовательский режим и запуск команды <command>shutdown
	now</command> для перехода в однопользовательский режим.  После этого
	вы можете установить новое ядро и всё окружение, а затем выполнить
	команду <command>mergemaster</command> обычным образом.  После
	выполнения этих действий перезагрузитесь для возвращения к обычному
	режиму работы во многопользовательском режиме с этой машиной.</para>

      <para>После того, как вы убедитесь в нормальной работе всего на тестовой
	машине, проведите ту же самую процедуру для установки нового
	программного обеспечения на каждой из оставшихся машин из набора для
	построения.</para>
    </sect2>

    <sect2>
      <title>Порты</title>

      <para>Те же самые идеи могут использоваться и для дерева портов.  Первым
	критическим шагом является монтирование <filename>/usr/ports</filename>
	с одной и той же машины на всех компьютерах в наборе для построения.
	Затем вы можете корректно настроить <filename>/etc/make.conf</filename>
	для использования общего каталога с дистрибутивными файлами.  Вы должны
	задать переменную <varname>DISTDIR</varname> так, чтобы она указывала
	на общедоступный каталог, доступный тому пользователю, который
	отображается в пользователя <systemitem class="username">root</systemitem> для ваших точек
	монтирования NFS.  Каждая машина
	должна задавать <varname>WRKDIRPREFIX</varname> так, чтобы она
	указывала на локальный каталог построения.  Наконец, если вы
	собираетесь строить и распространять пакеты, то должны задать
	переменную <varname>PACKAGES</varname> так, чтобы она указывала на
	каталог, соответствующий <varname>DISTDIR</varname>.</para>
    </sect2>
  </sect1>
</chapter>
