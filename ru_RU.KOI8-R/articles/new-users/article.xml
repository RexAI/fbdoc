<?xml version="1.0" encoding="koi8-r"?>
<!DOCTYPE article PUBLIC "-//FreeBSD//DTD DocBook XML V5.0-Based Extension//EN"
	"http://www.FreeBSD.org/XML/share/xml/freebsd50.dtd">
<!--
     The FreeBSD Russian Documentation Project

     $FreeBSD$
     $FreeBSDru: frdp/doc/ru_RU.KOI8-R/articles/new-users/article.xml,v 1.6 2007/05/15 18:28:39 gad Exp $

     Original revision: r43184
-->
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="ru">
  <info><title>Пособие для новичков во FreeBSD и &unix;</title>
    

    <authorgroup>
      <author><personname><firstname>Annelise</firstname><surname>Anderson</surname></personname><affiliation>
	  <address><email>andrsn@andrsn.stanford.edu</email></address>
	</affiliation></author>
    </authorgroup>

    <pubdate>15 августа 1997</pubdate>

    <legalnotice xml:id="trademarks" role="trademarks">
      &tm-attrib.freebsd;
      &tm-attrib.ibm;
      &tm-attrib.microsoft;
      &tm-attrib.opengroup;
      &tm-attrib.general;
    </legalnotice>

    <releaseinfo>$FreeBSD$</releaseinfo>

    <abstract>
      <para>Поздравляем вас с установкой FreeBSD!  Это вводное пособие
	предназначено для тех, кто является новичком в мире FreeBSD
	<emphasis>и</emphasis> &unix;&mdash;так что оно начнётся с основ.
	Предполагается, что вы используете дистрибутив &os; версии 2.0.5
	или более поздней, распространяемый &os;.org, и в вашей системе (на данный момент) имеется один
	пользователь (это вы)&mdash;и вы хорошо ориентируетесь в DOS/&windows;
	или &os2;.</para>
    </abstract>
  </info>

  <sect1 xml:id="in-and-out">
    <title>Регистрация в системе и выход из неё</title>

    <para>Зарегистрируйтесь в системе (когда увидите приглашение
      <prompt>login:</prompt>) как пользователь, которого вы создали во время
      установки, или войдите в систему как пользователь
      <systemitem class="username">root</systemitem>.  (В вашей установленной системе уже имеется
      учётная запись для пользователя <systemitem class="username">root</systemitem>; который может переходить хоть куда
      и делать всё, что угодно, в том числе удаление необходимых для работы
      файлов, так что будьте внимательны!)  Обозначения &prompt.user; и
      &prompt.root; в последующем тексте означают приглашения системы (ваше
      может отличаться от него), причём &prompt.user; обозначает обычного
      пользователя, а &prompt.root; пользователя <systemitem class="username">root</systemitem>.</para>

    <para>Чтобы выйти из системы (и получить новое приглашение
      <prompt>login:</prompt>) наберите</para>

    <informalexample>
      <screen>&prompt.root; <userinput>exit</userinput></screen>
    </informalexample>

    <para>столько раз, сколько нужно.  Да, нажимайте <keysym>enter</keysym>
      после набора команд, и помните, что &unix; чувствителен к регистру
      букв&mdash;набирайте <command>exit</command>, но не
      <command>EXIT</command>.</para>

    <para>Для завершения работы машины наберите</para>

    <informalexample>
      <screen>&prompt.root; <userinput>/sbin/shutdown -h now</userinput></screen>
    </informalexample>

    <para>Или, для перезагрузки нужно набрать</para>

    <informalexample>
      <screen>&prompt.root; <userinput>/sbin/shutdown -r now</userinput></screen>
    </informalexample>

    <para>или</para>

    <informalexample>
      <screen>&prompt.root; <userinput>/sbin/reboot</userinput></screen>
    </informalexample>

    <para>Перезагрузку можно также выполнить нажатием клавиш
      <keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap>
      <keycap>Delete</keycap></keycombo>.  Подождите некоторое время, чтобы
      дать этой команде отработать.  В последних релизах FreeBSD она
      эквивалента выдаче команды <command>/sbin/reboot</command> и гораздо,
      гораздо лучше, чем нажатие кнопки сброса.  Вы ведь не хотите всё
      переустанавливать заново, не так ли?</para>
  </sect1>

  <sect1 xml:id="adding-a-user">
    <title>Добавление пользователя с привилегиями root</title>

    <para>Если при установке системы вы не создали ни одного пользователя, и
      поэтому вошли в систему как <systemitem class="username">root</systemitem>, то теперь вы должны создать
      пользователя по команде</para>

    <informalexample>
      <screen>&prompt.root; <userinput>adduser</userinput></screen>
    </informalexample>

    <para>При первом использовании утилиты <command>adduser</command> она может запрашивать
      сохранение некоторых параметров для использования их по умолчанию.
      вы можете сделать оболочкой, используемой по умолчанию, командный
      процессор &man.csh.1;, а не &man.sh.1;, если по умолчанию вам
      предлагается <command>sh</command>.  В противном случае просто нажимайте
      enter для принятия всех предлагаемых по умолчанию вариантов.  Эти
      значения по умолчанию сохраняются в файле
      <filename>/etc/adduser.conf</filename>, в форме, доступной для
      редактирования.</para>

    <para>Предположим, что вы создали пользователя <systemitem class="username">jack</systemitem> с
      полным именем <emphasis>Jack Benimble</emphasis>.  Назначьте пользователю
      <systemitem class="username">jack</systemitem> пароль, если информационная безопасность имеет значение (даже если
      это дети, которые могут стучать по клавиатуре).  Когда вам будет задан
      вопрос по включению пользователя <systemitem class="username">jack</systemitem> в другие группы, наберите
      <systemitem class="groupname">wheel</systemitem></para>

    <informalexample>
      <screen>Login group is ``jack''. Invite jack into other groups: <userinput>wheel</userinput></screen>
    </informalexample>

    <para>Это позволит входить в систему как пользователь
      <systemitem class="username">jack</systemitem> и использовать команду &man.su.1; для того,
      чтобы стать пользователем <systemitem class="username">root</systemitem>.  Тогда вас не будут больше обвинять в
      том, чтобы вы входите в систему как пользователь <systemitem class="username">root</systemitem>.</para>

    <para>Вы можете прекратить работы с <command>adduser</command> в любой
      момент, нажав <keycombo><keycap>Ctrl</keycap>
      <keycap>C</keycap></keycombo>, а в завершении ввода у вас будет шанс
      подтвердить заведение нового пользователя или набрать <keycap>n</keycap>
      в качестве отрицательного ответа.  Вам может захотеться создать второго
      нового пользователя, для того, чтобы при редактировании файлов
      для входа пользователя <systemitem class="username">jack</systemitem> имелся горячий резерв на тот случай,
      если что-то пойдёт не так.</para>

    <para>После того, как вы это сделаете, воспользуйтесь командой
      <command>exit</command> для возврата к приглашению ко входу в систему и
      зарегистрируйтесь в ней как пользователь <systemitem class="username">jack</systemitem>.
      Вообще говоря, лучше всего основную массу работы выполнять, работая как
      обычный пользователь, который не имеет мощь и опасность пользователя
      <systemitem class="username">root</systemitem>.</para>

    <para>Если вы уже создали пользователя и хотите, чтобы он мог выполнять
      команду <command>su</command> для получения привилегий <systemitem class="username">root</systemitem>, вы можете
      войти в систему как <systemitem class="username">root</systemitem> и отредактировать файл
      <filename>/etc/group</filename>, добавив пользователя <systemitem class="username">jack</systemitem> в первую
      строчку (в группу <systemitem class="groupname">wheel</systemitem>).  Однако сначала вам
      нужно поупражняться с программой &man.vi.1;, текстовым
      редактором,&mdash;или использовать более простой редактор, &man.ee.1;,
      имеющийся в последней версии FreeBSD.</para>

    <para>Для удаления пользователя воспользуйтесь командой
      <command>rmuser</command>.</para>
  </sect1>

  <sect1 xml:id="looking-around">
    <title>Просмотр окружения</title>

    <para>Войдя в систему как обычный пользователь, оглянитесь вокруг и
      попробуйте выполнить некоторые команды, дающие доступ к источникам
      информации и помощи внутри FreeBSD.</para>

    <para>Вот некоторые команды и то, что они делают:</para>

    <variablelist>
      <varlistentry>
	<term><command>id</command></term>

	<listitem>
	  <para>Говорит вам, кто вы!</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>pwd</command></term>

	<listitem>
	  <para>Показывает, где вы находитесь&mdash;текущий рабочий
	    каталог.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>ls</command></term>

	<listitem>
	  <para>Выдаёт список файлов, находящихся в текущем каталоге.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>ls -F</command></term>

	<listitem>
	  <para>Выдаёт перечень файлов, находящихся в текущем каталоге,
	    добавляя символы <literal>*</literal> после выполнимых файлов,
	    <literal>/</literal> после каталогов и <literal>@</literal> после
	    символических ссылок.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>ls -l</command></term>

	<listitem>
	  <para>Выдаёт перечень файлов в расширенном формате&mdash;размер, дата
	    и права доступа.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>ls -a</command></term>

	<listitem>
	  <para>Вместе со всеми выдаёт и список скрытых
	    <quote>dot</quote>-файлов (начинающихся с точки).  Если вы
	    являетесь пользователем <systemitem class="username">root</systemitem>, то <quote>dot</quote>-файлы выдаются
	    и без указания флага <option>-a</option>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>cd</command></term>

	<listitem>
	  <para>Смена каталогов.  <command>cd
	    ..</command> перемещает на один уровень
	    выше; обратите внимание на промежуток после <command>cd</command>.
	    <command>cd /usr/local</command> перейдёт в
	    указанное место.  <command>cd ~</command>
	    перейдёт в домашний каталог человека, который вошёл в
	    систему&mdash;к примеру, <filename>/usr/home/jack</filename>.
	    попробуйте выполнить команду <command>cd
	    /cdrom</command>, а затем
	    <command>ls</command> для проверки того, что ваш CDROM смонтирован
	    и работает.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>view
	  filename</command></term>

	<listitem>
	  <para>Позволяет вам просмотреть файл (с именем
	    <replaceable>filename</replaceable>) без внесения в него изменений.
	    Попробуйте выполнить команду <command>view
	    /etc/fstab</command>.  Для выхода
	    наберите <command>:q</command>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>cat
	  filename</command></term>

	<listitem>
	  <para>Выдаёт содержимое <replaceable>filename</replaceable> на экран.
	    если он слишком длинный и вы можете увидеть только его конец,
	    нажмите <keycap>ScrollLock</keycap> и используйте клавишу
	    <keycap>стрелка вверх</keycap> для движения назад; вы можете
	    также использовать <keycap>ScrollLock</keycap> и со страницами
	    справки.  Нажмите <keycap>ScrollLock</keycap> снова для прекращения
	    прокрутки.  Вам может захотеться попробовать команду
	    <command>cat</command> с некоторыми из dot-файлов в вашем домашнем
	    каталоге&mdash;<command>cat
	    .cshrc</command>, <command>cat
	    .login</command>, <command>cat
	    .profile</command>.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>В файле <filename>.cshrc</filename> вы заметите алиасы для некоторых
      из команд <command>ls</command> (они очень удобны).  Вы можете создать
      другие алиасы, отредактировав файл <filename>.cshrc</filename>.  Вы
      можете сделать эти алиасы доступными всем пользователям системы, поместив
      их в общесистемный конфигурационный файл для <command>csh</command>,
      <filename>/etc/csh.cshrc</filename>.</para>
  </sect1>

  <sect1 xml:id="getting-help">
    <title>Получение помощи и информации</title>

    <para>Вот несколько полезных источников получения помощи.  Здесь
      <replaceable>Text</replaceable> обозначает что-то по вашему выбору, что
      вы вводите&mdash;обычно команду или имя файла.</para>

    <variablelist>
      <varlistentry>
	<term><command>apropos text</command></term>

	<listitem>
	  <para>Всё, что содержит строку <replaceable>text</replaceable> в
	    <database>базе whatis</database>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>man text</command></term>

	<listitem>
	  <para>Страница справки по <replaceable>text</replaceable>.  Это
	    главный источник документации в &unix;-системах.
	    <command>man ls</command> покажет вам все
	    способы использования команды <command>ls</command>.  Нажимайте
	    <keycap>Enter</keycap> для передвижения по тексту,
	    <keycombo><keycap>Ctrl</keycap><keycap>B</keycap></keycombo> для
	    возврата на страницу назад,
	    <keycombo><keycap>Ctrl</keycap><keycap>F</keycap></keycombo> для
	    продвижения вперёд, <keycap>q</keycap> или
	    <keycombo><keycap>Ctrl</keycap><keycap>C</keycap></keycombo> для
	    выхода.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>which text</command></term>

	<listitem>
	  <para>Покажет, в каком месте из маршрута поиска пользователя
	    находится команда <replaceable>text</replaceable>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>locate text</command></term>

	<listitem>
	  <para>Все маршруты, где находится строчка
	    <replaceable>text</replaceable>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>whatis text</command></term>

	<listitem>
	  <para>Описывает, что делает команда <replaceable>text</replaceable>
	    и её справочная страница.  Команда <command>whatis *</command>
	    расскажет вам обо всех двоичных файлах в текущем каталоге.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>whereis text</command></term>

	<listitem>
	  <para>Ищет файл <replaceable>text</replaceable> и выдаёт полный путь
	    до него.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Вы можете захотеть попробовать использоваться команду
      <command>whatis</command> с некоторыми полезными командами типа
      <command>cat</command>, <command>more</command>, <command>grep</command>,
      <command>mv</command>, <command>find</command>,
      <command>tar</command>, <command>chmod</command>,
      <command>chown</command>, <command>date</command>, и
      <command>script</command>.  Команда <command>more</command> позволит
      вам читать постранично, как и в DOS, например, <command>ls -l |
      more</command> или <command>more
      filename</command>.  Знак
      <literal>*</literal> работает как общий шаблон&mdash;например,
      <command>ls w*</command> выдаст перечень файлов, начинающихся с буквы
      <literal>w</literal>.</para>

    <para>Некоторые из этих команд работают не очень хорошо?  Обе команды
      &man.locate.1; и &man.whatis.1; зависят от базы данных, которая
      перестраивается еженедельно.  Если ваша машина будет оставаться включенной
      на выходные (и она работает под FreeBSD), то вы можете пожелать
      запускать определённые команды раз в день, неделю, месяц.  Запускайте их
      как <systemitem class="username">root</systemitem> и дайте каждой отработать, прежде чем запускать
      следующую.</para>

    <informalexample>
      <screen>&prompt.root; <userinput>periodic daily</userinput>
<lineannotation>выдача опущена</lineannotation>
&prompt.root; <userinput>periodic weekly</userinput>
<lineannotation>выдача опущена</lineannotation>
&prompt.root; <userinput>periodic monthly</userinput>
<lineannotation>выдача опущена</lineannotation></screen>
    </informalexample>

    <para>Если вам надоело ждать, нажмите
      <keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo> для перехода
      в другую <firstterm>виртуальную консоль</firstterm>, и войдите в систему
      снова.  В конце концов, это многопользовательская и многозадачная
      система.  Тем не менее эти команды, скорее всего, в процессе работы будут
      выдавать сообщения вам на экран; вы можете набрать
      <command>clear</command> в приглашении для очистки экрана.  Пока они
      работают, вы можете смотреть в содержимое файлов
      <filename>/var/mail/root</filename> и
      <filename>/var/log/messages</filename>.</para>

    <para>Выполнение таких команд является частью системного
      администрирования&mdash;и как единственный пользователь &unix;-системы вы
      являетесь собственным системным администратором.  Практически всё, для
      чего вам нужно быть пользователем <systemitem class="username">root</systemitem>, это системное администрирование.
      Эти обязанности не описываются достаточно хорошо даже в тех больших
      толстых книгах по &unix;, в которых слишком много места отдаётся описанию
      работы с меню в оконных менеджерах.  Вам может понадобиться одна из двух
      лучших книг по системному администрированию, либо автора Эви Немет
      <citetitle>UNIX System Administration
      Handbook</citetitle> (Prentice-Hall, 1995, ISBN
      0-13-15051-7)&mdash;второе издание с красной обложкой; или
      автора &AElig;leen Frisch <citetitle>Essential System
      Administration</citetitle> (O'Reilly &amp; Associates, 2002,
      ISBN 0-596-00343-9).  Я использую книгу Немет.</para>
  </sect1>

  <sect1 xml:id="editing-text">
    <title>Редактирование текста</title>

    <para>Для конфигурации вашей системы вам нужно редактировать текстовые
      файлы.  Большинство из них будут находиться в каталоге
      <filename>/etc</filename>; и вам необходимо командой
      <command>su</command> получить полномочия пользователя <systemitem class="username">root</systemitem>, чтобы их
      править.  Вы можете использовать простой редактор <command>ee</command>,
      однако в смысле перспективности лучше изучить текстовый редактор
      <command>vi</command>.  В каталоге
      <filename>/usr/src/contrib/nvi/docs/tutorial</filename> есть прекрасный
      учебник по vi, если у вас есть исходники системы.</para>

    <para>Перед тем, как редактировать файл, наверное, вы должны сохранить
      резервную копию.  Предположим, что вы собираетесь отредактировать файл
      <filename>/etc/rc.conf</filename>.  Вы можете воспользоваться командой
      <command>cd /etc</command> для перехода в каталог
      <filename>/etc</filename> и выполнить следующее:</para>

    <informalexample>
      <screen>&prompt.root; <userinput>cp rc.conf rc.conf.orig</userinput></screen>
    </informalexample>

    <para>При этом файл <filename>rc.conf</filename> скопируется в
      <filename>rc.conf.orig</filename>, и в последующем вы сможете скопировать
      <filename>rc.conf.orig</filename> в файл
      <filename>rc.conf</filename> для восстановления оригинала.  Но ещё лучше
      его переместить (переименовать), после чего скопировать обратно:</para>

    <informalexample>
      <screen>&prompt.root; <userinput>mv rc.conf rc.conf.orig</userinput>
&prompt.root; <userinput>cp rc.conf.orig rc.conf</userinput></screen>
    </informalexample>

    <para>потому что команда <command>mv</command> сохраняет исходную
      информацию о дате и владельце файла.  Теперь вы можете редактировать
      <filename>rc.conf</filename>.  Если вы захотите восстановить исходное
      состояние, то выполните <userinput>mv rc.conf rc.conf.myedit</userinput>
      (полагаем, что вы хотите сохранить отредактированную версию), а
      затем</para>

    <informalexample>
      <screen>&prompt.root; <userinput>mv rc.conf.orig rc.conf</userinput></screen>
    </informalexample>

    <para>для возврата всего на место.</para>

    <para>Для редактирования файла наберите</para>

    <informalexample>
      <screen>&prompt.root; <userinput>vi filename</userinput></screen>
    </informalexample>

    <para>Передвигайтесь по тексту при помощи клавиш со стрелками.
      <keycap>Esc</keycap> (клавиша отмены) переводит редактор
      <command>vi</command> в командный режим.  Вот некоторые из них:</para>

    <variablelist>
      <varlistentry>
	<term><command>x</command></term>

	<listitem>
	  <para>удалить символ, на котором находится курсор</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>dd</command></term>

	<listitem>
	  <para>удалить целую строку (даже если на экране она не помещается в
	    целую строку)</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>i</command></term>

	<listitem>
	  <para>вставка текста в позиции курсора</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>a</command></term>

	<listitem>
	  <para>вставка текста после курсора</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Сразу после набора <command>i</command> или <command>a</command> вы
      можете вводить текст.  <command>Esc</command> возвратит вас обратно в
      командный режим, где вы можете набрать</para>

    <variablelist>
      <varlistentry>
	<term><command>:w</command></term>

	<listitem>
	  <para>для записи ваших изменений на диск и продолжения
	    редактирования</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>:wq</command></term>

	<listitem>
	  <para>для записи и выхода</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>:q!</command></term>

	<listitem>
	  <para>для выхода без сохранения изменений</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>/text</command></term>

	<listitem>
	  <para>для перемещения курсора на <replaceable>text</replaceable>;
	    <command>/Enter</command> (клавиша ввода) для
	    поиска следующего экземпляра
	    <replaceable>text</replaceable>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>G</command></term>

	<listitem>
	  <para>для перехода в конец файла</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>nG</command></term>

	<listitem>
	  <para>Для перехода к строке <replaceable>n</replaceable> в файле,
	    где <replaceable>n</replaceable> является числом</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><keycombo><keycap>Ctrl</keycap><keycap>L</keycap></keycombo></term>

	<listitem>
	  <para>для перерисовки экрана</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><keycombo><keycap>Ctrl</keycap><keycap>b</keycap></keycombo> и
	  <keycombo><keycap>Ctrl</keycap><keycap>f</keycap></keycombo></term>

	<listitem>
	  <para>для перемотки на экран назад и вперёд, как при работе с
	    <command>more</command> и <command>view</command>.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Поупражняйтесь с редактором <command>vi</command> в своём домашнем
      каталоге, создав новый файл по команде <command>vi
      filename</command>, добавляя и удаляя текст,
      сохраняя файл и вызывая его снова.  Редактор <command>vi</command>
      преподносит некоторые сюрпризы, потому что он на самом деле достаточно
      сложный, и иногда вы можете неправильно вызвать команду, которая сделает
      нечто, чего вы не ожидали.  (Некоторым людям действительно нравится
      <command>vi</command>&mdash;он более мощный, чем EDIT из
      DOS&mdash;посмотрите команду <command>:r</command>.)  Для того, чтобы
      удостовериться, что вы находитесь в режиме команд, нажимайте
      <keycap>Esc</keycap> один или несколько раз, и начинайте снова с этого
      места, если возникли какие-то проблемы, часто сохраняйте текст командой
      <command>:w</command> и используйте <command>:q!</command> для того,
      чтобы прекратить работу и начать всё сначала (с вашей последней команды
      <command>:w</command>), если это нужно.</para>

    <para>Теперь вы можете выполнить <command>cd</command> для перехода в каталог
      <filename>/etc</filename>, <command>su</command> в пользователя <systemitem class="username">root</systemitem>,
      использовать <command>vi</command> для редактирования файла
      <filename>/etc/group</filename> и добавлять пользователя в группу <systemitem class="groupname">wheel</systemitem>,
      чтобы он имел полномочия пользователя root.  Просто добавьте запятую и
      имя входа пользователя в конце первой строки этого файла, нажмите
      <keycap>Esc</keycap> и воспользуйтесь <command>:wq</command> для записи
      файла на диск и выхода.  Работает всегда.  (Вы не поставили пробел после
      запятой, ведь так?)</para>
  </sect1>

  <sect1 xml:id="printing-files-from-dos">
    <title>Печать файлов из DOS</title>

    <para>На данный момент, скорее всего, принтер у вас не работает, так что
      вот способ создания файла из справочной страницы, перемещения её на
      дискету, а затем печать из DOS.  Положим, что вы хотите внимательно
      прочесть об изменении прав доступа на файлы (весьма важно).  Вы можете
      воспользоваться командой <command>man chmod</command> для того, чтобы
      прочесть об этом.  Команда</para>

    <informalexample>
      <screen>&prompt.user; <userinput>man chmod | col -b &gt; chmod.txt</userinput></screen>
    </informalexample>

    <para>удалит коды форматирования и перенаправит страницу справки в файл
      <filename>chmod.txt</filename>, не выдавая её на экран.  Теперь поместите
      отформатированную dos-дискету в дисковод <filename>a</filename>, выполните
      <command>su</command>, перейдя к пользователю <systemitem class="username">root</systemitem>, и наберите</para>

    <informalexample>
      <screen>&prompt.root; <userinput>/sbin/mount -t msdosfs /dev/fd0 /mnt</userinput></screen>
    </informalexample>

    <para>для монтирования дискеты в каталог <filename>/mnt</filename>.</para>

    <para>Теперь (и вам больше не нужно быть пользователем <systemitem class="username">root</systemitem>, так что можете
      набрать <command>exit</command> для возврата к пользователю jack) вы
      можете перейти в каталог, где создали <filename>chmod.txt</filename> и
      скопировать файл на дискету следующей командой:</para>

    <informalexample>
      <screen>&prompt.user; <userinput>cp chmod.txt /mnt</userinput></screen>
    </informalexample>

    <para>и воспользоваться командой <command>ls /mnt</command> для получения
      списка файлов каталога <filename>/mnt</filename>, которая теперь должна
      показать файл <filename>chmod.txt</filename>.</para>

    <para>Вы также можете захотеть создать файл из
      <filename>/sbin/dmesg</filename>, набрав</para>

    <informalexample>
      <screen>&prompt.user; <userinput>/sbin/dmesg &gt; dmesg.txt</userinput></screen>
    </informalexample>

    <para>и скопировав <filename>dmesg.txt</filename> на дискету.
      <command>/sbin/dmesg</command> является протоколом загрузки системы,
      который полезно понимать, потому что в нём перечисляется всё, что
      обнаружила при загрузке FreeBSD.  Если вы будете задавать вопросы в
      списке рассылки &a.questions; или в конференции USENET&mdash;наподобие
      <quote>FreeBSD не обнаруживает моего ленточного накопителя, что мне
      делать?</quote>&mdash;отвечающие захотят узнать, что выдаёт
      <command>dmesg</command>.</para>

    <para>Теперь вы можете (как <systemitem class="username">root</systemitem>) отмонтировать гибкий диск, чтобы его
      вынуть, по команде</para>

    <informalexample>
      <screen>&prompt.root; <userinput>/sbin/umount /mnt</userinput></screen>
    </informalexample>

    <para>и перезагрузиться в DOS.  Скопируйте эти файлы в каталог DOS,
      вызовите их при помощи редактора DOS EDIT, &windows; Notepad или
      Wordpad, или даже с текстовым процессором, внесите маленькое изменение,
      чтобы файл сохранился, и напечатайте его обычным образом из DOS или
      Windows.  Надеемся, это срабатывает!  Справочные страницы лучше всего
      выглядят при печати командой DOS <command>print</command>.  (Копирование
      файлов из FreeBSD на смонтированный раздел DOS в некоторых случаях всё
      ещё немного рискованная операция.)</para>

    <para>Процесс настройки принтера на печать из FreeBSD включает в себя
      создание соответствующей записи в файле
      <filename>/etc/printcap</filename> и создание нужного каталога очереди в
      <filename>/var/spool/output</filename>.  Если ваш принтер подключен к
      <hardware>lpt0</hardware> (то, что в DOS называется
      <hardware>LPT1</hardware>), то вам достаточно только перейти в каталог
      <filename>/var/spool/output</filename> и (как <systemitem class="username">root</systemitem>) создать каталог
      <filename>lpd</filename>, набрав: <command>mkdir lpd</command>, если её
      ещё не существует.  Тогда принтер должен реагировать, если при загрузке
      системы он включён, а команда <command>lp</command> или
      <command>lpr</command> должны посылать файл на принтер.  Будет ли файл
      действительно напечатан, зависит от его настройки, каковая описана в
      <link xlink:href="&url.books.handbook;/index.html">Руководстве
      FreeBSD.</link></para>
  </sect1>

  <sect1 xml:id="other-useful-commands">
    <title>Другие полезные команды</title>

    <variablelist>
      <varlistentry>
	<term><command>df</command></term>

	<listitem>
	  <para>выдаёт данные о занятом файлами пространстве и смонтированных
	    файловых системах.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>ps aux</command></term>

	<listitem>
	  <para>показывает работающие процессы.  <command>ps ax</command>
	    является частоупотребительной формой.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>rm filename</command></term>

	<listitem>
	  <para>удаляет <replaceable>filename</replaceable>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>rm -R dir</command></term>

	<listitem>
	  <para>удаляет каталог <replaceable>dir</replaceable> и все его
	    подкаталоги&mdash;осторожно!</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>ls -R</command></term>

	<listitem>
	  <para>выдаёт список файлов в текущем каталоге и всех его
	    подкаталогах; я использовал вариант, <command>ls -AFR &gt;
	    where.txt</command>, для получения перечня всех файлов в
	    <filename>/</filename> и (отдельно) <filename>/usr</filename> до
	    того, как узнал о более эффективном способе поиска файлов.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>passwd</command></term>

	<listitem>
	  <para>для изменения пароля пользователя (или пароля <systemitem class="username">root</systemitem>)</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>man hier</command></term>

	<listitem>
	  <para>справочная страница по файловой структуре &unix;</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Используйте <command>find</command> для поиска
      <filename>filename</filename> в <filename>/usr</filename> или в любом из
      её подкаталогов при помощи команды</para>

    <informalexample>
      <screen>&prompt.user; <userinput>find /usr -name "filename"</userinput></screen>
    </informalexample>

    <para>Вы можете использовать <literal>*</literal> в качестве шаблона внутри
      <parameter>"<replaceable>filename</replaceable>"</parameter>
      (это выражение должно быть в кавычках).  Если вы укажете команде
      <command>find</command> на поиск в <filename>/</filename>, а не в
      <filename>/usr</filename>, то она будет искать файл(ы) во всех
      смонтированных файловых системах, включая CDROM и раздел DOS.</para>

    <para>Прекрасным пособием, описывающим команды и утилиты &unix;, является
      книга Abrahams &amp; Larson, <citetitle>Unix for the
      Impatient</citetitle> (2nd ed., Addison-Wesley, 1996).  Масса информации
      по &unix; есть и в Internet.</para>
  </sect1>

  <sect1 xml:id="next-steps">
    <title>Следующие шаги</title>

    <para>Теперь вы должны иметь инструменты, которые необходимо держать под
      рукой и умеете редактировать файлы, так что вы должны суметь запустить
      всё, что угодно.  Много полезной информации содержится в Руководстве по
      FreeBSD (которое, скорее всего, есть на вашем жёстком диске) и <link xlink:href="&url.base;/index.html">Web-сайте FreeBSD</link>.  На CDROM, а
      также Web-сайте находятся различные пакеты и порты.  В Руководстве
      рассказывается более подробно о том, как их использовать (получить
      пакет, если он существует, командой <command>pkg_add
      /cdrom/packages/All/packagename</command>,
      где <replaceable>packagename</replaceable> является именем файла
      пакета).  На CDROM находится перечни пакетов и портов с их краткими
      описаниями в файлах <filename>cdrom/packages/index</filename>,
      <filename>cdrom/packages/index.txt</filename> и
      <filename>cdrom/ports/index</filename>, а более полные описания можно
      найти в <filename>/cdrom/ports/*/*/pkg/DESCR</filename>, где знаки
      <literal>*</literal> обозначают тематические подкаталоги с программами
      и названиями программ, соответственно.</para>

    <para>Если вы посчитаете, что Руководство является слишком сложной книгой
      (что с <command>lndir</command> и всё) по установке портов с CDROM, вот
      рецепт, который обычно срабатывает:</para>

    <para>Найдите нужный вам порт, скажем, <command>kermit</command>.  На CDROM
      для него должен существовать каталог.  Скопируйте этот подкаталог в
      каталог <filename>/usr/local</filename> (хорошее место для программного
      обеспечения, которое вы добавляете, и которое должно быть доступно всем
      пользователям) такой командой:</para>

    <informalexample>
      <screen>&prompt.root; <userinput>cp -R /cdrom/ports/comm/kermit /usr/local</userinput></screen>
    </informalexample>

    <para>В результате должен образоваться подкаталог
      <filename>/usr/local/kermit</filename>, содержащий все файлы, что есть в
      подкаталоге <command>kermit</command> на CDROM.</para>

    <para>Затем создайте каталог <filename>/usr/ports/distfiles</filename>,
      если он ещё не существует, при помощи команды <command>mkdir</command>.
      Теперь проверьте содержимое <filename>/cdrom/ports/distfiles</filename>
      на предмет наличия файла с именем, говорящем о том, что это тот порт,
      который вы хотите иметь.  Скопируйте этот файл в каталог
      <filename>/usr/ports/distfiles</filename>; в последних версиях вы можете
      пропустить этот шаг, и FreeBSD выполнит его за вас.  В случае с
      <command>kermit</command>, дистрибутивного файла не существует.</para>

    <para>После этого по команде <command>cd</command> перейдите в подкаталог
      <filename>/usr/local/kermit</filename>, в котором есть файл
      <filename>Makefile</filename>.  Наберите</para>

    <informalexample>
      <screen>&prompt.root; <userinput>make all install</userinput></screen>
    </informalexample>

    <para>Во время выполнения порт обратится к FTP для получения всех архивных
      файлов, нужных ему и которых не найдено на CDROM или в каталоге
      <filename>/usr/ports/distfiles</filename>.  Если сеть у вас ещё не
      работает, и файла для порта в каталоге
      <filename>/cdrom/ports/distfiles</filename> нет, вам потребуется получить
      дистрибутивный файл на другой машине и скопировать его в каталог
      <filename>/usr/ports/distfiles</filename>.  Прочтите
      <filename>Makefile</filename> (при помощи команд
      <command>cat</command>, <command>more</command> или
      <command>view</command>), чтобы понять, как называется файл и куда нужно
      обратиться (основной сайт распространения), чтобы его получить.
      (Используйте двоичный тип передачи файлов!)  Затем перейдите обратно
      в каталог <filename>/usr/local/kermit</filename>, найдите каталог с
      <filename>Makefile</filename> и наберите <command>make all
      install</command>.</para>

    <para>Ещё одной проблемой, встречающейся при установке портов или пакетов,
      является их потребность в какой-то другой программе.</para>

    <para>После того, как установка будет выполнена, наберите команду
      <command>rehash</command> для того, чтобы заставить FreeBSD перечитать
      файлы, находящиеся в маршрутах поиска, чтобы система обнаружила их
      появление.  (Если вы получили массу сообщений <errorname>path not
      found</errorname> при использовании <command>whereis</command> или
      <command>which</command>, то вам необходимо сделать добавления к перечню каталогов в
      команде определения маршрута в файле <filename>.cshrc</filename>,
      находящемся а вашем домашнем каталоге.  Задание маршрута в &unix; несёт
      ту же самую функцию, что и в DOS, за исключением работы с текущим
      каталогом (по умолчанию) по соображениям безопасности; если команда,
      которую вы хотите выполнить, находится в текущем каталоге, вам нужно
      набирать <filename>./</filename> перед названием команды, чтобы она
      заработала; пробелов после слэша ставить не нужно.)</para>
  </sect1>

  <sect1 xml:id="your-working-environment">
    <title>Ваше рабочее окружение</title>

    <para>Ваш командный процессор является самой важной частью вашего рабочего
      окружения.  В DOS обычной оболочкой является command.com.  Оболочка
      занимается интерпретацией команд, которые вы вводите в командной строке,
      и таким образом взаимодействует с остальной частью операционной системы.
      Вы можете также писать скрипты командного процессора, которые похожи на
      .bat-файлы DOS: это последовательности команд, которые должны выполняться
      без вашего участия.</para>

    <para>Вместе с FreeBSD устанавливаются два командный процессора:
      <command>csh</command> и <command>sh</command>.
      <command>csh</command> хорош для работы в командной строке, однако
      скрипты должны писаться на языке оболочек <command>sh</command> (или
      <command>bash</command>).  Вы можете выяснить, какой командный процессор
      у вас используется, набрав <command>echo $SHELL</command>.</para>

    <para>Оболочка <command>csh</command> подходящая, однако
      <command>tcsh</command> может всё, что умеет <command>csh</command> и
      ещё больше.  Она позволяет вам восстанавливать прошлые команды клавишами
      со стрелками и редактировать их.  В нём есть автозавершение имён файлов
      по нажатию клавиши табуляции (в <command>csh</command> используется
      клавиша <keycap>Esc</keycap>) и он позволяет вам переключаться в каталог,
      в котором вы были ранее, по команде <command>cd -</command>.  Также
      в <command>tcsh</command> гораздо легче изменять системное приглашение.
      Это гораздо упрощает жизнь.</para>

    <para>Вот три шага по установке нового командного процессора:</para>

    <procedure>
      <step>
	<para>Установите командный процессор как порт или пакет, как вы обычно
	  это делаете с другим портом или пакетом.  Используйте
	  <command>rehash</command> и <command>which tcsh</command>
	  (предполагается, что вы устанавливаете <command>tcsh</command>) для
	  проверки того, что командный процессор установлен.</para>
      </step>

      <step>
	<para>Работая как пользователь <systemitem class="username">root</systemitem>, отредактируйте файл
	  <filename>/etc/shells</filename>, добавив в него строку с новой
	  оболочкой, в нашем случае это
	  <filename>/usr/local/bin/tcsh</filename>, и сохраните файл.
	  (Некоторые порты могут делать это за вас.)</para>
      </step>

      <step>
	<para>Воспользуйтесь командой <command>chsh</command> для смены
	  постоянно используемой вами оболочки на <command>tcsh</command>, либо
	  наберите <command>tcsh</command> в командной строке для смены
	  вашей оболочки без повторного входа в систему.</para>
      </step>
    </procedure>

    <note>
      <para>Менять командный процессор для пользователя <systemitem class="username">root</systemitem> на что-то,
	отличающееся от <command>sh</command> или <command>csh</command>,
	в ранних версиях FreeBSD и во многих других версиях &unix; может быть опасно; вы
	можете лишиться работающей оболочки при переходе системы в
	однопользовательский режим.  Решением является использование
	<command>su -m</command> для того, чтобы стать пользователем <systemitem class="username">root</systemitem>, что
	даст в качестве оболочки <command>tcsh</command>, но вы будете являться
	пользователем <systemitem class="username">root</systemitem>, потому что оболочка является частью окружения.  Вы
	можете сделать это постоянным, добавив в ваш файл
	<filename>.tcshrc</filename> в качестве алиаса по такой команде:</para>

	<programlisting>alias su su -m</programlisting>
    </note>

    <para>При запуске <command>tcsh</command> он будет считывать файлы
      <filename>/etc/csh.cshrc</filename> и
      <filename>/etc/csh.login</filename>, как и <command>csh</command>.  Эта
      оболочка также читает файл <filename>.login</filename> из вашего
      домашнего каталога, а также файл <filename>.cshrc</filename>, если только
      вы не создали файл <filename>.tcshrc</filename>.  Это вы можете сделать
      простым копированием файла <filename>.cshrc</filename> в
      <filename>.tcshrc</filename>.</para>

    <para>Теперь, когда у вас установлен командный процессор
      <command>tcsh</command>, вы можете настроить приглашение командной
      строки.  Все подробности можно найти на странице справки по
      <command>tcsh</command>, но всё же вот строка, которая помещается в ваш
      файл <filename>.tcshrc</filename>, которая может показать, сколько команд
      вы уже набрали, сколько сейчас времени и в каком каталоге вы находитесь.
      Она также выдаёт <literal>&gt;</literal>, если вы являетесь обычным
      пользователем, и <literal>#</literal>, если вы являетесь пользователем
      <systemitem class="username">root</systemitem>, однако tsch будет делать это в любом случае:</para>

    <para>set prompt = "%h %t %~ %# "</para>

    <para>Эта строка должна быть поставлена на то же самое место, что и
      существующая строка установки приглашения, если она есть, либо после
      строки "if($?prompt) then", если её нет.  Закомментируйте старую
      строку; вы всегда сможете вернуться к ней обратно, если предпочтёте её.
      Не забудьте о пробелах и кавычках.  Вы можете заставить перечитать
      <filename>.tcshrc</filename>, набрав
      <command>source .tcshrc</command>.</para>

    <para>Перечень других установленных переменных окружения вы можете
      получить, набрав <command>env</command> в приглашении командной строки.
      В результате, кроме всего прочего, будут показаны редактор, используемый
      по умолчанию, программа постраничной выдачи и тип терминала.  Командой,
      полезной при входе в систему с удалённого места и невозможности запуска
      программы, потому что терминал не обладает некоторыми возможностями,
      является команда <command>setenv TERM vt100</command>.</para>
  </sect1>

  <sect1 xml:id="other">
    <title>Остальное</title>

    <para>Работая как пользователь <systemitem class="username">root</systemitem>, вы можете отмонтировать CDROM по
      команде <command>/sbin/umount /cdrom</command>, вытащить его из привода,
      вставить другой диск и смонтировать его командой
      <command>/sbin/mount_cd9660 /dev/cd0a /cdrom</command>, при этом
      предполагается, что <hardware>cd0a</hardware> является именем устройства
      для вашего привода CDROM.  Самые последние версии FreeBSD позволяют вам
      монтировать CDROM просто по команде
      <command>/sbin/mount /cdrom</command>.</para>

    <para>Использование живой файловой системы&mdash;она находится на втором
      диске FreeBSD из набора CDROM&mdash;полезно при нехватке пространства.
      То, что находится в этой файловой системе, меняется от релиза к релизу.
      Вы можете попытаться поиграть в игры с CDROM.  При этом применяется
      команда <command>lndir</command>, которая устанавливается с X Window
      System, и служит для указания программам, где искать необходимые файлы,
      потому что они находятся в файловой системе <filename>/cdrom</filename>,
      а не в <filename>/usr</filename> и её подкаталогах, где должны
      находиться.  Прочтите справку по команде
      <command>man lndir</command>.</para>
  </sect1>

  <sect1 xml:id="comments-welcome">
    <title>Пожелания приветствуются</title>

    <para>Если вы используете это руководство, мне будет интересно знать, в
      каком месте оно написано непонятно и что упущено из того, что, по вашему
      мнению, должно быть включено ценного.  Мои благодарности Eugene W. Stark,
      профессору информатики в SUNY-Stony Brook, и John Fieber за ценные
      советы.</para>

    <para>Annelise Anderson,
      <email>andrsn@andrsn.stanford.edu</email></para>
  </sect1>
</article>
