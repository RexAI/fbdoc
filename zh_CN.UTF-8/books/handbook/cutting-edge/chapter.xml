<?xml version="1.0" encoding="utf-8"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD Simplified Chinese Project

     Original Revision: r43258
     $FreeBSD$
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="updating-upgrading">
  <info><title>更新与升级 &os;</title>
    <authorgroup>
      <author><personname><firstname>Jim</firstname><surname>Mock</surname></personname><contrib>重新组织和部分更新，由 </contrib></author>
      <!-- Mar 2000 -->
    </authorgroup>

    <authorgroup>
      <author><personname><firstname>Jordan</firstname><surname>Hubbard</surname></personname><contrib>原创： </contrib></author>

      <author><personname><firstname>Poul-Henning</firstname><surname>Kamp</surname></personname></author>

      <author><personname><firstname>John</firstname><surname>Polstra</surname></personname></author>

      <author><personname><firstname>Nik</firstname><surname>Clayton</surname></personname></author>
    </authorgroup>
    
  </info>

  

  <sect1 xml:id="updating-upgrading-synopsis">
    <title>概述</title>

    <para>&os; 各个发行版之间始终处于持续开发状态。 有些人喜欢使用正式发行版，
        另一些人则更喜欢与最新开发版保持同步。
        不过， 即使是正式发行版也常常需要安全补丁和重大修正方面的更新。
        不论您使用的是何种版本， &os; 都提供了更新所需的所有工具，
        以使系统保持最新状态， 并允许各版本间的轻松升级。
        本章将介绍如何跟踪开发版系统， 并如何保持 &os; 操作系统最新。</para>

    <para>读完这一章， 您将了解：</para>

    <itemizedlist>
      <listitem>
	<para>使用哪些工具来更新系统与 Ports Collection 。</para>
      </listitem>

      <listitem>
          <para>如何使用 <application>freebsd-update</application> 、
              <application>Subversion</application> 或
              <application>CTM</application> 让您的系统保持最新。</para>
      </listitem>

      <listitem>
	<para>如何比较当前系统与原已知副本的状态。</para>
      </listitem>

      <listitem>
          <para>如何使用 <application>Subversion</application>
              或文档 ports 来更新本地的文档
              <!--, and <application>Docsnap</application>--> 。</para>
      </listitem>

      <listitem>
	<para>两个开发分支 &os.stable; 和 &os.current; 的区别。</para>
      </listitem>

      <listitem>
	<para>如何重新编译和安装基本系统。</para>
      </listitem>
    </itemizedlist>

    <para>阅读本章之前， 您应该了解：</para>

    <itemizedlist>
      <listitem>
	<para>正确配置网络连接 （ <xref linkend="advanced-networking"/> ）。</para>
      </listitem>

      <listitem>
	<para>安装额外的第三方软件 （ <xref linkend="ports"/> ）。</para>
      </listitem>
    </itemizedlist>

    <note>
        <para>在本章中， 使用 <command>svn</command> 用来获取和更新 &os; 源代码。
            要使用它， 首先需要安装 <package>devel/subversion</package> 的
            port 或预编译包。</para>
    </note>
  </sect1>

  <sect1 xml:id="updating-upgrading-freebsdupdate">
    <info><title>&os; 更新</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Written by </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Colin</firstname><surname>Percival</surname></personname><contrib>Based on notes provided by </contrib></author>
      </authorgroup>
    </info>
    

    <indexterm><primary>Updating and Upgrading</primary></indexterm>
    <indexterm>
      <primary>freebsd-update</primary>
      <see>updating-upgrading</see>
    </indexterm>

    <para>应用安全补丁是计算机软件维护的一个重要组成部分， 特别是针对操作系统来说。
        长期以来， 对于 &os; 来说， 这都不是一件很容易做到的事情。
        必须先把补丁修补到源代码上， 再编译成二进制代码， 然后才安装补丁。</para>

    <para>现在， &os; 引入 <command>freebsd-update</command> 工具， 应用补丁不再那么麻烦。
        这个工具提供两种功能： 首先支持直接把二进制的安全更新与勘误更新
        （errata updates） 应用到 &os; 基本系统， 而不需要重新编译安装。
        其次是这个工具还支持主要与次要发行版本间的升级。</para>

    <note>
        <para>目前， 二进制更新支持所有安全小组所支持的所有架构的正式发行版。
            在升级到一个新的正式发行版本之前， 应先阅读目标正式发行版的发行公告，
            因为它们可能包含有关目标升级版本的重要消息。
            这些发行公告可以通过以下链接查阅：
            <uri xlink:href="http://www.FreeBSD.org/releases/">http://www.FreeBSD.org/releases/</uri> 。</para>
    </note>

    <para>如果 <command>crontab</command> 中存在有用到 &man.freebsd-update.8;
        特性的部分， 那么在下面的操作开始以前， 必须先禁用它们。</para>

    <sect2 xml:id="freebsdupdate-config-file">
      <title>配置文件</title>

      <para>有些用户可能希望调整 <filename>/etc/freebsd-update.conf</filename>
          中的默认配置， 从而更好的控制升级过程。 可用的选项在文档中有详细介绍，
          但下面这些可能需要更多的解释：</para>

      <programlisting># Components of the base system which should be kept updated.
Components src world kernel</programlisting>

      <para>这个参数是控制 &os; 的哪些部分会被更新。 默认更新源代码、
          整个基本系统和内核。 组件同样也是可控制的， 举个例子，
          这里加入 <literal>world/games</literal> 就会允许应用游戏相关的补丁。
          使用 <literal>src/bin</literal> 则是允许更新
          <filename>src/bin</filename> 目录中的源代码。</para>

      <para>这个选项最好保持默认值， 因为如果指定了任何参数，
          那么就需要用户列出所有需要更新的项目。
          这可能会带来灾难性的后果，
          因为未指定部分的源代码和二进制程序将得不到更新。</para>

      <programlisting># Paths which start with anything matching an entry in an IgnorePaths
# statement will be ignored.
IgnorePaths</programlisting>

      <para>添加指定路径， 比如 <filename>/bin</filename> 或
          <filename>/sbin</filename> 这将能让这些指定的目录在更新过程中不被修改。
          这个选项能够防止本地的修改被 <command>freebsd-update</command> 工具覆盖。</para>

      <programlisting># Paths which start with anything matching an entry in an UpdateIfUnmodified
# statement will only be updated if the contents of the file have not been
# modified by the user (unless changes are merged; see below).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</programlisting>

      <para>更新时跳过指定目录或配置文件。 用户指定的配置文件都会使这些文件的自动更新失效。
          还有另外一个选项， <literal>KeepModifiedMetadata</literal> ，
          这能让 <command>freebsd-update</command>  在合并时另存修改。</para>

      <programlisting># When upgrading to a new &os; release, files which match MergeChanges
# will have any local changes merged into the version from the new release.
MergeChanges /etc/ /var/named/etc/</programlisting>

      <para><command>freebsd-update</command> 会尝试合并列表中配置文件。
          文件合并的过程是一系列类似 &man.mergemaster.8; 的 &man.diff.1; 补丁格式，
          但更少选项。 要么接受合并， 要么打开一个文件编辑器，
          或者终止 <command>freebsd-update</command> 。
          如果不能确定， 可以先备份 <filename>/etc</filename> ， 然后接受合并。
          有关 <command>mergemaster</command> 的更多信息请参阅：
          <xref linkend="mergemaster"/> 。</para>

<programlisting># Directory in which to store downloaded updates and temporary
# files used by &os; Update.
# WorkDir /var/db/freebsd-update</programlisting>

      <para>这个目录是存放所有补丁和临时文件的地方。
          一般情况下， 用户做一个版本间升级时，
          则至少要保证这个目录有 1 GB 的可用磁盘空间。</para>

      <programlisting># When upgrading between releases, should the list of Components be
# read strictly (StrictComponents yes) or merely as a list of components
# which *might* be installed of which &os; Update should figure out
# which actually are installed and upgrade those (StrictComponents no)?
# StrictComponents no</programlisting>

      <para>当这个选项设置成 <literal>yes</literal> 时，
          <command>freebsd-update</command> 将假设这个
          <literal>组件 （Components）</literal> 列表是完整的，
          不再尝试修改此列表以外的。 默认情况下，
          <command>freebsd-update</command> 将会尝试更新
          <literal>组件</literal> 列表里的每一个文件。</para>
    </sect2>

    <sect2 xml:id="freebsdupdate-security-patches">
      <title>安全补丁</title>

      <para>&os; 安全补丁可以通过以下命令下载并安装补丁：</para>

      <screen>&prompt.root; <userinput>freebsd-update fetch</userinput>
&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>如果补丁涉及到内核， 那么系统需要重启以应用补丁。 否则，
          则可以将应用补丁的任务可以交给 &man.cron.8; 由其每夜执行
          <command>freebsd-update</command> 更新。
          这可以在 <filename>/etc/crontab</filename> 中添加：</para>

      <programlisting>@daily                                  root    freebsd-update cron</programlisting>

      <para>这条记录说明由 <option>cron</option> 每天运行一次
          <command>freebsd-update</command> 工具。
          使用 <command>freebsd-update</command> 检测是否有可用更新，
          如果有可用更新， 那么它们会被自动下载到本地磁盘，
          但它们不会被自动更新。
          <systemitem class="username">root</systemitem>
          用户将会收到一份需要手动安装更新的电子邮件。</para>

      <para>如果更新出错， 可以使用以下命令让
          <command>freebsd-update</command> 回滚到更新前：</para>

      <screen>&prompt.root; <userinput>freebsd-update rollback</userinput></screen>

      <para>一旦完成更新， 如果内核或任何一个内核模块被修改的话， 就需要重启系统。
          让 &os; 加载新的二进制文件。</para>

      <para>使用 <filename>GENERIC</filename> 内核的情况下，
          <command>freebsd-update</command> 会自行更新内核， 无需用户干涉。
          如果使用的是自定义内核， 则它必须重新编译并安装新内核。
          不过这种情况下， <command>freebsd-update</command>
          依旧会检测是否存在 <filename>GENERIC</filename> 内核，
          如果 <filename>/boot/GENERIC</filename> 存在，
          即使它不是正在运行的系统内核， 也会更新它。</para>

      <note>
          <para>保存一份 <filename>GENERIC</filename> 内核的副本在
              <filename>/boot/GENERIC</filename> 目录中是个明智的选择。
              这可以诊断很多问题，
              以及在 <xref linkend="freebsdupdate-upgrade"/> 中介绍的使用
              <command>freebsd-update</command> 更新系统时会很有用。</para>
      </note>

      <para>除非修改了 <filename>/etc/freebsd-update.conf</filename> 里的默认配置，
          否则， <command>freebsd-update</command> 会更新的内核源代码以及其余部分。
          重新编译并安装自定义内核， 可以按照通常方式进行。</para>

      <note>
          <para>通过 <command>freebsd-update</command>
              分发的补丁并不是每次都会涉及内核更新。
              如果执行 <command>freebsd-update install</command> 时内核源码没有变动，
              就必要重新构建内核了。 不过， 由于 <command>freebsd-update</command>
              每次都会更新 <filename>/usr/src/sys/conf/newvers.sh</filename> 文件，
              补丁版本号 （<command>uname -r</command> 报告的 <literal>-p</literal> 数字）
              就是来自这个文件， 因此， 即使内核没有发生变化，
              重新编译内核也可以让 &man.uname.1; 准确报告补丁版本。
              这在维护多个系统的时候这样会比较有用，
              因为这一信息可以迅速反映判定更新情况。</para>
      </note>
    </sect2>

    <sect2 xml:id="freebsdupdate-upgrade">
      <title>主要和次要版本的升级</title>

      <para>升级 &os; 时， 从一个次要版本升级到另一个次要版本，
          就像 &os;&nbsp;9.0 升级到 &os;&nbsp;9.1 ，
          被称作次要版本升级。
          <emphasis>次要版本</emphasis>升级后已安装的应用程序一般都可以继续工作。</para>

      <para>当 &os; 从一个 <emphasis>主要版本</emphasis> 升级到另一个主要版本时，
          就像 &os;&nbsp;8.X 升级到 &os;&nbsp;9.X ， 这个过程中会删除旧的目标文件和库，
          这将导致绝大部分第三方应用程序无法继续使用，
          所以建议在升级前卸载所有已安装的 ports 软件，
          或者升级完成后使用 <package>ports-mgmt/portmaster</package> 工具，
          强制重装所有已安装应用程序。 输入以下命令重装所有软件：</para>

      <screen>&prompt.root; <userinput>portmaster -af</userinput></screen>

      <para>这将确保所有的第三方应用程序都会被正确的安装。
          请注意将环境变量 <varname>BATCH</varname> 被设置为 <literal>yes</literal> 时，
          整个过程中出现的所有询问， 都会自动应答 <literal>yes</literal> ，
          重建过程将不再需要人工干预。</para>

      <sect3 xml:id="freebsd-update-custom-kernel">
	<title>使用自定义内核的情况</title>

    <para>如果您正在使用一个自定义内核， 那么升级过程会稍微复杂些，
        而且根据使用的 &os; 版本的不同， 可能升级过程也会有些差异。</para>

	<sect4 xml:id="freebsd-update-custom-kernel-8x">
	  <title>&os;&nbsp;8.X 版本的自定义内核</title>

      <para>您需要将一份 <filename>GENERIC</filename> 内核副本放到
          <filename>/boot/GENERIC</filename> 。
          如果系统中没有 <filename>GENERIC</filename> 内核，
          可以通过以下方法获取：</para>

	  <itemizedlist>
	    <listitem>
            <para>如果只编译过一次内核， 则 <filename>/boot/kernel.old</filename>
                中的内核实际上就是 <filename>GENERIC</filename> 内核。
                重命名为 <filename>/boot/GENERIC</filename> 就可以了。</para>
	    </listitem>

	    <listitem>
            <para>如果可以直接接触到物理计算机，
                则可以通过安装介质直接安装 <filename>GENERIC</filename> 内核。
                从安装介质执行以下命令安装：</para>

	      <screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>cd /cdrom/X.Y-RELEASE/kernels</userinput>
&prompt.root; <userinput>./install.sh GENERIC</userinput></screen>

          <para>替换 <filename>X.Y-RELEASE</filename> 为您正使用的版本。
              <filename>GENERIC</filename> 内核默认会被安装到
              <filename>/boot/GENERIC</filename> 目录中。</para>
	    </listitem>

	    <listitem>
            <para>如果以上方法都不可行， 则还可以使用源代码来重新编译和安装
                <filename>GENERIC</filename> 内核：</para>

	      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>env DESTDIR=/boot/GENERIC make kernel __MAKE_CONF=/dev/null SRCCONF=/dev/null</userinput>
&prompt.root; <userinput>mv /boot/GENERIC/boot/kernel/* /boot/GENERIC</userinput>
&prompt.root; <userinput>rm -rf /boot/GENERIC/boot</userinput></screen>

          <para>如果希望 <command>freebsd-update</command> 工具能够正确识别
              <filename>GENERIC</filename> 内核，
              您必须确保没有对 <filename>GENERIC</filename> 内核配置文件进行过任何修改。
              此外， 建议您取消任何其他特殊的编译选项。</para>
	    </listitem>
	  </itemizedlist>

      <para>上述步骤并不需要使用这个
          <filename>GENERIC</filename> 内核来重新引导系统。</para>
	</sect4>

	<sect4 xml:id="freebsd-update-custom-kernel-9x">
	  <title>&os;&nbsp;9.X 或更高版本的自定义内核</title>

	  <itemizedlist>
	    <listitem>
            <para>如果只编译过一次内核， 则 <filename>/boot/kernel.old</filename>
                内核实际上就是 <filename>GENERIC</filename> 内核。
                重命名为 <filename>/boot/kernel</filename> 就可以了。</para>
	    </listitem>

	    <listitem>
            <para>如果可以直接接触到物理计算机，
                则可以通过安装介质直接安装 <filename>GENERIC</filename> 内核。
                从安装介质执行以下命令安装：</para>

	      <screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>cd /cdrom/usr/freebsd-dist</userinput>
&prompt.root; <userinput>tar -C/ -xvf kernel.txz boot/kernel/kernel</userinput></screen>
	    </listitem>

	    <listitem>
            <para>如果以上方法都不可用， 还可以使用源代码来重新编译和安装
                <filename>GENERIC</filename> 内核：</para>

	      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make kernel __MAKE_CONF=/dev/null SRCCONF=/dev/null</userinput></screen>

          <para>如果希望 <command>freebsd-update</command> 工具能够正确识别
              <filename>GENERIC</filename> 内核，
              您必须确保没有对 <filename>GENERIC</filename> 内核配置文件进行过任何修改。
              此外， 建议您取消任何其他特殊的编译选项。</para>
	    </listitem>
	  </itemizedlist>

      <para>上述步骤并不需要使用这个
          <filename>GENERIC</filename> 内核来重新引导系统。</para>
	</sect4>
      </sect3>

      <sect3 xml:id="freebsdupdate-using">
	<title>开始升级</title>

    <para>主要和次要版本都是可以通过在 <command>freebsd-update</command>
        命令后面指定一个正式发行版的参数来升级的，
        以下是一个升级到 &os;&nbsp;9.1 的例子：</para>

	<screen>&prompt.root; <userinput>freebsd-update -r 9.1-RELEASE upgrade</userinput></screen>

    <para>这个命令被执行后， <command>freebsd-update</command>
        工具将会解析配置文件并评估当前的系统， 以获取执行升级所需的必要信息。
        并回显已检测到的和未检测到的组件列表。 例如：</para>

	<screen>Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature for 9.0-RELEASE from update1.FreeBSD.org... done.
Fetching metadata index... done.
Inspecting system... done.

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD do not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable (y/n)? y</screen>

    <para>此时， <command>freebsd-update</command> 工具将会尝试下载所有升级所需文件。
        某些情况下， 用户可能被问及需安装些什么和如何进行之类的问题。</para>

	<para>当使用自定义内核时， 上面的步骤会产生类似下面的警告：</para>

	<screen>WARNING: This system is running a "<replaceable>MYKERNEL</replaceable>" kernel, which is not a
kernel configuration distributed as part of FreeBSD 9.0-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running "/usr/sbin/freebsd-update install"</screen>

    <para>此时， 您可以暂时安全地无视这个警告。 更新的 <filename>GENERIC</filename>
        内核将会在升级过程的中间步骤中使用。</para>

    <para>在下载完成针对本地系统的补丁之后， 这些补丁会被应用到系统上。
        这个过程需要消耗的时间取决于您计算机的性能及负载情况。
        这个过程中将会对配置文件所做的改动进行合并， 文件可能会自动合并，
        也可能在屏幕上显示一个编辑器， 用于手工完成合并操作。
        在处理过程中， 合并成功的结果会显示给用户。 失败或被忽略的合并，
        则会导致这一过程终止。 用户可能会希望保留一份 <filename>/etc</filename> 的备份，
        并在这之后手工合并重要的文件， 例如 <filename>master.passwd</filename> 和
        <filename>group</filename> 文件。</para>

	<note>
        <para>系统至此尚未被修改， 所有的补丁和合并工作都是在另外一个目录中进行的。
            当所有的补丁都被成功的应用上了以后， 所有的配置文件都被合并后，
            一旦这个步骤完成后， 使用以下的命令将升级后的文件安装到磁盘上：</para>

	<screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

	</note>

    <para>内核和内核模块会被首先应用上补丁。 此时， 您必须重新启动计算机。
        如果您使用的是自定义内核， 请使用 &man.nextboot.8; 命令临时指定下一次引导使用
        <filename>/boot/GENERIC</filename> 内核：</para>

	<screen>&prompt.root; <userinput>nextboot -k GENERIC</userinput></screen>

	<warning>
        <para>在使用 <filename>GENERIC</filename> 内核启动前，
            请确保它包含了用于引导系统所需的全部驱动程序
            （ 如果您是远程进行升级操作， 还应确保网卡驱动也是存在的 ）。
            需要特别注意的是，
            如果之前的内核中静态编译了通常以内核模块形式存在的驱动程序，
            则一定要通过 <filename>/boot/loader.conf</filename> 机制来将这些模块加载到
            <filename>GENERIC</filename> 内核上。
            此外， 通常建议您您临时禁用不太重要的服务、 磁盘和网络挂载服务等等，
            直至升级过程完成。</para>
	</warning>

	<para>现在可以重启更新内核了：</para>

	<screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>

    <para>在系统重新上线后， 需要再次运行 <command>freebsd-update</command> 工具。
        这会删除所有旧的共享库和目标文件， 但是升级状态会被保存，
        这样再次运行 <command>freebsd-update</command> 工具就不需要重头开始了。</para>

	<screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

	<note>
	  <para>取决于是否有库版本更新， 通常只有 2 个而不是 3 个安装阶段。</para>
	</note>
      </sect3>

      <sect3 xml:id="freebsdupdate-portsrebuild">
	<title>主要版本升级完成后重建 Ports 应用程序</title>

    <para>一个主要版本升级完成后， 所有的第三方软件都应该被重新编译和安装。
        这是因为已安装的软件可能依赖于已在升级过程中被删除的库。
        这个重建过程可以使用 <package>ports-mgmt/portmaster</package>
        工具自动化实现：</para>

	<screen>&prompt.root; <userinput>portmaster -f</userinput></screen>

    <para>一旦完成这个步骤， 再最后一次运行 <command>freebsd-update</command>
        工具来结束升级过程。 执行以下命令处理升级中的所有细节：</para>

	<screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

    <para>如果您使用临时的 <filename>GENERIC</filename> 内核来引导系统的，
        那么现在可以按照通常方法重新编译并安装新自定义内核了。</para>

	<para>重新启动计算机进入新版本的 &os; ， 至此升级过程全部完成。</para>
      </sect3>
    </sect2>

    <sect2 xml:id="freebsdupdate-system-comparison">
      <title>系统状态对照</title>

      <para><command>freebsd-update</command>
          工具也可被用来对照当前系统与一个已知完好的 &os; 拷贝的差异。
          这个工具可以评估的系统工具， 库和配置文件。 使用以下的命令开始对照：</para>

      <screen>&prompt.root; <userinput>freebsd-update IDS &gt;&gt; outfile.ids</userinput></screen>

      <warning>
          <para>这个命令的名称是 <acronym>IDS</acronym> ，
              它并不能代替真正的入侵检测系统 （如： <package>security/snort</package>） ，
              因为 <command>freebsd-update</command> 工具的数据存储在磁盘上，
              很显然它们有被篡改的可能。 当然也可以使用一些方法来降低被篡改的可能性，
              比如设置 <varname>kern.securelevel</varname>
              和不使用时将 <command>freebsd-update</command>
              工具的数据存储在只读文件系统上，
              例如 <acronym>DVD</acronym> 或安全的外置 <acronym>USB</acronym>
              磁盘上。</para>
      </warning>

      <para>系统会立即开始检测， 并生成一份包含了文件和它们的 &man.sha256.1;
          哈希值的清单， 已知发行版中的值与当前系统中安装的值将会被输出送到
          <filename>outfile.ids</filename> 文件中。</para>

<para>这个文件行数非常冗长， 但输出的格式很清晰。 举例来说，
    要获得一份与发行版中不同哈希值的文件列表， 可使用以下命令获得：</para>

      <screen>&prompt.root; <userinput>cat outfile.ids | awk '{ print $1 }' | more</userinput>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</screen>

      <para>这份输出时删节缩短后的， 其实是有更多的文件。 其中有些文件并非人为修改，
          比如 <filename>/etc/passwd</filename> 被修改可能是系统添加了新用户。
          在某些情况下， 还有另外的一些文件， 诸如内核模块与
          <command>freebsd-update</command> 数据不同是因为它们被更新过了。
          为了将指定的文件或目录排除在外， 可以把它们加到
          <filename>/etc/freebsd-update.conf</filename> 中的
          <literal>IDSIgnorePaths</literal> 参数中。</para>

<para>除了前面讨论过的部分之外， 这也能被当作是对升级方法的一种详细补充。</para>
    </sect2>
  </sect1>

  <sect1 xml:id="updating-upgrading-portsnap">
      <info><title>Portsnap： 一个 Ports Collection 更新工具</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>原著： </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Colin</firstname><surname>Percival</surname></personname><contrib>Based on notes provided by </contrib></author>
      </authorgroup>
    </info>
    

    <indexterm><primary>Updating and Upgrading</primary></indexterm>
    <indexterm>
      <primary>Portsnap</primary>
      <see>Updating and Upgrading</see>
    </indexterm>

    <para>&os; 基本系统包含了一个名叫 &man.portsnap.8; 的用于更新
        Ports Collection 的实用程序。 启动后会自动连接到 &os; 服务器，
        接着校验安全密钥， 然后下载一份 Ports Collection 最新副本。
        并使用密钥校验机制保证所下载的文件的完整性。
        要下载最新 Ports Collection ， 使用以下命令：</para>

    <screen>&prompt.root; <userinput>portsnap fetch</userinput>
Looking up portsnap.FreeBSD.org mirrors... 9 mirrors found.
Fetching snapshot tag from geodns-1.portsnap.freebsd.org... done.
Fetching snapshot metadata... done.
Updating from Tue May 22 02:12:15 CEST 2012 to Wed May 23 16:28:31 CEST 2012.
Fetching 3 metadata patches.. done.
Applying metadata patches... done.
Fetching 3 metadata files... done.
Fetching 90 patches.....10....20....30....40....50....60....70....80....90. done.
Applying patches... done.
Fetching 133 new ports or files... done.</screen>

    <para>这个例子显示 &man.portsnap.8; 工具发现并校验了几个用于当前 ports 的补丁。
        这说明之前运行过， 如果是第一次运行， 那么仅仅只会下载 Ports Collection 。</para>

    <para>在 &man.portsnap.8; 工具成功完成一次 <command>fetch</command> 操作后，
        将会校验本地的 Ports Collection 和后续补丁。
        首次执行 <command>portsnap</command> 命令， 需要使用 <literal>extract</literal>
        参数释放下载的文件。</para>

    <screen>&prompt.root; <userinput>portsnap extract</userinput>
/usr/ports/.cvsignore
/usr/ports/CHANGES
/usr/ports/COPYRIGHT
/usr/ports/GIDs
/usr/ports/KNOBS
/usr/ports/LEGAL
/usr/ports/MOVED
/usr/ports/Makefile
/usr/ports/Mk/bsd.apache.mk
/usr/ports/Mk/bsd.autotools.mk
/usr/ports/Mk/bsd.cmake.mk
<replaceable>...</replaceable></screen>

    <para>需要更新已安装的 Ports Collection 时，
        使用 <command>portsnap update</command> 来更新：</para>

    <screen>&prompt.root; <userinput>portsnap update</userinput></screen>

    <para>至此更新完成， 可以使用 Ports Collection 来安装或升级应用程序了。</para>

    <para><literal>fetch</literal> 和 <literal>extract</literal> 或 <literal>update</literal>
        可以合并执行， 例如：</para>

    <screen>&prompt.root; <userinput>portsnap fetch update</userinput></screen>

    <para>这个命令将会下载最新版 Ports Collection 快照并更新位于
        <filename>/usr/ports</filename> 目录的本地副本。</para>
  </sect1>

  <sect1 xml:id="updating-upgrading-documentation">
    <title>更新系统附带的文档</title>

    <indexterm><primary>Updating and Upgrading</primary></indexterm>

    <indexterm>
      <primary>Documentation</primary>
      <see>Updating and Upgrading</see>
    </indexterm>

    <para>文档是 &os; 操作系统的组成部分。 最新的 &os; 文档总是可以通过访问
        <link xlink:href="http://www.freebsd.org/doc/">&os; 网站</link> 获得，
        有些用户的网络可能很慢， 甚至完全没有网络。 则可以通过很多方法可以更新
        &os; 文档的本地副本。</para>

    <sect2 xml:id="dsvn-doc">
        <title>使用 <application>Subversion</application> 来更新文档</title>

        <para>&os; 文档的源代码可以使用 <application>svn</application> 工具获得。
            本节将介绍如何：</para>

      <itemizedlist>
	<listitem>
        <para>安装文档工具链， 用于编译 &os; 文档源代码所需的工具。</para>
	</listitem>

	<listitem>
        <para>使用 <application>svn</application> 工具下载文档源码到
            <filename>/usr/doc</filename> 目录中。</para>
	</listitem>

	<listitem>
        <para>从源代码编译 &os; 文档， 并安装到
            <filename>/usr/share/doc</filename> 目录。</para>
	</listitem>

	<listitem>
        <para>认识一些由文档生成系统所提供的编译选项，
            比如选择生成指定语言的部分文档， 或者输出指定格式。</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2 xml:id="installing-documentation-toolchain">
      <title>安装 <application>svn</application> 工具和文档工具链</title>

      <para>从源代码编译 &os; 文档需要的工具， 并不是 &os; 基本系统的组成部分，
          因为这些工具需要大量的磁盘空间， 并且并不是对所有 &os; 用户都需要，
          它们只对那些活跃撰写 &os; 新文档或经常从源代码更新文档的用户有用。</para>

      <para>所需要的工具， 包括 <application>svn</application> 工具，
          都可以在 &os; 文档计划维护的 <package>textproc/docproj</package>
          主 port 处安装。</para>

      <note>
          <para>如果没有输出 &postscript; 或 PDF 文档的需求， 可以考虑安装
              <package>textproc/docproj-nojadetex</package> 这个 port 。
              这套文档工具链包含了除 <application>teTeX</application>
              排版引擎外的所有工具。 <application>teTeX</application>
              是一个很庞大的工具集， 因此如果没有 PDF 输出需求的话，
              忽略它将是一个很明智的选择。</para>
      </note>
    </sect2>

    <sect2 xml:id="updating-documentation-sources">
      <title>更新文档源代码</title>

      <para>以下示例， 使用 <application>svn</application> 工具通过 HTTPS 协议，
          从美国西部镜像获取文档源代码的原始副本：</para>

      <screen>&prompt.root; <userinput>svn checkout https://svn0.us-west.FreeBSD.org/doc/head /usr/doc</userinput></screen>

      <para>从现有的镜像站里就近选择
          <link linkend="svn-mirrors">Subversion 镜像站</link> 。</para>

      <para>初始下载文档源代码可能需要一些时间， 请您耐心等待直到它完成。</para>

      <para>文档后续更新可以通过运行以下命令完成：</para>

      <screen>&prompt.root; <userinput>svn update /usr/doc</userinput></screen>

      <para>初始签出源代码后， 提供了另一种由 <filename>/usr/doc/Makefile</filename>
          提供的更新方法， 通过运行以下命令更新：</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make update</userinput></screen>
    </sect2>

    <sect2 xml:id="updating-documentation-options">
      <title>文档源代码中可调整的选项</title>

      <para>&os; 文档的更新和编译系统支持一些方便只更新一部分文档，
          或只编译特定格式及译文的选项。 这些选项可以在
          <filename>/etc/make.conf</filename> 文件中配置， 也可以通过使用
          &man.make.1; 命令行参数指定。</para>

      <para>这些选项包括：</para>

      <variablelist>
	<varlistentry>
	  <term><varname>DOC_LANG</varname></term>

	  <listitem>
          <para>准备编译和安装的语言列表。 例如， 指定
              <literal>en_US.ISO8859-1</literal> 时， 表示仅编译英文版的文档。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>FORMATS</varname></term>

	  <listitem>
          <para>准备输出的格式列表。 目前， 系统支持
              <literal>html</literal> 、 <literal>html-split</literal> 、
              <literal>txt</literal> 、 <literal>ps</literal> 、
              <literal>pdf</literal> 和 <literal>rtf</literal> 格式。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>DOCDIR</varname></term>

	  <listitem>
          <para>准备安装文档的目录。 默认为
              <filename>/usr/share/doc</filename> 目录。</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>了解 &os; 其他可供配置的全局 <command>make</command> 变量，
          请参阅 &man.make.conf.5; 。</para>

      <para>有关 &os; 文档构建系统更多支持的变量，
          请参阅 <link xlink:href="&url.doc.langbase;/books/fdp-primer">&os;
              文档计划入门之新手必读</link> 。</para>
    </sect2>

    <sect2 xml:id="updating-installed-documentation">
      <title>从源代码安装 &os; 文档</title>

      <para>在 <filename>/usr/doc</filename> 目录中下载好最新的文档快照后，
          就可以开始编译文档了。</para>

      <para>要更新 <varname>DOC_LANG</varname> 中指定的所有语言文档，
          可以执行以下命令：</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>如果只有某个特定语言的文档需要更新， 则可以切换到
          <filename>/usr/doc</filename> 目录中的对应子目录执行 &man.make.1; 更新：</para>

      <screen>&prompt.root; <userinput>cd /usr/doc/en_US.ISO8859-1</userinput>
&prompt.root; <userinput>make update install clean</userinput></screen>

      <para>如果需要指定输出格式， 则可以添加 <varname>FORMATS</varname> 参数：</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make FORMATS='html html-split' install clean</userinput></screen>

      <para>有关编辑和提交更正文档的信息， 请参阅
          <link xlink:href="&url.books.fdp-primer;">&os;
              文档计划入门之新手必读</link> 。</para>
    </sect2>

    <sect2 xml:id="doc-ports">
      <info><title>使用 Ports 更新文档</title>
	<authorgroup>
	  <author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Based on the work of </contrib></author>
	</authorgroup>
      </info>

      

      <indexterm><primary>Updating and Upgrading</primary></indexterm>

      <indexterm>
	<primary>documentation package</primary>
	<see>Updating and Upgrading</see>
      </indexterm>

      <para>上一节介绍从源代码更新 &os; 文档的方法。
          基于源代码的更新的方法可能并不是对于所有的 &os; 系统都可行有效。
          从源代码构建， 需要建立<emphasis>文档工具链</emphasis> ，
          熟悉 <application>svn</application> 工具和会从仓库检出源代码，
          还有一些编译已检出代码的手工步骤。
          本节介绍另一种使用 Ports Collection 来更新已安装文档的方法。</para>

      <itemizedlist>
	<listitem>
        <para>下载并安装预编译文档快照， 这将无需在本地编译任何部份，
            或安装文档工具链。</para>
	</listitem>

	<listitem>
        <para>下载文档源代码， 并通过 ports 框架构建它们，
            这将使得检出和编译的步骤更简易。</para>
	</listitem>
      </itemizedlist>

      <para>以上两种更新 &os; 文档的方法都是由 &a.doceng; 每月更新维护的
          <emphasis>文档 ports</emphasis> 所提供支持的。
          它们都位于 &os; Ports&nbsp;Collection 的
          <link xlink:href="http://www.freshports.org/docs/">docs</link> 目录下。</para>

      <sect3 xml:id="doc-ports-install-make">
	<title>编译和安装文档 Ports</title>

    <para>文档 ports 使用 ports 的构建框架使得文档的编译变得更加容易。
        它能自动获取文档源代码， 并配合适当的环境设置和 &man.make.1; 命令行选项，
        它使得安装和卸载文档变得像 &os; 其他 port 或预编译包一样容易。</para>

	<note>
        <para>当在本地编译文档 ports 时， <emphasis>文档工具链</emphasis> ports
            会被列为依赖关系， 而被自动安装。</para>
	</note>

	<para>文档 ports 组织形式如下：</para>

	<itemizedlist>
	  <listitem>
          <para>第一种是 <quote>主 port</quote> ，
              位于 <package>misc/freebsd-doc-en</package> 下，
              即安装所有英文文档的 ports 。</para>
	  </listitem>

	  <listitem>
          <para>另外一种是 <quote>文档 port 合集</quote> ，
              位于 <package>misc/freebsd-doc-all</package> 下，
              这将会构建并安装所有可用语言的文档。</para>
	  </listitem>

	  <listitem>
          <para>最后一种是各种翻译版本的 <quote>从 port</quote> ，
              比如： <package>misc/freebsd-doc-hu</package> 就是匈牙利文版的文档。</para>
	  </listitem>
	</itemizedlist>

    <para>以下示例将会安装与
        <uri xlink:href="http://www.FreeBSD.org">http://www.FreeBSD.org</uri>
        格式相同的， 使用的分章节的 <acronym>HTML</acronym> 英文文档到
        <filename>/usr/local/share/doc/freebsd</filename> 目录中，
        通过 port 安装使用：</para>

	<screen>&prompt.root; <userinput>cd /usr/ports/misc/freebsd-doc-en</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

	<sect4 xml:id="doc-ports-options">
	  <title>常见的调整选项</title>

      <para>有许多选项可以用来调整文档 ports 默认行为， 它们包括：</para>

	  <variablelist>
	    <varlistentry>
	      <term><varname>WITH_HTML</varname></term>

	      <listitem>
              <para>用于构建单一文件的 HTML 格式文档。 文档名视情况而定通常会保存为
                  <filename>article.html</filename> 或
                  <filename>book.html</filename> ， 另外会附带一些图片文件。</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><varname>WITH_PDF</varname></term>

	      <listitem>
              <para>用于构建 &adobe; 可移植文档格式 （ PDF ）文档。
                  该格式的文档文件名视情况而定通常为
                  <filename>article.pdf</filename> 或
                  <filename>book.pdf</filename> 。</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><varname>DOCBASE</varname></term>

	      <listitem>
              <para>用于指定文档安装目录。 默认为
                  <filename>/usr/local/share/doc/freebsd</filename> 目录。</para>

		<note>
            <para>默认安装目录与 <application>svn</application> 方式的默认安装目录不同。
                这是因为通常 ports 应用会被安装到 <filename>/usr/local</filename>
                目录中。 这可以通过 <varname>PREFIX</varname>
                环境变量来覆盖默认值。</para>
		</note>
	      </listitem>
	    </varlistentry>
	  </variablelist>

      <para>以下使用此变量来安装匈牙利文版文档的 PDF 格式：</para>

	  <screen>&prompt.root; cd /usr/ports/misc/freebsd-doc-hu
&prompt.root; make -DWITH_PDF DOCBASE=share/doc/freebsd/hu install clean</screen>
	</sect4>
      </sect3>

      <sect3 xml:id="doc-ports-install-package">
	<title>使用文档预编译包</title>

    <para>正如前文所述， 通过 ports 从源代码编译生成文档，
        需要在本地安装文档工具链并需要一些编译所需的磁盘空闲空间。
        当资源不足以安装文档工具链或从源代码编译需要磁盘空闲空间时，
        我们仍可以通过 ports 预先编译的文档快照版本安装。</para>

    <para>&a.doceng; 每个月都会制作 &os; 文档的快照版本的预编译包。
        这些预编译包可以通过包管理工具进行管理， 比如 &man.pkg.add.1; ，
        &man.pkg.delete.1; 等等。</para>

	<note>
        <para>当使用预编译包时， 将会安装指定语言相关的
            <emphasis>所有</emphasis> 可用的 &os; 文档。</para>
	</note>

    <para>例如， 以下命令将安装匈牙利文最新版预编译文档包：</para>

	<screen>&prompt.root; <userinput>pkg_add -r hu-freebsd-doc</userinput></screen>

	<note>
        <para>预编译包使用与对于 ports 不同的命名规则：
            <literal>lang-freebsd-doc</literal> 。
            这里的 <replaceable>lang</replaceable> 是语言代码的简短形式，
            比如 <literal>hu</literal> 表示匈牙利文，
            <literal>zh_cn</literal> 表示简体中文。</para>
	</note>
      </sect3>

      <sect3 xml:id="doc-ports-update">
	<title>更新文档 Ports</title>

    <para>文档 ports 可以通过任何可以更新 port 的工具更新。
        例如， 使用 <package>ports-mgmt/portmaster</package>
        工具通过预编译包方式更新匈牙利文预编译包：</para>

	<screen>&prompt.root; <userinput>portmaster -PP hu-freebsd-doc</userinput></screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="current-stable">
    <title>追踪开发分支</title>

    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>&os; 有两个开发分支: &os.current; 和 &os.stable; 。
        本节将简介它们， 并介绍如何让它们保持最新。
        我们将先讨论 &os.current; ， 然后再是 &os.stable; 。</para>

    <sect2 xml:id="current">
      <title>使用最新的 &os; CURRENT</title>

      <para>&os.current; 是 &os; 的开发的 <quote>最前沿</quote> 。
          &os.current; 用户需要有较高的技术能力， 并应具有自己解决复杂系统问题的能力。
          如果您是 &os; 新手， 推荐使用 &os.stable; 。</para>

      <sect3>
	<title>什么是 &os.current; ？</title>

	<indexterm><primary>snapshot</primary></indexterm>

    <para>&os.current; 是由 &os; 的最新源代码构建的。
        包含了可能出现或也可能不出现在下一个正式发行版里的仍在开发阶段、
        实验性质的修改， 过渡性机制。 尽管每天都有许多 &os; 开发者编译
        &os.current; 源代码， 但有时这些代码仍有可能不能通过编译。
        虽然这些问题通常很快会得到解决， 但 &os.current; 带来的是破坏或功能改善，
        这很可能完全取决于您获取源代码的时机。</para>
        </sect3>

      <sect3>
	<title>谁需要 &os.current; ？</title>

	<para>&os.current; 主要适合以下三类人：</para>

	<orderedlist>
	  <listitem>
          <para>&os; 社区成员： 积极工作在源代码树的某部分的人和视保持
              <quote>最新</quote> 版本为绝对需求的人。</para>
	  </listitem>

	  <listitem>
          <para>&os; 社区成员： 愿花时间去解决问题， 促使 &os.current;
              保持尽可能的稳定的。 以及提出有关 &os;
              改进和建设性建议的并提供补丁实现它们的人。</para>
	  </listitem>

	  <listitem>
          <para>只是关注或参考目的的人。 这些人也偶尔做做注释或贡献代码。</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>&os.current; <emphasis>不能</emphasis> 什么？</title>

	<orderedlist>
	  <listitem>
          <para>追求新功能， 获得下一个正式发行版的新功能。
              预发行功能还没有经过完整测试， 最有可能包含 bug 。</para>
	  </listitem>

	  <listitem>
	    <para>快速修复 bug 。因为在修复 bug 的同时又可能产生新的 bug 。</para>
	  </listitem>

	  <listitem>
	    <para>无所不在的 <quote>官方支持</quote> 。</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>使用 &os.current;</title>

	<indexterm>
	  <primary>-CURRENT</primary>
	  <secondary>using</secondary>
	</indexterm>
	<orderedlist>
	  <listitem>
	    <para>订阅 &a.current.name; 和 &a.svn-src-head.name; 邮件列表。
            这不仅仅是建议， 而是 <emphasis>必须</emphasis> 的。
            以便用户了解当前系统状态，
            并接收可能对系统的持续健康运行有至关重要影响的公告信息。</para>

        <para>&a.svn-src-head.name; 邮件列表允许您查看每个变化的提交记录，
            因为这些提交记录记录了变更内容以及可能的产生的副作用的相关信息。</para>

        <para>需要订阅这些邮件列表， 请访问 &a.mailman.lists.link; ，
            并点击您想订阅的项目。 并按照说明进行操作。
            为了跟踪整个源代码树的变更信息， 可以订阅 &a.svn-src-all.name;
            邮件列表。</para>
	  </listitem>

	  <listitem>
          <para>选择以下一种方式从 &os; <link linkend="mirrors">镜像站</link>
              获取源代码：</para>

	    <orderedlist>
	      <listitem>
		<para>使用 <link linkend="svn">svn</link><indexterm>
		      <primary>Subversion</primary>
		  </indexterm>
		  <indexterm>
		    <primary>-CURRENT</primary>
		    <secondary>Syncing with
		      <application>Subversion</application></secondary>
		  </indexterm>
          签出所需的开发版或正式发行版分支的源代码。 它是访问 &os; 开发库的首选方式。
          -CURRENT 分支源代码可以选择一个
          <link linkend="svn-mirrors">Subversion 镜像站</link> 的
          <literal>head</literal> 分支检出。 受仓库大小影响， 推荐仅检出子分支树。</para>
	      </listitem>

	      <listitem>
		<para>使用 <application>CTM</application><indexterm>
		    <primary>-CURRENT</primary>
		    <secondary>Syncing with CTM</secondary>
        </indexterm> 工具。 如果您的网络性能不好， 如高价网络连接或只能通过电子邮件获取，
        那么 <application>CTM</application> 将是一个很好的选择。
        但它没有 <application>Subversion</application> 可靠。 因此，
        <application>Subversion</application>
        依旧是所有已接入互联网的系统获取源代码首选方式。</para>
	      </listitem>
	    </orderedlist>
	  </listitem>

	  <listitem>
          <para>如果您获取源码是用于运行， 而不只是阅读，
              那么就应该获取 <emphasis>完整</emphasis> &os.current; 源代码，
              而不是获取一部分。 源代码的各个部分会依赖于其他部分，
              如果您仅试着编译其中一部分的话， 那么几乎可以肯定是会出问题的。</para>

	    <para>在编译 &os.current;<indexterm>
		<primary>-CURRENT</primary>
		<secondary>compiling</secondary>
    </indexterm> 之前， 请仔细阅读 <filename>/usr/src/Makefile</filename> 文件。
    作为的升级过程的一部分， 您至少也要首先了解 <link linkend="makeworld">
        安装一个新的内核和重新编译 world</link> 。
    此外， 还必须多多阅读 &a.current; 以及 <filename>/usr/src/UPDATING</filename> ，
    这样才能知道目前的进度以及下一版本会有什么新的进展。</para>
	  </listitem>

	  <listitem>
          <para>热心一点！ 如果您正运行着 &os.current; ，
              我们很希望知道您关于它的一些想法，
              尤其是关于 bug 修复或增进的建议。 非常欢迎附带补丁的建议！</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>

    <sect2 xml:id="stable">
      <title>使用最新的 &os; Stable</title>

      <sect3>
	<title>什么是 &os.stable; ？</title>

	<indexterm><primary>-STABLE</primary></indexterm>

    <para>&os.stable; 是我们的开发分支， 我们的正式发行版就由此发展而来。
        这个分支会以不同速度变化， 并且假定这些是第一次进入 &os.current; 进行测试。
        然而， 这 <emphasis>仍然</emphasis> 是个开发分支， 意味着在一定的时候，
        &os.stable; 源代码可能或不可能满足一些特殊的要求。
        它只不过是另一个工程发展途径， 并不是终端用户的资源。</para>
      </sect3>

      <sect3>
	<title>谁需要 &os.stable; ？</title>

    <para>如果您有兴趣追随 FreeBSD 的开发过程或为其做点贡献，
        尤其是和下一个 <quote>非计划</quote> 的 FreeBSD 发行版有关时，
        您应该考虑使用 &os.stable; 。</para>

    <para>尽管安全更新也会进入 &os.stable; 分支，
        但您并不需要因此 <emphasis>必须</emphasis>  使用 &os.stable; 。
        每一个 &os; 安全公告都会介绍如何修复受此问题影响的尚未停止支持的正式发行版上的问题

	  <footnote>
          <para>更多有关当前旧 FreeBSD 正式发行版的支持策略，
              请参阅 <link xlink:href="&url.base;/security/">
                  http://www.FreeBSD.org/security/</link> 。</para></footnote> 。</para>

  <para>尽管我们尽力确保 &os.stable; 分支能在任何时候都能正确编译和运行，
      但没人可以保证它永远不出问题。 此外， 代码进入 &os.stable; 之前都会经过
      &os.current; 的测试， 但 &os.current; 用户总是比 &os.stable; 用户少些。
      有些 &os.current; 上并没有暴露出来的问题可能在经过 &os.stable;
      测试的过程中才暴露出来。</para>

  <para>基于这些原因，我们 <emphasis>不推荐</emphasis> 您盲目追随 &os.stable; ，
      在尚未进行完整的开发或测试之前， 千万不能将生产服务器更新至 &os.stable; 。</para>

  <para>如果您没有更多时间和精力的话， 那推荐您使用最新的 FreeBSD 正式发行版，
      并使用二进制更新机制来完成版本间的升级与迁移。</para>
      </sect3>

      <sect3>
	<title>使用 &os.stable;</title>

	<indexterm>
	  <primary>-STABLE</primary>
	  <secondary>using</secondary>
	</indexterm>
	<orderedlist>
	  <listitem>
          <para>订阅 &a.stable.name; 邮件列表。 他可以让您随时了解 &os.stable;
              的软件编译依赖以及其他需要特别注意的问题。 对于那些有争议的修复或更新，
              开发者就会在这个邮件列表里发表声明， 听取用户意见。</para>

          <para>订阅您所关心的分支的 <application>svn</application> 提交日志。
              比如您关心 9-STABLE 分支，
              可以订阅 &a.svn-src-stable-9.name; 这个邮件列表。
              这个邮件列表会记录每一个提交日志信息， 包括变更原因，
              及可能出现的问题等等。</para>

          <para>需要订阅这些邮件列表， 请访问 &a.mailman.lists.link; ，
              并点击您想订阅的项目。 并按照说明进行操作。
              为了跟踪整个源代码树的变更信息，
              可以订阅 &a.svn-src-all.name; 邮件列表。</para>
	  </listitem>

	  <listitem>
          <para>如果您需要全新安装一个 &os.stable; 每月编译快照版本，
              请参阅 <link xlink:href="&url.base;/snapshots/">快照</link> 页面，
              以了解更多信息。 另外您也可以从 &os.stable; 发行版的
              <link linkend="mirrors">镜像站</link> 安装最新版本，
              并按照其中的说明更新 &os.stable; 源代码。</para>

          <para>有几种方法可以通过 &os; <link linkend="mirrors">镜像站</link>
              将系统升级为最新版 &os; ：</para>

	    <orderedlist>
	      <listitem>
		<para>使用 <link linkend="svn">svn</link><indexterm>
		    <primary>Subversion</primary>

        </indexterm>签出所需的开发版或正式发行版分支的源代码。
        它是访问 &os; 开发库的首选种方法。
        最新开发版分支使用 <literal>head</literal> 分支名，
        其他版本形式请参考 <link xlink:href="&url.base;/releng/">项目发布页面</link> 。
        主要形式有： <literal>stable/9</literal><indexterm>
		    <primary>-STABLE</primary>
		    <secondary>syncing with
		      <application>Subversion</application></secondary>
		  </indexterm>
          或 <literal>releng/9.2</literal> 等。
          可用的 URL 地址可以在 <application>Subversion</application>
          可用的基本系统 <link linkend="svn-mirrors">Subversion 镜像站</link> 上找到。
          受仓库大小影响， 推荐仅检出子分支树。</para>
	      </listitem>

	      <listitem>
		<para>考虑使用 <application>CTM</application><indexterm>
		    <primary>-STABLE</primary>
		    <secondary>syncing with CTM</secondary>
		  </indexterm> 如果您的没有快速互联网网络。</para>
	      </listitem>
	    </orderedlist>
	  </listitem>

	  <listitem>
	    <para>在编译 &os.stable;<indexterm>
		<primary>-STABLE</primary>
		<secondary>compiling</secondary>
    </indexterm> 之前， 请仔细阅读 <filename>/usr/src/Makefile</filename> 文件。
    作为的升级过程的一部分， 您至少也要首先了解 <link linkend="makeworld">
        安装一个新的内核和重新编译 world</link> 。
    此外， 还必须多多阅读 &a.current; 以及 <filename>/usr/src/UPDATING</filename> ，
    这样才能知道目前的进度以及下一版本会有什么新的进展。</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="synching">
    <title>同步源代码</title>

    <para>您可以通过互联网或电子邮件与 &os; 项目的部分源代码 （或全部源代码）
        保持同步， 这取决与您的需求。 我们主要提供
        <link linkend="svn">Subversion</link> 和 <link linkend="ctm">CTM</link>
        这两种源代码同步服务。</para>

    <warning>
        <para>虽然支持仅更新部分源代码树， 但唯一官方支持的更新过程是更新整个源代码树，
            并重新编译所有在用户空间运行的程序， （如在 <filename>/bin</filename> 和
            <filename>/sbin</filename> 目录下的程序） 和内核源码。
            如果仅更新部分代码树、 仅内核，
            或仅更新用户空间运行的程序源代码往往会导致问题， 比如： 编译出错、
            内核崩溃和数据损坏等。</para>
    </warning>

    <indexterm>
      <primary>Subversion</primary>
    </indexterm>

    <para><application>Subversion</application> 采用 <emphasis>pull</emphasis>
        方式来更新源代码。 用户或 <command>cron</command> 脚本，
        调用 <command>svn</command> 程序来更新源代码。
        （ <application>Subversion</application> 方式是更新本地源代码树的首选方式。）
        它们都是由服务器动态生成的都是最新的数据， 由用户控制何时下载更新。</para>

    <indexterm>
      <primary><application>CTM</application></primary>
    </indexterm>
    <para><application>CTM</application>
        不能通过交互方式的对比主归档服务器与本地源代码的差异并主动的获取源代码。
        相反的， 会有一个脚本专门用来识别变更过的档案，
        这个脚本由 CTM 服务器每天数次执行。 它将会自上次运行以来的变更档案加以压缩，
        并分配一个序列号， 然后对电子邮件采用可打印的 ASCII 编码进行编码后发送出去。
        当您接收到这些 <quote>CTM deltas</quote> 档案的时候， 将会交由
        &man.ctm.rmail.1; 程序自动进行解压， 校验和应用这些变更。 这种方式比
        <application>Subversion</application> 方式更有效， 并且因为它采用了
        <emphasis>push</emphasis> 方式， 而不是 <emphasis>pull</emphasis> 方式，
        可以有效减轻服务器压力。</para>

    <para>当然， 还有个问题是需要注意的。 如果您不小心破坏了本地存档的某部分，
        <application>Subversion</application> 会检测并重建被破坏的部分。
        而 <application>CTM</application> 并不会为您做这些事情。
        如果您删除了代码树的某一部分而没有事前备份， 那么您将不得不从头开始，
        使用最近的 CTM <quote>base delta</quote> ， 并使用
        <application>CTM</application> 重建它。</para>
  </sect1>

  <sect1 xml:id="makeworld">
    <title>重新编译 <quote>world</quote></title>

    <indexterm>
      <primary>Rebuilding <quote>world</quote></primary>
    </indexterm>
    <para>一旦 &os; 特定版本（如： &os.stable; 或 &os.current;）的本地源代码树完成同步，
        就可以使用这些源代码树重新编译系统。</para>

    <warning>
      <title>做好备份</title>

      <para>无需强调操作 <emphasis>之前</emphasis> 应进行备份的重要性，
          尽管重新编译系统是一件简单的事情，
          但难免会有一些出现在源代码里的问题而导致系统无法正常运行的情况。</para>

      <para>创建并校验备份， 并制作一个可引导的安装介质。 您可能永远不会用到它，
          但安全第一嘛！</para>
    </warning>

    <warning>
      <title>订阅相关邮件列表</title>

      <indexterm><primary>mailing list</primary></indexterm>
      <para>&os.stable; 和 &os.current; 分支， 从实质上都属于
          <emphasis>开发阶段</emphasis> 。 为 &os; 贡献者也都是人， 难免会犯错。</para>

      <para>这些错误可能没什么危害， 只会让系统生成新的错误警告。 也可能是灾难性的，
          可能导致系统无法启动或破坏文件系统。</para>

      <para>当问题发生时， 发送一封 <quote>注意 （heads up）</quote>
          开头的邮件到相关邮件列表， 并描述问题， 并写上受影响的系统。
          当问题解决以后再发送一封 <quote>已解决 （all clear）</quote>
          开头的声明邮件。</para>

      <para>如果使用 &os.stable; 或 &os.current; 而又不订阅 &a.stable; 或
          &a.current; 的用户， 那么完全是自找麻烦。</para>
    </warning>

    <warning>
      <title>不要使用 <command>make world</command> 命令</title>

      <para>一些比较早期的文档推荐使用 <command>make world</command> 命令完成这项工作。
          然而， 这个命令会跳过很多重要的步骤，
          建议只有在您知道自己在做什么的时候才这样做。 绝大部分情况下，
          请不要胡乱使用 <command>make world</command> 命令，
          您应该使用以下介绍的方式。</para>
    </warning>

    <sect2 xml:id="canonical-build">
      <title>更新系统的标准方法</title>

      <para>更新系统之前， 请先阅读 <filename>/usr/src/UPDATING</filename> 文件，
          以便了解重新编译 world 之前需要了解哪些事情或注意事项，
          然后再执行以下步骤。</para>

      <para>这里假定从一个包含旧编译器、 旧内核、旧 world 和旧配置文件的较早 &os;
          版本上的升级步骤。 <quote>World</quote> 包含了核心系统二进制文件，
          库和程序文件。 编译器是 <quote>world</quote> 的一部分，
          但也有一些需要特别注意的问题。</para>

      <para>此外， 我们还假定您已获得最新版本的源代码。 如果你还没来得及更新源代码，
          请参照 <xref linkend="synching"/> 获取同步到最新版本的详细帮助。</para>

      <para>从源代码更新系统的步骤有时会比初看上去更麻烦一些， 另一方面，
          &os; 开发者有时又不得不修改推荐更新步骤， 特别是当出现无法避免的依赖关系的时候。
          本节余下部分将介绍目前推荐的更新步骤及其原因。</para>

      <para>所有成功的更新操作都必须解决以下这些问题：</para>

      <itemizedlist>
	<listitem>
        <para>旧编译器可能有 bug， 无法编译新内核。 因此，
            新内核应该用新编译器构建， 这意味着新内核在构建之前，
            新编译器必须先行构建， 但并不意味着在构建新内核之前，
            新编译器必须先 <emphasis>安装</emphasis> 。</para>
	</listitem>

	<listitem>
        <para>新 world 可能依赖新内核的某些功能。 因此，
            新 world 安装之前， 新内核必须先安装。</para>
	</listitem>
      </itemizedlist>

      <para>这两个问题就是为什么需要按照 <buildtarget>buildworld</buildtarget> 、
          <buildtarget>buildkernel</buildtarget> 、
          <buildtarget>installkernel</buildtarget> ，
          <buildtarget>installworld</buildtarget> 的顺序来更新的原因，
          除此之外还有：</para>

      <itemizedlist>
	<listitem>
        <para>新内核可能无法在旧 world 中正常运行，
            因此新 world 必须在新内核安装完成后尽快更新。</para>
	</listitem>

	<listitem>
        <para>一些配置文件需要在安装新 world 之前完成更新，
            一些配置文件的更新则会导致旧 world 不能正常工作。
            因此， 通常需要两次不同的配置文件更新步骤。</para>
	</listitem>

	<listitem>
        <para>多数情况下， 更新步骤只会替换或增加文件而不会删除现有的旧文件。
            某些时候这可能会导致其他问题。 因此，
            有时安装操作会指明必须在操作某些步骤前删除这些文件。
            未来， 这可能会实现自动化， 也可能无法实现。</para>
	</listitem>
      </itemizedlist>

      <para>由于这些问题的存在， 一般会建议以下更新步骤。
          请注意， 对于特定的更新步骤可能需要一些额外的步骤，
          但这些核心步骤应该会在很长一段时间保持不变的：</para>

      <orderedlist>
	<listitem>
	  <para><command>make
	      buildworld</command></para>

  <para>这个步骤首先会编译新编译器及相关必需工具， 然后使用新编译器来编译新 world 。
      编译成果会存放在 <filename>/usr/obj</filename> 目录。</para>
	</listitem>

	<listitem>
	  <para><command>make
	      buildkernel</command></para>

  <para>这个步骤将会使用 <filename>/usr/obj</filename> 中的
      <emphasis>新</emphasis> 编译器。 以防止编译器与新内核不匹配的问题。</para>
	</listitem>

	<listitem>
	  <para><command>make
	      installkernel</command></para>

  <para>将新内核和内核模块安装到磁盘， 以便系统能从新内核启动。</para>
	</listitem>

	<listitem>
        <para>重启进入单用户模式。</para>

        <para>单用户模式能尽量减少更新时正在运行的软件导致的问题。
            此外， 它也能使新内核配合旧 world 时尽量少出问题。</para>
	</listitem>

	<listitem>
	  <para><command>mergemaster
	      -p</command></para>

  <para>这个步骤会进行安装新 world 前所需的配置文件更新工作。
      例如， 它可能会添加新用户组或用户名的密码数据库到系统中。
      这通常是自上次更新后增加了新用户组或特殊系统用户之后才需要做的，
      因为 <buildtarget>installworld</buildtarget>
      会需要这些用户或用户组才能完成工作。</para>
	</listitem>

	<listitem>
	  <para><command>make
	      installworld</command></para>

  <para>从 <filename>/usr/obj</filename> 中拷贝 world 副本。 这个步骤之后，
      您的磁盘上的系统， 包括内核和 world 都将是新的了。</para>
	</listitem>

	<listitem>
	  <para><command>mergemaster</command></para>

	  <para>再次更新剩下的配置文件， 现在您磁盘的新 world 更新完成。</para>
	</listitem>

	<listitem>
	  <para><command>make
	      delete-old</command></para>

  <para>这个步骤目标将是删除旧的（过时的）文件。
      这点很重要， 因为有时它们会导致一些问题，
      例如， 旧 <filename>utmp.h</filename> 文件如果存在，
      在安装某些需要新的 <filename>utmpx.h</filename> 文件的 ports 就会出现问题。</para>
	</listitem>

	<listitem>
	  <para>重启。</para>

      <para>重启计算机， 现在将加载新内核， 新 world 和新配置文件。</para>
	</listitem>

	<listitem>
	  <para><command>make
	      delete-old-libs</command></para>

  <para>删除所有过时的库， 以避免与新库的发生冲突。
      确保所有的 ports 重建之前， 已删除旧库文件。</para>
	</listitem>
      </orderedlist>

      <para>注意， 如果您正从一个主要 &os; 发行版的分支升级， 例如， 从 9.0 升级到 9.1 ，
          则上述步骤可能就没那么必要了， 因为它不太可能遇到严重的编译器、 内核、
          用户空间程序和配置文件不匹配的情况不匹配的情况。
          旧的 <command>make world</command> 命令可能能完成编译， 并按照新内核，
          并有可能正常完成这种次要版本的升级工作。</para>

      <para>但是， 在大主版本升级时，
          不按前面所介绍的步骤进行升级则很有可能需要一些问题。</para>

      <para>值得一提的是， 很多升级过程可能需要额外的附加步骤，
          例如， 重命名或删除 installworld 之前的一些特定文件。
          仔细阅读 <filename>/usr/src/UPDATING</filename> 文件，
          特别是它结尾部分推荐的升级步骤。</para>

      <para>由于这个过程是不断演化的过程中，
          开发者可能会发现某些不能完全避免的不匹配方面的问题。 不过幸运的是，
          目前这个推荐升级步骤应该会在很长的时间内保持不变。</para>

      <para>总之， 目前推荐的从源代码升级 &os; 的步骤是：</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput>
&prompt.root; <userinput>make installkernel</userinput>
&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <note>
          <para>有时, 能需要额外执行一次 <command>mergemaster -p</command> 命令，
              才能完成 <buildtarget>buildworld</buildtarget> 步骤。
              这些特殊情况一般都会在 <filename>UPDATING</filename> 中做说明。
              一般情况下， 可以简单的跳过这一步，
              只要不是一个大跨度的 &os; 版本升级。</para>
      </note>

      <para>在 <buildtarget>installkernel</buildtarget> 完成后，
          需要重启进入单用户模式（loader 加载器提示符后输入
          <command>boot -s</command>）。</para>

	<para>如果使用 UFS 文件系统， 运行：</para>


      <screen>&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput></screen>

      <para>如果使用的是 ZFS 文件系统 （假设 zpool 存储池名为 zroot）， 则运行：</para>

      <screen>&prompt.root; <userinput>zfs set readonly=off zroot</userinput>
&prompt.root; <userinput>zfs mount -a</userinput></screen>

      <para>然后运行：</para>

       <screen>&prompt.root; <userinput>adjkerntz -i</userinput>
&prompt.root; <userinput>mergemaster -p</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput>
&prompt.root; <userinput>mergemaster</userinput>
&prompt.root; <userinput>make delete-old</userinput>
&prompt.root; <userinput>reboot</userinput>
&prompt.root; <userinput>make delete-old-libs</userinput></screen>

      <warning>
	<title>进一步说明：</title>

    <para>以上步骤只是升级步骤的简要说明， 所要清楚了解每一步，
        尤其是希望自定义内核配置， 就更应该阅读以下内容。</para>
      </warning>
    </sect2>

    <sect2 xml:id="src-updating">
      <title>阅读 <filename>/usr/src/UPDATING</filename></title>

      <para>在执行任何更新操作之前， 请务必阅读
          <filename>/usr/src/UPDATING</filename> 文件。
          这个文件包含了更新可能存在的潜在问题的重要信息，
          或可能指定了某些命令的执行顺序。
          如果 <filename>UPDATING</filename> 中出现的内容与本文相冲突，
          请按 <filename>UPDATING</filename> 中的内容执行。</para>

      <important>
          <para>阅读 <filename>UPDATING</filename> 并不能替代的订阅适当的邮件列表。
              它们并非相互排斥的， 而是相互相成的。</para>
      </important>
    </sect2>

    <sect2 xml:id="make-conf">
      <title>检查 <filename>/etc/make.conf</filename></title>

      <indexterm>
	<primary><filename>make.conf</filename></primary>
      </indexterm>

      <para>&man.make.1; 可用的参数可以在 &man.make.conf.5;
          和 <filename>/usr/share/examples/etc/make.conf</filename> 中找到。
          这些参数可以添加到 <filename>/etc/make.conf</filename> 文件中，
          以控制 &man.make.1; 的运行及其编译程序的方式。
          请注意， 默认参数照顾到了性能与安全性， 变更默认参数值可能会产生严重后果，
          但也可能会达到意想不到的效果。</para>

      <para><filename>/etc/make.conf</filename> 中的参数会影响到
          &man.make.1; 的每次执行， 包括 Ports Collection ，
          用户自己写的 C 语言程序以及重新编译 &os; 操作系统。</para>
    </sect2>

    <sect2 xml:id="src-conf">
      <title>检查 <filename>/etc/src.conf</filename></title>

      <indexterm>
	<primary><filename>src.conf</filename></primary>
      </indexterm>

      <para><filename>/etc/src.conf</filename> 文件控制从源代码构建操作系统的相关参数。
          与 <filename>/etc/make.conf</filename> 不同，
          <filename>/etc/src.conf</filename> 仅控制构建 &os; 操作系统本身。
          有关这个文件的更多信息， 请参考 &man.src.conf.5; 。 有时，
          禁用那些看起来很不是必要的内核模块或编译选项也能有意想不到的效果。</para>
    </sect2>

    <sect2 xml:id="updating-etc">
      <title>更新 <filename>/etc</filename> 里的文件</title>

      <para><filename>/etc</filename> 目录中包含了大部分系统配置文件及系统启动脚本，
          这些文件可能会因为 &os; 版本的不同而有所差别。</para>

      <para>一些配置文件日常运行时都要经常用到， 比如，
          <filename>/etc/group</filename> 文件。</para>

      <para>有时作为安装过程的一部分， <command>make installworld</command>
          会要求事先建立某些特定的用户或用户组， 在升级前它们可能并不存在，
          因此 <command>make buildworld</command> 会先检查它们是否已存在。</para>

      <para>解决的办法是在构建前 （pre-buildworld） 使用个带 <option>-p</option>
          参数运行 &man.mergemaster.8; 命令。
          它只会更新在 <buildtarget>buildworld</buildtarget> 和
          <buildtarget>installworld</buildtarget> 过程起关键性作用的文件。</para>

      <tip>
	<para>您可以这样检测哪些文件是被重命名或删除了的用户组所拥有的：</para>

	<screen>&prompt.root; <userinput>find / -group GID -print</userinput></screen>

    <para>该命令将会显示所有 <replaceable>GID</replaceable> 用户组所拥有的所有文件，
        这里的用户组名称可以是字母组名或数字 ID 。</para>
      </tip>
    </sect2>

    <sect2 xml:id="makeworld-singleuser">
      <title>切换到单用户模式</title>

      <indexterm><primary>single-user mode</primary></indexterm>

      <para>您可能会考虑在单用户模式下编译系统。 重新安装涉及很多重要的系统文件，
          包括所有基本系统的二进制文件、 库文件， 头文件等等。
          在正在运行中的系统（尤其是大量用户在线时）更新将是自寻烦恼的行为。</para>

      <indexterm><primary>multi-user mode</primary></indexterm>
      <para>另一种方法是在多用户模式编译系统， 然后切换到单用户模式进行安装。
          如果使用这种方法， 可以在编译完成后， 以下命令，
          这将会直接切换为单用户模式， 然后执行
          <buildtarget>installkernel</buildtarget> 或
          <buildtarget>installworld</buildtarget> 命令即可：</para>

      <para>从正在运行的系统进入单用户模式使用：</para>

      <screen>&prompt.root; <userinput>shutdown now</userinput></screen>

      <para>也可以重启系统， 然后在 boot 提示符下， 选择 <quote>single user</quote>
          选项。 单用户模式启动完毕后会得到一个 shell 提示符， 执行：</para>

      <screen>&prompt.root; <userinput>fsck -p</userinput>
&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

      <para>这将会检查文件系统， 重新以读/写方式挂载 <filename>/</filename> ，
          根据 <filename>/etc/fstab</filename> 里的记录挂载所有 UFS 文件系统，
          最后启用交换分区。</para>

      <note>
          <para>如果您的 CMOS 时钟设置的是本地时间而不是 GMT （就是 &man.date.1;
              命令不能报告正确的时间和地区）， 您可能还需要执行以下命令：</para>

	<screen>&prompt.root; <userinput>adjkerntz -i</userinput></screen>

    <para>这样就可以确保了本地时区设置正确了。</para>
      </note>
    </sect2>

    <sect2 xml:id="cleaning-usr-obj">
      <title>移除 <filename>/usr/obj</filename></title>

      <para>随着系统重新构建的进行， 编译结果默认会放到 <filename>/usr/obj</filename>
          中， 目录里的结构会对应 <filename>/usr/src</filename> 里的目录结构。</para>

      <para>为了加快 <command>make buildworld</command> 过程，
          并避免可能出现的依赖性问题， 如果这个目录已存在， 请删除它。</para>

      <para>在 <filename>/usr/obj</filename> 中的某些文件可能设置了不可更改标志，
          删除前必须先使用 &man.chflags.1; 取消这些标志。</para>

      <screen>&prompt.root; <userinput>cd /usr/obj</userinput>
&prompt.root; <userinput>chflags -R noschg *</userinput>
&prompt.root; <userinput>rm -rf *</userinput></screen>
    </sect2>

    <sect2 xml:id="updating-upgrading-compilebase">
      <title>重新编译基本系统</title>

      <sect3>
	<title>保存输出日志</title>

    <para>将 &man.make.1; 输出日志保存这将是一个好主意。 如果出现错误，
        可以将该错误消息的副本可以发送到 &os; 邮件列表。</para>

    <para>这样做最简单的方法是使用 &man.script.1; 命令，
        带上一个保存所有输出的文件名的参数即可。 这一方法应该在重新编译系统之前执行，
        编译完成后输入 <userinput>exit</userinput> 退出。</para>

	<screen>&prompt.root; <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out
&prompt.root; <userinput>make TARGET</userinput>
<emphasis>&hellip; compile, compile, compile &hellip;</emphasis>
&prompt.root; <userinput>exit</userinput>
Script done, &hellip;</screen>

    <para><emphasis>不要</emphasis> 将输出日志保存到 <filename>/tmp</filename> 目录，
        这个目录可能会在下次启动的时候被清空， 比较稳妥的是保存到
        <filename>/var/tmp</filename> 目录或
        <systemitem class="username">root</systemitem> 用户主目录中。</para>
      </sect3>

      <sect3 xml:id="make-buildworld">
	<title>编译基本系统</title>

	<para>进入 <filename>/usr/src</filename> 目录：</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>

	<indexterm><primary><command>make</command></primary></indexterm>

    <para>使用 &man.make.1; 重新编译 world ， 会从 <filename>Makefile</filename>
        （描述如何构建 &os; ，及其构建顺序的文件）中读取构建指令。</para>

	<para>命令一般如下格式：</para>

	<screen>&prompt.root; <userinput>make -x -DVARIABLE target</userinput></screen>

    <para>示例中， <option>-<replaceable>x</replaceable></option> 参数会传递给
        &man.make.1; 。 更多可用参数， 请参考 &man.make.1; 联机手册。</para>

    <para><option>-D<replaceable>变量值</replaceable></option> 会传递一个变量给
        <filename>Makefile</filename> 。 这些变量会控制
        <filename>Makefile</filename> 的行为。
        这与设置 <filename>/etc/make.conf</filename> 变量一样，
        只是提供了另一种设置方法。</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE target</userinput></screen>

    <para>如上指定不编译先定库 （profiled libraries） 则等同于在</para>

	<programlisting>NO_PROFILE=    true     #    Avoid compiling profiled libraries</programlisting>

	<para><filename>/etc/make.conf</filename> 里的设置。</para>

    <para><replaceable>target</replaceable> 告诉 &man.make.1; 该执行什么。
        每个 <filename>Makefile</filename> 都定义了许多不同的 <quote>targets</quote> ，
        然后由您决定使用哪个 target ， 并产生对应结果。</para>

    <para>在 <filename>Makefile</filename> 中列出的 targets ，并不是都需要使用，
        targets 的目的是将重新编译系统的过程分成几个子步骤。</para>

    <para>大多数情况下都没必要向 &man.make.1; 传递参数， 因此命令看起来像是这样：</para>

	<screen>&prompt.root; <userinput>make target</userinput></screen>

    <para>这里的 <replaceable>target</replaceable> 是众多编译选项中的一个。
        一般情况下， 第一个 target 都应该是 <varname>buildworld</varname> 。</para>

    <para>正如名字所暗示的， <buildtarget>buildworld</buildtarget> 就是在
        <filename>/usr/obj</filename> 下构建一个全新的系统， 然后使用
        <buildtarget>installworld</buildtarget> 将新系统安装到计算机上。</para>

    <para>使用独立的选项有两个优点。 首先， 它允许您 <quote>独立</quote> 的构建系统，
        而不会影响系统的任何一个部件， 正因如此，
        <buildtarget>buildworld</buildtarget> 可以大胆的在多用户模式下的计算机上执行，
        而不用担心用不良影响， 不过依旧推荐您在单用户模式执行
        <buildtarget>installworld</buildtarget> 命令。</para>

    <para>其次， 它允许您使用 NFS 升级网络上的多台计算机。 如果您有
        <systemitem>A</systemitem> ， <systemitem>B</systemitem> 和
        <systemitem>C</systemitem> 三台计算机需要升级， 那么您可以在
        <systemitem>A</systemitem> 计算机执行 <command>make buildworld</command> 和
        <command>make installworld</command> 命令。
        <systemitem>B</systemitem> 和 <systemitem>C</systemitem> 计算机通过 NFS 方式
        挂载 <systemitem>A</systemitem> 计算机上的 <filename>/usr/src</filename> 和
        <filename>/usr/obj</filename> 目录。
        运行 <command>make installworld</command> 命令， 将编译成果安装到
        <systemitem>B</systemitem> 和 <systemitem>C</systemitem> 计算机上。</para>

    <para>尽管 <buildtarget>world</buildtarget> target 依旧存在，
        强烈建议您不要再使用它。</para>

	<para>相反的， 推荐使用：</para>

	<screen>&prompt.root; <userinput>make buildworld</userinput></screen>

    <para>我们可以指定 <option>-j</option> 参数， 强制 <command>make</command>
        启动多个并发进程。 对于有多个 CPU 的计算机而言， 这样有助于发挥计算机性能。
        不过多数情况下， 编译过程的主要瓶颈在 I/O 上，而不是不是 CPU ，
        但它依旧对单个 CPU 的计算机有好处。</para>

	<para>在常见的单 CPU 的计算机上， 使用：</para>

	<screen>&prompt.root; <userinput>make -j4 buildworld</userinput></screen>

    <para>这样 &man.make.1; 就能同时启动运行 4 个进程。
        根据邮件列表中的统计测试报告， 这样做通常能提供最佳的性能。</para>

    <para>如果您的计算机配置了多颗 CPU ， 并使用 SMP 内核，
        也可以试试 6 到10 的数值， 看看它们是如何高速完成编译的。</para>
      </sect3>

      <sect3>
	<title>耗时</title>

	<indexterm>
	  <primary>rebuilding <quote>world</quote></primary>
	  <secondary>timings</secondary>
	</indexterm>

    <para>有许多因素会影响的编译时间， 不过，
        较新的计算机一般都能在一两个小时内完成从源代码构建 &os.stable; ，
        而不需要使用任何技巧或走捷径。 对于 &os.current; ，
        则通常需要更长一点的时间。</para>
      </sect3>
    </sect2>

    <sect2 xml:id="new-kernel">
      <title>编译和安装新内核</title>

      <indexterm>
	<primary>kernel</primary>
	<secondary>compiling</secondary>
      </indexterm>

      <para>要充分利用新系统， 您应该重新编译内核。 这是很有必然的，
          因为特定的内存结构已经发生了改变， 像 &man.ps.1; 和 &man.top.1;
          这样的程序可能无法正常工作， 除非内核与源代码树的版本是一样的。</para>

      <para>要做到这一点最简单， 最安全的方式是构建和安装一个基于
          <filename>GENERIC</filename> 配置文件的内核。 虽然
          <filename>GENERIC</filename> 可能没有包含所有系统所需的设备驱动，
          但它包含启动到系统启动到单用户模式所需的所有内容。
          这是一个很好的测试新系统是否正常工作的方法。
          从 <filename>GENERIC</filename> 启动， 校验完系统后，
          就可以建立您自己的自定义内核了。</para>

      <para>在 &os; 上， 在构建新内核前完成
          <link linkend="make-buildworld">build world</link> 是非常重要的。</para>

      <note>
          <para>如果您想构建一个自定义内核， 并且这个配置文件已经创建完成，
              只需要指定内核名称 <literal>KERNCONF=MYKERNEL</literal> ：</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildkernel KERNCONF=MYKERNEL</userinput>
&prompt.root; <userinput>make installkernel KERNCONF=MYKERNEL</userinput></screen>

      </note>

      <para>如果您已把 <varname>kern.securelevel</varname> 
          调高到 1 或 <emphasis>以上</emphasis> ， 而且还设置了
          <literal>noschg</literal> 或相似标志到您的二进制内核上，
          你可能会发现需要切换到单用户模式执行
          <buildtarget>installkernel</buildtarget> 。
          否则， 这两个命令在多用户模式下执行应该也不会有问题。 请参阅
          &man.init.8; 以了解更多关于 <varname>kern.securelevel</varname> 的信息；
          参阅 &man.chflags.1; 了解更多不同文件标志的信息。</para>
    </sect2>

    <sect2 xml:id="new-kernel-singleuser">
      <title>重启到单用户模式</title>

      <indexterm><primary>single-user mode</primary></indexterm>

      <para>您应该使用单用户模式测试新内核，
          根据 <xref linkend="makeworld-singleuser"/> 中的说明去操作。</para>
    </sect2>

    <sect2 xml:id="make-installworld">
      <title>安装编译好的新系统</title>

      <para>接下来， 我们使用 <buildtarget>installworld</buildtarget>
          来安装新系统二进制文件：</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput></screen>

      <note>
          <para>在 <command>make buildworld</command> 时跟随的编译参数，
              在 <command>make installworld</command> 时也必须跟随，
              当然除 <option>-j</option> 参数外，
              它不能用在 <buildtarget>installworld</buildtarget> 上。</para>

	<para>就像这样时：</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE buildworld</userinput></screen>

	<para>安装时您也必须这样：</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE installworld</userinput></screen>

    <para>否则，该命令将试图安装在 <command>make buildworld</command>
        阶段没有建立的先定库。</para>
      </note>
    </sect2>

    <sect2 xml:id="post-installworld-updates">
      <title>更新不由 <command>make installworld</command> 负责更新的文件</title>

      <para>重构的 world 将不会更新下某些目录， 如 <filename>/etc</filename> ，
          <filename>/var</filename> 和 <filename>/usr</filename>
          目录下的新的或有变更的文件。</para>

      <para>更新这些目录中的文件的最简单的方法是使用在 &man.mergemaster.8; 。
          为了避免出错， 请务必先备份 <filename>/etc</filename> 目录。</para>

      <sect3 xml:id="mergemaster">
	<info><title><command>mergemaster</command></title>
	  <authorgroup>
	    <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>贡献者： </contrib></author>
	  </authorgroup>
	</info>
	

	<indexterm>
	  <primary>
	    <command>mergemaster</command>
	  </primary>
	</indexterm>

    <para>&man.mergemaster.8; 工具是一个 Bourne 脚本，
        用于检测 <filename>/etc</filename> 和源代码中的
        <filename>/usr/src/etc</filename> 中的配置文件的差异。
        这是保持系统中配置文件与源代码保持同步的一种首选方式。</para>

    <para>首先， <command>mergemaster</command> 会建立一个临时的根环境，
        在 <filename>/</filename> 下， 放置各种系统配置文件。 然后，
        这些文件会和系统中已按照的文件做对比， 并使用 &man.diff.1; 格式显示出来，
        使用 <option>+</option> 表示添加或修改的行， 使用 <option>-</option>
        表示完全删除或被替换成了新行。
        查阅 &man.diff.1; 联机手册以了解更多有关 &man.diff.1;
        的语法和文件不同点是怎么显示的。</para>

    <para>&man.mergemaster.8; 会给您显示每个文件的不同处，
        这样您就可以选择是删除新文件 (相对临时文件)， 是以未改状态安装临时文件，
        是以当前安装的文件合并临时文件， 还是再看一次 &man.diff.1; 结果。</para>

    <para>选择删除临时文件将让 &man.mergemaster.8; 保留当前文件， 并删除新版本文件。
        不建议使用这个选项， 除非您有不变更当前文件的理由。 任何时候，
        当需要帮助时， 可以在 &man.mergemaster.8; 提示符里输入 <keycap>?</keycap> ，
        您将得到帮助。 如果选择跳过这个文件， 将会在其他文件处理完后进行。</para>

    <para>选择使用未修改临时文件将会使用新文件替换当前文件。
        对于大多数未修改的文件， 这是最好的选择。</para>

    <para>选择合并文件将会打开一个文本编辑器， 里面是两个文件的内容。
        文件将并排在出现在屏幕上， 从它们中间选择需要部分合并为最终文件。
        当两个文件比较时， 使用 <keycap>l</keycap> 键选择左边内容，
        使用 <keycap>r</keycap> 键选择右边内容， 最终文件就是这两部分文件组成的，
        然后就可以用它安装。 这个选项通常用于用户修改过的配置文件。</para>

    <para>选择再次查看 &man.diff.1; 结果将再次显示文件差异，
        就像 &man.mergemaster.8; 之前提示的一样。</para>

    <para>最后， 在 &man.mergemaster.8; 完成系统文件处理后， 它还会提示其他问题。
        重建密码文件， 并在最后提示您是否删除余下的临时文件。</para>
        
      </sect3>

      <sect3>
	<title>手动更新</title>

    <para>如果希望手动执行更新， 请不要直接将 <filename>/usr/src/etc</filename>
        下的文件覆盖到 <filename>/etc</filename> 下， 因为有些文件是需要
        <quote>安装</quote> 后才能工作的。 事实上， 并 <emphasis>不是</emphasis>
        简单的把 <filename>/usr/src/etc</filename> 拷贝到 <filename>/etc</filename> ，
        有些文件 <filename>/etc</filename> 中有， <filename>/usr/src/etc</filename>
        却并不存在的。</para>

    <para>如果您使用的是 &man.mergemaster.8; （推荐）， 您可以直接跳到
        <link linkend="updating-upgrading-rebooting">下一节</link> 。</para>

    <para>手工合并文件最简单的方法是将文件安装到一个新目录，
        然后寻找它们的不同之处。</para>

	<warning>
	  <title>备份您现有的 <filename>/etc</filename></title>

      <para>建议先复制现有的 <filename>/etc</filename> 到安全的地方， 就像这样：</para>

	  <screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

      <para>其中 <option>-R</option> 参数会递归复制所有文件，
          <option>-p</option> 参数会保留文件时间和属主等等。</para>
	</warning>

    <para>创建一个临时目录将新的 <filename>/etc</filename>
        文件和相关文件安装到里面：</para>

	<screen>&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>

    <para>这将建立必要的目录结构并安装文件。
        在 <filename>/var/tmp/root</filename> 目录中， 会有很多子目录是空的，
        要删除它们最简单的方法是：</para>

	<screen>&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d . -type d | xargs rmdir 2&gt;/dev/null</userinput></screen>

    <para>这样将会删除所有空目录， 同时将有关非空目录的警告信息重定向到
        <filename>/dev/null</filename> 设备。</para>

    <para><filename>/var/tmp/root</filename> 现在包含了应放在
        <filename>/</filename> 某个位置的文件。 通过这些文件，
        比对系统中已存的文件有何差异。</para>

    <para><filename>/var/tmp/root</filename> 目录下有些 <quote>.</quote> 开头的文件，
        可能需要 <command>ls -a</command> 才能看得到它们。</para>

    <para>比较文件的最简单的方法是使用 &man.diff.1; ：</para>

	<screen>&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>

    <para>这个命令将会显示现有的 <filename>/etc/shells</filename> 和
        新 <filename>/var/tmp/root/etc/shells</filename> 文件的差异。
        这个差异决定了您是合并还是直接替换就旧文件。</para>

	<tip>
        <title>使用时间戳命名根目录 （ <filename>/var/tmp/root</filename> ），
            这样您可以轻松比较两个版本的不同：</title>

        <para>频繁重建系统意味着必须频繁更新 <filename>/etc</filename> ，
            而这可能会有些烦。</para>

        <para>为了加快这一进程， 可以使用以下过程来保留最后一套被合并的
            <filename>/etc</filename> 文件的副本。</para>

	  <procedure>
	    <step>
            <para>像通常那样建立 world 。当更新 <filename>/etc</filename>
                及其相关目录时，
                可以在目标目录基础上加一个当前日期到名称里：</para>

	      <screen>&prompt.root; <userinput>mkdir /var/tmp/root-20130214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-20130214 \
    distrib-dirs distribution</userinput></screen>
	    </step>

	    <step>
            <para>在这个目录的基础上进行合并工作， 当合并完成时，
                请 <emphasis>不要</emphasis> 删除这个目录。</para>
	    </step>

	    <step>
            <para>下载源代码的最新版本和修改后， 按照第一步，
                创建一个反映新日期的目录， 例如使用
                <filename>/var/tmp/root-20130221</filename> 。</para>
	    </step>

	    <step>
            <para>使用 &man.diff.1; 查看这段相隔的时间里两个目录之间的递归差异：</para>

	      <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-20130214 root-20130221</userinput></screen>

          <para>通常， 这组差异比起 <filename>/var/tmp/root-20130221/etc</filename>
              与 <filename>/etc</filename> 之间的差异要明显小很多，
              也就更容易把这些变更合并到 <filename>/etc</filename> 中去。</para>
	    </step>

	    <step>
            <para>完成后， 就可以删除较早的 <filename>/var/tmp/root-*</filename>
                目录：</para>

	      <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-20130214</userinput></screen>
	    </step>

	    <step>
            <para>每次需要合并 <filename>/etc</filename> ，
                都重复这个流程就可以了。</para>
	    </step>
	  </procedure>

	  <para>使用 &man.date.1; 自动生成目录名称：</para>

	  <screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
	</tip>
      </sect3>
    </sect2>

    <sect2 xml:id="make-delete-old">
      <info><title>删除过时的文件和目录</title>
	<authorgroup>
	  <author><personname><firstname>Anton</firstname><surname>Shterenlikht</surname></personname><contrib>Based on notes provided by </contrib></author>
	</authorgroup>
      </info>
      

      <indexterm>
	<primary>Deleting obsolete files and directories</primary>
      </indexterm>

      <para>由于 &os; 的开发周期里， 偶尔会有些文件或内容会过时的情况。
          这可能因为这个功能在其他地方实现， 或库版本号变更，
          也可能是完全从系统中移除等等。 在更新系统时， 包括旧文件，
          旧库文件， 旧目录， 它们都应该被从系统中移除，
          这是有好处的， 这样可以保证系统稳定，
          同时减少了不必要的磁盘空间及备份空间的浪费， 另外，
          如果旧库或文件存在安全或稳定性问题， 系统更新它们可以保证安全，
          同时防止因旧库导致的崩溃。
          过时的文件， 目录， 库文件都会在
          <filename>/usr/src/ObsoleteFiles.inc</filename> 中列出。
          接下来， 将介绍如何删除这些文件。</para>

      <para>在 <command>make installworld</command> 和
          <command>mergemaster</command> 命令完成后，
          可以使用以下命令检测过时的文件和库文件：</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make check-old</userinput></screen>

      <para>如果检测到任何过时的文件， 则可以使用以下的命令移除：</para>

      <screen>&prompt.root; <userinput>make delete-old</userinput></screen>

      <tip>
          <para>参阅 <filename>/usr/src/Makefile</filename> 可以了解更多其他
              targets 的功能。</para>
      </tip>

      <para>当删除每一个文件之前都会出现一个确认提示。
          要跳过提示， 让系统自动删除这些文件，
          可以设置 <varname>BATCH_DELETE_OLD_FILES</varname> 变量， 就像这样：</para>

      <screen>&prompt.root; <userinput>make -DBATCH_DELETE_OLD_FILES delete-old</userinput></screen>

      <para>也可以使用 <command>yes</command> 命令配合管道实现类似目的：</para>

      <screen>&prompt.root; <userinput>yes|make delete-old</userinput></screen>
    </sect2>

    <sect2 xml:id="updating-upgrading-rebooting">
      <title>重启</title>

      <para>确认一切都已正确完成后， 就可以使用 &man.shutdown.8; 重启系统了：</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>
    </sect2>

    <sect2 xml:id="make-delete-old-libs">
      <title>删除过时的库文件</title>

      <warning>
	<title>警告</title>

    <para>删除过时的文件可能会破坏现有的依赖于这些过时的文件的应用程序。
        尤其对于删除旧库文件这种情况， 多数情况下，
        在重新编译所有依赖旧库的 ports 程序之后，
        <command>make delete-old-libs</command> 删除那些过时的文件。</para>
      </warning>

      <para>通用检测共享库依赖的工具 <package>sysutils/libchk</package> 和
          <package>sysutils/bsdadminscripts</package> 可以通过
          Ports Collection 安装。</para>

      <para>过时的共享库与新共享库可能发生冲突， 会导致类似的警告消息：</para>

      <screen>/usr/bin/ld: warning: libz.so.4, needed by /usr/local/lib/libtiff.so, may conflict with libz.so.5
/usr/bin/ld: warning: librpcsvc.so.4, needed by /usr/local/lib/libXext.so, may conflict with librpcsvc.so.5</screen>

      <para>为了解决这类问题， 需要确定是哪个 port 安装了这个库文件：</para>

      <screen>&prompt.root; <userinput>pkg_info -W  /usr/local/lib/libtiff.so</userinput>
  /usr/local/lib/libtiff.so was installed by package tiff-3.9.4
  &prompt.root; <userinput>pkg_info -W /usr/local/lib/libXext.so</userinput>
  /usr/local/lib/libXext.so was installed by package libXext-1.1.1,1</screen>

      <para>然后卸载， 重新编译和安装的该 port 。
          可以使用 <package>ports-mgmt/portmaster</package> 工具自动化完成此过程。
          在确认所有 ports 都已经重建， 并不再有需要依赖旧库的情况后，
          执行以下命令删除它们：</para>

      <screen>&prompt.root; <userinput>make delete-old-libs</userinput></screen>

      <para>你现在应该已经成功升级了 &os; 。 恭喜。</para>

      <para>如果进展不顺利， 很容易重建系统的某一部分。
          例如， 在升级或合并 <filename>/etc</filename> 时不小心删除了
          <filename>/etc/magic</filename> ， 这将会导致 &man.file.1; 停止工作，
          这种情况下， 可以执行以下命令进行修复：</para>

      <screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2 xml:id="updating-questions">
      <title>提问</title>

      <qandaset>
	<qandaentry>
	  <question>
          <para>是否每个变更都需要重新编译 world ？</para>
	  </question>

	  <answer>
          <para>这不好说， 主要看是什么性质的变更。 比如： 如果
              <application>svn</application> 更新了以下文件：</para>

	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

        <para>这样就没必要重建 整个 world 。
            只需要进入相应的子目录， 运行 <command>make all install</command> 就可以了。
            但是， 如果是重大变更， 如 <filename>src/lib/libc/stdlib</filename> 发生变更，
            那么则需要重建 world ， 或至少编译静态链接的那部分。</para>

        <para>每天天结束的时候， 你就可以开始编译。
            也有些用户会让变更累积两个星期后再重新编译 world 。
            您也可以只重新编译变更过的部分， 不过那样你得确认能找出所有依赖关系。</para>

        <para>这取决与您希望什么样的升级频率，
            以及是否是跟踪 &os.stable; 或 &os.current; 。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>我的编译出错了， 并报告 11 <indexterm>
		<primary>signal 11</primary>
	      </indexterm>
	      （或其它的数字信息）的错误号。 这是什么情况？</para>
	  </question>

	  <answer>
          <para>这通常表明硬件出错。 （重新）构建 world 是高压测试硬件的有效方式，
              常常表现为编译器由于内存错误莫名其妙的终止了。</para>

          <para>一个确信的指示器是如果重新开始 <application>make</application> ，
              并且整个过程中会死在不同的点上。</para>

	    <para>对于这种情况， 可以更换机器的某个部件， 检测是哪一部分硬件出问题了。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
          <para>完成后可以删除 <filename>/usr/obj</filename> 吗？</para>
	  </question>

	  <answer>
	    <para>简单的说， 可以。</para>

        <para>在 <filename>/usr/obj</filename> 中包含了所有在编译阶段生成的目标文件。
            通常情况下， <command>make buildworld</command>
            过程的第一步就是删除这个目录重新开始。 在您完成后，
            保留 <filename>/usr/obj</filename> 没多大意义，
            删除它还可以释放大约 2&nbsp;GB 磁盘空间。</para>

        <para>高级用户可以指定 <command>make buildworld</command> 跳过这一步，
            这可以让后续的构建过程更快写， 因为大部分源代码不再需要重新编译。
            这样可能也可能引起一些由于敏感依赖问题编译失败。
            在 &os; 常常会有人抱怨他们编译失败了，
            但他们往往没想到是自己想偷懒导致的。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>构建过程中断可以恢复吗？</para>
	  </question>

	  <answer>
          <para>这取决于您在出问题前整个过程进行到哪一步了。</para>

          <para>一般来说， <command>make buildworld</command> 会构建必备工具的新副本
              （如： &man.gcc.1; ， &man.make.1; 和系统库）。
              并在随后使用这些工具再重新编译自己， 然后再开始编译整个系统
              （包括 &man.ls.1; 和 &man.grep.1;
              这些用户层程序也会随系统被重新构建）。</para>

          <para>如果您已经处于最后一个阶段， 则可以相当安全使用：</para>

	    <screen><emphasis>&hellip; fix the problem &hellip;</emphasis>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNO_CLEAN all</userinput></screen>

        <para>这样就不会取消先前的 <command>make buildworld</command> 工作。</para>

	    <para>如果您看到这样的消息：</para>

	    <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

        <para>如果 <command>make buildworld</command> 输出这样的消息，
            则应该不会出什么问题。</para>

        <para>如果没有显示这条消息， 或者你不能确定，
            则重新开始构建要比继续构建而导致失败的好。</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>我怎样才能加速构建 world ？</para>
	  </question>

	  <answer>
	    <itemizedlist>
	      <listitem>
		<para>在单用户模式下运行。</para>
	      </listitem>

	      <listitem>
              <para>把 <filename>/usr/src</filename> 和 <filename>/usr/obj</filename>
                  目录到放到独立的文件系统上。 如何可能，
                  将他们放在独立的磁盘控制器上会更好。</para>
	      </listitem>

	      <listitem>
              <para>另外， 可以通过 &man.ccd.4; 将这些文件系统放置在多个磁盘上。</para>
	      </listitem>

	      <listitem>
              <para>通过 <filename>/etc/make.conf</filename> 里添加
                  <quote>NO_PROFILE=true</quote> 来关闭编译性能分析。</para>
	      </listitem>

	      <listitem>
              <para>传递 <option>-j<replaceable>n</replaceable></option> 参数给
                  &man.make.1; ， 强制其并行多个进程，
                  这样有助于发挥您的单或多处理器计算机的性能。</para>
	      </listitem>

	      <listitem>
              <para>存放 <filename>/usr/src</filename> 目录的文件系统使用
                  <option>noatime</option> 选项挂载。
                  这样可以防止文件系统记录不必要的访问时间而导致的性能损失。</para>

		<screen>&prompt.root; <userinput>mount -u -o noatime /usr/src</userinput></screen>

		<warning>
            <para>示例中， 假定 <filename>/usr/src</filename> 在独立的文件系统上，
                如果它是 <filename>/usr</filename> 的一部分，
                则需要使用该挂载点来代替。</para>
		</warning>
	      </listitem>

	      <listitem>
              <para>存放 <filename>/usr/obj</filename> 文件系统可以使用
                  <option>async</option> 选项挂载。 这样会启用磁盘的异步写入，
                  也就是在数据并不会被立即写入磁盘， 而是延迟几秒后写入磁盘，
                  这能显著提升性能。</para>

		<warning>
            <para>切记， 此选项会使文件系统变得更加脆弱。 使用这个选项，
                会增加突然电源故障或异常重启导致文件系统损坏的机率。</para>

            <para>如果 <filename>/usr/obj</filename> 是这个文件系统上的唯一目录，
                这没有任何问题的。 如果你在文件系统还有其他有价值的数据，
                则请备份后启用这个选项。</para>
		</warning>

		<screen>&prompt.root; <userinput>mount -u -o async /usr/obj</userinput></screen>

		<warning>
            <para>如果 <filename>/usr/obj</filename> 不是独立的文件系统，
                请用合适的挂载点取代例子中的挂载点。</para>
		</warning>
	      </listitem>
	    </itemizedlist>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>如果出错， 我该怎么办？</para>
	  </question>

	  <answer>
	    <para>请确保系统没有先前构建任何残留：</para>

	    <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root; <userinput>rm -rf /usr/obj/usr</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

        <para>是的， <command>make cleandir</command> 确实要运行两次。</para>

        <para>然后， 使用 <command>make buildworld</command> 重新开始整个过程。</para>

        <para>如果问题仍然存在， 请发送错误信息和 <command>uname -a</command>
            信息到 &a.questions; 。 并准备回答有关您的设置的相关问题。</para>
	  </answer>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 xml:id="small-lan">
    <info><title>跟踪多台计算机</title>
      <authorgroup>
	<author><personname><firstname>Mike</firstname><surname>Meyer</surname></personname><contrib>贡献者 </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>NFS</primary>
      <secondary>installing multiple machines</secondary>
    </indexterm>

    <para>当您有多台计算机需要跟踪同一份源代码树， 如果让它们各自都建立一份副本，
        那么将会是一个及其浪费的磁盘空间， 网络带宽和 CPU 资源的行为。
        我们可以使用其中一台计算机来完成绝大部分这些工作，
        然后其他计算机通过 NFS 方式连接到这台计算机来完成剩下的工作。
        本章将简述几种使用这种方式工作的方法。</para>

    <sect2 xml:id="small-lan-preliminaries">
      <title>前期准备</title>

      <para>首先， 我们需要选定一批将运行相同的二进制代码的计算机，
          这里我们称它们为 <emphasis>编译客户机 （build set）</emphasis> 。
          它们可以运行着各自的自定义内核， 但是他们的用户层必须运行着同一套二进制程序
          （译者注： 运行相同版本的 world ）。
          然后， 在这批计算机中选择一台计算机用于构建系统与内核的计算机，
          这里我们它为 <emphasis>编译主机 （build machine）</emphasis> 。
          理想情况下， 它应该是一台有足够空闲 CPU 资源来执行
          <command>make buildworld</command> 和 <command>make buildkernel</command>
          指令的计算机。 接着，
          您还需要选择一台用于对即将投入生产的应用做测试工作的计算机，
          这里我们称它为 <emphasis>测试主机（test machine）</emphasis> 。
          它 <emphasis>必须</emphasis> 是一台日常常用的计算机， 它可以由编译主机担当，
          也可以专门选择一台。</para>

      <para>这里， 所有编译客户机都需要从同一台计算机上挂载
          <filename>/usr/obj</filename> 和 <filename>/usr/src</filename> 。
          理想情况下， 这些目录应该位于编译主机上的两个不同的磁盘驱动器上，
          编译主机也是可以通过 NFS 实现将这两个目录分布到两个磁盘驱动器上。
          如果您有多个编译客户机， 那么 <filename>/usr/src</filename>
          应该保存在编译主机上， 其他计算机通过 NFS 共享这个目录。</para>

      <para>最后， 需要保证所有编译客户机使用与编译主机相同的
          <filename>/etc/make.conf</filename> 和 <filename>/etc/src.conf</filename> 文件。
          这是因为， 编译主机构建的基本系统将会应用于所有编译客户机。
          此外， 编译主机还应在 <filename>/etc/make.conf</filename> 中设置
          <varname>KERNCONF</varname> 参数， 并在里面列出所有编译客户机的
          <varname>KERNCONF</varname> ， 同时将自己的内核配置文件列在最前面。
          如果希望构建所有编译客户机的内核， 则
          <filename>/usr/src/sys/arch/conf</filename>
          中必须包含所有编译客户机的内核配置文件。</para>
    </sect2>

    <sect2 xml:id="small-lan-base-system">
      <title>基本系统</title>

      <para>在编译主机根据 <xref linkend="make-buildworld"/>
          中的内容构建完内核和 world （但不安装）。 就可以进入测试主机安装刚构建的内核，
          如果您是通过 NFS 挂载 <filename>/usr/src</filename> 和
          <filename>/usr/obj</filename> 的情况， 则需要进入单用户模式后启动网络，
          然后挂载它。 最简单的方法是在多用户模式下执行
          <command>shutdown now</command> 命令， 直接切换到单用户模式，
          一旦完成， 就可以像通常情况那样运行安装内核， world 和
          <command>mergemaster</command> 命令了。 全部完成后，
          就重启进入正常的多用户模式了。</para>

      <para>确认一切在测试主机上都能正常工作后，
          就可以相同方式在所有编译客户机上安装新软件。</para>
    </sect2>

    <sect2 xml:id="small-lan-ports">
      <title>Ports</title>

      <para>类似， 这种想法也可用于 ports 树。
          首先关键步骤是在所有编译客户机上从同一台计算机上挂载
          <filename>/usr/ports</filename> 目录。
          然后在 <filename>/etc/make.conf</filename> 文件中设置合适的参数来共享
          distfiles 。 您还应该将 <varname>DISTDIR</varname> 安置到一个共享目录里，
          这样就可以通过 NFS 让所有 <systemitem class="username">root</systemitem>
          用户都能写入数据。 为每台计算机设置一个本地目录为
          <varname>WRKDIRPREFIX</varname> 变量。 如果需要构建并发布预编译二进制包，
          则还应该设置 <varname>PACKAGES</varname> 变量， 设置方法与
          <varname>DISTDIR</varname> 类似。</para>
    </sect2>
  </sect1>
</chapter>
